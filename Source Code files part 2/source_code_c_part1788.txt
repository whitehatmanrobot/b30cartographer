PCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_qwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringW(ach, TF_ATL);
        lstrcatW(ach, L"(ATL) ");
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);
        wvsprintfW(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringW(ach);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellFuncMsgW(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_qwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
*/
void
CDECL
CcshellDebugMsgA(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceA(LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_qwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringA(ach, TF_ATL);
        lstrcatA(ach, "(ATL) ");
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
*/
void
CDECL
CcshellFuncMsgA(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_qwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if hrTest is a failure code.
*/
HRESULT 
TraceHR(
    HRESULT hrTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING &&
        FAILED(hrTest))
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "THR: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, hrTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return hrTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if bTest is false.
*/
BOOL 
TraceBool(
    BOOL bTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && !bTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TBOOL: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!
        }
    }
    return bTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if iTest is -1.
*/
int 
TraceInt(
    int iTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && -1 == iTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TINT: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!
        }
    }
    return iTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if pvTest is NULL.
*/
LPVOID 
TracePtr(
    LPVOID pvTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && NULL == pvTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TPTR: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!
        }
    }
    return pvTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if dwTest is a Win32 failure code.
*/
DWORD  
TraceWin32(
    DWORD dwTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING &&
        ERROR_SUCCESS != dwTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TW32: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, dwTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return dwTest;
}



//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif

/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_qwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    ULONGLONG val;

    //  (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_qwTraceFlags = val;
#ifdef FULL_DEBUG
    else
        g_qwTraceFlags = 3; // default to TF_ERROR and TF_WARNING trace messages
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#16I64x.",
             c_szIniKeyTraceFlags, g_qwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwBreakFlags = 5; // default to break on ASSERT and TF_ERROR
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    // Are we using the new leak detection from shelldbg.dll?
    GetPrivateProfileStringA("ShellDbg",
                            "NewLeakDetection",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_bUseNewLeakDetection = BOOLIFY(val);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "DebugOutputFile",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);
    if (szRHS[0] != TEXT('\0'))
    {
        g_hDebugOutputFile = CreateFileA(szRHS, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    return TRUE;
    }

// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *pfnGSMS) (IShellMallocSpy **ppout);

STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, SIZE_T cb)
{
    static BOOL bDontTry=FALSE;
    static IShellMallocSpy *pms=NULL;

    if (!bDontTry && pms == NULL)
    {
        pfnGSMS pfnGetShellMallocSpy;
        HMODULE hmod;

        bDontTry = TRUE; // assume failure
        if (hmod = LoadLibraryA("ALLOCSPY.DLL"))
        {
            pfnGetShellMallocSpy = (pfnGSMS) GetProcAddress(hmod, "GetShellMallocSpy");

            pfnGetShellMallocSpy(&pms);
        }
    }
    if (bDontTry)
        return;

    if (bAdd)
        pms->lpVtbl->AddToList(pms, pv, cb);
    else
        pms->lpVtbl->RemoveFromList(pms, pv);
}


#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    LONGLONG val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF 


#ifdef DEBUG

// turn on path whacking for full-debug builds
#ifdef FULL_DEBUG
static BOOL g_fWhackPathBuffers = TRUE;
#else
static BOOL g_fWhackPathBuffers = FALSE;
#endif

void DEBUGWhackPathBufferA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch))
        {
            FillMemory(psz, cch * sizeof(char), 0xFE);
        }
    }
}

void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch))
        {
            FillMemory(psz, cch * sizeof(WCHAR), 0xFE);
        }
    }
}

void DEBUGWhackPathStringA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch) && IS_VALID_STRING_PTRA(psz, -1))
        {
            UINT len = lstrlenA(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringA: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(char), 0xFE);
            }
        }
    }
}

void DEBUGWhackPathStringW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch) && IS_VALID_STRING_PTRW(psz, -1))
        {
            UINT len = lstrlenW(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringW: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(WCHAR), 0xFE);
            }
        }
    }
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\dka.cpp ===
#include "stock.h"
#pragma hdrstop

#include <shellp.h>
#include <dpa.h>

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

//===========================================================================
// DCA stuff - Dynamic CLSID array
// 
//  This is a dynamic array of CLSIDs that you can obtain from 
//  a registry key or add individually.  Use DCA_CreateInstance
//  to actually CoCreateInstance the element.
//
//===========================================================================


#ifdef DECLARE_ONCE

HDCA DCA_Create()
{
    HDSA hdsa = DSA_Create(sizeof(CLSID), 4);
    return (HDCA)hdsa;
}

void DCA_Destroy(HDCA hdca)
{
    DSA_Destroy((HDSA)hdca);
}

int  DCA_GetItemCount(HDCA hdca)
{
    ASSERT(hdca);
    
    return DSA_GetItemCount((HDSA)hdca);
}

const CLSID * DCA_GetItem(HDCA hdca, int i)
{
    ASSERT(hdca);
    
    return (const CLSID *)DSA_GetItemPtr((HDSA)hdca, i);
}


BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid)
{
    ASSERT(hdca);
    
    int ccls = DCA_GetItemCount(hdca);
    int icls;
    for (icls = 0; icls < ccls; icls++)
    {
        if (IsEqualGUID(rclsid, *DCA_GetItem(hdca,icls))) 
            return FALSE;
    }

    DSA_AppendItem((HDSA)hdca, (LPVOID) &rclsid);
    return TRUE;
}


HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    return pclsid ? SHCoCreateInstance(NULL, pclsid, NULL, riid, ppv) : E_INVALIDARG;
}

// _KeyIsRestricted           (davepl 4-20-99)
//
// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)
//                       
BOOL _KeyIsRestricted(HKEY hkey)
{
    DWORD dwidRest;
    DWORD cbdwidRest = sizeof(dwidRest);
    if (S_OK == SHGetValue(hkey, NULL, TEXT("SuppressionPolicy"), NULL, &dwidRest, &cbdwidRest))
        if (SHRestricted( (RESTRICTIONS)dwidRest) )
            return TRUE;

    return FALSE;
}

#endif // DECLARE_ONCE

BOOL _KeyIsRestricted(HKEY hkey);


void DCA_AddItemsFromKey(HDCA hdca, HKEY hkey, LPCTSTR pszSubKey)
{
    HKEY hkEnum;
    if (RegOpenKeyEx(hkey, pszSubKey, 0L, KEY_READ, &hkEnum) == ERROR_SUCCESS)
    {
        TCHAR sz[CCH_KEYMAX];
        for (int i = 0; RegEnumKey(hkEnum, i, sz, ARRAYSIZE(sz)) == ERROR_SUCCESS; i++)
        {
            HKEY hkEach;
            if (RegOpenKeyEx(hkEnum, sz, 0L, KEY_READ, &hkEach) == ERROR_SUCCESS)
            {
                if (!_KeyIsRestricted(hkEach))
                {
                    CLSID clsid;
                    // First, check if the key itself is a CLSID
                    BOOL fAdd = GUIDFromString(sz, &clsid);
                    if (!fAdd)
                    {
                        LONG cb = sizeof(sz);
                        if (RegQueryValue(hkEach, NULL, sz, &cb) == ERROR_SUCCESS)
                        {
                            fAdd = GUIDFromString(sz, &clsid);
                        }
                    }

                    // Add the CLSID if we successfully got the CLSID.
                    if (fAdd)
                    {
                        DCA_AddItem(hdca, clsid);
                    }
                }
                RegCloseKey(hkEach);
            }
            

        }
        RegCloseKey(hkEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\dllver.cpp ===
//
//  This is a separate file so the dependency on c_dllver is pulled
//  in only if the application actually calls CCDllGetVersion.
//
#include "stock.h"
#pragma hdrstop


//
//  Common worker function for DllGetVersion.  This means we can add
//  new DLLVERSIONINFO2, 3, 4... structures and have to fix only one
//  function. See ccstock.h for description of usage.
//

extern "C" const DLLVERSIONINFO2 c_dllver;

STDAPI CCDllGetVersion(IN OUT DLLVERSIONINFO * pinfo)
{
    HRESULT hres = E_INVALIDARG;

    if (!IsBadWritePtr(pinfo, SIZEOF(*pinfo)))
    {
        if (pinfo->cbSize == sizeof(DLLVERSIONINFO) ||
            pinfo->cbSize == sizeof(DLLVERSIONINFO2))
        {
            CopyMemory((LPBYTE)pinfo     + sizeof(pinfo->cbSize),
                       (LPBYTE)&c_dllver + sizeof(pinfo->cbSize),
                       pinfo->cbSize     - sizeof(pinfo->cbSize));
            hres = S_OK;
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\cstrinout.cpp ===
#include "stock.h"
#pragma hdrstop

#include "cstrinout.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0 && !IsAtom())
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    ASSERT(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAYSIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if (0 == _awch[_cwchLen-1]) // account for terminator
            _cwchLen--;

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

#if DBG == 1 /* { */
    if (0 == _cwchLen)
    {
        int errcode = GetLastError();
        ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;

}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(uCP)
{
    Init(pwstr, -1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//  Note:       We ignore AreFileApisANSI() and always use CP_ACP.
//              The reason is that nobody uses SetFileApisToOEM() except
//              console apps, and once you set file APIs to OEM, you
//              cannot call shell/user/gdi APIs, since they assume ANSI
//              regardless of the FileApis setting.  So you end up in
//              this horrible messy state where the filename APIs interpret
//              the strings as OEM but SHELL32 interprets the strings
//              as ANSI and you end up with a big mess.
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0 || IsAtom())
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAYSIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }


    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);
#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    ASSERT(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, (int)(pwstrT - pwstr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::CPPFIn
//
//  Synopsis:   Inits the class.  Truncates the filename to MAX_PATH
//              so Win9x DBCS won't fault.  Win9x SBCS silently truncates
//              to MAX_PATH, so we're bug-for-bug compatible.
//
//----------------------------------------------------------------------------

CPPFIn::CPPFIn(LPCWSTR pwstr)
{
    SHUnicodeToAnsi(pwstr, _ach, ARRAYSIZE(_ach));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwchBuf);
}

CStrOut::CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf) : CConvertStr(uCP)
{
    Init(pwstr, cwchBuf);
}

void
CStrOut::Init(LPWSTR pwstr, int cwchBuf) 
{
    ASSERT(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        // Force cwchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAYSIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]    -- The MBCS buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf]  -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf)
{
    ASSERT(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;

    if (!pstr)
    {
        // Force cchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cchBuf = 0;
        _pwstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAYSIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    _pwstr = new WCHAR[cchBuf];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _pwstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = SHAnsiToUnicodeCP(_uCP, _pstr, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHAnsiToUnicode failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOutW::ConvertIncludingNul()
{
    int cch;

    if (!_pwstr)
        return 0;

    cch = SHUnicodeToAnsi(_pwstr, _pstr, _cchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHUnicodeToAnsi failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
    ConvertIncludingNul();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\dobjutil.cpp ===
#include "stock.h"
#pragma hdrstop

#ifndef UNICODE 
#define UNICODE 
#endif 

#include <dobjutil.h>


STDAPI DataObj_SetBlob(IDataObject *pdtobj, UINT cf, LPCVOID pvBlob, UINT cbBlob)
{
    HRESULT hr = E_OUTOFMEMORY;
    void *pv = GlobalAlloc(GPTR, cbBlob);
    if (pv)
    {
        CopyMemory(pv, pvBlob, cbBlob);
        hr = DataObj_SetGlobal(pdtobj, cf, pv);
        if (FAILED(hr))
            GlobalFree((HGLOBAL)pv);
    }
    return hr;
}

STDAPI DataObj_GetBlob(IDataObject *pdtobj, UINT cf, void *pvBlob, UINT cbBlob)
{
    STGMEDIUM medium = {0};
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        void *pv = GlobalLock(medium.hGlobal);
        if (pv)
        {
            CopyMemory(pvBlob, pv, cbBlob);
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    return DataObj_SetBlob(pdtobj, cf, &dw, sizeof(DWORD));
}

STDAPI_(DWORD) DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD dwDefault)
{
    DWORD dwRet;
    if (FAILED(DataObj_GetBlob(pdtobj, cf, &dwRet, sizeof(DWORD))))
        dwRet = dwDefault;
    return dwRet;
}

STDAPI DataObj_SetGlobal(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};

    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = hGlobal;
    medium.pUnkForRelease = NULL;

    // give the data object ownership of ths
    return pdtobj->SetData(&fmte, &medium, TRUE);
}

STDAPI_(LPIDA) DataObj_GetHIDAEx(IDataObject *pdtobj, CLIPFORMAT cf, STGMEDIUM *pmedium)
{
    FORMATETC fmte = {cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (!pmedium)
    {
        if (S_OK == pdtobj->QueryGetData(&fmte))
            return (LPIDA)TRUE;
        else
            return (LPIDA)FALSE;
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }

    return NULL;
}

STDAPI_(LPIDA) DataObj_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    static CLIPFORMAT cfHIDA = 0;
    if (!cfHIDA)
    {
        cfHIDA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    return DataObj_GetHIDAEx(pdtobj, cfHIDA, pmedium);
}


STDAPI_(void) ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed == TYMED_HGLOBAL))
    {
#ifdef DEBUG
        if (pv)
        {
            void *pvT = (void *)GlobalLock(pmedium->hGlobal);
            ASSERT(pvT == pv);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    else
    {
        ASSERT(0);
    }

    ReleaseStgMedium(pmedium);
}

STDAPI_(void) HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM * pmedium)
{
    ReleaseStgMediumHGLOBAL((void *)pida, pmedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\dspsprt.cpp ===
#include "stock.h"
#pragma hdrstop

#include "dspsprt.h"

#define TF_IDISPATCH 0

EXTERN_C HINSTANCE g_hinst;

CImpIDispatch::CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid) :
    m_libid(libid), m_wVerMajor(wVerMajor), m_wVerMinor(wVerMinor), m_riid(riid), m_pITINeutral(NULL)
{
    ASSERT(NULL == m_pITINeutral);
}

CImpIDispatch::~CImpIDispatch(void)
{
    ATOMICRELEASE(m_pITINeutral);
}

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 1;
    return S_OK;
}

// helper function for pulling ITypeInfo out of our typelib
// Uncomment to force loading libid from the calling module: #define FORCE_LOCAL_LOAD
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, 
                            REFGUID uuid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;        // assume failure

    ITypeLib *pITypeLib;
    HRESULT hr;
    USHORT wResID;

    if (!IsEqualGUID(libid, GUID_NULL))
    {
        // The type libraries are registered under 0 (neutral),
        // 7 (German), and 9 (English) with no specific sub-
        // language, which would make them 407 or 409 and such.
        // If you are sensitive to sub-languages, then use the
        // full LCID instead of just the LANGID as done here.
#ifdef FORCE_LOCAL_LOAD
        hr = E_FAIL;    // force load through GetModuleFileName(), to get fusion 1.0 support
#else
        hr = LoadRegTypeLib(libid, wVerMajor, wVerMinor, PRIMARYLANGID(lcid), &pITypeLib);
#endif
        wResID = 0;
    }
    else
    {
        // If libid is GUID_NULL, then get type lib from module and use wVerMajor as
        // the resource ID (0 means use first type lib resource).
        pITypeLib = NULL;
        hr = E_FAIL;
        wResID = wVerMajor;
    }

    // If LoadRegTypeLib fails, try loading directly with LoadTypeLib.
    if (FAILED(hr) && g_hinst)
    {
        WCHAR wszPath[MAX_PATH];
        GetModuleFileNameWrapW(g_hinst, wszPath, ARRAYSIZE(wszPath));
        // Append resource ID to path, if specified.
        if (wResID)
        {
            WCHAR wszResStr[10];
            wnsprintfW(wszResStr, ARRAYSIZE(wszResStr), L"\\%d", wResID);
            StrCatBuffW(wszPath, wszResStr, ARRAYSIZE(wszPath));
        }
        
        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr = LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Got the type lib, get type info for the interface we want.
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }
    return hr;
}


STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;

    if (0 != itInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ITypeInfo **ppITI = &m_pITINeutral; // our cached typeinfo

    // Load a type lib if we don't have the information already.
    if (NULL == *ppITI)
    {
        ITypeInfo *pITIDisp;
        HRESULT hr = GetTypeInfoFromLibId(lcid, m_libid, m_wVerMajor, m_wVerMinor, m_riid, &pITIDisp);
        if (SUCCEEDED(hr))
        {
            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HREFTYPE hrefType;
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    (*ppITI)->AddRef();
    *ppITypeInfo = *ppITI;
    return S_OK;
}

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    ITypeInfo *pTI;
    HRESULT hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

#ifdef DEBUG
    TCHAR szParam[MAX_PATH] = TEXT("");
    if (cNames >= 1)
        SHUnicodeToTChar(*rgszNames, szParam, ARRAYSIZE(szParam));

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif
    return hr;
}

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid, 
                                   LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, 
                                   VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE; // riid is supposed to be IID_NULL always

    IDispatch *pdisp;
    HRESULT hr = QueryInterface(m_riid, (void **)&pdisp);
    if (SUCCEEDED(hr))
    {
        //Get the ITypeInfo for lcid
        ITypeInfo *pTI;
        hr = GetTypeInfo(0, lcid, &pTI);
        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0, NULL);  //Clear exceptions
    
            // This is exactly what DispInvoke does--so skip the overhead.
            hr = pTI->Invoke(pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
        pdisp->Release();
    }
    return hr;
}

void CImpIDispatch::Exception(WORD wException)
{
    ASSERT(FALSE); // No one should call this yet
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\dllreghelper.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      DllRegHelper.cpp
//
//  Contents:  helper classes to register COM components in DLLs
//
//------------------------------------------------------------------------

#include "DllRegHelper.h"
#pragma hdrstop

#include <comcat.h>
#include <advpub.h>
#include "ccstock.h"
#include "shlwapi.h"
#include "debug.h"
#include "mluisupp.h"


#define _APLHA_ComCat_WorkAround    // { ALPHA ComCat bug work-around on alpha, nuke this eventually?
                                    // ie40:63004: comcat does RegCloseKey(invalid) on checked
                                    // nt/alpha if the clsid doesn't exist (e.g. for QuickLinksOld)

#if defined(_APLHA_ComCat_WorkAround)
//------------------------------------------------------------------------
//***   HasImplCat -- does "HKCR/CLSID/{clsid}/Implemented Categories" exist
// NOTES
//  used for ComCat bug work-around on alpha
BOOL HasImplCat(const CATID *pclsid)
{
    HKEY hk;
    TCHAR szClass[GUIDSTR_MAX];
    TCHAR szImpl[MAX_PATH];      // "CLSID/{clsid}/Implemented Categories" < MAX_PATH

    // "CLSID/{clsid}/Implemented Categories"
    SHStringFromGUID(*pclsid, szClass, ARRAYSIZE(szClass));
    ASSERT(lstrlen(szClass) == GUIDSTR_MAX - 1);
    wnsprintf(szImpl, ARRAYSIZE(szImpl), TEXT("CLSID\\%s\\Implemented Categories"), szClass);

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szImpl, 0, KEY_READ, &hk) == ERROR_SUCCESS) {
        RegCloseKey(hk);
        return TRUE;
    }
    else {
        TraceMsg(DM_WARNING, "HasImplCat: %s: ret 0", szImpl);
        return FALSE;
    }
}
#endif // }


//------------------------------------------------------------------------
//***   RegisterOneCategory -- [un]register ComCat implementor(s) and category
// ENTRY/EXIT
//  eRegister   CCR_REG, CCR_UNREG, CCR_UNREGIMP
//      CCR_REG, UNREG      reg/unreg implementor(s) and category
//      CCR_UNREGIMP        unreg implementor(s) only
//  pcatidCat   e.g. CATID_DeskBand
//  idResCat    e.g. IDS_CATDESKBAND
//  pcatidImpl  e.g. c_DeskBandClasses
HRESULT DRH_RegisterOneCategory(const CATID *pcatidCat, UINT idResCat, const CATID * const *pcatidImpl, enum DRH_REG_MODE eRegister)
{
    ICatRegister* pcr;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICatRegister, &pcr));
    if (SUCCEEDED(hr))
    {
        if (eRegister == CCR_REG)
        {
            // register the category
            CATEGORYINFO catinfo;
            catinfo.catid = *pcatidCat;     // e.g. CATID_DESKBAND
            catinfo.lcid = LOCALE_USER_DEFAULT;
            MLLoadString(idResCat, catinfo.szDescription, ARRAYSIZE(catinfo.szDescription));
            hr = pcr->RegisterCategories(1, &catinfo);
            ASSERT(SUCCEEDED(hr));
            
            // register the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++)
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;
                hr = pcr->RegisterClassImplCategories(clsid, 1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else
        {
            // unregister the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++)
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;

#if defined(_APLHA_ComCat_WorkAround)   // { ALPHA ComCat bug work-around on alpha, nuke this eventually?
                // workaround comcat/alpha bug
                // n.b. we do this for non-alpha too to reduce testing impact
                // ie40:63004: comcat does RegCloseKey(invalid) on checked
                // nt/alpha if the clsid doesn't exist (e.g. for QuickLinksOld)
                if (!HasImplCat(&clsid))
                    continue;
#endif // }
                hr = pcr->UnRegisterClassImplCategories(clsid, 1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
            
            if (eRegister == CCR_UNREG)
            {
                // Do we want to do this?  other classes (e.g. 3rd party
                // ones) might still be using the category.  however since we're
                // the component that added (and supports) the category, it
                // seems correct that we should remove it when we unregister.

                // unregister the category
                CATID catid = *pcatidCat;
                hr = pcr->UnRegisterCategories(1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
        }
        pcr->Release();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\expdsprt.cpp ===
#include "stock.h"
#pragma hdrstop

#include "expdsprt.h"

HRESULT CImpIExpDispSupport::FindCIE4ConnectionPoint(REFIID riid, CIE4ConnectionPoint **ppccp)
{
    CConnectionPoint* pccp = _FindCConnectionPointNoRef(FALSE, riid);

    if (pccp)
    {
        pccp->AddRef();
        *ppccp = pccp;
        return S_OK;
    }
    else
    {
        *ppccp = NULL;
        return E_NOINTERFACE;
    }
}

HRESULT CImpIExpDispSupport::OnTranslateAccelerator(MSG __RPC_FAR *pMsg,DWORD grfModifiers)
{
    return E_NOTIMPL;
}

HRESULT CImpIExpDispSupport::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                 VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    return E_NOTIMPL;
}

HRESULT CImpIConnectionPointContainer::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT *ppCP)
{
    if (NULL == ppCP)
        return E_POINTER;

    CConnectionPoint *pccp = _FindCConnectionPointNoRef(TRUE, iid);
    if (pccp)
    {
        pccp->AddRef();
        *ppCP = pccp->CastToIConnectionPoint();
        return S_OK;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\ieutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <varutil.h>
#include <shdocvw.h>

// Use this file to house browser-related utility functions

// -------------------------------------------------------------------
// ANSI/UNICODE-neutral functions
// these only need to be compiled once, so just do it UNICODE

#ifdef UNICODE

LPITEMIDLIST _ILCreateFromPathW(LPCWSTR pwszPath)
{
    // use this shdocvw export, this deals with down level shells and funky url parsing
    LPITEMIDLIST pidl;
    return SUCCEEDED(IEParseDisplayNameWithBCW(CP_ACP, pwszPath, NULL, &pidl)) ? pidl : NULL;
}

STDAPI_(LPITEMIDLIST) VariantToIDList(const VARIANT *pv)
{
    LPITEMIDLIST pidl = NULL;
    if (pv)
    {
        if (pv->vt == (VT_BYREF | VT_VARIANT) && pv->pvarVal)
            pv = pv->pvarVal;

        switch (pv->vt)
        {
        case VT_I2:
            pidl = SHCloneSpecialIDList(NULL, pv->iVal, TRUE);
            break;

        case VT_I4:
        case VT_UI4:
            if (pv->lVal < 0xFFFF)
            {
                pidl = SHCloneSpecialIDList(NULL, pv->lVal, TRUE);
            }
#ifndef _WIN64
            //We make sure we use it as a pointer only in Win32
            else
            {
                pidl = ILClone((LPCITEMIDLIST)pv->byref);    // HACK in process case, avoid the use of this if possible
            }
#endif // _WIN64
            break;

        //In Win64, the pidl variant could be 8 bytes long!
        case VT_I8:
        case VT_UI8:
            if(pv->ullVal < 0xFFFF)
            {
                pidl = SHCloneSpecialIDList(NULL, (int)pv->ullVal, TRUE);
            }
#ifdef _WIN64
            //We make sure we use it as a pointer only in Win64
            else
            {
                pidl = ILClone((LPCITEMIDLIST)pv->ullVal);    // HACK in process case, avoid the use of this if possible
            }
#endif //_WIN64
            break;

        case VT_BSTR:
            pidl = _ILCreateFromPathW(pv->bstrVal);
            break;

        case VT_ARRAY | VT_UI1:
            pidl = ILClone((LPCITEMIDLIST)pv->parray->pvData);
            break;

        case VT_DISPATCH | VT_BYREF:
            if (pv->ppdispVal)
                SHGetIDListFromUnk(*pv->ppdispVal, &pidl);
            break;

        case VT_DISPATCH:
            SHGetIDListFromUnk(pv->pdispVal, &pidl);
            break;
        }
    }
    return pidl;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\infotip.cpp ===
//
//  infotip.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//
#include "stock.h"
#pragma hdrstop

#include <vdate.h>
#include "shellp.h"

BOOL GetInfoTipHelpEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    BOOL fRet = FALSE;

    *pszText = 0;   // empty for failure

    if (pidl)
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_IQueryInfo, NULL, (void**)&pqi)))
        {
            WCHAR *pwszTip;
            if (SUCCEEDED(pqi->GetInfoTip(dwFlags, &pwszTip)) && pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
    }
    return fRet;
}

BOOL GetInfoTipHelp(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    return GetInfoTipHelpEx(psf, 0, pidl, pszText, cchTextMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\inetutil.cpp ===
/*****************************************************************************\
    FILE: inetutil.cpp

    DESCRIPTION:
        These are wininet wrappers that fix the error values and wrap functionality.

    BryanSt 10/12/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#include "stock.h"
#pragma hdrstop

#include <wininet.h>



////////////////////////////////
//  Wininet/URL Helpers
////////////////////////////////
STDAPI InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


#define SIZE_COPY_BUFFER                    (32 * 1024)     // 32k

STDAPI InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML)
{
    BYTE byteBuffer[SIZE_COPY_BUFFER];
    DWORD cbRead = SIZE_COPY_BUFFER;
    DWORD cchSize = 0;
    HRESULT hr = S_OK;

    *pbstrXML = NULL;
    while (SUCCEEDED(hr) && cbRead)
    {
        hr = InternetReadFileWrap(hInternetRead, byteBuffer, sizeof(byteBuffer), &cbRead);
        if (SUCCEEDED(hr) && cbRead)
        {
            BSTR bstrOld = *pbstrXML;
            BSTR bstrEnd;

            // The string may not be terminated.
            byteBuffer[cbRead] = 0;

            cchSize += ARRAYSIZE(byteBuffer);
            *pbstrXML = SysAllocStringLen(NULL, cchSize);
            if (*pbstrXML)
            {
                if (bstrOld)
                {
                    StrCpy(*pbstrXML, bstrOld);
                }
                else
                {
                    (*pbstrXML)[0] = 0;
                }

                bstrEnd = *pbstrXML + lstrlenW(*pbstrXML);

                SHAnsiToUnicode((LPCSTR) byteBuffer, bstrEnd, ARRAYSIZE(byteBuffer));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SysFreeString(bstrOld);
        }
    }

    return hr;
}


STDAPI InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


STDAPI InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


#define SZ_WININET_AGENT_FILEASSOC      TEXT("Microsoft File Association Lookup")

STDAPI DownloadUrl(LPCTSTR pszUrl, BSTR * pbstrXML)
{
    HRESULT hr = E_OUTOFMEMORY;
    HINTERNET hInternetSession;

    hr = InternetOpenWrap(SZ_WININET_AGENT_FILEASSOC, PRE_CONFIG_INTERNET_ACCESS, NULL, NULL, 0, &hInternetSession);
    if (SUCCEEDED(hr))
    {
        HINTERNET hOpenUrlSession;

        hr = InternetOpenUrlWrap(hInternetSession, pszUrl, NULL, 0, INTERNET_FLAG_NO_UI, NULL, &hOpenUrlSession);
        if (SUCCEEDED(hr))
        {
            hr = InternetReadIntoBSTR(hOpenUrlSession, pbstrXML);
            InternetCloseHandle(hOpenUrlSession);
        }

        InternetCloseHandle(hInternetSession);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\idhidden.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>

//  the last word of the pidl is where we store the hidden offset
#define _ILHiddenOffset(pidl)   (*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - sizeof(WORD))))
#define _ILSetHiddenOffset(pidl, cb)   ((*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - sizeof(WORD)))) = (WORD)cb)
#define _ILIsHidden(pidhid)     (HIWORD(pidhid->id) == HIWORD(IDLHID_EMPTY))

STDAPI_(PCIDHIDDEN) _ILNextHidden(PCIDHIDDEN pidhid, LPCITEMIDLIST pidlLimit)
{
    PCIDHIDDEN pidhidNext = (PCIDHIDDEN) _ILNext((LPCITEMIDLIST)pidhid);

    if ((BYTE *)pidhidNext < (BYTE *)pidlLimit && _ILIsHidden(pidhidNext))
    {
        return pidhidNext;
    }

    //  if we ever go past the limit,
    //  then this is not really a hidden id
    //  or we have messed up on some calculation.
    ASSERT((BYTE *)pidhidNext == (BYTE *)pidlLimit);
    return NULL;
}

STDAPI_(PCIDHIDDEN) _ILFirstHidden(LPCITEMIDLIST pidl)
{
    WORD cbHidden = _ILHiddenOffset(pidl);

    if (cbHidden && cbHidden + sizeof(HIDDENITEMID) < pidl->mkid.cb)
    {
        //  this means it points to someplace inside the pidl
        //  maybe this has hidden ids
        PCIDHIDDEN pidhid = (PCIDHIDDEN) (((BYTE *)pidl) + cbHidden);

        if (_ILIsHidden(pidhid)
        && (pidhid->cb + cbHidden <= pidl->mkid.cb))
        {
            //  this is more than likely a hidden id
            //  we could walk the chain and verify
            //  that it adds up right...
            return pidhid;
        }
    }

    return NULL;
}

//
//  HIDDEN ids are sneakily hidden in the last ID in a pidl.
//  we append our data without changing the existing pidl,
//  (except it is now bigger)  this works because the pidls
//  that we will apply this to are flexible in handling different
//  sized pidls.  specifically this is used in FS pidls.
// 
//  WARNING - it is the callers responsibility to use hidden IDs
//  only on pidls that can handle it.  most shell pidls, and 
//  specifically FS pidls have no problem with this.  however
//  some shell extensions might have fixed length ids, 
//  which makes these unadvisable to append to everything.
//  possibly add an SFGAO_ bit to allow hidden, otherwise key
//  off FILESYSTEM bit.
//


STDAPI ILCloneWithHiddenID(LPCITEMIDLIST pidl, PCIDHIDDEN pidhid, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    // If this ASSERT fires, then the caller did not set the pidhid->id
    // value properly.  For example, the packing settings might be incorrect.

    ASSERT(_ILIsHidden(pidhid));

    if (ILIsEmpty(pidl))
    {
        *ppidl = NULL;
        hr = E_INVALIDARG;
    }
    else
    {
        UINT cbUsed = ILGetSize(pidl);
        UINT cbRequired = cbUsed + pidhid->cb + sizeof(pidhid->cb);

        *ppidl = (LPITEMIDLIST)SHAlloc(cbRequired);
        if (*ppidl)
        {
            hr = S_OK;

            CopyMemory(*ppidl, pidl, cbUsed);

            LPITEMIDLIST pidlLast = ILFindLastID(*ppidl);
            WORD cbHidden = _ILFirstHidden(pidlLast) ? _ILHiddenOffset(pidlLast) : pidlLast->mkid.cb;
            PIDHIDDEN pidhidCopy = (PIDHIDDEN)_ILSkip(*ppidl, cbUsed - sizeof((*ppidl)->mkid.cb));

            // Append it, overwriting the terminator
            MoveMemory(pidhidCopy, pidhid, pidhid->cb);

            //  grow the copy to allow the hidden offset.
            pidhidCopy->cb += sizeof(pidhid->cb);

            //  now we need to readjust pidlLast to encompass 
            //  the hidden bits and the hidden offset.
            pidlLast->mkid.cb += pidhidCopy->cb;

            //  set the hidden offset so that we can find our hidden IDs later
            _ILSetHiddenOffset((LPITEMIDLIST)pidhidCopy, cbHidden);

            // We must put zero-terminator because of LMEM_ZEROINIT.
            _ILSkip(*ppidl, cbRequired - sizeof((*ppidl)->mkid.cb))->mkid.cb = 0;
            ASSERT(ILGetSize(*ppidl) == cbRequired);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// lame API that consumes pidl as input (caller must not touch after callign this)

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid)
{
    //
    // FEATURE - we dont handle collisions of multiple hidden ids
    //          maybe remove IDs of the same IDLHID?
    //
    // Note: We do not remove IDLHID_EMPTY hidden ids.
    // Callers need to call ILExpungeRemovedHiddenIDs explicitly
    // if they want empty hidden ids to be compressed out.
    //
    
    RIP(pidl);  //  we require a pidl to attach the hidden id to
    if (!ILIsEmpty(pidl))
    {
        LPITEMIDLIST pidlSave = pidl;
        ILCloneWithHiddenID(pidl, pidhid, &pidl);
        ILFree(pidlSave);
    }
    return pidl;
}



STDAPI_(PCIDHIDDEN) ILFindHiddenIDOn(LPCITEMIDLIST pidl, IDLHID id, BOOL fOnLast)
{
    RIP(pidl);
    if (!ILIsEmpty(pidl))
    {
        if (fOnLast)
            pidl = ILFindLastID(pidl);
        
        PCIDHIDDEN pidhid = _ILFirstHidden(pidl);

        //  reuse pidl to become the limit.
        //  so that we cant ever walk out of 
        //  the pidl.
        pidl = _ILNext(pidl);

        while (pidhid)
        {
            if (pidhid->id == id)
                break;

            pidhid = _ILNextHidden(pidhid, pidl);
        }
        return pidhid;
    }

    return NULL;
}

STDAPI_(LPITEMIDLIST) ILCreateWithHidden(UINT cbNonHidden, UINT cbHidden)
{
    //  alloc enough for the two ids plus term and hidden tail
    LPITEMIDLIST pidl;
    UINT cb = cbNonHidden + cbHidden + sizeof(pidl->mkid.cb);
    UINT cbAlloc = cb + sizeof(pidl->mkid.cb);
    pidl = (LPITEMIDLIST)SHAlloc(cbAlloc);
    if (pidl)
    {
        // zero-init for external task allocator
        memset(pidl, 0, cbAlloc);      
        PIDHIDDEN pidhid = (PIDHIDDEN)_ILSkip(pidl, cbNonHidden);

        //  grow the copy to allow the hidden offset.
        pidhid->cb = (USHORT) cbHidden + sizeof(pidhid->cb);

        //  now we need to readjust pidlLast to encompass 
        //  the hidden bits and the hidden offset.
        pidl->mkid.cb = (USHORT) cb;

        //  set the hidden offset so that we can find our hidden IDs later
        _ILSetHiddenOffset(pidl, cbNonHidden);

        ASSERT(ILGetSize(pidl) == cbAlloc);
        ASSERT(_ILNext(pidl) == _ILNext((LPCITEMIDLIST)pidhid));
    }
    return pidl;
}

// Note: The space occupied by the removed ID is not reclaimed.
// Call ILExpungeRemovedHiddenIDs explicitly to reclaim the space.

STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id)
{
    PIDHIDDEN pidhid = (PIDHIDDEN)ILFindHiddenID(pidl, id);

    if (pidhid)
    {
        pidhid->id = IDLHID_EMPTY;
        return TRUE;
    }
    return FALSE;
}

STDAPI_(void) ILExpungeRemovedHiddenIDs(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        pidl = ILFindLastID(pidl);

        // Note: Each IDHIDDEN has a WORD appended to it, equal to
        // _ILHiddenOffset, so we can just keep deleting IDHIDDENs
        // and if we delete them all, everything is cleaned up; if
        // there are still unremoved IDHIDDENs left, they will provide
        // the _ILHiddenOffset.

        PIDHIDDEN pidhid;
        BOOL fAnyDeleted = FALSE;
        while ((pidhid = (PIDHIDDEN)ILFindHiddenID(pidl, IDLHID_EMPTY)) != NULL)
        {
            fAnyDeleted = TRUE;
            LPBYTE pbAfter = (LPBYTE)pidhid + pidhid->cb;
            WORD cbDeleted = pidhid->cb;
            MoveMemory(pidhid, pbAfter,
                       (LPBYTE)pidl + pidl->mkid.cb + sizeof(WORD) - pbAfter);
            pidl->mkid.cb -= cbDeleted;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\makefile.inc ===
#
# rules for compiling stocklib files
#
$(O)\shstra.cpp: ..\shstr.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\shstrw.cpp: ..\shstr.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\dkaa.cpp: ..\dka.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\dkaw.cpp: ..\dka.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\nativea.cpp: ..\native.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\nativew.cpp: ..\native.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\infotipa.cpp: ..\infotip.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\infotipw.cpp: ..\infotip.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

#
# copy the generated lib to shell\lib\$O so people can include it
#
$(CCSHELL_DIR)\lib\$(O)\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\isos.cpp ===
#include "stock.h"
#pragma hdrstop

// do this before we #include <isos.c> so the function name gets set properly
#define IsOS    staticIsOS

#include <isos.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\mediautil.cpp ===
// mediautil.cpp: media bar utility routines

#include "stock.h"
#include "browseui.h"
#include "mediautil.h"

#define WZ_SMIE_MEDIA           TEXT("Software\\Microsoft\\Internet Explorer\\Media")
#define WZ_SMIE_MEDIA_MIME      TEXT("Software\\Microsoft\\Internet Explorer\\Media\\MimeTypes")
#define WZ_AUTOPLAY             TEXT("Autoplay")
#define WZ_AUTOPLAYPROMPT       TEXT("AutoplayPrompt")

#define MAX_REG_VALUE_LENGTH   50
#define MAX_MIME_LENGTH        256


static LPTSTR rgszMimeTypes[] = {
    TEXT("video/avi"),            
    TEXT("video/mpeg"),           
    TEXT("video/msvideo"),        
    TEXT("video/x-ivf"),          
    TEXT("video/x-mpeg"),         
    TEXT("video/x-mpeg2a"),       
    TEXT("video/x-ms-asf"),       
    TEXT("video/x-msvideo"),      
    TEXT("video/x-ms-wm"),        
    TEXT("video/x-ms-wmv"),       
    TEXT("video/x-ms-wvx"),       
    TEXT("video/x-ms-wmx"),       
    TEXT("video/x-ms-wmp"),       
    TEXT("audio/mp3"),            
    TEXT("audio/aiff"),           
    TEXT("audio/basic"),          
    TEXT("audio/mid"),            
    TEXT("audio/midi"),           
    TEXT("audio/mpeg"),           
    TEXT("audio/mpegurl"),           
    TEXT("audio/wav"),            
    TEXT("audio/x-aiff"),         
    TEXT("audio/x-mid"),         
    TEXT("audio/x-midi"),         
    TEXT("audio/x-mpegurl"),      
    TEXT("audio/x-ms-wax"),       
    TEXT("audio/x-ms-wma"),       
    TEXT("audio/x-background"),
    TEXT("audio/x-wav"),
    TEXT("midi/mid"),
    TEXT("application/x-ms-wmd")
};



//+----------------------------------------------------------------------------------------
// CMediaBarUtil Methods
//-----------------------------------------------------------------------------------------

HUSKEY
CMediaBarUtil::GetMediaRegKey()
{
    return OpenRegKey(WZ_SMIE_MEDIA);
}

HUSKEY  
CMediaBarUtil::OpenRegKey(TCHAR * pchName)
{
    HUSKEY hUSKey = NULL;

    if (pchName)
    {
        LONG lRet = SHRegCreateUSKey(
                                pchName,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hUSKey,
                                SHREGSET_HKCU);

        if ((ERROR_SUCCESS != lRet) || (NULL == hUSKey))
        {
            hUSKey = NULL;
            ASSERT(FALSE && L"couldn't open Key for registry settings");
        }
    }

    return hUSKey;
}

HRESULT
CMediaBarUtil::CloseRegKey(HUSKEY hUSKey)
{
    HRESULT hr = S_OK;

    if (hUSKey)
    {
        DWORD dwRet = SHRegCloseUSKey(hUSKey);
        if (ERROR_SUCCESS != dwRet)
        {
            ASSERT(FALSE && L"couldn't close Reg Key");
            hr = E_FAIL;
        }
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsRegValueTrue
//
//  Overview:  Check if given value is true
//
//  Arguments: [hUSKey]       Key to read from
//             [pchName]      name of the value to read out
//             [pfValue]      out param (true/false Reg value)
//
//  Returns:   S_FALSE if Value does not exist
//             S_OK otherwise
//
//------------------------------------------------------------------------
HRESULT CMediaBarUtil::IsRegValueTrue(HUSKEY hUSKey, TCHAR * pchName, BOOL *pfValue)
{
    DWORD   dwSize = MAX_REG_VALUE_LENGTH;
    DWORD   dwType;
    BYTE    bDataBuf[MAX_REG_VALUE_LENGTH];
    LONG    lRet;
    BOOL    bRet = FALSE;
    HRESULT hr = E_FAIL;

    if (!hUSKey || !pfValue || !pchName)
    {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto done;
    }

    lRet = SHRegQueryUSValue(hUSKey, 
                             pchName, 
                             &dwType, 
                             bDataBuf, 
                             &dwSize, 
                             FALSE, 
                             NULL, 
                             0);
                             
    if (ERROR_SUCCESS != lRet)
    {
        hr = S_FALSE;
        goto done;
    }

    if (REG_DWORD == dwType)
    {
        bRet = (*(DWORD*)bDataBuf != 0);
    }
    else if (REG_SZ == dwType)
    {
        TCHAR ch = (TCHAR)(*bDataBuf);

        if (TEXT('1') == ch ||
            TEXT('y') == ch ||
            TEXT('Y') == ch)
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }
    else if (REG_BINARY == dwType)
    {
        bRet = (*(BYTE*)bDataBuf != 0);
    }
    
    hr = S_OK;
done:
    if (pfValue)
        *pfValue = bRet;
    return hr;
}

// Value is implicity TRUE, unless it exists and is set to FALSE
BOOL    
CMediaBarUtil::GetImplicitMediaRegValue(TCHAR * pchName)
{
    BOOL fRet = FALSE;
    
    if (pchName)
    {
        HUSKEY hMediaKey = GetMediaRegKey();
        if (hMediaKey)
        {
            BOOL fVal = FALSE;
            HRESULT hr = E_FAIL;

            hr = IsRegValueTrue(hMediaKey, pchName, &fVal);

            if ((S_OK == hr) && (FALSE == fVal))
            {
                fRet = FALSE;
            }
            else
            {
                // true if key is not present or explicitly set to true
                fRet = TRUE;
            }

            CloseRegKey(hMediaKey);
        }
    }

    return fRet;
}

BOOL    
CMediaBarUtil::GetAutoplay()
{
    return GetImplicitMediaRegValue(WZ_AUTOPLAY);
}

HRESULT CMediaBarUtil::SetMediaRegValue(LPWSTR pstrName, DWORD dwRegDataType, void * pvData, DWORD cbData, BOOL fMime /* = FALSE */)
{
    HRESULT hr = E_FAIL;

    if (pstrName && pvData && (cbData > 0))
    {
        HUSKEY hMediaKey = (fMime == TRUE) ? GetMimeRegKey() : GetMediaRegKey();

        if (hMediaKey)
        {
            LONG lRet = SHRegWriteUSValue(hMediaKey, 
                                          pstrName, 
                                          dwRegDataType, 
                                          pvData, 
                                          cbData, 
                                          SHREGSET_FORCE_HKCU); 
            if (ERROR_SUCCESS == lRet)
            {
                hr = S_OK;
            }
            else
            {
                ASSERT(FALSE && L"couldn't write reg value");
            }

            CloseRegKey(hMediaKey);
        }
    }

    return hr;
}

HUSKEY
CMediaBarUtil::GetMimeRegKey()
{
    return OpenRegKey(WZ_SMIE_MEDIA_MIME);
}

BOOL    
CMediaBarUtil::GetAutoplayPrompt()
{
    return GetImplicitMediaRegValue(WZ_AUTOPLAYPROMPT);
}

HRESULT 
CMediaBarUtil::ToggleAutoplayPrompting(BOOL fOn)
{
    HRESULT hr = E_FAIL;
    DWORD dwData = 0;
    
    dwData = (TRUE == fOn ? 0x1 : 0x0);

    hr = SetMediaRegValue(WZ_AUTOPLAYPROMPT, REG_BINARY, (void*) &dwData, (DWORD) 1); 

    return hr;
}


HRESULT 
CMediaBarUtil::ToggleAutoplay(BOOL fOn)
{
    HRESULT hr = E_FAIL;
    DWORD dwData = 0;
    
    dwData = (TRUE == fOn ? 0x1 : 0x0);

    hr = SetMediaRegValue(WZ_AUTOPLAY, REG_BINARY, (void*) &dwData, (DWORD) 1); 

    return hr;
}


BOOL    
CMediaBarUtil::IsRecognizedMime(TCHAR * szMime)
{
    BOOL fRet = FALSE;

    if (!szMime || !(*szMime))
        goto done;

    for (int i = 0; i < ARRAYSIZE(rgszMimeTypes); i++)
    {
        if (0 == StrCmpI(rgszMimeTypes[i], szMime))
        {
            fRet = TRUE;
            goto done;
        }
    }
    
done:
    return fRet;
}


// this function checks if the media bar should play this mime type
HRESULT
CMediaBarUtil::ShouldPlay(TCHAR * szMime, BOOL * pfShouldPlay)
{
    BOOL fRet = FALSE;
    HRESULT hr = E_FAIL;

    HUSKEY hKeyMime = GetMimeRegKey();
    if (!hKeyMime)
        goto done;

    // Bail if Autoplay is disabled
    if (FALSE == GetAutoplay())
    {
        goto done;
    }

    // bail if this is not a recognized mime type
    if (FALSE == IsRecognizedMime(szMime))
        goto done;

    // check if the user wants us to play everything 
    if (FALSE == GetAutoplayPrompt())
    {
        fRet = TRUE;
        hr = S_OK;
        goto done;
    }

    // see if user wants us to play this mime type
    hr = IsRegValueTrue(hKeyMime, szMime, &fRet);
    if (FAILED(hr))
        goto done;

    if (S_FALSE == hr)
    {
        // S_FALSE means we have not asked the user about this mime type.
        // Which means the media bar should get a crack at this file
        // and ask the user if it should play this file.
        fRet = TRUE;
    }

done:
    *pfShouldPlay = fRet;

    if (hKeyMime)
        CloseRegKey(hKeyMime);

    return hr;
}


BOOL 
CMediaBarUtil::IsWMP7OrGreaterInstalled()
{
    TCHAR szPath[50];
    szPath[0] = 0;
    DWORD dwType, cb = sizeof(szPath), dwInstalled=0, cb2=sizeof(dwInstalled);
    return ((ERROR_SUCCESS==SHGetValue(HKEY_LOCAL_MACHINE, REG_WMP8_STR, TEXT("version"), &dwType, szPath, &cb))
            && ((DWORD)(*szPath-TEXT('0'))>=7)
            && (ERROR_SUCCESS==SHGetValue(HKEY_LOCAL_MACHINE, REG_WMP8_STR, TEXT("IsInstalled"), &dwType, &dwInstalled, &cb2))
            && (dwInstalled==1));
}

typedef UINT (WINAPI *GetSystemWow64DirectoryPtr) (PSTR pszBuffer, UINT uSize);
typedef BOOL (WINAPI *IsNTAdmin) (DWORD, DWORD*);

BOOL 
CMediaBarUtil::IsWMP7OrGreaterCapable()
{
    static BOOL fInitialized = FALSE;
    static BOOL fCapable = TRUE;
    if (!fInitialized)
    {
        // WMP isn't supported on NT4, IA64, or DataCenter.
        // If WMP isn't already installed, and we're not running with admin privileges, we might as well fail
        // since we need WMP to function.

        fCapable = IsOS(OS_WIN2000ORGREATER);
        if (!fCapable)
        {
            fCapable = IsOS(OS_WIN98ORGREATER);
        }
        else
        {
            CHAR szPath[MAX_PATH];

            HMODULE hModule = GetModuleHandle(TEXT("kernel32.dll"));
            if (hModule)
            {
                GetSystemWow64DirectoryPtr func = (GetSystemWow64DirectoryPtr)GetProcAddress(hModule, "GetSystemWow64DirectoryA");
                fCapable = !(func && func(szPath, ARRAYSIZE(szPath)));
            }
            if (fCapable && !IsWMP7OrGreaterInstalled())
            {
                HMODULE hModule = LoadLibrary(TEXT("advpack.dll"));
                if (hModule)
                {
                    IsNTAdmin func = (IsNTAdmin)GetProcAddress(hModule, "IsNTAdmin");
                    fCapable = func && func(0, NULL);
                    FreeLibrary(hModule);
                }
            }            
        }
        if (IsOS(OS_DATACENTER))
        {
            fCapable = FALSE;
        }
        fInitialized = TRUE;
    }
    return fCapable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\profsvc.cpp ===
#include "stock.h"
#pragma hdrstop

#include <profsvc.h>

typedef struct
{
    IServiceProvider *psp;
    GUID guidService;
    DWORD dwCookie;
} SERVICE_ITEM;

#define _Item(i)    (_hdsa ? (SERVICE_ITEM *)DSA_GetItemPtr(_hdsa, i) : NULL)
#define _Count()   (_hdsa ? DSA_GetItemCount(_hdsa) : 0)

IProfferServiceImpl::IProfferServiceImpl() :
    _hdsa(NULL),
    _dwNextCookie(0)
{
}

IProfferServiceImpl::~IProfferServiceImpl()
{
    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi)
        {
            IUnknown_Set((IUnknown **)&psi->psp, NULL);
        }
    }

    DSA_Destroy(_hdsa);
}

HRESULT IProfferServiceImpl::ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie)
{
    HRESULT hr;

    if (!_hdsa)
    {
        _hdsa = DSA_Create(sizeof(SERVICE_ITEM), 4);
    }

    SERVICE_ITEM si;
    
    si.psp = psp;
    si.guidService = rguidService;
    si.dwCookie = ++_dwNextCookie;  // start at 1

    if (_hdsa && (-1 != DSA_AppendItem(_hdsa, &si)))
    {
        psp->AddRef();
        *pdwCookie = si.dwCookie;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT IProfferServiceImpl::RevokeService(DWORD dwCookie)
{
    HRESULT hr = E_INVALIDARG;  // not found

    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi && (psi->dwCookie == dwCookie))
        {
            IUnknown_Set((IUnknown **)&psi->psp, NULL);
            DSA_DeleteItem(_hdsa, i);
            hr = S_OK;  // successful revoke
            break;
        }
    }
    return hr;
}

HRESULT IProfferServiceImpl::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;    // did not find the service object

    *ppv = NULL;

    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi && IsEqualGUID(psi->guidService, guidService))
        {
            hr = psi->psp->QueryService(guidService, riid, ppv);
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\propertybag.cpp ===
#include "stock.h"
#pragma hdrstop



void SHPropertyBag_ReadStrDef(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch, LPCWSTR pszDef)
{
    if (FAILED(SHPropertyBag_ReadStr(ppb, pszPropName, psz, cch)))
    {
        if (pszDef)
        {
            StrCpyNW(psz, pszDef, cch);
        }
        else
        {
            StrCpyNW(psz, L"", cch);
        }
    }
}

void SHPropertyBag_ReadIntDef(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult, int iDef)
{
    if (FAILED(SHPropertyBag_ReadInt(ppb, pszPropName, piResult)))
    {
        *piResult = iDef;
    }
}

void SHPropertyBag_ReadSHORTDef(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh, SHORT shDef)
{
    if (FAILED(SHPropertyBag_ReadSHORT(ppb, pszPropName, psh)))
    {
        *psh = shDef;
    }
}

void SHPropertyBag_ReadLONGDef(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl, LONG lDef)
{
    if (FAILED(SHPropertyBag_ReadLONG(ppb, pszPropName, pl)))
    {
        *pl = lDef;
    }
}

void SHPropertyBag_ReadDWORDDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef)
{
    if (FAILED(SHPropertyBag_ReadDWORD(ppb, pszPropName, pdw)))
    {
        *pdw = dwDef;
    }
}

void SHPropertyBag_ReadBOOLDef(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pf, BOOL fDef)
{
    if (FAILED(SHPropertyBag_ReadBOOL(ppb, pszPropName, pf)))
    {
        *pf = fDef;
    }
}

BOOL SHPropertyBag_ReadBOOLDefRet(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fDef)
{
    BOOL fRet;

    SHPropertyBag_ReadBOOLDef(ppb, pszPropName, &fRet, fDef);

    return fRet;
}

void SHPropertyBag_ReadGUIDDef(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid, const GUID* pguidDef)
{
    if (FAILED(SHPropertyBag_ReadGUID(ppb, pszPropName, pguid)))
    {
        *pguid = *pguidDef;
    }
}

void SHPropertyBag_ReadPOINTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt, const POINTL* pptDef)
{
    if (FAILED(SHPropertyBag_ReadPOINTL(ppb, pszPropName, ppt)))
    {
        *ppt = *pptDef;
    }
}

void SHPropertyBag_ReadPOINTSDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt, const POINTS* pptDef)
{
    if (FAILED(SHPropertyBag_ReadPOINTS(ppb, pszPropName, ppt)))
    {
        *ppt = *pptDef;
    }
}

void SHPropertyBag_ReadRECTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc, const RECTL* prcDef)
{
    if (FAILED(SHPropertyBag_ReadRECTL(ppb, pszPropName, prc)))
    {
        *prc = *prcDef;
    }
}

void AppendScreenResString(const WCHAR* psz, WCHAR* pszBuff, ULONG cchBuff)
{
    StrCpyNW(pszBuff, psz, cchBuff);
    ULONG cch = lstrlenW(pszBuff);
    SHGetPerScreenResName(pszBuff + cch, cchBuff- cch, 0);
}

HRESULT SHPropertyBag_ReadStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadStream(ppb, szScreenResProp, ppstm);
}

HRESULT SHPropertyBag_WriteStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteStream(ppb, szScreenResProp, pstm);
}

HRESULT SHPropertyBag_ReadPOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadPOINTS(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_WritePOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WritePOINTS(ppb, szScreenResProp, ppt);
}

void SHPropertyBag_ReadDWORDScreenResDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dw)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    SHPropertyBag_ReadDWORDDef(ppb, szScreenResProp, pdw, dw);
}

HRESULT SHPropertyBag_WriteDWORDScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const DWORD dw)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteDWORD(ppb, szScreenResProp, dw);
}

HRESULT SHPropertyBag_ReadPOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadPOINTL(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_WritePOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WritePOINTL(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_ReadRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadRECTL(ppb, szScreenResProp, prc);
}

HRESULT SHPropertyBag_WriteRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteRECTL(ppb, szScreenResProp, prc);
}

HRESULT SHPropertyBag_DeleteScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_Delete(ppb, szScreenResProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\rpctimeout.cpp ===
#include "stock.h"
#pragma hdrstop

#include "rpctimeout.h"

WINOLEAPI CoCancelCall(IN DWORD dwThreadId, IN ULONG ulTimeout);
WINOLEAPI CoEnableCallCancellation(IN LPVOID pReserved);
WINOLEAPI CoDisableCallCancellation(IN LPVOID pReserved);

void CRPCTimeout::_Callback(PVOID lpParameter, BOOLEAN)
{
    CRPCTimeout *self = reinterpret_cast<CRPCTimeout *>(lpParameter);
    if (SUCCEEDED(CoCancelCall(self->_dwThreadId, 0)))
    {
        self->_fTimedOut = TRUE;
    }
}

#define DEFAULT_RPCTIMEOUT      5000        // totally arbitrary number
#define REPEAT_RPCTIMEOUT       1000        // Re-cancel every second until disarmed

void CRPCTimeout::Init()
{
    _dwThreadId = GetCurrentThreadId();
    _fTimedOut = FALSE;
    _hrCancelEnabled = E_FAIL;
    _hTimer = NULL;
}

void CRPCTimeout::Arm(DWORD dwTimeout)
{
    Disarm();

    if (dwTimeout == 0)
    {
        dwTimeout = DEFAULT_RPCTIMEOUT;
    }


    // If this fails, then we don't get a cancel thingie; oh well.
    _hrCancelEnabled = CoEnableCallCancellation(NULL);
    if (SUCCEEDED(_hrCancelEnabled))
    {
        _hTimer = SHSetTimerQueueTimer(NULL, _Callback, this,
                                       dwTimeout, REPEAT_RPCTIMEOUT, NULL, 0);
    }
}

void CRPCTimeout::Disarm()
{
    if (SUCCEEDED(_hrCancelEnabled))
    {
        _hrCancelEnabled = E_FAIL;
        CoDisableCallCancellation(NULL);

        if (_hTimer)
        {
            SHCancelTimerQueueTimer(NULL, _hTimer);
            _hTimer = NULL;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\native.cpp ===
//
//  native.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//
#include "stock.h"
#pragma hdrstop

#include <vdate.h>
#include "shellp.h"
#include <regstr.h>

// get the name and flags of an absolute IDlist
// in:
//      dwFlags     SHGDN_ flags as hints to the name space GetDisplayNameOf() function
//
// in/out:
//      *pdwAttribs (optional) return flags

STDAPI SHGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        VDATEINPUTBUF(pszName, TCHAR, cchName);
        *pszName = 0;
    }

    HRESULT hrInit = SHCoInitialize();

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        if (pszName)
            hr = DisplayNameOf(psf, pidlLast, dwFlags, pszName, cchName);

        if (SUCCEEDED(hr) && pdwAttribs)
        {
            RIP(*pdwAttribs);    // this is an in-out param
            *pdwAttribs = SHGetAttributes(psf, pidlLast, *pdwAttribs);
        }

        psf->Release();
    }

    SHCoUninitialize(hrInit);
    return hr;
}

STDAPI_(DWORD) GetUrlScheme(LPCTSTR pszUrl)
{
    if (pszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        if (SUCCEEDED(ParseURL(pszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}

//
//  returns
//
//      TRUE if the key is present and nonzero.
//      FALSE if the key is present and zero.
//      -1 if the key is not present.
//

BOOL GetExplorerUserSetting(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPathExplorer[MAX_PATH];
    DWORD cbSize = ARRAYSIZE(szPath);
    DWORD dwType;

    PathCombine(szPathExplorer, REGSTR_PATH_EXPLORER, pszSubKey);
    if (ERROR_SUCCESS == SHGetValue(hkeyRoot, szPathExplorer, pszValue, 
            &dwType, szPath, &cbSize))
    {
        // Zero in the DWORD case or NULL in the string case
        // indicates that this item is not available.
        if (dwType == REG_DWORD)
            return *((DWORD*)szPath) != 0;
        else
            return (TCHAR)szPath[0] != 0;
    }

    return -1;
}

//
//  This function allows a feature to be controlled by both a user setting
//  or a policy restriction.  The policy restriction is first checked.
//
//  If the value is 1, then the action is restricted.
//  If the value is 2, then the action is allowed.
//  If the value is absent or 0, then we look at the user setting.
//
//  If the user setting is present, then ROUS_KEYALLOWS and ROUS_KEYRESTRICTS
//  controls the return value.  ROUS_KEYALLOWS means that a nonzero user
//  setting allows the action.  ROUS_KEYRESTRICTS means that a nonzero user
//  setting restricts the action.
//
//  If the user setting is absent, then ROUS_DEFAULTALLOW and
//  ROUS_DESFAULTRESTRICT controls the default return value.
//
STDAPI_(BOOL) IsRestrictedOrUserSetting(HKEY hkeyRoot, RESTRICTIONS rest, LPCTSTR pszSubKey, LPCTSTR pszValue, UINT flags)
{
    // See if the system policy restriction trumps

    DWORD dwRest = SHRestricted(rest);

    if (dwRest == 1)
        return TRUE;

    if (dwRest == 2)
        return FALSE;

    //
    //  Restriction not in place or defers to user setting.
    //
    BOOL fValidKey = GetExplorerUserSetting(hkeyRoot, pszSubKey, pszValue);

    switch (fValidKey)
    {
    case 0:     // Key is present and zero
        if (flags & ROUS_KEYRESTRICTS)
            return FALSE;       // restriction not present
        else
            return TRUE;        // ROUS_KEYALLOWS, value is 0 -> restricted

    case 1:     // Key is present and nonzero

        if (flags & ROUS_KEYRESTRICTS)
            return TRUE;        // restriction present -> restricted
        else
            return FALSE;       // ROUS_KEYALLOWS, value is 1 -> not restricted

    default:
        ASSERT(0);  // _GetExplorerUserSetting returns exactly 0, 1 or -1.
        // Fall through

    case -1:    // Key is not present
        return (flags & ROUS_DEFAULTRESTRICT);
    }

    /*NOTREACHED*/
}

//
// Repair font attributes that don't work on certain languages.
//
STDAPI_(void) SHAdjustLOGFONT(IN OUT LOGFONT *plf)
{
    ASSERT(plf);

    //
    // FE fonts don't look good in bold since the glyphs are intricate
    // and converting them to bold turns them into a black blob.
    //
    if (plf->lfCharSet == SHIFTJIS_CHARSET||
        plf->lfCharSet == HANGEUL_CHARSET ||
        plf->lfCharSet == GB2312_CHARSET  ||
        plf->lfCharSet == CHINESEBIG5_CHARSET)
    {
        if (plf->lfWeight > FW_NORMAL)
            plf->lfWeight = FW_NORMAL;
    }
}


//
//  Some of our registry keys were used prior to MUI, so for compat
//  reasons, apps have to put non-MUI strings there; otherwise,
//  downlevel clients will display at-signs which is kinda ugly.
//
//  So the solution for these keys is to store the non-MUI string
//  in the legacy location, but put the MUI version in the
//  "LocalizedString" value.
//
STDAPI SHLoadLegacyRegUIString(HKEY hk, LPCTSTR pszSubkey, LPTSTR pszOutBuf, UINT cchOutBuf)
{
    HKEY hkClose = NULL;

    ASSERT(cchOutBuf);
    pszOutBuf[0] = TEXT('\0');

    if (pszSubkey && *pszSubkey)
    {
        DWORD dwError = RegOpenKeyEx(hk, pszSubkey, 0, KEY_QUERY_VALUE, &hkClose);
        if (dwError != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(dwError);
        }
        hk = hkClose;
    }

    HRESULT hr = SHLoadRegUIString(hk, TEXT("LocalizedString"), pszOutBuf, cchOutBuf);
    if (FAILED(hr) || pszOutBuf[0] == TEXT('\0'))
    {
        hr = SHLoadRegUIString(hk, TEXT(""), pszOutBuf, cchOutBuf);
    }

    if (hkClose)
    {
        RegCloseKey(hkClose);
    }

    return hr;
}

STDAPI_(TCHAR) SHFindMnemonic(LPCTSTR psz)
{
    ASSERT(psz);
    TCHAR tchDefault = *psz;                // Default is first character
    LPCTSTR pszAmp;

    while ((pszAmp = StrChr(psz, TEXT('&'))) != NULL)
    {
        switch (pszAmp[1])
        {
        case TEXT('&'):         // Skip over &&
            psz = pszAmp + 2;
            continue;

        case TEXT('\0'):        // Ignore trailing ampersand
            return tchDefault;

        default:
            return pszAmp[1];
        }
    }
    return tchDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\setmodebias.cpp ===
//----------------------------------------------------------------------
// SetModeBias.cpp
//
// Utility function to set to input bias mode
//
#include "stock.h"
#pragma hdrstop
#include <imm.h>

//----------------------------------------------------------------------
void SetModeBias(DWORD dwMode)
{
    if (IsOS(OS_TABLETPC))
    {
        static UINT s_msgMSIMEModeBias = 0;
        HWND hwndIME = ImmGetDefaultIMEWnd(NULL);

        if (s_msgMSIMEModeBias == 0)
        {
            s_msgMSIMEModeBias = RegisterWindowMessage(RWM_MODEBIAS);
        }

        if (hwndIME && s_msgMSIMEModeBias)
        {
            PostMessage(hwndIME, s_msgMSIMEModeBias, MODEBIAS_SETVALUE, dwMode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\runtask.cpp ===
#include "stock.h"
#pragma hdrstop

#include "runtask.h"

#define SUPERCLASS  

// #define TF_RUNTASK  TF_GENERAL
#define TF_RUNTASK  0
// #define TF_RUNTASKV TF_CUSTOM1     // verbose version
#define TF_RUNTASKV 0


// constructor
CRunnableTask::CRunnableTask(DWORD dwFlags)
{
    _lState = IRTIR_TASK_NOT_RUNNING;
    _dwFlags = dwFlags;

    ASSERT(NULL == _hDone);
    
    if (_dwFlags & RTF_SUPPORTKILLSUSPEND)
    {
        // we signal this on suspend or kill
        // Explicitly call the ANSI version so we don't need to worry
        // about whether we're being built UNICODE and have to switch
        // to a wrapper function...
        _hDone = CreateEventA(NULL, TRUE, FALSE, NULL);
    }

#ifdef DEBUG
    _dwTaskID = GetTickCount();

    TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): creating task", _dwTaskID);
#endif

    _cRef = 1;
}


// destructor
CRunnableTask::~CRunnableTask()
{
    DEBUG_CODE( TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): deleting task", _dwTaskID); )

    if (_hDone)
        CloseHandle(_hDone);
}


STDMETHODIMP CRunnableTask::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    if ( ppvObj == NULL )
    {
        return E_INVALIDARG;
    }
    if ( riid == IID_IRunnableTask )
    {
        *ppvObj = SAFECAST( this, IRunnableTask *);
        AddRef();
    }
    else
        return E_NOINTERFACE;


    return NOERROR;
}


STDMETHODIMP_(ULONG) CRunnableTask::AddRef()
{
    InterlockedIncrement(&_cRef);
    return _cRef;
}


STDMETHODIMP_ (ULONG) CRunnableTask::Release()
{
    if (0 == _cRef)
    {
        AssertMsg(0, TEXT("CRunnableTask::Release called too many times!"));
        return 0;
    }
    
    if ( InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Run method

         This does a lot of the state-related work, and then
         calls the derived-class's RunRT() method.
         
*/
STDMETHODIMP CRunnableTask::Run(void)
{
    HRESULT hr = E_FAIL;

    // Are we already running?
    if (_lState == IRTIR_TASK_RUNNING)
    {
        // Yes; nothing to do 
        hr = S_FALSE;
    }
    else if ( _lState == IRTIR_TASK_PENDING )
    {
        hr = E_FAIL;
    }
    else if ( _lState == IRTIR_TASK_NOT_RUNNING )
    {
        // Say we're running
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
        if ( lRes == IRTIR_TASK_PENDING )
        {
            _lState = IRTIR_TASK_FINISHED;
            return NOERROR;
        }

        if (_lState == IRTIR_TASK_RUNNING)
        {
            // Prepare to run 
            DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): initialize to run", _dwTaskID); )
            
            hr = RunInitRT();
            
            ASSERT(E_PENDING != hr);
        }

        if (SUCCEEDED(hr))
        {
            if (_lState == IRTIR_TASK_RUNNING)
            {
                // Continue to do the work
                hr = InternalResumeRT();
            }
            else if (_lState == IRTIR_TASK_SUSPENDED)
            {
                // it is possible that RunInitRT took a little longer to complete and our state changed
                // from running to suspended with _hDone signaled, which would cause us to not call
                // internal resume.  We simulate internal resume here
                if (_hDone)
                    ResetEvent(_hDone);
                hr = E_PENDING;
            }
        }

        if (FAILED(hr) && E_PENDING != hr)
        {
            DEBUG_CODE( TraceMsg(TF_WARNING, "CRunnableTask (%#lx): task failed to run: %#lx", _dwTaskID, hr); )
        }            

        // Are we finished?
        if (_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            // Yes
            _lState = IRTIR_TASK_FINISHED;
        }
    }
    
    return hr;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Kill method

*/
STDMETHODIMP CRunnableTask::Kill(BOOL fWait)
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return S_FALSE;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): killing task", _dwTaskID); )

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )

        _lState = lRes;
    }
    else if (_hDone)
    {
        // signal the event it is likely to be waiting on
        SetEvent(_hDone);
    }

    return KillRT(fWait);
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Suspend method

*/
STDMETHODIMP CRunnableTask::Suspend( void )
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return E_FAIL;
    
    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): suspending task", _dwTaskID); )
    
    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);

    if (IRTIR_TASK_FINISHED == lRes)
    {
        // we finished before we could suspend
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )
        
        _lState = lRes;
        return NOERROR;
    }

    if (_hDone)
        SetEvent(_hDone);

    return SuspendRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Resume method

*/
STDMETHODIMP CRunnableTask::Resume(void)
{
    if (_lState != IRTIR_TASK_SUSPENDED)
        return E_FAIL;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): resuming task", _dwTaskID); )

    _lState = IRTIR_TASK_RUNNING;
    if (_hDone)
        ResetEvent(_hDone);

    return ResumeRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::IsRunning method

*/
STDMETHODIMP_( ULONG ) CRunnableTask:: IsRunning ( void )
{
    return _lState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\security.cpp ===
/*****************************************************************************\
    FILE: security.cpp

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/25/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/
#include "stock.h"
#pragma hdrstop

#include <mshtml.h>


/***************************************************************\
    DESCRIPTION:
        We are given a site via IObjectWithSite.  Obtain the host
    from there.

    These are the different scenarios to test against:
    1. HTA Content.
    2. HTA contains IFRAME to non-LocalZone.  That frame
       needs to be treated as unsafe because it hasn't been
       "sandboxed"
    3. HTA contains IFRAME to non-LocalZone except the IFRAME tag has
        <IFRAME APPLICATION="Yes" SRC="non-LocalZone:foo.htm" ...>
       so we need to treat this as safe.
    4. LocalZone Web page with Object.  It has an IFRAME to an
        non-LocalZone.  Is scripting from IFRAME to object allowed? [HUNTER?]
    5. non-LocalZone Web page.  It has an IFRAME to an LocalZone with Object.
        Is scripting from parent to IFRAME object allowed? [HUNTER?]
    6. LocalZone Web page.  It has 2 IFRAMEs.  One is in the LocalZone and
        has an Object.  The other is non-LocalZone.  Can the non-LocalZone
        script across frames to the object? [HUNTER?]
    7. VB or MFC host.
    8. HTML Mail Message with object.  This should be treated as
       non-LocalMachine? [HUNTER?]
\***************************************************************/
STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc)
{
    *ppHtmlDoc = NULL;

    if (!punk)
        return E_FAIL;
        
    *ppHtmlDoc = NULL;
    //  The window.external, jscript "new ActiveXObject" and the <OBJECT> tag
    //  don't take us down the same road.

    IOleClientSite *pClientSite;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IOleClientSite, &pClientSite));
    if (SUCCEEDED(hr))
    {
        //  <OBJECT> tag path
        IOleContainer *pContainer;

        // This will return the interface for the current FRAME containing the
        // OBJECT tag.  We will only check that frames security because we
        // rely on MSHTML to block cross frame scripting when it isn't safe.
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
            pContainer->Release();
        }
    
        if (FAILED(hr))
        {
            //  window.external path
            IWebBrowser2 *pWebBrowser2;
            hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
            if (SUCCEEDED(hr))
            {
                IDispatch *pDispatch;
                hr = pWebBrowser2->get_Document(&pDispatch);
                if (SUCCEEDED(hr))
                {
                    hr = pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
                    pDispatch->Release();
                }
                pWebBrowser2->Release();
            }
        }
        pClientSite->Release();
    }
    else
    {
        //  jscript path
        hr = IUnknown_QueryService(punk, SID_SContainerDispatch, IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
    }

    ASSERT(FAILED(hr) || (*ppHtmlDoc));

    return hr;
}


/***************************************************************\
    DESCRIPTION:
        This function is supposed to find out the zone from the
    specified URL or Path.
\***************************************************************/
STDAPI LocalZoneCheckPath(LPCWSTR pszUrl, IUnknown * punkSite)
{
    DWORD dwZoneID = URLZONE_UNTRUSTED;
    HRESULT hr = GetZoneFromUrl(pszUrl, punkSite, &dwZoneID);
    
    if (SUCCEEDED(hr))
    {
        if (dwZoneID == URLZONE_LOCAL_MACHINE)
            hr = S_OK;
        else
            hr = E_ACCESSDENIED;
    }

    return hr;
}

/***************************************************************\
    DESCRIPTION:
        Get the zone from the specified URL or Path.
\***************************************************************/
STDAPI GetZoneFromUrl(LPCWSTR pszUrl, IUnknown * punkSite, DWORD * pdwZoneID)
{
    HRESULT hr = E_FAIL;
    if (pszUrl && pdwZoneID) 
    {
        IInternetSecurityManager * pSecMgr = NULL;

        // WARNING: IInternetSecurityManager is the guy who translates
        //   from URL->Zone.  If we CoCreate this object, it will do the
        //   default mapping.  Some hosts, like Outlook Express, want to
        //   over ride the default mapping in order to sandbox some content.
        //   I beleive this could be used to force HTML in an email
        //   message (C:\mailmessage.eml) to act like it's from a more
        //   untrusted zone.  We use QueryService to get this interface
        //   from our host.  This info is from SanjayS. (BryanSt 8/21/1999)
        hr = IUnknown_QueryService(punkSite, SID_SInternetSecurityManager, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
        if (SUCCEEDED(hr))
        {
            hr = pSecMgr->MapUrlToZone(pszUrl, pdwZoneID, 0);
            ATOMICRELEASE(pSecMgr);
        }

        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
            if (SUCCEEDED(hr))
            {
                hr = pSecMgr->MapUrlToZone(pszUrl, pdwZoneID, 0);
                ATOMICRELEASE(pSecMgr);
            }
        }
    }
    else 
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


/***************************************************************\
    DESCRIPTION:
        We are given a site via IObjectWithSite.  See if that host
    maps to the Local Zone.

    These are the different scenarios to test against:
    1. HTA Content.
    2. HTA contains IFRAME to non-LocalZone.  That frame
       needs to be treated as unsafe because it hasn't been
       "sandboxed"
    3. HTA contains IFRAME to non-LocalZone except the IFRAME tag has
        <IFRAME APPLICATION="Yes" SRC="non-LocalZone:foo.htm" ...>
       so we need to treat this as safe.
    4. LocalZone Web page with Object.  It has an IFRAME to an
        non-LocalZone.  Is scripting from IFRAME to object allowed? [HUNTER?]
    5. non-LocalZone Web page.  It has an IFRAME to an LocalZone with Object.
        Is scripting from parent to IFRAME object allowed? [HUNTER?]
    6. LocalZone Web page.  It has 2 IFRAMEs.  One is in the LocalZone and
        has an Object.  The other is non-LocalZone.  Can the non-LocalZone
        script across frames to the object? [HUNTER?]
    7. VB or MFC host.
    8. HTML Mail Message with object.  This should be treated as
       non-LocalMachine? [HUNTER?]
\***************************************************************/
STDAPI LocalZoneCheck(IUnknown *punkSite)
{
    DWORD dwZoneID = URLZONE_UNTRUSTED;
    HRESULT hr = GetZoneFromSite(punkSite, &dwZoneID);
    
    if (SUCCEEDED(hr))
    {
        if (dwZoneID == URLZONE_LOCAL_MACHINE)
            hr = S_OK;
        else
            hr = E_ACCESSDENIED;
    }

    return hr;
}

STDAPI GetZoneFromSite(IUnknown *punkSite, DWORD *pdwZoneID)
{
    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
    {
        *pdwZoneID = URLZONE_UNTRUSTED;
        return S_FALSE;
    }

    HRESULT hr = E_ACCESSDENIED;
    BOOL fTriedBrowser = FALSE;

    // Try to find the original template path for zone checking
    IOleCommandTarget * pct;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        VARIANT vTemplatePath;
        vTemplatePath.vt = VT_EMPTY;
        if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vTemplatePath) == S_OK)
        {
            fTriedBrowser = TRUE;
            if (vTemplatePath.vt == VT_BSTR)
            {
                hr = GetZoneFromUrl(vTemplatePath.bstrVal, punkSite, pdwZoneID);
            }

            // We were able to talk to the browser, so don't fall back on Trident because they may be
            // less secure.
            fTriedBrowser = TRUE;
            VariantClear(&vTemplatePath);
        }
        pct->Release();
    }

    // If this is one of those cases where the browser doesn't exist (AOL, VB, ...) then
    // we will check the scripts security.  If we did ask the browser, don't ask trident
    // because the browser is often more restrictive in some cases.
    if (!fTriedBrowser && (hr != S_OK))
    {
        // Try to use the URL from the document to zone check 
        IHTMLDocument2 *pHtmlDoc;

        /***************************************************************\
         NOTE:
         1. If punkSite points into an <IFRAME APPLICATION="yes"> in a
            HTA file, then the URL GetHTMLDoc2() returns
            is for the IFRAME SRC..

         BUGS?:
         1. If this isn't an HTML container, the we will be saying that it
            isn't safe.  For example, if the container is VB and they support
            the security interfaces, then we will assume it isn't safe when
            it is.  (Is there an IInternet interface that will work in this
            case?)
        \***************************************************************/
        if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR bstrURL;

            /***************************************************************\
             WARNING:  (Security Holes?)
                I think this is fundamentally flawed because:
             1. If this HTML container isn't safe but it's URL maps to the
                Local Zone, then we have a problem.  This may happen with
                email messages, especially if they are saved to a file.
                If the user reopens a saved .eml file, it will be hosted in
                it's mail container that may support the IInternet interface
                to indicate that it's in an untrusted zone.  Will we get
                a Local Zone URL in that case?

            TO INVESTIGATE: (HunterH?)
             1. What is the parent HTML is LocalZone but the subframes aren't.
                Will trident block cross frame scripting?
            \***************************************************************/
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrURL)))
            {
                // NOTE: the above URL is improperly escaped, this is
                // due to app compat. if you depend on this URL being valid
                // use another means to get this

                hr = GetZoneFromUrl(bstrURL, punkSite, pdwZoneID);
                SysFreeString(bstrURL);
            }
            pHtmlDoc->Release();
        }
    }
                            
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shclient.cpp ===
#include "stock.h"
#pragma hdrstop

//
//  Return root hkey and default client name.  The caller is expected to
//  retrieve the command from hkey\default\shell\open\command.
//
STDAPI_(HKEY) _GetClientKeyAndDefaultW(LPCWSTR pwszClientType, LPWSTR pwszDefault, DWORD cchDefault)
{
    HKEY hkClient = NULL;

    ASSERT(cchDefault);     // This had better be a nonempty buffer

    // Borrow pwszDefault as a scratch buffer
    wnsprintfW(pwszDefault, cchDefault, L"SOFTWARE\\Clients\\%s", pwszClientType);

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, pwszDefault, 0, KEY_READ, &hkClient))
    {
        DWORD dwSize = cchDefault * sizeof(*pwszDefault);
        pwszDefault[0] = 0; // in case of failure
        RegQueryValueExW(hkClient, NULL, NULL, NULL, (LPBYTE)pwszDefault, &dwSize);

        // If no default client, then fail
        if (!pwszDefault[0])
        {
            RegCloseKey(hkClient);
            hkClient = NULL;
        }

    } else if (StrCmpIW(pwszClientType, L"webbrowser") == 0)
    {
        // In theory, we could use
        // RegOpenKeyExW(HKEY_CLASSES_ROOT, NULL, 0, KEY_READ, &hkClient)
        // but that just returns HKEY_CLASSES_ROOT back anyway.
        hkClient = HKEY_CLASSES_ROOT;
        StrCpyNW(pwszDefault, L"http", cchDefault);
    }
    return hkClient;
}

// Gets the path to open the default Mail, News, etc Client.
STDAPI SHGetDefaultClientOpenCommandW(LPCWSTR pwszClientType,
        LPWSTR pwszClientCommand, DWORD dwCch,
        OPTIONAL LPWSTR pwszClientParams, DWORD dwCchParams)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkClient;
    WCHAR wszDefault[MAX_PATH];

    ASSERT(pwszClientCommand && dwCch);
    ASSERT(pwszClientParams == NULL || dwCchParams);

    hkClient = _GetClientKeyAndDefaultW(pwszClientType, wszDefault, ARRAYSIZE(wszDefault));
    if (hkClient)
    {
        // For the webbrowser client, do not pass any command line arguments
        // at all.  This suppresses the "-nohome" flag that IE likes to throw
        // in there.  Also, if we end up being forced to use the Protocol key,
        // then strip the args there, too.
        BOOL fStripArgs = hkClient == HKEY_CLASSES_ROOT;

        BOOL iRetry = 0;
        int cchDefault = lstrlenW(wszDefault);
    again:
        StrCatBuffW(wszDefault, L"\\shell\\open\\command", ARRAYSIZE(wszDefault));

        // convert characters to bytes
        DWORD cb = dwCch * (sizeof(WCHAR)/sizeof(BYTE));
        // the default value of this key is the actual command to run the app
        DWORD dwError;
        dwError = SHGetValueW(hkClient, wszDefault, NULL, NULL, (LPBYTE) pwszClientCommand, &cb);

        if (dwError == ERROR_FILE_NOT_FOUND && iRetry == 0 &&
            StrCmpICW(pwszClientType, L"mail") == 0)
        {
            // Sigh, Netscape doesn't register a shell\open\command; we have to
            // look in Protocols\mailto\shell\open\command instead.
            wszDefault[cchDefault] = L'\0';
            StrCatBuffW(wszDefault, L"\\Protocols\\mailto", ARRAYSIZE(wszDefault));
            fStripArgs = TRUE;
            iRetry++;
            goto again;
        }

        if (dwError == ERROR_SUCCESS)
        {
            // Sigh.  Netscape forgets to quote its EXE name.
            PathProcessCommand(pwszClientCommand, pwszClientCommand, dwCch,
                               PPCF_ADDQUOTES | PPCF_NODIRECTORIES | PPCF_LONGESTPOSSIBLE);

            if (pwszClientParams)
            {
                if (fStripArgs)
                {
                    pwszClientParams[0] = 0;
                }
                else
                {
                    StrCpyNW(pwszClientParams, PathGetArgsW(pwszClientCommand), dwCchParams);
                }
            }
            PathRemoveArgsW(pwszClientCommand);
            PathUnquoteSpaces(pwszClientCommand);

            // Bonus hack for Netscape!  To read email you have to pass the
            // "-mail" command line option even though there is no indication
            // anywhere that this is the case.
            if (iRetry > 0 && pwszClientParams &&
                StrCmpIW(PathFindFileName(pwszClientCommand), L"netscape.exe") == 0)
            {
                StrCpyNW(pwszClientParams, L"-mail", dwCchParams);
            }

            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }

        // Do not RegCloseKey(HKEY_CLASSES_ROOT) or the world will end!
        if (hkClient != HKEY_CLASSES_ROOT)
            RegCloseKey(hkClient);
    }
    return hr;
}

// Gets the friendly name for the default Mail, News, etc Client.
// Note that this doesn't work for Webbrowser.

STDAPI SHGetDefaultClientNameW(LPCWSTR pwszClientType,
        LPWSTR pwszBuf, DWORD dwCch)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkClient;
    WCHAR wszDefault[MAX_PATH];

    ASSERT(pwszBuf && dwCch);

    hkClient = _GetClientKeyAndDefaultW(pwszClientType, wszDefault, ARRAYSIZE(wszDefault));
    if (hkClient && hkClient != HKEY_CLASSES_ROOT)
    {
        LONG cbValue = dwCch * sizeof(TCHAR);
        if (RegQueryValueW(hkClient, wszDefault, pwszBuf, &cbValue) == ERROR_SUCCESS &&
            pwszBuf[0])
        {
            hr = S_OK;
        }
        RegCloseKey(hkClient);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shstr.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class Implementation

    shstr.cpp

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


 Abstract:

    this allows automatic resizing and stuff.

  NOTE: this class is specifically designed to be used as a stack variable


--*/

#include "stock.h"
#pragma hdrstop

#include <shstr.h>


#define MALLOC(c)       LocalAlloc(LPTR, (c))
#define FREE(p)         LocalFree(p)

//
//  ShStr Public Methods
//

//
//  Constructors
//

ShStr :: ShStr () 
{
    _szDefaultBuffer[0] = '\0';
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}


/**************
    StrStr SetStr() methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/

HRESULT 
ShStr :: SetStr (LPCSTR pszStr)
{
    Reset();
    
    return _SetStr(pszStr);

}

HRESULT 
ShStr :: SetStr (LPCSTR pszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pszStr, cchStr);

}

HRESULT 
ShStr :: SetStr (LPCWSTR pwszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pwszStr, cchStr);

}


HRESULT
ShStr :: Append(LPCTSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_OK;

    if(pszStr)
    {
        DWORD cchLen = GetLen();

        if(cchStr == (DWORD) -1)
            cchStr = lstrlen(pszStr);

        //
        //  StrCpyN automagically appends the null term, 
        //  so we need to give room for it
        //
        cchStr++;

        if(SUCCEEDED(SetSize(cchStr + cchLen)))
            StrCpyN(_pszStr + cchLen, pszStr, cchStr);
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

ShStr *
ShStr :: Clone()
{
    ShStr *pshstr = new ShStr;

    if (pshstr)
    {
        pshstr->SetStr(_pszStr);
    
        if(pshstr->IsValid())
            return pshstr;
    }

    if(pshstr)
        delete pshstr;

    return NULL;
}

LPSTR 
ShStr :: CloneStrA()
#ifdef UNICODE
{
    LPSTR pszStr = NULL;

    if(_pszStr)
    {
        DWORD cchStr;
    
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            _pszStr, -1,
            NULL, 0,
            NULL, NULL);

        ASSERT(cchStr);

        if(cchStr)
        {
            pszStr = (LPSTR) MALLOC (CbFromCch(cchStr +1));

            if(pszStr)
            {
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    _pszStr, -1,
                    pszStr, cchStr,
                    NULL, NULL);
                ASSERT (cchStr);
            }
        }
    }

    return pszStr;
}

#else //!UNICODE

    {return _pszStr ? StrDupA(_pszStr) : NULL;}
#endif //UNICODE


#ifdef UNICODE
  
#endif
LPWSTR 
ShStr :: CloneStrW()
#ifdef UNICODE
    {return _pszStr ? StrDupW(_pszStr) : NULL;}
#else //!UNICODE
{
    LPWSTR pwsz;
    DWORD cch = lstrlenA(_pszStr) +1;

    pwsz = (LPWSTR) MALLOC (sizeof(WCHAR) * cch);
    
    if(pwsz)
        MultiByteToWideChar(CP_ACP, 0,
            _pszStr, -1,
            pwsz, cch);

    return pwsz;
}
#endif //UNICODE


/**************
    ShStr Utility methods

**************/


/**************
    ShStr SetSize method

    Sets the size of the internal buffer if larger than default

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT
ShStr :: SetSize(DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD cchNewSize = _cchSize;

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    // so that we always allocate in increments
    while (cchSize > cchNewSize)
        cchNewSize <<= 2;
    
    if(cchNewSize != _cchSize)
    {
        if(cchNewSize > DEFAULT_SHSTR_LENGTH)
        {
            LPTSTR psz;

            psz = (LPTSTR) LocalAlloc(LPTR, CbFromCch(cchNewSize));
    
            if(psz)
            {
                StrCpyN(psz, _pszStr, cchSize);
                Reset();
                _cchSize = cchNewSize;
                _pszStr = psz;
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (_pszStr && _cchSize) 
                StrCpyN(_szDefaultBuffer, _pszStr, ARRAYSIZE(_szDefaultBuffer));

            Reset();

            _pszStr = _szDefaultBuffer;
        }
    }

    return hr;
}

#ifdef DEBUG
BOOL
ShStr :: IsValid()
{
    BOOL fRet = TRUE;

    if(!_pszStr)
        fRet = FALSE;

    ASSERT( ((_cchSize != ARRAYSIZE(_szDefaultBuffer)) && (_pszStr != _szDefaultBuffer)) ||
            ((_cchSize == ARRAYSIZE(_szDefaultBuffer)) && (_pszStr == _szDefaultBuffer)) );

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    return fRet;
}
#endif //DEBUG

VOID 
ShStr :: Reset()
{
    if (_pszStr && (_cchSize != ARRAYSIZE(_szDefaultBuffer))) 
        LocalFree(_pszStr);

    _szDefaultBuffer[0] = TEXT('\0');
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)
VOID
ShStr :: Trim()
{

    if(_pszStr)
    {
        // APPCOMPAT - NETSCAPE compatibility - zekel 29-JAN-97
        //  we want to leave one space in the string
        TCHAR chFirst = *_pszStr;

        //  first trim the backside
        TCHAR *pchLastWhite = NULL;
        LPTSTR pch = _pszStr;
        
        // the front side
        while (*pch && IsWhite(*pch))
            pch = CharNext(pch);

        if (pch > _pszStr)
        {
            LPTSTR pchDst = _pszStr;

            while (*pchDst = *pch)
            {
                pch = CharNext(pch);
                pchDst = CharNext(pchDst);
            }
        }

        // then the backside
        for (pch = _pszStr; *pch; pch = CharNext(pch))
        {
            if(pchLastWhite && !IsWhite(*pch))
                pchLastWhite = NULL;
            else if(!pchLastWhite && IsWhite(*pch))
                pchLastWhite = pch;
        }

        if(pchLastWhite)
            *pchLastWhite = TEXT('\0');

        if(TEXT(' ') == chFirst && !*_pszStr)
        {
            _pszStr[0] = TEXT(' ');
            _pszStr[1] = TEXT('\0');
        }
    }
}

    


//
//  ShStr Private Methods
//


/**************
    StrStr Set* methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT 
ShStr :: _SetStr(LPCSTR pszStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr)
    {
        DWORD cchStr;

        cchStr = lstrlenA(pszStr);
    
        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if (SUCCEEDED(hr))
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0,
                    pszStr, -1,
                    _pszStr, _cchSize);
#else //!UNICODE
                lstrcpyA(_pszStr, pszStr);
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr(LPCSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
            cchStr = lstrlenA(pszStr);

        hr = SetSize(cchStr +1);

        if(SUCCEEDED(hr))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0,
                pszStr, cchStr,
                _pszStr, _cchSize);
            _pszStr[cchStr] = TEXT('\0');

#else //!UNICODE
            StrCpyN(_pszStr, pszStr, (++cchStr < _cchSize ? cchStr : _cchSize) );
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr (LPCWSTR pwszStr, DWORD cchStrIn)
{
    DWORD cchStr = cchStrIn;
    HRESULT hr = S_FALSE;

    if(pwszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
#ifdef UNICODE
            cchStr = lstrlen(pwszStr);
#else //!UNICODE
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            pwszStr, cchStrIn,
            NULL, 0,
            NULL, NULL);
#endif //UNICODE

        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if(SUCCEEDED(hr))
            {
#ifdef UNICODE 
                StrCpyN(_pszStr, pwszStr, (cchStr + 1< _cchSize ? cchStr + 1: _cchSize));
#else //!UNICODE
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    pwszStr, cchStrIn,
                    _pszStr, _cchSize,
                    NULL, NULL);
                _pszStr[cchStr < _cchSize ? cchStr : _cchSize] = TEXT('\0');
                ASSERT (cchStr);
#endif //UNICODE
            }
        }
#ifdef DEBUG
        else
        {
            DWORD dw;
            dw = GetLastError();
        }
#endif //DEBUG

    }
#ifdef DEBUG
    else
    {
        DWORD dw;
        dw = GetLastError();
    }
#endif //DEBUG

    return hr;
}

#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96
//
//  UrlStr Methods
//
  
  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl)
{
    return SetUrl(pszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl)
{
    return SetUrl(pwszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pszUrl, cchUrl);
    return *this;
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pwszUrl, cchUrl);
    return *this;
}

 
UrlStr::operator LPCTSTR()
{
    return _strUrl.GetStr();
}

  
UrlStr::operator SHSTR()
{
    return _strUrl;
}




  HRESULT
UrlStr::Combine(LPCTSTR pszUrl, DWORD dwFlags)
{
    SHSTR strRel;
    SHSTR strOut;
    HRESULT hr;

    strRel.SetStr(pszUrl);

    hr = UrlCombine(_strUrl.GetStr(), 
    hr = SHUrlParse(&_strUrl, &strRel, &strOut, NULL, URL_PARSE_CREATE);

    if(SUCCEEDED(hr))
        _strUrl = strOut;

    return hr;
}

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);
    HRESULT Encode(DWORD dwFlags);
    HRESULT EncodeSpaces()
        {return Encode(URL_ENCODE_SPACES_ONLY)}
    HRESULT Decode(DWORD dwFlags)
*/
#endif  //DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shco.c ===
#include "stock.h"
#pragma hdrstop

// Need to put into separate file because for some reason the /Gy compiler
// option doesn't work.

//
//  COM Initialization is weird due to multithreaded apartments.
//
//  If this thread has not called CoInitialize yet, but some other thread
//  in the process has called CoInitialize with the COINIT_MULTITHREADED,
//  then that infects our thread with the multithreaded virus, and a
//  COINIT_APARTMENTTHREADED will fail.
//
//  In this case, we must turn around and re-init ourselves as
//  COINIT_MULTITHREADED to increment the COM refcount on our thread.
//  If we didn't do that, and that other thread decided to do a
//  CoUninitialize, that >secretly< uninitializes COM on our own thread
//  and we fall over and die.
//
STDAPI SHCoInitialize(void)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shellacl.c ===
#include "stock.h"
#pragma hdrstop

#ifdef WINNT

//
// common SHELL_USER_SID's (needed for GetShellSecurityDescriptor)
//
const SHELL_USER_SID susCurrentUser = {0, 0, 0};                                                                            // the current user 
const SHELL_USER_SID susSystem = {SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID, 0};                                     // the "SYSTEM" group
const SHELL_USER_SID susAdministrators = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS};     // the "Administrators" group
const SHELL_USER_SID susPowerUsers = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS};    // the "Power Users" group
const SHELL_USER_SID susGuests = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS};             // the "Guests" group
const SHELL_USER_SID susEveryone = {SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID, 0};                                   // the "Everyone" group

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stock.h ===
//
// stock.h: shell\lib precompiled header file
//

#ifndef __STOCK_H__
#define __STOCK_H__

#ifndef STRICT
#define STRICT
#endif

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#define _SHLWAPI_       // Make sure we don't get declspec(dllimport) for these
#define _SHELL32_       // otherwise we get errors from the linker for the delayload
#define _OLE32_         // stubs

#include <windows.h>
#include <oleauto.h>
#include <exdisp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <shlobj.h>
#include <debug.h>
#include <port32.h>
#include <ccstock.h>

#include <shsemip.h>        // for _ILNext

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone   

// Some files are compiled twice: once for unicode and once for ansi.
// There are some functions which do not want to be declared twice
// (the ones which don't use string parameters).  Otherwise we'd get
// duplicate redefinitions.
//
// These are wrapped with #ifdef DECLARE_ONCE.
#ifdef UNICODE
#define DECLARE_ONCE
#else
#undef DECLARE_ONCE
#endif


// Note that CharNext is not supported on win95.  Normally we would
// include w95wraps.h, but comctl does not link to shlwapi and
// we don't want to add this dependency.
#ifdef UNICODE
// Note that this will still break if we ever go back to non-unicode
__inline LPWSTR CharNextWrapW_(LPWSTR psz) {return ++psz;}
#undef CharNext
#define CharNext CharNextWrapW_
#endif


#endif // __STOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\typelist.cpp ===
#include "stock.h"
#pragma hdrstop

STDAPI_(BOOL) IsTypeInList(LPCTSTR pszType, const LPCTSTR *arszList, UINT cList)
{
    BOOL fRet = FALSE;
    if (pszType && *pszType)
    {
        PCWSTR pszExt = NULL;
        PCWSTR pszProgID = NULL;
        if (*pszType == L'.')
            pszExt = pszType;
        else
            pszProgID = pszType;
        
        WCHAR szProgID[MAX_PATH];
        DWORD cb = sizeof(szProgID);
        if (!pszProgID)
        {
            ASSERT(pszExt);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb))
                pszProgID = szProgID;
            else
                pszProgID = NULL;
        }

        for (UINT n = 0; FALSE == fRet && n < cList; n++)
        {
            // check extension if available
            if (pszExt)
            {
                fRet = (0 == StrCmpI(pszExt, arszList[n]));
            }

            if (!fRet && pszProgID)     
            {
                WCHAR szTempID[MAX_PATH];
                ULONG cb = sizeof(szTempID);
                if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, arszList[n], NULL, NULL, szTempID, &cb))
                {
                    fRet = 0 == StrCmpIW(pszProgID, szTempID);
                }
            }
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stock.inc ===
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETPATH      = obj
TARGETTYPE      = LIBRARY

GENERATED_SOURCES =  \
                  $(O)\dkaa.cpp     \
                  $(O)\dkaw.cpp     \
                  $(O)\shstra.cpp   \
                  $(O)\shstrw.cpp   \
                  $(O)\nativea.cpp  \
                  $(O)\nativew.cpp  \
                  $(O)\infotipa.cpp \
                  $(O)\infotipw.cpp

SOURCES         = ..\autosecurity.cpp \
                  ..\bindctx.cpp    \
                  ..\caggunk.cpp    \
                  ..\cnctnpt.cpp    \
                  ..\cobjsafe.cpp   \
                  ..\cowsite.cpp    \
                  ..\cstrinout.cpp  \
                  ..\crst.cpp       \
                  ..\debug.c        \
                  ..\dllreghelper.cpp     \
                  ..\dllver.cpp     \
                  ..\dobjutil.cpp   \
                  ..\dspsprt.cpp    \
                  ..\expdsprt.cpp   \
                  ..\idhidden.cpp   \
                  ..\ieutil.cpp     \
                  ..\isos.cpp       \
                  ..\mediautil.cpp  \
                  ..\profsvc.cpp    \
                  ..\propertybag.cpp      \
                  ..\rpctimeout.cpp \
                  ..\runtask.cpp    \
                  ..\security.cpp   \
                  ..\setmodebias.cpp \
                  ..\shclient.cpp   \
                  ..\shco.c         \
                  ..\shellacl.c     \
                  ..\stdenum.cpp    \
                  ..\typelist.cpp   \
                  ..\util.cpp       \
                  ..\valid.c        \
                  ..\varutil.cpp    \
                  ..\wnetutil.cpp   \
                  $(GENERATED_SOURCES)

OBJLIBFILES     = ..\stockthk\$(O)\stockthk.lib

NTTARGETFILE1   = $(CCSHELL_DIR)\lib\$(O)\$(TARGETNAME).lib

PRECOMPILED_INCLUDE= ..\stock.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StandardEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//

#include "stock.h"
#pragma hdrstop

#include "stdenum.h"

// Used by creators of CStandardEnum
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,      // dest
    const void *pSource,    // src
    DWORD       dwSize      // size, ignored, since it's always 4
)
{
    IUnknown *pUnk = *((IUnknown **)pSource);
    *((IUnknown **)pDest) = pUnk;
    pUnk->AddRef();
}

void* CStandardEnum_CreateInstance(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                                                  void (WINAPI * pfnCopyElement)(void *, const void *, DWORD))
{
    return (LPVOID)new CStandardEnum(riid, fMembersAreInterfaces, cElement, cbElement, rgElements, pfnCopyElement);
}

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    BOOL fMembersAreInterfaces,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: m_cRef(1),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement),
  m_fMembersAreInterfaces(fMembersAreInterfaces)
{
    m_pEnumClonedFrom = NULL;
    if(m_fMembersAreInterfaces)
    {
        if(m_rgElements)
        {
            int i;
            for(i=0; i<m_cElements; i++)
            {
                LPUNKNOWN *ppunk = (IUnknown **)GetNthElement(i);
                (*ppunk)->AddRef();
            }
        }
    }
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
    {
        m_pEnumClonedFrom->Release();
    }
    else
    {
        if (m_rgElements)
        {
            if(m_fMembersAreInterfaces)
            {
                int i;

                for(i=0; i<m_cElements; i++)
                {
                    LPUNKNOWN *ppunk = (IUnknown **)GetNthElement(i);
                    (*ppunk)->Release();
                }
            }
            GlobalFree(m_rgElements);
        }
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    *ppvObjOut = NULL;
    if (IsEqualIID(riid, m_iid))
    {
        *ppvObjOut = (IEnumGeneric *)this;
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = (IUnknown *)this;
    }

    if (*ppvObjOut)
    {
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

ULONG CStandardEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG CStandardEnum::Release(void)
{
    int n = --m_cRef;

    if (n == 0)
        delete this;

    return(n);
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = GetNthElement(m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum = new CStandardEnum(m_iid, m_fMembersAreInterfaces, m_cElements, 
                                 m_cbElementSize, m_rgElements, m_pfnCopyElement);
    if (NULL == pNewEnum)
        return E_OUTOFMEMORY;

    // The clone has the same current position as we do
    pNewEnum->m_iCurrent = m_iCurrent;

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();

    return S_OK;
}


// Helper function for creating IConnectionPoint enumerators
//
HRESULT CreateInstance_IEnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum, DWORD count, ...)
{
    DWORD  countTemp;
    IConnectionPoint **rgCPs;

    if (NULL == ppEnum)
        return E_POINTER;

    ASSERT(count > 0);

    // GlobalAlloc an array of connection points [since our standard enum
    // assumes this and GlobalFree's it later]
    //
    rgCPs = (LPCONNECTIONPOINT*)GlobalAlloc(GPTR, SIZEOF(LPCONNECTIONPOINT) * count);
    if (NULL == rgCPs)
        return E_OUTOFMEMORY;

    va_list ArgList;
    va_start(ArgList, count);

    IConnectionPoint **prgCPs = rgCPs;
    countTemp = count;
    while (countTemp)
    {
        IConnectionPoint *pArg = va_arg(ArgList, IConnectionPoint*);

        *prgCPs = pArg;

        prgCPs++;
        countTemp--;
    }

    va_end(ArgList);

    *ppEnum = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                TRUE, count, SIZEOF(LPCONNECTIONPOINT), (LPVOID)rgCPs,
                                CopyAndAddRefObject);
    if (!*ppEnum)
    {
        GlobalFree(rgCPs);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\util.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>
#include <regitemp.h>
#include <shstr.h>
#include <shlobjp.h>
#include <lmcons.h>
#include <validc.h>
#include "ccstock2.h"

// Alpha platform doesn't need unicode thunks, seems like this
// should happen automatically in the headerfiles...
//
#if defined(_X86_) || defined(UNIX)
#else
#define NO_W95WRAPS_UNITHUNK
#endif

#include "wininet.h"
#include "w95wraps.h"

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
STDAPI_(LPCTSTR) SkipServerSlashes(LPCTSTR pszName)
{
    for (pszName; *pszName && *pszName == TEXT('\\'); pszName++);

    return pszName;
}


// pbIsNamed is true if the i-th item in hm is a named separator
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed)
{
    MENUITEMINFO mii;
    BOOL bLocal;

    if (!pbIsNamed)
        pbIsNamed = &bLocal;
        
    *pbIsNamed = FALSE;

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.cch = 0;    // WARNING: We MUST initialize it to 0!!!
    if (GetMenuItemInfo(hm, i, TRUE, &mii) && (mii.fType & MFT_SEPARATOR))
    {
        // NOTE that there is a bug in either 95 or NT user!!!
        // 95 returns 16 bit ID's and NT 32 bit therefore there is a
        // the following may fail, on win9x, to evaluate to false
        // without casting
        *pbIsNamed = ((WORD)mii.wID != (WORD)-1);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i)
{
    return _SHIsMenuSeparator2(hm, i, NULL);
}

//
// _SHPrettyMenu -- make this menu look darn purty
//
// Prune the separators in this hmenu to ensure there isn't one in the first or last
// position and there aren't any runs of >1 separator.
//
// Named separators take precedence over regular separators.
//
STDAPI_(void) _SHPrettyMenu(HMENU hm)
{
    BOOL bSeparated = TRUE;
    BOOL bWasNamed = TRUE;

    for (int i = GetMenuItemCount(hm) - 1; i > 0; --i)
    {
        BOOL bIsNamed;
        if (_SHIsMenuSeparator2(hm, i, &bIsNamed))
        {
            if (bSeparated)
            {
                // if we have two separators in a row, only one of which is named
                // remove the non named one!
                if (bIsNamed && !bWasNamed)
                {
                    DeleteMenu(hm, i+1, MF_BYPOSITION);
                    bWasNamed = bIsNamed;
                }
                else
                {
                    DeleteMenu(hm, i, MF_BYPOSITION);
                }
            }
            else
            {
                bWasNamed = bIsNamed;
                bSeparated = TRUE;
            }
        }
        else
        {
            bSeparated = FALSE;
        }
    }

    // The above loop does not handle the case of many separators at
    // the beginning of the menu
    while (_SHIsMenuSeparator2(hm, 0, NULL))
    {
        DeleteMenu(hm, 0, MF_BYPOSITION);
    }
}

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i)
{
    ASSERT(IsWindow(hwnd));
    ASSERT(i < SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0));

    DWORD dwEdge = 0;

    RECT rc, rcInt;
    SendMessage(hwnd, TB_GETITEMRECT, i, (LPARAM)&rc);

    if (!IntersectRect(&rcInt, prc, &rc))
    {
        dwEdge = EDGE_LEFT | EDGE_RIGHT | EDGE_TOP | EDGE_BOTTOM;
    }
    else
    {
        if (rc.top != rcInt.top)
            dwEdge |= EDGE_TOP;

        if (rc.bottom != rcInt.bottom)
            dwEdge |= EDGE_BOTTOM;

        if (rc.left != rcInt.left)
            dwEdge |= EDGE_LEFT;

        if (rc.right != rcInt.right)
            dwEdge |= EDGE_RIGHT;
    }

    return dwEdge;
}

STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState)
{
    if (dwRest == RESTOPT_BTN_STATE_VISIBLE)
        return (fsState & ~TBSTATE_HIDDEN);
    else if (dwRest == RESTOPT_BTN_STATE_HIDDEN)
        return (fsState | TBSTATE_HIDDEN);
    else {
#ifdef DEBUG
        if (dwRest != RESTOPT_BTN_STATE_DEFAULT)
            TraceMsg(TF_ERROR, "bad toolbar button state policy %x", dwRest);
#endif
        return fsState;
    }
}

//
// SHIsDisplayable
//
// Figure out if this unicode string can be displayed by the system
// (i.e., won't be turned into a string of question marks).
//
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5)
{
    BOOL fNotDisplayable = FALSE;

    if (pwszName)
    {
        if (!fRunOnNT5)
        {
            // if WCtoMB has to use default characters in mapping pwszName to multibyte,
            // it sets fNotDisplayable == TRUE, in which case we have to use something
            // else for the title string.
            WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
            if (fNotDisplayable)
            {
                if (fRunOnFE)
                {
                    WCHAR wzName[INTERNET_MAX_URL_LENGTH];

                    BOOL fReplaceNbsp = FALSE;

                    StrCpyNW(wzName, pwszName, ARRAYSIZE(wzName));
                    for (int i = 0; i < ARRAYSIZE(wzName); i++)
                    {
                        if (0x00A0 == wzName[i])    // if &nbsp
                        {
                            wzName[i] = 0x0020;     // replace to space
                            fReplaceNbsp = TRUE;
                        }
                        else if (0 == wzName[i])
                            break;
                    }
                    if (fReplaceNbsp)
                    {
                        pwszName = wzName;
                        WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
                    }
                }
            }
        }
    }

    return !fNotDisplayable;
}

// Trident will take URLs that don't indicate their source of
// origin (about:, javascript:, & vbscript:) and will append
// an URL turd and then the source URL.  The turd will indicate
// where the source URL begins and that source URL is needed
// when the action needs to be Zone Checked.
//
// This function will remove that URL turd and everything behind
// it so the URL is presentable for the user.

#define URL_TURD        ((TCHAR)0x01)

STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl)
{
    if (!pszUrl)
        return;

    while (0 != pszUrl[0])
    {
        if (URL_TURD == pszUrl[0])
        {
            pszUrl[0] = 0;
            break;
        }

        pszUrl = CharNext(pszUrl);
    }
}

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    return SetWindowPos(hwnd, hwndInsertAfter, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
}

BOOL CALLBACK _FixZorderEnumProc(HWND hwnd, LPARAM lParam)
{
    HWND hwndTest = (HWND)lParam;
    HWND hwndOwner = hwnd;

    while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
    {
        if (hwndOwner == hwndTest)
        {
            TraceMsg(TF_WARNING, "_FixZorderEnumProc: Found topmost window %x owned by non-topmost window %x, fixing...", hwnd, hwndTest);
            SetWindowZorder(hwnd, HWND_NOTOPMOST);
#ifdef DEBUG
            if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                TraceMsg(TF_ERROR, "_FixZorderEnumProc: window %x is still topmost", hwnd);
#endif
            break;
        }
    }

    return TRUE;
}

STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    BOOL fRet = SetWindowZorder(hwnd, hwndInsertAfter);

    if (fRet && hwndInsertAfter == HWND_TOPMOST)
    {
        if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
        {
            //
            // user didn't actually move the hwnd to topmost
            //
            // According to GerardoB, this can happen if the window has
            // an owned window that somehow has become topmost while the 
            // owner remains non-topmost, i.e., the two have become
            // separated in the z-order.  In this state, when the owner
            // window tries to make itself topmost, the call will
            // silently fail.
            //
            // TERRIBLE HORRIBLE NO GOOD VERY BAD HACK
            //
            // Hacky fix is to enumerate the toplevel windows, check to see
            // if any are topmost and owned by hwnd, and if so, make them
            // non-topmost.  Then, retry the SetWindowPos call.
            //

            TraceMsg(TF_WARNING, "SHForceWindowZorder: SetWindowPos(%x, HWND_TOPMOST) failed", hwnd);

            // Fix up the z-order
            EnumWindows(_FixZorderEnumProc, (LPARAM)hwnd);

            // Retry the set.  (This should make all owned windows topmost as well.)
            SetWindowZorder(hwnd, HWND_TOPMOST);

#ifdef DEBUG
            if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
                TraceMsg(TF_ERROR, "SHForceWindowZorder: window %x is still not topmost", hwnd);
#endif
        }
    }

    return fRet;
}

STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl)
{   
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent)
        ILRemoveLastID(pidlParent);

    return pidlParent;
}


// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//

STDAPI SHBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppv)
{
    // NOTE: callers should use SHBindToObjectEx!!!
    return SHBindToObjectEx(psf, pidl, NULL, riid, ppv);
}


// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//      pbc     bind context

STDAPI SHBindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder *psfRelease = NULL;

    if (!psf)
    {
        SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }

    if (psf)
    {
        if (!pidl || ILIsEmpty(pidl))
        {
            hr = psf->QueryInterface(riid, ppv);
        }
        else
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppv == NULL))
    {
        // Some shell extensions (eg WS_FTP) will return success and a null out pointer
        TraceMsg(TF_WARNING, "SHBindToObjectEx: BindToObject succeeded but returned null ppv!!");
        hr = E_FAIL;
    }

    return hr;
}

// psfRoot is the base of the bind.  If NULL, then we use the shell desktop.
// If you want to bind relative to the explorer root (e.g., CabView, MSN),
// then use SHBindToIDListParent.
STDAPI SHBindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hr;

    // Old shell32 code in some cases simply whacked the pidl,
    // but this is unsafe.  Do what shdocvw does and clone/remove:
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hr = SHBindToObjectEx(psfRoot, pidlParent, NULL, riid, ppv);
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hr;
}

//
//  Warning!  brutil.cpp overrides this function
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    return SHBindToFolderIDListParent(NULL, pidl, riid, ppv, ppidlLast);
}

// should be IUnknown_GetIDList()

STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr = E_NOINTERFACE;
    if (punk)
    {
        IPersistFolder2 *ppf;
        IPersistIDList *pperid;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistIDList, &pperid))))
        {
            hr = pperid->GetIDList(ppidl);
            pperid->Release();
        }
        else if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFolder2, &ppf))))
        {
            hr = ppf->GetCurFolder(ppidl);
            ppf->Release();
        }
    }
    return hr;
}

//
//  generically useful to hide.
//
#pragma pack(1)
typedef struct _HIDDENCLSID
{
    HIDDENITEMID hid;
    CLSID   clsid;
} HIDDENCLSID;
#pragma pack()

typedef UNALIGNED HIDDENCLSID *PHIDDENCLSID;
typedef const UNALIGNED HIDDENCLSID *PCHIDDENCLSID;

STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    HIDDENCLSID hc = {{sizeof(hc), 0, id}};
    hc.clsid = *pclsid;
    //  WARNING - cannot use hid.wVersion for compat reasons - ZekeL - 23-OCT-2000
    //  on win2k and winMe we appended clsid's with wVersion 
    //  as stack garbage.  this means we cannot use it for anything
    return ILAppendHiddenID(pidl, &hc.hid);
}

STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    PCHIDDENCLSID phc = (PCHIDDENCLSID) ILFindHiddenID(pidl, id);
    //  WARNING - cannot use hid.wVersion for compat reasons - ZekeL - 23-OCT-2000
    //  on win2k and winMe we appended clsid's with wVersion 
    //  as stack garbage.  this means we cannot use it for anything
    if (phc)
    {
        *pclsid = phc->clsid;
        return TRUE;
    }
    return FALSE;
}

#pragma pack(1)
typedef struct _HIDDENSTRINGA
{
    HIDDENITEMID hid;
    WORD    type;
    CHAR    sz[1];   //  variable length string
} HIDDENSTRINGA;
#pragma pack()

typedef UNALIGNED HIDDENSTRINGA *PHIDDENSTRINGA;
typedef const UNALIGNED HIDDENSTRINGA *PCHIDDENSTRINGA;

#pragma pack(1)
typedef struct _HIDDENSTRINGW
{
    HIDDENITEMID hid;
    WORD    type;
    WCHAR   sz[1];   //  canonical name to be passed to ISTRING
} HIDDENSTRINGW;
#pragma pack()

typedef UNALIGNED HIDDENSTRINGW *PHIDDENSTRINGW;
typedef const UNALIGNED HIDDENSTRINGW *PCHIDDENSTRINGW;

#define HIDSTRTYPE_ANSI        0x0001
#define HIDSTRTYPE_WIDE        0x0002

STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz)
{
    //  terminator is included in the ID definition
    USHORT cb = (USHORT)sizeof(HIDDENSTRINGW) + CbFromCchW(lstrlenW(psz));
    
    //
    // Use HIDDENSTRINGW* here instead of PHIDDENSTRINGW which is defined
    // as UNALIGNED.
    //

    HIDDENSTRINGW *phs = (HIDDENSTRINGW *) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->hid.cb = cb;
        phs->hid.id = id;
        phs->type = HIDSTRTYPE_WIDE;
        StrCpyW(phs->sz, psz);

        pidl = ILAppendHiddenID(pidl, &phs->hid);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}
    
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz)
{
    //  terminator is included in the ID definition
    USHORT cb = (USHORT)sizeof(HIDDENSTRINGA) + CbFromCchA(lstrlenA(psz));
    
    //
    // Use HIDDENSTRINGA* here instead of PHIDDENSTRINGW which is defined
    // as UNALIGNED.
    //

    HIDDENSTRINGA *phs = (HIDDENSTRINGA *) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->hid.cb = cb;
        phs->hid.id = id;
        phs->type = HIDSTRTYPE_ANSI;
        StrCpyA(phs->sz, psz);

        pidl = ILAppendHiddenID(pidl, &phs->hid);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}

STDAPI_(void *) _MemDupe(const UNALIGNED void *pv, DWORD cb)
{
    void *pvRet = LocalAlloc(LPTR, cb);
    if (pvRet)
    {
        CopyMemory(pvRet, pv, cb);
    }

    return pvRet;
}

STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_WIDE)
        {
            ualstrcpynW(psz, phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_ANSI);
            SHAnsiToUnicode((LPSTR)phs->sz, psz, cch);
            return TRUE;
        }
    }
    return FALSE;
}
        
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_ANSI)
        {
            ualstrcpynA(psz, (LPSTR)phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_WIDE);
            //  we need to handle the unalignment here...
            LPWSTR pszT = (LPWSTR) _MemDupe(phs->sz, CbFromCch(ualstrlenW(phs->sz) +1));

            if (pszT)
            {
                SHUnicodeToAnsi(pszT, psz, cch);
                LocalFree(pszT);
                return TRUE;
            }
        }
    }
    return FALSE;
}

STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id)
{

    // if there are fragments in here, then they might
    // differentiate the two pidls
    PCHIDDENSTRINGW ps1 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl1, id);
    PCHIDDENSTRINGW ps2 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl2, id);

    if (ps1 && ps2)
    {
        if (ps1->type == ps2->type)
        {
            if (ps1->type == HIDSTRTYPE_WIDE)
                return ualstrcmpW(ps1->sz, ps2->sz);

            ASSERT(ps1->type == HIDSTRTYPE_ANSI);

            return lstrcmpA((LPCSTR)ps1->sz, (LPCSTR)ps2->sz);
        }
        else
        {
            SHSTRW str;

            if (ps1->type == HIDSTRTYPE_ANSI)
            {
                str.SetStr((LPCSTR)ps1->sz);
                return ualstrcmpW(str, ps2->sz);
            }
            else
            {
                ASSERT(ps2->type == HIDSTRTYPE_ANSI);
                str.SetStr((LPCSTR)ps2->sz);
                return ualstrcmpW(ps1->sz, str);
            }
        }
    }

    if (ps1)
        return 1;
    if (ps2)
        return -1;
    return 0;
}

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl)
{
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;

    //  APPCOMPAT: FileNet IDMDS (Panagon)'s shell folder extension returns
    //  E_NOTIMPL for IPersistFolder::GetClassID, so to detect the application,
    //  we have to crack the pidl.  (B#359464: tracysh)

    if (!ILIsEmpty(pidl)
    && pidl->mkid.cb >= sizeof(IDREGITEM)
    && pidl->mkid.abID[0] == SHID_ROOT_REGITEM)
    {
        clsid = ((LPCIDLREGITEM)pidl)->idri.clsid;
        ocf = SHGetObjectCompatFlags(NULL, &clsid);
    }

    return ocf;
}


STDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // zero-init for external task allocator

    return pidl;
}

//
// ILClone using Task allocator
//
STDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILClone(pidl);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}

//
// ILCombine using Task allocator
//
STDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILCombine(pidl1, pidl2);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}

//
//  rooted helpers
//
LPCIDREGITEM _IsRooted(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = (LPCIDREGITEM)pidl;
    if (!ILIsEmpty(pidl)
    && pidlr->cb > sizeof(IDREGITEM)
    && pidlr->bFlags == SHID_ROOTEDREGITEM)
        return pidlr;

    return NULL;
}

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl)
{
    return (NULL != _IsRooted(pidl));
}

#define _ROOTEDPIDL(pidlr)      (LPITEMIDLIST)(((LPBYTE)pidlr)+sizeof(IDREGITEM))

STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    if (pidlr && pidlr->cb > sizeof(IDREGITEM))
    {
        //  then we have a rooted IDList in there
        return _ROOTEDPIDL(pidlr);
    }

    return NULL;
}

STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *pclsid)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    *pclsid = pidlr ? pidlr->clsid : CLSID_NULL;

    return (NULL != pidlr);
}

STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl)
{
    UINT cbPidl = ILGetSize(pidl);
    UINT cbTotal = sizeof(IDREGITEM) + cbPidl;

    LPIDREGITEM pidlr = (LPIDREGITEM) SHAlloc(cbTotal + sizeof(WORD));

    if (pidlr)
    {
        pidlr->cb = (WORD)cbTotal;

        pidlr->bFlags = SHID_ROOTEDREGITEM;
        pidlr->bOrder = 0;              // Nobody uses this (yet)

        if (pclsid)
            pidlr->clsid = *pclsid;
        else
            pidlr->clsid = CLSID_ShellDesktop;

        MoveMemory(_ROOTEDPIDL(pidlr), pidl, cbPidl);

        //  terminate
        _ILNext((LPITEMIDLIST)pidlr)->mkid.cb = 0;
    }

    return (LPITEMIDLIST) pidlr;
}

int CompareGUID(REFGUID guid1, REFGUID guid2)
{
    TCHAR sz1[GUIDSTR_MAX];
    TCHAR sz2[GUIDSTR_MAX];

    SHStringFromGUIDW(guid1, sz1, SIZECHARS(sz1));
    SHStringFromGUIDW(guid2, sz2, SIZECHARS(sz2));

    return lstrcmp(sz1, sz2);
}

STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;
    LPCIDREGITEM pidlr1 = _IsRooted(pidl1);
    LPCIDREGITEM pidlr2 = _IsRooted(pidl2);

    if (pidlr1 && pidlr2)
    {
        CLSID clsid1 = pidlr1->clsid;
        CLSID clsid2 = pidlr2->clsid;

        iRet = CompareGUID(clsid1, clsid2);
        if (0 == iRet)
        {
            if (!ILIsEqual(_ROOTEDPIDL(pidl1), _ROOTEDPIDL(pidl2)))
            {
                IShellFolder *psfDesktop;
                if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
                {
                    HRESULT hr = psfDesktop->CompareIDs(0, _ROOTEDPIDL(pidl1), _ROOTEDPIDL(pidl2));
                    psfDesktop->Release();
                    iRet = ShortFromResult(hr);
                }
            }
        }
    }
    else if (pidlr1)
    {
        iRet = -1;
    }
    else if (pidlr2)
    {
        iRet = 1;
    }
    else
    {
        //  if neither are rootes, then they share the desktop
        //  as the same root...
        iRet = 0;
    }

    return iRet;
}

LPITEMIDLIST ILRootedTranslate(LPCITEMIDLIST pidlRooted, LPCITEMIDLIST pidlTrans)
{
    LPCITEMIDLIST pidlChild = ILFindChild(ILRootedFindIDList(pidlRooted), pidlTrans);

    if (pidlChild)
    {
        LPITEMIDLIST pidlRoot = ILCloneFirst(pidlRooted);

        if (pidlRoot)
        {
            LPITEMIDLIST pidlRet = ILCombine(pidlRoot, pidlChild);
            ILFree(pidlRoot);
            return pidlRet;
        }
    }
    return NULL;
}

const ITEMIDLIST s_idlNULL = { 0 } ;

HRESULT ILRootedBindToRoot(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLSID clsid;
    ASSERT(ILIsRooted(pidl));

    ILRootedGetClsid(pidl, &clsid);
    pidl = ILRootedFindIDList(pidl);
    if (!pidl)
        pidl = &s_idlNULL;
    
    if (IsEqualGUID(clsid, CLSID_ShellDesktop))
    {
        hr = SHBindToObjectEx(NULL, pidl, NULL, riid, ppv);
    }
    else
    {
        IPersistFolder* ppf;
        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Initialize(pidl);

            if (SUCCEEDED(hr))
            {
                hr = ppf->QueryInterface(riid, ppv);
            }
            ppf->Release();
        }
    }
    return hr;
}

HRESULT ILRootedBindToObject(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    HRESULT hr = ILRootedBindToRoot(pidl, IID_PPV_ARG(IShellFolder, &psf));

    if (SUCCEEDED(hr))
    {
        pidl = _ILNext(pidl);

        if (ILIsEmpty(pidl))
            hr = psf->QueryInterface(riid, ppv);
        else
            hr = psf->BindToObject(pidl, NULL, riid, ppv);
    }
    return hr;
}

HRESULT ILRootedBindToParentFolder(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlChild)
{
    //
    //  there are three different cases to handle
    //  
    //  1.  Rooted pidl Alone
    //      [ rooted id [ target pidl ] ]
    //      return the parent folder of the target pidl
    //      and return its last id in ppidlChild 
    //  
    //  2.  Rooted pidl with One Child
    //      [ rooted id [ target pidl ] ][ child id ]
    //      return the rooted id as the parent folder
    //      and the child id in ppidlChild
    //  
    //  3. rooted pidl with many children
    //      [ rooted id [ target pidl ] ][ parent id ][ child id ]
    //      return rooted id bound to parent id as the folder
    //      and the child id in ppidlchild
    //
    
    HRESULT hr;
    ASSERT(ILIsRooted(pidl));

    //
    //  if this is a rooted pidl and it is just the root
    //  then we can bind to the target pidl of the root instead
    //
    if (ILIsEmpty(_ILNext(pidl)))
    {
        hr = SHBindToIDListParent(ILRootedFindIDList(pidl), riid, ppv, ppidlChild);
    }
    else
    {
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);
        if (pidlParent)
        {
            hr = ILRootedBindToObject(pidlParent, riid, ppv);
            ILFree(pidlParent);
        }
        else
            hr = E_OUTOFMEMORY;

        if (ppidlChild)
            *ppidlChild = ILFindLastID(pidl);
    }


    return hr;
}

#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])
#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])

STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i)
{
    if (i < pida->cidl)
        return ILCombine(HIDA_GetPIDLFolder(pida), HIDA_GetPIDLItem(pida, i));
    return NULL;
}

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText)
{
    BOOL bNonEmpty;
    
    PathRemoveBlanks(pszText);   // REVIEW, should we not remove from the end of
    bNonEmpty = lstrlen(pszText); // Not a BOOL, but okay

    EnableWindow(GetDlgItem(hDlg, IDOK), bNonEmpty);
    if (bNonEmpty)
    {
        SendMessage(hDlg, DM_SETDEFID, IDOK, 0L);
    }
}

STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id)
{
    TCHAR szText[MAX_PATH];

    if (!GetDlgItemText(hDlg, id, szText, ARRAYSIZE(szText)))
    {
        szText[0] = 0;
    }

    EnableOKButtonFromString(hDlg, szText);
}

//
//  C-callable versions of the ATL string conversion functions.
//

STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

STDAPI_(LPSTR) SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

//
//  Helper functions for SHChangeMenuAsIDList
//
//  See comment in declaration of SHChangeMenuAsIDList for caveats about
//  the pSender member.
//
//  This is tricky because IE 5.0 shipped with a Win64-unfriendly version
//  of this notification, so we have to sniff the structure and see if
//  this is an IE 5.0 style notification or a new Win64 style notification.
//  If an IE 5.0 style notification, then it was not sent by us because
//  we send the new Win64-style notification.
//
STDAPI_(BOOL) SHChangeMenuWasSentByMe(void * self, LPCITEMIDLIST pidlNotify)
{
    SHChangeMenuAsIDList UNALIGNED * pcmidl = (SHChangeMenuAsIDList UNALIGNED *)pidlNotify;
    return pcmidl->cb >= FIELD_OFFSET(SHChangeMenuAsIDList, cbZero) &&
           pcmidl->pSender == (INT64)self &&
           pcmidl->dwProcessID == GetCurrentProcessId();
}

//
//
//  Send out an extended event changenotify, using a SHChangeMenuAsIDList
//  as the pidl1 so recipients can identify whether they were the
//  sender or not.
//
//  It's okay to pass self==NULL here.  It means you don't care about
//  detecting whether it was sent by you or not.
//

STDAPI_(void) SHSendChangeMenuNotify(void * self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2)
{
    SHChangeMenuAsIDList cmidl;

    cmidl.cb          = FIELD_OFFSET(SHChangeMenuAsIDList, cbZero);
    cmidl.dwItem1     = shcnee;
    cmidl.pSender     = (INT64)self;
    cmidl.dwProcessID = self ? GetCurrentProcessId() : 0;
    cmidl.cbZero      = 0;

    // Nobody had better have specified a type; the type must be
    // SHCNF_IDLIST.
    ASSERT((shcnf & SHCNF_TYPE) == 0);
    SHChangeNotify(SHCNE_EXTENDED_EVENT, shcnf | SHCNF_IDLIST, (LPCITEMIDLIST)&cmidl, pidl2);
}


// Return FALSE if out of memory
STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl)
{
    BOOL bRet = TRUE;
    LPITEMIDLIST pidlNew;

    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    ASSERT(NULL == *ppidl || IS_VALID_PIDL(*ppidl));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (pidl)
    {
        pidlNew = ILClone(pidl);
        if (!pidlNew)
        {
            bRet = FALSE;   // failed to clone the pidl (out of memory)
        }
    }
    else
    {
        pidlNew = NULL;
    }

    LPITEMIDLIST pidlToFree = (LPITEMIDLIST)InterlockedExchangePointer((void **)ppidl, (void *)pidlNew);
    if (pidlToFree) 
    {
        ILFree(pidlToFree);
    }

    return bRet;
}

//  this needs to be the last thing in the file that uses ILClone, because everywhere
//  else, ILClone becomes SafeILClone
#undef ILClone

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl)
{
    //  the shell32 implementation of ILClone is different for win95 an ie4.
    //  it doesnt check for NULL in the old version, but it does in the new...
    //  so we need to always check
   return pidl ? ILClone(pidl) : NULL;
}

//
// retrieves the UIObject interface for the specified full pidl.
//
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf->GetUIObjectOf(hwnd, 1, &pidlChild, riid, NULL, ppv);
        psf->Release();
    }

    return hr;
}

STDAPI LoadFromFileW(REFCLSID clsid, LPCWSTR pszFile, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IPersistFile *ppf;
    HRESULT hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Load(pszFile, STGM_READ);
        if (SUCCEEDED(hr))
            hr = ppf->QueryInterface(riid, ppv);
        ppf->Release();
    }
    return hr;
}

STDAPI LoadFromIDList(REFCLSID clsid, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IPersistFolder *ppf;
    HRESULT hr = SHCoCreateInstanceAC(clsid, NULL, CLSCTX_INPROC, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Initialize(pidl);
        if (SUCCEEDED(hr))
        {
            hr = ppf->QueryInterface(riid, ppv);
        }
        ppf->Release();
    }
    return hr;
}

//
// This is a helper function for finding a specific verb's index in a context menu
//
STDAPI_(UINT) GetMenuIndexForCanonicalVerb(HMENU hMenu, IContextMenu *pcm, UINT idCmdFirst, LPCWSTR pwszVerb)
{
    int cMenuItems = GetMenuItemCount(hMenu);
    for (int iItem = 0; iItem < cMenuItems; iItem++)
    {
        MENUITEMINFO mii = {0};

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_ID;

        // IS_INTRESOURCE guards against mii.wID == -1 **and** against
        // buggy shell extensions which set their menu item IDs out of range.
        if (GetMenuItemInfo(hMenu, iItem, MF_BYPOSITION, &mii) &&
            !(mii.fType & MFT_SEPARATOR) && IS_INTRESOURCE(mii.wID) &&
            (mii.wID >= idCmdFirst))
        {
            union {
                WCHAR szItemNameW[80];
                char szItemNameA[80];
            };
            CHAR aszVerb[80];

            // try both GCS_VERBA and GCS_VERBW in case it only supports one of them
            SHUnicodeToAnsi(pwszVerb, aszVerb, ARRAYSIZE(aszVerb));

            if (SUCCEEDED(pcm->GetCommandString(mii.wID - idCmdFirst, GCS_VERBA, NULL, szItemNameA, ARRAYSIZE(szItemNameA))))
            {
                if (StrCmpICA(szItemNameA, aszVerb) == 0)
                {
                    break;  // found it
                }
            }
            else
            {
                if (SUCCEEDED(pcm->GetCommandString(mii.wID - idCmdFirst, GCS_VERBW, NULL, (LPSTR)szItemNameW, ARRAYSIZE(szItemNameW))) &&
                    (StrCmpICW(szItemNameW, pwszVerb) == 0))
                {
                    break;  // found it
                }
            }
        }
    }

    if (iItem == cMenuItems)
    {
        iItem = -1; // went through all the menuitems and didn't find it
    }

    return iItem;
}

// deal with GCS_VERBW/GCS_VERBA maddness

STDAPI ContextMenu_GetCommandStringVerb(IContextMenu *pcm, UINT idCmd, LPWSTR pszVerb, int cchVerb)
{
    // Ulead SmartSaver Pro has a 60 character verb, and 
    // over writes out stack, ignoring the cch param and we fault. 
    // so make sure this buffer is at least 60 chars

    TCHAR wszVerb[64];
    wszVerb[0] = 0;

    HRESULT hr = pcm->GetCommandString(idCmd, GCS_VERBW, NULL, (LPSTR)wszVerb, ARRAYSIZE(wszVerb));
    if (FAILED(hr))
    {
        // be extra paranoid about requesting the ansi version -- we've
        // found IContextMenu implementations that return a UNICODE buffer
        // even though we ask for an ANSI string on NT systems -- hopefully
        // they will have answered the above request already, but just in
        // case let's not let them overrun our stack!
        char szVerbAnsi[128];
        hr = pcm->GetCommandString(idCmd, GCS_VERBA, NULL, szVerbAnsi, ARRAYSIZE(szVerbAnsi) / 2);
        if (SUCCEEDED(hr))
        {
            SHAnsiToUnicode(szVerbAnsi, wszVerb, ARRAYSIZE(wszVerb));
        }
    }

    StrCpyNW(pszVerb, wszVerb, cchVerb);

    return hr;
}


//
//  Purpose:    Deletes the menu item specified by name
//
//  Parameters: pcm        - Context menu interface
//              hpopup     - Context menu handle
//              idFirst    - Beginning of id range
//              pszCommand - Command to look for
//

STDAPI ContextMenu_DeleteCommandByName(IContextMenu *pcm, HMENU hpopup, UINT idFirst, LPCWSTR pszCommand)
{
    UINT ipos = GetMenuIndexForCanonicalVerb(hpopup, pcm, idFirst, pszCommand);
    if (ipos != -1)
    {
        DeleteMenu(hpopup, ipos, MF_BYPOSITION);
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
}


//
// Helpers to banish STRRET's into the realm of darkness
//

STDAPI DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToBuf(&sr, pidl, psz, cch);
    return hr;
}

STDAPI DisplayNameOfAsOLESTR(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPWSTR *ppsz)
{
    *ppsz = NULL;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToStrW(&sr, pidl, ppsz);
    return hr;
}



// get the target pidl for a folder pidl. this deals with the case where a folder
// is an alias to a real folder, Folder Shortcuts, etc.

STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    
    // likely should ASSERT() that pidlFolder has SFGAO_FOLDER
    IShellLink *psl;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        hr = psl->GetIDList(ppidl);
        psl->Release();
    }

    // No its not a folder shortcut. Get the pidl normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// get the target folder for a folder pidl. this deals with the case where a folder
// is an alias to a real folder, Folder Shortcuts, MyDocs, etc.

STDAPI SHGetTargetFolderPathW(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    *pszPath = 0;

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(SHGetTargetFolderIDList(pidlFolder, &pidlTarget)))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // make sure it is a path
        ILFree(pidlTarget);
    }
    return *pszPath ? S_OK : E_FAIL;
}

STDAPI SHGetTargetFolderPathA(LPCITEMIDLIST pidlFolder, LPSTR pszPath, UINT cchPath)
{
    *pszPath = 0;
    WCHAR szPath[MAX_PATH];
    HRESULT hr = SHGetTargetFolderPathW(pidlFolder, szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
        SHAnsiToUnicode(pszPath, szPath, cchPath);
    return hr;
}

STDAPI SHBuildDisplayMachineName(LPCWSTR pszMachineName, LPCWSTR pszComment, LPWSTR pszDisplayName, DWORD cchDisplayName)
{
    HRESULT hr = E_FAIL;

    if (pszComment && pszComment[0])
    {
        // encorporate the comment into the display name
        LPCWSTR pszNoSlashes = SkipServerSlashes(pszMachineName);
        int i = wnsprintfW(pszDisplayName, cchDisplayName, L"%s (%s)", pszComment, pszNoSlashes);
        hr = (i < 0) ? E_FAIL : S_OK;
    }
    else
    {
        // Return failure here so netfldr can do smarter things to build a display name
        hr = E_FAIL;
    }

    return hr;
}

// create objects from registered under a key value, uses the per user per machine
// reg services to do this.

STDAPI CreateFromRegKey(LPCWSTR pszKey, LPCWSTR pszValue, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    WCHAR szCLSID[MAX_PATH];
    DWORD cbSize = sizeof(szCLSID);
    if (SHRegGetUSValueW(pszKey, pszValue, NULL, szCLSID, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        CLSID clsid;
        if (GUIDFromString(szCLSID, &clsid))
        {
            hr = SHCoCreateInstanceAC(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppv);
        }
    }
    return hr;
}

//
// SHProcessMessagesUntilEvent:
//
// this executes message loop until an event or a timeout occurs
//
STDAPI_(DWORD) SHProcessMessagesUntilEventEx(HWND hwnd, HANDLE hEvent, DWORD dwTimeout, DWORD dwWakeMask)
{
    DWORD dwEndTime = GetTickCount() + dwTimeout;
    LONG lWait = (LONG)dwTimeout;
    DWORD dwReturn;

    if (!hEvent && (dwTimeout == INFINITE))
    {
        ASSERTMSG(FALSE, "SHProcessMessagesUntilEvent: caller passed a NULL hEvent and an INFINITE timeout!!");
        return -1;
    }

    for (;;)
    {
        DWORD dwCount = hEvent ? 1 : 0;
        dwReturn = MsgWaitForMultipleObjects(dwCount, &hEvent, FALSE, lWait, dwWakeMask);

        // were we signalled or did we time out?
        if (dwReturn != (WAIT_OBJECT_0 + dwCount))
        {
            break;
        }

        // we woke up because of messages.
        MSG msg;
        while (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE))
        {
            ASSERT(msg.message != WM_QUIT);
            TranslateMessage(&msg);
            if (msg.message == WM_SETCURSOR)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
            } 
            else 
            {
                DispatchMessage(&msg);
            }
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }

    return dwReturn;
}

// deals with goofyness of IShellFolder::GetAttributesOf() including 
//      in/out param issue
//      failures
//      goofy cast for 1 item case
//      masks off results to only return what you asked for

STDAPI_(DWORD) SHGetAttributes(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    // like SHBindToObject, if psf is NULL, use absolute pidl
    LPCITEMIDLIST pidlChild;
    if (!psf)
    {
        SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    }
    else
    {
        psf->AddRef();
        pidlChild = pidl;
    }

    DWORD dw = 0;
    if (psf)
    {
        dw = dwAttribs;
        dw = SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlChild, &dw)) ? (dwAttribs & dw) : 0;
        if ((dw & SFGAO_FOLDER) && (dw & SFGAO_CANMONIKER) && !(dw & SFGAO_STORAGEANCESTOR) && (dwAttribs & SFGAO_STORAGEANCESTOR))
        {
            if (OBJCOMPATF_NEEDSSTORAGEANCESTOR & SHGetObjectCompatFlags(psf, NULL))
            {
                //  switch SFGAO_CANMONIKER -> SFGAO_STORAGEANCESTOR
                dw |= SFGAO_STORAGEANCESTOR;
                dw &= ~SFGAO_CANMONIKER;
            }
        }
    }

    if (psf)
    {
        psf->Release();
    }

    return dw;
}

//===========================================================================
// IDLARRAY stuff
//===========================================================================

STDAPI_(HIDA) HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST * apidl)
{
    UINT offset = sizeof(CIDA) + sizeof(UINT) * cidl;
    UINT cbTotal = offset + ILGetSize(pidlFolder);
    for (UINT i = 0; i<cidl ; i++) 
    {
        cbTotal += ILGetSize(apidl[i]);
    }

    HIDA hida = GlobalAlloc(GPTR, cbTotal);  // This MUST be GlobalAlloc!!!
    if (hida)
    {
        LPIDA pida = (LPIDA)hida;       // no need to lock

        LPCITEMIDLIST pidlNext;
        pida->cidl = cidl;

        for (i = 0, pidlNext = pidlFolder; ; pidlNext = apidl[i++])
        {
            UINT cbSize = ILGetSize(pidlNext);
            pida->aoffset[i] = offset;
            CopyMemory(((LPBYTE)pida) + offset, pidlNext, cbSize);
            offset += cbSize;

            ASSERT(ILGetSize(HIDA_GetPIDLItem(pida,i-1)) == cbSize);

            if (i == cidl)
                break;
        }

        ASSERT(offset == cbTotal);
    }

    return hida;
}

STDAPI_(void) HIDA_Free(HIDA hida)
{
    GlobalFree(hida);
}

STDAPI_(HIDA) HIDA_Clone(HIDA hida)
{
    SIZE_T cbTotal = GlobalSize(hida);
    HIDA hidaCopy = GlobalAlloc(GMEM_FIXED, cbTotal);
    if (hidaCopy)
    {
        CopyMemory(hidaCopy, GlobalLock(hida), cbTotal);
        GlobalUnlock(hida);
    }
    return hidaCopy;
}

STDAPI_(UINT) HIDA_GetCount(HIDA hida)
{
    UINT count = 0;
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        count = pida->cidl;
        GlobalUnlock(hida);
    }
    return count;
}

STDAPI_(UINT) HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem(pida, i);
        UINT cbFolder = ILGetSize(pidlFolder) - sizeof(USHORT);
        UINT cbItem = ILGetSize(pidlItem);
        if (cbMax < cbFolder+cbItem) 
        {
            if (pidlOut) 
                pidlOut->mkid.cb = 0;
        } 
        else 
        {
            MoveMemory(pidlOut, pidlFolder, cbFolder);
            MoveMemory(((LPBYTE)pidlOut) + cbFolder, pidlItem, cbItem);
        }
        GlobalUnlock(hida);

        return cbFolder + cbItem;
    }
    return 0;
}

STDAPI_(BOOL) PathIsImage(LPCTSTR pszFile)
{
    BOOL fPicture = FALSE;
    LPTSTR pszExt = PathFindExtension(pszFile);
    if (pszExt)
    {
        // there's no ASSOCSTR_PERCEIVED so pick it up from the registry.
        TCHAR szPerceivedType[MAX_PATH];
        DWORD cb = ARRAYSIZE(szPerceivedType) * sizeof(TCHAR);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, TEXT("PerceivedType"), NULL, szPerceivedType, &cb))
        {
            fPicture = (StrCmpI(szPerceivedType, TEXT("image")) == 0);
        }
    }
    return fPicture;
}

// helper function to create a stream or storage in a storage.
HRESULT CreateStreamOrStorage(IStorage * pStorageParent, LPCTSTR pszName, REFIID riid, void **ppv)
{
    DWORD grfModeCreated = STGM_READWRITE;
    HRESULT hr = E_INVALIDARG;

    if (IsEqualGUID(riid, IID_IStorage))
    {
        IStorage * pStorageCreated;
        hr = pStorageParent->CreateStorage(pszName, grfModeCreated, 0, 0, &pStorageCreated);

        if (SUCCEEDED(hr))
        {
            hr = pStorageParent->Commit(STGC_DEFAULT);
            *ppv = pStorageCreated;
        }
    }
    else if (IsEqualGUID(riid, IID_IStream))
    {
        IStream * pStreamCreated;
        hr = pStorageParent->CreateStream(pszName, grfModeCreated, 0, 0, &pStreamCreated);

        if (SUCCEEDED(hr))
        {
            hr = pStorageParent->Commit(STGC_DEFAULT);
            *ppv = pStreamCreated;
        }
    }

    return hr;
}


// same as PathMakeUniqueNameEx but it works on storages.
// Note: LFN only!
STDAPI StgMakeUniqueNameWithCount(IStorage *pStorageParent, LPCWSTR pszTemplate,
                                  int iMinLong, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    
    RIPMSG(pszTemplate && IS_VALID_STRING_PTR(pszTemplate, -1) && lstrlen(pszTemplate)<(MAX_PATH-6), "StgMakeUniqueNameWithCount: invalid pszTemplate");
    if (pszTemplate && lstrlen(pszTemplate)<(MAX_PATH-6)) // -6 for " (999)"
    {
        WCHAR szBuffer[MAX_PATH];
        WCHAR szFormat[MAX_PATH];
        int cchStem;
    
        // Set up:
        //   cchStem  : length of pszTemplate we're going to use w/o wsprintf
        //   szFormat : format string to wsprintf the number with, catenates on to pszTemplate[0..cchStem]

        // Has template already been uniquified?
        //
        LPWSTR pszRest = StrChr(pszTemplate, L'(');
        while (pszRest)
        {
            // First validate that this is the right one
            LPWSTR pszEndUniq = CharNext(pszRest);
            while (*pszEndUniq && *pszEndUniq >= L'0' && *pszEndUniq <= L'9')
            {
                pszEndUniq++;
            }
            if (*pszEndUniq == L')')
                break;  // We have the right one!
            pszRest = StrChr(CharNext(pszRest), L'(');
        }

        if (!pszRest)
        {
            // if no (, then tack it on at the end. (but before the extension)
            // eg.  New Link yields New Link (1)
            pszRest = PathFindExtension(pszTemplate);
            cchStem = (int)(pszRest - pszTemplate);
            wsprintf(szFormat, L" (%%d)%s", pszRest ? pszRest : L"");
        }
        else
        {
            // Template has been uniquified, remove uniquing digits
            // eg.  New Link (1) yields New Link (2)
            //
            pszRest++; // step over the (

            cchStem = (int) (pszRest - pszTemplate);

            while (*pszRest && *pszRest >= L'0' && *pszRest <= L'9')
            {
                pszRest++;
            }

            // we are guaranteed enough room because we don't include
            // the stuff before the # in this format
            wsprintf(szFormat, L"%%d%s", pszRest);
        }


        // copy the fixed portion into the buffer
        //
        StrCpyN(szBuffer, pszTemplate, cchStem+1);

        // Iterate on the uniquifying szFormat portion until we find a unique name:
        //
        LPTSTR pszDigit = szBuffer + cchStem;
        hr = STG_E_FILEALREADYEXISTS;
        for (int i = iMinLong; (i < 1000) && (STG_E_FILEALREADYEXISTS == hr); i++)
        {
            wsprintf(pszDigit, szFormat, i);

            // okay, we have the unique name, so create it in the storage.
            hr = CreateStreamOrStorage(pStorageParent, szBuffer, riid, ppv);
        }
    }

    return hr;
}


STDAPI StgMakeUniqueName(IStorage *pStorageParent, LPCTSTR pszFileSpec, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;

    TCHAR szTemp[MAX_PATH];

    LPTSTR psz;
    LPTSTR pszNew;

    // try it without the ( if there's a space after it
    psz = StrChr(pszFileSpec, L'(');
    while (psz)
    {
        if (*(CharNext(psz)) == L')')
            break;
        psz = StrChr(CharNext(psz), L'(');
    }

    if (psz)
    {
        // We have the ().  See if we have either x () y or x ().y in which case
        // we probably want to get rid of one of the blanks...
        int ichSkip = 2;
        LPTSTR pszT = CharPrev(pszFileSpec, psz);
        if (*pszT == L' ')
        {
            ichSkip = 3;
            psz = pszT;
        }

        pszNew = szTemp;
        lstrcpy(pszNew, pszFileSpec);
        pszNew += (psz - pszFileSpec);
        lstrcpy(pszNew, psz + ichSkip);
    }
    else
    {
        // 1taro registers its document with '/'.
        if (psz=StrChr(pszFileSpec, '/'))
        {
            LPTSTR pszT = CharNext(psz);
            pszNew = szTemp;
            lstrcpy(pszNew, pszFileSpec);
            pszNew += (psz - pszFileSpec);
            lstrcpy(pszNew, pszT);
        }
        else
        {
            lstrcpy(szTemp, pszFileSpec);
        }
    }

    hr = CreateStreamOrStorage(pStorageParent, szTemp, riid, ppv);
    if (FAILED(hr))
    {
        hr = StgMakeUniqueNameWithCount(pStorageParent, pszFileSpec, 2, riid, ppv);
    }

    return hr;
}


STDAPI SHInvokeCommandOnPidl(HWND hwnd, IUnknown* punk, LPCITEMIDLIST pidl, UINT uFlags, LPCSTR lpVerb)
{
    IShellFolder* psf;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnPidlArray(hwnd, punk, psf, &pidlChild, 1, uFlags, lpVerb);
        psf->Release();
    }
    return hr;
}


STDAPI SHInvokeCommandOnPidlArray(HWND hwnd, IUnknown* punk, IShellFolder* psf, LPCITEMIDLIST *ppidlItem, UINT cItems, UINT uFlags, LPCSTR lpVerb)
{
    IContextMenu *pcm;
    HRESULT hr = psf->GetUIObjectOf(hwnd, cItems, ppidlItem, IID_X_PPV_ARG(IContextMenu, 0, &pcm));
    if (SUCCEEDED(hr) && pcm)
    {
        hr = SHInvokeCommandOnContextMenu(hwnd, punk, pcm, uFlags, lpVerb);
        pcm->Release();
    }

    return hr;
}

STDAPI SHInvokeCommandOnDataObject(HWND hwnd, IUnknown* punk, IDataObject* pdtobj, UINT uFlags, LPCSTR pszVerb)
{
    HRESULT hr = E_FAIL;

    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlParent = IDA_GetIDListPtr(pida, (UINT)-1);
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlParent, &psf))))
        {
            LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
            if (ppidl)
            {
                for (UINT i = 0; i < pida->cidl; i++)
                {
                    ppidl[i] = IDA_GetIDListPtr(pida, i);
                }
                hr = SHInvokeCommandOnPidlArray(hwnd, punk, psf, ppidl, pida->cidl, uFlags, pszVerb);
                LocalFree(ppidl);
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    
    return hr;
}

STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    LPCITEMIDLIST pidl = NULL;
    if (pida && ((i == (UINT)-1) || i < pida->cidl))
    {
        pidl = HIDA_GetPIDLItem(pida, i);
    }
    return pidl;
}

STDAPI_(void) IEPlaySound(LPCTSTR pszSound, BOOL fSysSound)
{
    TCHAR szKey[256];

    // check the registry first
    // if there's nothing registered, we blow off the play,
    // but we don't set the MM_DONTLOAD flag so that if they register
    // something we will play it
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\%s\\%s\\.current"),
        (fSysSound ? TEXT(".Default") : TEXT("Explorer")), pszSound);

    TCHAR szFileName[MAX_PATH];
    szFileName[0] = 0;
    DWORD cbSize = sizeof(szFileName);

    // note the test for an empty string, PlaySound will play the Default Sound if we
    // give it a sound it cannot find...

    if ((SHGetValue(HKEY_CURRENT_USER, szKey, NULL, NULL, szFileName, &cbSize) == ERROR_SUCCESS)
        && cbSize && szFileName[0] != 0)
    {
        DWORD dwFlags = SND_FILENAME | SND_NODEFAULT | SND_ASYNC | SND_NOSTOP | SND_ALIAS;

        // This flag only works on Win95
        if (IsOS(OS_WIN95GOLD))
        {
            #define SND_LOPRIORITY 0x10000000l
            dwFlags |= SND_LOPRIORITY;
        }

        // Unlike SHPlaySound in shell32.dll, we get the registry value
        // above and pass it to PlaySound with SND_FILENAME instead of
        // SDN_APPLICATION, so that we play sound even if the application
        // is not Explroer.exe (such as IExplore.exe or WebBrowserOC).

        PlaySoundWrapW(szFileName, NULL, dwFlags);
    }
}

STDAPI IUnknown_DragEnter(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

STDAPI IUnknown_DragOver(IUnknown* punk, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragOver(grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

STDAPI IUnknown_DragLeave(IUnknown* punk)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragLeave();
            pdt->Release();
        }
    }
    return hr;
}

STDAPI IUnknown_Drop(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

__int64 MakeFileVersion(WORD wMajor, WORD wMinor, WORD wBuild, WORD wQfe)
{ 
   return ((__int64)(wMajor) << 48) | ((__int64)(wMinor) << 32) |
          ((__int64)(wBuild) << 16) | ((__int64)(wQfe));
}

HRESULT GetVersionFromString64(LPCWSTR psz, __int64 *pVer)

{
    HRESULT hr = S_OK;
    int idx = 0;
    WORD nums[4] = { 0, 0, 0, 0 };
 
    while (*psz && SUCCEEDED(hr))
    {
        if (L',' == *psz)
        {
            idx++;
            if (idx >= ARRAYSIZE(nums))
            {
                hr = E_INVALIDARG;
                break;
            }
        }
        else if ((*psz >= L'0') && (*psz <= L'9'))
        {
            nums[idx] = (nums[idx] * 10) + (*psz - L'0');
        }
        else
        {
            hr = E_INVALIDARG;
            break;
        }
        psz++;
    }
 
    if (SUCCEEDED(hr))
    {
        *pVer = MakeFileVersion(nums[0], nums[1], nums[2], nums[3]);
    }
    else
    {
        *pVer = 0i64;
    }
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\wnetutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>
#include <regitemp.h>
#include <shstr.h>
#include <shlobjp.h>
#include <lmcons.h>
#include <validc.h>
#include "ccstock2.h"

// Alpha platform doesn't need unicode thunks, seems like this
// should happen automatically in the headerfiles...
//
#if defined(_X86_) || defined(UNIX)
#else
#define NO_W95WRAPS_UNITHUNK
#endif

#include "wininet.h"
#include "w95wraps.h"

// Put stuff to clean up URLs from being spoofed here.
// We don't want to show escaped host names
// We don't want display the username:password combo that's embedded in the url, in the UI.
// So we remove those pieces, and reconstruct the url.

STDAPI_(void) SHCleanupUrlForDisplay(LPTSTR pszUrl)
{
    switch (GetUrlScheme(pszUrl))
    {
    case URL_SCHEME_FTP:
    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
      {
        URL_COMPONENTS uc = { 0 };
        TCHAR szName[INTERNET_MAX_URL_LENGTH];
        
        uc.dwStructSize = sizeof(uc);
        uc.dwSchemeLength = uc.dwHostNameLength = uc.dwUserNameLength = uc.dwPasswordLength = uc.dwUrlPathLength = uc.dwExtraInfoLength = 1;
        
        if (InternetCrackUrl(pszUrl, 0, 0, &uc) && uc.lpszHostName)
        {
            BOOL fRecreate = FALSE;

            for (DWORD dw=0; dw < uc.dwHostNameLength; dw++)
            {
                if (uc.lpszHostName[dw]==TEXT('%'))
                {
                    URL_COMPONENTS uc2 =  { 0 };
                    uc2.dwStructSize = sizeof(uc2);
                    uc2.dwHostNameLength = ARRAYSIZE(szName);
                    uc2.lpszHostName = szName;

                    if (InternetCrackUrl(pszUrl, 0, 0, &uc2))
                    {
                        uc.dwHostNameLength = 0;
                        uc.lpszHostName = szName;
                        fRecreate = TRUE;
                    }
                    break;
                }
            }


            if (uc.lpszUserName || uc.lpszPassword)
            {
                uc.dwPasswordLength = uc.dwUserNameLength = 0;
                uc.lpszUserName = uc.lpszPassword = NULL;
                fRecreate = TRUE;
            }

            if (fRecreate)
            {
                // The length of the url will be shorter than the original
                DWORD cc = lstrlen(pszUrl) + 1;
                InternetCreateUrl(&uc, 0, pszUrl, &cc); 
            }
        }
        break;
      }
        
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\modules.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    version.h

Abstract:

    Declares the structures used for version checkings.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#include <windows.h>
#include <winnt.h>

PBYTE
ShMapFileIntoMemory (
    IN      PCTSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle
    );

BOOL
ShUnmapFile (
    IN PBYTE  FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );

DWORD
ShGetModuleType (
    IN      PBYTE MappedImage
    );

ULONG
ShGetPECheckSum (
    IN      PBYTE MappedImage
    );

UINT
ShGetCheckSum (
    IN      ULONG ImageSize,
    IN      PBYTE MappedImage
    );

PTSTR
ShGet16ModuleDescription (
    IN      PBYTE MappedImage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\modules.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    modules.c

Abstract:

    Implements .

Author:

    Calin Negreanu (calinn)  20-Jan-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "modules.h"

PBYTE
ShMapFileIntoMemory (
    IN      PCTSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle
    )
{
    PBYTE fileImage = NULL;

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFile (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMapping (*FileHandle, NULL, PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}

BOOL
ShUnmapFile (
    IN PBYTE  FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )
{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}

#define MT_UNKNOWN_MODULE  0
#define MT_DOS_MODULE      1
#define MT_W16_MODULE      2
#define MT_W32_MODULE      3

DWORD
ShGetModuleType (
    IN      PBYTE MappedImage
    )
{
    DWORD result;
    PIMAGE_DOS_HEADER dh;
    PDWORD sign;
    PWORD signNE;

    dh = (PIMAGE_DOS_HEADER) MappedImage;

    if (dh->e_magic != IMAGE_DOS_SIGNATURE) {
        result = MT_UNKNOWN_MODULE;
    } else {
        result = MT_DOS_MODULE;
        sign = (PDWORD)(MappedImage + dh->e_lfanew);
        if (*sign == IMAGE_NT_SIGNATURE) {
            result = MT_W32_MODULE;
        }
        signNE = (PWORD)sign;
        if (*signNE == IMAGE_OS2_SIGNATURE) {
            result = MT_W16_MODULE;
        }
    }
    return result;
}

PIMAGE_NT_HEADERS
pShGetImageNtHeader (
    IN PVOID Base
    )
{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    return NULL;
}

ULONG
ShGetPECheckSum (
    IN      PBYTE MappedImage
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG result = 0;

    if (ShGetModuleType (MappedImage) != MT_W32_MODULE) {
        return 0;
    }
    NtHeaders = pShGetImageNtHeader(MappedImage);
    if (NtHeaders) {
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            result = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
        } else
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            result = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
        }
    }
    return result;
}

UINT
ShGetCheckSum (
    IN      ULONG ImageSize,
    IN      PBYTE MappedImage
    )
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    UINT   checkSum   = 0;

    if (ImageSize < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = ImageSize;
    }
    else
    if (startAddr + size > ImageSize) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = ImageSize - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    MappedImage = MappedImage + startAddr;

    for (i = 0; i<(size - 3); i+=4) {
        checkSum += *((PDWORD) (MappedImage + i));
        checkSum = _rotr (checkSum, 1);
    }
    return checkSum;
}

PTSTR
ShGet16ModuleDescription (
    IN      PBYTE MappedImage
    )
{
    CHAR a_result [512];  // we know for sure that this one cannot be larger (size is a byte)
    PTSTR result = NULL;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_OS2_HEADER neHeader;
    PBYTE size;
#ifdef UNICODE
    WCHAR w_result [512];
    INT converted;
#endif

    if (ShGetModuleType (MappedImage) != MT_W16_MODULE) {
        return NULL;
    }
    dosHeader = (PIMAGE_DOS_HEADER) MappedImage;
    neHeader = (PIMAGE_OS2_HEADER) (MappedImage + dosHeader->e_lfanew);
    size = (PBYTE) (MappedImage + neHeader->ne_nrestab);
    if (*size == 0) {
        return NULL;
    }
    CopyMemory (a_result, MappedImage + neHeader->ne_nrestab + 1, *size);
    a_result [*size] = 0;
#ifdef UNICODE
    converted = MultiByteToWideChar (
                    CP_ACP,
                    0,
                    a_result,
                    *size,
                    w_result,
                    512
                    );
    if (!converted) {
        return NULL;
    }
    w_result [*size] = 0;
    result = HeapAlloc (GetProcessHeap (), 0, (converted + 1) * sizeof (WCHAR));
    lstrcpyW (result, w_result);
#else
    result = HeapAlloc (GetProcessHeap (), 0, (*size + 1) * sizeof (CHAR));
    lstrcpyA (result, a_result);
#endif
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\srcc.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

# Winbasep.h
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)

MAJORCOMP=shell
MINORCOMP=badapps

# target
TARGETPATH=obj
TARGETTYPE=LIBRARY

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
        ..\utils.c     \
        ..\version.c   \
        ..\modules.c   \
        ..\badapps.c   \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\varutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <varutil.h>
#include <shdocvw.h>

#define VariantInit(p) memset(p, 0, sizeof(*(p)))


// ---------------------------------------------------
//
// InitVariantFrom... functions
//

STDAPI InitVariantFromInt(VARIANT *pvar, int lVal)
{
    pvar->vt = VT_I4;
    pvar->lVal = lVal;
    return S_OK;
}

STDAPI InitVariantFromUINT(VARIANT *pvar, UINT ulVal)
{
    pvar->vt = VT_UI4;
    pvar->ulVal = ulVal;
    return S_OK;
}

STDAPI_(UINT) VariantToUINT(VARIANT varIn)
{
    VARIANT varResult = {0};
    return SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_UI4)) ? varResult.ulVal : 0;
}

STDAPI_(int) VariantToInt(VARIANT varIn)
{
    VARIANT varResult = {0};
    return SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_I4)) ? varResult.lVal : 0;
}

STDAPI_(BOOL) VariantToBOOL(VARIANT varIn)
{
    VARIANT varResult = {0};
    if (SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_BOOL)))
        return (varResult.boolVal == VARIANT_FALSE) ? FALSE : TRUE;
    return FALSE;
}

STDAPI_(BOOL) VariantToBuffer(const VARIANT* pvar, void *pv, UINT cb)
{
    if (pvar && pvar->vt == (VT_ARRAY | VT_UI1))
    {
        CopyMemory(pv, pvar->parray->pvData, cb);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) VariantToGUID(const VARIANT *pvar, GUID *pguid)
{
    return VariantToBuffer(pvar, pguid, sizeof(*pguid));
}

STDAPI_(LPCWSTR) VariantToStrCast(const VARIANT *pvar)
{
    LPCWSTR psz = NULL;

    ASSERT(!IsBadReadPtr(pvar, sizeof(pvar)));

    if (pvar->vt == (VT_BYREF | VT_VARIANT) && pvar->pvarVal)
        pvar = pvar->pvarVal;

    if (pvar->vt == VT_BSTR)
        psz = pvar->bstrVal;
    else if (pvar->vt == (VT_BSTR | VT_BYREF))
        psz = *pvar->pbstrVal;
    
    return psz;
}

STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb)
{
    HRESULT hr;
    VariantInit(pvar);
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, cb);   // create a one-dimensional safe array
    if (psa) 
    {
        CopyMemory(psa->pvData, pv, cb);

        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDAPI_(UINT) _MyILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cbTotal;
}

STDAPI InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl)
{
    return InitVariantFromBuffer(pvar, pidl, _MyILGetSize(pidl));
}

STDAPI InitVariantFromGUID(VARIANT *pvar, REFGUID guid)
{
    return InitVariantFromBuffer(pvar, &guid, sizeof(guid));
}

STDAPI InitBSTRVariantFromGUID(VARIANT *pvar, REFGUID guid)
{
    WCHAR wszGuid[GUIDSTR_MAX];
    HRESULT hr;
    if (SUCCEEDED(SHStringFromGUIDW(guid, wszGuid, ARRAYSIZE(wszGuid))))
    {
        hr = InitVariantFromStr(pvar, wszGuid);
    }
    else
    {
        hr = E_FAIL;
        VariantInit(pvar);
    }
    return hr;
}

// note, this frees the STRRET contents
STDAPI InitVariantFromStrRet(STRRET *pstrret, LPCITEMIDLIST pidl, VARIANT *pv)
{
    WCHAR szTemp[INFOTIPSIZE];
    HRESULT hres = StrRetToBufW(pstrret, pidl, szTemp, ARRAYSIZE(szTemp));
    if (SUCCEEDED(hres))
    {
        pv->bstrVal = SysAllocString(szTemp);
        if (pv->bstrVal)
            pv->vt = VT_BSTR;
        hres = pv->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    return hres;
}

// returns:
//      S_OK    success
//      S_FALSE successfully created an empty string from a NULL [in] parameter
//      E_OUTOFMEMORY
STDAPI InitVariantFromStr(VARIANT *pvar, LPCWSTR psz)
{
    VariantInit(pvar);

    // There is no NULL bstr value, so convert NULL to "".
    pvar->bstrVal = SysAllocString(psz ? psz : L"");
    if (pvar->bstrVal)
        pvar->vt = VT_BSTR;

    return pvar->bstrVal ? (psz ? S_OK : S_FALSE) : E_OUTOFMEMORY;
}

// time is in GMT. this function converts to local time

STDAPI InitVariantFromFileTime(const FILETIME *pft, VARIANT *pv)
{
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);

    //
    //  Watch out for the special filesystem "uninitialized" values.
    //
    if (FILETIMEtoInt64(*pft) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ftLocal) == FT_FAT_UNKNOWNLOCAL)
        return E_FAIL;

    FileTimeToSystemTime(pft, &st);
    pv->vt = VT_DATE;
    return SystemTimeToVariantTime(&st, &pv->date) ? S_OK : E_FAIL; // delay load...
}

// Note: will allocate it for you if you pass NULL pszBuf
STDAPI_(LPTSTR) VariantToStr(const VARIANT *pvar, LPWSTR pszBuf, int cchBuf)
{
    TCHAR szBuf[INFOTIPSIZE];

    if (pszBuf)
    {
        DEBUGWhackPathBuffer(pszBuf, cchBuf);
    }
    else
    {
        pszBuf = szBuf;
        cchBuf = ARRAYSIZE(szBuf);
    }
    *pszBuf = 0;

    BOOL fDone = FALSE;
    if (pvar->vt == VT_DATE) // we want our date formatting
    {
        USHORT wDosDate, wDosTime;
        if (VariantTimeToDosDateTime(pvar->date, &wDosDate, &wDosTime))
        {
            DosTimeToDateTimeString(wDosDate, wDosTime, pszBuf, cchBuf, 0);
            fDone = TRUE;
        }
    }

    if (!fDone)
    {
        VARIANT varDst = {0};

        if (VT_BSTR != pvar->vt)
        {
            if (S_OK == VariantChangeType(&varDst, (VARIANT*)pvar, 0, VT_BSTR))
            {
                ASSERT(VT_BSTR == varDst.vt);

                pvar = &varDst;
            }
            else
                pszBuf = NULL; // error
        }
        if (VT_BSTR == pvar->vt)
        {
            StrCpyNW(pszBuf, pvar->bstrVal, cchBuf);
        }

        if (pvar == &varDst)
            VariantClear(&varDst);
    }

    if (pszBuf == szBuf)
        return StrDup(szBuf);
    else
        return pszBuf;
}


// ---------------------------------------------------
// [in,out] pvar:  [in] initialized with property bag data
//                 [out] data in format vtDesired or VT_EMPTY if no conversion
// [in] vtDesired: [in] type to convert to, or VT_EMPTY to accept all types of data
//
STDAPI VariantChangeTypeForRead(VARIANT *pvar, VARTYPE vtDesired)
{
    HRESULT hr = S_OK;

    if ((pvar->vt != vtDesired) && (vtDesired != VT_EMPTY))
    {
        VARIANT varTmp;
        VARIANT varSrc;

        // cache a copy of [in]pvar in varSrc - we will free this later
        CopyMemory(&varSrc, pvar, sizeof(varTmp));
        VARIANT* pvarToCopy = &varSrc;

        // oleaut's VariantChangeType doesn't support
        // hex number string -> number conversion, which we want,
        // so convert those to another format they understand.
        //
        // if we're in one of these cases, varTmp will be initialized
        // and pvarToCopy will point to it instead
        //
        if (VT_BSTR == varSrc.vt)
        {
            switch (vtDesired)
            {
                case VT_I1:
                case VT_I2:
                case VT_I4:
                case VT_INT:
                {
                    if (StrToIntExW(varSrc.bstrVal, STIF_SUPPORT_HEX, &varTmp.intVal))
                    {
                        varTmp.vt = VT_INT;
                        pvarToCopy = &varTmp;
                    }
                    break;
                }

                case VT_UI1:
                case VT_UI2:
                case VT_UI4:
                case VT_UINT:
                {
                    if (StrToIntExW(varSrc.bstrVal, STIF_SUPPORT_HEX, (int*)&varTmp.uintVal))
                    {
                        varTmp.vt = VT_UINT;
                        pvarToCopy = &varTmp;
                    }
                    break;
                }
            }
        }

        // clear our [out] buffer, in case VariantChangeType fails
        VariantInit(pvar);

        hr = VariantChangeType(pvar, pvarToCopy, 0, vtDesired);

        // clear the cached [in] value
        VariantClear(&varSrc);
        // if initialized, varTmp is VT_UINT or VT_UINT, neither of which need VariantClear
    }

    return hr;
}




// ---------------------------------------------------
//
// Other conversion functions
//

STDAPI_(BSTR) SysAllocStringA(LPCSTR psz)
{
    if (psz)
    {
        WCHAR wsz[INFOTIPSIZE];  // assumes INFOTIPSIZE number of chars max

        SHAnsiToUnicode(psz, wsz, ARRAYSIZE(wsz));
        return SysAllocString(wsz);
    }
    return NULL;
}

STDAPI StringToStrRetW(LPCWSTR pszName, STRRET *pStrRet)
{
    pStrRet->uType = STRRET_WSTR;
    return SHStrDupW(pszName, &pStrRet->pOleStr);
}

STDAPI_(void) DosTimeToDateTimeString(WORD wDate, WORD wTime, LPTSTR pszText, UINT cchText, int fmt)
{
    FILETIME ft;
    DWORD dwFlags = FDTF_DEFAULT;

    // Netware directories do not have dates...
    if (wDate == 0)
    {
        *pszText = 0;
        return;
    }

    DosDateTimeToFileTime(wDate, wTime, &ft);
    switch (fmt) {
    case LVCFMT_LEFT_TO_RIGHT :
        dwFlags |= FDTF_LTRDATE;
        break;
    case LVCFMT_RIGHT_TO_LEFT :
        dwFlags |= FDTF_RTLDATE;
        break;
    }
    SHFormatDateTime(&ft, &dwFlags, pszText, cchText);
}

STDAPI GetDateProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, FILETIME *pft)
{
    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (VT_DATE == var.vt)
        {
            SYSTEMTIME st;
            if (VariantTimeToSystemTime(var.date, &st) && SystemTimeToFileTime(&st, pft))
            {
                hr = S_OK;
            }
        }

        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI GetLongProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, ULONGLONG *pullVal)
{
    *pullVal = 0;

    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        if (VT_UI8 == var.vt)
        {
            *pullVal = var.ullVal;
            hr = S_OK;
        }
        else
        {
            VARIANT varLong = {0};
            hr = VariantChangeType(&varLong, &var, 0, VT_UI8);
            if (SUCCEEDED(hr))
            {
                *pullVal = varLong.ullVal;
                VariantClear(&varLong);
            }
        }
        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI GetStringProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, LPTSTR pszVal, int cchMax)
{
    *pszVal = 0;

    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        hr = VariantToStr(&var, pszVal, cchMax) ? S_OK : E_FAIL;
        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI QueryInterfaceVariant(VARIANT v, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if ((VT_UNKNOWN == v.vt) && v.punkVal)
    {
        hr = v.punkVal->QueryInterface(riid, ppv);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\valid.c ===
//
//  Validation code
//

#include "stock.h"
#pragma hdrstop

//
//  Validations
//

// Hack: size of the internal data structures, as defined in comctl32\da.c.
// We measure this by the number of DWORD-sized fields.
#ifdef DEBUG
#define CB_DSA      (6 * sizeof(DWORD))
#define CB_DPA      (6 * sizeof(DWORD))
#else
#define CB_DSA      (5 * sizeof(DWORD))
#define CB_DPA      (5 * sizeof(DWORD))
#endif

BOOL
IsValidHDSA(
    HDSA hdsa)
{
    return (IS_VALID_WRITE_BUFFER(hdsa, BYTE, CB_DSA));
}


BOOL
IsValidHDPA(
    HDPA hdpa)
{
    return (IS_VALID_WRITE_BUFFER(hdpa, BYTE, CB_DPA));
}

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl)
{
    return (IS_VALID_READ_PTR(pidl, USHORT) &&
            IS_VALID_READ_BUFFER((LPBYTE)pidl+sizeof(USHORT), BYTE, pidl->mkid.cb) &&
            (0 == _ILNext(pidl)->mkid.cb || IS_VALID_PIDL(_ILNext(pidl))));
}


BOOL 
IsValidHWND(
    HWND hwnd)
{
    /* Ask User if this is a valid window. */

    return(IsWindow(hwnd));
}


BOOL
IsValidHMENU(
    HMENU hmenu)
{
    return IsMenu(hmenu);
}    


BOOL 
IsValidHANDLE(
    HANDLE hnd)
{
    return(NULL != hnd && INVALID_HANDLE_VALUE != hnd);
}


BOOL 
IsValidHANDLE2(
    HANDLE hnd)
{
    return(hnd != INVALID_HANDLE_VALUE);
}


BOOL 
IsValidShowCmd(
    int nShow)
{
    BOOL bResult;
 
    switch (nShow)
    {
       case SW_HIDE:
       case SW_SHOWNORMAL:
       case SW_SHOWMINIMIZED:
       case SW_SHOWMAXIMIZED:
       case SW_SHOWNOACTIVATE:
       case SW_SHOW:
       case SW_MINIMIZE:
       case SW_SHOWMINNOACTIVE:
       case SW_SHOWNA:
       case SW_RESTORE:
       case SW_SHOWDEFAULT:
          bResult = TRUE;
          break;
 
       default:
          bResult = FALSE;
          TraceMsg(TF_ERROR, "IsValidShowCmd(): Invalid show command %d.",
                     nShow);
          break;
    }
 
    return(bResult);
}


BOOL 
IsValidPathA(
    LPCSTR pcszPath)
{
    return(IS_VALID_STRING_PTRA(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}

BOOL 
IsValidPathW(
    LPCWSTR pcszPath)
{
    return(IS_VALID_STRING_PTRW(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenW(pcszPath) < MAX_PATH));
}


BOOL 
IsValidPathResultA(
    HRESULT hr, 
    LPCSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathA(pcszPath)) &&
            EVAL((UINT)lstrlenA(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}

BOOL 
IsValidPathResultW(
    HRESULT hr, 
    LPCWSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathW(pcszPath)) &&
            EVAL((UINT)lstrlenW(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}


BOOL 
IsValidExtensionA(
    LPCSTR pcszExt)
{
    return(IS_VALID_STRING_PTRA(pcszExt, MAX_PATH) &&
           EVAL(lstrlenA(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == '.'));
}

BOOL 
IsValidExtensionW(
    LPCWSTR pcszExt)
{
    return(IS_VALID_STRING_PTRW(pcszExt, MAX_PATH) &&
           EVAL(lstrlenW(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == TEXTW('.')));
}


BOOL 
IsValidIconIndexA(
    HRESULT hr, 
    LPCSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultA(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}

BOOL 
IsValidIconIndexW(
    HRESULT hr, 
    LPCWSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultW(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}


BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenA(pcszBigger));
}


BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenW(pcszBigger));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\xml.cpp ===
/*****************************************************************************\
    FILE: xml.cpp

    DESCRIPTION:
        These are XML DOM wrappers that make it easy to pull information out
    of an XML file or object.

    BryanSt 10/12/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#include "stock.h"
#pragma hdrstop



/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
#define SZ_VALID_XML      L"<?xml"

STDAPI XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


STDAPI XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


STDAPI XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


STDAPI XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


STDAPI XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


STDAPI XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


STDAPI XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\badapps.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    badapps.c

Abstract:

    Implements a library for CheckBadApps key.

Author:

    Calin Negreanu (calinn)  20-Jan-1999

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <winnt.h>
#include <shlwapi.h>
#include <badapps.h>
#include "utils.h"
#include "version.h"
#include "modules.h"

typedef struct {
    PCTSTR FileName;
    BOOL FindDataLoaded;
    WIN32_FIND_DATA FindData;
    PBYTE MappedImage;
    HANDLE FileHandle;
    HANDLE MapHandle;
    VERSION_STRUCT VersionData;
    HKEY PrevOsKey;
} FILE_DATA, *PFILE_DATA;

typedef BOOL (VERSION_CHECK_PROTOTYPE) (PFILE_DATA FileData, DWORD DataSize, PBYTE Data);
typedef VERSION_CHECK_PROTOTYPE * PVERSION_CHECK_PROTOTYPE;

typedef struct {
    DWORD   VersionId;
    PVERSION_CHECK_PROTOTYPE VersionCheck;
} VERSION_DATA, *PVERSION_DATA;

#define LIBARGS(id, fn) VERSION_CHECK_PROTOTYPE fn;
#define TOOLARGS(name, dispName, allowance, edit, query, output)

VERSION_STAMPS

#undef TOOLARGS
#undef LIBARGS

#define LIBARGS(id, fn) {id, fn},
#define TOOLARGS(name, dispName, allowance, edit, query, output)
VERSION_DATA g_VersionData [] = {
                  VERSION_STAMPS
                  {0, NULL}
                  };
#undef TOOLARGS
#undef LIBARGS

#define FD_FINDDATA     0x00000001
#define FD_MAPPINGDATA  0x00000002
#define FD_VERSIONDATA  0x00000003
#define FD_PREVOSDATA   0x00000004

BOOL
ShLoadFileData (
    IN OUT  PFILE_DATA FileData,
    IN      DWORD FileDataType
    )
{
    LONG status;
    HANDLE findHandle;
    UINT oldMode;

    switch (FileDataType) {
    case FD_FINDDATA:
        if (!FileData->FindDataLoaded) {

            oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

            findHandle = FindFirstFile (FileData->FileName, &FileData->FindData);

            SetErrorMode(oldMode);

            if (findHandle == INVALID_HANDLE_VALUE) {
                return FALSE;
            } else {
                FindClose (findHandle);
                FileData->FindDataLoaded = TRUE;
            }
        }
        break;
    case FD_MAPPINGDATA:
        if (!FileData->MappedImage) {
            FileData->MappedImage = ShMapFileIntoMemory (
                                        FileData->FileName,
                                        &FileData->FileHandle,
                                        &FileData->MapHandle
                                        );
            if (!FileData->MappedImage) {
                return FALSE;
            }
        }
        break;
    case FD_VERSIONDATA:
        if (!FileData->VersionData.VersionBuffer) {
            if (!ShCreateVersionStruct (&FileData->VersionData, FileData->FileName)) {
                FileData->VersionData.VersionBuffer = NULL;
                return FALSE;
            }
        }
        break;
    case FD_PREVOSDATA:
        if (!FileData->PrevOsKey) {
            status = RegOpenKey (
                        HKEY_LOCAL_MACHINE,
                        S_KEY_PREVOSVERSION,
                        &FileData->PrevOsKey
                        );
            if (status != ERROR_SUCCESS) {
                return FALSE;
            }
        }
    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
ShFreeFileData (
    IN OUT  PFILE_DATA FileData
    )
{
    FileData->FindDataLoaded = FALSE;
    if (FileData->MappedImage) {
        ShUnmapFile (
            FileData->MappedImage,
            FileData->FileHandle,
            FileData->MapHandle
            );
        FileData->MappedImage = NULL;
        FileData->FileHandle = NULL;
        FileData->MapHandle = NULL;
    }
    if (FileData->VersionData.VersionBuffer) {
        ShDestroyVersionStruct (&FileData->VersionData);
        FileData->VersionData.VersionBuffer = NULL;
    }
    if (FileData->PrevOsKey) {
        RegCloseKey (FileData->PrevOsKey);
        FileData->PrevOsKey = NULL;
    }
    return TRUE;
}

BOOL
ShCheckFileSize (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    if (!ShLoadFileData (FileData, FD_FINDDATA)) {
        return FALSE;
    }
    return (*((UNALIGNED DWORD*)Data) == FileData->FindData.nFileSizeLow);
}

BOOL
ShCheckModuleType (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    if (!ShLoadFileData (FileData, FD_MAPPINGDATA)) {
        return FALSE;
    }
    return (*((UNALIGNED DWORD*) Data) == ShGetModuleType (FileData->MappedImage));
}

BOOL
ShCheckBinFileVer (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONGLONG value;
    ULONGLONG mask;
    ULONGLONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetFileVer (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONGLONG*) Data;
    mask = *((UNALIGNED ULONGLONG*) (Data + sizeof (ULONGLONG)));
    return ((value & mask) == currVer);
}

BOOL
ShCheckBinProductVer (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONGLONG value;
    ULONGLONG mask;
    ULONGLONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetProductVer (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONGLONG*)Data;
    mask = *((UNALIGNED ULONGLONG*)(Data + sizeof (ULONGLONG)));
    return ((value & mask) == currVer);
}

BOOL
ShCheckUpToBinProductVer (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONGLONG ProdVerMS;
    ULONGLONG BadProdVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        ProdVerMS = 0;
    } else {
        ProdVerMS = ShVerGetProductVer (&FileData->VersionData);
    }
    BadProdVer = *(UNALIGNED ULONGLONG*)Data;
    return (ProdVerMS <= BadProdVer);
}

BOOL
ShCheckFileDateHi (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONGLONG value;
    ULONGLONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetFileDateHi (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONGLONG*)Data;
    return (value == currVer);
}

BOOL
ShCheckFileDateLo (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONGLONG value;
    ULONGLONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetFileDateLo (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONGLONG*)Data;
    return (value == currVer);
}

BOOL
ShCheckFileVerOs (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONG value;
    ULONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetFileVerOs (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONG*)Data;
    return (value == currVer);
}

BOOL
ShCheckFileVerType (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONG value;
    ULONG currVer;
    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        currVer = 0;
    } else {
        currVer = ShVerGetFileVerType (&FileData->VersionData);
    }
    value = *(UNALIGNED ULONG*)Data;
    return (value == currVer);
}

BOOL
ShCheckFileCheckSum (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONG value;
    if (!ShLoadFileData (FileData, FD_FINDDATA)) {
        return FALSE;
    }
    if (!ShLoadFileData (FileData, FD_MAPPINGDATA)) {
        return FALSE;
    }
    value = *(UNALIGNED ULONG*)Data;
    return (value == ShGetCheckSum (FileData->FindData.nFileSizeLow, FileData->MappedImage));
}

BOOL
ShCheckFilePECheckSum (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    ULONG value;
    if (!ShLoadFileData (FileData, FD_MAPPINGDATA)) {
        return FALSE;
    }
    value = *(UNALIGNED ULONG*)Data;
    return (value == ShGetPECheckSum (FileData->MappedImage));
}

BOOL
ShCheckStrVersion (
    IN      PFILE_DATA FileData,
    IN      PCTSTR ValueToCheck,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    BOOL result = FALSE;

    if (!ShLoadFileData (FileData, FD_VERSIONDATA)) {
        return FALSE;
    }

    {
#ifndef UNICODE
        PSTR convStr = NULL;
        INT converted = 0;
#endif
        LPCWSTR localData;
        WSTR_ALIGNED_STACK_COPY(&localData,(UNALIGNED TCHAR*)Data);

#ifndef UNICODE
        convStr = HeapAlloc (GetProcessHeap (), 0, DataSize);

        if (convStr)
        {
            converted = WideCharToMultiByte (
                            CP_ACP,
                            0,
                            localData,
                            -1,
                            convStr,
                            DataSize,
                            NULL,
                            NULL
                            );
        }

        if (!converted)
        {
            if (convStr)
                HeapFree (GetProcessHeap (), 0, convStr);

            return FALSE;
        }
        result = ShGlobalVersionCheck (&FileData->VersionData, ValueToCheck, convStr);
        HeapFree (GetProcessHeap (), 0, convStr);
#else
        result = ShGlobalVersionCheck (&FileData->VersionData, ValueToCheck, localData);       
#endif
    }

    return result;
}

BOOL
ShCheckCompanyName (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_COMPANYNAME, DataSize, Data));
}

BOOL
ShCheckProductVersion (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_PRODUCTVERSION, DataSize, Data));
}

BOOL
ShCheckProductName (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_PRODUCTNAME, DataSize, Data));
}

BOOL
ShCheckFileDescription (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_FILEDESCRIPTION, DataSize, Data));
}

BOOL
ShCheckFileVersion (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_FILEVERSION, DataSize, Data));
}

BOOL
ShCheckOriginalFileName (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_ORIGINALFILENAME, DataSize, Data));
}

BOOL
ShCheckInternalName (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_INTERNALNAME, DataSize, Data));
}

BOOL
ShCheckLegalCopyright (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    return (ShCheckStrVersion (FileData, S_VER_LEGALCOPYRIGHT, DataSize, Data));
}

BOOL
ShCheck16BitDescription (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    PTSTR value;
    BOOL result = FALSE;

    value = ShGet16ModuleDescription (FileData->MappedImage);
    if (!value) {
        return FALSE;
    }

    {
#ifndef UNICODE
        PSTR convStr = NULL;
        INT converted = 0;
#endif
        LPCWSTR localData;
        WSTR_ALIGNED_STACK_COPY(&localData,(UNALIGNED TCHAR*)Data);

#ifndef UNICODE
        convStr = HeapAlloc (GetProcessHeap (), 0, DataSize);

        if (convStr)
        {
            converted = WideCharToMultiByte (
                            CP_ACP,
                            0,
                            localData,
                            -1,
                            convStr,
                            DataSize,
                            NULL,
                            NULL
                            );
        }

        if (!converted)
        {
            if (convStr)
                HeapFree (GetProcessHeap (), 0, convStr);

            HeapFree (GetProcessHeap (), 0, value);
            return FALSE;
        }
        result = ShIsPatternMatch (convStr, value);
        HeapFree (GetProcessHeap (), 0, convStr);
#else
        result = ShIsPatternMatch (localData, value);
#endif
    }

    HeapFree (GetProcessHeap (), 0, value);
    return result;
}

BOOL
pShLoadPrevOsData (
    IN      PFILE_DATA FileData,
    IN      PCTSTR ValueName,
    OUT     PDWORD Value
    )
{
    LONG status;
    BOOL result = FALSE;
    DWORD type;
    DWORD valueSize = sizeof (DWORD);

    if (ShLoadFileData (FileData, FD_PREVOSDATA)) {

        status = RegQueryValueEx (FileData->PrevOsKey, ValueName, NULL, &type, (PBYTE)Value, &valueSize);
        if ((status == ERROR_SUCCESS) &&
            (type == REG_DWORD)
            ) {
            result = TRUE;
        }
    }
    return result;
}

BOOL
ShCheckPrevOsMajorVersion (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    BOOL result = FALSE;
    DWORD value = 0;

    if (pShLoadPrevOsData (FileData, S_VAL_MAJORVERSION, &value)) {
        result = (value == *(UNALIGNED DWORD*)(Data));
    }
    return result;
}

BOOL
ShCheckPrevOsMinorVersion (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    BOOL result = FALSE;
    DWORD value = 0;

    if (pShLoadPrevOsData (FileData, S_VAL_MINORVERSION, &value)) {
        result = (value == *(UNALIGNED DWORD*)(Data));
    }
    return result;
}

BOOL
ShCheckPrevOsPlatformId (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    BOOL result = FALSE;
    DWORD value = 0;

    if (pShLoadPrevOsData (FileData, S_VAL_PLATFORMID, &value)) {
        result = (value == *(UNALIGNED DWORD*)(Data));
    }
    return result;
}

BOOL
ShCheckPrevOsBuildNo (
    IN      PFILE_DATA FileData,
    IN      DWORD DataSize,
    IN      PBYTE Data
    )
{
    BOOL result = FALSE;
    DWORD value = 0;

    if (pShLoadPrevOsData (FileData, S_VAL_BUILDNO, &value)) {
        result = (value == *(UNALIGNED DWORD*)(Data));
    }
    return result;
}

BOOL
DoesPathExist (
    IN      PCTSTR Path
    )
{
    BOOL result = FALSE;
    DWORD errMode;

    if (Path)
    {
        errMode = SetErrorMode (SEM_FAILCRITICALERRORS);

        result = (GetFileAttributes (Path) != 0xFFFFFFFF);

        SetErrorMode(errMode);
    }

    return result;
}

BOOL
pShCheckBlob (
    IN      PCTSTR FileName,
    IN      PBYTE Blob,
    IN      BOOL QuickMode
    )
{
    FILE_DATA fileData;
    PVERSION_DATA p;
    DWORD dataId;
    DWORD dataSize;
    BOOL result = TRUE;
    PTSTR reqFile = NULL;
	PTSTR oldReqFile = NULL;
    PCTSTR filePtr = NULL;
    UINT prefixPathChars;

    ZeroMemory (&fileData, sizeof (FILE_DATA));

    fileData.FileName = FileName;
    if (!DoesPathExist (fileData.FileName)) {
        return FALSE;
    }

    filePtr = ShGetFileNameFromPath (FileName);
    if (!filePtr) {
        return FALSE;
    }

    prefixPathChars = (UINT)(filePtr - FileName);

    __try {
        dataId = *((UNALIGNED DWORD*) Blob);
        while (dataId) {
            if (dataId == VTID_REQFILE) {

                Blob += sizeof (DWORD);
                dataSize = *((UNALIGNED DWORD*) Blob);
                if (!dataSize) {
                    // should never happen
                    dataSize = 1;
                }
                Blob += sizeof (DWORD);

                // if this is the first additional file, reqFile is NULL
				oldReqFile = reqFile;

                // dataSize includes terminating nul character
                reqFile = HeapAlloc (GetProcessHeap (), 0, prefixPathChars * sizeof (TCHAR) + dataSize);

                if (!reqFile) {
                    result = FALSE;
                    __leave;
                }

                lstrcpyn (reqFile, fileData.FileName, prefixPathChars + 1);

                // if this is the first additional file, oldReqFile is NULL
				if (oldReqFile) {
                    HeapFree (GetProcessHeap (), 0, oldReqFile);
                }

                {
#ifndef UNICODE
                    PSTR convStr = NULL;
                    INT converted = 0;
#endif
                    LPCWSTR localData;
                    WSTR_ALIGNED_STACK_COPY(&localData,(UNALIGNED TCHAR*)Blob);
#ifndef UNICODE
                    convStr = HeapAlloc (GetProcessHeap (), 0, dataSize);

                    if (convStr)
                    {
                        converted = WideCharToMultiByte (
                                        CP_ACP,
                                        0,
                                        localData,
                                        -1,
                                        convStr,
                                        dataSize,
                                        NULL,
                                        NULL
                                        );
                    }

                    if (!converted)
                    {
                        if (convStr)
                            HeapFree (GetProcessHeap (), 0, convStr);

                        result = FALSE;
                        __leave;
                    }
                    lstrcpyn (reqFile + prefixPathChars, convStr, dataSize / sizeof (TCHAR));
                    HeapFree (GetProcessHeap (), 0, convStr);
#else
                    lstrcpyn (reqFile + prefixPathChars, localData, dataSize / sizeof (TCHAR));
#endif
                }

                reqFile [prefixPathChars + (dataSize / sizeof (TCHAR)) - 1] = 0;

                ShFreeFileData (&fileData);

                fileData.FileName = reqFile;

                if (!DoesPathExist (fileData.FileName)) {
                    result = FALSE;
                    __leave;
                }

                Blob += dataSize;

            } else {
                if (dataId >= VTID_LASTID) {
                    result = FALSE;
                    __leave;
                }

                p = g_VersionData + (dataId - VTID_REQFILE - 1);

                if (p->VersionId != dataId) {
                    result = FALSE;
                    __leave;
                }

                Blob += sizeof (DWORD);
                dataSize = *((UNALIGNED DWORD*) Blob);
                Blob += sizeof (DWORD);
                if (!QuickMode) {
                    if (!p->VersionCheck (&fileData, dataSize, Blob)) {
                        result = FALSE;
                        __leave;
                    }
                }
                Blob += dataSize;
            }
            dataId = *((UNALIGNED DWORD*) Blob);
        }
    }
    __finally {
        if (reqFile) {
            HeapFree (GetProcessHeap (), 0, reqFile);
        }
        ShFreeFileData (&fileData);
    }
    return result;
}

BOOL
SHIsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    )
{
    BOOL result = FALSE;
    PBADAPP_PROP appProp;

    __try {
        if (Data->Size != sizeof (BADAPP_DATA)) {
            return FALSE;
        }
        if (Prop->Size != sizeof (BADAPP_PROP)) {
            return FALSE;
        }
        if (*(PDWORD)(Data->Blob) != sizeof (BADAPP_PROP)) {
            return FALSE;
        }
        if (pShCheckBlob (Data->FilePath, Data->Blob + sizeof (BADAPP_PROP), TRUE)) {
            result = pShCheckBlob (Data->FilePath, Data->Blob + sizeof (BADAPP_PROP), FALSE);
        }
        if (result) {
            appProp = (PBADAPP_PROP) Data->Blob;
            Prop->MsgId = appProp->MsgId;
            Prop->AppType = appProp->AppType;
        }
    }
    __except (1) {
        result = FALSE;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\utils.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Declares various function.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#include <windows.h>
#include <winnt.h>

BOOL
ShIsPatternMatch (
    IN     PCTSTR wstrPattern,
    IN     PCTSTR wstrStr
    );

PCTSTR
ShGetFileNameFromPath (
    IN      PCTSTR PathSpec
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\utils.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Implements various utilities.

Author:

    Calin Negreanu (calinn)  20-Jan-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "utils.h"

#define CHARTYPE WORD
#define PCHARTYPE PWORD

CHARTYPE
pGetNextChar (
    PCTSTR Source
    )
{
    CHARTYPE result;
#ifdef UNICODE
    result = Source [0];
#else
    if (IsDBCSLeadByte (Source [0])) {
        result = *((PCHARTYPE)Source);
    } else {
        result = Source [0];
    }
#endif
    return result;
}

CHARTYPE
pCharLower (
    CHARTYPE ch
    )
{
    return ((CHARTYPE) (CharLower ((PTSTR) ch)));
}

BOOL
ShIsPatternMatch (
    IN     PCTSTR strPat,
    IN     PCTSTR strStr
    )
{
    CHARTYPE chSrc, chPat;

    while (*strStr) {
        chSrc = pCharLower (pGetNextChar (strStr));
        chPat = pCharLower (pGetNextChar (strPat));

        if (chPat == TEXT('*')) {

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = pCharLower (pGetNextChar (CharNext (strPat)));
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == TEXT('?')) {

                // do recursive check for rest of pattern
                if (ShIsPatternMatch (CharNext (strPat), strStr))
                    return TRUE;
            }

            //
            // Allow any character and continue
            //

            strStr = CharNext (strStr);
            continue;
        }

        if (chPat != TEXT('?')) {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        strPat = CharNext (strPat);
        strStr = CharNext (strStr);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = pCharLower (pGetNextChar (strPat));
    while (chPat == TEXT('*')) {
        strPat = CharNext (strPat);
        chPat = pCharLower (pGetNextChar (strPat));
    }
    if (chPat) {
        return FALSE;
    }

    return TRUE;
}

PCTSTR
ShGetLastChar (
    IN      PCTSTR String,
    IN      CHARTYPE Char
    )
{
    PCTSTR lastCharPtr = NULL;

    while (*String) {
        if (pGetNextChar (String) == Char) {
            lastCharPtr = String;
        }
        String = CharNext (String);
    }
    return lastCharPtr;
}

PCTSTR
ShGetFileNameFromPath (
    IN      PCTSTR PathSpec
    )
{
    PCTSTR p;

    p = ShGetLastChar (PathSpec, TEXT('\\'));
    if (p) {
        p = CharNext (p);
    } else {
        p = PathSpec;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\version.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    version.h

Abstract:

    Declares the structures used for version checkings.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#include <windows.h>
#include <winnt.h>

#define MAX_TRANSLATION             32

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    TCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCTSTR FileSpec;
    PCTSTR VersionField;
} VERSION_STRUCT, *PVERSION_STRUCT;

BOOL
ShCreateVersionStruct (
    OUT     PVERSION_STRUCT VersionStruct,
    IN      PCTSTR FileSpec
    );

VOID
ShDestroyVersionStruct (
    IN      PVERSION_STRUCT VersionStruct
    );

ULONGLONG
ShVerGetFileVer (
    IN      PVERSION_STRUCT VersionStruct
    );

ULONGLONG
ShVerGetProductVer (
    IN      PVERSION_STRUCT VersionStruct
    );

DWORD
ShVerGetFileDateLo (
    IN      PVERSION_STRUCT VersionStruct
    );

DWORD
ShVerGetFileDateHi (
    IN      PVERSION_STRUCT VersionStruct
    );

DWORD
ShVerGetFileVerOs (
    IN      PVERSION_STRUCT VersionStruct
    );

DWORD
ShVerGetFileVerType (
    IN      PVERSION_STRUCT VersionStruct
    );

BOOL
ShGlobalVersionCheck (
    IN      PVERSION_STRUCT VersionData,
    IN      PCTSTR NameToCheck,
    IN      PCTSTR ValueToCheck
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\winnt\makefile.inc ===
LIBOBJ          = $(CCSHELL_DIR)\lib\$O

clean:
    -del $(NTTARGETFILES)

#
# Copy badappsu.lib to shell\lib\$(O)
#
$(LIBOBJ)\badappsu.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\badappsu.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\access.h ===
//  --------------------------------------------------------------------------
//  Module Name: Access.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a few classes that assist with ACL manipulation on
//  objects to which a handle has already been opened. This handle must have
//  (obvisouly) have WRITE_DAC access.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Access_
#define     _Access_

#include "DynamicArray.h"

//  --------------------------------------------------------------------------
//  CSecurityDescriptor
//
//  Purpose:    This class allocates and assigns a PSECURITY_DESCRIPTOR
//              structure with the desired access specified.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

class   CSecurityDescriptor
{
    public:
        typedef struct
        {
            PSID_IDENTIFIER_AUTHORITY   pSIDAuthority;
            int                         iSubAuthorityCount;
            DWORD                       dwSubAuthority0,
                                        dwSubAuthority1,
                                        dwSubAuthority2,
                                        dwSubAuthority3,
                                        dwSubAuthority4,
                                        dwSubAuthority5,
                                        dwSubAuthority6,
                                        dwSubAuthority7;
            DWORD                       dwAccessMask;
        } ACCESS_CONTROL, *PACCESS_CONTROL;
    private:
                                        CSecurityDescriptor (void);
                                        ~CSecurityDescriptor (void);
    public:
        static  PSECURITY_DESCRIPTOR    Create (int iCount, const ACCESS_CONTROL *pAccessControl);
    private:
        static  bool                    AddAces (PACL pACL, PSID *pSIDs, int iCount, const ACCESS_CONTROL *pAC);
};

//  --------------------------------------------------------------------------
//  CAccessControlList
//
//  Purpose:    This class manages access allowed ACEs and constructs an ACL
//              from these ACEs. This class only deals with access allowed
//              ACEs.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CAccessControlList : private CDynamicArrayCallback
{
    public:
                                        CAccessControlList (void);
                                        ~CAccessControlList (void);

                                        operator PACL (void);

                NTSTATUS                Add (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence);
                NTSTATUS                Remove (PSID pSID);
    private:
        virtual NTSTATUS                Callback (const void *pvData, int iElementIndex);
    private:
                CDynamicPointerArray    _ACEArray;
                ACL*                    _pACL;
                PSID                    _searchSID;
                int                     _iFoundIndex;
};

//  --------------------------------------------------------------------------
//  CSecuredObject
//
//  Purpose:    This class manages the ACL of a secured object. SIDs can be
//              added or removed from the ACL of the object.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSecuredObject
{
    private:
                        CSecuredObject (void);
    public:
                        CSecuredObject (HANDLE hObject, SE_OBJECT_TYPE seObjectType);
                        ~CSecuredObject (void);

        NTSTATUS        Allow (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)  const;
        NTSTATUS        Remove (PSID pSID)                                          const;
    private:
        NTSTATUS        GetDACL (CAccessControlList& accessControlList)             const;
        NTSTATUS        SetDACL (CAccessControlList& accessControlList)             const;
    private:
        HANDLE          _hObject;
        SE_OBJECT_TYPE  _seObjectType;
};

#endif  /*  _Access_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\version.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.c

Abstract:

    Implements calls to version APIs.

Author:

    Calin Negreanu (calinn)  20-Jan-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "utils.h"
#include "version.h"

static PCTSTR g_DefaultTranslations[] = {
    TEXT("04090000"),
    TEXT("040904E4"),
    TEXT("040904B0"),
    NULL
};

BOOL
ShCreateVersionStruct (
    OUT     PVERSION_STRUCT VersionStruct,
    IN      PCTSTR FileSpec
    )

/*++

Routine Description:

  ShCreateVersionStruct is called to load a version structure from a file
  and to obtain the fixed version stamp info that is language-independent.

  The caller must call ShDestroyVersionStruct after the VersionStruct is no
  longer needed.

Arguments:

  VersionStruct - Receives the version stamp info to be used by other
                  functions in this module

  FileSpec - Specifies the file to obtain version info from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

{
    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCT));
    VersionStruct->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VersionStruct->Size = GetFileVersionInfoSize (
                                (PTSTR) FileSpec,
                                &VersionStruct->Handle
                                );
    if (!VersionStruct->Size) {
        return FALSE;
    }

    VersionStruct->VersionBuffer = HeapAlloc (GetProcessHeap (), 0, VersionStruct->Size);

    if (!VersionStruct->VersionBuffer) {
        return FALSE;
    }

    VersionStruct->StringBuffer = HeapAlloc (GetProcessHeap (), 0, VersionStruct->Size);

    if (!VersionStruct->StringBuffer) {
        return FALSE;
    }


    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfo (
             (PTSTR) FileSpec,
             VersionStruct->Handle,
             VersionStruct->Size,
             VersionStruct->VersionBuffer
             )) {
        ShDestroyVersionStruct (VersionStruct);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValue (
        VersionStruct->VersionBuffer,
        TEXT("\\"),
        &VersionStruct->FixedInfo,
        &VersionStruct->FixedInfoSize
        );

    return TRUE;
}


VOID
ShDestroyVersionStruct (
    IN      PVERSION_STRUCT VersionStruct
    )

/*++

Routine Description:

  ShDestroyVersionStruct cleans up all memory allocated by the routines
  in this module.

Arguments:

  VersionStruct - Specifies the structure to clean up

Return Value:

  none

--*/

{
    if (VersionStruct->VersionBuffer) {
        HeapFree (GetProcessHeap (), 0, VersionStruct->VersionBuffer);
    }
    if (VersionStruct->StringBuffer) {
        HeapFree (GetProcessHeap (), 0, VersionStruct->StringBuffer);
    }

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCT));
}


ULONGLONG
ShVerGetFileVer (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwFileVersionMS;
    }
    return result;
}

ULONGLONG
ShVerGetProductVer (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwProductVersionMS;
    }
    return result;
}

DWORD
ShVerGetFileDateLo (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateLS;
    }
    return 0;
}

DWORD
ShVerGetFileDateHi (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateMS;
    }
    return 0;
}

DWORD
ShVerGetFileVerOs (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileOS;
    }
    return 0;
}

DWORD
ShVerGetFileVerType (
    IN      PVERSION_STRUCT VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileType;
    }
    return 0;
}

PCTSTR
pShEnumVersionValueCommon (
    IN OUT  PVERSION_STRUCT VersionStruct
    );

PCTSTR
pShEnumNextVersionTranslation (
    IN OUT  PVERSION_STRUCT VersionStruct
    );

PCTSTR
pShEnumFirstVersionTranslation (
    IN OUT  PVERSION_STRUCT VersionStruct
    )
{
    UINT ArraySize;

    if (!VerQueryValue (
            VersionStruct->VersionBuffer,
            TEXT("\\VarFileInfo\\Translation"),
            &VersionStruct->Translations,
            &ArraySize
            )) {
        //
        // No translations are available
        //

        ArraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VersionStruct->CurrentDefaultTranslation = 0;
    VersionStruct->MaxTranslations = ArraySize / sizeof (TRANSLATION);
    VersionStruct->CurrentTranslation = 0;

    return pShEnumNextVersionTranslation (VersionStruct);
}

BOOL
pShIsDefaultTranslation (
    IN      PCTSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslations[i] ; i++) {
        if (lstrcmpi (TranslationStr, g_DefaultTranslations[i]) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

PCTSTR
pShEnumNextVersionTranslation (
    IN OUT  PVERSION_STRUCT VersionStruct
    )
{
    PTRANSLATION Translation;

    if (g_DefaultTranslations[VersionStruct->CurrentDefaultTranslation]) {

        lstrcpy (VersionStruct->TranslationStr, g_DefaultTranslations[VersionStruct->CurrentDefaultTranslation]);
        VersionStruct->CurrentDefaultTranslation++;

    } else {

        do {
            if (VersionStruct->CurrentTranslation == VersionStruct->MaxTranslations) {
                return NULL;
            }

            Translation = &VersionStruct->Translations[VersionStruct->CurrentTranslation];

            wsprintf (
                VersionStruct->TranslationStr,
                TEXT("%04x%04x"),
                Translation->CodePage,
                Translation->Language
                );

            VersionStruct->CurrentTranslation++;

        } while (pShIsDefaultTranslation (VersionStruct->TranslationStr));
    }

    return VersionStruct->TranslationStr;
}


PCTSTR
pShEnumNextVersionValue (
    IN OUT  PVERSION_STRUCT VersionStruct
    )
{
    PCTSTR rc = NULL;

    do {
        if (!pShEnumNextVersionTranslation (VersionStruct)) {
            break;
        }

        rc = pShEnumVersionValueCommon (VersionStruct);

    } while (!rc);

    return rc;
}

PCTSTR
pShEnumFirstVersionValue (
    IN OUT  PVERSION_STRUCT VersionStruct,
    IN      PCTSTR VersionField
    )
{
    PCTSTR rc;

    if (!pShEnumFirstVersionTranslation (VersionStruct)) {
        return NULL;
    }

    VersionStruct->VersionField = VersionField;

    rc = pShEnumVersionValueCommon (VersionStruct);

    if (!rc) {
        rc = pShEnumNextVersionValue (VersionStruct);
    }

    return rc;
}

PCTSTR
pShEnumVersionValueCommon (
    IN OUT  PVERSION_STRUCT VersionStruct
    )
{
    PTSTR Text;
    UINT StringLen;
    PBYTE String;
    PCTSTR Result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //
    Text = HeapAlloc (GetProcessHeap (), 0, (18 + lstrlen (VersionStruct->TranslationStr) + lstrlen (VersionStruct->VersionField)) * sizeof (TCHAR));

    if (!Text) {
        return NULL;
    }

    wsprintf (
        Text,
        TEXT("\\StringFileInfo\\%s\\%s"),
        VersionStruct->TranslationStr,
        VersionStruct->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValue (
                VersionStruct->VersionBuffer,
                Text,
                &String,
                &StringLen
                )) {
            //
            // No value is available
            //

            return NULL;
        }
        CopyMemory (VersionStruct->StringBuffer, String, StringLen * sizeof (TCHAR));
        VersionStruct->StringBuffer [StringLen * sizeof (TCHAR)] = 0;
        Result = (PTSTR) VersionStruct->StringBuffer;

    }
    __finally {
        HeapFree (GetProcessHeap (), 0, Text);
    }

    return Result;
}

BOOL
ShGlobalVersionCheck (
    IN      PVERSION_STRUCT VersionData,
    IN      PCTSTR NameToCheck,
    IN      PCTSTR ValueToCheck
    )
{
    PCTSTR CurrentStr;
    BOOL result = FALSE;

    CurrentStr = pShEnumFirstVersionValue (VersionData, NameToCheck);
    while (CurrentStr) {
        if (ShIsPatternMatch (ValueToCheck, CurrentStr)) {
            result = TRUE;
            break;
        }
        CurrentStr = pShEnumNextVersionValue (VersionData);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\badapps\win95\makefile.inc ===
LIBOBJ          = $(CCSHELL_DIR)\lib\$O

clean:
    -del $(NTTARGETFILES)

#
# Copy badappsa.lib to shell\lib\$(O)
#
$(LIBOBJ)\badappsa.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\badappsa.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\countedobject.h ===
//  --------------------------------------------------------------------------
//  Module Name: CountedObjects.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements object reference counting
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _CountedObject_
#define     _CountedObject_

#include "DynamicObject.h"

//  --------------------------------------------------------------------------
//  CCountedObject
//
//  Purpose:    This class is a base class that implements object reference
//              counting. The default constructor is protected to disable
//              instantiating this object unless subclassed. The reference
//              count is private because subclasses really shouldn't need to
//              know about the reference counting.
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CCountedObject : public CDynamicObject
{
    protected:
                                CCountedObject (void);
        virtual                 ~CCountedObject (void);
    public:
                void            AddRef (void);
                void            Release (void);

                LONG            GetCount (void)     const;
    private:
        LONG                    _lReferenceCount;
        bool                    _fReleased;
};

#endif  /*  _CountedObject_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\access.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Access.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  This file contains a few classes that assist with ACL manipulation on
//  objects to which a handle has already been opened. This handle must have
//  (obvisouly) have WRITE_DAC access.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Access.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CSecurityDescriptor::CSecurityDescriptor
//
//  Arguments:  iCount          =   Count of ACCESS_CONTROLS passed in.
//              pAccessControl  =   Pointer to ACCESS_CONTROLS.
//
//  Returns:    <none>
//
//  Purpose:    Allocates and assigns the PSECURITY_DESCRIPTOR that
//              corresponds to the description given by the parameters. The
//              caller must release the memory allocated via LocalFree.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

PSECURITY_DESCRIPTOR    CSecurityDescriptor::Create (int iCount, const ACCESS_CONTROL *pAccessControl)

{
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
    PSID                    *pSIDs;

    pSecurityDescriptor = NULL;

    //  Allocate an array of PSIDs required to hold all the SIDs to add.

    pSIDs = reinterpret_cast<PSID*>(LocalAlloc(LPTR, iCount * sizeof(PSID)));
    if (pSIDs != NULL)
    {
        bool                    fSuccessfulAllocate;
        int                     i;
        const ACCESS_CONTROL    *pAC;

        for (fSuccessfulAllocate = true, pAC = pAccessControl, i = 0; fSuccessfulAllocate && (i < iCount); ++pAC, ++i)
        {
            fSuccessfulAllocate = (AllocateAndInitializeSid(pAC->pSIDAuthority,
                                                            static_cast<BYTE>(pAC->iSubAuthorityCount),
                                                            pAC->dwSubAuthority0,
                                                            pAC->dwSubAuthority1,
                                                            pAC->dwSubAuthority2,
                                                            pAC->dwSubAuthority3,
                                                            pAC->dwSubAuthority4,
                                                            pAC->dwSubAuthority5,
                                                            pAC->dwSubAuthority6,
                                                            pAC->dwSubAuthority7,
                                                            &pSIDs[i]) != FALSE);
        }
        if (fSuccessfulAllocate)
        {
            DWORD           dwACLSize;
            unsigned char   *pBuffer;

            //  Calculate the size of the ACL required by totalling the ACL header
            //  struct and the 2 ACCESS_ALLOWED_ACE structs with the SID sizes.
            //  Add the SECURITY_DESCRIPTOR struct size as well.

            dwACLSize = sizeof(ACL) + ((sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 3);
            for (i = 0; i < iCount; ++i)
            {
                dwACLSize += GetLengthSid(pSIDs[i]);
            }

            //  Allocate the buffer for everything and portion off the buffer to
            //  the right place.

            pBuffer = static_cast<unsigned char*>(LocalAlloc(LMEM_FIXED, sizeof(SECURITY_DESCRIPTOR) + dwACLSize));
            if (pBuffer != NULL)
            {
                PSECURITY_DESCRIPTOR    pSD;
                PACL                    pACL;

                pSD = reinterpret_cast<PSECURITY_DESCRIPTOR>(pBuffer);
                pACL = reinterpret_cast<PACL>(pBuffer + sizeof(SECURITY_DESCRIPTOR));

                //  Initialize the ACL. Fill in the ACL.
                //  Initialize the SECURITY_DESCRIPTOR. Set the security descriptor.

                if ((InitializeAcl(pACL, dwACLSize, ACL_REVISION) != FALSE) &&
                    AddAces(pACL, pSIDs, iCount, pAccessControl) &&
                    (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION) != FALSE) &&
                    (SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE) != FALSE))
                {
                    pSecurityDescriptor = pSD;
                }
                else
                {
                    (HLOCAL)LocalFree(pBuffer);
                }
            }
        }
        for (i = iCount - 1; i >= 0; --i)
        {
            if (pSIDs[i] != NULL)
            {
                (void*)FreeSid(pSIDs[i]);
            }
        }
        (HLOCAL)LocalFree(pSIDs);
    }
    return(pSecurityDescriptor);
}

//  --------------------------------------------------------------------------
//  CSecurityDescriptor::AddAces
//
//  Arguments:  pACL            =   PACL to add ACEs to.
//              pSIDs           =   Pointer to SIDs.
//              iCount          =   Count of ACCESS_CONTROLS passed in.
//              pAccessControl  =   Pointer to ACCESS_CONTROLS.
//
//  Returns:    bool
//
//  Purpose:    Adds access allowed ACEs to the given ACL.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

bool    CSecurityDescriptor::AddAces (PACL pACL, PSID *pSIDs, int iCount, const ACCESS_CONTROL *pAC)

{
    bool    fResult;
    int     i;

    for (fResult = true, i = 0; fResult && (i < iCount); ++pSIDs, ++pAC, ++i)
    {
        fResult = (AddAccessAllowedAce(pACL, ACL_REVISION, pAC->dwAccessMask, *pSIDs) != FALSE);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::CAccessControlList
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CAccessControlList object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::CAccessControlList (void) :
    _pACL(NULL)

{
}

//  --------------------------------------------------------------------------
//  CAccessControlList::~CAccessControlList
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CAccessControlList object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::~CAccessControlList (void)

{
    ReleaseMemory(_pACL);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::operator PACL
//
//  Arguments:  <none>
//
//  Returns:    PACL
//
//  Purpose:    If the ACL has been constructed returns that value. If not
//              then the ACL is constructed from the ACEs and then returned.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::operator PACL (void)

{
    PACL    pACL;

    if (_pACL == NULL)
    {
        int     i;
        DWORD   dwACLSize, dwSizeOfAllACEs;

        pACL = NULL;
        dwSizeOfAllACEs = 0;

        //  Walk thru all the ACEs to calculate the total size
        //  required for the ACL.

        for (i = _ACEArray.GetCount() - 1; i >= 0; --i)
        {
            ACCESS_ALLOWED_ACE  *pACE;

            pACE = static_cast<ACCESS_ALLOWED_ACE*>(_ACEArray.Get(i));
            dwSizeOfAllACEs += pACE->Header.AceSize;
        }
        dwACLSize = sizeof(ACL) + dwSizeOfAllACEs;
        _pACL = pACL = static_cast<ACL*>(LocalAlloc(LMEM_FIXED, dwACLSize));
        if (pACL != NULL)
        {
            TBOOL(InitializeAcl(pACL, dwACLSize, ACL_REVISION));

            //  Construct the ACL in reverse order of the ACEs. This
            //  allows CAccessControlList::Add to actually insert the
            //  granted access at the head of the list which is usually
            //  the desired result. The order of the ACEs is important!

            for (i = _ACEArray.GetCount() - 1; i >= 0; --i)
            {
                ACCESS_ALLOWED_ACE  *pACE;

                pACE = static_cast<ACCESS_ALLOWED_ACE*>(_ACEArray.Get(i));
                TBOOL(AddAccessAllowedAceEx(pACL, ACL_REVISION, pACE->Header.AceFlags, pACE->Mask, reinterpret_cast<PSID>(&pACE->SidStart)));
            }
        }
    }
    else
    {
        pACL = _pACL;
    }
    return(pACL);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Add
//
//  Arguments:  pSID            =   SID to grant access to.
//              dwMask          =   Level of access to grant.
//              ucInheritence   =   Type of inheritence for this access.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the given SID, access and inheritence type as an ACE to
//              the list of ACEs to build into an ACL. The ACE array is
//              allocated in blocks of 16 pointers to reduce repeated calls
//              to allocate memory if many ACEs are added.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Add (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)

{
    NTSTATUS            status;
    DWORD               dwSIDLength, dwACESize;
    ACCESS_ALLOWED_ACE  *pACE;

    dwSIDLength = GetLengthSid(pSID);
    dwACESize = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + dwSIDLength;
    pACE = static_cast<ACCESS_ALLOWED_ACE*>(LocalAlloc(LMEM_FIXED, dwACESize));
    if (pACE != NULL)
    {
        pACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pACE->Header.AceFlags = ucInheritence;
        pACE->Header.AceSize = static_cast<USHORT>(dwACESize);
        pACE->Mask = dwMask;
        CopyMemory(&pACE->SidStart, pSID, dwSIDLength);
        status = _ACEArray.Add(pACE);
        if (STATUS_NO_MEMORY == status)
        {
            (HLOCAL)LocalFree(pACE);
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Remove
//
//  Arguments:  pSID            =   SID to revoke access from.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes all references to the given SID from the ACE list.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Remove (PSID pSID)

{
    NTSTATUS    status;

    //  Set up for an iteration of the array.

    _searchSID = pSID;
    _iFoundIndex = -1;
    status = _ACEArray.Iterate(this);
    while (NT_SUCCESS(status) && (_iFoundIndex >= 0))
    {

        //  When the SIDs are found to match remove this entry.
        //  ALL matching SID entries are removed!

        status = _ACEArray.Remove(_iFoundIndex);
        if (NT_SUCCESS(status))
        {
            _iFoundIndex = -1;
            status = _ACEArray.Iterate(this);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Callback
//
//  Arguments:  pvData          =   Pointer to the array index data.
//              iElementIndex   =   Index into the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Callback from the CDynamicArray::Iterate function. This
//              method can be used to process the array contents by index or
//              by content when iterating thru the array. Return an error
//              status to stop the iteration and have that value returned to
//              the caller of CDynamicArray::Iterate.
//
//              Converts the pointer into a pointer to an ACCESS_ALLOWED_ACE.
//              The compares the SID in that ACE to the desired search SID.
//              Saves the index if found.
//
//  History:    1999-11-15  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Callback (const void *pvData, int iElementIndex)

{
    const ACCESS_ALLOWED_ACE    *pACE;

    pACE = *reinterpret_cast<const ACCESS_ALLOWED_ACE* const*>(pvData);
    if (EqualSid(reinterpret_cast<PSID>(const_cast<unsigned long*>((&pACE->SidStart))), _searchSID) != FALSE)
    {
        _iFoundIndex = iElementIndex;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::CSecuredObject
//
//  Arguments:  hObject         =   Optional HANDLE to the object to secure.
//              seObjectType    =   Type of object specified in handle.
//
//  Returns:    <none>
//
//  Purpose:    Sets the optionally given HANDLE into the member variables.
//              The HANDLE is duplicated so the caller must release their
//              HANDLE.
//
//              In order for this class to work the handle you pass it MUST
//              have DUPLICATE access as well as READ_CONTROL and WRITE_DAC.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CSecuredObject::CSecuredObject (HANDLE hObject, SE_OBJECT_TYPE seObjectType) :
    _hObject(hObject),
    _seObjectType(seObjectType)

{
}

//  --------------------------------------------------------------------------
//  CSecuredObject::~CSecuredObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release our HANDLE reference.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CSecuredObject::~CSecuredObject (void)

{
}

//  --------------------------------------------------------------------------
//  CSecuredObject::Allow
//
//  Arguments:  pSID            =   SID to grant access to.
//              dwMask          =   Level of access to grant.
//              ucInheritence   =   Type of inheritence for this access.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Get the DACL for the object. Add the desired access. Set the
//              DACL for the object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::Allow (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)  const

{
    NTSTATUS            status;
    CAccessControlList  accessControlList;

    status = GetDACL(accessControlList);
    if (NT_SUCCESS(status))
    {
        status = accessControlList.Add(pSID, dwMask, ucInheritence);
        if (NT_SUCCESS(status))
        {
            status = SetDACL(accessControlList);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::Remove
//
//  Arguments:  pSID            =   SID to revoke access from.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Get the DACL for the object. Remove the desired access. Set
//              the DACL for the object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::Remove (PSID pSID)                                          const

{
    NTSTATUS            status;
    CAccessControlList  accessControlList;

    status = GetDACL(accessControlList);
    if (NT_SUCCESS(status))
    {
        status = accessControlList.Remove(pSID);
        if (NT_SUCCESS(status))
        {
            status = SetDACL(accessControlList);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::GetDACL
//
//  Arguments:  accessControlList   =   CAccessControlList that gets the
//                                      decomposed DACL into ACEs.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets the object's DACL and walk the individual ACEs and add
//              this access to the CAccessControlList object given. The access
//              is walked backward to allow CAccessControlList::Add to add to
//              end of the list but actually add to the head of the list.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::GetDACL (CAccessControlList& accessControlList)             const

{
    NTSTATUS                status;
    DWORD                   dwResult;
    PACL                    pDACL;
    PSECURITY_DESCRIPTOR    pSD;

    status = STATUS_SUCCESS;
    pSD = NULL;
    pDACL = NULL;
    dwResult = GetSecurityInfo(_hObject,
                               _seObjectType,
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               &pDACL,
                               NULL,
                               &pSD);
    if ((ERROR_SUCCESS == dwResult) && (pDACL != NULL))
    {
        int                 i;
        ACCESS_ALLOWED_ACE  *pAce;

        for (i = pDACL->AceCount - 1; NT_SUCCESS(status) && (i >= 0); --i)
        {
            if (GetAce(pDACL, i, reinterpret_cast<void**>(&pAce)) != FALSE)
            {
                ASSERTMSG(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE, "Expect only access allowed ACEs in CSecuredObject::MakeIndividualACEs");
                status = accessControlList.Add(reinterpret_cast<PSID>(&pAce->SidStart), pAce->Mask, pAce->Header.AceFlags);
            }
        }
    }
    ReleaseMemory(pSD);
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::SetDACL
//
//  Arguments:  accessControlList   =   CAccessControlList that contains all
//                                      ACEs to build into an ACL.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Builds the ACL for the given ACE list and sets the DACL into
//              the object handle.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::SetDACL (CAccessControlList& accessControlList)             const

{
    NTSTATUS    status;
    DWORD       dwResult;

    dwResult = SetSecurityInfo(_hObject,
                               _seObjectType,
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               accessControlList,
                               NULL);
    if (ERROR_SUCCESS == dwResult)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfErrorCode(dwResult);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\countedobject.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CountedObjects.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements object reference counting
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CCountedObject::CCountedObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the reference count to 1.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CCountedObject::CCountedObject (void) :
    _lReferenceCount(1),
    _fReleased(false)

{
}

//  --------------------------------------------------------------------------
//  CCountedObject::~CCountedObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Virtual destructor that just checks valid deletion.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CCountedObject::~CCountedObject (void)

{
    ASSERTMSG(_fReleased, "CCountedObject::~CCountedObject invoked without being released");
}

//  --------------------------------------------------------------------------
//  CCountedObject::AddRef
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Increments the object's reference count.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

void    CCountedObject::AddRef (void)

{
    InterlockedIncrement(&_lReferenceCount);
}

//  --------------------------------------------------------------------------
//  CCountedObject::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Decrements the object's reference count. When the count
//              reaches zero the object is deleted. Do NOT use referenced
//              objects when using stack based objects. These must be
//              dynamically allocated.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

void    CCountedObject::Release (void)

{
    if (InterlockedDecrement(&_lReferenceCount) == 0)
    {
        _fReleased = true;
        delete this;
    }
}

//  --------------------------------------------------------------------------
//  CCountedObject::GetCount
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Returns the count of outstanding references on the object.
//
//  History:    2000-07-17  vtan        created
//  --------------------------------------------------------------------------

LONG    CCountedObject::GetCount (void)     const

{
    return(_lReferenceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\dynamicarray.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicArray.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains related classes to manage dynamic arrays. The array is
//  grown as required but never shrunk. The base class handles struct arrays.
//  Subclasses handle special cases of these arrays (such as pointer or
//  CCountedObject arrays).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "DynamicArray.h"

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CDynamicArray::CDynamicArray
//
//  Arguments:  iElementSize    =   Size of each array element.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDynamicArray. Stores the element size and
//              initializes the memory used to NULL.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicArray::CDynamicArray (int iElementSize) :
    _iElementSize(iElementSize),
    _iArraySize(0),
    _pvArray(NULL)

{
    ASSERTMSG(iElementSize > 0, "Cannot have negative or zero length element size in CDynamicArray::CDynamicArray");
}

//  --------------------------------------------------------------------------
//  CDynamicArray::~CDynamicArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicArray. Frees the memory used by the
//              array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicArray::~CDynamicArray (void)

{
    ReleaseMemory(_pvArray);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Add
//
//  Arguments:  pvData  =   Pointer to the data to copy to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Allocates memory for the element to be added to the array. If
//              there is no memory block it allocates an initial block. If
//              there isn't enough memory in the block to hold the next
//              element then it allocates a new larger block.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Add (const void *pvData)

{
    NTSTATUS    status;

    static  const int   DEFAULT_ELEMENTS_PER_ALLOCATE   =   16;

    status = STATUS_NO_MEMORY;

    //  If no array exists then allocate the first
    //  block of memory for this array.

    if (_pvArray == NULL)
    {
        _iArraySize = 0;
        _iArrayAllocatedSize = DEFAULT_ELEMENTS_PER_ALLOCATE;
        _pvArray = LocalAlloc(LPTR, _iElementSize * _iArrayAllocatedSize);
    }

    //  If the array exists but the limit of the allocated size has
    //  been reached then allocate a new block, copy the current
    //  block contents and fall thru.

    if (_pvArray != NULL)
    {
        if (_iArraySize == _iArrayAllocatedSize)
        {
            void    *pvNewArray;

            pvNewArray = LocalAlloc(LPTR, _iElementSize * (_iArrayAllocatedSize + DEFAULT_ELEMENTS_PER_ALLOCATE));
            if (pvNewArray != NULL)
            {
                _iArrayAllocatedSize += DEFAULT_ELEMENTS_PER_ALLOCATE;
                CopyMemory(pvNewArray, _pvArray, _iElementSize * _iArraySize);
                _pvArray = pvNewArray;
            }
        }

        //  Otherwise there is a spare slot in the array. Copy the
        //  data to the array. Increment the array size.

        if (_iArraySize < _iArrayAllocatedSize)
        {
            CopyMemory(static_cast<char*>(_pvArray) + (_iElementSize * _iArraySize), pvData, _iElementSize);
            ++_iArraySize;
            status = STATUS_SUCCESS;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes the element from the array. Slides down all the
//              members but does not reduce the size of the memory block used
//              by the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Remove (int iElementIndex)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {

        //  Make sure the index is valid.

        if (iElementIndex < _iArraySize)
        {
            int     iMoveSize;

            //  Determine the amount of bytes to move when deleting this
            //  element and move the memory. Don't resize the array when
            //  shrinking. Just leave it alone.

            iMoveSize = _iElementSize * (_iArraySize - iElementIndex - 1);
            ASSERTMSG(iMoveSize >= 0, "Negative move memory size in CDynamicArray::Remove");
            if (iMoveSize > 0)
            {
                MoveMemory(static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), static_cast<char*>(_pvArray) + (_iElementSize * (iElementIndex + 1)), iMoveSize);
            }
            ZeroMemory(static_cast<char*>(_pvArray) + (_iElementSize * (_iArraySize - 1)), _iElementSize);
            --_iArraySize;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::GetCount
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the number of elements in the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

int     CDynamicArray::GetCount (void)                             const

{
    return(_iArraySize);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Get
//
//  Arguments:  pvData          =   Pointer to memory to receive element.
//              iElementIndex   =   Index of element to retrieve in array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Copies the data for the specified element by index to the
//              block of memory given. No checks for access violations.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Get (void *pvData, int iElementIndex)

{
    NTSTATUS    status;

    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        CopyMemory(pvData, static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), _iElementSize);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Set
//
//  Arguments:  pvData          =   Pointer to memory to receive element.
//              iElementIndex   =   Index of element to retrieve in array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Copies the data for the specified element by index from the
//              block of memory given. No checks for access violations.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Set (const void* pvData, int iElementIndex)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {
        if (iElementIndex < _iArraySize)
        {
            CopyMemory(static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), pvData, _iElementSize);
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Iterate
//
//  Arguments:  pDynamicArrayCallback   =   Interface containing callback.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Iterate the elements of the array. Call the callback function
//              specified in the interface and give it a pointer to the
//              element and the index. Adhere to the NTSTATUS returned from
//              the callback and terminate on an unsuccessful result.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Iterate (CDynamicArrayCallback *pDynamicArrayCallback)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; NT_SUCCESS(status) && (i >= 0); --i)
        {
            status = pDynamicArrayCallback->Callback(static_cast<char*>(_pvArray) + (_iElementSize * i), i);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::CDynamicPointerArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDynamicPointerArray. All elements of this
//              class are pointers that are allocated with LocalAlloc.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicPointerArray::CDynamicPointerArray (void) :
    CDynamicArray(sizeof(void*))

{
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::~CDynamicPointerArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicPointerArray. Walk the entire array
//              and free each pointer in the array before allowing the base
//              class destructor to release the memory allocated for the
//              actual array itself.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicPointerArray::~CDynamicPointerArray (void)

{
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; i >= 0; --i)
        {
            ReleaseMemory(static_cast<void**>(_pvArray)[i]);
        }
    }
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Add
//
//  Arguments:  pvData  =   Pointer to add to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Add the given pointer to the array. The pointer is passed in
//              to this function not a pointer to the pointer.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicPointerArray::Add (const void *pvData)

{
    return(CDynamicArray::Add(&pvData));
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the memory occupied by the element and then removes
//              the element from the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicPointerArray::Remove (int iElementIndex)

{
    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        ReleaseMemory(static_cast<void**>(_pvArray)[iElementIndex]);
    }
    return(CDynamicArray::Remove(iElementIndex));
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Get
//
//  Arguments:  iElementIndex   =   Index of the element to get.
//
//  Returns:    void*
//
//  Purpose:    Returns the address of the given element in the array. This
//              applies only to pointer arrays.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

void*   CDynamicPointerArray::Get (int iElementIndex)

{
    void*   pvData;

    if (!NT_SUCCESS(CDynamicArray::Get(&pvData, iElementIndex)))
    {
        pvData = NULL;
    }
    return(pvData);
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::CDynamicCountedObjectArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CDynamicCountedObjectArray. All elements
//              should be a subclass of CCountedObject in some way.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray::CDynamicCountedObjectArray (void) :
    CDynamicArray(sizeof(CCountedObject*))

{
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::~CDynamicCountedObjectArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicCountedObjectArray. Walk the entire
//              array and release each CCountedObject in the array before
//              allowing the base class destructor to release the memory
//              allocated for the actual array itself.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray::~CDynamicCountedObjectArray (void)

{
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; i >= 0; --i)
        {
            reinterpret_cast<CCountedObject**>(_pvArray)[i]->Release();
        }
    }
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Add
//
//  Arguments:  pvData   =   CCountedObject* to add to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the CCountedObject* to the array. Calls
//              CCountedObject::AddRef to incremenet the reference count on
//              the object. If the object cannot be added the reference is
//              released.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicCountedObjectArray::Add (CCountedObject *pvData)

{
    NTSTATUS    status;

    pvData->AddRef();
    status = CDynamicArray::Add(&pvData);
    if (!NT_SUCCESS(status))
    {
        pvData->Release();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the reference held on the CCountedObject* and then
//              removes the element from the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicCountedObjectArray::Remove (int iElementIndex)

{
    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        reinterpret_cast<CCountedObject**>(_pvArray)[iElementIndex]->Release();
    }
    return(CDynamicArray::Remove(iElementIndex));
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Get
//
//  Arguments:  iElementIndex   =   Index of the element to get.
//
//  Returns:    CCountedObject*
//
//  Purpose:    Returns the address of the given element in the array. This
//              applies only to CCountedObject* arrays. This does NOT call
//              CCountedObject::AddRef on the returned pointer.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CCountedObject*     CDynamicCountedObjectArray::Get (int iElementIndex)

{
    CCountedObject*     pObject;

    pObject = NULL;
    (NTSTATUS)CDynamicArray::Get(&pObject, iElementIndex);
    return(pObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\dynamicarray.h ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicArray.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains related classes to manage dynamic arrays. The array is
//  grown as required but never shrunk. The base class handles struct arrays.
//  Subclasses handle special cases of these arrays (such as pointer or
//  CCountedObject arrays).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _DynamicArray_
#define     _DynamicArray_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CDynamicArrayCallback
//
//  Purpose:    Abstract class definition providing a callback mechanism for
//              iterating the dynamic array.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicArrayCallback
{
    public:
        virtual NTSTATUS    Callback (const void *pvData, int iElementIndex) = 0;
};

//  --------------------------------------------------------------------------
//  CDynamicArray
//
//  Purpose:    Base class that handles dynamic struct arrays. Allocates
//              memory for the array in 16 block chunks. The memory usage of
//              the array is never reduced.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicArray
{
    private:
                                    CDynamicArray (void);
    public:
                                    CDynamicArray (int iElementSize);
        virtual                     ~CDynamicArray (void);

        virtual NTSTATUS            Add (const void *pvData);
        virtual NTSTATUS            Remove (int iElementIndex);

                int                 GetCount (void)                             const;
                NTSTATUS            Get (void *pvData, int iElementIndex);
                NTSTATUS            Set (const void* pvData, int iElementIndex);

                NTSTATUS            Iterate (CDynamicArrayCallback *pDynamicArrayCallback);
    protected:
                int                 _iElementSize,
                                    _iArraySize,
                                    _iArrayAllocatedSize;
                void*               _pvArray;
};

//  --------------------------------------------------------------------------
//  CDynamicPointerArray
//
//  Purpose:    Class that subclasses CDynamicArray to implement dynamic
//              pointer arrays. Removing elements automatically frees the
//              memory block used (assuming it was allocated with LocalAlloc).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicPointerArray : public CDynamicArray
{
    public:
                                    CDynamicPointerArray (void);
        virtual                     ~CDynamicPointerArray (void);

        virtual NTSTATUS            Add (const void *pvData);
        virtual NTSTATUS            Remove (int iElementIndex);

                void*               Get (int iElementIndex);
};

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray
//
//  Purpose:    Class that subclasses CDynamicArray to implement dynamic
//              CCountedObject arrays. Removing elements automatically
//              releases the reference held on the dynamic object.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicCountedObjectArray : public CDynamicArray
{
    public:
                                    CDynamicCountedObjectArray (void);
        virtual                     ~CDynamicCountedObjectArray (void);

                NTSTATUS            Add (CCountedObject *pData);
        virtual NTSTATUS            Remove (int iElementIndex);

                CCountedObject*     Get (int iElementIndex);
};

#endif  /*  _DynamicArray_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\impersonation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Impersonation.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Impersonation.h"

#include "Access.h"
#include "SingleThreadedExecution.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CImpersonation::s_pMutex
//  CImpersonation::s_iReferenceCount
//
//  Purpose:    Static member variables that control access to the global
//              reference count which controls calling
//              kernel32!OpenProfileUserMapping which is a global entity in
//              kernel32.dll.
//  --------------------------------------------------------------------------

CMutex*     CImpersonation::s_pMutex            =   NULL;
int         CImpersonation::s_iReferenceCount   =   -1;

//  --------------------------------------------------------------------------
//  CImpersonation::CImpersonation
//
//  Arguments:  hToken  =   User token to impersonate.
//
//  Returns:    <none>
//
//  Purpose:    Causes the current thread to impersonate the given user for
//              scope of the object. See advapi32!ImpersonateLoggedOnUser for
//              more information on the token requirements. If the thread is
//              already impersonating a debug warning is issued and the
//              request is ignored.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CImpersonation::CImpersonation (HANDLE hToken) :
    _status(STATUS_UNSUCCESSFUL),
    _fAlreadyImpersonating(false)

{
    HANDLE      hImpersonationToken;

    ASSERTMSG(s_iReferenceCount >= 0, "Negative reference count in CImpersonation::CImpersonation");
    _fAlreadyImpersonating = (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hImpersonationToken) != FALSE);
    if (_fAlreadyImpersonating)
    {
        TBOOL(CloseHandle(hImpersonationToken));
        WARNINGMSG("Thread is already impersonating a user in CImpersonation::CImpersonation");
    }
    else
    {
        _status = ImpersonateUser(GetCurrentThread(), hToken);

        {
            CSingleThreadedMutexExecution   execution(*s_pMutex);

            //  Acquire the s_pMutex mutex before using the reference count.
            //  Control the reference count so that we only call
            //  kernel32!OpenProfileUserMapping for a single impersonation
            //  session. Calling kernel32!CloseProfileUserMapping will
            //  destroy kernel32.dll's global HKEY to the current user.

            if (s_iReferenceCount++ == 0)
            {
                TBOOL(OpenProfileUserMapping());
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CImpersonation::~CImpersonation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Reverts to the self token for the thread on the object going
//              out of scope.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CImpersonation::~CImpersonation (void)

{
    if (!_fAlreadyImpersonating)
    {
        {
            CSingleThreadedMutexExecution   execution(*s_pMutex);

            //  When the reference count hits zero - close the mapping.

            if (--s_iReferenceCount == 0)
            {
                TBOOL(CloseProfileUserMapping());
            }
        }
        TBOOL(RevertToSelf());
    }
}

//  --------------------------------------------------------------------------
//  CImpersonation::IsImpersonating
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the constructor successfully completed
//              impersonating the user.
//
//  History:    2001-01-18  vtan        created
//  --------------------------------------------------------------------------

bool    CImpersonation::IsImpersonating (void)  const

{
    return(NT_SUCCESS(_status));
}

//  --------------------------------------------------------------------------
//  CImpersonation::ImpersonateUser
//
//  Arguments:  hThread     =   HANDLE to the thread that will impersonate.
//              hToken      =   Token of user to impersonate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Duplicate the given token as an impersonation token. ACL the
//              new token and set it into the thread token.
//
//  History:    1999-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::ImpersonateUser (HANDLE hThread, HANDLE hToken)

{
    NTSTATUS                        status;
    HANDLE                          hImpersonationToken;
    OBJECT_ATTRIBUTES               objectAttributes;
    SECURITY_QUALITY_OF_SERVICE     securityQualityOfService;

    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               OBJ_INHERIT,
                               NULL,
                               NULL);
    securityQualityOfService.Length = sizeof(securityQualityOfService);
    securityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    securityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    securityQualityOfService.EffectiveOnly = FALSE;
    objectAttributes.SecurityQualityOfService = &securityQualityOfService;
    status = NtDuplicateToken(hToken,
                              TOKEN_IMPERSONATE | TOKEN_QUERY | READ_CONTROL | WRITE_DAC,
                              &objectAttributes,
                              FALSE,
                              TokenImpersonation,
                              &hImpersonationToken);
    if (NT_SUCCESS(status))
    {
        PSID                pLogonSID;
        CTokenInformation   tokenInformation(hImpersonationToken);

        pLogonSID = tokenInformation.GetLogonSID();
        if (pLogonSID != NULL)
        {
            CSecuredObject  tokenSecurity(hImpersonationToken, SE_KERNEL_OBJECT);

            TSTATUS(tokenSecurity.Allow(pLogonSID,
                                        TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
                                        0));
        }
        status = NtSetInformationThread(hThread,
                                        ThreadImpersonationToken,
                                        &hImpersonationToken,
                                        sizeof(hImpersonationToken));
        TSTATUS(NtClose(hImpersonationToken));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CImpersonation::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes the mutex object and the reference count. The
//              reference count is initialized to -1 by the compiler to help
//              detect cases where this function is not called!
//
//  History:    1999-10-13  vtan        created
//              2000-12-06  vtan        ignore create mutex failure
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::StaticInitialize (void)

{
    s_pMutex = new CMutex;
    if (s_pMutex != NULL)
    {
        (NTSTATUS)s_pMutex->Initialize(TEXT("Global\\winlogon: Logon UserProfileMapping Mutex"));
    }
    s_iReferenceCount = 0;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CImpersonation::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the mutex object.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::StaticTerminate (void)

{
    NTSTATUS    status;

    ASSERTMSG(s_iReferenceCount == 0, "Non zero reference count in CImpersonation::StaticTerminate");
    if (s_pMutex != NULL)
    {
        status = s_pMutex->Terminate();
        delete s_pMutex;
        s_pMutex = NULL;
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\impersonation.h ===
//  --------------------------------------------------------------------------
//  Module Name: Impersonation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Impersonation_
#define     _Impersonation_

#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CImpersonation
//
//  Purpose:    This class allows a thread to impersonate a user and revert to
//              self when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-10-13  vtan        added reference counting
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CImpersonation
{
    private:
                                    CImpersonation (void);
    public:
                                    CImpersonation (HANDLE hToken);
                                    ~CImpersonation (void);

                bool                IsImpersonating (void)  const;

        static  NTSTATUS            ImpersonateUser (HANDLE hThread, HANDLE hToken);

        static  NTSTATUS            StaticInitialize (void);
        static  NTSTATUS            StaticTerminate (void);
    private:
        static  CMutex*             s_pMutex;
        static  int                 s_iReferenceCount;

                NTSTATUS            _status;
                bool                _fAlreadyImpersonating;
};

#endif  /*  _Impersonation_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\dynamicobject.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicObject.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements operator new and operator delete for memory
//  usage tracking.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "DynamicObject.h"

//  --------------------------------------------------------------------------
//  CDynamicObject::operator new
//
//  Arguments:  iSize   =   Size of memory to allocate (in bytes).
//
//  Returns:    <none>
//
//  Purpose:    Allocates a block of memory for a dynamic object.
//
//  History:    1999-09-22  vtan        created
//  --------------------------------------------------------------------------

void*   CDynamicObject::operator new (size_t uiSize)

{
    return(LocalAlloc(LMEM_FIXED, uiSize));
}

//  --------------------------------------------------------------------------
//  CDynamicObject::operator delete
//
//  Arguments:  pObject     =   Address of memory block to delete.
//
//  Returns:    <none>
//
//  Purpose:    Deallocates a block of memory for a dynamic object.
//
//  History:    1999-09-22  vtan      created
//  --------------------------------------------------------------------------

void    CDynamicObject::operator delete (void *pvObject)

{
    (HLOCAL)LocalFree(pvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\dynamicobject.h ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicObject.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements operator new and operator delete for memory
//  usage tracking.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _DynamicObject_
#define     _DynamicObject_

//  --------------------------------------------------------------------------
//  CDynamicObject
//
//  Purpose:    This class is a base class that implements operator new and
//              operator delete so that memory usage can be tracked. Each time
//              an object is created the memory can be added to an array and
//              each time it is destroyed it can be removed.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicObject
{
    public:
        static  void*   operator new (size_t uiSize);
        static  void    operator delete (void *pvObject);
};

#endif  /*  _DynamicObject_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\kernelresources.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: KernelResources.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "KernelResources.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CHandle::CHandle
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CHandle object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::CHandle (HANDLE handle) :
    _handle(handle)

{
}

//  --------------------------------------------------------------------------
//  CHandle::~CHandle
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CHandle object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::~CHandle (void)

{
    ReleaseHandle(_handle);
}

//  --------------------------------------------------------------------------
//  CHandle::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CHandle to a HANDLE.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::operator HANDLE (void)                             const

{
    return(_handle);
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CEvent object. No event is created.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (void) :
    _hEvent(NULL)

{
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  copyObject  =   Object to copy on construction.
//
//  Returns:    <none>
//
//  Purpose:    Copy constructor for the CEvent object. An event is
//              duplicated.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (const CEvent& copyObject) :
    _hEvent(NULL)

{
    *this = copyObject;
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  pszName     =   Optional name of an event object to create on
//                              construction.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CEvent object. A named event is created.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (const TCHAR *pszName) :
    _hEvent(NULL)

{
    TSTATUS(Create(pszName));
}

//  --------------------------------------------------------------------------
//  CEvent::~CEvent
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CEvent object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::~CEvent (void)

{
    TSTATUS(Close());
}

//  --------------------------------------------------------------------------
//  CEvent::operator =
//
//  Arguments:  assignObject    =   Object being assigned.
//
//  Returns:    const CEvent&
//
//  Purpose:    Overloaded operator = to ensure that the event is properly
//              duplicated with another handle referencing the same object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

const CEvent&   CEvent::operator = (const CEvent& assignObject)

{
    if (this != &assignObject)
    {
        TSTATUS(Close());
        TBOOL(DuplicateHandle(GetCurrentProcess(), assignObject._hEvent, GetCurrentProcess(), &_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS));
    }
    return(*this);
}

//  --------------------------------------------------------------------------
//  CEvent::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CEvent to a HANDLE.
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

CEvent::operator HANDLE (void)                              const

{
    return(_hEvent);
}

//  --------------------------------------------------------------------------
//  CEvent::Open
//
//  Arguments:  pszName     =   Optional name of the event object to open.
//              dwAccess    =   Access level required.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the event object.
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Open (const TCHAR *pszName, DWORD dwAccess)

{
    NTSTATUS    status;

    TSTATUS(Close());
    _hEvent = OpenEvent(dwAccess, FALSE, pszName);
    if (_hEvent != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Create
//
//  Arguments:  pszName =   Optional name of the event object to create. It
//                          is possible to create un-named events.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates the event object. The event is manually reset and NOT
//              signaled initially.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Create (const TCHAR *pszName)

{
    NTSTATUS    status;

    TSTATUS(Close());
    _hEvent = CreateEvent(NULL, TRUE, FALSE, pszName);
    if (_hEvent != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Set
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the event object state to signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Set (void)                                          const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Set");
    if (SetEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Reset
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Clears the event object state to NOT signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Reset (void)                                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Reset");
    if (ResetEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Pulse
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the event object state to signaled, releases any threads
//              waiting on this event and clears the event object state to
//              NOT signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Pulse (void)                                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Pulse");
    if (PulseEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Wait
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait until the
//                                  event becomes signaled.
//              pdwWaitResult   =   Result from kernel32!WaitForSingleObject.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the event object to become signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Wait (DWORD dwMilliseconds, DWORD *pdwWaitResult)           const

{
    NTSTATUS    status;
    DWORD       dwWaitResult;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Wait");
    dwWaitResult = WaitForSingleObject(_hEvent, dwMilliseconds);
    if (pdwWaitResult != NULL)
    {
        *pdwWaitResult = dwWaitResult;
    }
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Wait
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait until the
//                                  event becomes signaled.
//              pdwWaitResult   =   Result from kernel32!WaitForSingleObject.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the event object to become signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::WaitWithMessages (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const

{
    NTSTATUS    status;
    DWORD       dwWaitResult;

    do
    {

        //  When waiting for the object check to see that it's not signaled.
        //  If signaled then abandon the wait loop. Otherwise allow user32
        //  to continue processing messages for this thread.

        dwWaitResult = WaitForSingleObject(_hEvent, 0);
        if (dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hEvent, FALSE, dwMilliseconds, QS_ALLINPUT);
            if (dwWaitResult == WAIT_OBJECT_0 + 1)
            {
                MSG     msg;

                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
                {
                    (BOOL)TranslateMessage(&msg);
                    (LRESULT)DispatchMessage(&msg);
                }
            }
         }
    } while (dwWaitResult == WAIT_OBJECT_0 + 1);
    if (pdwWaitResult != NULL)
    {
        *pdwWaitResult = dwWaitResult;
    }
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::IsSignaled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the event is signaled without waiting.
//
//  History:    2000-08-09  vtan        created
//  --------------------------------------------------------------------------

bool    CEvent::IsSignaled (void)                                   const

{
    return(WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0));
}

//  --------------------------------------------------------------------------
//  CEvent::Close
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Closes the event object HANDLE.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Close (void)

{
    ReleaseHandle(_hEvent);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CJob::CJob
//
//  Arguments:  pszName     =   Optional name of an event object to create on
//                              construction.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CJob object. A named event is created.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJob::CJob (const TCHAR *pszName) :
    _hJob(NULL)

{
    _hJob = CreateJobObject(NULL, pszName);
    ASSERTMSG(_hJob != NULL, "Job object creation failed iN CJob::CJob");
}

//  --------------------------------------------------------------------------
//  CJob::~CJob
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CJob object.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJob::~CJob (void)

{
    ReleaseHandle(_hJob);
}

//  --------------------------------------------------------------------------
//  CJob::AddProcess
//
//  Arguments:  hProcess    =   Handle to the process to add to this job.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the process to this job.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::AddProcess (HANDLE hProcess)                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::AddProcess");
    if (AssignProcessToJobObject(_hJob, hProcess) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob::SetCompletionPort
//
//  Arguments:  hCompletionPort     =   IO completion port for job completion
//                                      messages.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the IO completion port for this job. The caller should
//              watch this port for messages related to this job.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::SetCompletionPort (HANDLE hCompletionPort)          const

{
    NTSTATUS                                status;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT     associateCompletionPort;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetCompletionPort");
    associateCompletionPort.CompletionKey = NULL;
    associateCompletionPort.CompletionPort = hCompletionPort;

    //  If the job completion port cannot be set then don't use it.

    if (SetInformationJobObject(_hJob, JobObjectAssociateCompletionPortInformation, &associateCompletionPort, sizeof(associateCompletionPort)) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob:SetActiveProcessLimit
//
//  Arguments:  dwActiveProcessLimit    =   Maximum number of processes.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the limit for the number of processes related to this
//              job. Typically you can use this to restrict a process from
//              starting another process whena quota (such as 1) is reached.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::SetActiveProcessLimit (DWORD dwActiveProcessLimit)  const

{
    NTSTATUS                            status;
    DWORD                               dwReturnLength;
    JOBOBJECT_BASIC_LIMIT_INFORMATION   basicLimitInformation;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetActiveProcessLimit");
    if (QueryInformationJobObject(_hJob,
                                  JobObjectBasicLimitInformation,
                                  &basicLimitInformation,
                                  sizeof(basicLimitInformation),
                                  &dwReturnLength) != FALSE)
    {
        if (dwActiveProcessLimit == 0)
        {
            basicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
            basicLimitInformation.ActiveProcessLimit = 0;
        }
        else
        {
            basicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
            basicLimitInformation.ActiveProcessLimit = dwActiveProcessLimit;
        }
        if (SetInformationJobObject(_hJob, JobObjectBasicLimitInformation, &basicLimitInformation, sizeof(basicLimitInformation)) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

NTSTATUS    CJob::SetPriorityClass (DWORD dwPriorityClass)            const

{
    NTSTATUS                            status;
    DWORD                               dwReturnLength;
    JOBOBJECT_BASIC_LIMIT_INFORMATION   basicLimitInformation;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetPriorityClass");
    if (QueryInformationJobObject(_hJob,
                                  JobObjectBasicLimitInformation,
                                  &basicLimitInformation,
                                  sizeof(basicLimitInformation),
                                  &dwReturnLength) != FALSE)
    {
        if (dwPriorityClass == 0)
        {
            basicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            basicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;
        }
        else
        {
            basicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            basicLimitInformation.PriorityClass = dwPriorityClass;
        }
        if (SetInformationJobObject(_hJob, JobObjectBasicLimitInformation, &basicLimitInformation, sizeof(basicLimitInformation)) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob:RestrictAccessUIAll
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Restricts process in the job from accessing UI components.
//              Take care when using this feature.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::RestrictAccessUIAll (void)                          const

{
    NTSTATUS                            status;
    JOBOBJECT_BASIC_UI_RESTRICTIONS     basicUIRestrictions;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::RestrictAccessUIAll");
    basicUIRestrictions.UIRestrictionsClass = JOB_OBJECT_UILIMIT_DESKTOP |
                                              JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                                              JOB_OBJECT_UILIMIT_EXITWINDOWS |
                                              JOB_OBJECT_UILIMIT_GLOBALATOMS |
                                              JOB_OBJECT_UILIMIT_HANDLES |
                                              JOB_OBJECT_UILIMIT_READCLIPBOARD |
                                              JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |
                                              JOB_OBJECT_UILIMIT_WRITECLIPBOARD;
    if (SetInformationJobObject(_hJob, JobObjectBasicUIRestrictions, &basicUIRestrictions, sizeof(basicUIRestrictions)) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CMutex::Initialize
//
//  Arguments:  pszMutexName    =   Name of the mutex to create.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Create or open a mutex object. It always tries to create the
//              mutex so a name MUST be specified.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CMutex::Initialize (const TCHAR *pszMutexName)

{
    NTSTATUS    status;

    ASSERTMSG(pszMutexName != NULL, "Must specify a mutex name in CMutex::Initialize");
    _hMutex = CreateMutex(NULL, FALSE, pszMutexName);
    if (_hMutex != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CMutex::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the mutex object resource.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CMutex::Terminate (void)

{
    ReleaseHandle(_hMutex);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CMutex::Acquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquires the mutex object. This will block indefinitely and
//              will also block a message pump. Use this with caution!
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

void    CMutex::Acquire (void)

{
    if (_hMutex != NULL)
    {
        (DWORD)WaitForSingleObject(_hMutex, INFINITE);
    }
}

//  --------------------------------------------------------------------------
//  CMutex::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases ownership of the mutex object.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

void    CMutex::Release (void)

{
    if (_hMutex != NULL)
    {
        TBOOL(ReleaseMutex(_hMutex));
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::CCriticalSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CCriticalSection::CCriticalSection (void)

{
    _status = RtlInitializeCriticalSection(&_criticalSection);
}

//  --------------------------------------------------------------------------
//  CCriticalSection::~CCriticalSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destroys the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CCriticalSection::~CCriticalSection (void)

{
    if (NT_SUCCESS(_status))
    {
        TSTATUS(RtlDeleteCriticalSection(&_criticalSection));
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Acquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquire the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

void    CCriticalSection::Acquire (void)

{
    if (NT_SUCCESS(_status))
    {
        EnterCriticalSection(&_criticalSection);
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

void    CCriticalSection::Release (void)

{
    if (NT_SUCCESS(_status))
    {
        LeaveCriticalSection(&_criticalSection);
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Status
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns the construction status.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCriticalSection::Status (void)   const

{
    return(_status);
}

//  --------------------------------------------------------------------------
//  CCriticalSection::IsOwned
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the critical section is owned.
//
//  History:    2001-04-05  vtan        created
//  --------------------------------------------------------------------------

bool    CCriticalSection::IsOwned (void)  const

{
    return(NT_SUCCESS(_status) && (_criticalSection.OwningThread == NtCurrentTeb()->ClientId.UniqueThread));
}

//  --------------------------------------------------------------------------
//  CModule::CModule
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CModule object. Opens the given dynamic link
//              library.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CModule::CModule (const TCHAR *pszModuleName) :
    _hModule(NULL)

{
    _hModule = LoadLibrary(pszModuleName);
}

//  --------------------------------------------------------------------------
//  CModule::~CModule
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CModule object. Closes the
//              library if opened.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CModule::~CModule (void)

{
    if (_hModule != NULL)
    {
        TBOOL(FreeLibrary(_hModule));
        _hModule = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CModule::operator HMODULE
//
//  Arguments:  <none>
//
//  Returns:    HMODULE
//
//  Purpose:    Returns the HMODULE for the loaded library.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

CModule::operator HMODULE (void)                     const

{
    return(_hModule);
}

//  --------------------------------------------------------------------------
//  CModule::GetProcAddress
//
//  Arguments:  pszProcName     =   Name of function entry point to retrieve
//                                  in the given dynamic link library. This is
//                                  ANSI by definition.
//
//  Returns:    void*   =   Address of the function if it exists or NULL if
//                          failed.
//
//  Purpose:    Retrieves the function entry point in a dynamic link library.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

void*   CModule::GetProcAddress (LPCSTR pszProcName)                    const

{
    void*   pfnResult;

    pfnResult = NULL;
    if (_hModule != NULL)
    {
        pfnResult = ::GetProcAddress(_hModule, pszProcName);
    }
    return(pfnResult);
}

//  --------------------------------------------------------------------------
//  CFile::CFile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CFile object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CFile::CFile (void) :
    _hFile(NULL)

{
}

//  --------------------------------------------------------------------------
//  CFile::~CFile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CFile object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CFile::~CFile (void)

{
    ReleaseHandle(_hFile);
}

//  --------------------------------------------------------------------------
//  CFile::Open
//
//  Arguments:  See the platform SDK under kernel32!CreateFile.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!CreateFile.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::Open (const TCHAR *pszFilepath, DWORD dwDesiredAccess, DWORD dwShareMode)

{
    LONG    errorCode;

    ASSERTMSG((_hFile == NULL) || (_hFile == INVALID_HANDLE_VALUE), "Open file HANDLE exists in CFile::GetSize");
    _hFile = CreateFile(pszFilepath, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CFile::GetSize
//
//  Arguments:  See the platform SDK under kernel32!GetFileSize.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!GetFileSize.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::GetSize (DWORD& dwLowSize, DWORD *pdwHighSize)       const

{
    LONG    errorCode;

    ASSERTMSG((_hFile != NULL) && (_hFile != INVALID_HANDLE_VALUE), "No open file HANDLE in CFile::GetSize");
    dwLowSize = GetFileSize(_hFile, pdwHighSize);
    if (dwLowSize != static_cast<DWORD>(-1))
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CFile::Read
//
//  Arguments:  See the platform SDK under kernel32!ReadFile.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!ReadFile.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::Read (void *pvBuffer, DWORD dwBytesToRead, DWORD *pdwBytesRead)   const

{
    LONG    errorCode;

    ASSERTMSG((_hFile != NULL) && (_hFile != INVALID_HANDLE_VALUE), "No open file HANDLE in CFile::GetSize");
    if (ReadFile(_hFile, pvBuffer, dwBytesToRead, pdwBytesRead, NULL) != FALSE)
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CDesktop::CDesktop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDesktop. Saves the current thread's desktop.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

CDesktop::CDesktop (void) :
    _hDeskCurrent(GetThreadDesktop(GetCurrentThreadId())),
    _hDesk(NULL)

{
}

//  --------------------------------------------------------------------------
//  CDesktop::~CDesktop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDesktop. Restores the thread's desktop to
//              its previous state prior to the object's scope.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

CDesktop::~CDesktop (void)

{
    TBOOL(SetThreadDesktop(_hDeskCurrent));
    if (_hDesk != NULL)
    {
        TBOOL(CloseDesktop(_hDesk));
        _hDesk = NULL;
    }
    _hDeskCurrent = NULL;
}

//  --------------------------------------------------------------------------
//  CDesktop::Set
//
//  Arguments:  pszName     =   Name of desktop to set the thread to.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the named desktop with MAXIMUM_ALLOWED access and sets
//              the current thread's desktop to it.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::Set (const TCHAR *pszName)

{
    NTSTATUS    status;

    _hDesk = OpenDesktop(pszName, 0, FALSE, MAXIMUM_ALLOWED);
    if (_hDesk != NULL)
    {
        status = Set();
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDesktop::SetInput
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the input desktop and sets the current thread's desktop
//              to it.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::SetInput (void)

{
    NTSTATUS    status;

    _hDesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (_hDesk != NULL)
    {
        status = Set();
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDesktop::Set
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the thread's desktop to the given HDESK.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::Set (void)

{
    NTSTATUS    status;

    if (SetThreadDesktop(_hDesk) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\kernelresources.h ===
//  --------------------------------------------------------------------------
//  Module Name: KernelResources.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _KernelResources_
#define     _KernelResources_

//  --------------------------------------------------------------------------
//  CHandle
//
//  Purpose:    This class manages any generic HANDLE to an object.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CHandle
{
    private:
                                CHandle (void);
                                CHandle (const CHandle& copyObject);
        bool                    operator == (const CHandle& compareObject)  const;
        const CHandle&          operator = (const CHandle& assignObject);
    public:
                                CHandle (HANDLE handle);
                                ~CHandle (void);

                                operator HANDLE (void)                      const;
    private:
        HANDLE                  _handle;
};

//  --------------------------------------------------------------------------
//  CEvent
//
//  Purpose:    This class manages a named or un-named event object. Using
//              the default constructor will not create an event.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CEvent
{
    private:
        bool                    operator == (const CEvent& compareObject)           const;
    public:
                                CEvent (void);
                                CEvent (const CEvent& copyObject);
                                CEvent (const TCHAR *pszName);
                                ~CEvent (void);

        const CEvent&           operator = (const CEvent& assignObject);
                                operator HANDLE (void)                              const;

        NTSTATUS                Open (const TCHAR *pszName, DWORD dwAccess);
        NTSTATUS                Create (const TCHAR *pszName = NULL);
        NTSTATUS                Set (void)                                          const;
        NTSTATUS                Reset (void)                                        const;
        NTSTATUS                Pulse (void)                                        const;
        NTSTATUS                Wait (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const;
        NTSTATUS                WaitWithMessages (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const;
        bool                    IsSignaled (void)                                   const;
    private:
        NTSTATUS                Close (void);
    private:
        HANDLE                  _hEvent;
};

//  --------------------------------------------------------------------------
//  CJob
//
//  Purpose:    This class manages a named or un-named job object. It hides
//              Win32 APIs to manipulate the state of the job object.
//
//  History:    1999-10-07  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CJob
{
    private:
                                CJob (const CJob& copyObject);
        bool                    operator == (const CJob& compareObject)             const;
        const CJob&             operator = (const CJob& assignObject);
    public:
                                CJob (const TCHAR *pszName = NULL);
                                ~CJob (void);

        NTSTATUS                AddProcess (HANDLE hProcess)                        const;
        NTSTATUS                SetCompletionPort (HANDLE hCompletionPort)          const;
        NTSTATUS                SetActiveProcessLimit (DWORD dwActiveProcessLimit)  const;
        NTSTATUS                SetPriorityClass (DWORD dwPriorityClass)            const;
        NTSTATUS                RestrictAccessUIAll (void)                          const;
    private:
        HANDLE                  _hJob;
};

//  --------------------------------------------------------------------------
//  CMutex
//
//  Purpose:    This class implements a mutex object management. It's not a
//              static class but each class that uses this class should
//              declare the member variable as static as only one mutex is
//              required to protect a shared resource.
//
//  History:    1999-10-13  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CMutex
{
    public:
        NTSTATUS                Initialize (const TCHAR *pszMutexName);
        NTSTATUS                Terminate (void);

        void                    Acquire (void);
        void                    Release (void);
    private:
        HANDLE                  _hMutex;
};

//  --------------------------------------------------------------------------
//  CCriticalSection
//
//  Purpose:    This class implements a critical section object management.
//
//  History:    1999-11-06  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CCriticalSection
{
    public:
                                CCriticalSection (void);
                                ~CCriticalSection (void);

        void                    Acquire (void);
        void                    Release (void);
        NTSTATUS                Status (void)   const;
        bool                    IsOwned (void)  const;
    private:
        NTSTATUS                _status;
        CRITICAL_SECTION        _criticalSection;
};

//  --------------------------------------------------------------------------
//  CModule
//
//  Purpose:    This class manages a loading an unloading of a dynamic link
//              library. The scope of the object determines how long the
//              library remains loaded.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CModule
{
    private:
                                CModule (void);
                                CModule (const CModule& copyObject);
        bool                    operator == (const CModule& compareObject)  const;
        const CModule&          operator = (const CModule& assignObject);
    public:
                                CModule (const TCHAR *pszModuleName);
                                ~CModule (void);

                                operator HMODULE (void)                     const;

        void*                   GetProcAddress (LPCSTR pszProcName)         const;
    private:
        HMODULE                 _hModule;
};

//  --------------------------------------------------------------------------
//  CFile
//
//  Purpose:    This class manages a HANDLE to a file object. It is specific
//              for files and should not be abused.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CFile
{
    private:
                                CFile (const CFile& copyObject);
        bool                    operator == (const CFile& compareObject)                                    const;
        const CFile&            operator = (const CFile& assignObject);
    public:
                                CFile (void);
                                ~CFile (void);

        LONG                    Open (const TCHAR *pszFilepath, DWORD dwDesiredAccess, DWORD dwShareMode);
        LONG                    GetSize (DWORD& dwLowSize, DWORD *pdwHighSize)                              const;
        LONG                    Read (void *pvBuffer, DWORD dwBytesToRead, DWORD *pdwBytesRead)             const;
    private:
        HANDLE                  _hFile;
};

//  --------------------------------------------------------------------------
//  CDesktop
//
//  Purpose:    This class manages an HDESK object.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

class   CDesktop
{
    public:
                                CDesktop (void);
                                ~CDesktop (void);

        NTSTATUS                Set (const TCHAR *pszName);
        NTSTATUS                SetInput (void);
    private:
        NTSTATUS                Set (void);
    private:
        HDESK                   _hDeskCurrent;
        HDESK                   _hDesk;
};

#endif  /*  _KernelResources_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\singlethreadedexecution.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SingleThreadedExecution.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "SingleThreadedExecution.h"

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution::CSingleThreadedExecution
//
//  Arguments:  criticalSection   =   CCriticalSection object containing the
//                                    critical section controlling the block
//                                    of single threaded execution.
//
//  Returns:    <none>
//
//  Purpose:    Acquires the given CriticalSection.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedExecution::CSingleThreadedExecution (CCriticalSection& criticalSection) :
    _criticalSection(criticalSection)

{
    criticalSection.Acquire();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution::~CSingleThreadedExecution
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the single threaded execution critical section.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedExecution::~CSingleThreadedExecution (void)

{
    _criticalSection.Release();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution::CSingleThreadedMutexExecution
//
//  Arguments:  mutex   =   CMutex object containing the mutex controlling
//                          the block of single threaded execution.
//
//  Returns:    <none>
//
//  Purpose:    Acquires the given mutex.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedMutexExecution::CSingleThreadedMutexExecution (CMutex& mutex) :
    _hMutex(mutex)

{
    mutex.Acquire();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution::~CSingleThreadedMutexExecution
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the single threaded execution mutex.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedMutexExecution::~CSingleThreadedMutexExecution (void)

{
    _hMutex.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\standarddebug.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StandardDebug.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard debug helper functions for winlogon/GINA
//  projects for neptune.
//
//  History:    1999-09-10  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include <stdio.h>

#ifdef      DBG

//  --------------------------------------------------------------------------
//  gLastResult
//
//  Purpose:    Temporary global that stores the last result.
//  --------------------------------------------------------------------------

LONG    gLastResult     =   ERROR_SUCCESS;

//  --------------------------------------------------------------------------
//  CDebug::sHasUserModeDebugger
//  CDebug::sHasKernelModeDebugger
//
//  Purpose:    Booleans that indicate debugger status on this machine for
//              Winlogon. ntdll!DebugBreak should only be invoked if either
//              debugger is present (ntsd piped to kd).
//  --------------------------------------------------------------------------

bool    CDebug::s_fHasUserModeDebugger      =   false;
bool    CDebug::s_fHasKernelModeDebugger    =   false;

//  --------------------------------------------------------------------------
//  CDebug::AttachUserModeDebugger
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Attaches a user mode debugger to the current process. Useful
//              if you can't start the process under a debugger but still
//              want to be able to debug the process.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::AttachUserModeDebugger (void)

{
    HANDLE                  hEvent;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szCommandLine[MAX_PATH];

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    hEvent = CreateEvent(&sa, TRUE, FALSE, NULL);
    wsprintf(szCommandLine, TEXT("ntsd -dgGx -p %ld -e %ld"), GetCurrentProcessId(), hEvent);
    if (CreateProcess(NULL,
                      szCommandLine,
                      NULL,
                      NULL,
                      TRUE,
                      0,
                      NULL,
                      NULL,
                      &startupInfo,
                      &processInformation) != FALSE)
    {
        TBOOL(CloseHandle(processInformation.hThread));
        TBOOL(CloseHandle(processInformation.hProcess));
        (DWORD)WaitForSingleObject(hEvent, 10 * 1000);
    }
    TBOOL(CloseHandle(hEvent));
}

//  --------------------------------------------------------------------------
//  CDebug::Break
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Breaks into the debugger if the hosting process has been
//              started with a debugger and kernel debugger is present.
//
//  History:    2000-09-11  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::Break (void)

{
    if (s_fHasUserModeDebugger || s_fHasKernelModeDebugger)
    {
        DebugBreak();
    }
}

//  --------------------------------------------------------------------------
//  CDebug::BreakIfRequested
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If breakins are requested then breaks into the debugger if
//              present.
//
//              This function explicitly uses Win32 Registry APIs to avoid
//              link dependencies on debug code with library code.
//
//  History:    1999-09-13  vtan        created
//              1999-11-16  vtan        removed library code dependency
//              2001-02-21  vtan        breaks have teeth
//  --------------------------------------------------------------------------

void    CDebug::BreakIfRequested (void)

{
#if     0
    Break();
#else
    HKEY    hKeySettings;

    //  Keep retrieving this value form the registry so that it
    //  can be altered without restarting the machine.

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                      0,
                                      KEY_READ,
                                      &hKeySettings))
    {
        DWORD   dwBreakFlags, dwBreakFlagsSize;

        dwBreakFlagsSize = sizeof(dwBreakFlags);
        if ((ERROR_SUCCESS == RegQueryValueEx(hKeySettings,
                                             TEXT("BreakFlags"),
                                             NULL,
                                             NULL,
                                             reinterpret_cast<LPBYTE>(&dwBreakFlags),
                                             &dwBreakFlagsSize)) &&
            ((dwBreakFlags & FLAG_BREAK_ON_ERROR) != 0))
        {
            Break();
        }
        TW32(RegCloseKey(hKeySettings));
    }
#endif
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayStandardPrefix
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Displays the standard prefix before any debug spew to help
//              identify the source.
//
//  History:    1999-10-14  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayStandardPrefix (void)

{
    TCHAR   szModuleName[MAX_PATH];

    if (GetModuleFileName(NULL, szModuleName, ARRAYSIZE(szModuleName)) != 0)
    {
        TCHAR   *pTC;

        pTC = szModuleName + lstrlen(szModuleName) - 1;
        while ((pTC >= szModuleName) && (*pTC != TEXT('\\')))
        {
            --pTC;
        }
        if (*pTC == TEXT('\\'))
        {
            ++pTC;
        }
        OutputDebugString(pTC);
    }
    else
    {
        OutputDebugString(TEXT("UNKNOWN IMAGE"));
    }
    OutputDebugStringA(": ");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayError
//
//  Arguments:  eType           =   Type of error that occurred. This
//                                  determines what string is used.
//              code            =   Error code that occurred or zero if N/A.
//              pszFunction     =   Function that was invoked.
//              pszSource       =   Source file error occurred in.
//              iLine           =   Line number within the source file.
//
//  Returns:    <none>
//
//  Purpose:    Displays an error message specific the type of error that
//              occurred.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayError (TRACE_ERROR_TYPE eType, LONG code, const char *pszFunction, const char *pszSource, int iLine)

{
    LONG    lastError;
    char    szOutput[1024];

    switch (eType)
    {
        case TRACE_ERROR_TYPE_WIN32:
        {
            lastError = code;
            sprintf(szOutput, "Unexpected Win32 (%d) for %s in %s at line %d\r\n", lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_BOOL:
        {
            lastError = GetLastError();
            sprintf(szOutput, "Unexpected BOOL (GLE=%d) for %s in %s at line %d\r\n", lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_HRESULT:
        {
            lastError = GetLastError();
            sprintf(szOutput, "Unexpected HRESULT (%08x:GLE=%d) for %s in %s at line %d\r\n", code, lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_NTSTATUS:
        {
            const char  *pszType;

            if (NT_ERROR(code))
            {
                pszType = "NT_ERROR";
            }
            else if (NT_WARNING(code))
            {
                pszType = "NT_WARNING";
            }
            else if (NT_INFORMATION(code))
            {
                pszType = "NT_INFORMATION";
            }
            else
            {
                pszType = "UNKNOWN";
            }
            sprintf(szOutput, "%s (%08x) for %s in %s at line %d\r\n", pszType, code, pszFunction, pszSource, iLine);
            break;
        }
        default:
        {
            lstrcpyA(szOutput, "\r\n");
        }
    }
    DisplayStandardPrefix();
    OutputDebugStringA(szOutput);
    BreakIfRequested();
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayMessage
//
//  Arguments:  pszMessage  =   Message to display.
//
//  Returns:    <none>
//
//  Purpose:    Displays the message - no break.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayMessage (const char *pszMessage)

{
    DisplayStandardPrefix();
    OutputDebugStringA(pszMessage);
    OutputDebugStringA("\r\n");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayAssert
//
//  Arguments:  pszMessage      =   Message to display in assertion failure.
//              fForceBreak     =   Forces break into debugger if present.
//
//  Returns:    <none>
//
//  Purpose:    Displays the assertion failure message and breaks into the
//              debugger if requested.
//
//  History:    1999-09-13  vtan        created
//              2000-09-11  vtan        add force break
//  --------------------------------------------------------------------------

void    CDebug::DisplayAssert (const char *pszMessage, bool fForceBreak)

{
    DisplayMessage(pszMessage);
    if (fForceBreak)
    {
        Break();
    }
    else
    {
        BreakIfRequested();
    }
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayWarning
//
//  Arguments:  pszMessage  =   Message to display as a warning.
//
//  Returns:    <none>
//
//  Purpose:    Displays the warning message.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayWarning (const char *pszMessage)

{
    DisplayStandardPrefix();
    OutputDebugStringA("WARNING: ");
    OutputDebugStringA(pszMessage);
    OutputDebugStringA("\r\n");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayDACL
//
//  Arguments:  hObject         =   HANDLE to object to display DACL of.
//              seObjectType    =   Object type.
//
//  Returns:    <none>
//
//  Purpose:    Displays the discretionary access control list of the object
//              using the kernel debugger.
//
//  History:    1999-10-15  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayDACL (HANDLE hObject, SE_OBJECT_TYPE seObjectType)

{
    PACL                    pDACL;
    PSECURITY_DESCRIPTOR    pSD;

    DisplayStandardPrefix();
    OutputDebugStringA("Display DACL\r\n");
    pSD = NULL;
    pDACL = NULL;
    if (ERROR_SUCCESS == GetSecurityInfo(hObject,
                                         seObjectType,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         &pDACL,
                                         NULL,
                                         &pSD))
    {
        int             i, iLimit;
        unsigned char   *pUC;

        pUC = reinterpret_cast<unsigned char*>(pDACL + 1);
        iLimit = pDACL->AceCount;
        for (i = 0; i < iLimit; ++i)
        {
            ACE_HEADER      *pAceHeader;
            char            aszString[256];

            wsprintfA(aszString, "ACE #%d/%d:\r\n", i + 1, iLimit);
            OutputDebugStringA(aszString);
            pAceHeader = reinterpret_cast<ACE_HEADER*>(pUC);
            switch (pAceHeader->AceType)
            {
                case ACCESS_ALLOWED_ACE_TYPE:
                {
                    ACCESS_ALLOWED_ACE  *pAce;

                    OutputDebugStringA("\tAccess ALLOWED ACE");
                    pAce = reinterpret_cast<ACCESS_ALLOWED_ACE*>(pAceHeader);
                    OutputDebugStringA("\t\tSID = ");
                    DisplaySID(reinterpret_cast<PSID>(&pAce->SidStart));
                    wsprintfA(aszString, "\t\tMask = %08x\r\n", pAce->Mask);
                    OutputDebugStringA(aszString);
                    wsprintfA(aszString, "\t\tFlags = %08x\r\n", pAce->Header.AceFlags);
                    OutputDebugStringA(aszString);
                    break;
                }
                case ACCESS_DENIED_ACE_TYPE:
                {
                    ACCESS_DENIED_ACE   *pAce;

                    OutputDebugStringA("\tAccess DENIED ACE");
                    pAce = reinterpret_cast<ACCESS_DENIED_ACE*>(pAceHeader);
                    OutputDebugStringA("\t\tSID = ");
                    DisplaySID(reinterpret_cast<PSID>(&pAce->SidStart));
                    wsprintfA(aszString, "\t\tMask = %08x\r\n", pAce->Mask);
                    OutputDebugStringA(aszString);
                    wsprintfA(aszString, "\t\tFlags = %08x\r\n", pAce->Header.AceFlags);
                    OutputDebugStringA(aszString);
                    break;
                }
                default:
                    OutputDebugStringA("\tOther ACE type\r\n");
                    break;
            }
            pUC += pAceHeader->AceSize;
        }
        ReleaseMemory(pSD);
    }
}

//  --------------------------------------------------------------------------
//  CDebug::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Establishes the presence of the kernel debugger or if the
//              current process is being debugged.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDebug::StaticInitialize (void)

{
    NTSTATUS                            status;
    HANDLE                              hDebugPort;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION  kdInfo;

    status = NtQuerySystemInformation(SystemKernelDebuggerInformation, &kdInfo, sizeof(kdInfo), NULL);
    if (NT_SUCCESS(status))
    {
        s_fHasKernelModeDebugger = (kdInfo.KernelDebuggerEnabled != FALSE);
        status = NtQueryInformationProcess(NtCurrentProcess(), ProcessDebugPort, reinterpret_cast<PVOID>(&hDebugPort), sizeof(hDebugPort), NULL);
        if (NT_SUCCESS(status))
        {
            s_fHasUserModeDebugger = (hDebugPort != NULL);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDebug::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Does nothing but should clean up allocated resources.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDebug::StaticTerminate (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CDebug::DisplaySID
//
//  Arguments:  pSID    =   SID to display as a string.
//
//  Returns:    <none>
//
//  Purpose:    Converts the given SID to a string and displays it.
//
//  History:    1999-10-15  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplaySID (PSID pSID)

{
    UNICODE_STRING  sidString;

    RtlInitUnicodeString(&sidString, NULL);
    TSTATUS(RtlConvertSidToUnicodeString(&sidString, pSID, TRUE));
    sidString.Buffer[sidString.Length / sizeof(WCHAR)] = L'\0';
    OutputDebugStringW(sidString.Buffer);
    OutputDebugStringA("\r\n");
    RtlFreeUnicodeString(&sidString);
}

#endif  /*  DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\singlethreadedexecution.h ===
//  --------------------------------------------------------------------------
//  Module Name: SingleThreadedExecution.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _SingleThreadedExecution_
#define     _SingleThreadedExecution_

#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution
//
//  Purpose:    This class acquires the given critical section object in its
//              constructor and releases it in its destructor. Keep code
//              executed with the scope of this object to a minimum to avoid
//              impacting performance.
//
//  History:    1999-11-06  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSingleThreadedExecution
{
    private:
                                            CSingleThreadedExecution (void);
        const CSingleThreadedExecution&     operator = (const CSingleThreadedExecution& assignObject);
    public:
                                            CSingleThreadedExecution (CCriticalSection& criticalSection);
                                            ~CSingleThreadedExecution (void);
    private:
        CCriticalSection&                   _criticalSection;
};

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution
//
//  Purpose:    This class acquires the given CMutex object in its constructor
//              and releases it in its destructor. Keep code executed with
//              the scope of this object to a minimum to avoid impacting
//              performance.
//
//  History:    1999-10-13  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSingleThreadedMutexExecution
{
    private:
                                                CSingleThreadedMutexExecution (void);
        const CSingleThreadedMutexExecution&    operator = (const CSingleThreadedMutexExecution& assignObject);
    public:
                                                CSingleThreadedMutexExecution (CMutex& mutex);
                                                ~CSingleThreadedMutexExecution (void);
    private:
        CMutex&                                 _hMutex;
};

#endif  /*  _SingleThreadedExecution_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\standarddebug.h ===
//  --------------------------------------------------------------------------
//  Module Name: StandardDebug.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard debug macros for the consumer Windows additions
//  to Windows 2000 msgina.
//
//  History:    1999-08-18  vtan        created
//              1999-09-10  vtan        reworked macros
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StandardDebug_
#define     _StandardDebug_

#ifdef      DBG

    typedef enum
    {
        TRACE_ERROR_TYPE_WIN32      =   1,
        TRACE_ERROR_TYPE_BOOL,
        TRACE_ERROR_TYPE_HRESULT,
        TRACE_ERROR_TYPE_NTSTATUS
    } TRACE_ERROR_TYPE;

    static  const int   FLAG_BREAK_ON_ERROR         =   0x00000001;

    extern  LONG    gLastResult;

    class   CDebug
    {
        public:
            static  void        AttachUserModeDebugger (void);
            static  void        Break (void);
            static  void        BreakIfRequested (void);
            static  void        DisplayStandardPrefix (void);
            static  void        DisplayError (TRACE_ERROR_TYPE eType, LONG code, const char *pszFunction, const char *pszSource, int iLine);
            static  void        DisplayMessage (const char *pszMessage);
            static  void        DisplayAssert (const char *pszMessage, bool fForceBreak = false);
            static  void        DisplayWarning (const char *pszMessage);
            static  void        DisplayDACL (HANDLE hObject, SE_OBJECT_TYPE seObjectType);

            static  NTSTATUS    StaticInitialize (void);
            static  NTSTATUS    StaticTerminate (void);
        private:
            static  void        DisplaySID (PSID pSID);
        private:
            static  bool        s_fHasUserModeDebugger,
                                s_fHasKernelModeDebugger;
    };

    #undef  ASSERTMSG
    #define ASSERTMSG(condition, message)               \
            if (!(condition))                           \
            {                                           \
                CDebug::DisplayAssert(message);         \
            }

    #define ASSERTBREAKMSG(condition, message)          \
            if (!(condition))                           \
            {                                           \
                CDebug::DisplayAssert(message, true);   \
            }

    #define DISPLAYMSG(message)                         \
            {                                           \
                CDebug::DisplayAssert(message);         \
            }

    #define WARNINGMSG(message)                         \
            {                                           \
                CDebug::DisplayWarning(message);        \
            }
    #define INFORMATIONMSG(message)                     \
            {                                           \
                CDebug::DisplayMessage(message);        \
            }

    #define TW32(result)                                                                                    \
            if (ERROR_SUCCESS != (gLastResult = result))                                                    \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_WIN32, gLastResult, #result, __FILE__, __LINE__);     \
            }

    #define TBOOL(result)                                                                       \
            if (result == FALSE)                                                                \
            {                                                                                   \
                CDebug::DisplayError(TRACE_ERROR_TYPE_BOOL, 0, #result, __FILE__, __LINE__);    \
            }

    #define THR(result)                                                                                     \
            if (FAILED(gLastResult = result))                                                               \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_HRESULT, gLastResult, #result, __FILE__, __LINE__);   \
            }

    #define TSTATUS(result)                                                                                 \
            if (!NT_SUCCESS(gLastResult = result))                                                          \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_NTSTATUS, gLastResult, #result, __FILE__, __LINE__);  \
            }

    #define COMPILETIME_ASSERT(condition)   \
            switch (0) case 0: case condition:

    #define DEBUGFILLMEMORY(address,size)   \
            FillMemory(address, size, 0xA7)

#else   /*  DBG */

    #undef  ASSERTMSG
    #define ASSERTMSG(condition, message)
    #define DISPLAYMSG(message)
    #define WARNINGMSG(message)
    #define TW32(result)                    (LONG)result
    #define TBOOL(result)                   (BOOL)result
    #define THR(result)                     (HRESULT)result
    #define TSTATUS(result)                 (NTSTATUS)result
    #define DEBUGFILLMEMORY(address,size)

#endif  /*  DBG */

#endif  /*  _StandardDebug_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\registryresources.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: RegistryResources.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "RegistryResources.h"

#include <stdlib.h>

#include "StringConvert.h"

//  --------------------------------------------------------------------------
//  CRegKey::CRegKey
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CRegKey object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CRegKey::CRegKey (void) :
    _hKey(NULL),
    _dwIndex(0)

{
}

//  --------------------------------------------------------------------------
//  CRegKey::~CRegKey
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CRegKey object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CRegKey::~CRegKey (void)

{
    TW32(Close());
}

//  --------------------------------------------------------------------------
//  CRegKey::Create
//
//  Arguments:  See the platform SDK under advapi32!RegCreateKeyEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegCreateKeyEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Create (HKEY hKey, LPCTSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, LPDWORD lpdwDisposition)

{
    TW32(Close());
    return(RegCreateKeyEx(hKey, lpSubKey, 0, NULL, dwOptions, samDesired, NULL, &_hKey, lpdwDisposition));
}

//  --------------------------------------------------------------------------
//  CRegKey::Open
//
//  Arguments:  See the platform SDK under advapi32!RegOpenKeyEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegOpenKeyEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Open (HKEY hKey, LPCTSTR lpSubKey, REGSAM samDesired)

{
    TW32(Close());
    return(RegOpenKeyEx(hKey, lpSubKey, 0, samDesired, &_hKey));
}

//  --------------------------------------------------------------------------
//  CRegKey::OpenCurrentUser
//
//  Arguments:  lpSubKey    =   Subkey to open under the current user.
//              samDesired  =   Desired access.
//
//  Returns:    LONG
//
//  Purpose:    Opens HKEY_CURRENT_USER\<lpSubKey> for the impersonated user.
//              If the thread isn't impersonating it opens the .default user.
//
//  History:    2000-05-23  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::OpenCurrentUser (LPCTSTR lpSubKey, REGSAM samDesired)

{
    LONG        lErrorCode;
    NTSTATUS    status;
    HKEY        hKeyCurrentUser;

    status = RtlOpenCurrentUser(samDesired, reinterpret_cast<void**>(&hKeyCurrentUser));
    if (NT_SUCCESS(status))
    {
        lErrorCode = Open(hKeyCurrentUser, lpSubKey, samDesired);
        TW32(RegCloseKey(hKeyCurrentUser));
    }
    else
    {
        lErrorCode = RtlNtStatusToDosError(status);
    }
    return(lErrorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::QueryValue
//
//  Arguments:  See the platform SDK under advapi32!RegQueryValueEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegQueryValueEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::QueryValue (LPCTSTR lpValueName, LPDWORD lpType, LPVOID lpData, LPDWORD lpcbData)      const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::QueryValue");
    return(RegQueryValueEx(_hKey, lpValueName, NULL, lpType, reinterpret_cast<LPBYTE>(lpData), lpcbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetValue
//
//  Arguments:  See the platform SDK under advapi32!RegSetValueEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegSetValueEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetValue (LPCTSTR lpValueName, DWORD dwType, CONST VOID *lpData, DWORD cbData)         const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::SetValue");
    return(RegSetValueEx(_hKey, lpValueName, 0, dwType, reinterpret_cast<const unsigned char*>(lpData), cbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::DeleteValue
//
//  Arguments:  See the platform SDK under advapi32!RegDeleteValue.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegDeleteValue.
//
//  History:    1999-10-31  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::DeleteValue (LPCTSTR lpValueName)               const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::DeleteValue");
    return(RegDeleteValue(_hKey, lpValueName));
}

//  --------------------------------------------------------------------------
//  CRegKey::QueryInfoKey
//
//  Arguments:  See the platform SDK under advapi32!RegQueryInfoKey.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegQueryInfoKey.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::QueryInfoKey (LPTSTR lpClass, LPDWORD lpcbClass, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)      const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::QueryInfoKey");
    return(RegQueryInfoKey(_hKey, lpClass, lpcbClass, NULL, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime));
}

//  --------------------------------------------------------------------------
//  CRegKey::Reset
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Reset the enumeration index member variable used in
//              advapi32!RegEnumValue.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

void    CRegKey::Reset (void)

{
    _dwIndex = 0;
}

//  --------------------------------------------------------------------------
//  CRegKey::Next
//
//  Arguments:  See the platform SDK under advapi32!RegEnumValue.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegEnumValue.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Next (LPTSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpType, LPVOID lpData, LPDWORD lpcbData)

{
    return(RegEnumValue(_hKey, _dwIndex++, lpValueName, lpcbValueName, NULL, lpType, reinterpret_cast<LPBYTE>(lpData), lpcbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::GetString
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pszValueData        =   String buffer to be filled with data.
//              pdwValueDataSize    =   Size (in characters) of buffer.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_SZ.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetString (const TCHAR *pszValueName, TCHAR *pszValueData, int iStringCount)                    const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSizeInBytes;

    dwValueDataSizeInBytes = iStringCount * sizeof(TCHAR);
    errorCode = QueryValue(pszValueName, &dwType, pszValueData, &dwValueDataSizeInBytes);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType != REG_SZ)
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_SZ");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetPath
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pszValueData        =   String buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_SZ or REG_EXPAND_SZ.
//              Also expands the path stored as well as assumes that MAX_PATH
//              is the buffer size.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetPath (const TCHAR *pszValueName, TCHAR *pszValueData)                   const

{
    LONG    errorCode;
    DWORD   dwType, dwRawPathSize;
    TCHAR   szRawPath[MAX_PATH];

    dwRawPathSize = sizeof(szRawPath);
    errorCode = QueryValue(pszValueName, &dwType, szRawPath, &dwRawPathSize);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType == REG_SZ)
        {
            lstrcpyn(pszValueData, szRawPath, MAX_PATH);
        }
        else if (dwType == REG_EXPAND_SZ)
        {
            if (ExpandEnvironmentStrings(szRawPath, pszValueData, MAX_PATH) == 0)
            {
                lstrcpyn(pszValueData, szRawPath, MAX_PATH);
            }
        }
        else
        {
            DISPLAYMSG("CRegKey::GetPath retrieved data that is not REG_SZ or REG_EXPAND_SZ");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetDWORD
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pdwValueData        =   DWORD buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_DWORD.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetDWORD (const TCHAR *pszValueName, DWORD& dwValueData)                   const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSize;

    dwValueDataSize = sizeof(DWORD);
    errorCode = QueryValue(pszValueName, &dwType, &dwValueData, &dwValueDataSize);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType != REG_DWORD)
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_DWORD");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetInteger
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              piValueData         =   Integer buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. If the data is REG_DWORD this is
//              casted. If the data is REG_SZ this is converted. Everything
//              is illegal (including REG_EXPAND_SZ).
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetInteger (const TCHAR *pszValueName, int& iValueData)                    const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSize;

    errorCode = QueryValue(pszValueName, &dwType, NULL, NULL);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType == REG_DWORD)
        {
            dwValueDataSize = sizeof(int);
            errorCode = QueryValue(pszValueName, NULL, &iValueData, &dwValueDataSize);
        }
        else if (dwType == REG_SZ)
        {
            TCHAR   szTemp[32];

            dwValueDataSize = ARRAYSIZE(szTemp);
            errorCode = QueryValue(pszValueName, NULL, szTemp, &dwValueDataSize);
            if (ERROR_SUCCESS == errorCode)
            {
                char    aszTemp[32];

                CStringConvert::TCharToAnsi(szTemp, aszTemp, ARRAYSIZE(aszTemp));
                iValueData = atoi(aszTemp);
            }
        }
        else
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_DWORD");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::SetString
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetString (const TCHAR *pszValueName, const TCHAR *pszValueData)           const

{
    return(SetValue(pszValueName, REG_SZ, pszValueData, (lstrlen(pszValueData) + sizeof('\0')) * sizeof(TCHAR)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetPath
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetPath (const TCHAR *pszValueName, const TCHAR *pszValueData)             const

{
    return(SetValue(pszValueName, REG_EXPAND_SZ, pszValueData, (lstrlen(pszValueData) + sizeof('\0')) * sizeof(TCHAR)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetDWORD
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetDWORD (const TCHAR *pszValueName, DWORD dwValueData)                    const

{
    return(SetValue(pszValueName, REG_DWORD, &dwValueData, sizeof(dwValueData)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetInteger
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetInteger (const TCHAR *pszValueName, int iValueData)                     const

{
    TCHAR   szString[kMaximumValueDataLength];

    wsprintf(szString, TEXT("%d"), iValueData);
    return(SetString(pszValueName, szString));
}

//  --------------------------------------------------------------------------
//  CRegKey::Close
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Closes HKEY resource (if open).
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Close (void)

{
    LONG    errorCode;

    if (_hKey != NULL)
    {
        errorCode = RegCloseKey(_hKey);
        _hKey = NULL;
    }
    else
    {
        errorCode = ERROR_SUCCESS;
    }
    return(errorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\registryresources.h ===
//  --------------------------------------------------------------------------
//  Module Name: RegistryResources.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _RegistryResources_
#define     _RegistryResources_

//  --------------------------------------------------------------------------
//  CRegKey
//
//  Purpose:    This class operates on the registry and manages the HKEY
//              resource.
//
//  History:    1999-08-18  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CRegKey
{
    private:
                                CRegKey (const CRegKey& copyObject);
        bool                    operator == (const CRegKey& compareObject)      const;
        const CRegKey&          operator = (const CRegKey& assignObject);
    public:
                                CRegKey (void);
                                ~CRegKey (void);

        LONG                    Create (HKEY hKey,
                                        LPCTSTR lpSubKey,
                                        DWORD dwOptions,
                                        REGSAM samDesired,
                                        LPDWORD lpdwDisposition);
        LONG                    Open (HKEY hKey,
                                      LPCTSTR lpSubKey,
                                      REGSAM samDesired);
        LONG                    OpenCurrentUser (LPCTSTR lpSubKey,
                                                 REGSAM samDesired);
        LONG                    QueryValue (LPCTSTR lpValueName,
                                            LPDWORD lpType,
                                            LPVOID lpData,
                                            LPDWORD lpcbData)                   const;
        LONG                    SetValue (LPCTSTR lpValueName,
                                          DWORD dwType,
                                          CONST VOID *lpData,
                                          DWORD cbData)                         const;
        LONG                    DeleteValue (LPCTSTR lpValueName)               const;
        LONG                    QueryInfoKey (LPTSTR lpClass,
                                              LPDWORD lpcClass,
                                              LPDWORD lpcSubKeys,
                                              LPDWORD lpcMaxSubKeyLen,
                                              LPDWORD lpcMaxClassLen,
                                              LPDWORD lpcValues,
                                              LPDWORD lpcMaxValueNameLen,
                                              LPDWORD lpcMaxValueLen,
                                              LPDWORD lpcbSecurityDescriptor,
                                              PFILETIME lpftLastWriteTime)      const;
        void                    Reset (void);
        LONG                    Next (LPTSTR lpValueName,
                                      LPDWORD lpcValueName,
                                      LPDWORD lpType,
                                      LPVOID lpData,
                                      LPDWORD lpcbData);

        LONG                    GetString (const TCHAR *pszValueName,
                                           TCHAR *pszValueData,
                                           int iStringCount)                    const;
        LONG                    GetPath (const TCHAR *pszValueName,
                                         TCHAR *pszValueData)                   const;
        LONG                    GetDWORD (const TCHAR *pszValueName,
                                          DWORD& dwValueData)                   const;
        LONG                    GetInteger (const TCHAR *pszValueName,
                                            int& iValueData)                    const;

        LONG                    SetString (const TCHAR *pszValueName,
                                           const TCHAR *pszValueData)           const;
        LONG                    SetPath (const TCHAR *pszValueName,
                                         const TCHAR *pszValueData)             const;
        LONG                    SetDWORD (const TCHAR *pszValueName,
                                          DWORD dwValueData)                    const;
        LONG                    SetInteger (const TCHAR *pszValueName,
                                            int iValueData)                     const;
    private:
        LONG                    Close (void);

    private:
        HKEY                    _hKey;
        DWORD                   _dwIndex;
};

#endif  /*  _RegistryResources_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\standardheader.h ===
//  --------------------------------------------------------------------------
//  Module Name: StandardHeader.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard includes for the consumer Windows additions
//  to Windows 2000 msgina.
//
//  History:    1999-08-18  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StandardHeader_
#define     _StandardHeader_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>

#include <windows.h>
#include <winbasep.h>
#include <winuserp.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <aclapi.h>

#include <limits.h>

#include "StandardDebug.h"

static  const   int     kMaximumValueDataLength     =       1024;

#ifndef ARRAYSIZE
    #define ARRAYSIZE(x)                    (sizeof(x) / sizeof(x[0]))
#endif

#define goto                            !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

#define ReleaseMemory(x)                ReleaseMemoryWorker(reinterpret_cast<void**>(&x))
#define ReleasePassword(x)              ReleasePasswordWorker(reinterpret_cast<void**>(&x))
#define ReleaseGDIObject(x)             ReleaseGDIObjectWorker(reinterpret_cast<void**>(&x))

static  inline  void    ReleaseMemoryWorker (HLOCAL *memory)

{
    if (*memory != NULL)
    {
        (HLOCAL)LocalFree(*memory);
        *memory = NULL;
    }
}

static  inline  void    ReleasePasswordWorker (HLOCAL *memory)

{
    if (*memory != NULL)
    {
        ZeroMemory(*memory, lstrlenW(reinterpret_cast<WCHAR*>(*memory)) + sizeof(L'\0'));
        (HLOCAL)LocalFree(*memory);
        *memory = NULL;
    }
}

static  inline  void    ReleaseGDIObjectWorker (HGDIOBJ *hGDIObject)

{
    if (*hGDIObject != NULL)
    {
        TBOOL(DeleteObject(*hGDIObject));
        *hGDIObject = NULL;
    }
}

static  inline  void    ReleaseHandle (HANDLE& handle)

{
    if (handle != NULL)
    {
        TBOOL(CloseHandle(handle));
        handle = NULL;
    }
}

static  inline  void    ReleaseHWND (HWND& hwnd)

{
    if (hwnd != NULL)
    {
        TBOOL(DestroyWindow(hwnd));
        hwnd = NULL;
    }
}

#endif  /*  _StandardHeader_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\statuscode.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StatusCode.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements translation of Win32 error code to NTSTATUS and
//  the reverse.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CStatusCode::ErrorCodeOfStatusCode
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts NTSTATUS status code to Win32 error code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CStatusCode::ErrorCodeOfStatusCode (NTSTATUS statusCode)

{
    return(RtlNtStatusToDosError(statusCode));
}

//  --------------------------------------------------------------------------
//  CStatusCode::StatusCodeOfErrorCode
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts Win32 error code to NTSTATUS status code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CStatusCode::StatusCodeOfErrorCode (LONG errorCode)

{
    NTSTATUS    status;

    if (errorCode != ERROR_SUCCESS)
    {
        status = MAKE_SCODE(STATUS_SEVERITY_ERROR, FACILITY_WIN32, errorCode);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CStatusCode::StatusCodeOfLastError
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts last Win32 error code to NTSTATUS status code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CStatusCode::StatusCodeOfLastError (void)

{
    return(StatusCodeOfErrorCode(GetLastError()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\statuscode.h ===
//  --------------------------------------------------------------------------
//  Module Name: StatusCode.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements translation of Win32 error code to NTSTATUS and
//  the reverse.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StatusCode_
#define     _StatusCode_

//  --------------------------------------------------------------------------
//  CStatusCode
//
//  Purpose:    This class manages a conversion from standard Win32 error
//              codes to NTSTATUS codes. NTSTATUS codes are widely used by
//              Windows NT in the core NT functions.
//
//  History:    1999-08-18  vtan        created
//              1999-11-24  vtan        added ErrorCodeOfStatusCode
//  --------------------------------------------------------------------------

class   CStatusCode
{
    public:
        static  LONG            ErrorCodeOfStatusCode (NTSTATUS statusCode);
        static  NTSTATUS        StatusCodeOfErrorCode (LONG errorCode);
        static  NTSTATUS        StatusCodeOfLastError (void);
};

#endif  /*  _StatusCode_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\stringconvert.h ===
//  --------------------------------------------------------------------------
//  Module Name: StringConvert.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Utility string functions. These are probably duplicated in some form in
//  shlwapi.dll. Currently this file exists to prevent some dependencies on
//  that file.
//
//  History:    1999-08-23  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StringConvert_
#define     _StringConvert_

//  --------------------------------------------------------------------------
//  CStringConvert
//
//  Purpose:    Collection of string conversion related functions bundled
//              into the CStringConvert namespace.
//
//  History:    1999-08-23  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class    CStringConvert
{
    public:
        static  int             AnsiToUnicode (const char *pszAnsiString, WCHAR *pszUnicodeString, int iUnicodeStringCount);
        static  int             UnicodeToAnsi (const WCHAR *pszUnicodeString, char *pszAnsiString, int iAnsiStringCount);
        static  void            TCharToUnicode (const TCHAR *pszString, WCHAR *pszUnicodeString, int iUnicodeStringCount);
        static  void            UnicodeToTChar (const WCHAR *pszUnicodeString, TCHAR *pszString, int iStringCount);
        static  void            TCharToAnsi (const TCHAR *pszString, char *pszAnsiString, int iAnsiStringCount);
        static  void            AnsiToTChar (const char *pszAnsiString, TCHAR *pszString, int iStringCount);
};

#endif  /*  _StringConvert_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\tokeninformation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TokenInformation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to get information about either the current thread/process token or
//  a specified token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CTokenInformation::CTokenInformation
//
//  Arguments:  hToken  =   Optional user token to get information on.
//
//  Returns:    <none>
//
//  Purpose:    Duplicates the given token if provided. Otherwise the thread
//              token is opened or the process token if that doesn't exist.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

CTokenInformation::CTokenInformation (HANDLE hToken) :
    _hToken(hToken),
    _hTokenToRelease(NULL),
    _pvGroupBuffer(NULL),
    _pvPrivilegeBuffer(NULL),
    _pvUserBuffer(NULL),
    _pszUserLogonName(NULL),
    _pszUserDisplayName(NULL)

{
    if (hToken == NULL)
    {
        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &_hToken) == FALSE)
        {
            TBOOL(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &_hToken));
        }
        if (_hToken != NULL)
        {
            _hTokenToRelease = _hToken;
        }
    }
}

//  --------------------------------------------------------------------------
//  CTokenInformation::~CTokenInformation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

CTokenInformation::~CTokenInformation (void)

{
    ReleaseMemory(_pszUserLogonName);
    ReleaseMemory(_pszUserDisplayName);
    ReleaseMemory(_pvUserBuffer);
    ReleaseMemory(_pvPrivilegeBuffer);
    ReleaseMemory(_pvGroupBuffer);
    ReleaseHandle(_hTokenToRelease);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetLogonSID
//
//  Arguments:  <none>
//
//  Returns:    PSID
//
//  Purpose:    Gets token information for the token groups. Walks the groups
//              looking for the SID with SE_GROUP_LOGON_ID and returns a
//              pointer to this SID. This memory is available for the scope
//              of the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

PSID    CTokenInformation::GetLogonSID (void)

{
    PSID    pSID;

    pSID = NULL;
    if ((_hToken != NULL) && (_pvGroupBuffer == NULL))
    {
        GetTokenGroups();
    }
    if (_pvGroupBuffer != NULL)
    {
        ULONG           ulIndex, ulLimit;
        TOKEN_GROUPS    *pTG;

        pTG = reinterpret_cast<TOKEN_GROUPS*>(_pvGroupBuffer);
        ulLimit = pTG->GroupCount;
        for (ulIndex = 0; (pSID == NULL) && (ulIndex < ulLimit); ++ulIndex)
        {
            if ((pTG->Groups[ulIndex].Attributes & SE_GROUP_LOGON_ID) != 0)
            {
                pSID = pTG->Groups[ulIndex].Sid;
            }
        }
    }
    return(pSID);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserSID
//
//  Arguments:  <none>
//
//  Returns:    PSID
//
//  Purpose:    Gets token information for the token user. This returns the
//              SID for the user of the token. This memory is available for
//              the scope of the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

PSID    CTokenInformation::GetUserSID (void)

{
    PSID    pSID;

    if ((_pvUserBuffer == NULL) && (_hToken != NULL))
    {
        DWORD   dwReturnLength;

        dwReturnLength = 0;
        (BOOL)GetTokenInformation(_hToken, TokenUser, NULL, 0, &dwReturnLength);
        _pvUserBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
        if ((_pvUserBuffer != NULL) &&
            (GetTokenInformation(_hToken, TokenUser, _pvUserBuffer, dwReturnLength, &dwReturnLength) == FALSE))
        {
            ReleaseMemory(_pvUserBuffer);
            _pvUserBuffer = NULL;
        }
    }
    if (_pvUserBuffer != NULL)
    {
        pSID = reinterpret_cast<TOKEN_USER*>(_pvUserBuffer)->User.Sid;
    }
    else
    {
        pSID = NULL;
    }
    return(pSID);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsUserTheSystem
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is the local system.
//
//  History:    1999-12-13  vtan        created
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsUserTheSystem (void)

{
    static  const LUID  sLUIDSystem     =   SYSTEM_LUID;

    ULONG               ulReturnLength;
    TOKEN_STATISTICS    tokenStatistics;

    return((GetTokenInformation(_hToken, TokenStatistics, &tokenStatistics, sizeof(tokenStatistics), &ulReturnLength) != FALSE) &&
           RtlEqualLuid(&tokenStatistics.AuthenticationId, &sLUIDSystem));
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsUserAnAdministrator
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is a member of the local administrator group.
//
//  History:    92-05-06    davidc  created
//              1999-11-06  vtan    stolen
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsUserAnAdministrator (void)

{
    bool    fIsAnAdministrator;

    fIsAnAdministrator = false;
    if ((_hToken != NULL) && (_pvGroupBuffer == NULL))
    {
        GetTokenGroups();
    }
    if (_pvGroupBuffer != NULL)
    {
        PSID    pAdministratorSID;

        static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

        if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                                   2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_ADMINS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &pAdministratorSID)))
        {
            ULONG           ulIndex, ulLimit;
            TOKEN_GROUPS    *pTG;

            pTG = reinterpret_cast<TOKEN_GROUPS*>(_pvGroupBuffer);
            ulLimit = pTG->GroupCount;
            for (ulIndex = 0; !fIsAnAdministrator && (ulIndex < ulLimit); ++ulIndex)
            {
                fIsAnAdministrator = ((RtlEqualSid(pTG->Groups[ulIndex].Sid, pAdministratorSID) != FALSE) &&
                                      ((pTG->Groups[ulIndex].Attributes & SE_GROUP_ENABLED) != 0));
            }
            (void*)RtlFreeSid(pAdministratorSID);
        }
    }
    return(fIsAnAdministrator);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::UserHasPrivilege
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is a member of the local administrator group.
//
//  History:    2000-04-26  vtan    created
//  --------------------------------------------------------------------------

bool    CTokenInformation::UserHasPrivilege (DWORD dwPrivilege)

{
    bool    fUserHasPrivilege;

    fUserHasPrivilege = false;
    if ((_hToken != NULL) && (_pvPrivilegeBuffer == NULL))
    {
        GetTokenPrivileges();
    }
    if (_pvPrivilegeBuffer != NULL)
    {
        ULONG               ulIndex, ulLimit;
        TOKEN_PRIVILEGES    *pTP;
        LUID                luidPrivilege;

        luidPrivilege.LowPart = dwPrivilege;
        luidPrivilege.HighPart = 0;
        pTP = reinterpret_cast<TOKEN_PRIVILEGES*>(_pvPrivilegeBuffer);
        ulLimit = pTP->PrivilegeCount;
        for (ulIndex = 0; !fUserHasPrivilege && (ulIndex < ulLimit); ++ulIndex)
        {
            fUserHasPrivilege = (RtlEqualLuid(&pTP->Privileges[ulIndex].Luid, &luidPrivilege) != FALSE);
        }
    }
    return(fUserHasPrivilege);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserName
//
//  Arguments:  <none>
//
//  Returns:    WCHAR
//
//  Purpose:    Looks up the account name of the implicit token..
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

const WCHAR*    CTokenInformation::GetUserName (void)

{
    if (_pszUserLogonName == NULL)
    {
        DWORD           dwUserNameSize, dwReferencedDomainSize;
        SID_NAME_USE    eUse;
        WCHAR           *pszReferencedDomain;

        dwUserNameSize = dwReferencedDomainSize = 0;
        (BOOL)LookupAccountSid(NULL,
                               GetUserSID(),
                               NULL,
                               &dwUserNameSize,
                               NULL,
                               &dwReferencedDomainSize,
                               &eUse);
        pszReferencedDomain = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwReferencedDomainSize * sizeof(WCHAR)));
        if (pszReferencedDomain != NULL)
        {
            _pszUserLogonName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwUserNameSize * sizeof(WCHAR)));
            if (_pszUserLogonName != NULL)
            {
                if (LookupAccountSid(NULL,
                                     GetUserSID(),
                                     _pszUserLogonName,
                                     &dwUserNameSize,
                                     pszReferencedDomain,
                                     &dwReferencedDomainSize,
                                     &eUse) == FALSE)
                {
                    ReleaseMemory(_pszUserLogonName);
                }
            }
            (HLOCAL)LocalFree(pszReferencedDomain);
        }
    }
    return(_pszUserLogonName);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserDisplayName
//
//  Arguments:  <none>
//
//  Returns:    WCHAR
//
//  Purpose:    Returns the display name of the implicit token.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

const WCHAR*    CTokenInformation::GetUserDisplayName (void)

{
    if (_pszUserDisplayName == NULL)
    {
        const WCHAR     *pszUserName;

        pszUserName = GetUserName();
        if (pszUserName != NULL)
        {
            USER_INFO_2     *pUserInfo;

            if (NERR_Success == NetUserGetInfo(NULL, pszUserName, 2, reinterpret_cast<LPBYTE*>(&pUserInfo)))
            {
                const WCHAR     *pszUserDisplayName;

                if (pUserInfo->usri2_full_name[0] != L'\0')
                {
                    pszUserDisplayName = pUserInfo->usri2_full_name;
                }
                else
                {
                    pszUserDisplayName = pszUserName;
                }
                _pszUserDisplayName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (lstrlen(pszUserDisplayName) + sizeof('\0')) * sizeof(WCHAR)));
                if (_pszUserDisplayName != NULL)
                {
                    lstrcpy(_pszUserDisplayName, pszUserDisplayName);
                }
                TW32(NetApiBufferFree(pUserInfo));
            }
        }
    }
    return(_pszUserDisplayName);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::LogonUser
//
//  Arguments:  See the platform SDK under LogonUser.
//
//  Returns:    DWORD
//
//  Purpose:    Calls advapi32!LogonUserW with supplied credentials using
//              interactive logon type. Returns the error code as a DWORD
//              rather than the standard Win32 API method which allows the
//              filtering of certain error codes.
//
//  History:    2001-03-28  vtan    created
//  --------------------------------------------------------------------------

DWORD   CTokenInformation::LogonUser (const WCHAR *pszUsername, const WCHAR *pszDomain, const WCHAR *pszPassword, HANDLE *phToken)

{
    DWORD   dwErrorCode;

    if (::LogonUserW(const_cast<WCHAR*>(pszUsername),
                     const_cast<WCHAR*>(pszDomain),
                     const_cast<WCHAR*>(pszPassword),
                     LOGON32_LOGON_INTERACTIVE,
                     LOGON32_PROVIDER_DEFAULT,
                     phToken) != FALSE)
    {
        dwErrorCode = ERROR_SUCCESS;
    }
    else
    {
        *phToken = NULL;
        dwErrorCode = GetLastError();

        //  Ignore ERROR_PASSWORD_MUST_CHANGE and ERROR_PASSWORD_EXPIRED.

        if ((dwErrorCode == ERROR_PASSWORD_MUST_CHANGE) || (dwErrorCode == ERROR_PASSWORD_EXPIRED))
        {
            dwErrorCode = ERROR_SUCCESS;
        }
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsSameUser
//
//  Arguments:  hToken1     =   Token of one user.
//              hToken2     =   Token of other user.
//
//  Returns:    bool
//
//  Purpose:    Compares the user SID of the tokens for a match.
//
//  History:    2001-03-28  vtan    created
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsSameUser (HANDLE hToken1, HANDLE hToken2)

{
    PSID                pSID1;
    PSID                pSID2;
    CTokenInformation   tokenInformation1(hToken1);
    CTokenInformation   tokenInformation2(hToken2);

    pSID1 = tokenInformation1.GetUserSID();
    pSID2 = tokenInformation2.GetUserSID();
    return((pSID1 != NULL) &&
           (pSID2 != NULL) &&
           (EqualSid(pSID1, pSID2) != FALSE));
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetTokenGroups
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Gets token information for the token user. This function
//              allocates the memory for the token groups. This memory is
//              available for the scope of the object.
//
//  History:    1999-11-06  vtan    created
//  --------------------------------------------------------------------------

void    CTokenInformation::GetTokenGroups (void)

{
    DWORD   dwReturnLength;

    dwReturnLength = 0;
    (BOOL)GetTokenInformation(_hToken, TokenGroups, NULL, 0, &dwReturnLength);
    _pvGroupBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
    if ((_pvGroupBuffer != NULL) &&
        (GetTokenInformation(_hToken, TokenGroups, _pvGroupBuffer, dwReturnLength, &dwReturnLength) == FALSE))
    {
        ReleaseMemory(_pvGroupBuffer);
        _pvGroupBuffer = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetTokenPrivileges
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Gets token privileges for the token user. This function
//              allocates the memory for the token privileges. This memory is
//              available for the scope of the object.
//
//  History:    2000-04-26  vtan    created
//  --------------------------------------------------------------------------

void    CTokenInformation::GetTokenPrivileges (void)

{
    DWORD   dwReturnLength;

    dwReturnLength = 0;
    (BOOL)GetTokenInformation(_hToken, TokenPrivileges, NULL, 0, &dwReturnLength);
    _pvPrivilegeBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
    if ((_pvPrivilegeBuffer != NULL) &&
        (GetTokenInformation(_hToken, TokenPrivileges, _pvPrivilegeBuffer, dwReturnLength, &dwReturnLength) == FALSE))
    {
        ReleaseMemory(_pvPrivilegeBuffer);
        _pvPrivilegeBuffer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\thread.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Thread.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements thread functionality. Subclass this class and
//  implement the virtual ThreadEntry function. When you instantiate this
//  class a thread gets created which will call ThreadEntry and when that
//  function exits will call ThreadExit. These objects should be created using
//  operator new because the default implementation of ThreadExit does
//  "delete this". You should override this function if you don't want this
//  behavior. The threads are also created SUSPENDED. You make any changes
//  that are required in the subclass' constructor. At the end of the
//  constructor or from the caller of operator new a "->Resume()" can be
//  invoked to start the thread.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Thread.h"

#include "Access.h"
#include "Impersonation.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CThread::CThread
//
//  Arguments:  stackSpace              =   Size of stack to reserve for this
//                                          thread. Default = system default.
//              createFlags             =   Additional flags designating how
//                                          the thread should be created.
//                                          Default = none.
//              hToken                  =   User token to assign to the
//                                          thread. Default = none.
//              pSecurityDescriptor     =   SecurityDescriptor to assign to
//                                          thread. Default = none.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CThread object. Creates the thread SUSPENDED
//              with given security attributes and assigns the hToken to the
//              thread. The token need not have SecurityImpersonation as a
//              duplicate is made with this access mode.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CThread::CThread (DWORD stackSpace, DWORD createFlags, HANDLE hToken) :
    CCountedObject(),
    _hThread(NULL),
    _fCompleted(false)

{
    DWORD   dwThreadID;

    //  It is important to create the thread suspended. This constructor could
    //  get pre-empted by the system and does. If pre-empted whilst executing
    //  the constructor, the derived class is NOT fully constructed and the
    //  virtual table isn't correctly initialized.

    _hThread = CreateThread(NULL,
                            stackSpace,
                            ThreadEntryProc,
                            this,
                            createFlags | CREATE_SUSPENDED,
                            &dwThreadID);
    if (_hThread != NULL)
    {

        //  Make a call to CCountedObject::AddRef here. This reference belongs
        //  to the thread. It's necessary to do it now because the creator of
        //  this thread can release its reference before the thread even begins
        //  executing which would cause the object to be released!
        //  CThread::ThreadEntryProc will release this reference when the
        //  thread's execution is finished. The creator of this thread should
        //  release its reference when it's done with the thread which may be
        //  immediately in the case of an asynhronous operation in which the
        //  thread cleans itself up.

        AddRef();

        //  Impersonate the user token if given. Also grant access to the thread
        //  object to the user. This will allow them to query thread information.

        if (hToken != NULL)
        {
            TSTATUS(SetToken(hToken));
        }
    }
}

//  --------------------------------------------------------------------------
//  CThread::~CThread
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CThread object on thread
//              termination.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

CThread::~CThread (void)

{
    ASSERTMSG(_fCompleted, "CThread::~CThread called before ThreadEntry() completed");
    ReleaseHandle(_hThread);
}

//  --------------------------------------------------------------------------
//  CThread::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CThread to a HANDLE
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

CThread::operator HANDLE (void)                      const

{
    return(_hThread);
}

//  --------------------------------------------------------------------------
//  CThread::IsCreated
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether a thread was created or not.
//
//  History:    2000-09-08  vtan        created
//  --------------------------------------------------------------------------

bool    CThread::IsCreated (void)                            const

{
    return(_hThread != NULL);
}

//  --------------------------------------------------------------------------
//  CThread::Suspend
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Suspends thread execution.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Suspend (void)                              const

{
    if (SuspendThread(_hThread) == 0xFFFFFFFF)
    {
        DISPLAYMSG("SuspendThread failed for thread handle in CThread::Suspend");
    }
}

//  --------------------------------------------------------------------------
//  CThread::Resume
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Resumes thread execution.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Resume (void)                               const

{
    if ((_hThread == NULL) || (ResumeThread(_hThread) == 0xFFFFFFFF))
    {
        DISPLAYMSG("ResumeThread failed for thread handle in CThread::Resume");
    }
}

//  --------------------------------------------------------------------------
//  CThread::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Forcibly terminates the thread. Use this with care. It should
//              only be used in case a sub-class constructor fails and the
//              thread is suspended and hasn't even run yet.
//
//  History:    2000-10-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThread::Terminate (void)

{
    NTSTATUS    status;

    if (TerminateThread(_hThread, 0) != FALSE)
    {
        _fCompleted = true;
        Release();
        ReleaseHandle(_hThread);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThread::IsCompleted
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Determines whether the thread has completed execution. This
//              does not check the signaled state of the thread handle but
//              rather checks member variables.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

bool    CThread::IsCompleted (void)                          const

{
    DWORD   dwExitCode;

    return((GetExitCodeThread(_hThread, &dwExitCode) != FALSE) && (dwExitCode != STILL_ACTIVE));
}

//  --------------------------------------------------------------------------
//  CThread::WaitForCompletion
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait for
//                                  thread completion.
//
//  Returns:    DWORD
//
//  Purpose:    Waits for the thread handle to become signaled.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThread::WaitForCompletion (DWORD dwMilliseconds)    const

{
    DWORD       dwWaitResult;

    do
    {

        //  When waiting for the object check to see that it's not signaled.
        //  If signaled then abandon the wait loop. Otherwise allow user32
        //  to continue processing messages for this thread.

        dwWaitResult = WaitForSingleObject(_hThread, 0);
        if (dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hThread, FALSE, dwMilliseconds, QS_ALLINPUT);
            if (dwWaitResult == WAIT_OBJECT_0 + 1)
            {
                MSG     msg;

                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
                {
                    (BOOL)TranslateMessage(&msg);
                    (LRESULT)DispatchMessage(&msg);
                }
            }
        }
    } while (dwWaitResult == WAIT_OBJECT_0 + 1);
    return(dwWaitResult);
}

//  --------------------------------------------------------------------------
//  CThread::GetResult
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Gets the thread's exit code. This assumes it has completed
//              execution and returns STILL_ACTIVE if not completed.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThread::GetResult (void)                            const

{
    DWORD   dwResult;

    if (GetExitCodeThread(_hThread, &dwResult) == FALSE)
    {
        dwResult = STILL_ACTIVE;
    }
    return(dwResult);
}

//  --------------------------------------------------------------------------
//  CThread::GetPriority
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Gets the thread's priority.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

int     CThread::GetPriority (void)                          const

{
    return(GetThreadPriority(_hThread));
}

//  --------------------------------------------------------------------------
//  CThread::SetPriority
//
//  Arguments:  newPriority     =   New priority for the thread.
//
//  Returns:    <none>
//
//  Purpose:    Sets the thread's priority.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::SetPriority (int newPriority)               const

{
    if (SetThreadPriority(_hThread, newPriority) == 0)
    {
        DISPLAYMSG("SetThreadPriorty failed in CThread::SetPriority");
    }
}

//  --------------------------------------------------------------------------
//  CThread::ThreadExit
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Default base class implementation of thread exit. For threads
//              whose execution is self contained and termination is not an
//              issue then this will clean up after the thread. This function
//              should be overriden if this behavior is NOT desired.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Exit (void)

{
}

//  --------------------------------------------------------------------------
//  CThread::SetToken
//
//  Arguments:  hToken  =   HANDLE to the user token to assign to this thread.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the impersonation token associated with this thread so
//              the thread will execute in the user's context from the start.
//
//  History:    1999-09-23  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThread::SetToken (HANDLE hToken)

{
    PSID                pLogonSID;
    CTokenInformation   tokenInformation(hToken);

    pLogonSID = tokenInformation.GetLogonSID();
    if (pLogonSID != NULL)
    {
        CSecuredObject      threadSecurity(_hThread, SE_KERNEL_OBJECT);

        TSTATUS(threadSecurity.Allow(pLogonSID,
                                     THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
                                     0));
        TSTATUS(CImpersonation::ImpersonateUser(_hThread, hToken));
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThread::ThreadEntryProc
//
//  Arguments:  pParameter  =   "this" object.
//
//  Returns:    DWORD
//
//  Purpose:    Entry procedure for the thread. This manages the type-casting
//              and invokation of CThread::ThreadEntry and CThread::ThreadExit
//              as well as the _fCompleted member variable.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CThread::ThreadEntryProc (void *parameter)

{
    DWORD       dwThreadResult;
    CThread     *pThread;

    pThread = static_cast<CThread*>(parameter);
    dwThreadResult = pThread->Entry();
    pThread->_fCompleted = true;
    pThread->Exit();
    pThread->Release();
    return(dwThreadResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\thread.h ===
//  --------------------------------------------------------------------------
//  Module Name: Thread.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements thread functionality. Subclass this class and
//  implement the virtual ThreadEntry function. When you instantiate this
//  class a thread gets created which will call ThreadEntry and when that
//  function exits will call ThreadExit. These objects should be created using
//  operator new because the default implementation of ThreadExit does
//  "->Release()". You should override this function if you don't want this
//  behavior. The threads are also created SUSPENDED. You make any changes
//  that are required in the subclass' constructor. At the end of the
//  constructor or from the caller of operator new a "->Resume()" can be
//  invoked to start the thread.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Thread_
#define     _Thread_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CThread
//
//  Purpose:    A base class to manage threads.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CThread : public CCountedObject
{
    public:
                                CThread (DWORD stackSpace = 0, DWORD createFlags = 0, HANDLE hToken = NULL);
        virtual                 ~CThread (void);

                                operator HANDLE (void)                      const;

                bool            IsCreated (void)                            const;

                void            Suspend (void)                              const;
                void            Resume (void)                               const;
                NTSTATUS        Terminate (void);

                bool            IsCompleted (void)                          const;
                DWORD           WaitForCompletion (DWORD dwMilliseconds)    const;
                DWORD           GetResult (void)                            const;

                int             GetPriority (void)                          const;
                void            SetPriority (int newPriority)               const;
    protected:
        virtual DWORD           Entry (void) = 0;
        virtual void            Exit (void);

                NTSTATUS        SetToken (HANDLE hToken);
    private:
        static  DWORD   WINAPI  ThreadEntryProc (void *pParameter);
    protected:
                HANDLE          _hThread;
                bool            _fCompleted;
};

#endif  /*  _Thread_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\stringconvert.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StringConvert.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  Utility string functions. These are probably duplicated in some form in
//  shlwapi.dll. Currently this file exists to prevent some dependencies on
//  that file.
//
//  History:    1999-08-23  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "StringConvert.h"

//  --------------------------------------------------------------------------
//  CStringConvert::AnsiToUnicode
//
//  Arguments:  pszAnsiString           =   ANSI string to convert.
//              pszUnicodeString        =   UNICODE string receiving output.
//              iUnicodeStringCount     =   Character count of output string.
//
//  Returns:    int     =   See kernel32!MultiByteToWideChar.
//
//  Purpose:    Explicitly converts an ANSI string to a UNICODE string.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

int     CStringConvert::AnsiToUnicode (const char *pszAnsiString, WCHAR *pszUnicodeString, int iUnicodeStringCount)

{
    return(MultiByteToWideChar(CP_ACP, 0, pszAnsiString, -1, pszUnicodeString, iUnicodeStringCount));
}

//  --------------------------------------------------------------------------
//  CStringConvert::UnicodeToAnsi
//
//  Arguments:  pszUnicodeString        =   UNICODE string receiving output.
//              pszAnsiString           =   ANSI string to convert.
//              iAnsiStringCount        =   Character count of output string.
//
//  Returns:    int     =   See kernel32!WideCharToMultiByte.
//
//  Purpose:    Explicitly converts a UNICODE string to an ANSI string.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

int     CStringConvert::UnicodeToAnsi (const WCHAR *pszUnicodeString, char *pszAnsiString, int iAnsiStringCount)

{
    return(WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, -1, pszAnsiString, iAnsiStringCount, NULL, NULL));
}

//  --------------------------------------------------------------------------
//  CStringConvert::TCharToUnicode
//
//  Arguments:  pszString               =   TCHAR string to convert.
//              pszUnicodeString        =   UNICODE string receiving output.
//              iUnicodeStringCount     =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a UNICODE string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::TCharToUnicode (const TCHAR *pszString, WCHAR *pszUnicodeString, int iUnicodeStringCount)

{
#ifdef  UNICODE
    (const char*)lstrcpyn(pszUnicodeString, pszString, iUnicodeStringCount);
#else
    (int)AnsiToUnicode(pszString, pszUnicodeString, iUnicodeStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::UnicodeToTChar
//
//  Arguments:  pszUnicodeString    =   UNICODE string to convert.
//              pszString           =   TCHAR string receiving output.
//              iStringCount        =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::UnicodeToTChar (const WCHAR *pszUnicodeString, TCHAR *pszString, int iStringCount)

{
#ifdef  UNICODE
    (const char*)lstrcpyn(pszString, pszUnicodeString, iStringCount);
#else
    (int)UnicodeToAnsi(pszUnicodeString, pszString, iStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::TCharToAnsi
//
//  Arguments:  pszString           =   TCHAR string to convert.
//              pszAnsiString       =   ANSI string receiving output.
//              iAnsiStringCount    =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::TCharToAnsi (const TCHAR *pszString, char *pszAnsiString, int iAnsiStringCount)

{
#ifdef  UNICODE
    (int)UnicodeToAnsi(pszString, pszAnsiString, iAnsiStringCount);
#else
    (const char*)lstrcpyn(pszAnsiString, pszString, iAnsiStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::AnsiToTChar
//
//  Arguments:  pszAnsiString   =   ANSI string to convert.
//              pszString       =   TCHAR string receiving output.
//              iStringCount    =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::AnsiToTChar (const char *pszAnsiString, TCHAR *pszString, int iStringCount)

{
#ifdef  UNICODE
    (int)AnsiToUnicode(pszAnsiString, pszString, iStringCount);
#else
    (const char*)lstrcpyn(pszString, pszAnsiString, iStringCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\generic\tokeninformation.h ===
//  --------------------------------------------------------------------------
//  Module Name: TokenInformation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to get information about either the current thread/process token or
//  a specified token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _TokenInformation_
#define     _TokenInformation_

//  --------------------------------------------------------------------------
//  CTokenInformation
//
//  Purpose:    This class either uses the given access token or if none is
//              given then the thread impersonation token or if that doesn't
//              exist then the process token. It duplicates the token so the
//              original must be released by the caller. It returns
//              information about the access token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CTokenInformation
{
    public:
                                CTokenInformation (HANDLE hToken = NULL);
                                ~CTokenInformation (void);

                PSID            GetLogonSID (void);
                PSID            GetUserSID (void);
                bool            IsUserTheSystem (void);
                bool            IsUserAnAdministrator (void);
                bool            UserHasPrivilege (DWORD dwPrivilege);
                const WCHAR*    GetUserName (void);
                const WCHAR*    GetUserDisplayName (void);

        static  DWORD           LogonUser (const WCHAR *pszUsername, const WCHAR *pszDomain, const WCHAR *pszPassword, HANDLE *phToken);
        static  bool            IsSameUser (HANDLE hToken1, HANDLE hToken2);
    private:
                void            GetTokenGroups (void);
                void            GetTokenPrivileges (void);
    private:
                HANDLE          _hToken,
                                _hTokenToRelease;
                void            *_pvGroupBuffer,
                                *_pvPrivilegeBuffer,
                                *_pvUserBuffer;
                WCHAR           *_pszUserLogonName,
                                *_pszUserDisplayName;
};

#endif  /*  _TokenInformation_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\ieguid\ieguidp.c ===
#include <initguid.h>

#include "ieguidp.h"
#include "msieftp_i.c"
#include "iepriv_i.c"
#include "brdispp_i.c"
#include "webvw_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\ieguid\makefile.inc ===
$(CCSHELL_DIR)\lib\$O\ieguidp.lib: $(O)\ieguidp.obj
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\inetutil\makefile.inc ===
#
# Copy inetutil.lib to shell\lib\$(O)
#
$(PROJECT_ROOT)\lib\$(O)\inetutil.lib: $(O)\inetutil.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\secutil\makefile.inc ===
#
# Copy secutil.lib to shell\lib\$(O)
#
$(PROJECT_ROOT)\lib\$(O)\secutil.lib: $(O)\secutil.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\secutil\profileutil.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ProfileUtil.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to handle profile loading and unloading without a token.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <sddl.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <dsgetdc.h>

#include "ProfileUtil.h"
#include "TokenUtil.h"

#define ARRAYSIZE(x)    (sizeof(x) / sizeof(x[0]))
#define TBOOL(x)        (BOOL)(x)
#define TW32(x)         (DWORD)(x)

//  --------------------------------------------------------------------------
//  CUserProfile::s_szUserHiveFilename
//
//  Purpose:    Default user hive name.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

const TCHAR     CUserProfile::s_szUserHiveFilename[]    =   TEXT("ntuser.dat");

//  --------------------------------------------------------------------------
//  CUserProfile::CUserProfile
//
//  Arguments:  pszUsername     =   User name of profile to load.
//              pszDomain       =   Domain for the user.
//
//  Returns:    <none>
//
//  Purpose:    Opens a handle to the given user's hive. If the hive isn't
//              loaded then the hive is loaded and a handle opened.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::CUserProfile (const TCHAR *pszUsername, const TCHAR *pszDomain) :
    _hKeyProfile(NULL),
    _pszSID(NULL),
    _fLoaded(false)

{

    //  Validate parameter.

    if (!IsBadStringPtr(pszUsername, static_cast<UINT_PTR>(-1)))
    {
        PSID    pSID;

        //  Convert the username to a SID.

        pSID = UsernameToSID(pszUsername, pszDomain);
        if (pSID != NULL)
        {

            //  Convert the SID to a string.

            if (ConvertSidToStringSid(pSID, &_pszSID) != FALSE)
            {

                //  Attempt to open the user's hive.

                if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_USERS,
                                                  _pszSID,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &_hKeyProfile))
                {
                    TCHAR   szProfilePath[MAX_PATH];

                    //  If that failed then convert the string to a profile path.

                    if (SIDStringToProfilePath(_pszSID, szProfilePath))
                    {

                        //  Prevent buffer overrun.

                        if ((lstrlen(szProfilePath) + sizeof('\\') + ARRAYSIZE(s_szUserHiveFilename)) < ARRAYSIZE(szProfilePath))
                        {
                            CPrivilegeEnable    privilege(SE_RESTORE_NAME);

                            //  Enable SE_RESTORE_PRIVILEGE and create the
                            //  path to the user hive. Then load the hive.

                            lstrcat(szProfilePath, TEXT("\\"));
                            lstrcat(szProfilePath, s_szUserHiveFilename);
                            if (ERROR_SUCCESS == RegLoadKey(HKEY_USERS, _pszSID, szProfilePath))
                            {

                                //  Mark the hive as loaded and open the handle.

                                _fLoaded = true;
                                TW32(RegOpenKeyEx(HKEY_USERS,
                                                  _pszSID,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &_hKeyProfile));
                            }
                        }
                    }
                }
            }
            (HLOCAL)LocalFree(pSID);
        }
    }
}

//  --------------------------------------------------------------------------
//  CUserProfile::~CUserProfile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by this object.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::~CUserProfile (void)

{
    if (_hKeyProfile != NULL)
    {
        TBOOL(RegCloseKey(_hKeyProfile));
    }
    if (_fLoaded)
    {
        CPrivilegeEnable    privilege(SE_RESTORE_NAME);

        TW32(RegUnLoadKey(HKEY_USERS, _pszSID));
        _fLoaded = false;
    }
    if (_pszSID != NULL)
    {
        (HLOCAL)LocalFree(_pszSID);
        _pszSID = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CUserProfile::operator HKEY
//
//  Arguments:  <none>
//
//  Returns:    HKEY
//
//  Purpose:    Returns the HKEY to the user's hive.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::operator HKEY (void)  const

{
    return(_hKeyProfile);
}

//  --------------------------------------------------------------------------
//  CUserProfile::UsernameToSID
//
//  Arguments:  pszUsername     =   User name to convert.
//              pszDomain       =   Domain for the user.
//
//  Returns:    PSID
//
//  Purpose:    Uses the security accounts manager to look up the account by
//              name and return the SID.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

PSID    CUserProfile::UsernameToSID (const TCHAR *pszUsername, const TCHAR *pszDomain)

{
    DWORD                   dwSIDSize, dwComputerNameSize, dwReferencedDomainSize;
    SID_NAME_USE            eSIDUse;
    PSID                    pSID, pSIDResult;
    WCHAR                   *pszDomainControllerName;
    DOMAIN_CONTROLLER_INFO  *pDCI;
    TCHAR                   szComputerName[CNLEN + sizeof('\0')];

    pSIDResult = NULL;
    dwComputerNameSize = ARRAYSIZE(szComputerName);
    if (GetComputerName(szComputerName, &dwComputerNameSize) == FALSE)
    {
        szComputerName[0] = TEXT('\0');
    }
    if ((pszDomain != NULL) &&
        (lstrcmpi(szComputerName, pszDomain) != 0) &&
        (ERROR_SUCCESS == DsGetDcName(NULL,
                                     pszDomain,
                                     NULL,
                                     NULL,
                                     0,
                                     &pDCI)))
    {
        pszDomainControllerName = pDCI->DomainControllerName;
    }
    else
    {
        pDCI = NULL;
        pszDomainControllerName = NULL;
    }
    dwSIDSize = dwReferencedDomainSize = 0;
    (BOOL)LookupAccountName(pszDomainControllerName,
                            pszUsername,
                            NULL,
                            &dwSIDSize,
                            NULL,
                            &dwReferencedDomainSize,
                            &eSIDUse);
    pSID = LocalAlloc(LMEM_FIXED, dwSIDSize);
    if (pSID != NULL)
    {
        TCHAR   *pszReferencedDomain;

        pszReferencedDomain = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwReferencedDomainSize * sizeof(TCHAR)));
        if (pszReferencedDomain != NULL)
        {
            if (LookupAccountName(pszDomainControllerName,
                                  pszUsername,
                                  pSID,
                                  &dwSIDSize,
                                  pszReferencedDomain,
                                  &dwReferencedDomainSize,
                                  &eSIDUse) != FALSE)
            {
                if (SidTypeUser == eSIDUse)
                {

                    //  If the account was successfully looked up and the
                    //  account type is a user then return the result back
                    //  to the caller and ensure that it's not released here.

                    pSIDResult = pSID;
                    pSID = NULL;
                }
            }
            (HLOCAL)LocalFree(pszReferencedDomain);
        }
        if (pSID != NULL)
        {
            (HLOCAL)LocalFree(pSID);
        }
    }
    if (pDCI != NULL)
    {
        (NET_API_STATUS)NetApiBufferFree(pDCI);
    }
    return(pSIDResult);
}

//  --------------------------------------------------------------------------
//  CUserProfile::SIDStringToProfilePath
//
//  Arguments:  pszSIDString    =   SID string to look up.
//              pszProfilePath  =   Returned path to the profile.
//
//  Returns:    bool
//
//  Purpose:    Looks up the profile path for the given SID string in the
//              location where userenv stores it. This doesn't change
//              although no API exists for this information.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

bool    CUserProfile::SIDStringToProfilePath (const TCHAR *pszSIDString, TCHAR *pszProfilePath)

{
    bool    fResult;

    fResult = false;
    if (!IsBadStringPtr(pszSIDString, static_cast<UINT_PTR>(-1)) && !IsBadWritePtr(pszProfilePath, MAX_PATH * sizeof(TCHAR)))
    {
        HKEY    hKeyProfileList;

        pszProfilePath[0] = TEXT('\0');
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
                                          0,
                                          KEY_QUERY_VALUE,
                                          &hKeyProfileList))
        {
            HKEY    hKeySID;

            if (ERROR_SUCCESS == RegOpenKeyEx(hKeyProfileList,
                                              pszSIDString,
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeySID))
            {
                DWORD   dwType, dwProfilePathSize;
                TCHAR   szProfilePath[MAX_PATH];

                dwProfilePathSize = ARRAYSIZE(szProfilePath);
                if (ERROR_SUCCESS == RegQueryValueEx(hKeySID,
                                                     TEXT("ProfileImagePath"),
                                                     NULL,
                                                     &dwType,
                                                     reinterpret_cast<LPBYTE>(szProfilePath),
                                                     &dwProfilePathSize))
                {
                    if (REG_EXPAND_SZ == dwType)
                    {
                        fResult = true;
                        if (ExpandEnvironmentStrings(szProfilePath, pszProfilePath, MAX_PATH) == 0)
                        {
                            dwType = REG_SZ;
                        }
                    }
                    if (REG_SZ == dwType)
                    {
                        fResult = true;
                        (TCHAR*)lstrcpy(pszProfilePath, szProfilePath);
                    }
                }
                TW32(RegCloseKey(hKeySID));
            }
            TW32(RegCloseKey(hKeyProfileList));
        }
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\delaycc.h ===
#ifndef DELAYCC_H
#define DELAYCC_H

BOOL DelayLoadCC();
HANDLE NT5_CreateActCtx(ACTCTX* p);
void NT5_ReleaseActCtx(HANDLE h);
BOOL NT5_ActivateActCtx(HANDLE h, ULONG_PTR * p);
BOOL NT5_DeactivateActCtx(ULONG_PTR p);
BOOL SHActivateContext(ULONG_PTR *pdwCookie);
void SHDeactivateContext(ULONG_PTR dwCookie);

extern HANDLE g_hActCtx;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\cc\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\secutil\tokenutil.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TokenUtil.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Functions that are useful for token manipulation.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "TokenUtil.h"

//  --------------------------------------------------------------------------
//  ::OpenEffectiveToken
//
//  Arguments:  dwDesiredAccess     =   Access to open the handle with.
//
//  Returns:    BOOL
//
//  Purpose:    Opens the effective token. If the thread is impersonating then
//              this is opened. Otherwise the process token is opened.
//
//  History:    2000-03-31  vtan        created
//  --------------------------------------------------------------------------

STDAPI_(BOOL)   OpenEffectiveToken (IN DWORD dwDesiredAccess, OUT HANDLE *phToken)

{
    BOOL    fResult;

    if (IsBadWritePtr(phToken, sizeof(*phToken)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        fResult = FALSE;
    }
    else
    {
        *phToken = NULL;
        fResult = OpenThreadToken(GetCurrentThread(), dwDesiredAccess, FALSE, phToken);
        if (fResult == FALSE)
        {
            fResult = OpenProcessToken(GetCurrentProcess(), dwDesiredAccess, phToken);
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::CPrivilegeEnable
//
//  Arguments:  pszName     =   Name of the privilege to enable.
//
//  Returns:    <none>
//
//  Purpose:    Gets the current state of the privilege and enables it. The
//              privilege is specified by name and looked up.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::CPrivilegeEnable (const TCHAR *pszName) :
    _fSet(false),
    _hToken(NULL)

{
    if (OpenEffectiveToken(TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &_hToken) != FALSE)
    {
        TOKEN_PRIVILEGES    newPrivilege;

        if (LookupPrivilegeValue(NULL, pszName, &newPrivilege.Privileges[0].Luid) != FALSE)
        {
            DWORD   dwReturnTokenPrivilegesSize;

            newPrivilege.PrivilegeCount = 1;
            newPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            _fSet = (AdjustTokenPrivileges(_hToken,
                                           FALSE,
                                           &newPrivilege,
                                           sizeof(newPrivilege),
                                           &_tokenPrivilegePrevious,
                                           &dwReturnTokenPrivilegesSize) != FALSE);
        }
    }
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::~CPrivilegeEnable
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Restores the previous state of the privilege prior to
//              instantiation of the object.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::~CPrivilegeEnable (void)

{
    if (_fSet)
    {
        (BOOL)AdjustTokenPrivileges(_hToken,
                                    FALSE,
                                    &_tokenPrivilegePrevious,
                                    0,
                                    NULL,
                                    NULL);
    }
    if (_hToken != NULL)
    {
        (BOOL)CloseHandle(_hToken);
        _hToken = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\native\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\ansi\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\downlevel\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\delaycc.c ===
#define _COMCTL32_
#define _COMDLG32_
#include "stock.h"
#pragma hdrstop
#include "delaycc.h"
#include "shfusion.h"

// Load
HINSTANCE g_hinstCC = NULL;
HINSTANCE g_hinstCD = NULL;

BOOL DelayLoadCC()
{
    if (g_hinstCC == NULL)
    {
        g_hinstCC = SHFusionLoadLibrary(TEXT("comctl32.dll"));

        if (g_hinstCC == NULL)
        {
            SHFusionUninitialize();     // Unable to get v6, don't try to use a manifest

            g_hinstCC = LoadLibrary(TEXT("comctl32.dll"));
        }
    }
    return g_hinstCC != NULL;
}

BOOL DelayLoadCD()
{
    if (g_hinstCD == NULL)
    {
        g_hinstCD = SHFusionLoadLibrary(TEXT("comdlg32.dll"));

        if (g_hinstCD == NULL)
        {
            g_hinstCD = LoadLibrary(TEXT("comdlg32.dll"));
        }
    }
    return g_hinstCD != NULL;
}

void _GetProcFromComCtl32(FARPROC* ppfn, LPCSTR pszProc)
{
    if (g_hinstCC)
        *ppfn = GetProcAddress(g_hinstCC, pszProc);
    else
    {
        // Hmm, This is a fatal error.... Dialog and Quit?
        *ppfn = NULL;
    }
}

void _GetProcFromComDlg(FARPROC* ppfn, LPCSTR pszProc)
{
    // make sure g_hinstCD isn't NULL
    DelayLoadCD();

    if (g_hinstCD != NULL)
    {
        *ppfn = GetProcAddress(g_hinstCD, pszProc);
    }
    else
    {
        *ppfn = NULL;
    }
}


#define STUB_INVOKE_FN(_pfnVar, _nargs)                                       \
do                                                                            \
{                                                                             \
    if (_pfnVar)                                                              \
    {                                                                         \
        return _pfnVar _nargs;                                                \
    }                                                                         \
} while (0)

#define STUB_INVOKE_VOID_FN(_pfnVar, _nargs)                                  \
do                                                                            \
{                                                                             \
    if (_pfnVar)                                                              \
    {                                                                         \
        _pfnVar _nargs;                                                       \
    }                                                                         \
} while (0)

#define STUB_COMCTL32(_ret, _fn, _args, _nargs, _err)                         \
_ret __stdcall _fn _args                                                      \
{                                                                             \
    static _ret (__stdcall *_pfn##_fn) _args = (_ret (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (_ret (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, #_fn);                    \
    STUB_INVOKE_FN(_pfn ## _fn, _nargs);                                      \
    return (_ret)_err;                                                        \
}

#define STUB_COMCTL32_ORD(_ret, _fn, _args, _nargs, _ord, _err)               \
_ret __stdcall _fn _args                                                      \
{                                                                             \
    static _ret (__stdcall *_pfn##_fn) _args = (_ret (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (_ret (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);            \
    STUB_INVOKE_FN(_pfn ## _fn, _nargs);                                      \
    return (_ret)_err;                                                        \
}

#define STUB_COMCTL32_ORD_VOID(_fn, _args, _nargs, _ord)                      \
void __stdcall _fn _args                                                      \
{                                                                             \
    static void (__stdcall *_pfn##_fn) _args = (void (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (void (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);            \
    STUB_INVOKE_VOID_FN(_pfn ## _fn, _nargs);                                 \
}

#define STUB_COMCTL32_ORD_BOOL(_fn, _args, _nargs, _ord)  STUB_COMCTL32_ORD(BOOL, _fn, _args, _nargs, _ord, FALSE)
#define STUB_COMCTL32_BOOL(_fn, _args, _nargs)  STUB_COMCTL32(BOOL, _fn, _args, _nargs, FALSE)

#define STUB_COMCTL32_VOID(_fn, _args, _nargs)                                \
void __stdcall _fn _args                                                      \
{                                                                             \
    static void (__stdcall *_pfn##_fn) _args = (void (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (void (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, #_fn);                    \
    STUB_INVOKE_VOID_FN(_pfn ## _fn, _nargs);                                 \
}

STUB_COMCTL32_VOID(InitCommonControls, (), ());
STUB_COMCTL32_BOOL(InitCommonControlsEx, (LPINITCOMMONCONTROLSEX a), (a));
STUB_COMCTL32_BOOL(DestroyPropertySheetPage, (HPROPSHEETPAGE a), (a));
STUB_COMCTL32(HIMAGELIST, ImageList_Create, (int cx, int cy, UINT flags, int cInitial, int cGrow), (cx, cy, flags, cInitial, cGrow), NULL);
STUB_COMCTL32_BOOL(ImageList_Destroy, (HIMAGELIST himl), (himl));
STUB_COMCTL32(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl), FALSE);
STUB_COMCTL32_BOOL(ImageList_SetImageCount, (HIMAGELIST himl, UINT uNewCount), (himl, uNewCount));
STUB_COMCTL32(int, ImageList_Add, (HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask), (himl, hbmImage, hbmMask), -1);
STUB_COMCTL32(int, ImageList_ReplaceIcon, (HIMAGELIST himl, int i, HICON hicon), (himl, i, hicon), -1);
STUB_COMCTL32(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl, COLORREF clrBk), (himl, clrBk), RGB(0,0,0));
STUB_COMCTL32(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl), RGB(0,0,0));
STUB_COMCTL32_BOOL(ImageList_SetOverlayImage, (HIMAGELIST himl, int iImage, int iOverlay), (himl, iImage, iOverlay));
STUB_COMCTL32_BOOL(ImageList_Draw, (HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle), (himl, i, hdcDst, x, y, fStyle));
STUB_COMCTL32_BOOL(ImageList_Replace, (HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask), (himl, i, hbmImage, hbmMask));
STUB_COMCTL32(int, ImageList_AddMasked, (HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask), (himl, hbmImage, crMask), -1);
STUB_COMCTL32_BOOL(ImageList_DrawEx, (HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle), (himl, i, hdcDst, x, y, dx, dy, rgbBk, rgbFg, fStyle));
STUB_COMCTL32_BOOL(ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS* pimldp), (pimldp));
STUB_COMCTL32_BOOL(ImageList_Remove, (HIMAGELIST himl, int i), (himl, i));
STUB_COMCTL32(HICON, ImageList_GetIcon, (HIMAGELIST himl, int i, UINT flags), (himl, i, flags), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags), (hi, lpbmp, cx, cGrow, crMask, uType, uFlags), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags), (hi, lpbmp, cx, cGrow, crMask, uType, uFlags), NULL);
STUB_COMCTL32_BOOL(ImageList_Copy, (HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags), (himlDst, iDst, himlSrc, iSrc, uFlags));
STUB_COMCTL32_BOOL(ImageList_BeginDrag, (HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot), (himlTrack, iTrack, dxHotspot, dyHotspot));
STUB_COMCTL32_VOID(ImageList_EndDrag, (), ());
STUB_COMCTL32_BOOL(ImageList_DragEnter, (HWND hwndLock, int x, int y), (hwndLock, x, y));
STUB_COMCTL32_BOOL(ImageList_DragLeave, (HWND hwndLock), (hwndLock));
STUB_COMCTL32_BOOL(ImageList_DragMove, (int x, int y), (x, y));
STUB_COMCTL32_BOOL(ImageList_SetDragCursorImage, (HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot), (himlDrag, iDrag, dxHotspot, dyHotspot));
STUB_COMCTL32_BOOL(ImageList_DragShowNolock, (BOOL fShow), (fShow));
STUB_COMCTL32(HIMAGELIST, ImageList_GetDragImage, (POINT* ppt, POINT* pptHotspot), (ppt, pptHotspot), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_Read, (LPSTREAM pstm), (pstm), NULL);
STUB_COMCTL32_BOOL(ImageList_Write, (HIMAGELIST himl, LPSTREAM pstm), (himl, pstm));
STUB_COMCTL32_BOOL(ImageList_GetIconSize, (HIMAGELIST himl, int *cx, int*cy), (himl, cx, cy));
STUB_COMCTL32_BOOL(ImageList_SetIconSize, (HIMAGELIST himl, int cx, int cy), (himl, cx, cy));
STUB_COMCTL32_BOOL(ImageList_GetImageInfo, (HIMAGELIST himl, int i, IMAGEINFO* pImageInfo), (himl, i, pImageInfo));
STUB_COMCTL32(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy), (himl1, i1, himl2, i2, dx, dy), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl), NULL);
STUB_COMCTL32_VOID(InitMUILanguage, (LANGID uiLang), (uiLang));
STUB_COMCTL32_BOOL(ImageList_SetFilter, (HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter), (himl, pfnFilter, lParamFilter));
STUB_COMCTL32_BOOL(ImageList_GetImageRect, (HIMAGELIST himl, int i, RECT FAR* prcImage), (himl, i, prcImage));
STUB_COMCTL32_BOOL(ImageList_SetFlags, (HIMAGELIST himl, UINT flags), (himl, flags));
STUB_COMCTL32(UINT, ImageList_GetFlags, (HIMAGELIST himl), (himl), 0);
STUB_COMCTL32(HRESULT, HIMAGELIST_QueryInterface, (HIMAGELIST himl, REFIID riid, void** ppv), (himl, riid, ppv), E_FAIL);
STUB_COMCTL32(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize),(hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize), NULL );
STUB_COMCTL32(HWND, CreateStatusWindowW, (LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID), (style, lpszText, hwndParent, wID), NULL);

STUB_COMCTL32_ORD(int          , ImageList_SetColorTable, (HIMAGELIST piml, int start, int len, RGBQUAD *prgb), (piml, start, len, prgb), 390, 0);
STUB_COMCTL32_ORD_BOOL(MirrorIcon, (HICON* phiconSmall, HICON* phiconLarge), (phiconSmall, phiconLarge), 414);
STUB_COMCTL32_ORD(int          , Str_GetPtrW, (LPCWSTR psz, LPWSTR pszBuf, int cchBuf), (psz,pszBuf,cchBuf), 235, -1);
STUB_COMCTL32_ORD_BOOL(Str_SetPtrW, (LPWSTR * ppsz, LPCWSTR psz), (ppsz, psz), 236);
STUB_COMCTL32_ORD_BOOL(Str_SetPtrA, (LPSTR * ppsz, LPCSTR psz), (ppsz, psz), 234);
STUB_COMCTL32_ORD(HANDLE       , CreateMRUList, (LPMRUINFO lpmi), (lpmi), 400, NULL);
STUB_COMCTL32_ORD_VOID(FreeMRUList, (HANDLE hMRU), (hMRU), 152);
STUB_COMCTL32_ORD(int     , AddMRUStringA, (HANDLE hMRU, LPCSTR szString), (hMRU, szString), 401, -1);
STUB_COMCTL32_ORD(int     , AddMRUStringW, (HANDLE hMRU, LPCWSTR szString), (hMRU, szString), 401, -1);
STUB_COMCTL32_ORD(int     , DelMRUString, (HANDLE hMRU, int nItem), (hMRU, nItem), 156, -1);
STUB_COMCTL32_ORD(int     , FindMRUStringA, (HANDLE hMRU, LPCSTR szString, LPINT lpiSlot), (hMRU, szString, lpiSlot), 402, -1);
STUB_COMCTL32_ORD(int     , FindMRUStringW, (HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot), (hMRU, szString, lpiSlot), 402, -1);
STUB_COMCTL32_ORD(int     , EnumMRUList, (HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen), (hMRU, nItem, lpData, uLen), 403, -1);
STUB_COMCTL32_ORD(int     , AddMRUData, (HANDLE hMRU, const void FAR *lpData, UINT cbData), (hMRU, lpData, cbData), 167, -1);
STUB_COMCTL32_ORD(int     , FindMRUData, (HANDLE hMRU, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (hMRU, lpData, cbData, lpiSlot), 169, -1);
STUB_COMCTL32_ORD(HANDLE  , CreateMRUListLazyA, (LPMRUINFOA lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (lpmi, lpData, cbData, lpiSlot), 404, NULL);
STUB_COMCTL32_ORD(HANDLE  , CreateMRUListLazyW, (LPMRUINFOW lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (lpmi, lpData, cbData, lpiSlot), 404, NULL);
STUB_COMCTL32_ORD_BOOL(SetWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData), (hWnd, pfnSubclass, uIdSubclass, dwRefData), 410);
STUB_COMCTL32_ORD_BOOL(GetWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR *pdwRefData), (hWnd, pfnSubclass, uIdSubclass, pdwRefData), 411);
STUB_COMCTL32_ORD_BOOL(RemoveWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass), (hWnd, pfnSubclass, uIdSubclass), 412);
STUB_COMCTL32_ORD(LRESULT , DefSubclassProc, (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam), (hWnd, uMsg, wParam, lParam), 413, 0);
STUB_COMCTL32_ORD(HDSA    , DSA_Create, (int cbItem, int cItemGrow), (cbItem, cItemGrow), 320, NULL);
STUB_COMCTL32_ORD_BOOL(DSA_Destroy, (HDSA hdsa), (hdsa), 321);
STUB_COMCTL32_ORD_BOOL(DSA_GetItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 322);
STUB_COMCTL32_ORD(LPVOID  , DSA_GetItemPtr, (HDSA hdsa, int i), (hdsa, i), 323, NULL);
STUB_COMCTL32_ORD_BOOL(DSA_SetItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 325);
STUB_COMCTL32_ORD(int     , DSA_InsertItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 324, -1);
STUB_COMCTL32_ORD_BOOL(DSA_DeleteItem, (HDSA hdsa, int i), (hdsa, i), 326);
STUB_COMCTL32_ORD_BOOL(DSA_DeleteAllItems, (HDSA hdsa), (hdsa), 327);
STUB_COMCTL32_ORD_VOID(DSA_EnumCallback, (HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData), (hdsa, pfnCB, pData), 387);
STUB_COMCTL32_ORD_VOID(DSA_DestroyCallback, (HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData), (hdsa, pfnCB, pData), 388);
STUB_COMCTL32_ORD(HDPA    , DPA_Create, (int cItemGrow), (cItemGrow), 328, NULL);
STUB_COMCTL32_ORD(HDPA    , DPA_CreateEx, (int cpGrow, HANDLE hheap), (cpGrow, hheap), 340, NULL);
STUB_COMCTL32_ORD_BOOL(DPA_Destroy, (HDPA hdpa), (hdpa), 329);
STUB_COMCTL32_ORD(HDPA    , DPA_Clone, (HDPA hdpa, HDPA hdpaNew), (hdpa, hdpaNew), 331, NULL);
STUB_COMCTL32_ORD(LPVOID  , DPA_GetPtr, (HDPA hdpa, INT_PTR i), (hdpa, i), 332, NULL);
STUB_COMCTL32_ORD(int     , DPA_GetPtrIndex, (HDPA hdpa, LPVOID p), (hdpa, p), 333, -1);
STUB_COMCTL32_ORD_BOOL(DPA_Grow, (HDPA pdpa, int cp), (pdpa, cp), 330);
STUB_COMCTL32_ORD_BOOL(DPA_SetPtr, (HDPA hdpa, int i, LPVOID p), (hdpa, i, p), 335);
STUB_COMCTL32_ORD(int     , DPA_InsertPtr, (HDPA hdpa, int i, LPVOID p), (hdpa, i, p), 334, -1);
STUB_COMCTL32_ORD(LPVOID  , DPA_DeletePtr, (HDPA hdpa, int i), (hdpa, i), 336, NULL);
STUB_COMCTL32_ORD_BOOL(DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa), 337);
STUB_COMCTL32_ORD_VOID(DPA_EnumCallback, (HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData), (hdpa, pfnCB, pData), 385);
STUB_COMCTL32_ORD_VOID(DPA_DestroyCallback, (HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData), (hdpa, pfnCB, pData), 386);
STUB_COMCTL32_ORD(HRESULT  , DPA_LoadStream, (HDPA * phdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData), (phdpa, pfn, pstream, pvInstData), 9, E_FAIL);
STUB_COMCTL32_ORD(HRESULT  , DPA_SaveStream, (HDPA hdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData), (hdpa, pfn, pstream, pvInstData), 10, E_FAIL);
STUB_COMCTL32_ORD_BOOL(DPA_Sort, (HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam), (hdpa, pfnCompare, lParam), 338);
STUB_COMCTL32_ORD_BOOL(DPA_Merge, (HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDPACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam), (hdpaDest, hdpaSrc, dwFlags, pfnCompare, pfnMerge, lParam), 11);
STUB_COMCTL32_ORD(int  , DPA_Search, (HDPA hdpa, LPVOID pFind, int iStart, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options), (hdpa, pFind, iStart, pfnCompare, lParam, options), 339, -1);
STUB_COMCTL32_ORD(LRESULT  , SendNotify, (HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr), (hwndTo, hwndFrom, code, pnmhdr), 341, 0);
STUB_COMCTL32_ORD(LRESULT  , SendNotifyEx, (HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr, BOOL bUnicode), (hwndTo, hwndFrom, code, pnmhdr, bUnicode), 342, 0);
STUB_COMCTL32_ORD_VOID(SetPathWordBreakProc, (HWND hwndEdit, BOOL fSet), (hwndEdit, fSet), 384);
STUB_COMCTL32_ORD(HPROPSHEETPAGE , CreateProxyPage, (HPROPSHEETPAGE hpage16, HINSTANCE hinst16), (hpage16, hinst16), 164, NULL);
STUB_COMCTL32_ORD(HBITMAP , CreateMappedBitmap, (HINSTANCE hInstance, INT_PTR idBitmap, UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps), (hInstance, idBitmap, wFlags, lpColorMap, iNumMaps), 8, NULL);
STUB_COMCTL32_ORD(HWND , CreateUpDownControl, (DWORD dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, HWND hwndBuddy, int nUpper, int nLower, int nPos), (dwStyle, x, y, cx, cy, hParent, nID, hInst, hwndBuddy, nUpper, nLower, nPos), 16, NULL);
//STUB_COMCTL32_ORD(DWORD , SHGetProcessDword, (DWORD idProcess, LONG iIndex), (idProcess, iIndex), 389, 0);
STUB_COMCTL32_ORD_VOID(MenuHelp, (UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT FAR *lpwIDs), (uMsg, wParam, lParam, hMainMenu, hInst, hwndStatus, lpwIDs), 2);
STUB_COMCTL32_ORD_VOID(GetEffectiveClientRect, (HWND hWnd, LPRECT lprc, LPINT lpInfo), (hWnd, lprc, lpInfo), 4);

// This is for OE
STUB_COMCTL32_BOOL(_TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack));
STUB_COMCTL32_ORD(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style, lpszText, hwndParent, wID),6, NULL);
STUB_COMCTL32_ORD_BOOL(MakeDragList, (HWND hLB), (hLB), 13);
STUB_COMCTL32_ORD_VOID(DrawInsert, (HWND handParent, HWND hLB, int nItem), (handParent, hLB, nItem), 15);
STUB_COMCTL32_ORD(int, LBItemFromPt, (HWND hLB, POINT pt, BOOL bAutoScroll), (hLB, pt, bAutoScroll), 14, -1);

static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageW)(LPCPROPSHEETPAGEW a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1;

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageW (LPCPROPSHEETPAGEW a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageW == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageW, "CreatePropertySheetPageW");
        if (_pfnCreatePropertySheetPageW)
        {
            ret = _pfnCreatePropertySheetPageW(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

HPROPSHEETPAGE __stdcall CreatePropertySheetPageW (LPCPROPSHEETPAGEW a)
{
    static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageW)(LPCPROPSHEETPAGEW a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1;
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageW == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageW, "CreatePropertySheetPageW");
        if (_pfnCreatePropertySheetPageW)
        {
            // only apply the new info if the size is correct
            if (a->dwSize > PROPSHEETPAGE_V2_SIZE)
            {
                LPPROPSHEETPAGEW ps = (LPPROPSHEETPAGEW)a;
                ps->dwFlags |= PSP_USEFUSIONCONTEXT;
                ps->hActCtx = g_hActCtx;
            }

            ret = _pfnCreatePropertySheetPageW(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageA)(LPCPROPSHEETPAGEA a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1;

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageA (LPCPROPSHEETPAGEA a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageA == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageA, "CreatePropertySheetPageA");
        if (_pfnCreatePropertySheetPageA)
        {
            ret = _pfnCreatePropertySheetPageA(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

HPROPSHEETPAGE __stdcall CreatePropertySheetPageA (LPCPROPSHEETPAGEA a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageA == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageA, "CreatePropertySheetPageA");
        if (_pfnCreatePropertySheetPageA)
        {
            // only apply the new info if the size is correct
            if (a->dwSize > PROPSHEETPAGE_V2_SIZE)
            {
                LPPROPSHEETPAGEA ps = (LPPROPSHEETPAGEA)a;
                ps->dwFlags |= PSP_USEFUSIONCONTEXT;
                ps->hActCtx = g_hActCtx;
            }

            ret = _pfnCreatePropertySheetPageA(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }

    return ret;
}

INT_PTR __stdcall PropertySheetA (LPCPROPSHEETHEADERA a)
{
    static INT_PTR (__stdcall *_pfnPropertySheetA)(LPCPROPSHEETHEADERA a) = (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERA))-1;
    ULONG_PTR dwCookie = -1;
    INT_PTR ret = 0;
    if (_pfnPropertySheetA == (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERA))-1)
         _GetProcFromComCtl32((FARPROC*)&_pfnPropertySheetA, "PropertySheetA");
    if (_pfnPropertySheetA)
    {
        NT5_ActivateActCtx(NULL, &dwCookie);
        __try
        {
            ret = _pfnPropertySheetA(a);
        }
        __finally
        {
            NT5_DeactivateActCtx(dwCookie);
        }
    }

    return ret;
}

INT_PTR __stdcall PropertySheetW (LPCPROPSHEETHEADERW a)
{
    static INT_PTR (__stdcall *_pfnPropertySheetW)(LPCPROPSHEETHEADERW a) = (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERW))-1;
    ULONG_PTR dwCookie = -1;
    INT_PTR ret = 0;
    if (_pfnPropertySheetW == (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERW))-1)
         _GetProcFromComCtl32((FARPROC*)&_pfnPropertySheetW, "PropertySheetW");
    if (_pfnPropertySheetW)
    {
        NT5_ActivateActCtx(NULL, &dwCookie);
        __try
        {
            ret = _pfnPropertySheetW(a);
        }
        __finally
        {
            NT5_DeactivateActCtx(dwCookie);
        }
    }

    return ret;
}




// Macro for comdlg wrappers
#define DELAY_LOAD_COMDLG_NAME_ERR(_ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    ULONG_PTR dwCookie = 0; \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _ret ret = _err; \
    _GetProcFromComDlg((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
{ \
        SHActivateContext(&dwCookie); \
        __try \
        { \
            ret = _pfn##_fn _nargs;  \
        } \
        __finally \
        { \
        SHDeactivateContext(dwCookie); \
        } \
} \
    return (_ret)ret;           \
}



DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetOpenFileNameW, "GetOpenFileNameW", (LPOPENFILENAMEW lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetOpenFileNameA, "GetOpenFileNameA", (LPOPENFILENAMEA lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetSaveFileNameW, "GetSaveFileNameW", (LPOPENFILENAMEW lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetSaveFileNameA, "GetSaveFileNameA", (LPOPENFILENAMEA lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseColorW    , "ChooseColorW",     (LPCHOOSECOLORW lpcc),   (lpcc),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseColorA    , "ChooseColorA",     (LPCHOOSECOLORA lpcc),   (lpcc),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseFontW     , "ChooseFontW",      (LPCHOOSEFONTW lpcf),    (lpcf),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseFontA     , "ChooseFontA",      (LPCHOOSEFONTA lpcf),    (lpcf),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(DWORD,CommDlgExtendedError, "CommDlgExtendedError", (void),          (),      CDERR_INITIALIZATION)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, FindTextW,        "FindTextW",        (LPFINDREPLACEW lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, FindTextA,        "FindTextA",        (LPFINDREPLACEA lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(short,GetFileTitleW,    "GetFileTitleW",    (LPCWSTR lpszFile, LPWSTR lpszTitle, WORD cbBuf), (lpszFile, lpszTitle, cbBuf), (-1))
DELAY_LOAD_COMDLG_NAME_ERR(short,GetFileTitleA,    "GetFileTitleA",    (LPCSTR lpszFile, LPSTR lpszTitle, WORD cbBuf), (lpszFile, lpszTitle, cbBuf), (-1))
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PageSetupDlgW,    "PageSetupDlgW",    (LPPAGESETUPDLGW lppsd), (lppsd), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PageSetupDlgA,    "PageSetupDlgA",    (LPPAGESETUPDLGA lppsd), (lppsd), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PrintDlgW,        "PrintDlgW",        (LPPRINTDLGW     lppd),  (lppd),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PrintDlgA,        "PrintDlgA",        (LPPRINTDLGA     lppd),  (lppd),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(HRESULT,PrintDlgExW,    "PrintDlgExW",      (LPPRINTDLGEXW   lppd),  (lppd),  E_FAIL)
DELAY_LOAD_COMDLG_NAME_ERR(HRESULT,PrintDlgExA,    "PrintDlgExA",      (LPPRINTDLGEXA   lppd),  (lppd),  E_FAIL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, ReplaceTextW,     "ReplaceTextW",     (LPFINDREPLACEW lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, ReplaceTextA,     "ReplaceTextA",     (LPFINDREPLACEA lpfr),   (lpfr),  NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shguid\makefile.inc ===
$(CCSHELL_DIR)\lib\$O\shguid.lib: $(O)\shguid.obj
    lib -out:$@ $**

$(CCSHELL_DIR)\lib\$O\shguidp.lib: $(O)\shguidp.obj
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shguid\shguidp.c ===
#include <initguid.h>

#include <shlguidp.h>
#include <shguidp.h>
#include <shdguid.h>
#include <sfview.h>
#include <dvocx.h>
#include <msluguid.h>
#include <adoid.h>
#include "theme_i.c"
#include "shpriv_i.c"
#include "shimgvw_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shfusion\shfusion.c ===
#include "stock.h"
#pragma hdrstop

#define SHFUSION_IMPL
#include "shfusion.h"
#include "delaycc.h"

#ifdef FUSION_DOWNLEVEL
#include <w95wraps.h>
#endif

typedef BOOL (__stdcall *PFNACTCTX)(HANDLE, ULONG_PTR *);
typedef BOOL (__stdcall *PFNDEACTCTX)(DWORD, ULONG_PTR );
typedef HANDLE (__stdcall *PFNCREATECTX)(ACTCTX*);
typedef void (__stdcall *PFNRELCTX)(HANDLE);
typedef void (__stdcall *PFNGSWD)(PTSTR psz, int cch);
HMODULE g_hmodKernel = NULL;
static PFNACTCTX s_pfnAct = (PFNACTCTX)-1;
static PFNDEACTCTX s_pfnDeact = (PFNDEACTCTX)-1;
static PFNCREATECTX s_pfnCreateact = (PFNCREATECTX)-1;
static PFNRELCTX s_pfnReleaseact = (PFNRELCTX)-1;
static PFNGSWD s_pfnGetSysWinDir = (PFNGSWD)-1;

HANDLE NT5_CreateActCtx(ACTCTX* p)
{
    if (s_pfnCreateact == (PFNCREATECTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
#ifdef _UNICODE
            s_pfnCreateact = (PFNCREATECTX)GetProcAddress(g_hmodKernel, "CreateActCtxW");
#else
            s_pfnCreateact = (PFNCREATECTX)GetProcAddress(g_hmodKernel, "CreateActCtxA");
#endif // _UNICODE

        }
        else
            s_pfnCreateact = NULL;
    }

    if (s_pfnCreateact)
        return s_pfnCreateact(p);

    return NULL;
}

void NT5_ReleaseActCtx(HANDLE h)
{
    if (s_pfnReleaseact == (PFNRELCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnReleaseact = (PFNRELCTX)GetProcAddress(g_hmodKernel, "ReleaseActCtx");
        }
        else
            s_pfnReleaseact = NULL;

    }

    if (s_pfnReleaseact)
        s_pfnReleaseact(h);
}

BOOL NT5_ActivateActCtx(HANDLE h, ULONG_PTR* p)
{
    if (s_pfnAct == (PFNACTCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnAct = (PFNACTCTX)GetProcAddress(g_hmodKernel, "ActivateActCtx");
        }
        else
        {
            s_pfnAct = NULL;
        }
    }
    *p = 0;

    if (s_pfnAct)
    {
        return s_pfnAct(h, p);
    }

    return TRUE;
}

BOOL NT5_DeactivateActCtx(ULONG_PTR p)
{
    if (s_pfnDeact == (PFNDEACTCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnDeact = (PFNDEACTCTX)GetProcAddress(g_hmodKernel, "DeactivateActCtx");
        }
        else
            s_pfnDeact = NULL;
    }

    if (s_pfnDeact)
        return s_pfnDeact(0, p);

    return TRUE;
}

BOOL SHActivateContext(ULONG_PTR* pulCookie)
{
    *pulCookie = 0;

    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        return NT5_ActivateActCtx(g_hActCtx, pulCookie);
    }

    // Default to success in activation for down level.
    return TRUE;
}

void SHDeactivateContext(ULONG_PTR ulCookie)
{
    if (ulCookie != 0)
    {
        NT5_DeactivateActCtx(ulCookie);
    }
}

#define ENTERCONTEXT(fail) \
    ULONG_PTR ulCookie = 0;\
    if (!SHActivateContext(&ulCookie)) \
        return fail;\
    __try {

#define LEAVECONTEXT \
    } __finally {SHDeactivateContext(ulCookie);}


EXTERN_C HINSTANCE g_hinst;
HANDLE g_hActCtx = INVALID_HANDLE_VALUE;

void NT5_GetSystemWindowsDirectory(PTSTR psz, int cch)
{
    if (s_pfnGetSysWinDir == (PFNGSWD)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
#ifdef _UNICODE
            s_pfnGetSysWinDir = (PFNGSWD)GetProcAddress(g_hmodKernel, "GetSystemWindowsDirectoryW");
#else
            s_pfnGetSysWinDir = (PFNGSWD)GetProcAddress(g_hmodKernel, "GetSystemWindowsDirectoryA");
#endif // _UNICODE
        }
        else
            s_pfnGetSysWinDir = NULL;
    }

    if (s_pfnGetSysWinDir)
        s_pfnGetSysWinDir(psz, cch);
    else
        GetWindowsDirectory(psz, cch);
}

void SHGetManifest(PTSTR pszManifest, int cch)
{
    NT5_GetSystemWindowsDirectory(pszManifest, cch);

    // Tack WindowsShell.Manifest

    StrCat(pszManifest, TEXT("\\WindowsShell.Manifest"));
}

BOOL SHFusionInitializeID(PTSTR pszPath, int id)
{
    TCHAR szPath[MAX_PATH];
    ACTCTX act = {0};

    if (pszPath == NULL)
    {
        SHGetManifest(szPath, ARRAYSIZE(szPath));
        pszPath = szPath;
    }
    else
    {
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpResourceName = MAKEINTRESOURCE(id);
    }

    if (g_hActCtx == INVALID_HANDLE_VALUE)
    {
        act.cbSize = sizeof(act);
        act.lpSource = pszPath;


        g_hActCtx = NT5_CreateActCtx(&act);
    }

#ifndef NOCOMCTL32
    DelayLoadCC();
#endif

    return g_hActCtx != INVALID_HANDLE_VALUE;
}

BOOL SHFusionInitialize(PTSTR pszPath)
{
    return SHFusionInitializeID(pszPath, 123);
}

BOOL SHFusionInitializeFromModuleID(HMODULE hMod, int id)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitializeID(szPath, id);
}


BOOL SHFusionInitializeFromModule(HMODULE hMod)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitialize(szPath);
}

void SHFusionUninitialize()
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        NT5_ReleaseActCtx(g_hActCtx);
        g_hActCtx = INVALID_HANDLE_VALUE;
    }
}


HMODULE SHFusionLoadLibrary(LPCTSTR lpLibFileName)
{
    HMODULE hmod;
    ENTERCONTEXT(NULL)
    hmod = LoadLibrary(lpLibFileName);
    LEAVECONTEXT

    return hmod;
}

HWND SHFusionCreateWindow(LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle,
                          int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                          HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    hwnd = CreateWindow(lpClassName, lpWindowName, dwStyle,
                      x, y, nWidth, nHeight, hWndParent, 
                      hMenu, hInstance, lpParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, 
                            DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                            HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    hwnd = CreateWindowEx(dwExStyle, lpClassName, lpWindowName, 
                            dwStyle, x, y, nWidth, nHeight, hWndParent, 
                            hMenu, hInstance, lpParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHNoFusionCreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, 
                            DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                            HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    // DO NOT ACTIVATE A MANIFEST.
    HWND hwnd = CreateWindowEx(dwExStyle, lpClassName, lpWindowName, 
                            dwStyle, x, y, nWidth, nHeight, hWndParent, 
                            hMenu, hInstance, lpParam);
    return hwnd;
}


HWND SHFusionCreateDialogIndirect(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, 
                                  HWND hWndParent, DLGPROC lpDialogFunc)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    hwnd = CreateDialogIndirect(hInstance, lpTemplate, hWndParent, lpDialogFunc);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateDialogParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    hwnd = CreateDialogParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateDialogIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, 
                                       DLGPROC lpDialogFunc, LPARAM lParamInit)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    hwnd = CreateDialogIndirectParam(hInstance, lpTemplate, hWndParent, 
                                       lpDialogFunc, lParamInit);
    LEAVECONTEXT
    return hwnd;
}

HWND SHNoFusionCreateDialogIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, 
                                       DLGPROC lpDialogFunc, LPARAM lParamInit)
{
    HWND hwnd;
    hwnd = CreateDialogIndirectParam(hInstance, lpTemplate, hWndParent, 
                                       lpDialogFunc, lParamInit);
    return hwnd;
}

INT_PTR SHFusionDialogBoxIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE hDialogTemplate, HWND hWndParent, 
                                            DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    INT_PTR i;
    ENTERCONTEXT(0)
    i = DialogBoxIndirectParam(hInstance, hDialogTemplate, hWndParent, 
                                            lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return i;

}

INT_PTR SHFusionDialogBoxParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, 
                               DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    INT_PTR i;
    ENTERCONTEXT(0)
    i = DialogBoxParam(hInstance, lpTemplateName, hWndParent, 
                                       lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return i;
}

ATOM SHFusionRegisterClass(CONST WNDCLASS *lpWndClass)
{
    ATOM a;
    ENTERCONTEXT(0)
    a = RegisterClass(lpWndClass);
    LEAVECONTEXT
    return a;
}
 
ATOM SHFusionRegisterClassEx(CONST WNDCLASSEX *lpwcx)
{
    ATOM a;
    ENTERCONTEXT(0)
    a = RegisterClassEx(lpwcx);
    LEAVECONTEXT
    return a;
}

BOOL SHFusionGetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass)
{
    BOOL f;
    ENTERCONTEXT(FALSE)
    f = GetClassInfo(hInstance, lpClassName, lpWndClass);
    LEAVECONTEXT
    return f;
}

BOOL SHFusionGetClassInfoEx(HINSTANCE hinst, LPCTSTR lpszClass, LPWNDCLASSEX lpwcx)
{
    BOOL f;
    ENTERCONTEXT(FALSE)
    f = GetClassInfoEx(hinst, lpszClass, lpwcx);
    LEAVECONTEXT
    return f;
}

STDAPI SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    char szManifest[2048];  // Comctl32 has a long manifest.

    if (LoadStringA(hInst, uIdManifest, szManifest, ARRAYSIZE(szManifest)))
    {
        HANDLE hFile;

        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        
        hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dw = lstrlenA(szManifest) * sizeof(char);
            if (WriteFile(hFile, szManifest, dw, &dw, NULL))
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            CloseHandle(hFile);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\shguid\shguid.c ===
#define INITGUID
#include <initguid.h>

#define GUID_DEFS_ONLY
#include <shlguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stock4\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stock\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\stockthk\rtlmir.cpp ===
/****************************** Module*Header *****************************\
* Module Name: rtlmir.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines which are used across the whole IShell project. It abstracts    *
* platform-support routines of RTL mirroring (NT5 and Memphis) and removes *
* linkage depedenency with the Mirroring APIs.                             *
*                                                                          *
* Functions prefixed with Mirror, deal with the new Mirroring APIs         *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "..\stock.h"

#if (WINVER < 0x0500)
#error WINVER setting must be >= 0x0500
#endif

#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

const DWORD dwNoMirrorBitmap = NOMIRRORBITMAP;
const DWORD dwExStyleRTLMirrorWnd = WS_EX_LAYOUTRTL;
const DWORD dwExStyleNoInheritLayout = WS_EX_NOINHERITLAYOUT; 
const DWORD dwPreserveBitmap = LAYOUT_BITMAPORIENTATIONPRESERVED;

/*
 * Remove linkage dependecy for the RTL mirroring APIs, by retreiving
 * their addresses at runtime.
 */
typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout
typedef BOOL  (WINAPI *PFNSETPROCESSDEFLAYOUT)(DWORD);       // user32!SetProcessDefaultLayout
typedef BOOL  (WINAPI *PFNGETPROCESSDEFLAYOUT)(DWORD*);      // user32!GetProcessDefaultLayout
typedef LANGID (WINAPI *PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage
typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR); // kernel32!EnumUILanguages

typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

#ifdef UNICODE
#define ConvertHexStringToInt ConvertHexStringToIntW
#else
#define ConvertHexStringToInt ConvertHexStringToIntA
#endif


/***************************************************************************\
* ConvertHexStringToIntA
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToIntA( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}


/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/

BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static TRIBIT s_tbBiDi = TRIBIT_UNDEFINED;
    static LANGID s_langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (s_tbBiDi == TRIBIT_UNDEFINED)
    {
        BOOL bRet = FALSE;
        if(staticIsOS(OS_WIN2000ORGREATER))
        {
            /*
             * Need to use NT5 detection method (Multiligual UI ID)
             */
            s_langID = Mirror_GetUserDefaultUILanguage();

            if(s_langID)
            {
                WCHAR wchLCIDFontSignature[16];
                iLCID = MAKELCID(s_langID, SORT_DEFAULT );

                /*
                 * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
                 * convert to decimal value and call GetLocaleInfo afterwards.
                 * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
                 */

                if( GetLocaleInfoW( iLCID , 
                                    LOCALE_FONTSIGNATURE , 
                                    (WCHAR *) &wchLCIDFontSignature[0] ,
                                    (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
                {
          
                    /* Let's verify the bits we have a BiDi UI locale */
                    if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(s_langID) )
                    {
                        bRet = TRUE;
                    }
                }
            }
        } else {

            /*
             * Check if BiDi-Memphis is running with Lozalized Resources (
             * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
             */
            if( (staticIsOS(OS_WIN98ORGREATER)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
            {
                HKEY          hKey;

                if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                                   "Control Panel\\Desktop\\ResourceLocale" , 
                                   0, 
                                   KEY_READ, &hKey) == ERROR_SUCCESS) 
                {
                    CHAR szResourceLocale[12];
                    DWORD dwSize = sizeof(szResourceLocale);
                    RegQueryValueExA( hKey , "" , 0 , NULL, (LPBYTE)szResourceLocale , &dwSize );
                    szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                    RegCloseKey(hKey);

                    if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                    {
                        iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                        if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                        {
                            bRet = TRUE;
                            s_langID = LANGIDFROMLCID(iLCID);
                        }
                    }
                }
            }
        }

        COMPILETIME_ASSERT(sizeof(s_tbBiDi) == sizeof(long));
        //  close multiproc race on startup
        InterlockedExchange((long*)&s_tbBiDi, bRet ? TRIBIT_TRUE : TRIBIT_FALSE);
    }

    if (s_tbBiDi == TRIBIT_TRUE && pLangID)
    {
        *pLangID = s_langID;
    }
    
    return (s_tbBiDi == TRIBIT_TRUE);
}

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}

/***************************************************************************\
* IsBiDiLocalizedWin95
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) Win95.
* Needed for legacy operating system check for needed RTL UI elements
* For example, DefView ListView, TreeView,...etc 
* History:
* 12-June-1998 a-msadek    Created
\***************************************************************************/
BOOL IsBiDiLocalizedWin95(BOOL bArabicOnly)
{
    HKEY  hKey;
    DWORD dwType;
    BOOL  bRet = FALSE;
    CHAR  szResourceLocale[12];
    DWORD dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int   iLCID=0L;

         /*
         * Check if BiDi-Win95 is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if( (staticIsOS(OS_WIN95ORGREATER)) && (!staticIsOS(OS_WIN98ORGREATER)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    //
                    //If bArabicOnly we will return true if it a Arabic Win95 localized. 
                    //
                    if( (LANG_ARABIC == iLCID) || ((LANG_HEBREW == iLCID) && !bArabicOnly ))
                    {
                        bRet = TRUE;
                    }
                }
            }
        }
    
    return bRet;
}

/***************************************************************************\
* Mirror_IsEnabledOS
*
* returns TRUE if the mirroring APIs are enabled on the current OS.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsEnabledOS( void )
{
    BOOL bRet = FALSE;

    if(staticIsOS(OS_WIN2000ORGREATER))
    {
        bRet = TRUE;
    } else if( staticIsOS(OS_WIN98ORGREATER) && GetSystemMetrics(SM_MIDEASTENABLED)) {
        bRet=TRUE;
    }

    return bRet;
}


/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToInt(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************\
* Mirror_IsWindowMirroredRTL
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsWindowMirroredRTL( HWND hWnd )
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}




/***************************************************************************\
* Mirror_GetLayout
*
* returns TRUE if the hdc is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_IsDCMirroredRTL( HDC hdc )
{
    return (Mirror_GetLayout( hdc ) & LAYOUT_RTL);
}



/***************************************************************************\
* Mirror_SetLayout
*
* RTL Mirror the hdc
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

DWORD Mirror_MirrorDC( HDC hdc )
{
    return Mirror_SetLayout( hdc , LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_SetProcessDefaultLayout
*
* Set the process-default layout.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_SetProcessDefaultLayout( DWORD dwDefaultLayout )
{
    BOOL bRet=0;
    static PFNSETPROCESSDEFLAYOUT pfnSetProcessDefLayout=NULL;

    if( NULL == pfnSetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnSetProcessDefLayout = (PFNSETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "SetProcessDefaultLayout");
    }

    if( pfnSetProcessDefLayout )
        bRet = pfnSetProcessDefLayout( dwDefaultLayout );

    return bRet;
}

BOOL Mirror_MirrorProcessRTL( void )
{
    return Mirror_SetProcessDefaultLayout( LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_GetProcessDefaultLayout
*
* Get the process-default layout.
*
* History:
* 26-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout )
{
    BOOL bRet=0;
    static PFNGETPROCESSDEFLAYOUT pfnGetProcessDefLayout=NULL;

    if( NULL == pfnGetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnGetProcessDefLayout = (PFNGETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "GetProcessDefaultLayout");
    }

    if( pfnGetProcessDefLayout )
        bRet = pfnGetProcessDefLayout( pdwDefaultLayout );

    return bRet;
}

BOOL Mirror_IsProcessRTL( void )
{
    DWORD dwDefLayout=0;

    return (Mirror_GetProcessDefaultLayout(&dwDefLayout) && (dwDefLayout&LAYOUT_RTL));
}

////////////////////////////////////////////////////////////////////////////
// Skip_IDorString
//
// Skips string (or ID) and returns the next aligned WORD.
////////////////////////////////////////////////////////////////////////////
PBYTE Skip_IDorString(LPBYTE pb)
{
    LPWORD pw = (LPWORD)pb;

    if (*pw == 0xFFFF)
        return (LPBYTE)(pw + 2);

    while (*pw++ != 0)
        ;

    return (LPBYTE)pw;
}

////////////////////////////////////////////////////////////////////////////
// Skip_DialogHeader
//
// Skips the dialog header and returns the next aligned WORD. 
////////////////////////////////////////////////////////////////////////////
PBYTE Skip_DialogHeader(LPDLGTEMPLATE pdt)
{
    LPBYTE pb;

    pb = (LPBYTE)(pdt + 1);

    // If there is a menu ordinal, add 4 bytes skip it. Otherwise it is a string or just a 0.
    pb = Skip_IDorString(pb);

    // Skip window class and window text, adjust to next word boundary.
    pb = Skip_IDorString(pb);    // class
    pb = Skip_IDorString(pb);    // window text

    // Skip font type, size and name, adjust to next dword boundary.
    if (pdt->style & DS_SETFONT)
    {
        pb += sizeof(WORD);
        pb = Skip_IDorString(pb);
    }
    pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);    // DWORD align

    return pb;
}

////////////////////////////////////////////////////////////////////////////
// EditBiDiDLGTemplate
//
// Edits a dialog template for BiDi stuff.
// Optionally, skipping some controls.
// Works only with DLGTEMPLATE.
////////////////////////////////////////////////////////////////////////////
void EditBiDiDLGTemplate(LPDLGTEMPLATE pdt, DWORD dwFlags, PWORD pwIgnoreList, int cIgnore)
{
    LPBYTE pb;
    UINT cItems;

    if (!pdt)
        return;
    // we should never get an extended template
    ASSERT (((LPDLGTEMPLATEEX)pdt)->wSignature != 0xFFFF);
    
    if(dwFlags & EBDT_NOMIRROR)
    {
        // Turn off the mirroring styles for the dialog.
        pdt->dwExtendedStyle &= ~(WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
    }
    cItems = pdt->cdit;

    // skip DLGTEMPLATE part
    pb = Skip_DialogHeader(pdt);

    while (cItems--)
    {
        UINT cbCreateParams;
        int i = 0;
        BOOL bIgnore = FALSE;

        if(pwIgnoreList && cIgnore)
        {
            for(i = 0;i < cIgnore; i++)
            {
                if((((LPDLGITEMTEMPLATE)pb)->id == *(pwIgnoreList +i)))
                {
                    bIgnore = TRUE;
                }
            }
        }
        
        if((dwFlags & EBDT_NOMIRROR) && !bIgnore)
        {
            // Turn off the mirroring styles for this item.
            ((LPDLGITEMTEMPLATE)pb)->dwExtendedStyle &= ~(WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT); 
        }    

        if((dwFlags & EBDT_FLIP) && !bIgnore)
        {
            ((LPDLGITEMTEMPLATE)pb)->x = pdt->cx - (((LPDLGITEMTEMPLATE)pb)->x + ((LPDLGITEMTEMPLATE)pb)->cx);
            // BUGBUG: Should we force RTL reading order for title as well ?
            // The client has the option of doining this already by PSH_RTLREADING
        }
        pb += sizeof(DLGITEMTEMPLATE);

        // Skip the dialog control class name.
        pb = Skip_IDorString(pb);

        // Look at window text now.
        pb = Skip_IDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        // skip any CreateParams which include the generated size WORD.
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        // Point at the next dialog item. (DWORD aligned)
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);

        bIgnore = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\xml\makefile.inc ===
#
# Copy xml.lib to shell\lib\$(O)
#
$(PROJECT_ROOT)\lib\$(O)\xml.lib: $(O)\xml.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\accessid.h ===
#define	 HELPID_SAVE_TO_WIN_INI     523
#define	 HELPID_EXIT				524
#define	 HELPID_ABOUT			    525
#define	 HELPID_HELP				526
#define  HELPID_SAVE_DEFAULT                    527


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\access.c ===
/****************************************************************************

    PROGRAM:    Access.c

    PURPOSE:    Provide Access for individuals with physical impairments

    FUNCTIONS:

    WinMain()         - calls initialization function, processes message loop
    AccessWndProc()   - processes messages
    About()           - processes messages for "About" dialog box

    COMMENTS:

    Windows can have several copies of your application running at the
    same time.  The variable hInst keeps track of which instance this
    application is so that processing will be to the correct window.

    You only need to initialize the application once.  After it is
    initialized, all other copies of the application will use the same
    window class, and do not need to be separately initialized.

****************************************************************************/

#include "windows.h"              /* required for all Windows applications */
#include "Access.h"               /* specific to this program */
#include "Menu.h"
#include "accessid.h"
#include "dialogs.h"
#include <string.h>

int    testnumber = 10;
char   lpReturn[11];
int    monitor_type = 0;
int    string_result = 1;

extern HWND    FilterhWnd;     /* from Dialogs.c */
extern HWND    StickyhWnd;
extern HWND    MousehWnd;
extern HWND    TogglehWnd;
extern HWND    SerialhWnd;
extern HWND    TimeOuthWnd;
extern HWND    ShowSoundshWnd;
extern HWND    SoundSentryhWnd;
extern BOOL    userpainthidden;
extern HBRUSH  hBrush;

HMENU hmenuaccess,hmenusubaccess1;
WORD  wpopupmenu1 = FALSE;
WORD  wpopuptemp = FALSE;

HANDLE  hInst;                                /* current instance */
BOOL    bmessage = TRUE;
HOOKPROC lpfnNewDialogHook = NULL;
HHOOK	lpfnOldDialogHook = NULL;
BOOL    bHelp = FALSE;                        /* Help mode flag; TRUE = "ON" */
int     iCN,iBR,iCCN,iCBR;
BOOL    bCO;
int     iPlatform;

char    szHelpFileName[EXE_NAME_MAX_SIZE+1];     /* Help file name */


/****************************************************************************/

short OkAccessMessage (HWND hWnd, WORD wnumber)

{
    int  ianswer;
    char sreadbuf[255];
    char sbuffer[45];
    {

    LoadString (hInst,wnumber,(LPSTR)sreadbuf,245);
    LoadString (hInst,IDS_TITLE,(LPSTR)sbuffer,35);
    if (bmessage)
       ianswer = MessageBox (hWnd, (LPSTR)sreadbuf,(LPSTR)sbuffer, MB_YESNO|MB_ICONHAND);
    else
       ianswer = MessageBox (hWnd, (LPSTR)sreadbuf,(LPSTR)sbuffer, MB_OK|MB_ICONHAND);
    }

	return ((short)ianswer);
}

short AccessMessageBox (HWND hWnd, WORD wnumber, UINT iFlags )

{
    int  ianswer;
    char sreadbuf[255];
    char sbuffer[45];
    {

    LoadString (hInst,wnumber,(LPSTR)sreadbuf,245);
    LoadString (hInst,IDS_TITLE,(LPSTR)sbuffer,35);
    ianswer = MessageBox (hWnd, (LPSTR)sreadbuf,(LPSTR)sbuffer, iFlags|MB_ICONHAND);
    }

	return ((short)ianswer);
}

void OkAccessMsg( HWND hWnd, WORD wMsg,...)
    {
    char szBuffer[256];
    char szFormat[256];
    char szTitle[48];
    va_list vaList;

    LoadString (hInst,IDS_TITLE,(LPSTR)szTitle,sizeof szTitle);
    LoadString (hInst,wMsg,(LPSTR)szFormat,sizeof szFormat);
    //
    // Use va_start, va_end to manage vaList
    //
    va_start(vaList, wMsg);
    wvsprintf( szBuffer, szFormat, vaList );
    va_end(vaList);

    MessageBox( hWnd, (LPSTR)szBuffer, (LPSTR)szTitle, MB_OK );
    }

/*************************************************************************

    FUNCTION:    WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:    processes message loop

    COMMENTS:

    This will initialize the window class if it is the first time this
    application is run.  It then creates the window, and processes the
    message loop until a PostQuitMessage is received.  It exits the
    application by returning the value passed by the PostQuitMessage.

****************************************************************************/

int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
HINSTANCE hInstance;                            /* current instance */
HINSTANCE hPrevInstance;                        /* previous instance */
LPSTR lpCmdLine;                                /* command line */
int nCmdShow;                                   /* show-window type (open/icon)    */

{
    static    char szAppName[] = "Access";
    static    char szAppTitle[] = "Access Utility";
    static    char szAppMenu[] = "ACCESSMENU";

    HWND hWnd;                                  /* window handle */
    MSG msg;                                    /* message */
    WNDCLASS    wc;

    DWORD dwOS;
    WORD wWinVer;
    BOOL fNT;

    // abort if running on WinNT versions < 3.5 or > 3.99
    dwOS = GetVersion();
    fNT = (HIWORD(dwOS) & 0x8000) == 0;
    wWinVer = LOWORD(GetVersion());
    if( ( fNT && ( LOBYTE(wWinVer) != 3 || HIBYTE(wWinVer) < 0x32 ) )
        || ( !fNT && LOBYTE(wWinVer) < 4 ) )
        {
        OkFiltersMessage (NULL,IDS_BAD_OS_VER);
        return (FALSE);
        }

    // The following test is good only for Win16 but harmless under Win32
    if (hPrevInstance)                          /* Has application been initialized? */
        return (FALSE);                         /*  yes, don't start again */

    // The following test is good only for Win32
    hWnd = FindWindow( szAppName, szAppTitle ); /* If another copy of us is running */
    if( hWnd != NULL )
        {
        SetForegroundWindow( hWnd );            /* Bring IT to the foreground */
        return (FALSE);                         /* and exit ourselves */
        }

    wc.style            = CS_HREDRAW | CS_VREDRAW ;
    wc.lpfnWndProc      = AccessWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hInstance, (LPSTR) "icon");
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
   //    wc.hbrBackground = COLOR_WINDOW +1 ;
    wc.lpszMenuName     = szAppMenu;
    wc.lpszClassName    = szAppName;

    RegisterClass(&wc);

    hInst = hInstance;                          /* Saves the current instance */

    hWnd = CreateWindow(szAppName,              /* window class */
        szAppTitle,                     /* window name */
        WS_OVERLAPPEDWINDOW,            /* window style */
        30,                             /* x position */
        30,                             /* y position */
        308,                            /* width */
    //  47,                             /* height */
        GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU) +
        GetSystemMetrics(SM_CYFRAME) * 2 +
        GetSystemMetrics(SM_CYBORDER) * 4,
        NULL,                           /* parent handle */
        NULL,                           /* menu or child ID */
        hInstance,                      /* instance */
        NULL);                          /* additional info */

   /* CreateWindow sends a WM_CREATE message ****************************************/


    if (!hWnd)                          /* Was the window created? */
    {
        OkAccessMsg(NULL,IDS_UNABLE_TO_START);
        return (0);
    }

   //    hdcWndMain = GetDC(hWnd);
   //    SetBkColor (hdcWndMain,GetSysColor(COLOR_WINDOW));
   //    SetTextColor(hdcWndMain,GetSysColor(COLOR_WINDOWTEXT));
   //    ReleaseDC(hWnd,hdcWndMain);

    ShowWindow(hWnd, nCmdShow);  /* Shows the window and send WM_SIZE message */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message */


   /*
    * UpdateWindow() call forces Windows to send WM_PAINT immediately
    * instead of taking it's time by posting a WM_PAINT message in the
    * message queue.  Windows exits to WM_PAINT message to process it
    * and returns to next instruction after UpDateWindows when it finishes.
    */

    MakeHelpPathName(szHelpFileName);

    while (GetMessage(&msg,        /* message structure */
               NULL,               /* handle of window receiving the message */
               0,                  /* lowest message to examine */
               0))                 /* highest message to examine */
    {
        TranslateMessage(&msg);    /* Translates virtual key codes */
        DispatchMessage(&msg);     /* Dispatches message to window */
    }

    return ((int)msg.wParam);      /* Returns the value from PostQuitMessage */
}

/****************************************************************************

    FUNCTION:    AccessWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:    Processes messages

    WM_COMMAND processing:

        IDM_ABOUT               - display "About" box.
        IDM_SAVE_TO_WIN_INI     - display message box before saving user parameters
        IDM_ADJUST_SERIALKEYS   - displag dialog box...
        IDM_ADJUST_TOGGLEKEYS   -
        IDM_ADJUST_STICKEYS     -
        IDM_ADJUST_FILTERKEYS   -
        IDM_ADJUST_MOUSEKEYS    -
        IDM_ADJUST_SHOWSOUNDS   -
        IDM_ADJUST_TIMEOUT      -


****************************************************************************/

LRESULT APIENTRY AccessWndProc(HWND hWnd, UINT message,
                               WPARAM wParam, LPARAM lParam)
{

    int     MessageReturn;
    DWORD   dwHelpContextId;
    extern  int        fQuestion_Save;

#ifdef NOTUSED
    lp_kybdinfoparam   = &KybdInfoParam;
    lp_mouinfoparam    = &MouInfoParam;
    lpa_passthecomvars = &passthecomvars;
#endif

    switch (message) {

    case WM_ENTERIDLE:
        if ((wParam == MSGF_MENU) && (GetKeyState(VK_F1) & 0x8000))
        {
            bHelp = TRUE;
            PostMessage(hWnd, WM_KEYDOWN, VK_RETURN, 0L);
            break;
        }
        if ((wParam == MSGF_DIALOGBOX) && (userpainthidden))
        {
            SendMessage(FilterhWnd,WM_HSCROLL,SB_LINEUP,0L);
            break;
        }

    case WM_COMMAND:
      /* Was F1 just pressed in a menu, or are we in help mode */
      /* (Shift-F1)? */

      if (bHelp)
       {
          dwHelpContextId =
              (wParam == IDM_SAVE_TO_WIN_INI)    ? (DWORD) HELPID_SAVE_TO_WIN_INI:
              (wParam == IDM_SAVE_DEFAULT)       ? (DWORD) HELPID_SAVE_DEFAULT:
              (wParam == IDM_EXIT)               ? (DWORD) HELPID_EXIT  :
              (wParam == IDM_ABOUT)              ? (DWORD) HELPID_ABOUT :
              (wParam == IDM_ADJUST_STICKEYS)    ? (DWORD) IDM_HELP_STICKYKEYS :
              (wParam == IDM_ADJUST_FILTERKEYS)  ? (DWORD) IDM_HELP_FILTERKEYS :
              (wParam == IDM_ADJUST_MOUSEKEYS)   ? (DWORD) IDM_HELP_MOUSEKEYS  :
              (wParam == IDM_ADJUST_TIMEOUT)     ? (DWORD) IDM_HELP_TIMEOUT    :
              (wParam == IDM_ADJUST_SERIALKEYS)  ? (DWORD) IDM_HELP_SERIALKEYS :
              (wParam == IDM_ADJUST_TOGGLEKEYS)  ? (DWORD) IDM_HELP_TOGGLEKEYS :
              (wParam == IDM_ADJUST_SHOWSOUNDS)  ? (DWORD) IDM_HELP_SHOWSOUNDS :
              (wParam == IDM_ADJUST_SOUNDSENTRY) ? (DWORD) IDM_HELP_SOUNDSENTRY:
                                       (DWORD) 0L;

          if (!dwHelpContextId)
           {
               bHelp = FALSE;
               OkFiltersMessage (hWnd,IDS_HELP_MESSAGE);
               return (DefWindowProc(hWnd, message, wParam, lParam));
           }

          bHelp = FALSE;
          WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
          break;
       }

       switch (wParam)
           {

           case IDM_EXIT:
               SendMessage (hWnd,WM_CLOSE,0,0L);
               return (0L);
               break;

           case IDM_HELP:
               dwHelpContextId = (DWORD) 0xFFFF ;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_START:
               dwHelpContextId = (DWORD) HELPID_HELP ;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_FILTERKEYS:
               dwHelpContextId = (DWORD) IDM_HELP_FILTERKEYS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_STICKYKEYS:
               dwHelpContextId = (DWORD) IDM_HELP_STICKYKEYS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_MOUSEKEYS:
               dwHelpContextId = (DWORD) IDM_HELP_MOUSEKEYS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_TOGGLEKEYS:
               dwHelpContextId = (DWORD) IDM_HELP_TOGGLEKEYS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_SERIALKEYS:
               dwHelpContextId = (DWORD) IDM_HELP_SERIALKEYS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_TIMEOUT:
               dwHelpContextId = (DWORD) IDM_HELP_TIMEOUT;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_SHOWSOUNDS:
               dwHelpContextId = (DWORD) IDM_HELP_SHOWSOUNDS;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_HELP_SOUNDSENTRY:
               dwHelpContextId = (DWORD) IDM_HELP_SOUNDSENTRY;
               bHelp = FALSE;
               WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
               break;

           case IDM_ABOUT:
               if( (HIWORD(GetVersion()) & 0x8000) == 0 )
                    {
                    // windows nt dialog
                    DialogBox(hInst,             /* current instance */
                        MAKEINTRESOURCE(808),    /* resource to use */
                        hWnd,                    /* parent handle */
                        About);                  /* About() instance address */
                    }
                else
                    {
                    // windows chicago dialog
                    DialogBox(hInst,             /* current instance */
                        MAKEINTRESOURCE(807),    /* resource to use */
                        hWnd,                    /* parent handle */
                        About);                  /* About() instance address */
                    }
               break;

           case IDM_SAVE_DEFAULT:
               if( fQuestion_Save == 1 )
                    {
                    MessageReturn = AccessMessageBox( hWnd, IDS_SAVE_FIRST, MB_YESNOCANCEL );
                    if( MessageReturn == IDYES )
                        {
                        SaveFeatures();
                        fQuestion_Save =0;
                        }
                    else if( MessageReturn == IDCANCEL )
                        {
                        break; // cancel the save procedure
                        }
                    else if( MessageReturn == IDNO )
                        ; // fall through to normal processing
                    else
                        ; // we should print an error message but what the heck
                    }

               MessageReturn = OkAccessMessage (hWnd,IDS_SAVE_DEFAULT);
               if (MessageReturn == IDYES )
                   {
                   DWORD iStatus;
                   iStatus = SaveDefaultSettings();
                   switch( iStatus )
                        {
                        case ERROR_SUCCESS:
                                break;
                        case ERROR_ACCESS_DENIED:
                                OkFiltersMessage (hWnd,IDS_ACCESS_DENIED);
                                break;
                    //    case ERROR_BADDB:
                    //    case ERROR_CANT_OPEN:
                    //    case ERROR_CANT_READ:
                    //    case ERROR_INVALID_PARAMETER:
                    //    case ERROR_OUT_OF_MEMORY:
                    //    case ERROR_PRIVILEGE_NOT_HELD:
                    //    case ERROR_KEY_DELETED:
                    //    case ERROR_FILE_NOT_FOUND:
                    //    case ERROR_CHILD_MUST_BE_VOLATILE:
                        default:
                                OkAccessMsg(hWnd,IDS_ERROR_CODE,iStatus);
                                break;
                        }
                   // note we don't reset fQuestion_Save so that, if we saved
                   // as default without saving locally, we will still be
                   // prompted to save for this account on exit
                   }
               break;

           case IDM_SAVE_TO_WIN_INI:
#ifdef NOSAVE
               bmessage = FALSE;
               OkAccessMessage (hWnd,IDS_SAVE_DISABLED);
               bmessage = TRUE;
               break;
#else
               MessageReturn = OkAccessMessage (hWnd,IDS_SAVE_TO_WIN_INI);

               if (MessageReturn == IDYES )
                   {
                   SaveFeatures();
                   fQuestion_Save =0;
                   }
               break;
#endif // else if not def nosave

            case IDM_ADJUST_STICKEYS:
                DialogBox(hInst,           /* current instance */
                    MAKEINTRESOURCE(800),  /* resource to use */
                    hWnd,                  /* parent handle */
                    AdjustSticKeys);       /* dialog instance address */

                break;

            case IDM_ADJUST_FILTERKEYS:
                DialogBox(hInst,           /* current instance */
                    MAKEINTRESOURCE(801),  /* resource to use */
                    hWnd,                  /* parent handle */
                    AdjustFilterKeys);     /* dialog instance address */

                break;

            case IDM_ADJUST_MOUSEKEYS:
                DialogBox(hInst,           /* current instance */
                    MAKEINTRESOURCE(802),  /* resource to use */
                    hWnd,                  /* parent handle */
                    AdjustMouseKeys);      /* dialog instance address */

                break;

           case IDM_ADJUST_SERIALKEYS:
               DialogBox(hInst,             /* current instance */
                    MAKEINTRESOURCE(803),    /* resource to use */
                    hWnd,                    /* parent handle */
                    AdjustSerialKeys);       /* dialog instance address */
                break;

           case IDM_ADJUST_TIMEOUT:
                DialogBox(hInst,           /* current instance */
                    MAKEINTRESOURCE(804),  /* resource to use */
                    hWnd,                  /* parent handle */
                    AdjustTimeOut);        /* dialog instance address */

                break;


           case IDM_ADJUST_TOGGLEKEYS:
                DialogBox(hInst,           /* current instance */
                    MAKEINTRESOURCE(805),  /* resource to use */
                    hWnd,                  /* parent handle */
                    AdjustToggleKeys);     /* dialog instance address */

                break;


           case IDM_ADJUST_SHOWSOUNDS:
                if (fShowSoundsOn) {
                    CheckMenuItem(GetMenu(hWnd), LOWORD(wParam), MF_UNCHECKED);
                    fShowSoundsOn = 0;
                } else {
                    CheckMenuItem(GetMenu(hWnd), LOWORD(wParam), MF_CHECKED);
                    fShowSoundsOn = 1;
                }
                SystemParametersInfo(
                    SPI_SETSHOWSOUNDS,
                    fShowSoundsOn,
                    0,
                    0);
                fQuestion_Save = 1;
                break;


           //
           // Full screen text and graphics modes are only available on the
           // chicago platform so we use separate dialogs.
           // also won't support them on Cairo non-x86 platforms; but right
           // now we'll just skip on any non-Chicago.
           //
           case IDM_ADJUST_SOUNDSENTRY:
               if( (HIWORD(GetVersion()) & 0x8000) == 0 )
                    {
                    // windows nt dialog
                    DialogBox(hInst,             /* current instance */
                        MAKEINTRESOURCE(809),    /* resource to use */
                        hWnd,                    /* parent handle */
                        AdjustSoundSentry);      /* dialog instance address */
                    }
                else
                    {
                    // windows chicago dialog
                    DialogBox(hInst,             /* current instance */
                        MAKEINTRESOURCE(806),    /* resource to use */
                        hWnd,                    /* parent handle */
                        AdjustSoundSentry);      /* dialog instance address */
                    }
                break;

           default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
                break;

            }

    break;


    case WM_KEYDOWN:

    /******* Decided not to support shift+F1 support, just F1 support.
             See Windows Programming Tools, p18-17 for other ideas if
             want to add some day */

         switch (wParam)
             {
             case VK_F1:

                 dwHelpContextId = (DWORD) 0xFFFF;
                 bHelp = FALSE;
                 WinHelp(hWnd,szHelpFileName,HELP_CONTEXT,dwHelpContextId);
                 break;

             default:
                 return (DefWindowProc(hWnd, message, wParam, lParam));
                 break;
             }
         return(0);

    case WM_CREATE:

      {
	  
      InitializeUserRegIfNeeded();
      if( (HIWORD(GetVersion()) & 0x8000) != 0 )
           {
           HMENU hMenu;
           // chicago -- remove the Save Default command
           hMenu = GetMenu(hWnd);
           DeleteMenu(hMenu, IDM_SAVE_DEFAULT, MF_BYCOMMAND );
           DrawMenuBar(hWnd);
           }

      if (!lpfnNewDialogHook)
         {
             DWORD dwThread;
             dwThread = GetCurrentThreadId();
             lpfnNewDialogHook = hookDialogBoxMsg;
             if (lpfnNewDialogHook)
                 lpfnOldDialogHook = SetWindowsHookEx(WH_MSGFILTER,lpfnNewDialogHook,NULL,dwThread);
         }

      InitFeatures(hWnd,hInst);

      // initialize the ShowSounds menu item correctly checked or unchecked
      if (fShowSoundsOn) {
          CheckMenuItem(GetMenu(hWnd), IDM_ADJUST_SHOWSOUNDS, MF_CHECKED);
      } else {
          CheckMenuItem(GetMenu(hWnd), IDM_ADJUST_SHOWSOUNDS, MF_UNCHECKED);
      }

///   ShowSoundsParam.fvideo_flash = FALSE;
///   Set_ShowSounds_Param(&ShowSoundsParam);

// WHAT IS THIS CODE ABOUT CHECKING FOR ALTERED MENUS ALL ABOUT???
      hmenuaccess = GetMenu(hWnd);
      hmenusubaccess1 = GetSubMenu(hmenuaccess,1);  /* &Adjust popup */
      wpopupmenu1 = (WORD)GetMenuItemCount(hmenusubaccess1);
      }


      return(0);
      break;

      case WM_QUERYENDSESSION:
      case WM_CLOSE:

         /*  Both EXIT and CLOSE get here, as selecting close from the menu
             horizontal bar will cause WM_CLOSE and exit is programmmed to
             send a WM_CLOSE also */

         // check to see if anyone appended or changed our menu but onlu if AU Windows was created??

        // WHAT IS THIS CODE ABOUT CHECKING FOR ALTERED MENUS ALL ABOUT???
         if (wpopupmenu1)
         {
            wpopuptemp = (WORD)GetMenuItemCount(hmenusubaccess1);
            if (wpopupmenu1 != -1)
               {
               if (wpopupmenu1 != wpopuptemp)
                  {
                  bmessage = FALSE;
                  MessageReturn = OkAccessMessage (hWnd,IDS_MENU_MESSAGE);
                  bmessage = TRUE;
                  return(0L);
                  }
               }
         }

         if (fQuestion_Save == 1)
            {
#ifdef NOSAVE
            bmessage = FALSE;
            OkAccessMessage (hWnd,IDS_SAVE_DISABLED);
            bmessage = TRUE;
#else
            fQuestion_Save =0;
            MessageReturn = OkAccessMessage (hWnd,IDS_CLOSE_MESSAGE);

            if (MessageReturn == IDYES )
               {
               SaveFeatures();
               }
#endif
         }


         if (message == WM_QUERYENDSESSION)
            return (TRUE);
         else
            DestroyWindow(hWnd);
         return (0L);
         break;

     case WM_DESTROY:

         WinHelp(hWnd,szHelpFileName,HELP_QUIT,0L);

         // check to see if anyone appended or changed our menu but only if AU Windows was created??

         if (wpopupmenu1)
         {
         wpopuptemp = (WORD)GetMenuItemCount(hmenusubaccess1);
         if (wpopupmenu1 != -1)
            {
            if (wpopupmenu1 != wpopuptemp)
               {
               bmessage = FALSE;
               MessageReturn = OkAccessMessage (hWnd,IDS_MENU_MESSAGE);
               bmessage = TRUE;
               return(0L);
               }
            }
         }

         if (hBrush)
            DeleteObject(hBrush);

         if (lpfnNewDialogHook)
            {
                UnhookWindowsHookEx (lpfnOldDialogHook);
                lpfnNewDialogHook = NULL;
                lpfnOldDialogHook = NULL;
            }

         PostQuitMessage(0);
         return (0);

      /* Passes it on if unproccessed */
      default:
         return (DefWindowProc(hWnd, message, wParam, lParam));
         break;

    }
    return (0);
}


/****************************************************************************

    FUNCTION:    About(HWND, unsigned, WORD, LONG)

    PURPOSE:    Processes messages for "About" dialog box

    MESSAGES:

    WM_INITDIALOG    - initialize dialog box
    WM_COMMAND       - Input received

    COMMENTS:

    No initialization is needed for this particular dialog box, but TRUE
    must be returned to Windows.

    Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY About(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)

    {

    switch (message) {
    case WM_INITDIALOG:                     /* message: initialize dialog box */
        return (TRUE);

    case WM_COMMAND:                        /* message: received a command */
        if (wParam == IDOK) {               /* "OK" box selected? */
        EndDialog(hDlg, 0);                 /* Exits the dialog box */
        return (TRUE);
        }
        break;
    }
    return (FALSE);                            /* Didn't process a message */
}

/****************************************************************************

   FUNCTION:   MakeHelpPathName

   PURPOSE:    HelpEx assumes that the .HLP help file is in the same
               directory as the HelpEx executable.  This function derives
               the full path name of the help file from the path of the
               executable.

****************************************************************************/

void MakeHelpPathName(szFileName)
char * szFileName;
{
   char *  pcFileName;
   int     nFileNameLen;
   static    char szAppHelp[8];
   DWORD dwOS;
   WORD  wWinVer;

   dwOS = GetVersion();
   /*
    * If the high bit of the high word is 1, the OS platform is either
    * Win32s or Win3.1.  If the high bit of the high word is 0, the OS
    * platform is NT.
    */
   if (HIWORD(dwOS) & 0x8000) {
       wWinVer = LOWORD(GetVersion());
       if ((LOBYTE(wWinVer) == 3) && (HIBYTE(wWinVer) == 0))
          strcpy(szAppHelp,"access30.hlp");
       else if((LOBYTE(wWinVer) == 3) && (HIBYTE(wWinVer) > 0))
          strcpy(szAppHelp,"access31.hlp");
       else if((LOBYTE(wWinVer) == 4) && (HIBYTE(wWinVer) == 0))
          strcpy(szAppHelp,"access40.hlp");
   } else {
          strcpy(szAppHelp,"access35.hlp");
   }

   nFileNameLen = GetModuleFileName(hInst,szFileName,EXE_NAME_MAX_SIZE);
   pcFileName = szFileName + nFileNameLen;

   while (pcFileName > szFileName)
      {
      if (*pcFileName == '\\' || *pcFileName == ':')
          {
          *(++pcFileName) = '\0';
          break;
          }
      nFileNameLen--;
      pcFileName--;
      }

   if ((nFileNameLen+13) < EXE_NAME_MAX_SIZE)
      {
      lstrcat(szFileName, szAppHelp);
      }
   else
      {
      lstrcat(szFileName, "?");
      }

   return;
}

/****************************************************************************

   FUNCTION:   hookDialogBoxMsg

   PURPOSE:    To hook dialog box message and watch for F1 or help request.
               This is down by processing WM_KEYDOWN and WM_KEYUP messages.

****************************************************************************/
LRESULT APIENTRY hookDialogBoxMsg(nCode,wParam,lParam)    /* Function to trap for F1 in dialog boxes */
//HOOKPROC hookDialogBoxMsg(nCode,wParam,lParam)    /* Function to trap for F1 in dialog boxes */
int    nCode;
WPARAM wParam;
LPARAM lParam;
{
    LRESULT iResult;
    static MSG FAR *msgdialog;
    HWND hWndlocal;
    WORD localcontext;

    msgdialog = (MSG FAR *) lParam;
    iResult = TRUE;
    hWndlocal = NULL;


    /* first check if message is of interest */

    if (nCode == MSGF_DIALOGBOX)
    {
        if (msgdialog->message == WM_KEYDOWN)
        {
        /*  process virtual key code   */

        switch (msgdialog->wParam)
            {
            case VK_F1:

/***************************************************************************
    The following SendMessage will work, but it requires a global variable
    called "hWndParent".  I can get the same results if I query the message
    that the Filter function caught by sending the code here by getting a
    handle to the window the message was intended for, and then getting the
    parent of that handle, and then sending the message this way.

    ex. SendMessage(hWndParent,WM_COMMAND,IDM_HELP_FILTERKEYS,0L);

    ex. hWndlocal = GetParent(GetWindowWord(msgdialog->hwnd,GWW_HWNDPARENT));

*****************************************************************************/

                hWndlocal = GetParent(GetParent(msgdialog->hwnd));

                if (GetParent(msgdialog->hwnd) == FilterhWnd)
                        localcontext = IDM_HELP_FILTERKEYS;

                else if (GetParent(msgdialog->hwnd) == StickyhWnd)
                        localcontext = IDM_HELP_STICKYKEYS;

                else if (GetParent(msgdialog->hwnd) == MousehWnd)
                        localcontext = IDM_HELP_MOUSEKEYS;

                else if (GetParent(msgdialog->hwnd) == TogglehWnd)
                        localcontext = IDM_HELP_TOGGLEKEYS;

                else if (GetParent(msgdialog->hwnd) == SerialhWnd)
                        localcontext = IDM_HELP_SERIALKEYS;

                else if (GetParent(msgdialog->hwnd) == TimeOuthWnd)
                        localcontext = IDM_HELP_TIMEOUT;

                else if (GetParent(msgdialog->hwnd) == ShowSoundshWnd)
                        localcontext = IDM_HELP_SHOWSOUNDS;

                else if (GetParent(msgdialog->hwnd) == SoundSentryhWnd)
                        localcontext = IDM_HELP_SOUNDSENTRY;

                else
                    {
                    localcontext = IDM_HELP_START;
                    }

                SendMessage(hWndlocal,WM_COMMAND,localcontext,0L);
                break;

            default:

                iResult = CallNextHookEx(lpfnOldDialogHook,nCode,wParam,lParam);
                return (iResult);
                break;

            }

        }else if (msgdialog->message != WM_KEYUP)
            {
            iResult = CallNextHookEx(lpfnOldDialogHook,nCode,wParam,lParam);
            return (iResult);
            }

    }

    iResult = CallNextHookEx(lpfnOldDialogHook,nCode,wParam,lParam);
    return (iResult);
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\dialogs.c ===
/****************************************************************************

    DIALOGS.C

    This file handles the parts related to the dialogs for adjustment

****************************************************************************/
#include "windows.h"

#include "Dialogs.h"
#include "Menu.h"
#include "skeys.h"
#include "resource.h"
#include "access.h"

// debug only in theory
void AssertBool( LPSTR sz, LPBOOL lpf );
void OkMsgBox( LPSTR szCaption, LPSTR szFormat,... );

#include <stdio.h>
#include <io.h>

/****************************************************************************

    Declaration of externs

****************************************************************************/

						    /* from ACCESS.C */
extern BOOL    OK_to_Save;
extern HANDLE  hInst;
extern int     iCN;
extern int     iBR;
extern int     iCCN;
extern int     iCBR;
extern BOOL    bCO;
extern char    lpReturn;
extern int     monitor_type;

int fQuestion_Save = ID_FLAG_1;

extern  void InitSerialKeys();

#ifdef NOTUSED
extern COMMVARS passthecomvars;
extern COMMVARS *lpa_passthecomvars;
#endif

HWND FilterhWnd;
HWND StickyhWnd;
HWND MousehWnd;
HWND TogglehWnd;
HWND SerialhWnd;
HWND TimeOuthWnd;
HWND ShowSoundshWnd;
HWND SoundSentryhWnd;

BOOL SerialKeysEnabled = FALSE;
/****************************************************************************

    Declaration of variables

****************************************************************************/

FILTERKEYS    FilterKeysParam;
STICKYKEYS    StickyKeysParam;
MOUSEKEYS     MouseKeysParam;
TOGGLEKEYS    ToggleKeysParam;
ACCESSTIMEOUT TimeOutParam;
SOUNDSENTRY   SoundSentryParam;

#ifdef MYSK
MYSERIALKEYS  MySerialKeysParam;
#else
SERIALKEYS    SerialKeysParam;
#endif

CHAR          SK_ActivePort[MAX_PATH];
INT           fShowSoundsOn;

/*
 * Sound Sentry support
 */
HWND hSSListBox;
typedef struct tagSSInfo {
    UINT idResource;
    UINT iEffectFlag;
    UINT idDialog;
    TCHAR szEffect[128];
} SSINFO, *PSSINFO;
SSINFO aSSWin[4] = {{IDS_NONE, WF_NONE, 0},
		    {IDS_SS_WINCAPTION, WF_TITLE, 0},
		    {IDS_SS_WINWINDOW, WF_WINDOW, 0},
		    {IDS_SS_WINDESKTOP, WF_DISPLAY, 0}};
#ifdef BORDERFLASH
SSINFO aSSText[3] = {{IDS_NONE, TF_NONE, 0},
		     {IDS_SS_FSBORDER, TF_BORDER, 0},
		     {IDS_SS_FSSCREEN, TF_DISPLAY, 0}};
#else
SSINFO aSSText[2] = {{IDS_NONE, TF_NONE, 0},
		     {IDS_SS_FSSCREEN, TF_DISPLAY, 0}};
#endif

#ifdef GRAPHICSMODE
SSINFO aSSGraphics[2] = {{IDS_NONE, GF_NONE, 0},
			 {IDS_SS_GRAPHICSSCREEN, GF_DISPLAY, 0}};

UINT cGraphicEffects = (sizeof(aSSGraphics) / sizeof(SSINFO));
#endif

UINT cWindowsEffects = (sizeof(aSSWin) / sizeof(SSINFO));
UINT cTextEffects = (sizeof(aSSText) / sizeof(SSINFO));

void SerialKeysRemove(HWND hDlg);
void SerialKeysInstall(HWND hDlg);
void SetDialogItems(HWND hDlg);
void SKeysError(HWND hDlg, int Error);


int  iSK_ComName;
int  iSK_BaudRate;
BOOL bSK_CommOpen;

BOOL userpainthidden;
HBRUSH hBrush =0;

//  int        OnOffTable[2] = {
//    { FALSE    },
//    { TRUE    },
//};

BYTE OnOffTable[2] = {
    { FALSE },
    { TRUE },
};


/***************************************/

//
// Times are in milliseconds
//
UINT DelayTable[4] = {
    {  700 },
    { 1000 },
    { 1500 },
    { 2000 },
};

int DelayTableConv[4] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
};

/***************************************/

//
// Times are in milliseconds
//
UINT RateTable[7] = {
    {    0 },
    {  300 },
    {  500 },
    {  700 },
    { 1000 },
    { 1500 },
    { 2000 },
};

int RateTableConv[7] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
    { 5 },
    { 6 },
    { 7 },
};

/***************************************/

//
// Times are in milliseconds
//
UINT BounceTable[6] = {
    {    0 },
    {  500 },
    {  700 },
    { 1000 },
    { 1500 },
    { 2000 },
};


int BounceTableConv[6] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
    { 5 },
    { 6 },
};


/***************************************/

//
// Times are in milliseconds
//
UINT AcceptTable[7] = {
    {    0 },
    {  300 },
    {  500 },
    {  700 },
    { 1000 },
    { 1400 },
    { 2000 },
};

int AcceptTableConv[7] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
    { 5 },
    { 6 },
    { 7 },
};

/***************************************/

//
// Times are in milliseconds
//
UINT TimeTable[9] = {
    { 5000 },
    { 4500 },
    { 4000 },
    { 3500 },
    { 3000 },
    { 2500 },
    { 2000 },
    { 1500 },
    { 1000 },
};

int TimeTableConv[9] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
    { 5 },
    { 6 },
    { 7 },
    { 8 },
    { 9 },
};


//
// Pixels per second
//
UINT SpeedTable[9] = {
    { 10  },
    { 20  },
    { 30  },
    { 40  },
    { 60  },
    { 80  },
    { 120 },
    { 180 },
    { 360 },
};

int SpeedTableConv[9] = {
    { 1 },
    { 2 },
    { 3 },
    { 4 },
    { 5 },
    { 6 },
    { 7 },
    { 8 },
    { 9 },
};


//
// Times are in milliseconds
//
DWORD TimeOutTable[4] = {
      {  300000 },   //  5 minutes
      {  600000 },   // 10 minutes
      {  900000 },   // 15 minutes
      { 1800000 },   // 30 minutes
};

/****************************************************************************/

struct AcceptText {
    char *acceptstrings;
}
AcceptTableText[]= {

{"OFF"},
{"0.3"},
{"0.5"},
{"0.7"},
{"1.0"},
{"1.4"},
{"2.0"},
};

struct    DelayText {
    char *delaystrings;
}
DelayTableText[]= {

{"0.7"},
{"1.0"},
{"1.5"},
{"2.0"},
};

struct    RateText {
    char *ratestrings;
}
RateTableText[]= {

{"OFF"},
{"0.3"},
{"0.5"},
{"0.7"},
{"1.0"},
{"1.5"},
{"2.0"},
};

struct    BounceText {
    char *bouncestrings;
}
BounceTableText[]= {

{"OFF"},
{"0.5"},
{"0.7"},
{"1.0"},
{"1.5"},
{"2.0"},
};

struct    TableText {
    char *timestrings;
}
TimeTableText[]= {

{"5.0"},
{"4.5"},
{"4.0"},
{"3.5"},
{"3.0"},
{"2.5"},
{"2.0"},
{"1.5"},
{"1.0"},
};

/****************************************************************************/
/* DEBUGGING  */
//
//void OkMsgBox (HWND hWnd, char *szCaption, char *szFormat)
//    {
//    char szBuffer[256];
//    char *pArguments;
//
//    pArguments = (char *) &szFormat + sizeof szFormat;
//    vsprintf (szBuffer, szFormat, pArguments);
//    MessageBox (hWnd, szBuffer, szCaption, MB_OK);
//    }
//
/****************************************************************************/
void OkFiltersMessage (HWND hWnd, WORD wnumber)

{
    char sreadbuf[255];
    char    sbuf[45];
    {

    LoadString (hInst,wnumber,(LPSTR)sreadbuf,245);
    LoadString (hInst,IDS_TITLE,(LPSTR)sbuf,35);
    MessageBox (hWnd, (LPSTR)sreadbuf, (LPSTR)sbuf, MB_OK|MB_ICONHAND);
    }
return;
}

/****************************************************************************

    FUNCTION:    AdjustFilterKeys(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustFilterKeys(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    int    i;
    DWORD  colorcheck,colortest;
    static int  iaccepttemp,idelaytemp,iratetemp,ibouncetemp;
    static int  iaccept,idelay,irate,ibounce;
    static BOOL userpainton,userpaintoff,userpaintoverlap;
    static BOOL fMyQuestion_Save;
    POINT point;
    HWND hFCtrl,hCtrlAcceptance,hCtrlDelay,hCtrlRate,hCtrlBounce,hCtrlKybTest;
    int hFCtrlID;
    char *lpaccepttext,*lpdelaytext,*lpratetext,*lpbouncetext;
    FILTERKEYS *lp_FilterKeys_Param;
    static FILTERKEYS SavedFilterKeysParam;    // local copy for restore on Cancel

    lp_FilterKeys_Param = &FilterKeysParam;

    switch (message) {
    case WM_COMMAND:
	switch (wParam) {

	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, (DWORD)wParam);
	    SetFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON,OnOffTable[wParam-ID_OFF]);

		if( TestFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON) )
		    {
			if ((iaccepttemp !=1) && (ibouncetemp !=1))
			    {
			    OkFiltersMessage (hDlg,IDS_FILTERS_1);
			    ibouncetemp = 1;
			    SetScrollPos(GetDlgItem(hDlg,ID_KB_BOUNCE_3),SB_CTL,ibouncetemp,TRUE);
			    for (i=0;i<6;i++) {
				if (BounceTableConv[i] == ibouncetemp) break;
				}
			    FilterKeysParam.iBounceMSec = BounceTable[i];
			    lpbouncetext = BounceTableText[i].bouncestrings;
			    SetDlgItemText(hDlg,ID_KB_BOUNCE_TEXT,(LPSTR)lpbouncetext);

			    }
		    }

	    FilterKeysParam.cbSize = sizeof(FilterKeysParam);
	    SystemParametersInfo(
		SPI_SETFILTERKEYS,
		0, // sizeof(FilterKeysParam),
		lp_FilterKeys_Param,
		0);
	    fMyQuestion_Save = 1;
	    break;

	case ID_ON_OFF_FEEDBACK:
	    SetFlag(FilterKeysParam.dwFlags,FKF_HOTKEYSOUND,IsDlgButtonChecked(hDlg, ID_ON_OFF_FEEDBACK) );
	    fMyQuestion_Save = 1;
	    break;

	case ID_ON_OFF_CLICK:
	    SetFlag(FilterKeysParam.dwFlags,FKF_CLICKON,IsDlgButtonChecked(hDlg, ID_ON_OFF_CLICK) );
	    fMyQuestion_Save = 1;
	    break;

	case ID_HOTKEY_ACTIVATION:
	    SetFlag(FilterKeysParam.dwFlags,FKF_HOTKEYACTIVE,IsDlgButtonChecked(hDlg, ID_HOTKEY_ACTIVATION) );
	    fMyQuestion_Save = 1;
	    break;

	case IDOK:
	    FilterKeysParam.cbSize = sizeof(FilterKeysParam);
	    SystemParametersInfo(
		SPI_SETFILTERKEYS,
		0, // sizeof(FilterKeysParam),
		lp_FilterKeys_Param,
		0);
	    FilterhWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg, IDOK);
	    break;

	case IDCANCEL:

	    /* Let the caller know the user cancelled */

	    // if ((iaccept != iaccepttemp)||(idelay != idelaytemp)||(irate != iratetemp)||(ibounce != ibouncetemp))
	    //     {
	    //         for (i=0;i<7;i++) {
	    //             if (AcceptTableConv[i] == iaccept) break;
	    //             }
	    //             FilterKeysParam.iWaitMSec = AcceptTable[i];
	    //
	    //         for (i=0;i<4;i++) {
	    //             if (DelayTableConv[i] == idelay) break;
	    //             }
	    //             FilterKeysParam.iDelayMSec = DelayTable[i];
	    //
	    //         for (i=0;i<7;i++) {
	    //             if (RateTableConv[i] == irate) break;
	    //             }
	    //             FilterKeysParam.iRepeatMSec = RateTable[i];
	    //
	    //         for (i=0;i<6;i++) {
	    //             if (BounceTableConv[i] == ibounce) break;
	    //             }
	    //             FilterKeysParam.iBounceMSec = BounceTable[i];
	    //     SystemParametersInfo(
	    //         SPI_SETFILTERKEYS,
	    //         sizeof(FilterKeysParam),
	    //         lp_FilterKeys_Param,
	    //         0);
	    //     }

	    SavedFilterKeysParam.cbSize = sizeof(SavedFilterKeysParam);
	    SystemParametersInfo(               /* restore original state */
		SPI_SETFILTERKEYS,
		0, // sizeof(FilterKeysParam),
		&SavedFilterKeysParam,
		0);
	    FilterKeysParam.cbSize = sizeof(FilterKeysParam);
	    SystemParametersInfo(               /* synch up internal structure */
		SPI_GETFILTERKEYS,
		0, // sizeof(FilterKeysParam),
		&FilterKeysParam,
		0);
	    FilterhWnd = NULL;
	    EndDialog(hDlg, IDCANCEL);
	    break;

	default:
	    return (FALSE);
	}
	return(TRUE);
	break;

/***************************************/

	case WM_ACTIVATEAPP:

	    if (!IsWindowEnabled(GetDlgItem(hDlg,ID_KB_DELAY_3)))
		{
		userpaintoverlap = TRUE;
		return(FALSE);
		break;
		}

/***************************************/

	case WM_CTLCOLORSCROLLBAR:

	     if (userpainton)
		    {
		    userpainton = FALSE;
		    userpaintoverlap = FALSE;

		    colorcheck = GetSysColor(COLOR_SCROLLBAR);
		    colortest = GetBkColor((HDC)wParam);
		    if ((colorcheck == colortest) && (colorcheck == RGB(255,255,255)))                // if background color == scrollbar color
												    // and both are white
			hBrush =CreateSolidBrush(RGB(80,80,80));         //solid gray brush
		    else
			hBrush =CreateSolidBrush(RGB(255,255,255));        //solid white brush

		    point.x = point.y = 0;
		    ClientToScreen (hDlg,&point);
		    UnrealizeObject (hBrush);
		    SetBrushOrgEx((HDC)wParam,point.x,point.y,(LPPOINT)NULL);
		    return((WORD) hBrush);
		    break;
		    }
	    else if (userpaintoff)
		    {
		    userpaintoff = FALSE;
		    userpaintoverlap = FALSE;
		    point.x = point.y = 0;
		    DeleteObject(hBrush);
		    ClientToScreen (hDlg,&point);
		    UnrealizeObject (hBrush);
		    SetBrushOrgEx((HDC)wParam,point.x,point.y,(LPPOINT)NULL);
		    return((WORD) CreateSolidBrush (GetSysColor(COLOR_SCROLLBAR)));
		    break;
		    }
	    else if (userpaintoverlap)
		    {
		    if (lParam == (LPARAM)GetDlgItem(
                                             hDlg,ID_KB_DELAY_3))
			{
			point.x = point.y = 0;
			ClientToScreen (GetDlgItem(hDlg,ID_KB_DELAY_3),&point);
			UnrealizeObject (hBrush);
			SetBrushOrgEx((HDC)wParam,point.x,point.y,(LPPOINT)NULL);
			userpaintoverlap = FALSE;
			return((WORD) hBrush);
			break;
			}
		    else
			{
			return(FALSE);
			break;
			}
		    }
	    else
		    {
		    return(FALSE);
		    break;
		    }

/***************************************/

	case WM_KEYDOWN:

	    switch (wParam)
		{
		case VK_PRIOR:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEUP,0L);
		    break;

		case VK_NEXT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEDOWN,0L);
		    break;

		case VK_UP:
		    SendMessage (hDlg,WM_HSCROLL,SB_LINEUP,0L);
		    break;

		case VK_DOWN:
		    SendMessage (hDlg,WM_HSCROLL,SB_LINEDOWN,0L);
		    break;

		case VK_LEFT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEUP,0L);
		    break;

		case VK_RIGHT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEDOWN,0L);
		    break;

		default:
		    return (FALSE);
		    break;

		}
	    return (TRUE);
	    break;


	case WM_HSCROLL:

	    if (userpainthidden)
		hFCtrlID = ID_KB_RATE_2;

	    else
		{
		hFCtrl = (HWND)lParam;
		hFCtrlID = GetDlgCtrlID(hFCtrl);
		}

	    if (ID_KB_ACCEPT_3 == hFCtrlID)
		{
		switch (LOWORD(wParam))
		    {
		case SB_LINEUP:
		    iaccepttemp = max (1,iaccepttemp -1);
		    break;

		case SB_LINEDOWN:
		    iaccepttemp =min (7,iaccepttemp +1);
		    break;

		case SB_PAGEUP:
		    iaccepttemp = max (1,iaccepttemp -2);
		    break;

		case SB_PAGEDOWN:
		    iaccepttemp = min (7,iaccepttemp +2);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    iaccepttemp = HIWORD (wParam);
		    break;

		default:
		    return (FALSE);
		  }


		if( TestFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON) )
		    {
			if ((iaccepttemp !=1) && (ibouncetemp !=1))
			    {
			    OkFiltersMessage (hDlg,IDS_FILTERS_2);
			    iaccepttemp = 1;
			    }
		    }

		SetScrollPos(hFCtrl,SB_CTL,iaccepttemp,TRUE);

		for (i=0;i<7;i++) {
		    if (AcceptTableConv[i] == iaccepttemp) break;
			}

		    FilterKeysParam.iWaitMSec = AcceptTable[i];
		    lpaccepttext = AcceptTableText[i].acceptstrings;

		SetDlgItemText(hDlg,ID_KB_ACCEPT_TEXT,(LPSTR)lpaccepttext);

		FilterKeysParam.cbSize = sizeof(FilterKeysParam);
		SystemParametersInfo(
		    SPI_SETFILTERKEYS,
		    0, // sizeof(FilterKeysParam),
		    lp_FilterKeys_Param,
		    0);
		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

/************************/

	      if (ID_KB_DELAY_3 == hFCtrlID)
		{
		switch (LOWORD(wParam))
		    {
		case SB_PAGEUP:
		    idelaytemp = max (1,idelaytemp-1);
		    break;

		case SB_LINEUP:
		    idelaytemp = max (1,idelaytemp-1);
		    break;

		case SB_PAGEDOWN:
		    idelaytemp = min (4,idelaytemp+1);
		    break;

		case SB_LINEDOWN:
		    idelaytemp = min (4,idelaytemp+1);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    idelaytemp = HIWORD (wParam);
		    break;
		default:
		    return (FALSE);
		  }

		SetScrollPos(hFCtrl,SB_CTL,idelaytemp,TRUE);

		    for (i=0;i<4;i++) {
			if (DelayTableConv[i] == idelaytemp) break;
			}

		    FilterKeysParam.iDelayMSec = DelayTable[i];
		    lpdelaytext = DelayTableText[i].delaystrings;

		SetDlgItemText(hDlg,ID_KB_DELAY_TEXT,(LPSTR)lpdelaytext);
		FilterKeysParam.cbSize = sizeof(FilterKeysParam);
		SystemParametersInfo(
		    SPI_SETFILTERKEYS,
		    0, // sizeof(FilterKeysParam),
		    lp_FilterKeys_Param,
		    0);
		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

/************************/

	      if (ID_KB_RATE_2 == hFCtrlID)
		{
		switch (LOWORD(wParam))
		    {
		case SB_PAGEUP:
		    iratetemp = max (1,iratetemp-2);
		    break;

		case SB_LINEUP:
		    iratetemp = max (1,iratetemp-1);
		    break;

		case SB_PAGEDOWN:
		    iratetemp = min (7,iratetemp+2);
		    break;

		case SB_LINEDOWN:
		    iratetemp = min (7,iratetemp+1);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    iratetemp = HIWORD ( wParam );
		    break;
		default:
		    return (FALSE);
		  }


		SetScrollPos(hFCtrl,SB_CTL,iratetemp,TRUE);

                // note the check for SM_THUMBTRACK fixes the bug where
                // we got messed up if the user drags scroll bar to the
                // off position and we popped up a msgbox before mouse
                // was released!  -- GCL

                if ((iratetemp ==1) &&
                   (LOWORD(wParam) != SB_THUMBTRACK ) &&
                   (IsWindowEnabled (GetDlgItem(hDlg,ID_KB_DELAY_3))))
		    {
		    EnableWindow(GetDlgItem(hDlg,ID_KB_DELAY_3),FALSE);
		    OkFiltersMessage (hDlg,IDS_FILTERS_3);
		    InvalidateRect(GetDlgItem(hDlg,ID_KB_DELAY_3),NULL,FALSE);
		    userpainton = TRUE;
		    userpainthidden = FALSE;
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_1),SW_HIDE);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_TEXT),SW_HIDE);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_4),SW_HIDE);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_5),SW_HIDE);
		    }
		else if ((iratetemp ==1) && (!IsWindowEnabled (GetDlgItem(hDlg,ID_KB_DELAY_3))))
		    {
		    return (FALSE);
		    break;
		    }
		else if ((iratetemp !=1) && (!IsWindowEnabled (GetDlgItem(hDlg,ID_KB_DELAY_3))))
		    {
		    EnableWindow(GetDlgItem(hDlg,ID_KB_DELAY_3),TRUE);
		    InvalidateRect(GetDlgItem(hDlg,ID_KB_DELAY_3),NULL,FALSE);
		    userpaintoff = TRUE;
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_1),SW_SHOWNORMAL);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_TEXT),SW_SHOWNORMAL);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_4),SW_SHOWNORMAL);
		    ShowWindow(GetDlgItem(hDlg,ID_KB_DELAY_5),SW_SHOWNORMAL);
		    }

		for (i=0;i<7;i++)
		    {
		    if (iratetemp == RateTableConv[i] ) break;
		    }
		FilterKeysParam.iRepeatMSec = RateTable[i];
		lpratetext = RateTableText[i].ratestrings;

		SetDlgItemText(hDlg,ID_KB_RATE_TEXT,(LPSTR)lpratetext);

		FilterKeysParam.cbSize = sizeof(FilterKeysParam);
		SystemParametersInfo(
		    SPI_SETFILTERKEYS,
		    0, // sizeof(FilterKeysParam),
		    lp_FilterKeys_Param,
		    0);
		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

/************************/

	      if (ID_KB_BOUNCE_3 == hFCtrlID)
		{
		switch (LOWORD(wParam))
		    {
		case SB_PAGEUP:
		    ibouncetemp = max (1,ibouncetemp-2);
		    break;

		case SB_LINEUP:
		    ibouncetemp = max (1,ibouncetemp-1);
		    break;

		case SB_PAGEDOWN:
		    ibouncetemp = min (6,ibouncetemp+2);
		    break;

		case SB_LINEDOWN:
		    ibouncetemp = min (6,ibouncetemp+1);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    ibouncetemp = HIWORD (wParam);
		    break;
		default:
		    return (FALSE);
		  }


		if( TestFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON) )
		    {
			if ((iaccepttemp !=1) && (ibouncetemp !=1))
			    {
			    OkFiltersMessage (hDlg,IDS_FILTERS_2);
			    ibouncetemp = 1;
			    }
		    }

		SetScrollPos(hFCtrl,SB_CTL,ibouncetemp,TRUE);

		    for (i=0;i<6;i++) {
			if (BounceTableConv[i] == ibouncetemp) break;
			}

		    FilterKeysParam.iBounceMSec = BounceTable[i];
		    lpbouncetext = BounceTableText[i].bouncestrings;

		SetDlgItemText(hDlg,ID_KB_BOUNCE_TEXT,(LPSTR)lpbouncetext);
		FilterKeysParam.cbSize = sizeof(FilterKeysParam);
		SystemParametersInfo(
		    SPI_SETFILTERKEYS,
		    0, // sizeof(FilterKeysParam),
		    lp_FilterKeys_Param,
		    0);
		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

/***************************************/

    case WM_INITDIALOG:                            /* Request to initalize        */

	FilterhWnd = hDlg;
	fMyQuestion_Save = 0;
	userpainton = userpaintoff = userpainthidden = userpaintoverlap = FALSE;

	FilterKeysParam.cbSize = sizeof(FilterKeysParam);
	SystemParametersInfo(
	    SPI_GETFILTERKEYS,
	    0, // sizeof(FilterKeysParam),
	    lp_FilterKeys_Param,
	    0);

	SavedFilterKeysParam.cbSize = sizeof(SavedFilterKeysParam);
	SystemParametersInfo(
	    SPI_GETFILTERKEYS,
	    0, // sizeof(FilterKeysParam),
	    &SavedFilterKeysParam,
	    0);

	hCtrlAcceptance = GetDlgItem(hDlg,ID_KB_ACCEPT_3);
	hCtrlDelay = GetDlgItem(hDlg,ID_KB_DELAY_3);
	hCtrlRate = GetDlgItem(hDlg,ID_KB_RATE_2);
	hCtrlBounce = GetDlgItem(hDlg,ID_KB_BOUNCE_3);
	hCtrlKybTest = GetDlgItem(hDlg,ID_KB_TEST_1);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON) break;
	// }
	//
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i );
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(FilterKeysParam.dwFlags,FKF_FILTERKEYSON) ? ID_ON : ID_OFF );

	CheckDlgButton(hDlg, ID_ON_OFF_FEEDBACK, TestFlag(FilterKeysParam.dwFlags,FKF_HOTKEYSOUND) );
	CheckDlgButton(hDlg, ID_ON_OFF_CLICK, TestFlag(FilterKeysParam.dwFlags,FKF_CLICKON) );
	CheckDlgButton(hDlg, ID_HOTKEY_ACTIVATION, TestFlag(FilterKeysParam.dwFlags,FKF_HOTKEYACTIVE) );


	for (i=0;i<7;i++) {
	    if (AcceptTable[i] == FilterKeysParam.iWaitMSec) break;
	}

	iaccepttemp = AcceptTableConv[i];
	iaccept = iaccepttemp;
	lpaccepttext = AcceptTableText[i].acceptstrings;

	for (i=0;i<4;i++) {
	    if (DelayTable[i] == FilterKeysParam.iDelayMSec) break;
	}

	idelaytemp = DelayTableConv[i];
	idelay = idelaytemp;
	lpdelaytext = DelayTableText[i].delaystrings;


	for (i=0;i<7;i++) {
	    if (RateTable[i] == FilterKeysParam.iRepeatMSec) break;
	}

	iratetemp = RateTableConv[i];
	irate = iratetemp;
	lpratetext = RateTableText[i].ratestrings;

	for (i=0;i<6;i++) {
	    if (BounceTable[i] == FilterKeysParam.iBounceMSec) break;
	}

	ibouncetemp = BounceTableConv[i];
	ibounce = ibouncetemp;
	lpbouncetext = BounceTableText[i].bouncestrings;


	SetScrollRange (hCtrlAcceptance,SB_CTL,1,7,FALSE);
	SetScrollRange (hCtrlDelay,SB_CTL,1,4,FALSE);
	SetScrollRange (hCtrlRate,SB_CTL,1,7,FALSE);
	SetScrollRange (hCtrlBounce,SB_CTL,1,6,FALSE);

	SetScrollPos(hCtrlAcceptance,SB_CTL,iaccepttemp,TRUE);
	SetScrollPos(hCtrlDelay,SB_CTL,idelaytemp,TRUE);
	SetScrollPos(hCtrlRate,SB_CTL,iratetemp,TRUE);
	SetScrollPos(hCtrlBounce,SB_CTL,ibouncetemp,TRUE);

	SetDlgItemText(hDlg,ID_KB_ACCEPT_TEXT,(LPSTR)lpaccepttext);
	SetDlgItemText(hDlg,ID_KB_DELAY_TEXT,(LPSTR)lpdelaytext);
	SetDlgItemText(hDlg,ID_KB_RATE_TEXT,(LPSTR)lpratetext);
	SetDlgItemText(hDlg,ID_KB_BOUNCE_TEXT,(LPSTR)lpbouncetext);

	if (iratetemp == 1)
	    {
		userpainthidden=TRUE;
	    }

	return(TRUE);
	break;

    default:
	break;
    }
return (FALSE);
}

/****************************************************************************

    FUNCTION:    AdjustSticKeys(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustSticKeys(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    STICKYKEYS        *lp_SticKeys_Param;
    static BOOL fMyQuestion_Save;

    lp_SticKeys_Param = &StickyKeysParam;

    switch (message) {
    case WM_COMMAND:
	switch (wParam) {

	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, (DWORD)wParam);
	    SetFlag(StickyKeysParam.dwFlags,SKF_STICKYKEYSON,OnOffTable[wParam-ID_OFF]);
	    fMyQuestion_Save = 1;
	    break;

	case ID_TRISTATE:
	    SetFlag(StickyKeysParam.dwFlags,SKF_TRISTATE,IsDlgButtonChecked(hDlg, ID_TRISTATE));
	    fMyQuestion_Save = 1;
	    break;

	case ID_ON_OFF_FEEDBACK:
	    SetFlag(StickyKeysParam.dwFlags,SKF_HOTKEYSOUND,IsDlgButtonChecked(hDlg, ID_ON_OFF_FEEDBACK));
	    fMyQuestion_Save = 1;
	    break;

	case ID_HOTKEY_ACTIVATION:
	    SetFlag(StickyKeysParam.dwFlags,SKF_HOTKEYACTIVE,IsDlgButtonChecked(hDlg, ID_HOTKEY_ACTIVATION));
	    fMyQuestion_Save = 1;
	    break;

	case ID_TWOKEYS_TURNOFF:
	    SetFlag(StickyKeysParam.dwFlags,SKF_TWOKEYSOFF,IsDlgButtonChecked(hDlg, ID_TWOKEYS_TURNOFF));
	    fMyQuestion_Save = 1;
	    break;

	case ID_STATE_FEEDBACK:
	    SetFlag(StickyKeysParam.dwFlags,SKF_AUDIBLEFEEDBACK,IsDlgButtonChecked(hDlg, ID_STATE_FEEDBACK));
	    fMyQuestion_Save = 1;
	    break;

	case IDOK:
	    StickyKeysParam.cbSize = sizeof(StickyKeysParam);
	    SystemParametersInfo(
		SPI_SETSTICKYKEYS,
		0, // sizeof(StickyKeysParam),
		lp_SticKeys_Param,
		0);
	    StickyhWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg, IDOK);
	    break;

	case IDCANCEL:

	    /* Let the caller know the user cancelled */
	    StickyhWnd = NULL;
	    EndDialog(hDlg, IDCANCEL);
	    break;
	default:
	    return (FALSE);
	}
	return(TRUE);
	break;

    case WM_INITDIALOG:                            /* Request to initalize        */

	StickyhWnd = hDlg;
	fMyQuestion_Save = 0;

	StickyKeysParam.cbSize = sizeof(StickyKeysParam);
	SystemParametersInfo(
	    SPI_GETSTICKYKEYS,
	    0, // sizeof(StickyKeysParam),
	    lp_SticKeys_Param,
	    0);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(StickyKeysParam.dwFlags,SKF_STICKYKEYSON) ) break;
	// }
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i);
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(StickyKeysParam.dwFlags,SKF_STICKYKEYSON) ? ID_ON : ID_OFF );

	CheckDlgButton(hDlg, ID_HOTKEY_ACTIVATION, TestFlag(StickyKeysParam.dwFlags,SKF_HOTKEYACTIVE) );
	CheckDlgButton(hDlg, ID_ON_OFF_FEEDBACK, TestFlag(StickyKeysParam.dwFlags,SKF_HOTKEYSOUND) );
	CheckDlgButton(hDlg, ID_STATE_FEEDBACK, TestFlag(StickyKeysParam.dwFlags,SKF_AUDIBLEFEEDBACK) );
	CheckDlgButton(hDlg, ID_TRISTATE, TestFlag(StickyKeysParam.dwFlags,SKF_TRISTATE) );
	CheckDlgButton(hDlg, ID_TWOKEYS_TURNOFF, TestFlag(StickyKeysParam.dwFlags,SKF_TWOKEYSOFF) );
	return(TRUE);
	break;

    default:
	break;
    }
    return (FALSE);
}

#ifdef CALCULATEDINTERNALLY
/****************************************************************************

    FUNCTION:    CalculateMouseTable()

    PURPOSE:    To set mouse table based on time to max speed and max speed.

    COMMENTS:


****************************************************************************/
void    CalculateMouseTable()
{
    long    Total_Distance;         /* in 1000th of pixel */

    long    Accel_Per_Tick;         /* in 1000th of pixel/tick */
    long    Current_Speed;          /* in 1000th of pixel/tick */
    long    Max_Speed;              /* in 1000th of pixel/tick */
    long    Real_Total_Distance;    /* in pixels */
    long    Real_Delta_Distance;    /* in pixels */
    int     i;
    int     Num_Constant_Table,Num_Accel_Table;

    Max_Speed = MouseKeysParam.iMaxSpeed;
    Max_Speed *= 1000 / 20;

    Accel_Per_Tick = Max_Speed * 1000 / (MouseKeysParam.iTimeToMaxSpeed * 20);
    Current_Speed = 0;
    Total_Distance = 0;
    Real_Total_Distance = 0;
    Num_Constant_Table = 0;
    Num_Accel_Table = 0;

    for(i=0; i<= 255; i++) {
	Current_Speed = Current_Speed + Accel_Per_Tick;
	if (Current_Speed > Max_Speed) {
	    Current_Speed = Max_Speed;
	}
	Total_Distance += Current_Speed;

	//
	// Calculate how many pixels to move on this tick
	//
	Real_Delta_Distance = ((Total_Distance - (Real_Total_Distance * 1000)) + 500) / 1000 ;
	//
	// Calculate total distance moved up to this point
	//
	Real_Total_Distance = Real_Total_Distance + Real_Delta_Distance;

	if ((Current_Speed < Max_Speed) && (Num_Accel_Table < 128)) {
	    MouseKeysParam.bAccelTable[Num_Accel_Table++] = (BYTE)Real_Delta_Distance;
	}

	if ((Current_Speed == Max_Speed) && (Num_Constant_Table < 128)) {
	    MouseKeysParam.bConstantTable[Num_Constant_Table++] = (BYTE)Real_Delta_Distance;
	}

    }
    MouseKeysParam.bAccelTableLen = (BYTE)Num_Accel_Table;
    MouseKeysParam.bConstantTableLen = (BYTE)Num_Constant_Table;
}
#endif

/****************************************************************************

    FUNCTION:    AdjustMouseKeys(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustMouseKeys(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    char *lptimetext;
    int        i;
    static int     ispeedtemp,itimetemp;                  /* these valuse MUST be static for scroll bars to work !!! */
    static int     ispeed,itime;                      /* these valuse MUST be static for scroll bars to work !!! */
    static BOOL fMyQuestion_Save;
    HWND    hCtrlTime,hCtrlSpeed,hMCtrl;  /* ,hCtrlText; */
    int hMCtrlID;
    MOUSEKEYS    *lp_MouseKeys_Param;
    static MOUSEKEYS   SavedMouseKeysParam;    // saved copy for restore on Cancel

    lp_MouseKeys_Param = &MouseKeysParam;

    switch (message) {
    case WM_COMMAND:
	switch (wParam) {
	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, (DWORD)wParam);
	    SetFlag(MouseKeysParam.dwFlags,MKF_MOUSEKEYSON,OnOffTable[wParam-ID_OFF]);
	    fMyQuestion_Save = 1;
	    MouseKeysParam.cbSize = sizeof(MouseKeysParam);
	    SystemParametersInfo(
		SPI_SETMOUSEKEYS,
		0, // sizeof(MouseKeysParam),
		lp_MouseKeys_Param,
		0);
	    break;

	case ID_ON_OFF_FEEDBACK:
	    SetFlag(MouseKeysParam.dwFlags,MKF_HOTKEYSOUND,IsDlgButtonChecked(hDlg, ID_ON_OFF_FEEDBACK));
	    fMyQuestion_Save = 1;
	    break;

	case ID_HOTKEY_ACTIVATION:
	    SetFlag(MouseKeysParam.dwFlags,MKF_HOTKEYACTIVE,IsDlgButtonChecked(hDlg, ID_HOTKEY_ACTIVATION));
	    fMyQuestion_Save = 1;
	    break;

	case IDOK:
	    MouseKeysParam.cbSize = sizeof(MouseKeysParam);
	    SystemParametersInfo(
		SPI_SETMOUSEKEYS,
		0, // sizeof(MouseKeysParam),
		lp_MouseKeys_Param,
		0);
	    MousehWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg,IDOK);
	    break;

	case IDCANCEL:

/* Let the caller know the user cancelled */
/* set speed and time parameters back if they have been changed since we do on the FLY now */

	    // MousehWnd = NULL;
	    // if (ispeed != ispeedtemp)
	    // {
	    //     for (i=0;i<9;i++) {
	    //         if (SpeedTableConv[i] == ispeed) break;
	    //                 }
	    //         MouseKeysParam.iMaxSpeed = SpeedTable[i];
	    //         SystemParametersInfo(
	    //             SPI_SETMOUSEKEYS,
	    //             sizeof(MouseKeysParam),
	    //             lp_MouseKeys_Param,
	    //             0);
	    //
	    // }
	    //
	    // if (itime != itimetemp)
	    // {
	    //     for (i=0;i<9;i++) {
	    //         if (TimeTableConv[i] == itime) break;
	    //                 }
	    //         MouseKeysParam.iTimeToMaxSpeed = TimeTable[i];
	    //         SystemParametersInfo(
	    //             SPI_SETMOUSEKEYS,
	    //             sizeof(MouseKeysParam),
	    //             lp_MouseKeys_Param,
	    //             0);
	    //
	    // }
	    SavedMouseKeysParam.cbSize = sizeof(SavedMouseKeysParam);
	    i = SystemParametersInfo(               /* restore saved settings */
		SPI_SETMOUSEKEYS,
		0, // sizeof(SavedMouseKeysParam),
		&SavedMouseKeysParam,
		0);
#ifdef DEBUG
	    if( i != TRUE )
		{
		OkMsgBox( "ERROR", "Return from SET MK = %i", i );
		}
#endif
	    MouseKeysParam.cbSize = sizeof(MouseKeysParam);
	    i = SystemParametersInfo(               /* synch up our internal data struct */
		SPI_GETMOUSEKEYS,
		0, // sizeof(MouseKeysParam),
		&MouseKeysParam,
		0);
#ifdef DEBUG
	    if( i != TRUE )
		{
		OkMsgBox( "ERROR", "Return from GET MK = %i", i );
		}
#endif
	    EndDialog(hDlg,IDCANCEL);
	    break;

	default:
		return (FALSE);
	    }
    return(TRUE);
    break;


	case WM_KEYDOWN:

	    switch (wParam)
		{
		case VK_PRIOR:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEUP,0L);
		    break;

		case VK_NEXT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEDOWN,0L);
		    break;

		case VK_UP:
		    SendMessage (hDlg,WM_HSCROLL,SB_LINEUP,0L);
		    break;

		case VK_DOWN:
		    SendMessage (hDlg,WM_HSCROLL,SB_LINEDOWN,0L);
		    break;

		case VK_LEFT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEUP,0L);
		    break;

		case VK_RIGHT:
		    SendMessage (hDlg,WM_HSCROLL,SB_PAGEDOWN,0L);
		    break;

		default:
		    return(FALSE);
		    break;

		}
	return (TRUE);
    break;


	case WM_HSCROLL:

	    hMCtrl = (HWND)lParam;
	    hMCtrlID = GetDlgCtrlID (hMCtrl);

	    if (ID_MK_SPEED_1 == hMCtrlID)
		{
		switch (LOWORD(wParam))
		    {
		case SB_LINEUP:
		    ispeedtemp = max (1,ispeedtemp -1);
		    break;

		case SB_LINEDOWN:
		    ispeedtemp =min (9,ispeedtemp +1);
		    break;

		case SB_PAGEUP:
		    ispeedtemp = max (1,ispeedtemp -3);
		    break;

		case SB_PAGEDOWN:
		    ispeedtemp = min (9,ispeedtemp +3);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    ispeedtemp = HIWORD (wParam);
		    break;

		default:
		    return (FALSE);
		  }

		for (i=0;i<9;i++) {
		    if (SpeedTableConv[i] == ispeedtemp) break;
			    }
		    MouseKeysParam.iMaxSpeed = SpeedTable[i];

		MouseKeysParam.cbSize = sizeof(MouseKeysParam);
		SystemParametersInfo(
		    SPI_SETMOUSEKEYS,
		    0, // sizeof(MouseKeysParam),
		    lp_MouseKeys_Param,
		    0);
		SetScrollPos(hMCtrl,SB_CTL,ispeedtemp,TRUE);
		SetDlgItemInt(hDlg,ID_MK_SPEED_TEXT,MouseKeysParam.iMaxSpeed,FALSE);

/* DEBUGGING  */

/*        OkMsgBox (NULL,"MouseKeys Speed set to",
		    "iMaxSpeed = %04i",
		    ispeedtemp);
*/

		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

	    else
		{
		switch (LOWORD(wParam))
		    {
		case SB_PAGEUP:
		    itimetemp = max (1,itimetemp-3);
		    break;

		case SB_LINEUP:
		    itimetemp = max (1,itimetemp-1);
		    break;

		case SB_PAGEDOWN:
		    itimetemp = min (9,itimetemp+3);
		    break;

		case SB_LINEDOWN:
		    itimetemp = min (9,itimetemp+1);
		    break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
		    itimetemp = HIWORD (wParam);
		    break;
		default:
		    return (FALSE);
		  }

		for (i=0;i<9;i++) {
		    if (TimeTableConv[i] == itimetemp) break;
			}
		    MouseKeysParam.iTimeToMaxSpeed = TimeTable[i];

		MouseKeysParam.cbSize = sizeof(MouseKeysParam);
		SystemParametersInfo(
		    SPI_SETMOUSEKEYS,
		    0, // sizeof(MouseKeysParam),
		    lp_MouseKeys_Param,
		    0);

		SetScrollPos(hMCtrl,SB_CTL,itimetemp,TRUE);
		lptimetext = TimeTableText[i].timestrings;
		SetDlgItemText(hDlg,ID_MK_TIME_TEXT,(LPSTR)lptimetext);

/* DEBUGGING  */

/*        OkMsgBox (NULL,"MouseKeys Time Set to",
		    "iTimeToMaxSpeed = %04i",
		    itimetemp);
*/

		fMyQuestion_Save = 1;
		return(TRUE);
		break;
		}

    case WM_INITDIALOG:                            /* Request to initalize        */

	MousehWnd = hDlg;
	fMyQuestion_Save = 0;
	ispeedtemp = ispeed = itimetemp = itime = 0;

	MouseKeysParam.cbSize = sizeof(MouseKeysParam);
	i = SystemParametersInfo(
	    SPI_GETMOUSEKEYS,
	    0, // sizeof(MouseKeysParam),
	    lp_MouseKeys_Param,
	    0);
#ifdef DEBUG
	if( i != TRUE )
	    {
	    OkMsgBox( "ERROR", "Return from GET MK init = %i", i );
	    }
#endif

	SavedMouseKeysParam.cbSize = sizeof(SavedMouseKeysParam);
	i = SystemParametersInfo(
	    SPI_GETMOUSEKEYS,
	    0, // sizeof(SavedMouseKeysParam),
	    &SavedMouseKeysParam,
	    0);
#ifdef DEBUG
	if( i != TRUE )
	    {
	    OkMsgBox( "ERROR", "Return from GET MK save = %i", i );
	    }
#endif

	hCtrlTime = GetDlgItem (hDlg,ID_MK_TIME_1);
	hCtrlSpeed = GetDlgItem (hDlg,ID_MK_SPEED_1);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(MouseKeysParam.dwFlags,MKF_MOUSEKEYSON) ) break;
	// }
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i);
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(MouseKeysParam.dwFlags,MKF_MOUSEKEYSON) ? ID_ON : ID_OFF );

	CheckDlgButton(hDlg, ID_HOTKEY_ACTIVATION, TestFlag(MouseKeysParam.dwFlags,MKF_HOTKEYACTIVE) );
	CheckDlgButton(hDlg, ID_ON_OFF_FEEDBACK, TestFlag(MouseKeysParam.dwFlags,MKF_HOTKEYSOUND) );

	for (i=0;i<9;i++) {
	    if (SpeedTable[i] == MouseKeysParam.iMaxSpeed) break;
	}
	    ispeedtemp = SpeedTableConv[i];
	    ispeed = ispeedtemp;


	for (i=0;i<9;i++) {
	    if (TimeTable[i] == MouseKeysParam.iTimeToMaxSpeed) break;
	}
	    itimetemp = TimeTableConv[i];
	    itime = itimetemp;
	    lptimetext = TimeTableText[i].timestrings;

	SetScrollRange (hCtrlSpeed,SB_CTL,1,9,FALSE);
	SetScrollRange (hCtrlTime,SB_CTL,1,9,FALSE);


	SetScrollPos(hCtrlSpeed,SB_CTL,ispeedtemp,TRUE);
	SetScrollPos(hCtrlTime,SB_CTL,itimetemp,TRUE);

	SetDlgItemInt(hDlg,ID_MK_SPEED_TEXT,MouseKeysParam.iMaxSpeed,FALSE);
	SetDlgItemText(hDlg,ID_MK_TIME_TEXT,(LPSTR)lptimetext);


/* DEBUGGING  */

/*        OkMsgBox (NULL,"MouseKeys Initalized at",
		    "iMaxSpeed = %04i, iTimeToMaxSpeed = %04i",
		    ispeedtemp,itimetemp);
*/
	return (TRUE);
	break;

    }
    return(FALSE);
}

/****************************************************************************

    FUNCTION:    AdjustToggleKeys(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustToggleKeys(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    TOGGLEKEYS    *lp_ToggleKeys_Param;
    static BOOL fMyQuestion_Save;

    lp_ToggleKeys_Param = &ToggleKeysParam;

    switch (message) {
    case WM_COMMAND:
	switch (wParam) {

	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, (DWORD)wParam);
	    SetFlag(ToggleKeysParam.dwFlags,TKF_TOGGLEKEYSON,OnOffTable[wParam-ID_OFF]);
	    fMyQuestion_Save = 1;
	    break;

	case IDOK:
	    ToggleKeysParam.cbSize = sizeof(ToggleKeysParam);
	    SystemParametersInfo(
		SPI_SETTOGGLEKEYS,
		0, // sizeof(ToggleKeysParam),
		lp_ToggleKeys_Param,
		0);
	    TogglehWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg, IDOK);
	    break;

	case ID_HOTKEY_ACTIVATION:
	    SetFlag(ToggleKeysParam.dwFlags,TKF_HOTKEYACTIVE,IsDlgButtonChecked(hDlg, ID_HOTKEY_ACTIVATION));
	    fMyQuestion_Save = 1;
	    break;

	case ID_ON_OFF_FEEDBACK:
	    SetFlag(ToggleKeysParam.dwFlags,TKF_HOTKEYSOUND,IsDlgButtonChecked(hDlg, ID_ON_OFF_FEEDBACK));
	    fMyQuestion_Save = 1;
	    break;

	case IDCANCEL:

	    /* Let the caller know the user cancelled */
	    TogglehWnd = NULL;
	    EndDialog(hDlg, IDCANCEL);
	    break;

	default:
	    return (FALSE);
	    break;
	}
	return (TRUE);
	break;

    case WM_INITDIALOG:                        /* Request to initalize        */

	TogglehWnd = hDlg;
	fMyQuestion_Save = 0;

	ToggleKeysParam.cbSize = sizeof(ToggleKeysParam);
	SystemParametersInfo(
	    SPI_GETTOGGLEKEYS,
	    0, // sizeof(ToggleKeysParam),
	    lp_ToggleKeys_Param,
	    0);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(ToggleKeysParam.dwFlags,TKF_TOGGLEKEYSON) ) break;
	// }
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i);
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(ToggleKeysParam.dwFlags,TKF_TOGGLEKEYSON) ? ID_ON : ID_OFF );

	CheckDlgButton(hDlg, ID_HOTKEY_ACTIVATION, TestFlag(ToggleKeysParam.dwFlags,TKF_HOTKEYACTIVE) );
	CheckDlgButton(hDlg, ID_ON_OFF_FEEDBACK, TestFlag(ToggleKeysParam.dwFlags,TKF_HOTKEYSOUND) );

	return(TRUE);
	break;

    default:
	break;
    }
    return (FALSE);
}

/****************************************************************************

    FUNCTION:    AdjustTimeOut(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustTimeOut(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    ACCESSTIMEOUT        *lp_TimeOut_Param;
    int        i;
    static BOOL fMyQuestion_Save;

    lp_TimeOut_Param = &TimeOutParam;

    switch (message) {
    case WM_COMMAND:
	switch (wParam) {

	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, (int)wParam);
	    SetFlag(TimeOutParam.dwFlags,ATF_TIMEOUTON,OnOffTable[wParam-ID_OFF]);
	    fMyQuestion_Save = 1;
	    break;

	case ID_ON_OFF_FEEDBACK:
	    SetFlag(TimeOutParam.dwFlags,ATF_ONOFFFEEDBACK,IsDlgButtonChecked(hDlg, ID_ON_OFF_FEEDBACK));
	    fMyQuestion_Save = 1;
	    break;

	case ID_TIMEOUT_1:
	case ID_TIMEOUT_2:
	case ID_TIMEOUT_3:
	case ID_TIMEOUT_4:
	    CheckRadioButton(hDlg, ID_TIMEOUT_1, ID_TIMEOUT_4, (int)wParam);
	    TimeOutParam.iTimeOutMSec = TimeOutTable[wParam-ID_TIMEOUT_1];
	    fMyQuestion_Save = 1;
	    break;

	case IDOK:
	    TimeOutParam.cbSize = sizeof(TimeOutParam);
	    SystemParametersInfo(
		SPI_SETACCESSTIMEOUT,
		0, // sizeof(TimeOutParam),
		lp_TimeOut_Param,
		0);
	    TimeOuthWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg, IDOK);
	    break;

	case IDCANCEL:

	    /* Let the caller know the user cancelled */
	    TimeOuthWnd = NULL;
	    EndDialog(hDlg, IDCANCEL);
	    break;
	default:
	    return (FALSE);
	}
	return(TRUE);
	break;

    case WM_INITDIALOG:                            /* Request to initalize        */

	TimeOuthWnd = hDlg;
	fMyQuestion_Save = 0;

	TimeOutParam.cbSize = sizeof(TimeOutParam);
	SystemParametersInfo(
	    SPI_GETACCESSTIMEOUT,
	    0, // sizeof(TimeOutParam),
	    lp_TimeOut_Param,
	    0);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(TimeOutParam.dwFlags,ATF_TIMEOUTON) ) break;
	// }
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i);
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(TimeOutParam.dwFlags,ATF_TIMEOUTON) ? ID_ON : ID_OFF );

	CheckDlgButton(hDlg, ID_ON_OFF_FEEDBACK, TestFlag(TimeOutParam.dwFlags,ATF_ONOFFFEEDBACK) );

	for (i=0;i<4;i++) {
	    if (TimeOutTable[i] == TimeOutParam.iTimeOutMSec) break;
	}
	CheckRadioButton(hDlg, ID_TIMEOUT_1, ID_TIMEOUT_4, ID_TIMEOUT_1 + i);

	return(TRUE);
	break;

    default:
	break;
    }
    return (FALSE);
}

/****************************************************************************

    FUNCTION:    AdjustSerialKeys(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustSerialKeys(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{

	int    iPortButton;
	int    iBaudButton;
   static BOOL fMyQuestion_Save;
	char   sbuf1[255];

#ifdef MYSK
    MYSERIALKEYS    *lp_serialkeys;
    lp_serialkeys    = &MySerialKeysParam;
#endif

	switch (message)
	{
		//-------------------------------------------------------------
		case WM_COMMAND:
			switch (wParam)
			{

				//------------------------------------------------------
				case IDC_INST_REMOVE:
					if (!SerialKeysEnabled)
						SerialKeysInstall(hDlg);
					else
						SerialKeysRemove(hDlg);

					SetDialogItems(hDlg);
					break;

				//---------------------------------------------------------
				case ID_OFF:
				case ID_ON:
					CheckRadioButton(hDlg, ID_OFF, ID_ON, (int)wParam);
					bSK_CommOpen = (BOOL)wParam;
		   fMyQuestion_Save = 1;
					break;

				//---------------------------------------------------------
				case ID_BAUD_300:
				case ID_BAUD_600:
				case ID_BAUD_1200:
				case ID_BAUD_2400:
				case ID_BAUD_4800:
				case ID_BAUD_9600:
				case ID_BAUD_19200:
					CheckRadioButton(hDlg, ID_BAUD_300, ID_BAUD_19200,
                                     (int)wParam);
					iSK_BaudRate = (int)wParam;
		   fMyQuestion_Save = 1;
					break;

				//---------------------------------------------------------
				case ID_COM1:
				case ID_COM2:
				case ID_COM3:
				case ID_COM4:
					CheckRadioButton(hDlg, ID_COM1, ID_COM4, (int)wParam);
					iSK_ComName = (int)wParam;
		   fMyQuestion_Save = 1;
					break;

				//---------------------------------------------------------
				case IDOK:

					if (!SerialKeysEnabled)         // Is Serial Keys Installed?
					{
						EndDialog(hDlg, IDOK);          // No - Remove Dialog
						break;
					}

#ifdef MYSK
					MySerialKeysParam.fSerialKeysOn = bSK_CommOpen;
					MySerialKeysParam.iBaudRate     = iSK_BaudRate - ID_BAUD_300;
					MySerialKeysParam.iComName      = iSK_ComName - ID_COM1;
		   SystemParametersInfo(SPI_SETSERIALKEYS,sizeof(MySerialKeysParam),lp_serialkeys,0);

#else
					switch( iSK_ComName )
					{
						case ID_COM1:
							strcpy( SK_ActivePort, "COM1" );
							break;
						case ID_COM2:
							strcpy( SK_ActivePort, "COM2" );
							break;
						case ID_COM3:
							strcpy( SK_ActivePort, "COM3" );
							break;
						case ID_COM4:
							strcpy( SK_ActivePort, "COM4" );
							break;
						default:
                                                     // OkMsgBox( "Access Utility", "Bad SerialKeys Port Name" );
                                                        OkFiltersMessage( hDlg, IDS_BAD_SK_PORT );
							break;
					}

					switch( iSK_BaudRate )
					{
						case ID_BAUD_300:
							SerialKeysParam.iBaudRate = CBR_300;
							break;
						case ID_BAUD_600:
							SerialKeysParam.iBaudRate = CBR_600;
							break;
						case ID_BAUD_1200:
							SerialKeysParam.iBaudRate = CBR_1200;
							break;
						case ID_BAUD_2400:
							SerialKeysParam.iBaudRate = CBR_2400;
							break;
						case ID_BAUD_4800:
							SerialKeysParam.iBaudRate = CBR_4800;
							break;
						case ID_BAUD_9600:
							SerialKeysParam.iBaudRate = CBR_9600;
							break;
						case ID_BAUD_19200:
							SerialKeysParam.iBaudRate = CBR_19200;
							break;
						default:
                                                     // OkMsgBox( "Access Utility", "Bad SerialKeys Baud Rate" );
                                                        OkFiltersMessage( hDlg, IDS_BAD_SK_BAUD );
							break;
					}

					SerialKeysParam.dwFlags = SERKF_AVAILABLE;
					if (bSK_CommOpen == ID_ON)
						SerialKeysParam.dwFlags += SERKF_SERIALKEYSON;

					SKEY_SystemParametersInfo
					(
						SPI_SETSERIALKEYS,
						sizeof(SerialKeysParam),
						&SerialKeysParam,0
					);

					bSK_CommOpen = (SerialKeysParam.dwFlags & SERKF_SERIALKEYSON) ? ID_ON : ID_OFF;
#endif

					if ( fMyQuestion_Save )
						fQuestion_Save = 1;

			    EndDialog(hDlg, IDOK);
		break;
				
				//---------------------------------------------------------
				case IDCANCEL:
				
					/* Let the caller know the user cancelled */
					SerialhWnd = NULL;
					EndDialog(hDlg, IDCANCEL);
					break;

				//---------------------------------------------------------
			default:
					return (FALSE);
			}
			return (TRUE);

		//-------------------------------------------------------------
		case WM_INITDIALOG:                        /* Request to initalize        */

			SerialhWnd = hDlg;
			fMyQuestion_Save = 0;

			// serialkeys params already filled in earlier....or were they?
			// before we save, check to see if AAC or framing errors changed baudrate
			// and we havenot caught it for display or saving purposes as yet
			// we don't do this now, should we?  doesn't vxd fill in
			// current values for us automatically?

#ifdef MYSK
			iPortButton = MySerialKeysParam.iComName + ID_COM1;
			if( MySerialKeysParam.iComName < 0 || MySerialKeysParam.iComName > 3 )
			   {
			//  OkMsgBox( "Access Utility", "Bad SerialKeys port number %i",
			//      MySerialKeysParam.iComName );
			   MySerialKeysParam.iComName = 0;
			   }
			if( MySerialKeysParam.iBaudRate < 0 || MySerialKeysParam.iBaudRate > 5 )
			   {
			//  OkMsgBox( "Access Utility", "Bad SerialKeys baud rate option %i",
			//      MySerialKeysParam.iBaudRate );
			   MySerialKeysParam.iBaudRate = 0;
			   }
			CheckRadioButton(hDlg, ID_COM1, ID_COM4, ID_COM1 + MySerialKeysParam.iComName );
			CheckRadioButton(hDlg, ID_BAUD_300, ID_BAUD_9600, ID_BAUD_300 + MySerialKeysParam.iBaudRate );
			if( ! MySerialKeysParam.fSerialKeysOn )
			   CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF);
			else
			   CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_ON);
#else

			//
			// Check if the Serial Keys Service is installed
			SerialKeysEnabled = SKEY_SystemParametersInfo   // Get Current Values
				(
					SPI_GETSERIALKEYS,sizeof(SerialKeysParam),
					&SerialKeysParam,0
				);

			if (SerialKeysEnabled)
			{
			    LoadString (hInst,IDS_SK_REMOVE,(LPSTR)sbuf1,245);
	       if( lstrlen( SK_ActivePort ) == 0 )
					lstrcpy( SK_ActivePort, "COM1" );
				
				iPortButton = ID_COM1 + (SK_ActivePort[3] - '1');
			}
			else
			{
			    LoadString (hInst,IDS_SK_INSTALL,(LPSTR)sbuf1,245);
				iPortButton = ID_COM1;                                  // Set Default Com Port
				SerialKeysParam.iBaudRate = CBR_300;    // Set Default
				SerialKeysParam.dwFlags = 0;
			}

			SetDlgItemText(hDlg, IDC_INST_REMOVE,sbuf1);
			SetDialogItems(hDlg);

			switch( SerialKeysParam.iBaudRate )
			{
		    case CBR_300:
		  iBaudButton = ID_BAUD_300;
		       break;

		    case CBR_600:
		       iBaudButton = ID_BAUD_600;
		       break;

		    case CBR_1200:
		       iBaudButton = ID_BAUD_1200;
		       break;

		    case CBR_2400:
		       iBaudButton = ID_BAUD_2400;
		       break;

		    case CBR_4800:
		       iBaudButton = ID_BAUD_4800;
		       break;

		    case CBR_9600:
		       iBaudButton = ID_BAUD_9600;
		       break;

		    case CBR_19200:
		       iBaudButton = ID_BAUD_19200;
		       break;

		    case 0:
					iBaudButton = ID_BAUD_300;
					break;

		    default:
		       OkMsgBox( "Access Utility", "Bad SerialKeys baud rate %i",
			   SerialKeysParam.iBaudRate );
		       iBaudButton = ID_BAUD_300;
		       break;
			}

			// Set Default Values
			iSK_BaudRate    = iBaudButton;
			iSK_ComName             = iPortButton;
			bSK_CommOpen    = (SerialKeysParam.dwFlags & SERKF_SERIALKEYSON) ? ID_ON : ID_OFF;

			CheckRadioButton(hDlg, ID_OFF, ID_ON, bSK_CommOpen);
			CheckRadioButton(hDlg, ID_COM1,ID_COM4, iPortButton);
			CheckRadioButton(hDlg, ID_BAUD_300, ID_BAUD_19200, iBaudButton);
#endif
			return(TRUE);

		//-------------------------------------------------------------
		default:
			break;
    }
    return (FALSE);
}


/****************************************************************************/
void SerialKeysInstall(HWND hDlg)
{
   char sbuf1[255];

	SERVICE_STATUS  ssStatus;
	DWORD   dwOldCheckPoint;
	DWORD   LastError;
	int             ErrCode;
	char    FileName[255];

	LPCTSTR lpszBinaryPathName = TEXT("%SystemRoot%\\system32\\skeys.exe");

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	GetWindowsDirectory(FileName,sizeof(FileName));
	strcat(FileName,"\\system32\\skeys.exe");
	//lpszBinaryPathName =

	if (GetFileAttributes(FileName) == 0xFFFFFFFF)        // Is Service File installed?
	{
		SKeysError(hDlg, IDS_SK_ERR_FAILFIND);  // No - Display Error & Exit
		return;
	}

	schSCManager = OpenSCManager            // Open Service Manager
		(
		NULL,                           // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		SC_MANAGER_ALL_ACCESS           // access required
	);

	if (schSCManager == NULL)                                       // Did Open Service Fail?
	{
		LastError = GetLastError();                             // Yes - Get Error Code

		if (LastError == ERROR_ACCESS_DENIED)           // Did we have correct privledge?
			SKeysError(hDlg, IDS_SK_ERR_ACCESS);    // No - Disp error
		else
			SKeysError(hDlg, IDS_SK_ERR_FAILSCM);   // Yes - Misc Error

		return;
	}


	schService = CreateService(
	    schSCManager,               // SCManager database
	    TEXT("SerialKeys"),                 // name of service
	    TEXT("SerialKeys"),                 // name to display (new parameter after october beta)
	    SERVICE_ALL_ACCESS,         // desired access
	    SERVICE_WIN32_OWN_PROCESS,  // service type
	    SERVICE_AUTO_START,             // start type
	    SERVICE_ERROR_NORMAL,       // error control type
	    FileName,                           // service's binary
	    NULL,                       // no load ordering group
	    NULL,                       // no tag identifier
	    NULL,                       // no dependencies
	    NULL,                       // LocalSystem account
	    NULL);                      // no password

	ErrCode = IDS_SK_ERR_CREATE;
	if (schService == NULL)                 // Was Service Created?
		goto ErrExit;                           // No - Exit

	CloseServiceHandle(schService);
	schService = OpenService
		(
			schSCManager ,
			"SerialKeys",
			SERVICE_ALL_ACCESS
		);

	ErrCode = IDS_SK_ERR_START;
	if (!StartService(schService,0,NULL))
		goto ErrExit;
		
	QueryServiceStatus(schService,&ssStatus);

	while (ssStatus.dwCurrentState != SERVICE_RUNNING)
	{
		dwOldCheckPoint = ssStatus.dwCheckPoint;
		Sleep(ssStatus.dwWaitHint);
		if (!QueryServiceStatus(schService,&ssStatus))
			break;

		if (dwOldCheckPoint >= ssStatus.dwCheckPoint)
			break;
	}

	if (ssStatus.dwCurrentState == SERVICE_RUNNING)
	{
		SerialKeysEnabled = TRUE;
		LoadString (hInst,IDS_SK_REMOVE,(LPSTR)sbuf1,245);
		SetDlgItemText(hDlg, IDC_INST_REMOVE,sbuf1);
		goto Exit;
	}

ErrExit:
	DeleteService(schService);
	SKeysError(hDlg, ErrCode);

Exit:
	CloseServiceHandle(schService);
	CloseServiceHandle(schSCManager);
	return;
}

/****************************************************************************/
void SerialKeysRemove(HWND hDlg)
{
   char sbuf1[255];

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;
	SERVICE_STATUS  ssStatus;
	DWORD   dwOldCheckPoint;
	DWORD   LastError;
	
	// Open Service Control Manager
	schSCManager = OpenSCManager
		(
		NULL,                   // machine (NULL == local)
	    NULL,                   // database (NULL == default)
		SC_MANAGER_ALL_ACCESS   // access required
	);

	if (schSCManager == NULL)               // Was Open successful?
	{
		LastError = GetLastError();                             // Yes - Get Error Code

		if (LastError == ERROR_ACCESS_DENIED)           // Did we have correct privledge?
			SKeysError(hDlg, IDS_SK_ERR_REMOVE);    // No - Disp error
		else
			SKeysError(hDlg, IDS_SK_ERR_FAILSCM);   // Yes - Misc Error

		return;                                         // No - Exit
	}

	schService = OpenService                // Open Service
		(
		schSCManager,
		"SerialKeys",
		SERVICE_ALL_ACCESS
	);

	if (schService == NULL)                 // Did Open Fail?
	{
		SKeysError(hDlg, IDS_SK_ERR_OPEN);
		goto Exit;
	}

	ControlService(schService,SERVICE_CONTROL_STOP,&ssStatus);      // Stop Service
	QueryServiceStatus(schService,&ssStatus);                                       // Get Status

	//
	// Wait until the service is stopped.
	while (ssStatus.dwCurrentState != SERVICE_STOPPED)                      // Wait until Service Stops
	{
		dwOldCheckPoint = ssStatus.dwCheckPoint;
		Sleep(ssStatus.dwWaitHint);
		if (!QueryServiceStatus(schService,&ssStatus))
			break;

		if (dwOldCheckPoint >= ssStatus.dwCheckPoint)
			break;
	}

	//
	// Stop the Service
	if (ssStatus.dwCurrentState != SERVICE_STOPPED)
	{
		SKeysError(hDlg, IDS_SK_ERR_STOP);
		goto Exit;
	}

	//
	// Delete the Service
	if (!DeleteService(schService))
	{
		SKeysError(hDlg, IDS_SK_ERR_DELETE);
		goto Exit;
	}

	SerialKeysEnabled = FALSE;
	LoadString (hInst,IDS_SK_INSTALL,(LPSTR)sbuf1,245);
	SetDlgItemText(hDlg, IDC_INST_REMOVE,sbuf1);

Exit:
	CloseServiceHandle(schService);
	CloseServiceHandle(schSCManager);
	return;
}

/****************************************************************************/
void SKeysError(HWND hDlg, int Error)
{
   char sbuf1[255];
   char sbuf2[255];

	LoadString (hInst,IDS_SK_TITLE,(LPSTR)sbuf1,245);
	LoadString (hInst,Error,(LPSTR)sbuf2,245);
	MessageBox (hDlg, (LPSTR)sbuf2,(LPSTR)sbuf1, MB_OK|MB_ICONHAND);
}


/****************************************************************************/
// Enable or Disable Dialog Controlls
void SetDialogItems(HWND hDlg)
{
	EnableWindow(GetDlgItem(hDlg,ID_OFF),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_ON ),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_300),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_600),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_1200),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_2400),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_4800),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_9600),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_BAUD_19200),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_COM1),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_COM2),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_COM3),SerialKeysEnabled);
	EnableWindow(GetDlgItem(hDlg,ID_COM4),SerialKeysEnabled);

}


/****************************************************************************/
BOOL LoadLBStrings(hwndLB, pSSInfo, cEffects)
HWND hwndLB;
PSSINFO pSSInfo;
UINT cEffects;
{
    UINT i, index;

    for (i = 0; i < cEffects; i++) {
	LoadString(hInst,
		   pSSInfo[i].idResource,
		   (LPTSTR)pSSInfo[i].szEffect,
		   MAXEFFECTSTRING
		   );
    index = (UINT)SendMessage(hwndLB,
                              CB_ADDSTRING,
                              0,
                              (LPARAM)(LPTSTR)pSSInfo[i].szEffect
                             );
	if (index == CB_ERR || index == CB_ERRSPACE) {
	    return FALSE;
	}
	pSSInfo[i].idDialog = index;
    }
    return TRUE;
}

/****************************************************************************

    FUNCTION:    AdjustSoundSentry(HWND, unsigned, WORD, LONG)

    PURPOSE:

    COMMENTS:


****************************************************************************/

INT_PTR APIENTRY AdjustSoundSentry(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    SOUNDSENTRY *lp_SoundSentry_Param;
    char   *lpReturnType;
    LRESULT i;
    static BOOL fMyQuestion_Save;

    lp_SoundSentry_Param = &SoundSentryParam;
    lpReturnType = &lpReturn;
    switch (message) {
    case WM_COMMAND:
	switch (LOWORD(wParam)) {

	case ID_OFF:
	case ID_ON:
	    CheckRadioButton(hDlg, ID_OFF, ID_ON, LOWORD(wParam));
	    SetFlag(SoundSentryParam.dwFlags,SSF_SOUNDSENTRYON,OnOffTable[wParam-ID_OFF]);
	    fMyQuestion_Save = 1;
	    break;
	case ID_SS_WINDOWS:
	    if (HIWORD(wParam) == CBN_SELCHANGE) {
		i = SendDlgItemMessage(hDlg, ID_SS_WINDOWS, CB_GETCURSEL, 0, 0);
		SoundSentryParam.iWindowsEffect = aSSWin[i].iEffectFlag;
		fMyQuestion_Save =1;
	    }
	    return FALSE;
	    break;

	//
	// Full screen text and graphics modes are only available on the
	// x86 platform.
	//
	case ID_SS_TEXTMODE:
	    if (HIWORD((DWORD)wParam) == CBN_SELCHANGE) {
		i = SendDlgItemMessage(hDlg, ID_SS_TEXTMODE, CB_GETCURSEL, 0, 0);
		SoundSentryParam.iFSTextEffect = aSSText[i].iEffectFlag;
		fMyQuestion_Save =1;
	    }
	    return FALSE;
	    break;

	case ID_SS_GRAPHICSMODE:
	    if (HIWORD((DWORD)wParam) == CBN_SELCHANGE) {
		i = SendDlgItemMessage(hDlg, ID_SS_GRAPHICSMODE, CB_GETCURSEL, 0, 0);
		SoundSentryParam.iFSGrafEffect = aSSGraphics[i].iEffectFlag;
		fMyQuestion_Save =1;
	    }
	    return FALSE;
	    break;

	case IDOK:
	    SoundSentryParam.cbSize = sizeof(SoundSentryParam);
	    SystemParametersInfo(
		SPI_SETSOUNDSENTRY,
		0, // sizeof(SoundSentryParam),
		lp_SoundSentry_Param,
		0);
	    SoundSentryhWnd = NULL;
	    if( fMyQuestion_Save ) fQuestion_Save = 1;
	    EndDialog(hDlg, IDCANCEL);
	    break;

	case IDCANCEL:
	    SoundSentryhWnd = NULL;
	    EndDialog(hDlg, IDCANCEL);
	    break;
	default:
	    return (FALSE);
	}
	return(TRUE);
	break;

    case WM_INITDIALOG:                            /* Request to initalize        */

	SoundSentryhWnd = hDlg;
	fMyQuestion_Save = 0;

	SoundSentryParam.cbSize = sizeof(SoundSentryParam);
	SystemParametersInfo(
	    SPI_GETSOUNDSENTRY,
	    0, // sizeof(SoundSentryParam),
	    lp_SoundSentry_Param,
	    0);

	// for (i=0;i<2;i++) {
	//     if (OnOffTable[i] == TestFlag(SoundSentryParam.dwFlags,SSF_SOUNDSENTRYON) ) break;
	// }
	// CheckRadioButton(hDlg, ID_OFF, ID_ON, ID_OFF + i);
	CheckRadioButton(hDlg, ID_OFF, ID_ON, TestFlag(SoundSentryParam.dwFlags,SSF_SOUNDSENTRYON) ? ID_ON : ID_OFF );

	hSSListBox = GetDlgItem(hDlg, ID_SS_WINDOWS);
	if (!LoadLBStrings(hSSListBox, &aSSWin[0], cWindowsEffects)) {
	    EndDialog(hDlg, IDCANCEL);
	    return FALSE;
	}
	for (i = 0; i < (LPARAM)cWindowsEffects; i++) {
	    if (aSSWin[i].iEffectFlag == SoundSentryParam.iWindowsEffect) {
		SendMessage(hSSListBox, CB_SETCURSEL, aSSWin[i].idDialog, 0);
		break;
	    }
	}

	//
	// Full screen text and graphics modes are only available on the
	// x86 platform.
	//
	hSSListBox = GetDlgItem(hDlg, ID_SS_TEXTMODE);
	if (!LoadLBStrings(hSSListBox, &aSSText[0], cTextEffects)) {
	    EndDialog(hDlg, IDCANCEL);
	    return FALSE;
	}
	for (i = 0; i < (LPARAM)cTextEffects; i++) {
	    if (aSSText[i].iEffectFlag == SoundSentryParam.iFSTextEffect) {
		SendMessage(hSSListBox, CB_SETCURSEL, aSSText[i].idDialog, 0);
		break;
	    }
	}

	hSSListBox = GetDlgItem(hDlg, ID_SS_GRAPHICSMODE);
	if (!LoadLBStrings(hSSListBox, &aSSGraphics[0], cGraphicEffects)) {
	    EndDialog(hDlg, IDCANCEL);
	    return FALSE;
	}
	for (i = 0; i < (LPARAM)cGraphicEffects; i++) {
	    if (aSSGraphics[i].iEffectFlag == SoundSentryParam.iFSGrafEffect) {
		SendMessage(hSSListBox, CB_SETCURSEL, aSSGraphics[i].idDialog, 0);
		break;
	    }
	}

	return(TRUE);
	    break;


    default:
	break;

    }
    return (FALSE);
}

/*-------------------------------------------------------------------------*/
/*                                                                         */
/*    OkMsgBox( szCaption, szFormat )                                      */
/*                                                                         */
/*-------------------------------------------------------------------------*/

void OkMsgBox( LPSTR szCaption, LPSTR szFormat,... )
    {
    char szBuffer[256];
    va_list vaList;


    //
    // Use va_start, va_end to manage vaList
    //
    va_start(vaList, szFormat);
    wvsprintf( szBuffer, szFormat, vaList );
    va_end(vaList);

    MessageBox( NULL, (LPSTR)szBuffer, (LPSTR)szCaption, MB_OK );
    }

void AssertBool( LPSTR sz, LPBOOL lpf )
    {
    if( *lpf != 0 && *lpf != 1 )
	{
// #ifdef DEBUG
	OkMsgBox( "Access Utility",
		  "Assertion Failed: boolean variable '%s' has value %X",
		  sz, *lpf );
// #endif
	*lpf = 1;
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\access.h ===
/****************************************************************************

    ACCESS.H

    This file defines the definitions for in the ACCESS.C program

****************************************************************************/

/* declaration of procedures and functions */

/* from ACCESS.C */

void MakeHelpPathName(char*);                    /* Function deriving help file path */
LRESULT APIENTRY hookDialogBoxMsg(int,WPARAM,LPARAM);    /* Function to trap for F1 in dialog boxes */
//HOOKPROC hookDialogBoxMsg(int,WPARAM,LPARAM);    /* Function to trap for F1 in dialog boxes */

int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
LRESULT APIENTRY AccessWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY About(HWND, UINT, WPARAM, LPARAM);
short OkAccessMessage (HWND, WORD);
short AccessMessageBox (HWND hWnd, WORD wnumber, UINT iFlags );
void OkAccessMsg( HWND hWnd, WORD wMsg,...);

/* from DIALOGS.C */
/* dialogs procedure routines */

INT_PTR APIENTRY AdjustSticKeys(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustFilterKeys(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustMouseKeys(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustTimeOut(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustSerialKeys(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustToggleKeys(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustShowSounds(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AdjustSoundSentry(HWND, UINT, WPARAM, LPARAM);
void OkFiltersMessage (HWND, WORD);

extern INT fShowSoundsOn;

/* from INIT.C */

void  InitFeatures(HWND,HANDLE);
void  SaveFeatures(void);
BOOL MySystemParametersInfo( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);

/* from REG.C */

BOOL InitializeUserRegIfNeeded( void );
DWORD SaveDefaultSettings( void );



#define  IDS_SAVE_TO_WIN_INI    1
#define  IDS_CLOSE_MESSAGE      2
#define  IDS_FILTERS_1          3
#define  IDS_FILTERS_2          4
#define  IDS_FILTERS_3          5
//#define    IDS_FILTERS_4        6
//#define    IDS_FILTERS_5        7

#define  IDS_HELP_MESSAGE       8
#define  IDS_TITLE              9

#define  IDS_FILTERS_6         10
#define  IDS_INIT_1            11
#define  IDS_INIT_2            14
#define  IDS_SHOW_1            12
#define  IDS_SHOW_2            13

#define  IDS_MENU_MESSAGE      15
#define  IDS_KYBDBAD_MESSAGE   16
#define  IDS_MOUBAD_MESSAGE    17

#define  IDS_NONE              18

#define  IDS_SS_WINCAPTION     20
#define  IDS_SS_WINWINDOW      21
#define  IDS_SS_WINDESKTOP     22

#define  IDS_SS_FSBORDER       30
#define  IDS_SS_FSSCREEN       31

#define  IDS_SS_GRAPHICSBORDER 40
#define  IDS_SS_GRAPHICSSCREEN 41

#define  IDS_SAVE_DISABLED     42
#define  IDS_SK_DISABLED       43

#define  IDS_SAVE_DEFAULT       44
#define  IDS_ACCESS_DENIED      45
#define  IDS_ERROR_CODE         46

#define  IDS_SAVE_FIRST         60
#define  IDS_BAD_OS_VER         61
#define  IDS_UNABLE_TO_START    62
#define  IDS_BAD_SK_PORT        63
#define  IDS_BAD_SK_BAUD        64

#define  MAXEFFECTSTRING      128

#define  Stickeys     800
#define  FilterKeys   801
#define  MouseKeys    802
#define  SerialKeys   803
#define  TimeOut      804
#define  ToggleKeys   805
#define  ShowSounds   806
#define  AboutBox     807


// these should be in winuser.h but are not yet in Chicago project.
#ifndef WF_NONE
/*
 * Define window flash parameters
 */
#define WF_NONE     0
#define WF_TITLE    1
#define WF_WINDOW   2
#define WF_DISPLAY  3

/*
 * Define graphic flash parameters
 */
#define GF_NONE     0
#define GF_DISPLAY  3

/*
 * Define text flash parameters
 */
#define TF_NONE      0
#define TF_CHARS     1
#define TF_BORDER    2
#define TF_DISPLAY   3

#endif

#ifndef GRAPHICSMODE
#define GRAPHICSMODE
#endif
#ifndef BORDERFLASH
#define BORDERFLASH
#endif
#ifndef i386
#define i386
#endif
#ifndef NOSAVE
//#define NOSAVE
#endif

typedef struct tagMYSERIALKEYS
    {
    UINT    cbSize;
    UINT    iComName;
    UINT    iBaudRate;
    UINT    iCurrentComName;
    UINT    iCurrentBaudRate;
    BOOL    fCommOpen;
    BOOL    fSerialKeysOn;
    } MYSERIALKEYS, *LPMYSERIALKEYS;

// #define MYSK    YesHackIt

#ifndef SPI_GETSERIALKEYS
#define SPI_GETSERIALKEYS           62
#endif
#ifndef SPI_SETSERIALKEYS
#define SPI_SETSERIALKEYS           63
#endif

// #ifndef SERKF_SERIALKEYSON
// typedef struct tagSERIALKEYS
// {
//     DWORD   cbSize;
//     DWORD   dwFlags;
//     LPSTR   lpszActivePort;
//     LPSTR   lpszPort;
//     DWORD   iBaudRate;
//     DWORD   iPortState;
//     DWORD   iActive;
// }   SERIALKEYS, *LPSERIALKEYS;
//
// /* flags for SERIALKEYS dwFlags field */
// #define SERKF_SERIALKEYSON  0x00000001
// #define SERKF_AVAILABLE     0x00000002
// #define SERKF_INDICATOR     0x00000004
// #endif

#ifndef HCF_HIGHCONTRASTON
typedef struct tagHIGHCONTRAST      
{                                   
    DWORD   cbSize;
    DWORD   dwFlags;
}   HIGHCONTRAST, *LPHIGHCONTRAST;

/* flags for HIGHCONTRAST dwFlags field */
#define HCF_HIGHCONTRASTON  0x00000001
#define HCF_AVAILABLE       0x00000002
#define HCF_HOTKEYACTIVE    0x00000004
#define HCF_CONFIRMHOTKEY   0x00000008
#define HCF_HOTKEYSOUND     0x00000010
#define HCF_INDICATOR       0x00000020
#define HCF_HOTKEYAVAILABLE 0x00000040
#endif

// SetFlag is a statement
#define SetFlag( dw, m, f ) if(f) { dw |= m; } else { dw &= ~m; }
// TestFlag is an operator
#define TestFlag( dw, m ) ( (dw & m) ? TRUE : FALSE )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\menu.h ===
/****************************************************************************

    MENU.H

    This file defines the definitions for MENU items

****************************************************************************/

/* file menu items */

#define        IDM_SAVE_TO_WIN_INI     603
#define        IDM_SAVE_DEFAULT        608
#define        IDM_EXIT                604
#define        IDM_ABOUT               605
#define        IDM_HELP                606
#define        IDM_HELP_START          607

/* adjust menu items */

#define        IDM_ADJUST_STICKEYS     610
#define        IDM_ADJUST_FILTERKEYS   611
#define        IDM_ADJUST_MOUSEKEYS    612
#define        IDM_ADJUST_TIMEOUT      613
#define        IDM_ADJUST_SERIALKEYS   614
#define        IDM_ADJUST_TOGGLEKEYS   615
#define        IDM_ADJUST_SHOWSOUNDS   616
#define        IDM_ADJUST_SOUNDSENTRY  617


/* help menu items */

#define        IDM_HELP_STICKYKEYS     511
#define        IDM_HELP_FILTERKEYS     512
#define        IDM_HELP_MOUSEKEYS      513
#define        IDM_HELP_TOGGLEKEYS     514
#define        IDM_HELP_SERIALKEYS     515
#define        IDM_HELP_TIMEOUT        516
#define        IDM_HELP_SHOWSOUNDS     517
#define        IDM_HELP_SOUNDSENTRY    518

#define        HELPID_HELP             526

#define        EXE_NAME_MAX_SIZE       128
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\dialogs.h ===
/****************************************************************************

	DIALOGS.H

	This file defines the definitions for handling the dialogs.

****************************************************************************/

#define		ID_COM1					400
#define		ID_COM2					401
#define		ID_COM3					402
#define		ID_COM4					403


#define		ID_BAUD_300				410
#define		ID_BAUD_600				411
#define		ID_BAUD_1200			412
#define		ID_BAUD_2400			413
#define		ID_BAUD_4800			414
#define		ID_BAUD_9600			415
#define		ID_BAUD_19200			416

#define		ID_MK_TIME_1			420
#define		ID_MK_TIME_TEXT			421
#define		ID_MK_TIME_3			422
#define		ID_MK_TIME_4			423
#define		ID_MK_TIME_5			424

#define		ID_MK_SPEED_1			430
#define		ID_MK_SPEED_TEXT		431
#define		ID_MK_SPEED_3			432
#define		ID_MK_SPEED_4			433
#define		ID_MK_SPEED_5			434

#define		ID_KB_ACCEPT_0			440
#define		ID_KB_ACCEPT_1			441
#define		ID_KB_ACCEPT_TEXT		442
#define		ID_KB_ACCEPT_3			443
#define		ID_KB_ACCEPT_4			444
#define		ID_KB_ACCEPT_5			445

#define		ID_USER_OPTION1			447
#define		ID_USER_OPTION2			448
#define   	ID_ON_OFF_CLICK			449

#define		ID_KB_DELAY_0			450
#define		ID_KB_DELAY_1			451
#define		ID_KB_DELAY_TEXT		452
#define		ID_KB_DELAY_3			453
#define		ID_KB_DELAY_4			454
#define		ID_KB_DELAY_5			455

#define		ID_KB_RATE_0			460
#define		ID_KB_RATE_TEXT			461
#define		ID_KB_RATE_2			462
#define		ID_KB_RATE_3			463
#define		ID_KB_RATE_4			464
#define		ID_KB_RATE_5			465

#define		ID_OFF					470
#define		ID_ON					471
#define		ID_FLAG_1				472
#define		ID_FLAG_2				473

#define		ID_TIMEOUT_1			480
#define		ID_TIMEOUT_2			481
#define		ID_TIMEOUT_3			482
#define		ID_TIMEOUT_4			483

#define		ID_ON_OFF_FEEDBACK		490
#define		ID_TRISTATE				491
#define		ID_TWOKEYS_TURNOFF		492
#define		ID_STATE_FEEDBACK		493

#define		ID_KB_BOUNCE_0			500
#define		ID_KB_BOUNCE_1			501
#define		ID_KB_BOUNCE_TEXT		502
#define		ID_KB_BOUNCE_3			503
#define		ID_KB_BOUNCE_4			504
#define		ID_KB_BOUNCE_5			505

#define		ID_KB_TEST_0			530
#define		ID_KB_TEST_1			531
#define		ID_SHOW_SOUND_SCREEN	532
#define		ID_SHOW_SOUND_CAPTION	533
#define		ID_SHOW_SOUND_TYPE		534

#define     ID_SS_WINDOWS           540
#define     ID_SS_TEXTMODE          541
#define     ID_SS_GRAPHICSMODE      542
#define ID_HOTKEY_ACTIVATION        489
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\init.c ===
/****************************************************************************

    INIT.C

    This file handles the parts related to initializing the features based
    on keynames and values in the WIN.INI file.

****************************************************************************/

#include    <string.h>
#include    <stdlib.h>
#include    "windows.h"
#include    "Dialogs.h"
#include    "skeys.h"
#include    "access.h"

/****************************************************************************

    Declaration of externs

****************************************************************************/

                                                    /* from DIALOGS.C */
extern FILTERKEYS    FilterKeysParam;
extern STICKYKEYS    StickyKeysParam;
extern MOUSEKEYS     MouseKeysParam;
extern TOGGLEKEYS    ToggleKeysParam;
extern ACCESSTIMEOUT TimeOutParam;
extern SOUNDSENTRY   SoundSentryParam;
extern SERIALKEYS    SerialKeysParam;
extern char          SK_ActivePort[MAX_PATH];

extern	BOOL IsSerialKeysInstalled();

#ifdef MYSK
extern MYSERIALKEYS  MySerialKeysParam;
#endif
extern INT           fShowSoundsOn;
// extern BOOL fSaveStickyKeys;
// extern BOOL fSaveFilterKeys;
// extern BOOL fSaveMouseKeys;
// extern BOOL fSaveToggleKeys;
// extern BOOL fSaveTimeOut;
// extern BOOL fSaveSerialKeys;
// extern BOOL fSaveSoundSentry;
// extern BOOL fSaveShowSounds;

void InitFilterKeys(HWND,HANDLE);

/* extern    int       fno_mouse;  */
                                                    /* from GIDI-INI.C */

extern    HANDLE    hInst;

/****************************************************************************

    Declaration of variables

****************************************************************************/

int OkInitMessage (HWND hWnd, WORD wnumber)

{
    int   ianswer;
    char sreadbuf[255];
    char    sbuf[45];
    {

    LoadString (hInst,wnumber,(LPSTR)sreadbuf,245);
    LoadString (hInst,IDS_TITLE,(LPSTR)sbuf,35);
    ianswer = MessageBox (hWnd, (LPSTR)sreadbuf, (LPSTR)sbuf, MB_SYSTEMMODAL | MB_YESNO|MB_ICONHAND);
    }
return(ianswer);
}


/****************************************************************************

    FUNCTION:    InitFilterKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitFilterKeys(hWnd,hInst)
HWND hWnd;                          /* window handle */
HANDLE    hInst;                    /* current instance */
{
    BOOL fStatus;
    FILTERKEYS    *lp_FilterKeys_Param;
    lp_FilterKeys_Param = &FilterKeysParam;

    FilterKeysParam.cbSize = sizeof(FilterKeysParam);
    fStatus = SystemParametersInfo(
                  SPI_GETFILTERKEYS,
                  0,
                  lp_FilterKeys_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitStickeyKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitStickeyKeys()
{
    BOOL fStatus;
    STICKYKEYS        *lp_StickyKeys_Param;
    lp_StickyKeys_Param = &StickyKeysParam;

    StickyKeysParam.cbSize = sizeof(StickyKeysParam);
    fStatus = SystemParametersInfo(
                  SPI_GETSTICKYKEYS,
                  0,
                  lp_StickyKeys_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitMouseKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitMouseKeys()
{
    BOOL fStatus;
    MOUSEKEYS    *lp_MouseKeys_Param;

    lp_MouseKeys_Param = &MouseKeysParam;
    MouseKeysParam.cbSize = sizeof(MouseKeysParam);
    fStatus = SystemParametersInfo(
                  SPI_GETMOUSEKEYS,
                  0,
                  lp_MouseKeys_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitToggleKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitToggleKeys()
{
    BOOL fStatus;
    TOGGLEKEYS    *lp_ToggleKeys_Param;
    lp_ToggleKeys_Param = &ToggleKeysParam;


    ToggleKeysParam.cbSize = sizeof(ToggleKeysParam);
    fStatus = SystemParametersInfo(
                  SPI_GETTOGGLEKEYS,
                  0,
                  lp_ToggleKeys_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitTimeOut()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitTimeOut()
{
    BOOL fStatus;
    ACCESSTIMEOUT        *lp_TimeOut_Param;
    lp_TimeOut_Param = &TimeOutParam;


    TimeOutParam.cbSize = sizeof(TimeOutParam);
    fStatus = SystemParametersInfo(
                  SPI_GETACCESSTIMEOUT,
                  0,
                  lp_TimeOut_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitSerialKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitSerialKeys()
{

#ifdef MYSK
    BOOL fStatus;

    MYSERIALKEYS          *lp_SerialKeys_Param;
    lp_SerialKeys_Param = &MySerialKeysParam;
    MySerialKeysParam.cbSize = sizeof(MySerialKeysParam);
    fStatus = SystemParametersInfo(
                  SPI_GETSERIALKEYS,
                  0,
                  lp_SerialKeys_Param,
                  0);
    // hack around -1 returned by VxD here if not turned on.
    if( MySerialKeysParam.iComName == -1 )
        MySerialKeysParam.iComName =  0;

#else

	SerialKeysParam.cbSize = sizeof(SerialKeysParam);
	SerialKeysParam.lpszActivePort = SK_ActivePort;
	SerialKeysParam.lpszPort = NULL;

	SKEY_SystemParametersInfo
	(
		SPI_GETSERIALKEYS,
                0,
		&SerialKeysParam,0
	);
#endif
}

/****************************************************************************

    FUNCTION:    InitShowSounds()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitShowSounds()
{
    BOOL fStatus;

    fStatus = SystemParametersInfo(
                  SPI_GETSHOWSOUNDS,
                  sizeof(fShowSoundsOn),
                  &fShowSoundsOn,
                  0);
}

/****************************************************************************

    FUNCTION:    InitSoundSentry()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitSoundSentry()
{
    BOOL fStatus;
    SOUNDSENTRY        *lp_SoundSentry_Param;
    lp_SoundSentry_Param = &SoundSentryParam;

    SoundSentryParam.cbSize = sizeof(SoundSentryParam);
    fStatus = SystemParametersInfo(
                  SPI_GETSOUNDSENTRY,
                  0,
                  lp_SoundSentry_Param,
                  0);

}

/****************************************************************************

    FUNCTION:    InitFeatures()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void InitFeatures(hWnd,hInst)
HWND hWnd;                        /* window handle                */
HANDLE    hInst;                    /* current instance                */
{
    InitFilterKeys(hWnd,hInst);
    InitStickeyKeys();
    InitMouseKeys();
    InitToggleKeys();
    InitTimeOut();
    InitSerialKeys();
    InitSoundSentry();
    InitShowSounds();

}

/****************************************************************************

    FUNCTION:    SaveFilterKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveFilterKeys()
{
    FILTERKEYS    *lp_FilterKeys_Param;
    lp_FilterKeys_Param = &FilterKeysParam;

    SystemParametersInfo(
        SPI_GETFILTERKEYS,
        0,
        lp_FilterKeys_Param,
        0);

    SystemParametersInfo(
        SPI_SETFILTERKEYS,
        0,
        lp_FilterKeys_Param,
        1);

}

/****************************************************************************

    FUNCTION:    SaveStickeyKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveStickeyKeys()
{
    STICKYKEYS        *lp_StickyKeys_Param;
    lp_StickyKeys_Param = &StickyKeysParam;

    SystemParametersInfo(
        SPI_GETSTICKYKEYS,
        0,
        lp_StickyKeys_Param,
        0);

    SystemParametersInfo(
        SPI_SETSTICKYKEYS,
        0,
        lp_StickyKeys_Param,
        1);
}

/****************************************************************************

    FUNCTION:    SaveMouseKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveMouseKeys()
{
    MOUSEKEYS    *lp_MouseKeys_Param;
    lp_MouseKeys_Param = &MouseKeysParam;

    SystemParametersInfo(
        SPI_GETMOUSEKEYS,
        0,
        lp_MouseKeys_Param,
        0);

    SystemParametersInfo(
        SPI_SETMOUSEKEYS,
        0,
        lp_MouseKeys_Param,
        1);
}

/****************************************************************************

    FUNCTION:    SaveToggleKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveToggleKeys()
{
    TOGGLEKEYS    *lp_ToggleKeys_Param;
    lp_ToggleKeys_Param = &ToggleKeysParam;


    SystemParametersInfo(
        SPI_GETTOGGLEKEYS,
        0,
        lp_ToggleKeys_Param,
        0);

    SystemParametersInfo(
        SPI_SETTOGGLEKEYS,
        0,
        lp_ToggleKeys_Param,
        1);
}

/****************************************************************************

    FUNCTION:    SaveTimeOut()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveTimeOut()
{
    ACCESSTIMEOUT        *lp_TimeOut_Param;

    lp_TimeOut_Param = &TimeOutParam;


    SystemParametersInfo(
        SPI_GETACCESSTIMEOUT,
        0,
        lp_TimeOut_Param,
        0);

    SystemParametersInfo(
        SPI_SETACCESSTIMEOUT,
        0,
        lp_TimeOut_Param,
        1);
}

/****************************************************************************

    FUNCTION:    SaveSerialKeys()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveSerialKeys()
{
#ifdef MYSK
    MYSERIALKEYS           *lp_SerialKeys_Param;
    lp_SerialKeys_Param = &MySerialKeysParam;

    SystemParametersInfo(
        SPI_GETSERIALKEYS,
        sizeof(MySerialKeysParam),
        lp_SerialKeys_Param,
        0);

    SystemParametersInfo(
        SPI_SETSERIALKEYS,
        sizeof(MySerialKeysParam),
        lp_SerialKeys_Param,
        1);

#else

    SERIALKEYS           *lp_SerialKeys_Param;
	int Ret = 0;

    lp_SerialKeys_Param = &SerialKeysParam;
	

    Ret = SKEY_SystemParametersInfo(
        SPI_GETSERIALKEYS,
        sizeof(SerialKeysParam),
        lp_SerialKeys_Param, 0);

    Ret = SKEY_SystemParametersInfo(
        SPI_SETSERIALKEYS,
        sizeof(SerialKeysParam),
        lp_SerialKeys_Param, 1);
#endif

}
/****************************************************************************

    FUNCTION:    SaveShowSounds()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveShowSounds()
{
    // ShowSounds unlike the others is a simple boolean value, so
    // SystemParametersInfo takes bool in wParam on SET, and
    // takes ptr to bool in lParam on GET.

    SystemParametersInfo(
        SPI_GETSHOWSOUNDS,
        0,
        &fShowSoundsOn,
        0);

    SystemParametersInfo(
        SPI_SETSHOWSOUNDS,
        fShowSoundsOn,
        0,
        1);
}

/****************************************************************************

    FUNCTION:    SaveSoundSentry()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveSoundSentry()
{
    SOUNDSENTRY        *lp_SoundSentry_Param;
    lp_SoundSentry_Param = &SoundSentryParam;


    SystemParametersInfo(
        SPI_GETSOUNDSENTRY,
        0,
        lp_SoundSentry_Param,
        0);

    SystemParametersInfo(
        SPI_SETSOUNDSENTRY,
        0,
        lp_SoundSentry_Param,
        1);
}

/****************************************************************************

    FUNCTION:    SaveFeatures()

    PURPOSE:

    COMMENTS:


****************************************************************************/

void SaveFeatures()
{
    SaveFilterKeys();
    SaveStickeyKeys();
    SaveMouseKeys();
    SaveToggleKeys();
    SaveTimeOut();
    SaveSerialKeys();
    SaveSoundSentry();
    SaveShowSounds();
}

/////////////////////////////////////////////////////////////////////
#ifdef never
BOOL MySystemParametersInfo(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni)
    {
    BOOL b;
    switch( uiAction )
        {
        case SPI_GETSTICKYKEYS:
        case SPI_SETSTICKYKEYS:
                ((LPSTICKYKEYS)pvParam)->fStickyKeysOn =
                ((LPSTICKYKEYS)pvParam)->fStickyKeysOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPSTICKYKEYS)pvParam)->fStickyKeysOn =
                ((LPSTICKYKEYS)pvParam)->fStickyKeysOn ? 1 : 0;
                return b;

        case SPI_GETMOUSEKEYS:
        case SPI_SETMOUSEKEYS:
                ((LPMOUSEKEYS)pvParam)->fMouseKeysOn =
                ((LPMOUSEKEYS)pvParam)->fMouseKeysOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPMOUSEKEYS)pvParam)->fMouseKeysOn =
                ((LPMOUSEKEYS)pvParam)->fMouseKeysOn ? 1 : 0;
                return b;

        case SPI_GETTOGGLEKEYS:
        case SPI_SETTOGGLEKEYS:
                ((LPTOGGLEKEYS)pvParam)->fToggleKeysOn =
                ((LPTOGGLEKEYS)pvParam)->fToggleKeysOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPTOGGLEKEYS)pvParam)->fToggleKeysOn =
                ((LPTOGGLEKEYS)pvParam)->fToggleKeysOn ? 1 : 0;
                return b;

        case SPI_GETFILTERKEYS:
        case SPI_SETFILTERKEYS:
                ((LPFILTERKEYS)pvParam)->fFilterKeysOn =
                ((LPFILTERKEYS)pvParam)->fFilterKeysOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPFILTERKEYS)pvParam)->fFilterKeysOn =
                ((LPFILTERKEYS)pvParam)->fFilterKeysOn ? 1 : 0;
                return b;

        case SPI_GETSOUNDSENTRY:
        case SPI_SETSOUNDSENTRY:
                ((LPSOUNDSENTRY)pvParam)->fSoundSentryOn =
                ((LPSOUNDSENTRY)pvParam)->fSoundSentryOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPSOUNDSENTRY)pvParam)->fSoundSentryOn =
                ((LPSOUNDSENTRY)pvParam)->fSoundSentryOn ? 1 : 0;
                return b;

        case SPI_GETACCESSTIMEOUT:
        case SPI_SETACCESSTIMEOUT:
                ((LPACCESSTIMEOUT)pvParam)->fTimeOutOn =
                ((LPACCESSTIMEOUT)pvParam)->fTimeOutOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPACCESSTIMEOUT)pvParam)->fTimeOutOn =
                ((LPACCESSTIMEOUT)pvParam)->fTimeOutOn ? 1 : 0;
                return b;

        case SPI_GETSERIALKEYS:
        case SPI_SETSERIALKEYS:
                ((LPSERIALKEYS)pvParam)->fSerialKeysOn =
                ((LPSERIALKEYS)pvParam)->fSerialKeysOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPSERIALKEYS)pvParam)->fSerialKeysOn =
                ((LPSERIALKEYS)pvParam)->fSerialKeysOn ? 1 : 0;
                return b;

#ifdef NEVER
        case SPI_GETACCESSHIGHCONTRAST:
        case SPI_SETACCESSHIGHCONTRAST:
                ((LPACCESSHIGHCONTRAST)pvParam)->fHighContrastOn =
                ((LPACCESSHIGHCONTRAST)pvParam)->fHighContrastOn ? -1 : 0;
                b = SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
                ((LPACCESSHIGHCONTRAST)pvParam)->fHighContrastOn =
                ((LPACCESSHIGHCONTRAST)pvParam)->fHighContrastOn ? 1 : 0;
                return b;
#endif
        default:
                return SystemParametersInfo( uiAction, uiParam, pvParam, fWinIni );
        }
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\skeys.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SKEYS.H
 *
 * PURPOSE:			The file contains data structures for the 
 *					transmission of information between the 
 *					Serial Keys Application and and the DLL.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#define SK_SPI_INITUSER -1

BOOL APIENTRY SKEY_SystemParametersInfo(
    UINT uAction, UINT uParam, LPSERIALKEYS lpvParam, BOOL fWinIni);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by ACCESS.RC
//
#define IDS_SK_ERR_CREATE               47
#define IDS_SK_ERR_OPEN                 48
#define IDS_SK_TITLE                    49
#define IDS_SK_INSTALL                  50
#define IDS_SK_REMOVE                   51
#define IDS_SK_ERR_DELETE               52
#define IDS_SK_ERR_START                53
#define IDS_SK_ERR_STOP                 54
#define IDS_SK_ERR_ACCESS               55
#define IDS_SK_ERR_FAILSCM              56
#define IDS_SK_ERR_FAILFIND             57
#define IDS_SK_ERR_REMOVE               58
#define ID_BAUD_19200                   416
// #define WINVER                          0x0300
#define IDC_INST_REMOVE                 1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         102
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\access\reg.c ===
/*
1. on startup, check to see if we're administrator
  a) use RegOpenKeyEx on HKEY_USERS\.DEFAULT\Software with read/write
    access writes.  if it fails, we're not administrator
  b) if not, grey menu option
2. on startup
  a) use RegOpenKeyEx on HKEY_CURRENTUSER\Software...
  b) if it fails, create these keys with default values.
3. creating keys
  a) RegCreateKeyEx
  b) RegSetValue
  c) RegCloseKey

*/

#include "windows.h"

BOOL InitializeUserRegIfNeeded( void );
BOOL AreUserRegEntriesWritable( void );
BOOL DoAccessRegEntriesExist( HKEY hkeyRoot );
BOOL IsAdministrator( void );
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam );
LONG OpenAccessRegKeyW( HKEY hkeyRoot, LPSTR lpstr, PHKEY phkey );
BOOL CloseAccessRegKey( HKEY hkey );
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue );
BOOL SetDefaultRegEntries( HKEY hkeyRoot );

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey );
DWORD SaveDefaultSettings( void );


char szAccessRegPath[] = "Control Panel\\Accessibility";

/********************************************************************/
BOOL InitializeUserRegIfNeeded( void )
    {
    BOOL f = TRUE;
    DWORD dwOS;
    WORD wWinVer;
    BOOL fNT;

    dwOS = GetVersion();
    fNT = (HIWORD(dwOS) & 0x8000) == 0;
    wWinVer = LOWORD(GetVersion());

    // do the following only on Windows NT Version 3.5 (0x3203)
    // or Version 3.51 (0x3303).
    // on Chicago this is taken care of by the Enable VxD.
    if (fNT)
        {
        f = DoAccessRegEntriesExist( HKEY_CURRENT_USER );
        if( f != TRUE )
            return SetDefaultRegEntries( HKEY_CURRENT_USER );
        }
    return f;
    }

/********************************************************************/
// NOT CURRENTLY USED
BOOL AreUserRegEntriesWritable( void )
    {
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\StickyKeys" );
    return CheckRegEntry( HKEY_USERS, sz, KEY_ALL_ACCESS );
    }

/********************************************************************/
// NOT CURRENTLY USED
BOOL IsAdministrator( void )
    {
    return CheckRegEntry( HKEY_USERS, "\\Software", KEY_ALL_ACCESS );
    }

/********************************************************************/
BOOL DoAccessRegEntriesExist( HKEY hkeyRoot )
    {
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\StickyKeys" );
    return CheckRegEntry( hkeyRoot, sz, KEY_READ ); // execute means readonly
    }

/********************************************************************/
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam )
    {
    LONG dw;
    HKEY hkey;
    dw = RegOpenKey( hkeyRoot, lpsz, &hkey );
 // dw = RegOpenKeyEx( hkeyRoot, lpsz, 0, sam, &hkey );
    if( dw == ERROR_SUCCESS )
	{
	if( RegCloseKey( hkey ) != ERROR_SUCCESS )
	    {
	    //  _assert
	    }
	return TRUE;
	}
    else
	return FALSE;
    }

/********************************************************************/
LONG OpenAccessRegKeyW( HKEY hkeyRoot, LPSTR lpstr, PHKEY phkey )
    {
    LONG dw;
    LONG dwDisposition;
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\" );
    strcat( sz, lpstr );
//    dw = RegOpenKey( hkeyRoot, sz, phkey );
//    dw = RegOpenKey( hkeyRoot, "\\Software", phkey );
//    dw = RegOpenKey( hkeyRoot, "\\FOOBAR", phkey );
//    dw = RegOpenKey( hkeyRoot, "Software", phkey );
//    dw = RegOpenKey( hkeyRoot, "FOOBAR", phkey );
//    dw = RegOpenKey( hkeyRoot, "Software\\Microsoft\\Accessibility\\StickyKeys", phkey );
    dw = RegCreateKeyEx( hkeyRoot,
	    sz,
	    0,
	    NULL,                // CLASS NAME??
	    0,                   // by default is non-volatile
	    KEY_ALL_ACCESS,
	    NULL,                // default security descriptor
	    phkey,
	    &dwDisposition );    // yes we throw this away
    if( dw != ERROR_SUCCESS )
	{
	// should do something
	}
    return dw;
    }

/********************************************************************/
BOOL CloseAccessRegKey( HKEY hkey )
    {
    DWORD dw;
    dw = RegCloseKey( hkey );
    if( dw == ERROR_SUCCESS )
	return TRUE;
    else
	return FALSE;
    }

/********************************************************************/
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue )
    {
    DWORD dwResult;
    dwResult = RegSetValueEx( hkey,
			      lpszEntry,
			      0,
			      REG_SZ,
			      lpszValue,
			      strlen( lpszValue ) + sizeof( TCHAR ) );
    if( dwResult != ERROR_SUCCESS )
	{
	; // should do something like print a message
	return FALSE;
	}
    else
	return TRUE;
    }

/********************************************************************/
// NOTE THAT THE DEFAULTS INCLUDED HERE ARE FOR DAYTONA ONLY, NOT CHICAGO
//
BOOL SetDefaultRegEntries( HKEY hkeyRoot )
    {
    HKEY hkey;

    OpenAccessRegKeyW( hkeyRoot, "StickyKeys", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "466" );
   // -------- flag --------------- value --------- default ------
   // #define SKF_STICKYKEYSON    0x00000001          0
   // #define SKF_AVAILABLE       0x00000002          2
   // #define SKF_HOTKEYACTIVE    0x00000004          0
   // #define SKF_CONFIRMHOTKEY   0x00000008          0
   // #define SKF_HOTKEYSOUND     0x00000010         10
   // #define SKF_INDICATOR       0x00000020          0
   // #define SKF_AUDIBLEFEEDBACK 0x00000040         40
   // #define SKF_TRISTATE        0x00000080         80
   // #define SKF_TWOKEYSOFF      0x00000100        100
   // ----------------------------------------- total = 0x1d2 = 466
   //
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "OnOffFeedback",         "1" );
    SetRegString( hkey, "AudibleFeedback",       "1" );
    SetRegString( hkey, "TriState",              "1" );
    SetRegString( hkey, "TwoKeysOff",            "1" );
    SetRegString( hkey, "HotkeyActive",          "0" );
    SetRegString( hkey, "Available",             "1" );
    SetRegString( hkey, "ConfirmHotkey",         "0" );
#endif
    CloseAccessRegKey( hkey );

    OpenAccessRegKeyW( hkeyRoot, "Keyboard Response", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "82" );
    // -------- flag --------------- value --------- default ------
    // #define FKF_FILTERKEYSON    0x00000001           0
    // #define FKF_AVAILABLE       0x00000002           2
    // #define FKF_HOTKEYACTIVE    0x00000004           0
    // #define FKF_CONFIRMHOTKEY   0x00000008           0
    // #define FKF_HOTKEYSOUND     0x00000010          10
    // #define FKF_INDICATOR       0x00000020           0
    // #define FKF_CLICKON         0x00000040          40
    // ----------------------------------------- total = 0x52 = 82
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "OnOffFeedback",         "1" );
    SetRegString( hkey, "ClickOn",               "0" );
    SetRegString( hkey, "HotkeyActive",          "0" );
    SetRegString( hkey, "Available",             "1" );
    SetRegString( hkey, "ConfirmHotkey",         "0" );
#endif
    SetRegString( hkey, "DelayBeforeAcceptance", "1000" );
    SetRegString( hkey, "AutoRepeatRate",        "500" );
    SetRegString( hkey, "AutoRepeatDelay",       "1000" );
    SetRegString( hkey, "BounceTime",            "0" );
    CloseAccessRegKey( hkey );


    OpenAccessRegKeyW( hkeyRoot, "MouseKeys", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "18" );
    // -------- flag --------------- value --------- default ------
    // #define MKF_MOUSEKEYSON     0x00000001           0
    // #define MKF_AVAILABLE       0x00000002           2
    // #define MKF_HOTKEYACTIVE    0x00000004           0
    // #define MKF_CONFIRMHOTKEY   0x00000008           0
    // #define MKF_HOTKEYSOUND     0x00000010          10
    // #define MKF_INDICATOR       0x00000020           0
    // #define MKF_NOMODIFIERS     0x00000040           0
    // #define MKF_REPLACENUMBERS  0x00000080           0
    // ----------------------------------------- total = 0x12 = 18
    //
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "OnOffFeedback",         "1" );
    SetRegString( hkey, "HotkeyActive",          "0" );
    SetRegString( hkey, "Available",             "1" );
    SetRegString( hkey, "ConfirmHotkey",         "0" );
#endif
    SetRegString( hkey, "MaximumSpeed",          "40" );
    SetRegString( hkey, "TimeToMaximumSpeed",    "3000" );
    CloseAccessRegKey( hkey );


    OpenAccessRegKeyW( hkeyRoot, "ToggleKeys", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "18" );
    // -------- flag --------------- value --------- default ------
    // #define TKF_TOGGLEKEYSON    0x00000001           0
    // #define TKF_AVAILABLE       0x00000002           2
    // #define TKF_HOTKEYACTIVE    0x00000004           0
    // #define TKF_CONFIRMHOTKEY   0x00000008           0
    // #define TKF_HOTKEYSOUND     0x00000010          10
    // #define TKF_INDICATOR       0x00000020           0
    // ----------------------------------------- total = 0x12 = 18
    //
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "OnOffFeedback",         "1" );
    SetRegString( hkey, "HotkeyActive",          "0" );
    SetRegString( hkey, "Available",             "1" );
    SetRegString( hkey, "ConfirmHotkey",         "0" );
#endif
    CloseAccessRegKey( hkey );


    OpenAccessRegKeyW( hkeyRoot, "TimeOut", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "2" );
    //
    // -------- flag --------------- value --------- default ------
    // #define ATF_TIMEOUTON       0x00000001           0
    // #define ATF_ONOFFFEEDBACK   0x00000002           2
    // ----------------------------------------- total = 0x2 = 2
    //
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "OnOffFeedback",         "1" );
#endif
    SetRegString( hkey, "TimeToWait",            "300000" );
    CloseAccessRegKey( hkey );


    OpenAccessRegKeyW( hkeyRoot, "SoundSentry", &hkey );
#ifndef MANYFLAGS
    SetRegString( hkey, "Flags",                 "2" );
    //
    // -------- flag --------------- value --------- default ------
    // #define SSF_SOUNDSENTRYON   0x00000001           0
    // #define SSF_AVAILABLE       0x00000002           1
    // #define SSF_INDICATOR       0x00000004           0
    // ----------------------------------------- total = 0x2 = 2
#else
    SetRegString( hkey, "On",                    "0" );
    SetRegString( hkey, "Available",             "1" );
#endif
    SetRegString( hkey, "FSTextEffect",          "0" );
    SetRegString( hkey, "WindowsEffect",         "0" );
    CloseAccessRegKey( hkey );


    OpenAccessRegKeyW( hkeyRoot, "ShowSounds", &hkey );
    SetRegString( hkey, "On",                    "0" );
    CloseAccessRegKey( hkey );


    return TRUE;
    }


/***********************************************************************/

DWORD SaveDefaultSettings( void )
    {
    DWORD iStatus;
    HKEY hkeyDst;

    iStatus  = RegOpenKey( HKEY_USERS, ".DEFAULT", &hkeyDst );
    if( iStatus != ERROR_SUCCESS )
	return iStatus;
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szAccessRegPath );
    RegCloseKey( hkeyDst );
    return iStatus;
    }

/***********************************************************************/
// CopyKey( hKey, hKeyDst, name )
//     create the destination key
//     for each value
//         CopyValue
//     for each subkey
//         CopyKey

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey )
    {
    HKEY hkeyOld, hkeyNew;
    char szValue[128];
    char szData[128];
    char szBuffer[128];
    DWORD iStatus;
    UINT nValue, nKey;
    UINT iValueLen, iDataLen;

    iStatus = RegOpenKey( hkeySrc, szKey, &hkeyOld );
    if( iStatus != ERROR_SUCCESS )
	return iStatus;
    iStatus = RegOpenKey( hkeyDst, szKey, &hkeyNew );
    if( iStatus != ERROR_SUCCESS )
	{
	iStatus = RegCreateKey( hkeyDst, szKey, &hkeyNew );
	if( iStatus != ERROR_SUCCESS )
	    {
	    RegCloseKey( hkeyOld );
	    return iStatus;
	    }
	}
    //*********** copy the values **************** //

    for( nValue = 0, iValueLen=sizeof szValue, iDataLen=sizeof szValue;
	 ERROR_SUCCESS == (iStatus = RegEnumValue(hkeyOld,
						  nValue,
						  szValue,
						  &iValueLen,
						  NULL, // reserved
						  NULL, // don't need type
						  szData,
						  &iDataLen ) );
	 nValue ++, iValueLen=sizeof szValue, iDataLen=sizeof szValue )
	 {
	 iStatus = RegSetValueEx( hkeyNew,
				  szValue,
				  0, // reserved
				  REG_SZ,
				  szData,
				  strlen( szData ) + 1 );
	 }
    if( iStatus != ERROR_NO_MORE_ITEMS )
	{
	RegCloseKey( hkeyOld );
	RegCloseKey( hkeyNew );
	return iStatus;
	}

    //*********** copy the subtrees ************** //

    for( nKey = 0;
	 ERROR_SUCCESS == (iStatus = RegEnumKey(hkeyOld,nKey,szBuffer,sizeof(szBuffer)));
	 nKey ++ )
	 {
	 iStatus = CopyKey( hkeyOld, hkeyNew, szBuffer );
	 if( iStatus != ERROR_NO_MORE_ITEMS && iStatus != ERROR_SUCCESS )
		{
		RegCloseKey( hkeyOld );
		RegCloseKey( hkeyNew );
		return iStatus;
		}
	 }
    RegCloseKey( hkeyOld );
    RegCloseKey( hkeyNew );
    if( iStatus == ERROR_NO_MORE_ITEMS )
	return ERROR_SUCCESS;
    else
	return iStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\inc\w95trace.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"


#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#ifdef __cplusplus
extern "C" {
#endif

static HANDLE g_hSpewFile = INVALID_HANDLE_VALUE;

__inline BOOL TestMutex()
{
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return FALSE;
    CloseHandle( hTestMutex );
    return TRUE;
}

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    if (TestMutex())
	{
        HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
        HANDLE heventData;   /* data passing synch object */
        HANDLE hSharedFile;  /* memory mapped file shared data */
        LPTSTR lpszSharedMem;
        TCHAR achBuffer[500];

        /* create the output buffer */
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        va_end(args);

        /* 
            Do a regular OutputDebugString so that the output is 
            still seen in the debugger window if it exists.

            This ifdef is necessary to avoid infinite recursion 
            from the inclusion of W95TRACE.H
        */
#ifdef UNICODE
        OutputDebugStringW(achBuffer);
#else
        OutputDebugStringA(achBuffer);
#endif

        /* bail if it's not Win95 */
        {
            OSVERSIONINFO VerInfo;
            VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&VerInfo);
            if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
                return;
        }

        /* make sure DBWIN is open and waiting */
        heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
        if ( !heventDBWIN )
        {
            //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
            return;            
        }

        /* get a handle to the data synch object */
        heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
        if ( !heventData )
        {
            // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
            CloseHandle(heventDBWIN);
            return;            
        }
    
        hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
        if (!hSharedFile) 
        {
            //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
        if (!lpszSharedMem) 
        {
            //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        /* wait for buffer event */
        WaitForSingleObject(heventDBWIN, INFINITE);

        /* write it to the shared memory */
        *((LPDWORD)lpszSharedMem) = _getpid();
        wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

        /* signal data ready event */
        SetEvent(heventData);

        /* clean up handles */
        CloseHandle(hSharedFile);
        CloseHandle(heventData);
        CloseHandle(heventDBWIN);
	}
    return;
}
void SpewOpenFile(LPCTSTR pszSpewFile)
{
#ifdef UNICODE
    // Only produce output if this mutex is set...
    if (g_hSpewFile == INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR szSpewFile[MAX_PATH];
        GetTempPath(MAX_PATH, szSpewFile);
        if (lstrlen(szSpewFile)+lstrlen(pszSpewFile) >= MAX_PATH)
        {
            MessageBox(NULL, TEXT("SpewOpenFile:  Name will be longer than MAX_PATH"), TEXT("OOPS"), MB_OK);
            return;
        }
        lstrcat(szSpewFile, pszSpewFile);
        g_hSpewFile = CreateFile(szSpewFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == g_hSpewFile)
        {
//            MessageBox(NULL, TEXT("SpewOpenFile:  Unable to open spew file"), TEXT("Error"), MB_OK);
        }
    }
#endif
}
void SpewToFile( LPCTSTR lpOutputString, ...)
{
#ifdef UNICODE
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR achBuffer[1025];
        CHAR achAnsiBuf[500];
        DWORD dwcBytesWr, dwcBytes;
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        dwcBytes = WideCharToMultiByte(CP_ACP, 0, achBuffer, -1, achAnsiBuf, sizeof(achAnsiBuf)*sizeof(CHAR), NULL, NULL);
        if (!WriteFile(g_hSpewFile, achAnsiBuf, dwcBytes-1, &dwcBytesWr, NULL))
        {
//            MessageBox(NULL, TEXT("SpewToFile:  Unable to write to spew file"), TEXT("Error"), MB_OK);
        }
        va_end(args);
    }
#endif
}
void SpewCloseFile()
{
#ifdef UNICODE
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
        CloseHandle(g_hSpewFile);
#endif
}
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\inc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95

#define DBPRINTF_IF(exp, msg)	{if (!exp) DBPRINTF(msg);}


// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );
void SpewOpenFile(LPCTSTR pszSpewFile);
void SpewToFile( LPCTSTR lpOutputString, ...);
void SpewCloseFile();
#ifdef __cplusplus
}
#endif



#else
// avoid warning:
// error C4353: nonstandard extension used: constant 0 as function expression.
// Use '__noop' function intrinsic instead
  #define DBPRINTF        __noop
  #define DBPRINTF_IF(exp, msg)
  #define SpewOpenFile    __noop
  #define SpewToFile      __noop
  #define SpewCloseFile   __noop
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\dialogs.h ===
/****************************************************************************

	DIALOGS.H

	This file defines the definitions for handling the dialogs.

****************************************************************************/

#define		ID_COM1					400
#define		ID_COM2					401
#define		ID_COM3					402
#define		ID_COM4					403

#define		ID_BAUD_110             600
#define		ID_BAUD_300				410
#define		ID_BAUD_600				411
#define		ID_BAUD_1200			412
#define		ID_BAUD_2400			413
#define		ID_BAUD_4800			414
#define		ID_BAUD_9600			415
#define		ID_BAUD_14400           601
#define		ID_BAUD_19200			416
#define		ID_BAUD_38400           602
#define		ID_BAUD_56000           603
#define		ID_BAUD_57600           604
#define		ID_BAUD_115200          605

#define		ID_MK_TIME_1			420
#define		ID_MK_TIME_TEXT			421
#define		ID_MK_TIME_3			422
#define		ID_MK_TIME_4			423
#define		ID_MK_TIME_5			424

#define		ID_MK_SPEED_1			430
#define		ID_MK_SPEED_TEXT		431
#define		ID_MK_SPEED_3			432
#define		ID_MK_SPEED_4			433
#define		ID_MK_SPEED_5			434

#define		ID_KB_ACCEPT_0			440
#define		ID_KB_ACCEPT_1			441
#define		ID_KB_ACCEPT_TEXT		442
#define		ID_KB_ACCEPT_3			443
#define		ID_KB_ACCEPT_4			444
#define		ID_KB_ACCEPT_5			445

#define		ID_USER_OPTION1			447
#define		ID_USER_OPTION2			448
#define   	ID_ON_OFF_CLICK			449

#define		ID_KB_DELAY_0			450
#define		ID_KB_DELAY_1			451
#define		ID_KB_DELAY_TEXT		452
#define		ID_KB_DELAY_3			453
#define		ID_KB_DELAY_4			454
#define		ID_KB_DELAY_5			455

#define		ID_KB_RATE_0			460
#define		ID_KB_RATE_TEXT			461
#define		ID_KB_RATE_2			462
#define		ID_KB_RATE_3			463
#define		ID_KB_RATE_4			464
#define		ID_KB_RATE_5			465

#define		ID_OFF					470
#define		ID_ON					471
#define		ID_FLAG_1				472
#define		ID_FLAG_2				473

#define		ID_TIMEOUT_1			480
#define		ID_TIMEOUT_2			481
#define		ID_TIMEOUT_3			482
#define		ID_TIMEOUT_4			483

#define		ID_ON_OFF_FEEDBACK		490
#define		ID_TRISTATE				491
#define		ID_TWOKEYS_TURNOFF		492
#define		ID_STATE_FEEDBACK		493

#define		ID_KB_BOUNCE_0			500
#define		ID_KB_BOUNCE_1			501
#define		ID_KB_BOUNCE_TEXT		502
#define		ID_KB_BOUNCE_3			503
#define		ID_KB_BOUNCE_4			504
#define		ID_KB_BOUNCE_5			505

#define		ID_KB_TEST_0			530
#define		ID_KB_TEST_1			531
#define		ID_SHOW_SOUND_SCREEN	532
#define		ID_SHOW_SOUND_CAPTION	533
#define		ID_SHOW_SOUND_TYPE		534
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\drivers.h ===
/****************************************************************************

	DRIVERS.H

	This file defines the external calls and structures of the keyboard and 
	mouse drivers.

****************************************************************************/

typedef	struct tagKBDFILTERKEYSPARM {
	BYTE	fFilterKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fUser_SetUp_Option1;	/* boolean 0 = false, 1 = true */
	BYTE	fUser_SetUp_Option2;	/* boolean 0 = false, 1 = true */
	int		wait_ticks;			/* time till accept key 18.2 ticks/sec */
	int		delay_ticks;		/* delay to repeat		18.2 ticks/sec */
	int		repeat_ticks;		/* repeat rate			18.2 ticks/sec */
	int		bounce_ticks;		/* debounce rate		18.2 ticks/sec */
	BYTE	fRecovery_On;		/* boolean 0 = false, 1 = true */ 
	BYTE	fclick_on;			/* boolean 0 = false, 1 = true */ 
} KBDFILTERKEYSPARM;

extern	void FAR PASCAL Get_FilterKeys_Param(KBDFILTERKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_FilterKeys_Param(KBDFILTERKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDSTICKEYSPARM {
	BYTE	fSticKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fAudible_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fTriState;			/* boolean 0 = false, 1 = true */
	BYTE	fTwo_Keys_Off;		/* boolean 0 = false, 1 = true */
	BYTE	fDialog_Stickeys_Off;	/* boolean 0 = false, 1 = true */
} KBDSTICKEYSPARM;

extern	void FAR PASCAL Get_SticKeys_Param(KBDSTICKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_SticKeys_Param(KBDSTICKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDMOUSEKEYSPARM {
	BYTE	fMouseKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	int		Max_Speed;			/* in pixels per second        */
	int		Time_To_Max_Speed;	/* in 1/100th of a second      */
	BYTE	Accel_Table_Len;
	BYTE	Accel_Table[128];
	BYTE	Constant_Table_Len;
	BYTE	Constant_Table[128];
} KBDMOUSEKEYSPARM;

extern	void FAR PASCAL Get_MouseKeys_Param(KBDMOUSEKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_MouseKeys_Param(KBDMOUSEKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDTOGGLEKEYSPARM {
	BYTE	fToggleKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
} KBDTOGGLEKEYSPARM;

extern	void FAR PASCAL Get_ToggleKeys_Param(KBDTOGGLEKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_ToggleKeys_Param(KBDTOGGLEKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDTIMEOUTPARM {
	BYTE	fTimeOutOn;			/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	int		to_value;			/* time to turn off 18.2 times/sec */
} KBDTIMEOUTPARM;

extern	void FAR PASCAL Get_TimeOut_Param(KBDTIMEOUTPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_TimeOut_Param(KBDTIMEOUTPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDSHOWSOUNDSPARM {
	BYTE	fshow_sound_screen;	/* boolean 0 = false, 1 = true */
	BYTE	fshow_sound_caption;	/* boolean 0 = false, 1 = true */
	BYTE	fvideo_found;
	BYTE	fvideo_flash;
} KBDSHOWSOUNDSPARM;

extern	void FAR PASCAL Get_ShowSounds_Param(KBDSHOWSOUNDSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_ShowSounds_Param(KBDSHOWSOUNDSPARM FAR *);	/* part of keyboard driver */

typedef  struct tagMouseKeysParam {
	int		NumButtons;		/* holds number of buttons on the mice	*/
	int		Delta_Y;		/* Relative Y motion sign extended		*/
	int		Delta_X;		/* Relative X motion sign extended		*/
	int		Status;			/* status of mouse buttons and motion	*/
} MOUSEKEYSPARAM;

//extern	void FAR PASCAL InjectMouse(MOUSEKEYSPARAM FAR *);	/* part of mouse driver */
//extern	void FAR PASCAL InjectKeys(int);	/* part of keyboard driver */
//extern	void FAR PASCAL ErrorCode(int); 	/* part of keyboard driver */

typedef  struct tagKBDINFOPARAM {
	int		kybdversion;		/* holds handicap keyboard version number */
} KBDINFOPARM;

typedef  struct tagMOUINFOPARAM {
	int		mouversion;	    	/* holds handicap mouse version number */
} MOUINFOPARM;


/*;BCK*/
//extern	void FAR PASCAL Get_KybdInfo_Param(KBDINFOPARM FAR *);	/* part of appcalls in keyboard driver */
//extern	void FAR PASCAL Get_MouInfo_Param(MOUINFOPARM FAR *);	/* part of appcalls in keyboard driver */

extern	void FAR PASCAL Save_SerialKeys_Param(int); 	/* part of appcalls.asm */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skdll\skdll.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SKEYDLL.C
 *
 * PURPOSE:		    The file contains the SerialKeys DLL Functions
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#include	"windows.h"
#include	"..\skeys\sk_dllif.h"
#include	"..\skeys\sk_dll.h"
#include	"..\skeys\sk_reg.h"
#include	"..\access\skeys.h"
#include <malloc.h>
#include "w95trace.c"

#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))

#define RUNNINGEVENT TEXT("SkeysRunning")
#define ONE_MINUTE (60 * 1000)

static BOOL SerialKeysInstall(void);
static BOOL IsSerialKeysRunning();
static BOOL IsServiceStartAllowed();
static BOOL WaitForServiceRunning();


/*---------------------------------------------------------------
 *
 * FUNCTION	int APIENTRY LibMain
 *
 *	TYPE		Global
 *
 * PURPOSE		LibMain is called by Windows when
 *				the DLL is initialized, Thread Attached, and other times.
 *				Refer to SDK documentation, as to the different ways this
 *				may be called.
 *
 *				The LibMain function should perform additional initialization
 *				tasks required by the DLL.  In this example, no initialization
 *				tasks are required.  LibMain should return a value of 1 if
 *				the initialization is successful.
 *
 * INPUTS	 
 *
 * RETURNS		TRUE - Transfer Ok
 *				FALSE- Transfer Failed
 *
 *---------------------------------------------------------------*/
INT  APIENTRY LibMain(HANDLE hInst, DWORD ul_reason_being_called, LPVOID lpReserved)
{
	return 1;

	UNREFERENCED_PARAMETER(hInst);
	UNREFERENCED_PARAMETER(ul_reason_being_called);
	UNREFERENCED_PARAMETER(lpReserved);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SkeyGetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Reads the values from the registry into the 
 *              SerialKeys structure
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL SkeyGetRegistryValues(HKEY hkey, LPSERIALKEYS psk)
{
	LONG lErr;
	DWORD dwType;
	DWORD cbData;
	
	psk->iPortState = 0;
	psk->iActive = 0;

	psk->dwFlags = 0;
    cbData = sizeof(psk->dwFlags);

	lErr = RegQueryValueEx(
			hkey,
			REG_FLAGS,
			0,
			&dwType,
			(LPBYTE)&psk->dwFlags,
			&cbData);
	
	psk->dwFlags |= SERKF_AVAILABLE;

	if (NULL != psk->lpszActivePort)
	{
		cbData = MAX_PATH * sizeof(*psk->lpszActivePort);
		lErr = RegQueryValueEx(
				hkey,
				REG_ACTIVEPORT,
				0,
				&dwType,
				(LPBYTE)psk->lpszActivePort,
				&cbData);

		if (ERROR_SUCCESS != lErr)
		{
			lstrcpy(psk->lpszActivePort, TEXT("COM1"));
		}
	}

	if (NULL != psk->lpszPort)
	{
        cbData = MAX_PATH * sizeof(*psk->lpszPort);
		lErr = RegQueryValueEx(
				hkey,
				REG_PORT,
				0,
				&dwType,
				(LPBYTE)psk->lpszPort,
				&cbData);

		if (ERROR_SUCCESS != lErr)
		{
			lstrcpy(psk->lpszPort, TEXT("COM1"));
		}
    }				

    cbData = sizeof(psk->iBaudRate);
	lErr = RegQueryValueEx(
			hkey,
			REG_BAUD,
			0,&dwType,
			(LPBYTE)&psk->iBaudRate,
			&cbData);

	if (ERROR_SUCCESS != lErr)
	{
		psk->iBaudRate = 300;
	}
				
	return TRUE;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL SkeyGetUserValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		Read the registery an collect the data for the current
 *				user.
 *	
 * RETURNS		TRUE - User wants Serial Keys Enabled
 *				FALSE- User wants Serial Keys Disabled
 *
 *---------------------------------------------------------------*/
BOOL SkeyGetUserValues(LPSERIALKEYS psk)
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	DWORD dwRet;
    DWORD dwDisposition;

     dwRet = RegCreateKeyEx( HKEY_CURRENT_USER,
            TEXT("Control Panel\\Accessibility\\SerialKeys"),
            0,
            NULL,                // CLASS NAME??
            0,                   // by default is non-volatile
            KEY_READ,
            NULL,                // default security descriptor
            &hkey,
            &dwDisposition);    // yes we throw this away

    if (ERROR_SUCCESS == dwRet)
	{
		fOk = SkeyGetRegistryValues(hkey, psk);
		RegCloseKey(hkey);
	}
	if (fOk)
	{
		// Not available unless the service is running or this
		// user can start it
		if (IsSerialKeysRunning() || IsServiceStartAllowed())
		{
			psk->dwFlags |= SERKF_AVAILABLE;
		}
		else
		{
			psk->dwFlags &= ~SERKF_AVAILABLE;
		}
	}
	return(fOk);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Writes the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL SkeySetRegistryValues(HKEY hkey, LPSERIALKEYS psk)
{
	LONG lErr;
	BOOL fOk;
	DWORD dwFlags;

	dwFlags = psk->dwFlags | SERKF_AVAILABLE;
	lErr = RegSetValueEx(			// Write dwFlags
			hkey,
			REG_FLAGS,
			0,REG_DWORD,
			(CONST LPBYTE)&dwFlags,
			sizeof(DWORD));

    fOk = (ERROR_SUCCESS == lErr);

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_ACTIVEPORT,
				0,REG_SZ,
				(CONST LPBYTE) psk->lpszActivePort,
				(NULL == psk->lpszActivePort) ? 0 : 
					(lstrlen(psk->lpszActivePort) + 1) * 
						sizeof(*psk->lpszActivePort));
					
        fOk = (ERROR_SUCCESS == lErr);
    }				

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_PORT,
				0,REG_SZ,
				(CONST LPBYTE)psk->lpszPort,
				(NULL == psk->lpszPort) ? 0 : 
					(lstrlen(psk->lpszPort) + 1) * sizeof(*psk->lpszPort));
					
        fOk = (ERROR_SUCCESS == lErr);
    }				

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_BAUD,
				0,REG_DWORD,
				(CONST LPBYTE) &psk->iBaudRate,
				sizeof(psk->iBaudRate));

        fOk = (ERROR_SUCCESS == lErr);
    }				

	return fOk;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetUserValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function writes out information to the
 *				registry.
 *	
 * INPUTS		None
 *
 * RETURNS		TRUE - Write Successful
 *				FALSE- Write Failed
 *
 *---------------------------------------------------------------*/
BOOL SkeySetUserValues(LPSERIALKEYS psk)
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	DWORD dwRet;
    DWORD dwDisposition;

    dwRet = RegCreateKeyEx(
			HKEY_CURRENT_USER,
	        TEXT("Control Panel\\Accessibility\\SerialKeys"),
            0,
            NULL,                // class name
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,                // default security descriptor
            &hkey,
            &dwDisposition);    // yes we throw this away

    if (ERROR_SUCCESS == dwRet)
	{
	    fOk = SkeySetRegistryValues(hkey, psk);
		RegCloseKey(hkey);
	}
	return(fOk);
}

#if 0 // This old code is no longer needed ////////////////////////////////////
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL IsSerialKeysInstalled();
 *
 *	TYPE		Local
 *
 * PURPOSE		This function passes the information from the 
 *				Serial Keys application to the Server
 *
 * INPUTS	 	None
 *
 * RETURNS		TRUE - SerialKeys is Installed
 *				FALSE- SerialKeys Not Installed
 *
 *---------------------------------------------------------------*/
static BOOL IsSerialKeysInstalled()
{

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	BOOL fOk = FALSE;
	//
	// Check if the Serial Keys Service is installed
	schSCManager = OpenSCManager
	(
		NULL,                   // machine (NULL == local)
		NULL,                   // database (NULL == default)
		SC_MANAGER_ALL_ACCESS   // access required
	);

	if (NULL != schSCManager)
	{
		schService = OpenService(schSCManager, "SerialKeys", SERVICE_ALL_ACCESS);
			
		if (NULL != schService)
		{
			CloseServiceHandle(schService);
			fOk = TRUE;
        }

		CloseServiceHandle(schSCManager);
    }

	return fOk;
}
#endif ////////////////////////////////////////////////////////////////////////

BOOL IsSerialKeysRunning()
{
	BOOL fRunning = FALSE;
    HANDLE hEventSkeysServiceRunning;

	hEventSkeysServiceRunning = OpenEvent(SYNCHRONIZE, FALSE, RUNNINGEVENT);
    if (NULL != hEventSkeysServiceRunning)
	{
		DWORD dwWait;

		dwWait = WaitForSingleObject(hEventSkeysServiceRunning, 0);

		fRunning = (WAIT_OBJECT_0 == dwWait);
        CloseHandle(hEventSkeysServiceRunning);
    }
	return fRunning;
}


BOOL IsServiceStartAllowed()
{
	BOOL fServiceStartAllowed = FALSE;

	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		SC_MANAGER_CREATE_SERVICE);     // access required

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
        CloseServiceHandle(schSCManager);
		fServiceStartAllowed = TRUE;
	}

	return fServiceStartAllowed;
}


BOOL SkeyServiceRequest(UINT uAction, LPSERIALKEYS psk, BOOL fWinIni)
{
	BOOL fOk = FALSE;
    SKEYDLL SKeyDLL;
	DWORD bytesRead;

	if (IsSerialKeysRunning())
	{
		memset(&SKeyDLL, 0, sizeof(SKeyDLL));
		SKeyDLL.Message = uAction;
		if (psk->lpszActivePort != NULL)
		{
			strcpy(SKeyDLL.szActivePort,psk->lpszActivePort);
		}

		if (psk->lpszPort != NULL)
		{
			strcpy(SKeyDLL.szPort,psk->lpszPort);
		}

		SKeyDLL.dwFlags		= psk->dwFlags | SERKF_AVAILABLE;
		SKeyDLL.iBaudRate	= psk->iBaudRate;
		SKeyDLL.iPortState	= psk->iPortState;
		SKeyDLL.iSave 		= fWinIni;

		fOk = CallNamedPipe(
				SKEY_NAME, 						// Pipe name
				&SKeyDLL, 
				sizeof(SKeyDLL),
				&SKeyDLL, 
				sizeof(SKeyDLL),
				&bytesRead, 
				NMPWAIT_USE_DEFAULT_WAIT);

		if (fOk)
		{
			if (psk->lpszActivePort != NULL)
			{
				strcpy(psk->lpszActivePort,SKeyDLL.szActivePort);
			}

			if (psk->lpszPort != NULL)
			{
				strcpy(psk->lpszPort,SKeyDLL.szPort);
			}

			psk->dwFlags 		= SKeyDLL.dwFlags | SERKF_AVAILABLE;	  
			psk->iBaudRate 		= SKeyDLL.iBaudRate; 
			psk->iPortState 	= SKeyDLL.iPortState;
		}
	}
    return fOk;
}


BOOL SkeyInitUser()
{
    BOOL fOk;
	SERIALKEYS sk;
	TCHAR szActivePort[256];
	TCHAR szPort[256];


	memset(&sk, 0, sizeof(sk));
	sk.cbSize = sizeof(sk);
	sk.lpszActivePort = szActivePort;
	sk.lpszPort = szPort;

	fOk = SkeyGetUserValues(&sk);
	if (fOk)
	{
		fOk = SkeyServiceRequest(SPI_SETSERIALKEYS, &sk, FALSE);
	}
	return fOk;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	int APIENTRY SKEY_SystemParameterInfo
 *
 *	TYPE		Global
 *
 * PURPOSE		This function passes the information from the 
 *				Serial Keys application to the Server
 *
 * INPUTS	 
 *
 * RETURNS		TRUE - Transfer Ok
 *				FALSE- Transfer Failed
 *
 *---------------------------------------------------------------*/
BOOL APIENTRY SKEY_SystemParametersInfo(
		UINT uAction, 
		UINT uParam, 
		LPSERIALKEYS psk, 
		BOOL fWinIni)
{
	BOOL fOk;
	BOOL fStarted;

	fOk = ((uAction ==  SK_SPI_INITUSER) || 
		   (NULL != psk && (0 != psk->cbSize)));
    
    if (fOk)
	{
		switch (uAction)			
		{
		case SPI_SETSERIALKEYS:
			fOk = SkeySetUserValues(psk);
            
			if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && IsServiceStartAllowed())
			{
				fOk = SerialKeysInstall();
			}

			if (fOk && IsSerialKeysRunning())
			{
	            fOk = SkeyInitUser();
			}
			
			break;

		case SPI_GETSERIALKEYS:	
			fOk = SkeyGetUserValues(psk);
			if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && 
				!IsSerialKeysRunning() && IsServiceStartAllowed())
			{
				fOk = SerialKeysInstall();
			}

			if (fOk && IsSerialKeysRunning())
			{
	            fOk = SkeyInitUser();
			}

			break;

        case SK_SPI_INITUSER:
			// give the service a chance to start
			fStarted = WaitForServiceRunning();
			
			if (!fStarted)
			{
				// service does not seem to be running
				// let's try to start it
				fOk = SkeyGetUserValues(psk);

				if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && 
					!IsSerialKeysRunning() && IsServiceStartAllowed())
				{
					SerialKeysInstall();
				}

				if (IsSerialKeysRunning())
				{
					fOk = SkeyInitUser();
				}
			}
			break;

		default:
			fOk = FALSE;			// No - Fail
		}
	}
    return fOk;
}

/*****************************************************************************/
/* WaitForServiceRunning - wait up to one minute for the SerialKeys service
 * to signal it is ready.  CreateEvent has been called by SKeys.exe before
 * this function is executed.
 */
BOOL WaitForServiceRunning()
{
	BOOL fOk = FALSE;
    HANDLE hEventSkeysServiceRunning = OpenEvent(SYNCHRONIZE, FALSE, RUNNINGEVENT);
    
    if (hEventSkeysServiceRunning)
	{
        DWORD dwWait = WaitForSingleObject(hEventSkeysServiceRunning, ONE_MINUTE);
        CloseHandle(hEventSkeysServiceRunning);

		fOk = (WAIT_OBJECT_0 == dwWait);
    }

	return fOk;
}

/****************************************************************************/

BOOL SerialKeysInstall(void)
{
    BOOL fStarted = FALSE;
	SERVICE_STATUS  ssStatus;
	DWORD   dwOldCheckPoint;
	TCHAR   szFileName[255];

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		SC_MANAGER_ALL_ACCESS);     // access required

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    SERVICE_ALL_ACCESS);

	    if (NULL != schService)
		{			
			// insure the serivce is auto-start

			ChangeServiceConfig(
				schService,
				SERVICE_WIN32_OWN_PROCESS,
				SERVICE_AUTO_START,		// when to start service 
				SERVICE_NO_CHANGE,		// severity if service fails to start 
				NULL,					// pointer to service binary file name 
				NULL,					// pointer to load ordering group name 
				NULL,					// pointer to variable to get tag identifier 
				NULL,					// pointer to array of dependency names 
				NULL,					// pointer to account name of service 
				NULL,					// pointer to password for service account  
				__TEXT("SerialKeys"));	// name to display 
		}
		else
		{
			if (!GetWindowsDirectory(szFileName, ARRAY_SIZE(szFileName)))
				return FALSE;	// PREFIX #113665 don't use szFileName if call fails

			lstrcat(szFileName, __TEXT("\\system32\\skeys.exe"));

			// Is Service File installed?
			if (0xFFFFFFFF != GetFileAttributes(szFileName)) 
			{       
				schService = CreateService(
					schSCManager,               // SCManager database
					__TEXT("SerialKeys"),       // name of service
					__TEXT("SerialKeys"),       // name to display 
					SERVICE_ALL_ACCESS,         // desired access
					SERVICE_WIN32_OWN_PROCESS,  // service type
					SERVICE_AUTO_START,         // start type
					SERVICE_ERROR_NORMAL,       // error control type
					szFileName,                 // service's binary
					NULL,                       // no load ordering group
					NULL,                       // no tag identifier
					NULL,                       // no dependencies
					NULL,                       // LocalSystem account
					NULL);                      // no password
			}
		}
	    if (NULL != schService)
        {
            BOOL fOk = QueryServiceStatus(schService,&ssStatus);
			if (fOk && ssStatus.dwCurrentState != SERVICE_RUNNING)
			{
				static PTSTR pszArg = TEXT("F\0"); // force service to start
				PTSTR apszArg[] = {pszArg, NULL};
				
				if (StartService(schService, 1, apszArg))
				{   
					while(fOk && ssStatus.dwCurrentState != SERVICE_RUNNING)
					{
						dwOldCheckPoint = ssStatus.dwCheckPoint;
						Sleep(max(ssStatus.dwWaitHint, 1000));
						fOk = QueryServiceStatus(schService,&ssStatus);
						fOk = (fOk && (dwOldCheckPoint >= ssStatus.dwCheckPoint));
					}
				}
			}
			fStarted = fOk && (ssStatus.dwCurrentState == SERVICE_RUNNING);
			CloseServiceHandle(schService);
			
			if (fStarted)
			{
				fStarted = WaitForServiceRunning();
			}
        }
        CloseServiceHandle(schSCManager);
    }
    return fStarted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\gide.c ===
/* GIDE.C  */

//#define     WINVER 0x0300
#define     USECOMM                     /* added to be compatible with new windows.h (12/91) and wintric.h */
                                          /* last rellease of 3.1 SDK switched back to using NOCOMM in windows.h */

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "gidei.h"
#include "vars.h"
#include "gide.h"
#include "kbd.h"
#include "mou.h"
#include "tables.h"
#include "dialogs.h"
#include "sk_ex.h"
#include "w95trace.h"


typedef	struct	tagAliasTable {
	char	*Alias;
	BYTE	Code;
} ALIASTABLE;

long 	AtoL(char *Str);

extern	void	initClear(void);

BOOL	bGIDEIokay = TRUE;				/* general flag for error in processing */
int   	nFrameCnt = 0;					/* keep track of framming errors	*/

char cInBuffer[2];						/* buffer for receiving characters	*/

//char	cInBuffer[7];					/* buffer for receiving characters, size increased */
//short	cInBuffer_count =0;			/* count of chars. returned in ReadComm */
//int		intct = 0;					/* counter for looping thru cInBuffer_count */

//char	cOutStr[2] = {0,0};				/* single char output string		*/


void handleFatalError(void)
{
	SkEx_SendBeep();
	SkEx_SendBeep();
	initClear();
	return;
}

void handleErrorReport(void)
{
	SkEx_SendBeep();
	initClear();
	return;
}

int aliasForGideiCode(unsigned char *cTempPtr)
{
	struct aliasTable *tablePtr;
	int found;

	found = FALSE;
	for (tablePtr=gideiAliasTable;(tablePtr->aliasName[0] != '\x0') && (!found);tablePtr++)
 		if (strcmp(cAliasString,tablePtr->aliasName) == 0) {
			found = TRUE;
			*cTempPtr = tablePtr->gideiCode;
			}
	return (found);
}


int aliasUsedInStandard(unsigned char *cTempPtr)
{
	struct aliasTable *tablePtr;
	int found;
	unsigned char iCode;

	if (aliasPtr == keyAliasTable) {
		if (lstrlenA(cAliasString) == 1) {
			/* use ASCII table */
			if ((iCode = asciiTable[cAliasString[0]].gideiCode1) == NOCODE) return(FALSE);
			if ((iCode == control_Code) || (iCode == shift_Code))
				iCode = asciiTable[cAliasString[0]].gideiCode2;
			*cTempPtr = iCode;
			return(TRUE);
			}
		}
	found = FALSE;
	for (tablePtr=aliasPtr;(tablePtr->aliasName[0] != '\x0') && (!found);tablePtr++)
		if (lstrcmpA(cAliasString,tablePtr->aliasName) == 0) {
			found = TRUE;
			*cTempPtr = tablePtr->gideiCode;
			}
	return (found);
}



/****************************************************************************

	FUNCTION:	pushCommandVector

	PURPOSE:	push CommandVector on to vectorStack

	COMMENTS:
****************************************************************************/

int pushCommandVector(void)
{
	if (stackPointer < MAXVECTORSTACK) {
		aliasStack[stackPointer] = aliasPtr;
		vectorStack[stackPointer++] = commandVector;
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************

	FUNCTION:	popCommandVector

	PURPOSE:	pop CommandVector from vectorStack

	COMMENTS:

*****************************************************************************/

int popCommandVector(void)
{
	if (stackPointer > 0) {
		aliasPtr = aliasStack[--stackPointer];
		commandVector = vectorStack[stackPointer];
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************

	FUNCTION:	restoreCommandVector

	PURPOSE:	restore CommandVector from vectorStack but does not update
				stack pointer.

	COMMENTS:

*****************************************************************************/

int restoreCommandVector(void)
{
	if (stackPointer > 0) {
		aliasPtr = aliasStack[--stackPointer];
		commandVector = vectorStack[stackPointer];
		++stackPointer;
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************/
int storeByte(unsigned char *bytePtr)
{
	if ((spos+1==rpos) || (spos+1==CODEBUFFERLEN && !rpos)) return notOKstatus;
	buf[spos++] = *bytePtr;
	if (spos==CODEBUFFERLEN) spos = 0;
	return okStatus;
}

int retrieveByte(unsigned char *bytePtr)
{
	if (rpos==CODEBUFFERLEN) rpos = 0;
	if (rpos==spos) return notOKstatus;
	++rpos;
	*bytePtr = buf[rpos-1];
	return okStatus;
}


/****************************************************************************

	FUNCTION:	noOpRoutine

	PURPOSE:	"Do nothing" routine

	COMMENTS:

****************************************************************************/
void noOpRoutine(unsigned char cJunk)
{
	return;
}

void processGen(unsigned char c)
{
	return;
}

void processComm(unsigned char c)
{
	return;
}
/****************************************************************************

	FUNCTION:	processCommand

	PURPOSE:	Determine which command is active.  Then set commandVector to
				point to appropriate routine.

	COMMENTS:

****************************************************************************/
void processCommand(unsigned char cGideiCode)
{
	switch(cGideiCode) {
		case KBDEXPANSIONCODE:
			commandVector = processKbd;
			aliasPtr = kbdAliasTable;
			beginOK = TRUE;
			break;
		case MOUEXPANSIONCODE:
			commandVector = processMou;
			aliasPtr = mouseAliasTable;
			beginOK = TRUE;
			break;
		case GENCODE:
			commandVector = processGen;
			aliasPtr = genAliasTable;
			beginOK = TRUE;
			break;
		case COMMCODE:
			commandVector = processComm;
			aliasPtr = commAliasTable;
			beginOK = TRUE;
			break;
		case KBDLOCKCODE:
			commandVector = processKbdLock;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDRELCODE:
			commandVector = processKbdRel;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDPRESSCODE:
			commandVector = processKbdPress;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDCOMBINECODE:
			commandVector = processKbdCombine;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDHOLDCODE:
			commandVector = processKbdHold;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case MOULOCKCODE:
			commandVector = processMouLock;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOURELCODE:
			commandVector = processMouRel;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUCLICKCODE:
			commandVector = processMouClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUDOUBLECLICKCODE:
			commandVector = processMouDoubleClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUMOVECODE:
			commandVector = processMouMove;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOUGOTOCODE:
			commandVector = processMouGoto;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOURESETCODE:
			commandVector = processMouReset;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOUANCHORCODE:
			commandVector = processMouAnchor;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case BAUDRATECODE:
			commandVector = processBaudrate;
			aliasPtr = baudrateAliasTable;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			beginOK = TRUE;
		default:
			if (cGideiCode >= LOWESTGIDEICODE) handleFatalError();
			else {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			break;
		}
	return;
}



void processBytes(unsigned char iGideiCode)
{
	(*commandVector)(iGideiCode);
	if (!(--blockCount))
      {
      passAll = FALSE;
      codeVector = processGideiCode;
      }
}

void processBlock(unsigned char iGideiCode)
{
	if (blockCount--) (*commandVector)(iGideiCode);
	else {
      passAll = FALSE;
		if (iGideiCode == TERMCODE) codeVector = processGideiCode;
		else handleFatalError();
		}
}

void processGideiBlockCount(unsigned char iGideiCode)
{
	blockCount = iGideiCode;
	codeVector = processBlock;
   passAll = TRUE;
}

void processGideiClear(unsigned char iGideiCode)
{
	if (iGideiCode == TERMCODE) initClear();
	else handleFatalError();
}

void processGideiEnd(unsigned char iGideiCode)
{
	if (iGideiCode == TERMCODE) {
		if (!popCommandVector()) handleFatalError();
		else {
			if (restoreCommandVector()) {
				beginOK = TRUE;
				codeVector = processGideiCode;
				}
			else {
				commandVector = processCommand;
				codeVector = processCharMode;
				serialVector = charHandler;
				beginOK = FALSE;
				}
			lastCode = iGideiCode;
			}
		}
	else handleFatalError();
}


/****************************************************************************

	FUNCTION:	processCOMMbaudrate(Code)

	PURPOSE:	Processes the baudrate commands.

	COMMENTS:

****************************************************************************/

void processBaudrate(unsigned char Code)
{
	static int SetBaud = 0;

	switch(Code)
	{
		case TERMCODE:
			if (SetBaud != 0) 			/* valid one set */
				SkEx_SendBeep();
			break;

		case BAUD300CODE:
			SetBaud = ID_BAUD_300;
			SkEx_SetBaud(300);
			break;

		case BAUD600CODE:
			SetBaud = ID_BAUD_600;
			SkEx_SetBaud(600);
			break;

		case BAUD1200CODE:
			SetBaud = ID_BAUD_1200;
			SkEx_SetBaud(1200);
			break;

		case BAUD2400CODE:
			SetBaud = ID_BAUD_2400;
			SkEx_SetBaud(2400);
			break;

		case BAUD4800CODE:
			SetBaud = ID_BAUD_4800;
			SkEx_SetBaud(4800);
			break;

		case BAUD9600CODE:
			SetBaud = ID_BAUD_9600;
			SkEx_SetBaud(9600);
			break;

		case BAUD19200CODE:
			SetBaud = ID_BAUD_19200;
			SkEx_SetBaud(19200);
			break;

		case BAUD110CODE:
			SetBaud = ID_BAUD_110;
			SkEx_SetBaud(110);
			break;

		case BAUD14400CODE:
			SetBaud = ID_BAUD_14400;
			SkEx_SetBaud(14400);
			break;

		case BAUD38400CODE:
			SetBaud = ID_BAUD_38400;
			SkEx_SetBaud(38400);
			break;

		case BAUD56000CODE:
			SetBaud = ID_BAUD_56000;
			SkEx_SetBaud(56000);
			break;

		case BAUD57600CODE:
			SetBaud = ID_BAUD_57600;
			SkEx_SetBaud(57600);
			break;

		case BAUD115200CODE:
			SetBaud = ID_BAUD_115200;
			SkEx_SetBaud(115200);
			break;

		default:
			handleErrorReport();
			break;
	}
}

/****************************************************************************

	FUNCTION:	processGideiCode

	PURPOSE:
				

	COMMENTS:

*****************************************************************************/

void processGideiCode(unsigned char iGideiCode)
{
	if (waitForClear) {
		if (iGideiCode == CLEARCODE) codeVector = processGideiClear;
		else handleFatalError();
		return;
		}
	switch (iGideiCode) {

		case BEGINCODE:
			if (beginOK) {
				if (pushCommandVector()) lastCode = iGideiCode;
				else handleFatalError();
				}
			else handleFatalError();
			break;

		case ENDCODE:
			if (lastCode == TERMCODE) {
				codeVector = processGideiEnd;
				beginOK = FALSE;
				lastCode = iGideiCode;
				}
			else handleFatalError();
			break;

		case CLEARCODE:
			codeVector = processGideiClear;
			lastCode = iGideiCode;
			break;

		case TERMCODE:
			(*commandVector)(iGideiCode);
			if (!restoreCommandVector()) {
				commandVector = processCommand;
				codeVector = processCharMode;
				serialVector = charHandler;
				beginOK = FALSE;
				}
			else
				beginOK = TRUE;
			lastCode = iGideiCode;
			break;

		case BLKTRANSCODE:
			codeVector = processGideiBlockCount;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case BYTECODE:
			codeVector = processBytes;
			blockCount = 1;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case INTEGERCODE:
			codeVector = processBytes;
			blockCount = 2;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case LONGCODE:
			codeVector = processBytes;
			blockCount = 4;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case DOUBLECODE:
			codeVector = processBytes;
			blockCount = 8;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		default:
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;
		}

}


/****************************************************************************

	FUNCTION:	processCharMode

	PURPOSE:	Handles processing of ASCII characters in Character Mode
				

	COMMENTS:

***************************************************************************/
void processCharMode(unsigned char ucSerialByte)
{
	unsigned char tempKeyCode;

	if (ucSerialByte == ESCAPE) {
		codeVector = processGideiCode;
		return;
		}

	if (waitForClear) {
		handleFatalError();
		return;
		}

	if ( ucSerialByte > 127 )			// Are We processing an Extended Code
	{
		sendExtendedKey(ucSerialByte);	// Yes - Send Code
		return;							// Exit
	}

	if ((tempKeyCode = (asciiTable[ucSerialByte]).gideiCode1) == NOCODE) {
		handleErrorReport();
		tempList.len = 0;
		return;
		}

	if ((!inLockList(tempKeyCode)) && (!inHoldList(tempKeyCode)))
		tempList.list[tempList.len++] = tempKeyCode;

	if ((tempKeyCode = asciiTable[ucSerialByte].gideiCode2) != NOCODE) {
		if ((!inLockList(tempKeyCode)) && (!inHoldList(tempKeyCode)))
			tempList.list[tempList.len++] = tempKeyCode;
		}

	sendCombineList();
	keyHoldList.len = tempList.len = 0;
	return;
}



/****************************************************************************

	FUNCTION:	executeAlias()

	PURPOSE:	Takes the alias string, convert to code, and then does
				proper processing.

	COMMENTS:

*****************************************************************************/
void executeAlias(void)
{
	static unsigned char *cTempPtr;
	static int iTemp;

	cTempPtr = cAliasString;
	if (lstrlenA(cAliasString) > MAXALIASLEN) *cTempPtr = UNKNOWNCODE;
	else 
    {
		if (!aliasForGideiCode(cTempPtr)) 
        {
			CharLowerA(cAliasString);
			if (!aliasUsedInStandard(cTempPtr))
            {
 					/* Must be a number.  But is it an ASCII coded number
 					or ASCII coded GIDEI code */
				switch (cAliasString[0]) 
                {
					case '0':
					case '+':
					case '-':
						iTemp = AtoL(cAliasString);
						*cTempPtr = INTEGERCODE;
						storeByte(cTempPtr);
						cTempPtr = (unsigned char*) &iTemp;
						storeByte(cTempPtr++);
						break;
					default:
						/* must be a ASCII coded GIDEI code */
						iTemp = AtoL(cAliasString);
						if ((unsigned)iTemp > 255) *cTempPtr = UNKNOWNCODE;
						else *cTempPtr = (unsigned char) iTemp;
						break;
				}
            }
		}
	}
	storeByte(cTempPtr);
	return;
}


/****************************************************************************

	FUNCTION:	processAlias(ucSerialByte)

	PURPOSE:	This routine builds up the alias string and then passes
				control onto executeAlias.

	COMMENTS:
*****************************************************************************/

void processAlias(unsigned char ucSerialByte)
{
	static unsigned char	tempCode, *codePtr;
	static unsigned char sbtemp[2];

	codePtr = &tempCode;

	switch (ucSerialByte) {
		case ESCAPE:
			cAliasString[0] = '\0';
			break;
		case TAB:
		case LINEFEED:
		case VERTICALTAB:
		case FORMFEED:
		case RETURN:
		case SPACE:
			if (!lstrlenA(cAliasString)) break;	/* if previous character was a */
				 								/* delimiter then eat white space */
		case COMMA:
		case PERIOD:
			if (lstrlenA(cAliasString)) executeAlias();
			else
				{
				tempCode = DEFAULTCODE;
				storeByte(codePtr);
				}
			if (ucSerialByte == '.')
				{
				tempCode = TERMCODE;
				storeByte(codePtr);
				}
			cAliasString[0] = '\0';
			for (;retrieveByte(codePtr);) (*codeVector)(tempCode);
			break;
		default:
			/* just add the char to the string */
			if ((ucSerialByte >= ' ') && (ucSerialByte <= '~'))
			{
				if (lstrlenA(cAliasString) < MAXALIASLEN+1)	/*make sure room */
				{
					sbtemp[0] = ucSerialByte;
					sbtemp[1] = 0;
					lstrcatA(cAliasString,sbtemp);
                } else
                {
                    DBPRINTF(TEXT("processAlias:  no room\r\n"));
                }
			}
			else
            {
				handleFatalError();					/* not an alias */
            }
		}
	return;
}

/****************************************************************************

	FUNCTION:	passAllCodes

	PURPOSE:	Just keeps the GIDEI hierarchy consistant

	COMMENTS:	
****************************************************************************/

void passAllCodes(unsigned char cGideiCode)
{
	(*codeVector)(cGideiCode);
	return;
}



/****************************************************************************

	FUNCTION:	determineFormat

	PURPOSE:	Figure out what Escape Sequence form (i.e. Alias, Code, KEI, etc)

	COMMENTS:
****************************************************************************/

void determineFormat(unsigned char ucSerialByte)
{
	static char cStuffStr[7], *cPtr;

	switch (ucSerialByte)
		{
		case COMMA:
			serialVector = processAlias;
			aliasPtr = commandsAliasTable;
			break;
		case ESC:
			break;
		default:
			if ((ucSerialByte >= ' ') && (ucSerialByte <= '~')) /* KEI Implied Press */
				{
				serialVector = processAlias;
				aliasPtr = commandsAliasTable;
				for (cPtr = strcpy(cStuffStr,"press,"); *cPtr != '\0'; cPtr++) processAlias(*cPtr);
				processAlias(ucSerialByte);
				}
			else
				{
				serialVector = passAllCodes;
				(*codeVector)(ucSerialByte);
				}
			break;
		}
	return;
}

/****************************************************************************

	FUNCTION:	charHandler

	PURPOSE:	If ESCAPE then set up new vectors.  Also processes the char

	COMMENTS:
****************************************************************************/

void charHandler(unsigned char ucSerialByte)
{
	if (ucSerialByte == ESC) {
		serialVector = determineFormat;
		commandVector = processCommand;
		beginOK = TRUE;
		}
	(*codeVector)(ucSerialByte);
	return;
}


BOOL  serialKeysBegin(unsigned char c)
{
	static	char junk[2];
	
	junk[0] = c;
	junk[1] = '\0';

	if (!passAll) {
		if (c == '\0')
			{
			SkEx_SendBeep();
			if ((++nullCount) >= 3) {
				initClear();
				SkEx_SendBeep();
				SkEx_SendBeep();
				SkEx_SendBeep();

				}
			}
		}
	(*serialVector)(c);
	return(TRUE);
}


long AtoL(char *s)
{
	long num = 0;
	long sign = 1L;

	while(*s == ' ' || *s == '\t')
		s++;

	if( *s == '-' ) 
    {
		sign = -1L;
		s++;
	}
	else if( *s == '+' )
    {
		s++;
    }
	while('0' <= *s  &&  *s <= '9') 
    {
		num = 10 * num + *s - '0';
		s++;
	}

	return( sign * num );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\gide.h ===
/*  GIDE.H   */

#include "gidei.h"

int pushCommandVector(void);
int popCommandVector(void);
int restoreCommandVector(void);

void noOpRoutine(unsigned char cJunk);

int storebyte(unsigned char *bytePtr);
int retrievebyte(unsigned char *bytePtr);

void processComm(unsigned char);
void processGen(unsigned char);
void processEnd(unsigned char iGideiCode);
void processBytes(unsigned char iGideiCode);
void processBlock(unsigned char iGideiCode);
void processGideiBlockCount(unsigned char iGideiCode);
void processClear(unsigned char iGideiCode);
void processGideiCode(unsigned char iGideiCode);

void executeAlias(void);
void processAlias(unsigned char ucSerialByte);
short	writeCommPort (char *outStr);

void passAllCodes(unsigned char cGideiCode);
void determineFormat(unsigned char ucSerialByte);
void charHandler(unsigned char ucSerialByte);
void processCharMode(unsigned char ucSerialByte);
void processCommand(unsigned char cGideiCode);
void	processBaudrate(unsigned char Code);

BOOL FAR serialKeysBegin(unsigned char c);

void handleErrorReport(void);
void handleFatalError(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\initgide.h ===
/*  INIT.H  */

void serialKeysStartUpInit(void);
void initClear(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\initgide.c ===
/*  INIT.C  */

//#define     WINVER 0x0300
#include	"windows.h"

//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "vars.h"
#include "gide.h"
#include "initgide.h"
#include "dialogs.h"

void serialKeysStartUpInit(void)
{

	mouseX = mouseY = 0;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	requestButton1, requestButton2, requestButton3 = FALSE;
	button1Status, button2Status, button3Status = FALSE;
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	keyLockList.len = keyHoldList.len = tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;

	return;				/* beep and set baudrate */
}

void initClear(void)
{
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	return;
}

VOID FAR PASCAL serialKeysStartupInitDLL(void)
{
	mouseX = mouseY = 0;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	requestButton1, requestButton2, requestButton3 = FALSE;
	button1Status, button2Status, button3Status = FALSE;
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	keyLockList.len = keyHoldList.len = tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;
	return;						/* beep and set baudrate */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\gidei.h ===
/* GIDEI Codes */

/* reserved 236-242 */
#define NOCODE 0
#define LOWESTGIDEICODE 236

#define DOUBLECODE 243
#define LONGCODE 244
#define INTEGERCODE 245
#define BYTECODE 246
#define BLKTRANSCODE 247
#define DELIMITERCODE 248
#define ENDCODE 249
#define BEGINCODE 250
#define CLEARCODE 251
#define DEFAULTCODE 252
#define UNKNOWNCODE 253
#define EXTENDEDCODE 254
#define TERMCODE 255

/* Command Codes */
#define KBDPRESSCODE 2
#define KBDCOMBINECODE 3
#define KBDHOLDCODE 4
#define KBDLOCKCODE 5
#define KBDRELCODE 6
#define KBDEXPANSIONCODE 10

#define MOULOCKCODE 11
#define MOURELCODE 12
#define MOUCLICKCODE 13
#define MOUDOUBLECLICKCODE 14
#define MOUMOVECODE 15
#define MOUGOTOCODE 16
#define MOURESETCODE 17
#define MOUANCHORCODE   18
#define MOUEXPANSIONCODE 20

#define COMMCODE 150
#define BAUDRATECODE 151
#define GENCODE 160
#define DEBUGCODE 220

/* Model Codes */

#define IBMEXTENDEDCODE 	1
#define IBMATCODE		 	2
#define IBMPCCODE			3

#define KBDINDICATORCODE 6
#define KBDVERSIONCODE	7
#define KBDMODELCODE 	8
#define KBDDESCRIPTIONCODE 9
#define KBDUNKNOWNCODE 10

#define NOBUTTON			0
#define DEFAULTBUTTONCODE	1
#define LEFTBUTTONCODE		1
#define RIGHTBUTTONCODE		2

/* BAUDRATE CODES  */

#define BAUD300CODE	1
#define BAUD600CODE  2
#define BAUD1200CODE	3
#define BAUD2400CODE	4
#define BAUD4800CODE	5
#define BAUD9600CODE	6
#define BAUD19200CODE   7
#define BAUD14400CODE   9
#define BAUD38400CODE   10
#define BAUD56000CODE   11
#define BAUD57600CODE   12
#define BAUD115200CODE  13
#define BAUD110CODE     8

/****************************************************************************

	The Key Code is the GIDEI standard Key Code.  The IBM Key Number is the
	number used in the IBM techincal reference of the American English
	extended 101 key keyboard.  It is included only for reference as to
	how this implementation mapped the key code to the IBM keys.

		Name			Key Code	IBM Key Number
****************************************************************************/


/* GIDEI KEY CODES */
/*************************************************************************/
/*************************************************************************/
/* Internal Key number table  */

#define	NOCODE			0
#define	NOKEY				0
#define	no_key			0
#define	lquote_key		1
#define	one_key			2
#define	two_key			3
#define	three_key		4
#define	four_key			5
#define	five_key			6
#define	six_key			7
#define	seven_key		8
#define	eight_key		9
#define	nine_key			10
#define	zero_key			11
#define	hyphen_key		12
#define	equal_key		13
#define	backspace_key	15

#define	tab_key			16
#define	q_key				17
#define	w_key				18
#define	e_key				19
#define	r_key				20
#define	t_key				21
#define	y_key				22
#define	u_key				23
#define	i_key				24
#define	o_key				25
#define	p_key				26
#define	lbracket_key	27
#define	rbracket_key	28
#define	bslash_key		29

#define	caps_key			30
#define	a_key				31
#define	s_key				32
#define	d_key				33
#define	f_key				34
#define	g_key				35
#define	h_key				36
#define	j_key				37
#define	k_key				38
#define	l_key				39
#define	semicolon_key	40
#define	rquote_key		41
#define	return_key		43

#define	lshift_key		44
#define	z_key				46
#define	x_key				47
#define	c_key				48
#define	v_key				49
#define	b_key				50
#define	n_key				51
#define	m_key				52
#define	comma_key		53
#define	period_key		54
#define	fslash_key		55
#define	rshift_key		57

#define	lcontrol_key	58
#define	lcommand_key	59
#define	lalt_key			60
#define	space_key		61
#define	ralt_key			62
#define	rcommand_key	63
#define	rcontrol_key	64

#define	insert_key		75
#define	delete_key		76
#define	left_key			79
#define	home_key			80
#define	end_key			81
#define	up_key			83
#define	down_key			84
#define	pageup_key		85
#define	pagedown_key	86
#define	right_key		89

#define	numlock_key		90
#define	kp7_key			91
#define	kp4_key			92
#define	kp1_key			93
#define	kpfslash_key	95
#define	kp8_key			96
#define	kp5_key			97
#define	kp2_key			98
#define	kp0_key			99
#define	kpstar_key		100
#define	kp9_key			101
#define	kp6_key			102
#define	kp3_key			103
#define	kpperiod_key	104
#define	kpminus_key		105
#define	kpplus_key		106
#define	kpequal_key		107
#define	kpenter_key		108

#define	escape_key		110

#define	f1_key			112
#define	f2_key			113
#define	f3_key			114
#define	f4_key			115

#define	f5_key			116
#define	f6_key			117
#define	f7_key			118
#define	f8_key			119

#define	f9_key			120
#define	f10_key			121
#define	f11_key			122
#define	f12_key			123

#define	print_key		124
#define	scroll_key		125
#define	pause_key		126
#define	reset_key		127

#define	shift_key		lshift_key
#define	control_key		lcontrol_key
#define	alt_key			lalt_key

#define	shift_Code		lshift_key
#define	control_Code	lcontrol_key

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\kbd.h ===
/* KBD.H  */



void sendPressList(void);
void sendCombineList(void);
void sendExtendedKey(unsigned char cKeyCode);
void sendDownKeyCode(unsigned char cKeyCode);
void sendUpKeyCode(unsigned char cKeyCode);

int inLockList(unsigned char searchChar);
int inHoldList(unsigned char searchChar);
int inTempList(unsigned char searchChar);

void releaseKeysFromHoldList(void);
void removeKeyFromHoldList(unsigned char cTheKey);
void releaseKeysFromLockList(void);

void processKbdIndicator(unsigned char cGideiCode);
void processKbdVersion(unsigned char cGideiCode);
void processKbdDescription(unsigned char cGideiCode);
void processKbdModel(unsigned char cGideiCode);

void processKbdRel(unsigned char cGideiCode);
void processKbdLock(unsigned char cGideiCode);
void processKbdHold(unsigned char cGideiCode);
void processKbdCombine(unsigned char cGideiCode);
void processKbdPress(unsigned char cGideiCode);
void processKbd(unsigned char cGideiCode);

unsigned char xlateNumToScanCode(unsigned char Value);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\kbd.c ===
/* KBD.C  */

//#define     WINVER 0x0300

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */

#include	"gidei.h"
#include	"vars.h"
#include	"gide.h"
#include	"kbd.h"
#include	"tables.h"
#include	"sk_ex.h"

BOOL IsInBuff(char *buf, unsigned char SerchChar, int Len);


void sendDownKeyCode(unsigned char cKeyCode)
{
	int 	scanCode;

	if (cKeyCode == NOKEY)
		return;

	if ((scanCode = IBMextendedScanCodeSet1[cKeyCode]) == 0) 
		return;

	SkEx_SendKeyDown(scanCode);
}


void sendUpKeyCode(unsigned char cKeyCode)
{
	int		scanCode;

	if (cKeyCode == NOKEY)
		return;

	if ((scanCode = IBMextendedScanCodeSet1[cKeyCode]) == 0) 
		return;

	SkEx_SendKeyUp(scanCode);
}

void sendExtendedKey(unsigned char cKeyCode)
{
	unsigned char Key[4], Tmp;

	// Start with the Alt Key
	Key[0] = ralt_key;

	Tmp = cKeyCode/10;					// Calc One's
	Key[3] = cKeyCode - (Tmp * 10);		

	cKeyCode = Tmp;						// Calc Ten's
	Tmp /= 10;
	Key[2] = cKeyCode - (Tmp * 10);		
	Key[1] = Tmp;						// Calc Hundreds

	// Translate Numbers into ScanCodes
	Key[1] = xlateNumToScanCode(Key[1]);
	Key[2] = xlateNumToScanCode(Key[2]);
	Key[3] = xlateNumToScanCode(Key[3]);

	// Send Keys to Host
	sendDownKeyCode(Key[0]);		// Send Alt Key Down
	sendDownKeyCode(Key[1]);		// Send Hundreds Key Down
	sendDownKeyCode(Key[2]);		// Send Tens Key Down
	sendDownKeyCode(Key[3]);		// Send Ones Key Down
	sendUpKeyCode(Key[3]);
	sendUpKeyCode(Key[2]);
	sendUpKeyCode(Key[1]);
	sendUpKeyCode(Key[0]);
}

unsigned char xlateNumToScanCode(unsigned char Value)
{
	switch (Value)
	{
		case 0:	return(kp0_key);
		case 1:	return(kp1_key);
		case 2: return(kp2_key);
		case 3:	return(kp3_key);
		case 4:	return(kp4_key);
		case 5:	return(kp5_key);
		case 6:	return(kp6_key);
		case 7:	return(kp7_key);
		case 8:	return(kp8_key);
		case 9:	return(kp9_key);
	}

    // should never be reached
    return 0;
}


void sendPressList(void)
{
	int i;

	for (i=0; i < keyHoldList.len; sendDownKeyCode(keyHoldList.list[i++]));
	for (i=0; i < tempList.len; i++) {
		sendDownKeyCode(tempList.list[i]);
		sendUpKeyCode(tempList.list[i]);
		}
	for (i=keyHoldList.len; i > 0; sendUpKeyCode(keyHoldList.list[--i]));
	keyHoldList.len = tempList.len = 0;
	return;
}

void sendCombineList(void)
{
	int i;

	for (i=0; i < keyHoldList.len; sendDownKeyCode(keyHoldList.list[i++]));
	for (i=0; i < tempList.len; sendDownKeyCode(tempList.list[i++]));
	for (i=tempList.len; i > 0; sendUpKeyCode(tempList.list[--i]));
	for (i=keyHoldList.len; i > 0; sendUpKeyCode(keyHoldList.list[--i]));
	keyHoldList.len = tempList.len = 0;
	return;
}

int inLockList(unsigned char searchChar)
{
	return(IsInBuff(keyLockList.list,searchChar,keyLockList.len));
}

int inHoldList(unsigned char searchChar)
{
	return(IsInBuff(keyHoldList.list,searchChar,keyHoldList.len));
}

int inTempList(unsigned char searchChar)
{
	return(IsInBuff(tempList.list,searchChar,tempList.len));
}

BOOL IsInBuff(char *buf, unsigned char SearchChar, int Len)
{
	int x = 0;

	if (!Len)					// Are there any Chars to search?
		return(FALSE);			// No - Return False
		
	while (x < Len)				// Loop until num chars reached
	{
		if (*buf == SearchChar)	// Does buffer and search char match?
			return(TRUE);		// Yes - Return found it.

		buf++;					// Inc buffer;
		x++;					// Inc byte count
	}
 	return(FALSE);				// character not found in buffer
}


void releaseKeysFromHoldList(void)
{
	unsigned char cTemp;
	int i,j,k;

	if (tempList.len) {
		k = 0;
		for (i=0; (i<tempList.len) && ((cTemp = tempList.list[i]) != DEFAULTCODE); i++) {
			for (j=0; j < keyHoldList.len; j++)
				if ((keyHoldList.list[k] = keyHoldList.list[j]) != cTemp) k++;
			keyHoldList.len = k;
			}
		if (tempList.list[i] == DEFAULTCODE) keyHoldList.len = 0;
		}
	return;
}

void removeKeyFromHoldList(unsigned char cTheKey)
{
//	unsigned char cTemp;
	int j,k;

	if (cTheKey != NOKEY) {
		k = 0;
		for (j=0; j < keyHoldList.len; j++)
			if ((keyHoldList.list[k] = keyHoldList.list[j]) != cTheKey) k++;
		keyHoldList.len = k;
		}
	return;
}

void releaseKeysFromLockList(void)
{
	int i,j,k;
	unsigned char cTemp;

	if (tempList.len) {
		k = 0;
		for (i=0; (i<tempList.len) && ((cTemp = tempList.list[i]) != DEFAULTCODE); i++) {
			for (j=0; j < keyLockList.len; j++) {
				if ((keyLockList.list[k] = keyLockList.list[j]) != cTemp) k++;
				else sendUpKeyCode(cTemp);
				}
			keyHoldList.len = k;
			}
		if (tempList.list[i] == DEFAULTCODE) {
			for (i=0; i < keyLockList.len; i++) sendUpKeyCode(keyLockList.list[i]);
			tempList.len = keyLockList.len = 0;
			}
		}
	return;
}



void processKbdIndicator(unsigned char cGideiCode)
{
	return;
}

void processKbdVersion(unsigned char cGideiCode)
{
	return;
}

void processKbdDescription(unsigned char cGideiCode)
{
	return;
}

void processKbdUnknown(unsigned char cGideiCode)
{
	return;
}


void processKbdModel(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			break;
		default:
			break;
		}
	return;
}


void processKbdRel(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode)
		{
		case TERMCODE:
			if (!tempList.len)
				{
				tempList.list[0] = DEFAULTCODE;
				++tempList.len;
				}
			releaseKeysFromLockList();
			releaseKeysFromHoldList();
			tempList.len = 0;
			break;

		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if ((cGideiCode >= LOWESTGIDEICODE) && (cGideiCode != DEFAULTCODE))
				{
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH)
				{
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if (cGideiCode == DEFAULTCODE)
				iKeyNumber = DEFAULTCODE;
			else
				{
				if ((iKeyNumber=cGideiCode) == NOKEY)
					{
					handleErrorReport();
					commandVector = noOpRoutine;
					tempList.len = 0;
					break;
					}
				if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber)))
					iKeyNumber = NOKEY;
				}
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
	return;
}

void processKbdLock(unsigned char cGideiCode)
{
	int i;
	unsigned char iKeyNumber;
	unsigned char temp;

	switch (cGideiCode) {
		case TERMCODE:
			for (i=0; i < tempList.len; i++) {
				if ((temp = tempList.list[i]) != NOKEY) {
					keyLockList.list[keyLockList.len++] = temp;
					sendDownKeyCode(temp);
					if (inHoldList(temp)) removeKeyFromHoldList(temp);
					}
				}
			if (tempList.len == 0) handleErrorReport();
			tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= (int)LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if ((keyLockList.len + tempList.len) >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if (inLockList(iKeyNumber)) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
}


void processKbdHold(unsigned char cGideiCode)
{
	int i;
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			for (i=0; i < tempList.len; i++)
				if ((keyHoldList.list[keyHoldList.len] = tempList.list[i]) != NOKEY)
					++(keyHoldList.len);
			if (tempList.len == 0) handleErrorReport();
			tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= (int)LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if ((keyHoldList.len + tempList.len) >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
}

void processKbdCombine(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			sendCombineList();
			keyHoldList.len = tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++] = iKeyNumber;
			beginOK = FALSE;
			break;
		}
}

void processKbdPress(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			sendPressList();
			keyHoldList.len = tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			tempList.list[tempList.len++] = iKeyNumber;
			beginOK = FALSE;
			break;
		}
}



void processKbd(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case KBDINDICATORCODE:
			commandVector = processKbdIndicator;
			aliasPtr = kbdIndicatorAliasTable;
			beginOK = TRUE;
			break;

		case KBDVERSIONCODE:
			commandVector = processKbdVersion;
			aliasPtr = kbdVersionAliasTable;
			beginOK = TRUE;
			break;

		case KBDMODELCODE:
			commandVector = processKbdModel;
			aliasPtr = kbdModelAliasTable;
			beginOK = TRUE;
			break;

		case KBDDESCRIPTIONCODE:
			commandVector = processKbdDescription;
			aliasPtr = kbdDescriptionAliasTable;
			beginOK = TRUE;
			break;

/*		case KBDUNKNOWNCODE:
			commandVector = processKbdUnknown;
			aliasPtr = kbdUnknownAliasTable;
			beginOK = TRUE;
			break;
*/
		default:
			if (cGideiCode < LOWESTGIDEICODE) handleFatalError();
			else {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			break;
		}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\mou.h ===
/*  MOU.H  */


void processMouClick(unsigned char cGideiCode);
void processMou(unsigned char cGideiCode);
void processMouDoubleClick(unsigned char cGideiCode);
void processMouRel(unsigned char cGideiCode);

void processMouReset(unsigned char cGideiCode);
void processMouAnchor(unsigned char cGideiCode);
//void processMouPin(unsigned char cGideiCode);
void processMouGoto(unsigned char cGideiCode);
void processMouLock(unsigned char cGideiCode);
void processMouMove(unsigned char cGideiCode);
void pressMouseButtonUp();
void pressMouseButtonDown();
void moveTheMouseAbsolute(void);
void moveTheMouseRelative(void);
void collectGotoInteger(unsigned char moveByte);
void collectGotoByte(unsigned char moveByte);
void collectMoveInteger(unsigned char moveByte);
void collectMoveByte(unsigned char moveByte);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\mou.c ===
/* MOU.C */

//#define     WINVER 0x0300

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include	"vars.h"
#include	"gide.h"
#include	"mou.h"
#include	"kbd.h"
#include	"sk_ex.h"				// Serial Keys Interface Routines
#include    "w95trace.h"

#if 0
#define	SF_MOVEMENT	0x0001
#define	SF_B1_DOWN	0x0002
#define	SF_B1_UP	0x0004
#define	SF_B2_DOWN	0x0008
#define	SF_B2_UP	0x0010
#define	SF_ABSOLUTE	0x8000
#else
#define	SF_MOVEMENT		MOUSEEVENTF_MOVE      
#define	SF_B1_DOWN 		MOUSEEVENTF_LEFTDOWN  
#define	SF_B1_UP 		MOUSEEVENTF_LEFTUP    
#define	SF_B2_DOWN 		MOUSEEVENTF_RIGHTDOWN 
#define	SF_B2_UP 		MOUSEEVENTF_RIGHTUP   
#define	SF_ABSOLUTE 	MOUSEEVENTF_ABSOLUTE  
#endif

void pressMouseButtonDown(void);
void pressMouseButtonUp(void);
void setTheMouseAbsolute(int PosX,int PosY);

BOOL  bmouseanchored =  FALSE;           /* flag, if false, mouse not pinned to a point */
POINT mouseanchor;

#ifndef SPI_GETMOUSESPEED
#define SPI_GETMOUSESPEED   112
#endif

void SendMouseToQueue(MOUSEKEYSPARAM *p)
{
	SkEx_SendMouse(p);
}

void processMouReset(unsigned char cGideiCode)
{
	if (cGideiCode == TERMCODE) 
    {
		// mouse_event treats button parameters as state changes not as state
		// setting; when resetting, only release a button if it is already down

		mouData.Status = SF_ABSOLUTE | SF_MOVEMENT;
		if(GetAsyncKeyState(VK_LBUTTON) > 1)
			mouData.Status |= GetSystemMetrics(SM_SWAPBUTTON) ? SF_B2_UP : SF_B1_UP;
		if(GetAsyncKeyState(VK_RBUTTON) > 1)
			mouData.Status |= GetSystemMetrics(SM_SWAPBUTTON) ? SF_B1_UP : SF_B2_UP;

		mouData.Delta_Y = 0;
		mouData.Delta_X = 0;

		SendMouseToQueue(mouseDataPtr);
		mouseX = mouseY = 0;
	}
	else 
    {
		handleErrorReport();
		commandVector = noOpRoutine;
	}
	return;
}

void moveTheMouseAbsolute(void)
{
 	short tempX, tempY;

	tempX = tempList.list[1];
	tempX = (tempX << 8) + tempList.list[0];
	tempY = tempList.list[3];
	tempY = (tempY << 8) + tempList.list[2];

	mouseX = tempX;
	mouseY = tempY;
	setTheMouseAbsolute(tempX, tempY);
	return;
}

void setTheMouseAbsolute(int PosX,int PosY)
{
	mouData.Status = SF_ABSOLUTE | SF_MOVEMENT;
	mouData.Delta_Y = (int) 0;
	mouData.Delta_X = (int) 0;
	SendMouseToQueue(mouseDataPtr);

	mouData.Status = SF_MOVEMENT;
	mouData.Delta_Y = (int) PosY;
	mouData.Delta_X = (int) PosX;
	SendMouseToQueue(mouseDataPtr);
	return;	
}

void moveTheMouseRelative(void)
{
	short xDist, yDist, newX, newY;

	xDist = tempList.list[1];
	xDist = (xDist << 8) + tempList.list[0];
	yDist = tempList.list[3];
	yDist = (yDist << 8) + tempList.list[2];
	newX = mouseX + xDist;
	newY = mouseY + yDist;
	if (newX < 0) newX = 0;
	if (newY < 0) newY = 0;
	mouseX = newX;
	mouseY = newY;
	mouData.Status = SF_MOVEMENT;
	mouData.Delta_Y = (int) yDist;
	mouData.Delta_X = (int) xDist;
	SendMouseToQueue(mouseDataPtr);
	return;
}


void processMouAnchor(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:

//			if (tempList.len < 4)
// 				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);

         if (bmouseanchored) /* if true, need to release mouse */
            {
            bmouseanchored = FALSE;
			 if (SkEx_GetAnchor(&mouseanchor))
               {
               setTheMouseAbsolute(mouseanchor.x,mouseanchor.y);
               mouseX = mouseanchor.x;
               mouseY = mouseanchor.y;
               }
            else
               SkEx_SendBeep();  

            }
         else /* if false, need to pin the mouse */
            {
			 SkEx_SetAnchor();
            bmouseanchored = TRUE;
            }

			tempList.len = 0;
			beginOK = TRUE;
			break;
//		case INTEGERCODE:
//			commandVector = collectGotoInteger;
//			beginOK = FALSE;
//			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void collectGotoInteger(unsigned char moveByte)
{
	if (tempList.len >= 4) handleFatalError();
	else {
		tempList.list[tempList.len++] = moveByte;
		if ((tempList.len == 2) || (tempList.len == 4)) commandVector = processMouGoto;
		}
	return;
}

void collectGotoByte(unsigned char moveByte)
{
	if (tempList.len >= 4) handleFatalError();
	else 
    {
        tempList.list[tempList.len++] = moveByte;
        if (moveByte >127) 
        {
            tempList.list[tempList.len++] = 0xFF;
        }
        else
        {
            tempList.list[tempList.len++] = 0;
        }
	    commandVector = processMouGoto;
	}
	return;
}

void processMouGoto(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if (tempList.len < 4)
				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);
			moveTheMouseAbsolute();
			tempList.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			commandVector = collectGotoByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			commandVector = collectGotoInteger;
			beginOK = FALSE;
			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void collectMoveInteger(unsigned char moveByte)
{
	if (tempList.len >= 4) 
    {
        handleFatalError();
    }
	else 
    {
		tempList.list[tempList.len++] = moveByte;
		if ((tempList.len == 2) || (tempList.len == 4)) 
        {
            commandVector = processMouMove;
        }
	}
	return;
}

void collectMoveByte(unsigned char moveByte)
{
	if (tempList.len >= 4) 
    {
        handleFatalError();
    }
	else 
    {
		tempList.list[tempList.len++] = moveByte;
        if (moveByte >127)
        {
            tempList.list[tempList.len++] = 0xFF;
        }
        else
        {
            tempList.list[tempList.len++] = 0;
        }
		commandVector = processMouMove;
	}
	return;
}

void processMouMove(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if (tempList.len < 4)
				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);
			moveTheMouseRelative();
			tempList.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			commandVector = collectMoveByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			commandVector = collectMoveInteger;
			beginOK = FALSE;
			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void pressMouseButtonDown()
{
	mouData.Status = 0;
	if (requestButton1) {
		if (!button1Status) {
			mouData.Status += SF_B1_DOWN;
			button1Status = TRUE;
			}
		}
	if (requestButton2) {
		if (!button2Status) {
			mouData.Status += SF_B2_DOWN;
			button2Status = TRUE;
			}
		}
	if (mouData.Status != 0) 
    {
        SendMouseToQueue(mouseDataPtr);
    }
	return;
}

void	pressMouseButtonUp()
{
	mouData.Status = 0;
	if (requestButton1) {
		if (button1Status) {
			mouData.Status += SF_B1_UP;
			button1Status = FALSE;
			}
		}
	if (requestButton2) {
		if (button2Status) {
			mouData.Status += SF_B2_UP;
			button2Status = FALSE;
			}
		}
	if (mouData.Status != 0) 
    {
        SendMouseToQueue(mouseDataPtr);
    }
	return;
}

void processMouRel(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3))
				requestButton1 = requestButton2 = requestButton3 = TRUE;
			pressMouseButtonUp();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMouLock(unsigned char cGideiCode)
{
	switch (cGideiCode)
		{
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3))
				requestButton1 = TRUE;
			pressMouseButtonDown();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMouDoubleClick(unsigned char cGideiCode)
{
	if (cGideiCode == TERMCODE) {
		if ((!requestButton1) && (!requestButton2) && (!requestButton3 ))
			requestButton1 = TRUE;
		mouData.Status = 0;
		if ((requestButton1) && (button1Status)) {
			mouData.Status += SF_B1_UP;
			button1Status = FALSE;
			}
		if ((requestButton2) && (button2Status)) {
			mouData.Status += SF_B2_UP;
			button2Status = FALSE;
			}
		if (!mouData.Status) 
        {
            SendMouseToQueue(mouseDataPtr);
        }
		pressMouseButtonDown();
		pressMouseButtonUp();
		pressMouseButtonDown();
		pressMouseButtonUp();
		requestButton1 = requestButton2 = requestButton3 = FALSE;
		beginOK = TRUE;
		}
	else
		processMouClick(cGideiCode);
	return;
}

void processMouClick(unsigned char cGideiCode)
{
	switch (cGideiCode)
		{
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3 ))
				requestButton1 = TRUE;
			mouData.Status = 0;
			if ((requestButton1) && (button1Status)) {
				mouData.Status += SF_B1_UP;
				button1Status = FALSE;
				}
			if ((requestButton2) && (button2Status)) {
				mouData.Status += SF_B2_UP;
				button2Status = FALSE;
				}
			if (!mouData.Status) 
            {
                SendMouseToQueue(mouseDataPtr);
            }
			pressMouseButtonDown();
			pressMouseButtonUp();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMou(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			beginOK = TRUE;
			break;
		default:
			if (cGideiCode < LOWESTGIDEICODE) {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			else handleFatalError();
		}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_defs.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_defs.h
 *
 * PURPOSE:			Global Variables & Defines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Defines ---------------------------------------------------------*/

//	Commands Process by the Service  inside the MainService Routine

#ifdef DEFDATA
#define	EXTERN	
#define PATHSZ	MAX_PATH
#else
#define	EXTERN	extern
#define PATHSZ	
#endif

// Main Service Defines ---------------------------------------

#define	SC_CLEAR		0
#define SC_LOG_OUT		1
#define SC_LOG_IN		2
#define SC_CHANGE_COMM	3
#define SC_DISABLE_SKEY	4
#define SC_ENABLE_SKEY	5

// Variables ---------------------------------------------------


// Structures ---------------------------------------------------
EXTERN SERIALKEYS	skNewKey, skCurKey;
EXTERN LPSERIALKEYS lpskSKey;

EXTERN TCHAR szNewActivePort[PATHSZ];
EXTERN TCHAR szNewPort[PATHSZ];
EXTERN TCHAR szCurActivePort[PATHSZ];
EXTERN TCHAR szCurPort[PATHSZ];


#define	SERKF_ACTIVE		0x00000040

#define REG_DEF			1
#define REG_USER		2

#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))

void DoServiceCommand(DWORD dwServiceCommand);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\skeys.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SKeys.c
 *
 * PURPOSE:		The main interface routines between the service
 *					manager and the Serial Keys program.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak
 *
 * NOTES:
 *
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm
 * without the express written permission of Black Diamond Software.
 * This permission is available only in the form of a Software Source
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include "vars.h"
#include "w95trace.c"

#define DEFDATA	1
#include "sk_defs.h"
#include "sk_comm.h"
#include "sk_reg.h"
#include "sk_dll.h"
#include "sk_login.h"

#include	"sk_ex.h"

#include	"..\access\skeys.h"

#define LONGSTRINGSIZE 1024

#define WAITMAX 0x7FFFFFFF

#define RUNNINGEVENT TEXT("SkeysRunning")

#if defined(DEBUG) && 0
	// give us a long time to startup in case we're debugging
	#define WAITSTARTUP WAITMAX  
#else
	// normal startup time
	#define WAITSTARTUP 60000
#endif


// --- Local Variables  --------------------------------------------------

static SERVICE_STATUS_HANDLE   s_sshStatusHandle;
static SERVICE_STATUS          s_ssStatus;       // current status of the service

PTSTR SERVICENAME = TEXT("SerialKeys");
PTSTR SKEYSUSERINITCMD = TEXT("SKEYS /I");
PTSTR WINLOGONPATH = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
PTSTR USERINIT = TEXT("Userinit");
PTSTR USERINITCMDSEP = TEXT(",");

DWORD   s_dwServiceCommand;

static HANDLE s_hEventServiceRequest = NULL;
static HANDLE s_hEventServiceRequestReady = NULL;
static HANDLE s_hEventServiceTerminate = NULL;
static HANDLE s_hEventSkeysServiceRunning = NULL;

void DoService();
void DoInit();
void InstallUserInit();
BOOL IsSerialKeysAutoStart();


//--- SCM Function Prototypes  ------------------------------------------------
//
// Note:	The following fuctions manage the connection of the service
//			with the Service Contol Manager.

void	PostEventLog(LPTSTR lpszMsg,DWORD Error);

VOID	ServiceMain(DWORD dwArgc, LPTSTR *ppszArgv);

VOID	StopSerialKeys(LPTSTR lpszMsg);
BOOL	ReportStatusToSCMgr(DWORD dwCurrentState,
                            DWORD dwWin32ExitCode,
                            DWORD dwCheckPoint,
                            DWORD dwWaitHint);

LPHANDLER_FUNCTION ServiceCtrl(DWORD dwCtrlCode);

// Service Routines -----------------------------------------------
//
// Note:	The following fuctions manage the internal control of the
//			Service
static void InitReg();
static BOOL	InitService();
static void PauseService();
static void	ProcessService();
static void	ResumeService();
static void	TerminateService();

static void	ProcessLogout(DWORD dwCtrlType);
static BOOL	InstallLogout();
static BOOL	TerminateLogout();
static void EnableService(BOOL fOn);

// CONSIDER - Removing this code.  It only gets executed when SKeys is 
// run from the command line.  When run as a service, ServiceMain is
// called when the service is started.  The sources file pulls in
// winmain from the runtime lib.  DoInit and DoService could also be
// removed with _tWinMain.

int WINAPI _tWinMain(
    HINSTANCE hInstance,	
    HINSTANCE hPrevInstance,
    PTSTR pszCmdLine,	
    int nCmdShow)
{

	if ((TEXT('/') == pszCmdLine[0] || TEXT('-') == pszCmdLine[0]) &&
  		(TEXT('I') == pszCmdLine[1] || TEXT('i') == pszCmdLine[1]))
	{
        DoInit();
	}
	else
	{
		DoService();
	}

	ExitProcess(0);
	return(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	DoInit()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called to read skeys configuration
 *              from HKEY_CURRENT_USER at logon session startup and
 *              send the information to the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoInit()
{
    HANDLE hEventSkeysServiceRunning = NULL;
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

    pSD = CreateSd(SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE);
    if (pSD)
    {
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = TRUE;
		sa.lpSecurityDescriptor = pSD;

		hEventSkeysServiceRunning = CreateEvent(
			&sa,	// Security
			TRUE,	// Manual reset?
			FALSE,  // initial state - not signaled
			RUNNINGEVENT);  // name

        free(pSD);
    }

    if (NULL != hEventSkeysServiceRunning)
	{
		DWORD dwWait;

		dwWait = WaitForSingleObject(hEventSkeysServiceRunning, 60 * 1000);

		if (WAIT_OBJECT_0 == dwWait)
		{
			SKEY_SystemParametersInfo((UINT)SK_SPI_INITUSER, 0, NULL, 0);
		}
        CloseHandle(hEventSkeysServiceRunning);
    }
	
	return;
}


/*---------------------------------------------------------------
 *
 *		SCM Interface Functions
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	DoService()
 *
 *	TYPE		Global
 *
 * PURPOSE		all DoService does is call StartServiceCtrlDispatcher
 *				to register the main service thread.  When the
 *				API returns, the service has stopped, so exit.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoService()
{
	SERVICE_TABLE_ENTRY dispatchTable[] =
	{
		{ SERVICENAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
		{ NULL, NULL }
	};
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

    s_hEventServiceRequest = CreateEvent(
		NULL,	// Security
		FALSE,	// Manual reset?
		FALSE,  // initial state - not signaled
		NULL);  // name

    s_hEventServiceRequestReady = CreateEvent(
		NULL,	// Security
		FALSE,	// Manual reset?
		TRUE,  // initial state - signaled (can accept one request even before ready)
		NULL);  // name

    s_hEventServiceTerminate = CreateEvent(
		NULL,	// Security
		TRUE,	// Manual reset?
		FALSE,  // initial state - not signaled
		NULL);  // name

    s_hEventSkeysServiceRunning = NULL;

    pSD = CreateSd(SYNCHRONIZE|EVENT_MODIFY_STATE|GENERIC_READ|GENERIC_WRITE);
    DBPRINTF(TEXT("DoService:  CreateSd %s\r\n"), (pSD)?TEXT("Succeeded"):TEXT("Failed"));
    if (pSD)
	{
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = TRUE;
		sa.lpSecurityDescriptor = pSD;

		s_hEventSkeysServiceRunning = CreateEvent(
			&sa,	// Security
			TRUE,	// Manual reset?
			FALSE,  // initial state - not signaled
			RUNNINGEVENT);  // name

        free(pSD);
	}

    if (NULL != s_hEventServiceRequest &&
		NULL != s_hEventServiceRequestReady &&
		NULL != s_hEventServiceTerminate &&
		NULL != s_hEventSkeysServiceRunning)
	{
        DBPRINTF(TEXT("DoService:  calling StartServiceCtrlDispatcher... \r\n"));
		if (!StartServiceCtrlDispatcher(dispatchTable))
        {
            DBPRINTF(TEXT("DoService:  StartServiceCtrlDispatcher FAILED\r\n"));
			StopSerialKeys(TEXT("StartServiceCtrlDispatcher failed."));
        }
    }
	else
	{
        DBPRINTF(TEXT("DoService:  Unable to create event %p %p %p %p\r\n"), s_hEventServiceRequest, s_hEventServiceRequestReady, s_hEventServiceTerminate, s_hEventSkeysServiceRunning);
		StopSerialKeys(TEXT("Unable to create event."));
	}
	
	if (NULL != s_hEventServiceRequest)
	{
	    CloseHandle(s_hEventServiceRequest);
	}

	if (NULL != s_hEventServiceRequestReady)
	{
        CloseHandle(s_hEventServiceRequestReady);
	}

	if (NULL != s_hEventServiceTerminate)
	{
        CloseHandle(s_hEventServiceTerminate);
	}

	if (NULL != s_hEventSkeysServiceRunning)
	{
		ResetEvent(s_hEventSkeysServiceRunning);
        CloseHandle(s_hEventSkeysServiceRunning);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	ServiceMain()
 *
 *	TYPE		Global
 *
 * PURPOSE		this function takes care of actually starting the service,
 *				informing the service controller at each step along the way.
 *				After launching the worker thread, it waits on the event
 *				that the worker thread will signal at its termination.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
VOID ServiceMain(DWORD dwArgc, LPTSTR *ppszArgv)
{
	DBPRINTF(TEXT("ServiceMain()\r\n"));

	//
	// SERVICE_STATUS members that don't change
	s_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	s_ssStatus.dwServiceSpecificExitCode = 0;
    
	//
	// register our service control handler:
	s_sshStatusHandle = RegisterServiceCtrlHandler(
			SERVICENAME,
			(LPHANDLER_FUNCTION) ServiceCtrl);

	if (!s_sshStatusHandle)
	{
		TerminateService(GetLastError());
		return;
	}

	// report the status to Service Control Manager.
	ReportStatusToSCMgr(
				SERVICE_START_PENDING,	// service state
				NO_ERROR,				// exit code
				1,						// checkpoint
				WAITSTARTUP);			// wait hint

#if defined(DEBUG) && 0  /////////////////////////////////////////////////
	// This debug code gives us time to attach a debugger

    {
		int i;

		for (i = 0; i < 180; i++)  // 180 sec = 3 min
		{
			Sleep(1000);  // one second
		}
    }
#endif ////////////////////////////////////////////////////////

	InitReg();
	GetUserValues(REG_DEF);

////EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);

	if (!InitService())					// Did Service Initiate successfully?
	{
		TerminateService(GetLastError());		// No Terminate With Error
		return;
	}

	ReportStatusToSCMgr(	// report status to service manager.
		SERVICE_RUNNING,	// service state
		NO_ERROR,			// exit code
		0,					// checkpoint
		0);					// wait hint
	
	SetEvent(s_hEventSkeysServiceRunning);

	ProcessService();					// Process the Service
	TerminateService(0);				// Terminate
	return;
}


BOOL IsSerialKeysAutoStart()
{
	BOOL fAutoStart = FALSE;
	BOOL fOk;

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		MAXIMUM_ALLOWED);

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    MAXIMUM_ALLOWED);

	    if (NULL != schService)
		{
			BYTE abServiceConfig[1024];
			LPQUERY_SERVICE_CONFIG pqsc = (LPQUERY_SERVICE_CONFIG)abServiceConfig;
			DWORD cbBytesNeeded;

			fOk = QueryServiceConfig(
				schService,
				pqsc,
				sizeof(abServiceConfig),
				&cbBytesNeeded);

			if (fOk)
			{
				fAutoStart = (SERVICE_AUTO_START == pqsc->dwStartType);
			}
	        CloseServiceHandle(schService);
		}
        CloseServiceHandle(schSCManager);
    }

	return fAutoStart;
}


void InstallUserInit()
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	LONG lErr;
	DWORD dwType;
	TCHAR szUserinit[LONGSTRINGSIZE];
	DWORD cbData = sizeof(szUserinit);

	lErr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
        WINLOGONPATH,
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        &hkey); 
	
    if (ERROR_SUCCESS == lErr)
	{
		lErr = RegQueryValueEx(
                hkey,
                USERINIT,
                0,
                &dwType,
                (LPBYTE)szUserinit,
                &cbData);

		if (ERROR_SUCCESS == lErr)
		{
			// check to see if we are already installed and if we have
			// enough room to install
			// the + 2 allows for the terminating null and for the command seperator char

			if (NULL == _tcsstr(szUserinit, SKEYSUSERINITCMD) &&
				    lstrlen(szUserinit) + lstrlen(SKEYSUSERINITCMD) + 2 < 
					        ARRAY_SIZE(szUserinit))
			{
				lstrcat(szUserinit, USERINITCMDSEP);
				lstrcat(szUserinit, SKEYSUSERINITCMD);

				RegSetValueEx(
					hkey,
					USERINIT,
                    0,
					REG_SZ,
				    (CONST LPBYTE)szUserinit,
				    (lstrlen(szUserinit) + 1) * 
					    sizeof(*szUserinit));
			}
		}
		RegCloseKey(hkey);
	}
    return;
}

void RemoveUserInit()
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	LONG lErr;
	DWORD dwType;
	TCHAR szUserinit[LONGSTRINGSIZE];
	PTSTR pszDest;
	PTSTR pszSrc;
	DWORD cbData = sizeof(szUserinit);

	lErr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
        WINLOGONPATH,
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        &hkey); 
	
    if (ERROR_SUCCESS == lErr)
	{
		lErr = RegQueryValueEx(
                hkey,
                USERINIT,
                0,
                &dwType,
                (LPBYTE)szUserinit,
                &cbData);

		if (ERROR_SUCCESS == lErr)
		{

			// check to see if we are already installed
			pszDest = _tcsstr(szUserinit, SKEYSUSERINITCMD);
			if (NULL != pszDest)
			{
				pszSrc =_tcsstr(pszDest, USERINITCMDSEP);
				if (NULL != pszSrc)
				{
					_tcscpy(pszDest, pszSrc+1);
				}
				else
				{
					while(szUserinit < pszDest && *SKEYSUSERINITCMD != *pszDest)
					{
						--pszDest;
					}
					*pszDest = 0;  // null terminate
				}
			}
		}
		RegCloseKey(hkey);
	}
    return;
}

static void EnableService(BOOL fOn)
{
	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		MAXIMUM_ALLOWED);

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    SERVICE_CHANGE_CONFIG | SERVICE_STOP);

	    if (NULL != schService)
		{
			ChangeServiceConfig(
				schService,
				SERVICE_WIN32_OWN_PROCESS,
				(fOn) ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
				SERVICE_NO_CHANGE,		// severity if service fails to start 
				NULL,					// pointer to service binary file name 
				NULL,					// pointer to load ordering group name 
				NULL,					// pointer to variable to get tag identifier 
				NULL,					// pointer to array of dependency names 
				NULL,					// pointer to account name of service 
				NULL,					// pointer to password for service account  
				__TEXT("SerialKeys"));	// name to display 

	        CloseServiceHandle(schService);
		}

        CloseServiceHandle(schSCManager);
    }

	if (fOn)
	{
		InstallUserInit();
	}
	else
	{
		RemoveUserInit();
	}

    return;
}


//---------------------------------------------------------------
//
// FUNCTION	void ServiceCtrl(DWORD dwCtrlCode)
//
//	TYPE		Global
//
// PURPOSE		this function is called by the Service Controller whenever
//				someone calls ControlService in reference to our service.
//
// INPUTS		DWORD dwCtrlCode -
//
// RETURNS		None
//
//-----------------------------------------------------------------
LPHANDLER_FUNCTION ServiceCtrl(DWORD dwCtrlCode)
{
	DWORD	dwState = SERVICE_RUNNING;
	DWORD	dwWait = 0;

	DBPRINTF(TEXT("ServiceCtrl()\r\n"));

	// Handle the requested control code.

	switch(dwCtrlCode)
	{
		case SERVICE_CONTROL_PAUSE:			// Pause the service if it is running.
			if (s_ssStatus.dwCurrentState == SERVICE_RUNNING)
			{
				PauseService();
				dwState = SERVICE_PAUSED;
			}
			break;

		case SERVICE_CONTROL_CONTINUE:		// Resume the paused service.
			if (s_ssStatus.dwCurrentState == SERVICE_PAUSED)
			{
				ResumeService();
				dwState = SERVICE_RUNNING;
			}
			break;

		case SERVICE_CONTROL_STOP:			// Stop the service.
			// Report the status, specifying the checkpoint and waithint,
			//  before setting the termination event.
			if (s_ssStatus.dwCurrentState == SERVICE_RUNNING)
			{
				dwState = SERVICE_STOP_PENDING;
				dwWait = 20000;
				SetEvent(s_hEventServiceTerminate);
			}
			break;

		case SERVICE_CONTROL_INTERROGATE:	// Update the service status.
		default:							// invalid control code
			break;
    }
	// send a status response.
    ReportStatusToSCMgr(dwState, NO_ERROR, 0, dwWait);
	 return(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL		ReportStatusToSCMgr()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called by the ServMainFunc() and
 *				ServCtrlHandler() functions to update the service's status
 *				to the service control manager.
 *
 * INPUTS		DWORD	dwCurrentState
 *				DWORD	dwWin32ExitCode
 *				DWORD	dwCheckPoint
 *				DWORD	dwWaitHint
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                    DWORD dwWin32ExitCode,
                    DWORD dwCheckPoint,
                    DWORD dwWaitHint)
{
	BOOL fResult;

#ifdef DEBUG
{
	switch (dwCurrentState)
	{
		case SERVICE_START_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_START_PENDING:)\r\n"));
			break;
		case SERVICE_PAUSED:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_PAUSED:)\r\n"));
			break;
		case SERVICE_CONTINUE_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_CONTINUE_PENDING:)\r\n"));
			break;
		case SERVICE_STOP_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_STOP_PENDING:)\r\n"));
			break;
		case SERVICE_STOPPED:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_STOPPED:)\r\n"));
			break;
		case SERVICE_RUNNING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_RUNNING:)\r\n"));
			break;

		default:
			DBPRINTF(TEXT("ReportStatusToSCMgr(ERROR - SERVICE_UNKNOWN)\r\n"));
			break;
	}
}
#endif


    switch (dwCurrentState)
	{
	case SERVICE_STOPPED:
	case SERVICE_START_PENDING:
	case SERVICE_STOP_PENDING:
		s_ssStatus.dwControlsAccepted = 0;
		break;
    default:
    	s_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |	SERVICE_ACCEPT_PAUSE_CONTINUE;
		break;
	}

	// These SERVICE_STATUS members are set from parameters.
	s_ssStatus.dwCurrentState	= dwCurrentState;
	s_ssStatus.dwWin32ExitCode	= dwWin32ExitCode;
	s_ssStatus.dwCheckPoint		= dwCheckPoint;
	s_ssStatus.dwWaitHint		= dwWaitHint;

	// Report the status of the service to the service control manager.

	fResult = SetServiceStatus(
		s_sshStatusHandle,				// service reference handle
		&s_ssStatus); 					// SERVICE_STATUS structure

	if (!fResult)
	{
		StopSerialKeys(TEXT("SetServiceStatus")); // If an error occurs, stop the service.
	}
	return fResult;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void StopSerialKeys(LPTSTR lpszMsg)
 *
 *	TYPE		Global
 *
 * PURPOSE		The StopSerialKeys function can be used by any thread
 *				to report an error, or stop the service.
 *
 * INPUTS		LPTSTR lpszMsg -
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
VOID StopSerialKeys(LPTSTR lpszMsg)
{
	DBPRINTF(TEXT("StopSerialKeys()\r\n"));

	PostEventLog(lpszMsg,GetLastError());	// Post to Event Log
	SetEvent(s_hEventServiceTerminate);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void PostEventLog(LPTSTR lpszMsg, DWORD Error)
 *
 *	TYPE		Local
 *
 * PURPOSE		This function post strings to the Event Log
 *
 * INPUTS		LPTSTR lpszMsg - String to send
 *				DWORD Error		- Error Code (if 0 no error)
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void PostEventLog(LPTSTR lpszMsg,DWORD Error)
{
	WORD 	ErrType = EVENTLOG_INFORMATION_TYPE;
	WORD	ErrStrings = 0;

	TCHAR   szMsg[256];
	HANDLE  hEventSource;
	LPTSTR  lpszStrings[2];

	DBPRINTF(TEXT("PostEventLog()\r\n"));

	lpszStrings[0] = lpszMsg;

	if (Error)
	{
		ErrType = EVENTLOG_ERROR_TYPE;
		ErrStrings = 2;
		wsprintf(szMsg, TEXT("SerialKeys error: %d"), Error);
		lpszStrings[0] = szMsg;
		lpszStrings[1] = lpszMsg;
	}

	hEventSource = RegisterEventSource(NULL,SERVICENAME);

	if (hEventSource != NULL)
	{
		ReportEvent
		(
			hEventSource,		// handle of event source
			ErrType,			// event type
			0,					// event category
			0,					// event ID
			NULL,				// current user's SID
			ErrStrings,			// strings in lpszStrings
			0,					// no bytes of raw data
			lpszStrings,		// array of error strings
			NULL				// no raw data
		);

		(VOID) DeregisterEventSource(hEventSource);
	}
}

/*---------------------------------------------------------------
 *
 *		Internal Service Control Functions
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	void InitService()
 *
 * PURPOSE		This function Initializes the Service & starts the
 *				major threads of the service.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL InitService()
{
	DBPRINTF(TEXT("InitService()\r\n"));

	InstallLogout();

	if (!InitDLL())
		return(FALSE);

	if (!InitLogin())
		return(FALSE);

	if (!InitComm())
		return(FALSE);

	DoServiceCommand(SC_LOG_IN);	// Set ProcessService to Login Serial Keys

	return(TRUE);
}


static void InitReg()
{
	// Set Structure pointers to Buffers
	skNewKey.cbSize = sizeof(skNewKey);
	skNewKey.lpszActivePort = szNewActivePort;
	skNewKey.lpszPort = szNewPort;

	skCurKey.cbSize = sizeof(skCurKey);
	skCurKey.lpszActivePort = szCurActivePort;
	skCurKey.lpszPort = szCurPort;

	// Set Default Values
	skNewKey.dwFlags = SERKF_AVAILABLE;

	skNewKey.iBaudRate = 300;
	skNewKey.iPortState = 2;
	lstrcpy(szNewPort,TEXT("COM1:"));
	lstrcpy(szNewActivePort,TEXT("COM1:"));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void PauseService()
 *
 * PURPOSE		This function is called to pause the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void PauseService()
{
	DBPRINTF(TEXT("PauseService()\r\n"));

	SuspendDLL();
	SuspendComm();
	SuspendLogin();
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void DoServiceCommand()
 *
 * PURPOSE		Passes a command to the service thread
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoServiceCommand(DWORD dwServiceCommand)
{
	DWORD dwWaitRet;

    dwWaitRet = WaitForSingleObject(s_hEventServiceRequestReady, 10*1000);
    
	if (WAIT_OBJECT_0 == dwWaitRet)
	{
		s_dwServiceCommand = dwServiceCommand;
		SetEvent(s_hEventServiceRequest);
	}
    else
	{
		DBPRINTF(TEXT("DoServiceCommand - wait failed or timed-out, request ignored\r\n"));
	}
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessService()
 *
 * PURPOSE		This function is the main service thread for Serial
 *				Keys. 	Is monitors the status of the other theads
 *				and responds to their request.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessService()
{
    DWORD dwServiceCommand;
	DWORD dwWaitRet;
	typedef enum {
		iheventServiceRequest,    
		iheventServiceTerminate
	};
	HANDLE ahevent[2] = {s_hEventServiceRequest, s_hEventServiceTerminate};

 	DBPRINTF(TEXT("ProcessService()\r\n"));
    
    dwWaitRet = WaitForMultipleObjects(ARRAY_SIZE(ahevent), ahevent, 
		FALSE,  // wait all?
		INFINITE);

	//  This loop will terminate when iheventServiceTerminate is signaled or
	//  WaitForMultipleObjects fails

	while (iheventServiceRequest == dwWaitRet - WAIT_OBJECT_0)
	{
		dwServiceCommand = s_dwServiceCommand;
    	SetEvent(s_hEventServiceRequestReady);

		switch (dwServiceCommand)
		{
			case SC_LOG_OUT:				// Login to New User
				DBPRINTF(TEXT("---- User Logging Out\r\n"));
				StopComm();			// Stop SerialKey Processing
				if(GetUserValues(REG_DEF))	// Get Default values & Do we Start?
				{
					EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);
					StartComm();			// Yes - Process SerialKey
				}
				break;

			case SC_LOG_IN:					// Login to New User
				DBPRINTF(TEXT("---- User Logging In\r\n"));
				StopComm();			// Stop SerialKey Processing
				if(GetUserValues(REG_DEF)) 
				{	
					EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);
					StartComm();			// Yes - Process SerialKey
				}
				break;

			case SC_CHANGE_COMM: 			// Change Comm Configuration
				DBPRINTF(TEXT("---- Making Comm Change\r\n"));
				StopComm();			// Stop SerialKey Processing
				StartComm();				// Restart SerialKey Processing
				break;

			case SC_DISABLE_SKEY:		 	// Disable Serial Keys
				DBPRINTF(TEXT("---- Disable Serial Keys\r\n"));
				StopComm();
				break;

			case SC_ENABLE_SKEY:			// Enable Serial Keys
				DBPRINTF(TEXT("---- Enable Serial Keys\r\n"));
				StartComm();
				break;
		}
		dwWaitRet = WaitForMultipleObjects(ARRAY_SIZE(ahevent), ahevent, 
			FALSE,  // wait all?
			INFINITE);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeService()
 *
 * PURPOSE		This function is called to restore the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ResumeService()
{
	DBPRINTF(TEXT("ResumeService()\r\n"));

	ResumeDLL();
	ResumeComm();
	ResumeLogin();
}

//---------------------------------------------------------------
//
// FUNCTION	void TerminateService(DWORD Error)
//
//	TYPE		Local
//
// PURPOSE		This function is called by ServiceMain to terminate
//				the server.  It closes all of the open handles &
//				and reports the service is stopped.
//
// INPUTS		DWORD Error - Any Errors that could abort the
//				Service. 0 = Normal Stop
//
// RETURNS		None
//
//---------------------------------------------------------------

static void TerminateService(DWORD Error)
{
	DBPRINTF(TEXT("TerminateService()\r\n"));

	TerminateLogout();						// Remove Logout Monitoring

	TerminateComm();						// Init Comm Thread Shutdown

	TerminateDLL();							// Init DLL Thread Shutdown

	TerminateLogin();						// Init Login Thread Shutdown

	// Loop untill all of the Threads are shut down.

	while (!DoneLogin()) 					// Loop until Login Thread is terminated
		Sleep(250);							// Sleep 

	while (!DoneDLL())	 					// Loop until DLL Thread is terminated
		Sleep(250);							// Sleep 


    // reload registery values to insure we have the current values
	GetUserValues(REG_DEF);

	EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);

	// Report the status is stopped
	if (s_sshStatusHandle)
		(VOID)ReportStatusToSCMgr(SERVICE_STOPPED,Error,0,0);
}

/*---------------------------------------------------------------
 *
 *	Logout Functions - Process Logout request
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	void InstallLogout()
 *
 * PURPOSE		This function installs a Control Handler to process
 *				logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL InstallLogout()
{
	DBPRINTF(TEXT("InstallLogout()\r\n"));

	return(SetConsoleCtrlHandler((PHANDLER_ROUTINE)ProcessLogout,TRUE));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateLogout()
 *
 * PURPOSE		This function Removes a Control Handler to process
 *				logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL TerminateLogout()
{
	DBPRINTF(TEXT("TerminateLogout()\r\n"));

	return(SetConsoleCtrlHandler((PHANDLER_ROUTINE)ProcessLogout,FALSE));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessLogout()
 *
 * PURPOSE		This function processes	logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessLogout(DWORD dwCtrlType)
{
	DBPRINTF(TEXT("ProcessLogout()\r\n"));

	if (dwCtrlType == CTRL_LOGOFF_EVENT)
	{
		DoServiceCommand(SC_LOG_OUT);

		// we'll do this each time the currently logged in user logs out
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_comm.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_COMM.H
 *
 * PURPOSE:			Function prototypes for Serial Keys Comm Routines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--------------------------------------------------------------*/

// Global Variables ---------------------------------


// Global Function ProtoTypes --------------------------------

BOOL	InitComm();
void	TerminateComm();

void 	SuspendComm();
void 	ResumeComm();

BOOL	StartComm();
void	StopComm();

void	SetCommBaud(int Baud);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_comm.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_COMM.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing the COMM ports
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

//#define	WINVER 0x0300

// added to be compatible with new windows.h (12/91) and wintric.h 
#define	USECOMM	

#include 	<stdio.h>
#include 	<stdlib.h>
#include	<process.h>

#include	"windows.h"
//#include "winstric.h"				// added for win 3.1 compatibility 1/92

#include	"gide.h"					// Serial Keys Function Proto
#include	"initgide.h"	   			// Serial Keys Function Proto
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include    "drivers.h"
#include	"sk_ex.h"

#define COMMTERMINATE 0xFFFFFFFF     // this 'character' indicates a request to terminate

// Local Function ProtoTypes --------------------------------

static BOOL	OpenComm();
static void	__cdecl ProcessComm(VOID *notUsed);
static int	ReadComm();


// Local Variables ---------------------------------------------------

static DCB	s_dcbCommNew;			// New DCB for comm port
static DCB	s_dcbCommOld;			// Origional DCB for comm port

static OVERLAPPED s_oRead;			// Overlapped structure for reading.

static	HANDLE	s_hFileComm;

static	HANDLE	s_hThreadComm = NULL;

static	HDESK	s_hdeskUser = NULL;

static	DWORD	s_NullTimer;
static	int		s_NullCount=0;

static	HANDLE  s_ahEvents[2] = {NULL, NULL};

#define iEventComm			0
#define iEventExit			1


/*---------------------------------------------------------------
 *
 *	Global Functions -
 *
 *---------------------------------------------------------------*/

 /*---------------------------------------------------------------
 *
 * FUNCTION	void InitComm()
 *
 * TYPE         Global
 *
 * PURPOSE		
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL InitComm()
{
    BOOL fOk = TRUE;

	DBPRINTF(TEXT("InitComm()\r\n"));

	// Create Event for Overlap File Read 
	s_ahEvents[iEventComm] = CreateEvent(NULL, TRUE, FALSE, NULL);	
	fOk = (NULL != s_ahEvents[iEventComm]);
	if (fOk) 
	{
		s_ahEvents[iEventExit] = CreateEvent(NULL, TRUE, FALSE, NULL);	
		fOk = (NULL != s_ahEvents[iEventExit]);
	}

	if (!fOk)
	{
		TerminateComm();
	}

	return(fOk);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called for the final shutdown of
 *				the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void TerminateComm()
{
	BOOL fOk;
	int i;

	DBPRINTF(TEXT("TerminateComm()\r\n"));

	StopComm();

	for (i = 0; i < ARRAY_SIZE(s_ahEvents); ++i)
	{
		if (NULL != s_ahEvents[i])
		{
			fOk = CloseHandle(s_ahEvents[i]);
			DBPRINTF_IF(fOk, TEXT("Unable to Close Event\r\n"));
			s_ahEvents[i] = NULL;
		}
	}

	return;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL StartComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is call to start the thread to 
 *				read and process data coming from the comm port.
 *				It will create a thread and an event.  This function
 *				assumes that the comm port is already opened.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
BOOL StartComm()
{
	BOOL fOk = TRUE;
	DWORD 	Id;

	DBPRINTF(TEXT("StartComm()\r\n"));

	// ----------------------------------------------------------
	// Note:	Comm Threads are started and stopped whenever
	// 			the com port is changed. The User logs in or out
	// 			or the comm configuration is changed.
	// ----------------------------------------------------------

	if (NULL == s_hFileComm && // no port currently in use
		(skNewKey.dwFlags & SERKF_AVAILABLE) &&
		(skNewKey.dwFlags & SERKF_SERIALKEYSON))
	{
		if (NULL != s_hThreadComm) 
		{
			// This is an unexpected situation.  We have the comm thread
			// running with no open comm port.  The thread must be hung.
			// Let's close the open handle and forget about it.

			DBPRINTF(TEXT("StartComm() unexpected (NULL != s_hThreadComm)\r\n"));
			WaitForSingleObject(s_hThreadComm, 5 * 1000);

			if (NULL != s_hThreadComm)
			{
				DBPRINTF(TEXT("StartComm() s_hThreadComm abandoned\r\n"));
				CloseHandle(s_hThreadComm);		
				s_hThreadComm = NULL;
			}
		}


		// skNewKey is used by OpenComm.  We're setting skCurKey to default
		// values in case OpenComm fails.

		skCurKey.iBaudRate = 300;				// No - Reset To Default Values
		skCurKey.iPortState= 0;
		skCurKey.dwFlags   = 0;
		lstrcpy(skCurKey.lpszActivePort, TEXT("COM1"));
		lstrcpy(skCurKey.lpszPort, TEXT("COM1"));

		if (!OpenComm())							// Did Comm Open Ok?
		{
			skNewKey.iBaudRate = 300;				// No - Reset To Default Values
			skNewKey.iPortState= 0;
			skNewKey.dwFlags   = 0;
			lstrcpy(skNewKey.lpszActivePort, TEXT("COM1"));
			lstrcpy(skNewKey.lpszPort, TEXT("COM1"));
			fOk = FALSE;
		}
		else
		{
            // ensure we start with clean events

			ResetEvent(s_ahEvents[iEventComm]);
            ResetEvent(s_ahEvents[iEventExit]);

			memset(&s_oRead, 0, sizeof(OVERLAPPED));	// Init Struct
			s_oRead.hEvent = s_ahEvents[iEventComm];	// Store Event

			// Create thread to handle Processing Comm Port
			s_hThreadComm = (HANDLE)CreateThread(	// Start Service Thread
				0, 0,
				(LPTHREAD_START_ROUTINE) ProcessComm,
				0, 0,&Id);							// argument to thread

			if (NULL == s_hThreadComm)// Is Thread Handle Valid?
			{
				// Close out the Comm Port
				SetCommState(s_hFileComm, &s_dcbCommOld);	// Restore Comm State 
				CloseHandle(s_hFileComm);
				s_hFileComm = NULL;
				skCurKey.iPortState = 0;

				fOk = FALSE;
			}
			else
			{
				// Comm Thread Successfully Started Set The Current Values
				skCurKey.iBaudRate = skNewKey.iBaudRate;
				skCurKey.iPortState	 = 2;
				skCurKey.dwFlags = SERKF_SERIALKEYSON	
									| SERKF_AVAILABLE	
									| SERKF_ACTIVE;

				lstrcpy(skCurKey.lpszActivePort, skNewKey.lpszActivePort);
				lstrcpy(skCurKey.lpszPort, skNewKey.lpszActivePort);

				DBPRINTF(TEXT("---- Comm Started\r\n"));
			}
		}
	}
	return(fOk);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendComm()
{
	DBPRINTF(TEXT("SuspendComm()\r\n"));

	if (NULL != s_hThreadComm)
	{
		SuspendThread(s_hThreadComm);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeComm()
{
	if (s_hThreadComm != NULL)
		ResumeThread(s_hThreadComm);	
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void StopComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to stop the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void StopComm()
{
	DBPRINTF(TEXT("StopComm()\r\n"));

	if (NULL != s_hFileComm)
	{
		skCurKey.dwFlags = SERKF_AVAILABLE;	

		SetEvent(s_ahEvents[iEventExit]);

		if (NULL != s_hThreadComm)
		{
			DWORD dwRet;
			BOOL fOk;

			dwRet = WaitForSingleObject(s_hThreadComm, 5 * 1000);
            DBPRINTF_IF(WAIT_OBJECT_0 == dwRet, TEXT("StopComm() Comm Thread may be hung.\r\n"));
			CloseHandle(s_hThreadComm);		
			s_hThreadComm = NULL;

			SetCommState(s_hFileComm, &s_dcbCommOld);	// Restore Comm State 
			fOk = CloseHandle(s_hFileComm);			// Close the Comm Port
			DBPRINTF_IF(fOk, TEXT("Unable to Close Comm File\r\n"));
			s_hFileComm = NULL;

			skCurKey.iPortState	 = 0;
		}
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SetCommBaud(int Baud)
 *
 *	TYPE		Global
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void SetCommBaud(int Baud)
{
	DBPRINTF(TEXT("SetCommBaud(%d)\r\n"), Baud);

	switch (Baud)				// Check for Valid Baud Rates
	{
		case 300:
		case 600:
		case 1200:
		case 2400:
		case 4800:
		case 9600:
		case 19200:
		case 110:
		case 14400:
		case 38400:
		case 56000:
		case 57600:
		case 115200:
			break;				// Baud Ok

		default:
			return;				// Baud Invalid
	}

	skNewKey.iBaudRate = Baud;				            // Save Baud

	if (NULL != s_hFileComm)						    // Is Comm Port Open?
	{
		s_dcbCommNew.BaudRate = skNewKey.iBaudRate;	    // Set new DCB Params
        if (SetCommState(s_hFileComm, &s_dcbCommNew))   // State Change Ok?
        {
		    skCurKey.iBaudRate = skNewKey.iBaudRate;	// Save New Baud Rate
        } else
        {
            DBPRINTF(TEXT("SetCommState(%d) FAILED!\r\n"), Baud);
            // failed to set baud rate; try to revert it
		    s_dcbCommNew.BaudRate = skCurKey.iBaudRate; // reset DCB Params
  		    if (!SetCommState(s_hFileComm, &s_dcbCommNew))
                DBPRINTF(TEXT("SetCommState(%d) FAILED!\r\n"), skCurKey.iBaudRate);
        }
	}
}

/*---------------------------------------------------------------
 *
 *		Local Functions
 *
/*---------------------------------------------------------------


/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ProcessComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		The function is the thread the cycles thru reading
 *				processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ProcessComm(VOID *notUsed)
{
	int 	c;
	HWINSTA	hwinstaSave;
	HWINSTA	hwinstaUser;
	HDESK	hdeskSave;
	DWORD	dwThreadId;
	BOOL    fCont;

	//------------------------------------------------------
	//
	// Note:
	//	The following code set the input focus to the current
	//  desktop.  It is needed to insure that keyboard and mouse
	//	events  will be passed to the current desktop.
	//
	//------------------------------------------------------

	hwinstaSave = GetProcessWindowStation();
	dwThreadId = GetCurrentThreadId();
	hdeskSave = GetThreadDesktop(dwThreadId);

	hwinstaUser = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	SetProcessWindowStation(hwinstaUser);


	serialKeysStartUpInit();				// Initialize the Serial Keys
	fCont = TRUE;

	while (fCont)
	{
		c = ReadComm();						// Read Char from Com Port
		switch (c)
		{
		case 0:
			// Is Character a Null

			// Is Null Timer > 30 Seconds
			if ((GetTickCount() - s_NullTimer) > 30000) 
			{
				s_NullTimer = GetTickCount();	// Yes - Reset Timer
				s_NullCount = 1;				// Reset Null Count
			} else 	{
				
				s_NullCount++;				// No - Inc Null Count
				if (s_NullCount == 3)		// Have we had 3 Null in 30 Sec.?
				{
					// the user is requesting us to reset
					SetCommBaud(300);		

					// DeskSwitch should be unnessary, but if it gets out of sync,
					// this is where we resync

					s_NullCount = 0;		// Reset Null Counter
				}
			}
			break;		
			
		case COMMTERMINATE:
			fCont = FALSE;
			break;

		default:
			DeskSwitchToInput();
			serialKeysBegin((UCHAR)c);	// Process Char
			break;

		}
	}

	SetThreadDesktop(hdeskSave);
	SetProcessWindowStation(hwinstaSave);
	CloseDesktop(s_hdeskUser);
	s_hdeskUser = NULL;
	CloseWindowStation(hwinstaUser);

	ExitThread(0);					// Close Thread
}


/*---------------------------------------------------------------
 *
 * BOOL IsCommPortName()
 *
 * Determines whether a given filename is a valid COM port name.
 * Used by OpenComm so that it doesn't open a remote file or named
 * pipe instead.
 *
 *---------------------------------------------------------------*/
static BOOL IsCommPortName( LPCTSTR pszFilename )
{
    // Ensure that filename has form:
    // COMn[n]\0
    LPCTSTR pScan = pszFilename;

    // Must start with COMn, where COM can be any case,
    // and n is any 0..9 digit.
    if( *pScan != 'C' && *pScan != 'c' )
        return FALSE;
    pScan++;
    if( *pScan != 'O' && *pScan != 'o' )
        return FALSE;
    pScan++;
    if( *pScan != 'M' && *pScan != 'm' )
        return FALSE;
    pScan++;

    if( *pScan < '0' || *pScan > '9' )
        return FALSE;
    pScan++;

/*
    // TODO: are COM54 really allowed?
    // Optional second digit
    if( *pScan >= '0' && *pScan <= '9' )
        pScan++;
*/

    // Manditory terminating nul
    if( *pScan != '\0' )
        return FALSE;

    return TRUE;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL OpenComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		This Function opens the comm port and sets the new
 *				sets the Device Control Block.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Open Ok / FALSE - Open Failed
 *
 *---------------------------------------------------------------*/
static BOOL OpenComm()
{
	BOOL fOk = FALSE;
	COMMTIMEOUTS ctmo;

    // Check that the path we're given looks like a COM port.
    // (Not, eg, a remote file or named pipe.)
    if( ! IsCommPortName( skNewKey.lpszActivePort ) )
    {
		DBPRINTF(TEXT("- Not a COMn port\r\n"));
		s_hFileComm = NULL;
        return FALSE;
    }

    // The Security flags ensure that if we are duped into opening
    // a named pipe, we'll do so anonymously, so that we can't be
    // impersonated.
	s_hFileComm = CreateFile(
			skNewKey.lpszActivePort,// FileName (Com Port)
			GENERIC_READ ,			// Access Mode
			0,						// Share Mode
			NULL,					// Address of Security Descriptor
			OPEN_EXISTING,			// How to Create	
			FILE_ATTRIBUTE_NORMAL	// File Attributes
			| FILE_FLAG_OVERLAPPED  // Set for Async File Reads
            | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, // see above comment
  			NULL);					// Templet File.

	if (INVALID_HANDLE_VALUE == s_hFileComm)	// File Ok?
	{
		DBPRINTF(TEXT("- Invalid File\r\n"));

		s_hFileComm = NULL;
	}
	else
	{
		BOOL fRet;
		COMMPROP cmmp;

		SetupComm(
			s_hFileComm,
			1024,	// size of input buffer
			1024);	// size of output buffer

		memset(&s_dcbCommOld, 0, sizeof(s_dcbCommOld));
		s_dcbCommOld.DCBlength = sizeof(s_dcbCommOld);

		GetCommState(s_hFileComm, &s_dcbCommOld);	// Save Old DCB for restore
		s_dcbCommNew = s_dcbCommOld;	// Copy to New

		// set XoffLim and XonLim based on actual buffer size

		fRet = GetCommProperties(s_hFileComm, &cmmp);
		if (fRet)
		{
			s_dcbCommNew.XoffLim = (WORD)(cmmp.dwCurrentRxQueue / 4);
			s_dcbCommNew.XonLim = (WORD)(cmmp.dwCurrentRxQueue / 4);
		}

		s_dcbCommNew.BaudRate	= skNewKey.iBaudRate; 	// Set new DCB Params
		s_dcbCommNew.ByteSize	= 8;
		s_dcbCommNew.Parity 	= NOPARITY;
		s_dcbCommNew.StopBits	= ONESTOPBIT;
		s_dcbCommNew.fOutX 		= FALSE;  	// XOn/XOff used during transmission
  		s_dcbCommNew.fInX 		= TRUE;	  	// XOn/XOff used during reception 
  		s_dcbCommNew.fNull 		= FALSE;  	// tell windows not to strip nulls 
  		s_dcbCommNew.fBinary	= TRUE;

  		s_dcbCommNew.fOutxCtsFlow	= FALSE;
  		s_dcbCommNew.fOutxDsrFlow	= FALSE;
  		s_dcbCommNew.fDtrControl	= DTR_CONTROL_ENABLE;
  		s_dcbCommNew.fDsrSensitivity   = FALSE;
  		s_dcbCommNew.fErrorChar		= TRUE;
  		s_dcbCommNew.fRtsControl	= RTS_CONTROL_DISABLE;
  		s_dcbCommNew.fAbortOnError	= FALSE;
  		s_dcbCommNew.XonChar		= (char)0x11;
  		s_dcbCommNew.XoffChar		= (char)0x13;
  		s_dcbCommNew.ErrorChar		= '\0';

  		fOk = SetCommState(s_hFileComm, &s_dcbCommNew);

		memset(&ctmo, 0, sizeof(ctmo));
		SetCommTimeouts(s_hFileComm, &ctmo);
	}

	if (!fOk && NULL != s_hFileComm)
	{
		CloseHandle(s_hFileComm);
		s_hFileComm = NULL;
	}

	return(fOk);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	int ReadComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		This Function reads a character from the comm port.
 *				If no character is present it wait on the HEV_COMM
 *				Event untill a character is present
 *
 * INPUTS		None
 *
 * RETURNS		int - Character read (-1 = Error Read)
 *
 *---------------------------------------------------------------*/
static int ReadComm()
{
	int     nRet;
	DWORD	cbRead = 0;
	DWORD	lastError, ComError;
	DWORD	dwRetWait;
	BOOL    fOk;
	BOOL    fExit;

	BOOL	fExitLoop = FALSE;		// Boolean Flag to exit loop.
	UCHAR   uchBuff;
	COMSTAT ComStat;
	
	fExit = (WAIT_OBJECT_0 == WaitForSingleObject(s_ahEvents[iEventExit], 0));

	if (!fExit)
	{
		fOk = ReadFile(s_hFileComm, &uchBuff, 1, &cbRead, &s_oRead);

		if (!fOk)						// Was there a Read Error?
		{
			lastError = GetLastError();	// This var can be useful for debugging
			switch (lastError)			
			{
			// If Error = IO_PENDING, wait til
			// the event hadle signals success,
			case ERROR_IO_PENDING:
				dwRetWait = WaitForMultipleObjects(
					ARRAY_SIZE(s_ahEvents), s_ahEvents, FALSE, INFINITE);

				switch (dwRetWait - WAIT_OBJECT_0)
				{
				case iEventComm:
					// this is the expected event
					GetOverlappedResult(s_hFileComm, &s_oRead, &cbRead, FALSE);

					if (cbRead < 1)			// Did we read bytes;
					{
						// There was some error, return null
						nRet = 0;
					}
					else
					{
						nRet = uchBuff;
					}
					break;

				case iEventExit:
					fExit = TRUE;
					// fall through

				default:
					// this indicates and error and we exit to prevent loop
					nRet = COMMTERMINATE;
					break;
				}
				break;

			default:	
				fOk = ClearCommError(s_hFileComm, &ComError,&ComStat);
				if (fOk)
				{
					nRet = 0;          // return a null
				}
				else
				{
					nRet = COMMTERMINATE;        // terminate
				}
				break;
			}
		}
		else
		{
			if (cbRead < 1)			// Did we read bytes;
			{
				// There was some error, return null
				nRet = 0;
			}
			else
			{
				nRet = uchBuff;
			}

		}
	}
	if (fExit)
	{
		ResetEvent(s_ahEvents[iEventExit]);
		nRet = COMMTERMINATE;
	}
	return(nRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_dllif.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLLIF.H
 *
 * PURPOSE:			The file contains data structures for the 
 *					transmission of information between the 
 *					SerialKeys and the DLL.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

typedef struct _SKEYDLL
{
	int		Message;					// Get or Set Changes
	DWORD	dwFlags;
	char	szActivePort[MAX_PATH];
	char	szPort[MAX_PATH];
	DWORD	iBaudRate;
	DWORD	iPortState;
	DWORD	iSave;						// TRUE - Write to Registry
} SKEYDLL;


// Messages

#define	SKEY_NAME			TEXT("\\\\.\\PIPE\\SKeys")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_dll.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLL.H
 *
 * PURPOSE:			The file contains the Functions responsible for
 *					managing information passed between SerialKeys
 *					and the SerialKeys DLL
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

// Global Variables ---------------------------------

// Global Function Prototypes ---------------------------------

BOOL DoneDLL();
BOOL InitDLL();
void ResumeDLL();
void SuspendDLL();
void TerminateDLL();

// Helper functions

PSECURITY_DESCRIPTOR CreateSd(unsigned long ulRights);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_ex.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_EX.h
 *
 * PURPOSE:			Header file for SK_EX.C
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/
BOOL SkEx_GetAnchor(LPPOINT Mouse);
void SkEx_SetAnchor();
void SkEx_SendBeep();
void SkEx_SendKeyUp(int scanCode); 			// Send char from SerialKeys
void SkEx_SendKeyDown(int scanCode);
void SkEx_SendMouse(MOUSEKEYSPARAM *p);		// Send mouse from SerialKeys
void SkEx_SetBaud(int Baud);

BOOL DeskSwitchToInput();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_login.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_LOGIN.H
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

// Global Variables -------------------------------------------


// Global Function Prototypes ---------------------------------

BOOL DoneLogin();
BOOL InitLogin();
void ResumeLogin();
void SuspendLogin();
void TerminateLogin();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_dll.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLL.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing information passed between SerialKeys
 *					and the SerialKeys DLL
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/
#include	<process.h>

#include	"windows.h"
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_reg.h"
#include	"sk_dll.h"
#include	"sk_dllif.h"
#include <malloc.h>

#ifdef DEBUG

    void dbg_Output(LPSTR Header)
    {
	    DBPRINTF(Header);
	    DBPRINTF(TEXT("-- dwFlags (%d)  iBaudRate (%d) Save (%d) iPortState (%d)\r\n"), SKeyDLL.dwFlags,SKeyDLL.iBaudRate,SKeyDLL.iSave,SKeyDLL.iPortState);
	    DBPRINTF(TEXT("-- ActivePort (%s) Port (%s)\r\n"),SKeyDLL.szActivePort,SKeyDLL.szPort);
    }

    #define	DBG_DUMP(Header)	dbg_Output(Header)
#else
    #define	DBG_DUMP(Header)	
#endif

// Defines --------------------------------------------------

// Local Function Prototypes ---------------------------------

static void CleanUpDLL();
static void GetCurrentValues();
static void GetNewValues();
static void ProcessDLL();
static BOOL ReadDLL();
static void __cdecl ServiceDLL(VOID *notUsed);
static BOOL WriteDLL();

// Local Variables --------------------------------------------------

static OVERLAPPED	OverLapRd;		// Overlapped structure for reading.
static SKEYDLL		SKeyDLL; 		// Input buffer for pipe.

static BOOL			fExitDLL; 			// Set Exit Flag
static BOOL			fDoneDLL = TRUE;

static	HANDLE		hPipeDLL;
static	HANDLE		hThreadDLL;

/*---------------------------------------------------------------
 *
 *	Global Functions 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL DoneDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the state of the DLL Thread
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - DLL Thread not running
 * 			FALSE - DLL Thread Is running
 *
 *---------------------------------------------------------------*/
BOOL DoneDLL()
{
	return(fDoneDLL);
}

//-----------------------------------------------------------------------------
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with an authenticated user DACL and the
// rights specified by ulRights.
//
// Caller must call free() on the returned buffer if not NULL.
//
PSECURITY_DESCRIPTOR
CreateSd(unsigned long ulRights)
{
    PSECURITY_DESCRIPTOR pSd = NULL;
    PSID psidAuthentUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    // Make a SID for a local administrator
	if (AllocateAndInitializeSid(&NtAuthority, 2,
                 SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &psidAuthentUser))
    {
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.

        ULONG cbAclSize = sizeof (ACL)
             + (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))
             + GetLengthSid(psidAuthentUser);

        pSd = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + cbAclSize);

        if (pSd) 
        {
            ACL *pAcl = (ACL *)((BYTE *)pSd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (   !InitializeAcl(pAcl, cbAclSize, ACL_REVISION)
                || !AddAccessAllowedAce(pAcl, ACL_REVISION, ulRights, psidAuthentUser)
                || !InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION)
                || !SetSecurityDescriptorDacl(pSd, TRUE, pAcl, FALSE)) 
            {
                free(pSd);   // error!
                pSd = NULL;
            }
        }

        FreeSid(psidAuthentUser);
    }

    return pSd;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL InitDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function creates a thread that monitors when an
 *				application uses the DLL to Get or Set the state
 *				of Serial Keys.  
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Init ok & Thread installed
 *				FALSE- Thread failed
 *
 *---------------------------------------------------------------*/
BOOL InitDLL()
{
	DWORD Id;
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

	DBPRINTF(TEXT("InitDLL()\r\n"));

	hPipeDLL	= INVALID_HANDLE_VALUE;
	hThreadDLL	= NULL;
	fExitDLL 	= FALSE;

    pSD = CreateSd(FILE_CREATE_PIPE_INSTANCE|GENERIC_READ|GENERIC_WRITE);
	if (!pSD)
		return(FALSE);

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = pSD;

    hPipeDLL = CreateNamedPipe(
  		SKEY_NAME, 						// Pipe name
		PIPE_ACCESS_DUPLEX,	 			// 2 way pipe.
		PIPE_TYPE_MESSAGE | 
		PIPE_READMODE_MESSAGE | 
		PIPE_WAIT,
		1,							// Maximum instance limit.
		0,							// Buffer sizes.
		0,
		1000 * 30,					// Specify time out.
		&sa);						// Default securities specified.

	free(pSD);

	if (INVALID_HANDLE_VALUE == hPipeDLL)
	{
		hPipeDLL = NULL;
		DBPRINTF(TEXT("Unable to Create DLL Named Pipe\r\n"));
		return FALSE;
	}
	
	fDoneDLL = FALSE;  						// Clear Thread Done Flag

	// Generate thread to handle DLL processing;
	hThreadDLL = (HANDLE)CreateThread(	// Start Service Thread
		0,
		0,
		(LPTHREAD_START_ROUTINE) ServiceDLL,
		0,0,&Id);								// argument to thread

	if (NULL == hThreadDLL)
	{
		DBPRINTF(TEXT("Unable to Create DLL Thread\r\n"));
		CleanUpDLL();
		return FALSE;
	}

	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendDLL()
{
	if (NULL != hThreadDLL)
	{
		SuspendThread(hThreadDLL);	
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeDLL()
{
	if (NULL != hThreadDLL)
	{
		ResumeThread(hThreadDLL);	
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called to Terminate the DLL Process
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void TerminateDLL()
{
	DWORD bytesRead;

	DBPRINTF(TEXT("TerminateDLL()\r\n"));

	if (fDoneDLL)
		return;

	fExitDLL = TRUE;					// Set Exit Flag

	CallNamedPipe						// Trigger the DLL to Shutdown
	(
		SKEY_NAME, 						// Pipe name
		&SKeyDLL, sizeof(SKeyDLL),
		&SKeyDLL, sizeof(SKeyDLL),
		&bytesRead, NMPWAIT_NOWAIT
	);
}

/*---------------------------------------------------------------
 *
 *	Local Functions 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION    static void CleanUpDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function cleans up file handles and misc stuff
 *				when the thread is terminated.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CleanUpDLL()
{
	BOOL	Stat;

	DBPRINTF(TEXT("CleanUpDLL()\r\n"));

	// Close Pipe Handle
	if (NULL != hPipeDLL)
	{
		Stat = CloseHandle(hPipeDLL);
		DBPRINTF_IF(Stat,TEXT("Unable to Close DLL Pipe\r\n"));
	}

	// Close Thread Handle 
	if (NULL != hThreadDLL)
	{
		Stat = CloseHandle(hThreadDLL);
		DBPRINTF_IF(Stat,TEXT("Unable to Close DLL Thread\r\n"));
	}

	hPipeDLL	= NULL;
	hThreadDLL	= NULL;
	fDoneDLL = TRUE;							// Set Thread Done Flag
	DBPRINTF(TEXT("DLL Service Processing Done\r\n"));
}

/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ServiceDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function is a thread that monitors when an
 *				application uses the DLL to Get or Set the state
 *				of Serial Keys.  
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ServiceDLL(VOID *notUsed)
{
	DWORD	retCode;
	DWORD	bytesRead;
	DWORD	bytesWritten;

	DBPRINTF(TEXT("SericeDLL()\r\n"));

	while (TRUE)
	{
		if (!ConnectNamedPipe(hPipeDLL,NULL))
		{
			ExitThread(0);
			return;
		}	

		if (fExitDLL)			// Is the Service Done?
		{						// Yes - Close Down Service
			CleanUpDLL();		// Close Handles Etc.
			ExitThread(0);		// Exit The Thread
			return;
		}
		
		retCode = ReadFile(		// Read Message
				hPipeDLL, 
				&SKeyDLL, 
				sizeof(SKeyDLL), 
				&bytesRead, 
				NULL);

		if (!retCode) 			// Pipe is Broken Try & reconnect
			continue;

		ProcessDLL();	  		// Yes - Process incoming buffer

		retCode = WriteFile(	// Write Message
			hPipeDLL, 
			&SKeyDLL, 
			sizeof(SKeyDLL), 
			&bytesWritten, 
			NULL);

		if (!retCode) 			// Pipe is Broken Try & reconnect
			continue;

		DisconnectNamedPipe(hPipeDLL);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function process the input buffer received from
 *				the DLL.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessDLL()
{
	DWORD	dwService;

	DBPRINTF(TEXT("ProcessDLL()\r\n"));

	dwService = SC_CHANGE_COMM;			

	switch (SKeyDLL.Message)			// Validate Message
	{
		case SPI_GETSERIALKEYS:
			if (skCurKey.dwFlags & SERKF_ACTIVE)	// Are We Disabled?
				GetCurrentValues();					// No - Send the actual Values
			else
				GetNewValues();						// Yes - Send the Proposed values
			DBG_DUMP("---Info Sent");
			return;
			
		case SPI_SETSERIALKEYS:
			DBG_DUMP("---Info Received");
			if ((SKeyDLL.dwFlags & SERKF_SERIALKEYSON) &&	// Are We Truning on &
				(SKeyDLL.dwFlags & SERKF_AVAILABLE))		// Is SerialKeys Available
			{
				if (!(skCurKey.dwFlags & SERKF_ACTIVE))		// Are We Disabled?
				{
					dwService = SC_ENABLE_SKEY;				// Yes - Turn SKeys On
					DBPRINTF(TEXT("Turn Serial Key On\r\n"));
				}
			}

			if (!(SKeyDLL.dwFlags & SERKF_SERIALKEYSON) &&	// Are We Truning off &
				(SKeyDLL.dwFlags & SERKF_AVAILABLE))		// Is SerialKeys Available
			{
				if (skCurKey.dwFlags & SERKF_ACTIVE) 		// Are We Active?
				{
					dwService = SC_DISABLE_SKEY;  			// Yes - Turn SKeys Off
					DBPRINTF(TEXT("Turn Serial Key Off\r\n"));
				}
			}

			skNewKey.iBaudRate	= SKeyDLL.iBaudRate;
			skNewKey.dwFlags 	= SKeyDLL.dwFlags;

#ifdef UNICODE
			MultiByteToWideChar(
				CP_ACP, 0, SKeyDLL.szActivePort, -1,
 				skNewKey.lpszActivePort, MAX_PATH);

			MultiByteToWideChar(
				CP_ACP, 0, SKeyDLL.szPort, -1,
				skNewKey.lpszPort, MAX_PATH);
#else
			lstrcpy(skNewKey.lpszActivePort,SKeyDLL.szActivePort);
			lstrcpy(skNewKey.lpszPort,SKeyDLL.szPort);
#endif

			if (*skNewKey.lpszPort == 0)
			{
                lstrcpy(skNewKey.lpszPort, skNewKey.lpszActivePort);	
			}

			// the calling dll is now responsible for saving the
			// settings because it's running in the user context
			// and can access HKEY_CURRENT_USER.  Here we're
			// running as a service (as the system) and have
			// no HKEY_CURRENT_USER
			
			DoServiceCommand(dwService);

			Sleep(1000);							// Sleep 1 Sec to set values

			if (SKeyDLL.dwFlags & SERKF_SERIALKEYSON) 	// Are We Truning on 
				GetCurrentValues();					// Yes - Send the actual Values
			else
				GetNewValues();						// No - Send the Proposed values

			DBG_DUMP("---Info Sent");
			break;

		default:
			return;
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetCurrentValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetCurrentValues()
{
	DBPRINTF(TEXT("GetCurrentValues()\r\n"));

#ifdef UNICODE
	WideCharToMultiByte(
		CP_ACP, 0, skCurKey.lpszActivePort, -1, 
		SKeyDLL.szActivePort, sizeof(SKeyDLL.szActivePort), NULL, NULL);

	WideCharToMultiByte(
		CP_ACP, 0, skCurKey.lpszPort, -1, 
		SKeyDLL.szPort, sizeof(SKeyDLL.szPort), NULL, NULL);
#else
	lstrcpy(SKeyDLL.szActivePort,skCurKey.lpszActivePort);
	lstrcpy(SKeyDLL.szPort,skCurKey.lpszPort);
#endif

	SKeyDLL.dwFlags		= skCurKey.dwFlags;
	SKeyDLL.iBaudRate	= skCurKey.iBaudRate;
	SKeyDLL.iPortState	= skCurKey.iPortState;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetNewValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetNewValues()
{
	DBPRINTF(TEXT("GetNewValues()\r\n"));


    // FEATURE a-jimhar 04-03-96 this next line is suspect.  May need to 
	// change 'skCurKey.dwFlags' to 'skNewKey.dwFlags.  This is either
	// a mistake or was done to always return the current flags.

	SKeyDLL.dwFlags		= skCurKey.dwFlags;

	SKeyDLL.iBaudRate	= skNewKey.iBaudRate;
	SKeyDLL.iPortState	= skNewKey.iPortState;

#ifdef UNICODE
	WideCharToMultiByte(
		CP_ACP, 0, skNewKey.lpszActivePort, -1, 
		SKeyDLL.szActivePort, sizeof(SKeyDLL.szActivePort), NULL, NULL);

	WideCharToMultiByte(
		CP_ACP, 0, skNewKey.lpszPort, -1, 
		SKeyDLL.szPort, sizeof(SKeyDLL.szPort), NULL, NULL);
#else
	lstrcpy(SKeyDLL.szActivePort,skNewKey.lpszActivePort);
	lstrcpy(SKeyDLL.szPort,skNewKey.lpszPort);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_ex.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_EX.C
 *
 * PURPOSE:		This File contains the interface routines
 *					that connect Serial Keys to the Mouse or keyboard.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

#include	<windows.h>
#include    <winable.h>
#include    "w95trace.h"
#include 	"vars.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include 	"sk_ex.H"

#ifdef QUEUE_BUF
typedef	struct _KEYQUE
{
	BYTE	VirKey;
	BYTE	ScanCode;
	int		Flags;
} KEYQUE;

#define MAXKEYS 100

KEYQUE KeyQue[MAXKEYS];
int	KeyFront = 0;		// Pointer to front of Que
int	KeyBack	= 0;		// Pointer to Back of Que
#endif


#define 	CTRL		56
#define 	ALT			29
#define 	DEL			83

char    Key[3];
int     Push = 0;

POINT 		MouseAnchor;
HWND		MouseWnd;

static	HDESK	s_hdeskSave = NULL;
static	HDESK	s_hdeskUser = NULL;


// Local Function Prototypes -------------------------------------

static void SendAltCtrlDel();
static void CheckAltCtrlDel(int scanCode);
static void AddKey(BYTE VirKey, BYTE ScanCode, int Flags);

/* 
AdjustPixels takes the point and adjusts it such that the  
mouse cursor moves in pixels.  The system applies acceleration
to the MOUSEINPUT {dx, dy} values then scales that based on mouse
speed so this code converts the pixels into MOUSEINPUT {dx, dy}
values.
*/

int g_aiMouseParms[3] = {-1, -1, -1};
float g_fSpeedScaleFactor = 0.0;

#define MOU_THRESHOLD_1  g_aiMouseParms[0]
#define MOU_THRESHOLD_2  g_aiMouseParms[1]
#define MOU_ACCELERATION g_aiMouseParms[2]
#define MOU_SPEED_SCALE  g_fSpeedScaleFactor

#ifndef SPI_GETMOUSESPEED
#define SPI_GETMOUSESPEED   112
#endif

void AdjustPixels(int *pX, int *pY)
{
    int iX = abs(*pX);
    int iY = abs(*pY);
    int iSignX = ((*pX) >= 0)?1:-1;
    int iSignY = ((*pY) >= 0)?1:-1;

    if (!iX && !iY)
        return; // optimization for {0,0} case

    if (MOU_THRESHOLD_1 == -1)
    {
        // This code assumes the user won't changes these settings 
        // from mouse CPL w/o restarting the service.
        int iSpeed;
        SystemParametersInfo(SPI_GETMOUSE, 0, g_aiMouseParms, 0);
        SystemParametersInfo(SPI_GETMOUSESPEED, 0, &iSpeed, 0);
        g_fSpeedScaleFactor = (float)iSpeed/(float)10.0;
    }

    /*
        The system applies two tests to the specified relative mouse motion 
        when applying acceleration. If the specified distance along either 
        the x or y axis is greater than the first mouse threshold value, and 
        the mouse acceleration level is not zero, the operating system doubles 
        the distance.  If the specified distance along either the x- or y-axis 
        is greater than the second mouse threshold value, and the mouse 
        acceleration level is equal to two, the operating system doubles the 
        distance that resulted from applying the first threshold test. It is 
        thus possible for the operating system to multiply relatively-specified 
        mouse motion along the x- or y-axis by up to four times.
    */
    if (MOU_ACCELERATION)
    {
        if (iX > MOU_THRESHOLD_1)
            iX /= 2;
        if (iY > MOU_THRESHOLD_1)
            iY /= 2;

        if (MOU_ACCELERATION == 2)
        {
            if (iX > MOU_THRESHOLD_2)
                iX /= 2;
            if (iY > MOU_THRESHOLD_2)
                iY /= 2;
        }
    }

    /*
        Once acceleration has been applied, the system scales the resultant 
        value by the desired mouse speed. Mouse speed can range from 1 (slowest) 
        to 20 (fastest) and represents how much the pointer moves based on the 
        distance the mouse moves. The default value is 10, which results in no 
        additional modification to the mouse motion. 
    */
    *pX = (int)((float)iX/MOU_SPEED_SCALE) * iSignX;
    *pY = (int)((float)iY/MOU_SPEED_SCALE) * iSignY;
}


/*---------------------------------------------------------------
 *	Public Functions
/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SetAnchor()
 *
 *	TYPE		Global
 *
 * PURPOSE		Sets an anchor to the current mouse position within
 *				the current window.
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SetAnchor()
{
	GetCursorPos(&MouseAnchor);

	DBPRINTF(TEXT("SkEx_SetAnchor( x %d y %d )\r\n"), MouseAnchor.x, MouseAnchor.y);

//	MouseWnd = GetActiveWindow();
//	ScreenToClient(MouseWnd, &MouseAnchor);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_GetAnchor()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the mouse postion within the active window
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL SkEx_GetAnchor(LPPOINT Mouse)
{
#if 0
	HWND	CurrentWnd;

	CurrentWnd = GetActiveWindow();

	if (CurrentWnd != MouseWnd)			// Has the Active window Changed?
		return(FALSE);					// Yes Return False

	ClientToScreen(MouseWnd, &MouseAnchor);	// Convert Window to Screen

#endif

	Mouse->x = MouseAnchor.x;
	Mouse->y = MouseAnchor.y;

	DBPRINTF(TEXT("SkEx_GetAnchor( x %d y %d )\r\n"), MouseAnchor.x, MouseAnchor.y);

	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendBeep()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Down events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendBeep()
{
	MessageBeep(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SetBaud(int Baud)
 *
 *	TYPE		Global
 *
 * PURPOSE		Sets the Baudrate for the current port
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SetBaud(int Baud)
{
	DBPRINTF(TEXT("SkEx_SetBaud()\r\n"));

	SetCommBaud(Baud);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendKeyDown()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Down events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendKeyDown(int scanCode)
{
	BYTE c;
	int	Flags = 0;

	if (scanCode & 0xE000)				// Is this and Extended Key
	{
		Flags  = KEYEVENTF_EXTENDEDKEY;	// Yes - Set Ext Flag
		scanCode &= 0x000000FF;			// Clear out extended value
	}
	c = (BYTE)MapVirtualKey(scanCode, 3);

	if (scanCode == ALT || scanCode == CTRL || scanCode == DEL)
		CheckAltCtrlDel(scanCode);

	DBPRINTF(TEXT("SkEx_SendKeyDown(Virtual %d Scan %d Flag %d)\r\n"), c, scanCode, Flags);

	DeskSwitchToInput();         
	keybd_event(c, (BYTE) scanCode, Flags, 0L);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendKeyDown()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Up events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendKeyUp(int scanCode)
{
	BYTE	c;
	int		Flags = 0;

	if (Push)
	{
		Key[0] = Key[1] = Key[2] = 0;	// Clear Buffer
		Push = 0;						// Reset AltCtrlDel
	}

	if (scanCode & 0xE000)				// Is this and Extended Key
	{
		Flags  = KEYEVENTF_EXTENDEDKEY;	// Yes - Set Ext Flag
		scanCode &= 0xFF;				// Clear out extended value
	}

	Flags += KEYEVENTF_KEYUP;
	c = (BYTE) MapVirtualKey(scanCode, 3);

	DBPRINTF(TEXT("SkEx_SendKeyUp(Virtual %d Scan %d Flags %d)\r\n"), c, scanCode, Flags);

    DeskSwitchToInput();         
	keybd_event(c, (BYTE) scanCode, Flags, 0L);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendMouse()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Mouse Events to the Event manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendMouse(MOUSEKEYSPARAM *p)
{
    INPUT input;

    // According to GIDEI spec, the move command specifies pixels. 
    // SendInput adjusts the XY values based on acceleration and
    // mouse speed so we need to adjust them so the resulting move
    // is pixels.

    AdjustPixels(&p->Delta_X, &p->Delta_Y);

	DBPRINTF(TEXT("SkEx_SendMouse(Stat %d x %d y %d )\r\n"), p->Status, p->Delta_X, p->Delta_Y);

    memset(&input, 0, sizeof(INPUT));
    input.type = INPUT_MOUSE;
    input.mi.dx = p->Delta_X;
    input.mi.dy = p->Delta_Y;
    input.mi.dwFlags = p->Status;
    input.mi.dwExtraInfo = (DWORD)GetMessageExtraInfo();    // documented assignment; must be OK?

	DeskSwitchToInput();         

    if (!SendInput(1, &input, sizeof(INPUT)))
        DBPRINTF(TEXT("SkEx_SendMouse:  SendInput FAILED 0x%x\r\n"), GetLastError());
}

#ifdef QUEUE_BUF
/*---------------------------------------------------------------
 *
 * FUNCTION	SendKey()
 *
 *	TYPE		Global
 *
 * PURPOSE		This Function Send keys from the Que to Windows NT
 *				
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SendKey()
{
	if (KeyBack == KeyFront)		// Are there Keys in the Que?
		return;						// No - Exit;

	DBPRINTF(TEXT("SkEx_SendKey(KeyBack %d )\r\n"), KeyBack);

	DeskSwitchToInput();         
	keybd_event						// Process the Key Event
	(
		KeyQue[KeyBack].VirKey,
		KeyQue[KeyBack].ScanCode,
		KeyQue[KeyBack].Flags, 0L
	);

	KeyBack++;						// Increment Key pointer
	if (KeyBack == MAXKEYS)			// Are we at the End of the buffer
		KeyBack = 0;				// Yes - Reset to start.
}			  

/*---------------------------------------------------------------
 *	Local Functions
/*---------------------------------------------------------------
 *
 * FUNCTION	AddKey(BYTE VirKey, BYTE ScanCode, int Flags)
 *
 *	TYPE		Local
 *
 * PURPOSE		Adds a key to the Key Que.  
 *						   
 * INPUTS		BYTE 	VirKey 	- Virtual Key
 *				BYTE 	ScanCode- 
 *				int		Flags	-
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void AddKey(BYTE VirKey, BYTE ScanCode, int Flags)
{
	DBPRINTF(TEXT("AddKey(KeyFront %d )\r\n"), KeyFront);

	// Add Keys to Que
	KeyQue[KeyFront].VirKey 	= VirKey;	
	KeyQue[KeyFront].ScanCode	= ScanCode;
	KeyQue[KeyFront].Flags		= Flags;

	KeyFront++;							// Point to next Que
	if (KeyFront == MAXKEYS)			// Are we at the End of the buffer
		KeyFront = 0;					// Yes - Reset to start.

	// Process the Key Event
	DeskSwitchToInput();         
	keybd_event(VirKey, ScanCode, Flags, 0L);

}
#endif		// QUE

/*---------------------------------------------------------------
 *
 * FUNCTION	CheckAltCtrlDel(int scanCode)
 *
 *	TYPE		Local
 *
 * PURPOSE		Checks for the condition of Alt-Ctrl-Del key 
 *				Combination.
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CheckAltCtrlDel(int scanCode)
{
	BOOL fCtrl = FALSE;
	BOOL fAlt = FALSE;
	BOOL fDel = FALSE;
	int i;

	DBPRINTF(TEXT("CheckAltCtrlDel()\r\n"));
	Key[Push] = (char)scanCode;		// Save Scan Code
	Push++;							// Inc Index

	if (Push != 3)					// Have we got 3 keys?
		return;						// No - Exit

	for ( i = 0; i < 3; i++ )
	{
		switch ( Key[i] )
		{
			case CTRL:	fCtrl = TRUE; break;
			case ALT:	fAlt = TRUE; break;
			case DEL:	fDel = TRUE; break;
		}
	}
	
	if ( fCtrl && fAlt && fDel )		// Is Buffer Alt=Ctrl=Del
		SendAltCtrlDel();			// Yes - Send command
		
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SendAltCtrlDel()
 *
 *	TYPE		Local
 *
 * PURPOSE		Signal system reset
 *				
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void SendAltCtrlDel()
{
	HWINSTA hwinsta;
	HDESK hdesk;
	HWND hwndSAS;
	HWINSTA	hwinstaSave;
	HDESK	hdeskSave;

	DBPRINTF(TEXT("SendAltCtrlDel()\r\n"));

	hwinstaSave = GetProcessWindowStation();
	hdeskSave = GetThreadDesktop(GetCurrentThreadId());

	hwinsta = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	SetProcessWindowStation(hwinsta);
	hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
	SetThreadDesktop(hdesk);

	hwndSAS = FindWindow(NULL, TEXT("SAS window"));
////PostMessage(hwndSAS, WM_HOTKEY, 0, 0);
	SendMessage(hwndSAS, WM_HOTKEY, 0, 0);

	if (NULL != hdeskSave)
	{
		SetThreadDesktop(hdeskSave);
	}

	if (NULL != hwinstaSave)
	{
		SetProcessWindowStation(hwinstaSave);
	}
	
	CloseDesktop(hdesk);
	CloseWindowStation(hwinsta);
}

BOOL DeskSwitchToInput()
{
	BOOL fOk = FALSE;
	HANDLE	hNewDesktop;

	// We are switching desktops
	
	// get current Input desktop
	hNewDesktop = OpenInputDesktop(		
			0L,
			FALSE,
			MAXIMUM_ALLOWED);

	if (NULL == hNewDesktop)
	{
		DBPRINTF(TEXT("OpenInputDesktop failed\r\n"));
	}
	else
	{
		fOk = SetThreadDesktop(hNewDesktop);	// attach thread to desktop
		if (!fOk)
		{
			DBPRINTF(TEXT("Failed SetThreadDesktop()\r\n"));
		}
		else
		{
			if (NULL != s_hdeskUser)
			{
				CloseDesktop(s_hdeskUser);		// close old desktop
			}
			s_hdeskUser = hNewDesktop;		// save desktop
		}
	}
	return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_login.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_LOGIN.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing when the user logs in and out of NT.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *	Notes:
 *		The Login process is currently not implemented.  We need additional
 *		code to determine who is actually logged in and how to receive 
 *		notification of a login event.
 *
 *--- Includes  ---------------------------------------------------------*/
#include	<process.h>

#include	"windows.h"
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_login.h"

#define	DISABLE_LOGIN 1

// Local Variables --------------------------------------------

static BOOL	fDoneLogin = TRUE;
static BOOL	fExitLogin = FALSE;

static HANDLE	hEventLogin  = NULL;
static HANDLE	hThreadLogin = NULL;

// Local Function Prototypes ---------------------------------

static void CleanUpLogin();
static void __cdecl ProcessLogin(VOID *notUsed);


/*---------------------------------------------------------------
 *	Global Functions - 
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL DoneLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the state of the login Thread
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Login Thread not running
 * 			FALSE - Login Thread Is running
 *
 *---------------------------------------------------------------*/
BOOL DoneLogin()
{
	return(fDoneLogin);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void InitLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function creates a thread that monitors when a user
 *				has logged in and out of NT.  On each case it sets
 *				the ServiceCommand to notify the MainSerice of the
 *				change.  The MainService will then reset Serial Keys
 *				for the new user settings.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL InitLogin()
{

	DBPRINTF(TEXT("InitLogin()\r\n"));

#if DISABLE_LOGIN // clean this up /////////////////////////////////////
	return(TRUE);
#else /////////////////////////////////////////////////////////////////////////
   hEventLogin = CreateEvent(NULL,TRUE,FALSE,NULL);	

	if (NULL == hEventLogin)	// Is Handle VALID?
	{
		DBPRINTF(TEXT("Unable to Create DLL Event\r\n"));
		TerminateLogin();
		return FALSE;
	}
    
	{
  	DWORD Id;

	// Generate thread to handle Login in & Out processing;
	hThreadLogin = (HANDLE)CreateThread(	// Start Service Thread
		0,
		0,
		(LPTHREAD_START_ROUTINE) ProcessLogin,
		0,
		0,
		&Id);								// argument to thread
    }

	if (NULL == hThreadLogin)
	{
		TerminateLogin();
		return FALSE;
	}

	fDoneLogin = FALSE;
#endif ////////////////////////////////////////////////////////////////////////
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendLogin()
{

	DBPRINTF(TEXT("SuspendLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else 

	if (NULL != hThreadLogin)
		SuspendThread(hThreadLogin);
#endif
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeLogin()
{
	DBPRINTF(TEXT("ResumeLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else

	if (NULL != hThreadLogin)
		ResumeThread(hThreadLogin);	
#endif
}
/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		Terminates the Login Thread
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void TerminateLogin()
{
	DBPRINTF(TEXT("TerminateLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else
	if (DoneLogin())
	{
		fExitLogin = TRUE;
		SetEvent(hEventLogin);			// Trigger Login Event
		Sleep(150);
	}
#endif
}

/*---------------------------------------------------------------
 *	Local Functions
/*---------------------------------------------------------------
 *
 * FUNCTION    static void CleanUpLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		Cleans up misc handles and memory allocated for 
 *				the thread;
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CleanUpLogin()
{
	BOOL Stat;

	DBPRINTF(TEXT("CleanUpLogin()\r\n"));

	if (NULL != hEventLogin)
	{
		Stat = CloseHandle(hEventLogin);
		DBPRINTF_IF(Stat,TEXT("Unable to Close Login Event\r\n"));
	}

	if (NULL != hThreadLogin)
	{
		Stat = CloseHandle(hThreadLogin);
		DBPRINTF_IF(Stat,TEXT("Unable to Close Login Thread\r\n"));
	}

 	hEventLogin = NULL;
 	hThreadLogin = NULL;

	DBPRINTF(TEXT("Login Service Processing Done\r\n"));
	fDoneLogin = TRUE;
}

/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ProcessLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function is a thread that monitors when a user
 *				has logged in and out of NT.  On each case it sets
 *				the ServiceCommand to notify the MainSerice of the
 *				change.  The MainService will then reset Serial Keys
 *				for the new user settings.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ProcessLogin(VOID *notUsed)
{
	DBPRINTF(TEXT("ProcessLogin()\r\n"));

	while (TRUE)
	{
		if (fExitLogin)
		{
			fExitLogin = FALSE;
			CleanUpLogin();
			ExitThread(0);
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\tables.c ===
/* TABLES.C  */

//#define     WINVER 0x0300

#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "gidei.h"
#include "vars.h"
#include "gide.h"

struct aliasTable	gideiAliasTable[] = {
	{ "BEGIN",		BEGINCODE	},
	{ "BLKTRNS",	BLKTRANSCODE},
	{ "CLEAR",		CLEARCODE	},
	{ "END", 		ENDCODE		},
	{ "",			NOCODE		},
};


struct aliasTable	commandsAliasTable[] = {
	{ "baudrate",	BAUDRATECODE	},
	{ "click",		MOUCLICKCODE	},
	{ "combine",	KBDCOMBINECODE	},
	{ "comm",		COMMCODE		},
	{ "dblclick",	MOUDOUBLECLICKCODE	},
	{ "gen",		GENCODE			},
	{ "goto",		MOUGOTOCODE		},
	{ "hold",		KBDHOLDCODE		},
	{ "kbd",		KBDEXPANSIONCODE},
	{ "lock",		KBDLOCKCODE		},
	{ "mou",		MOUEXPANSIONCODE},
   { "mouanchor", MOUANCHORCODE     },
	{ "moulock", 	MOULOCKCODE		},
	{ "mourel",		MOURELCODE		},
	{ "moureset",	MOURESETCODE	},
	{ "move",		MOUMOVECODE		},
	{ "press",		KBDPRESSCODE	},
	{ "rel",		KBDRELCODE		},
	{ "",			NOCODE		},
};

struct aliasTable	kbdAliasTable[] = {
	{ "desc",		KBDDESCRIPTIONCODE },
	{ "ind",		KBDINDICATORCODE	},
	{ "model",		KBDMODELCODE		},
	{ "ver",		KBDVERSIONCODE		},
	{ "",			NOCODE		},
};


struct aliasTable	kbdModelAliasTable[] = {
	{ "ibmat",		IBMATCODE		},
	{ "ibmenhc",	IBMEXTENDEDCODE	},		/* IBM 101 key keyboard */
	{ "ibmpc",		IBMPCCODE		},		/* IBM original keyboard */
	{ "",			NOCODE		},
};


struct aliasTable	kbdDescriptionAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable kbdVersionAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable kbdIndicatorAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable mouseAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable genAliasTable[] = {
	{ "",			NOCODE		},
};


struct aliasTable	commAliasTable[] = {
	{ "",			NOCODE		},
};



struct aliasTable	baudrateAliasTable[] = {
	{ "1200",	BAUD1200CODE	},
	{ "2400",	BAUD2400CODE	},
	{ "300",	BAUD300CODE		},
	{ "4800",	BAUD4800CODE	},
	{ "600",	BAUD600CODE		},
	{ "9600",	BAUD9600CODE	},
	{ "19200",	BAUD19200CODE	},
	{ "110",	BAUD110CODE	    },
	{ "14400",	BAUD14400CODE	},
	{ "38400",	BAUD38400CODE	},
	{ "56000",	BAUD56000CODE	},
	{ "57600",	BAUD57600CODE	},
	{ "115200",	BAUD115200CODE	},
	{ "",			NOCODE		},
};

struct aliasTable	mouButtonAliasTable[] = {
	{ "left",	LEFTBUTTONCODE	},
	{ "right",	RIGHTBUTTONCODE	},
	{ "",			NOCODE		},
};

int	baudrateTable[] = {
	{ 300		},
	{ 600		},
	{ 1200		},
	{ 2400		},
	{ 4800		},
	{ 9600		},
	{ 0			},
};


/****************************************************************************

	Table for converting the ISO characters to the keys that need to be typed
	on the keyboard.

****************************************************************************/

struct asciiTables asciiTable[] = {
	{ control_key,	two_key,},							/*   0 */
	{ control_key,	a_key,},								/*   1 */
	{ control_key,	b_key,},								/*   2 */
	{ control_key,	c_key,},								/*   3 */
	{ control_key,	d_key,},								/*   4 */
	{ control_key,	e_key,},								/*   5 */
	{ control_key,	f_key,},								/*   6 */
	{ control_key,	g_key,},								/*   7 */
	{ control_key,	h_key,},								/*   8 */
	{ control_key,	i_key,},								/*   9 */
	{ control_key,	j_key,},								/*  10 */
	{ control_key,	k_key,},								/*  11 */
	{ control_key,	l_key,},								/*  12 */
	{ control_key,	m_key,},								/*  13 */
	{ control_key,	n_key,},								/*  14 */
	{ control_key,	o_key,},								/*  15 */
	{ control_key,	p_key,},								/*  16 */
	{ control_key,	q_key,},								/*  17 */
	{ control_key,	r_key,},								/*  18 */
	{ control_key,	s_key,},								/*  19 */
	{ control_key,	t_key,},								/*  20 */
	{ control_key,	u_key,},								/*  21 */
	{ control_key,	v_key,},								/*  22 */
	{ control_key,	w_key,},								/*  23 */
	{ control_key,	x_key,},								/*  24 */
	{ control_key,	y_key,},								/*  25 */
	{ control_key,	z_key,},								/*  26 */
	{ control_key,	lbracket_key,},					/*  27 */
	{ control_key,	bslash_key,},						/*  28 */
	{ control_key,	rbracket_key,},					/*  29 */
	{ control_key,	six_key,},							/*  30 */
	{ control_key,	hyphen_key,},						/*  31 */
	{ space_key,	no_key,},							/*  32 */
	{ shift_key,	one_key,},							/*  33 */
	{ shift_key,	rquote_key,},						/*  34 */
	{ shift_key,	three_key,},						/*  35 */
	{ shift_key,	four_key,},							/*  36 */
	{ shift_key,	five_key,},							/*  37 */
	{ shift_key,	seven_key,},						/*  38 */
	{ rquote_key,	no_key,},							/*  39 */
	{ shift_key,	nine_key,},							/*  40 */
	{ shift_key,	zero_key,},							/*  41 */
	{ shift_key,	eight_key,},						/*  42 */
	{ shift_key,	equal_key,},						/*  43 */
	{ comma_key,	no_key,},							/*  44 */
	{ hyphen_key,	no_key,},							/*  45 */
	{ period_key,	no_key,},							/*  46 */
	{ fslash_key,	no_key,},							/*  47 */
	{ zero_key,		no_key,},							/*  48 */
	{ one_key,		no_key,},							/*  49 */
	{ two_key,		no_key,},							/*  50 */
	{ three_key,	no_key,},							/*  51 */
	{ four_key,		no_key,},							/*  52 */
	{ five_key,		no_key,},							/*  53 */
	{ six_key,		no_key,},							/*  54 */
	{ seven_key,	no_key,},							/*  55 */
	{ eight_key,	no_key,},							/*  56 */
	{ nine_key,		no_key,},							/*  57 */
	{ shift_key,	semicolon_key,},					/*  58 */
	{ semicolon_key,no_key,},							/*  59 */
	{ shift_key,	comma_key,},						/*  60 */
	{ equal_key,	no_key,},							/*  61 */
	{ shift_key,	period_key,},						/*  62 */
	{ shift_key,	fslash_key,},						/*  63 */
	{ shift_key,	two_key,},							/*  64 */
	{ shift_key,	a_key,},								/*  65 */
	{ shift_key,	b_key,},								/*  66 */
	{ shift_key,	c_key,},								/*  67 */
	{ shift_key,	d_key,},								/*  68 */
	{ shift_key,	e_key,},								/*  69 */
	{ shift_key,	f_key,},								/*  70 */
	{ shift_key,	g_key,},								/*  71 */
	{ shift_key,	h_key,},								/*  72 */
	{ shift_key,	i_key,},								/*  73 */
	{ shift_key,	j_key,},								/*  74 */
	{ shift_key,	k_key,},								/*  75 */
	{ shift_key,	l_key,},								/*  76 */
	{ shift_key,	m_key,},								/*  77 */
	{ shift_key,	n_key,},								/*  78 */
	{ shift_key,	o_key,},								/*  79 */
	{ shift_key,	p_key,},								/*  80 */
	{ shift_key,	q_key,},								/*  81 */
	{ shift_key,	r_key,},								/*  82 */
	{ shift_key,	s_key,},								/*  83 */
	{ shift_key,	t_key,},								/*  84 */
	{ shift_key,	u_key,},								/*  85 */
	{ shift_key,	v_key,},								/*  86 */
	{ shift_key,	w_key,},								/*  87 */
	{ shift_key,	x_key,},								/*  88 */
	{ shift_key,	y_key,},								/*  89 */
	{ shift_key,	z_key,},								/*  90 */
	{ lbracket_key,	no_key,},						/*  91 */
	{ bslash_key,	no_key,},							/*  92 */
	{ rbracket_key,	no_key,},						/*  93 */
	{ shift_key,	six_key,},							/*  94 */
	{ shift_key,	hyphen_key,},						/*  95 */
	{ lquote_key,	no_key,},							/*  96 */
	{ a_key,		no_key,},								/*  97 */
	{ b_key,		no_key,},								/*  98 */
	{ c_key,		no_key,},								/*  99 */
	{ d_key,		no_key,},								/* 100 */
	{ e_key,		no_key,},								/* 101 */
	{ f_key,		no_key,},								/* 102 */
	{ g_key,		no_key,},								/* 103 */
	{ h_key,		no_key,},								/* 104 */
	{ i_key,		no_key,},								/* 105 */
	{ j_key,		no_key,},								/* 106 */
	{ k_key,		no_key,},								/* 107 */
	{ l_key,		no_key,},								/* 108 */
	{ m_key,		no_key,},								/* 109 */
	{ n_key,		no_key,},								/* 110 */
	{ o_key,		no_key,},								/* 111 */
	{ p_key,		no_key,},								/* 112 */
	{ q_key,		no_key,},								/* 113 */
	{ r_key,		no_key,},								/* 114 */
	{ s_key,		no_key,},								/* 115 */
	{ t_key,		no_key,},								/* 116 */
	{ u_key,		no_key,},								/* 117 */
	{ v_key,		no_key,},								/* 118 */
	{ w_key,		no_key,},								/* 119 */
	{ x_key,		no_key,},								/* 120 */
	{ y_key,		no_key,},								/* 121 */
	{ z_key,		no_key,},								/* 122 */
	{ shift_key,	lbracket_key,},					/* 123 */
	{ shift_key,	bslash_key,},						/* 124 */
	{ shift_key,	rbracket_key,},					/* 125 */
	{ shift_key,	lquote_key,},						/* 126 */
	{ control_key,	kpperiod_key,},					/* 127 */
};


/****************************************************************************

	Table for converting the ASCII string of the key names into the key
	number.

****************************************************************************/

struct aliasTable	keyAliasTable[] = {
	{ "alt",		alt_key,},
	{ "backspace",	backspace_key,},
  	{ "bksp",		backspace_key,},
  	{ "break",		pause_key,},
	{ "capslk",		caps_key,},
	{ "capslock",	caps_key,},
	{ "comma",		comma_key,},
	{ "control", 	control_key,},
	{ "ctrl",		control_key,},
	{ "del",		delete_key,},
	{ "delete",		delete_key,},
	{ "divide",		kpfslash_key,},
	{ "down",		down_key,},
	{ "end",		end_key,},
	{ "enter",		return_key,},
	{ "esc",		escape_key,},
	{ "escape",		escape_key,},
	{ "f1",			f1_key,},
	{ "f10",		f10_key,},
	{ "f11",		f11_key,},
	{ "f12",		f12_key,},
	{ "f2",			f2_key,},
	{ "f3",			f3_key,},
	{ "f4",			f4_key,},
	{ "f5",			f5_key,},
	{ "f6",			f6_key,},
	{ "f7",			f7_key,},
	{ "f8",			f8_key,},
	{ "f9",			f9_key,},
	{ "home",		home_key,},
	{ "ins",		insert_key,},
	{ "insert",		insert_key,},
	{ "kp*",		kpstar_key,},
	{ "kp+",		kpplus_key,},
	{ "kp-",		kpminus_key,},
	{ "kp/",		kpfslash_key,},
	{ "kp0",		kp0_key,},
	{ "kp1",		kp1_key,},
	{ "kp2",		kp2_key,},
	{ "kp3",		kp3_key,},
	{ "kp4",		kp4_key,},
	{ "kp5",		kp5_key,},
	{ "kp6",		kp6_key,},
	{ "kp7",		kp7_key,},
	{ "kp8",		kp8_key,},
	{ "kp9",		kp9_key,},
	{ "kpdel",		kpperiod_key,},
	{ "kpdelete",	kpperiod_key,},
	{ "kpdivide",	kpfslash_key,},
	{ "kpdn",		kp2_key,},
	{ "kpdown",		kp2_key,},
	{ "kpdp",		kpperiod_key,},
	{ "kpend",		kp1_key,},
	{ "kpenter",	kpenter_key,},
	{ "kphome",		kp7_key,},
	{ "kpins",		kp0_key,},
	{ "kpinsert",	kp0_key,},
	{ "kpleft",		kp4_key,},
	{ "kpmidl",		kp5_key,},
	{ "kpminus",	kpminus_key,},
	{ "kppagedown",	kp3_key,},
	{ "kppageup",	kp9_key,},
	{ "kppgdn",		kp3_key,},
	{ "kppgup",		kp9_key,},
	{ "kpplus",		kpplus_key,},
	{ "kpright",	kp6_key,},
	{ "kpslash",	kpfslash_key,},
	{ "kpstar",		kpstar_key,},
	{ "kptimes",	kpstar_key,},
	{ "kpup",		kp8_key,},
	{ "lalt",		lalt_key,},
	{ "lcontrol",	lcontrol_key,},
	{ "lctrl",		lcontrol_key,},
	{ "left",		left_key,},
	{ "leftalt",	lalt_key,},
	{ "leftcontrol", lcontrol_key,},
	{ "leftctrl",	lcontrol_key,},
	{ "leftshift",	lshift_key,},
	{ "lshift",		lshift_key,},
	{ "multiply",	kpstar_key,},
	{ "numlk",		numlock_key,},
	{ "numlock",	numlock_key,},
	{ "pagedown", 	pagedown_key,},
	{ "pageup",		pageup_key,},
	{ "pause",		pause_key,},
	{ "period",		period_key,},
	{ "pgdn",		pagedown_key,},
	{ "pgup",		pageup_key,},
	{ "print",		print_key,},
	{ "printscreen", print_key,},
	{ "prtsc",		print_key,},
	{ "ralt",		ralt_key,},
	{ "rcontrol",	rcontrol_key,},
	{ "rctrl",		rcontrol_key,},
	{ "ret",		return_key,},
	{ "return",		return_key,},
	{ "right",		right_key,},
	{ "rightalt",	ralt_key,},
	{ "rightcontrol", rcontrol_key,},
	{ "rightctrl",	rcontrol_key,},
	{ "rightshift",	rshift_key,},
	{ "rshift",		rshift_key,},
	{ "scroll",		scroll_key,},
	{ "scrolllock",	scroll_key,},
	{ "shift",		shift_key,},
	{ "space",		space_key,},
	{ "sysreq",		print_key,},
	{ "tab",		tab_key,},
	{ "tilde",		lquote_key,},
	{ "up",			up_key,},
	{ "",			no_key,},
};




/****************************************************************************

	Constants of extended scan code for the keys on the 101 key keyboard.
	The Key Number corresponds to the IBM documentation in their technical
	reference manuals.  It is not the same as the GIDEI key code

		Name			Make Code	Key Number
****************************************************************************/

#define	lquote_scan_101		0x0029	/*   1 */
#define	one_scan_101		0x0002	/*   2 */
#define	two_scan_101		0x0003	/*   3 */
#define	three_scan_101		0x0004	/*   4 */
#define	four_scan_101		0x0005	/*   5 */
#define	five_scan_101		0x0006	/*   6 */
#define	six_scan_101		0x0007	/*   7 */
#define	seven_scan_101		0x0008	/*   8 */
#define	eight_scan_101		0x0009	/*   9 */
#define	nine_scan_101		0x000A	/*  10 */
#define	zero_scan_101		0x000B	/*  11 */
#define	hyphen_scan_101		0x000C	/*  12 */
#define	equal_scan_101		0x000D	/*  13 */
#define	backspace_scan_101	0x000E	/*  15 */

#define	tab_scan_101		0x000F	/*  16 */
#define	q_scan_101			0x0010	/*  17 */
#define	w_scan_101			0x0011	/*  18 */
#define	e_scan_101			0x0012	/*  19 */
#define	r_scan_101			0x0013	/*  20 */
#define	t_scan_101			0x0014	/*  21 */
#define	y_scan_101			0x0015	/*  22 */
#define	u_scan_101			0x0016	/*  23 */
#define	i_scan_101			0x0017	/*  24 */
#define	o_scan_101			0x0018	/*  25 */
#define	p_scan_101			0x0019	/*  26 */
#define	lbracket_scan_101	0x001A	/*  27 */
#define	rbracket_scan_101	0x001B	/*  28 */
#define	bslash_scan_101		0x002B	/*  29 */

#define	caps_scan_101		0x003A	/*  30 */
#define	a_scan_101			0x001E	/*  31 */
#define	s_scan_101			0x001F	/*  32 */
#define	d_scan_101			0x0020	/*  33 */
#define	f_scan_101			0x0021	/*  34 */
#define	g_scan_101			0x0022	/*  35 */
#define	h_scan_101			0x0023	/*  36 */
#define	j_scan_101			0x0024	/*  37 */
#define	k_scan_101			0x0025	/*  38 */
#define	l_scan_101			0x0026	/*  39 */
#define	semi_scan_101		0x0027	/*  40 */
#define	rquote_scan_101		0x0028	/*  41 */
#define	return_scan_101		0x001C	/*  43 */

#define	lshift_scan_101		0x002A	/*  44 */
#define	z_scan_101			0x002C	/*  46 */
#define	x_scan_101			0x002D	/*  47 */
#define	c_scan_101			0x002E	/*  48 */
#define	v_scan_101			0x002F	/*  49 */
#define	b_scan_101			0x0030	/*  50 */
#define	n_scan_101			0x0031	/*  51 */
#define	m_scan_101			0x0032	/*  52 */
#define	comma_scan_101		0x0033	/*  53 */
#define	period_scan_101		0x0034	/*  54 */
#define	fslash_scan_101		0x0035	/*  55 */
#define	rshift_scan_101		0x0036	/*  57 */

#define	lcontrol_scan_101	0x001D	/*  58 */
#define	lalt_scan_101		0x0038	/*  60 */
#define	space_scan_101		0x0039	/*  61 */
#define	ralt_scan_101		0xE038	/*  62 */
#define	rcontrol_scan_101	0xE01D	/*  64 */

#define	insert_scan_101		0xE052	/*  75 */
#define	delete_scan_101		0xE053	/*  76 */
#define	left_scan_101		0xE04B	/*  79 */
#define	home_scan_101		0xE047	/*  80 */
#define	end_scan_101		0xE04F	/*  81 */
#define	up_scan_101			0xE048	/*  83 */
#define	down_scan_101		0xE050	/*  84 */
#define	pageup_scan_101		0xE049	/*  85 */
#define	pagedown_scan_101	0xE051	/*  86 */
#define	right_scan_101		0xE04D	/*  89 */

#define	numlock_scan_101	0x0045	/*  90 */
#define	kp7_scan_101		0x0047	/*  91 */
#define	kp4_scan_101		0x004B	/*  92 */
#define	kp1_scan_101		0x004F	/*  93 */

#define	kpDivide_scan_101	0xE035	/*  95 */
#define	kp8_scan_101		0x0048	/*  96 */
#define	kp5_scan_101		0x004C	/*  97 */
#define	kp2_scan_101		0x0050	/*  98 */
#define	kp0_scan_101		0x0052	/*  99 */

#define	asterisk_scan_101	0x0037	/* 100 */
#define	kp9_scan_101		0x0049	/* 101 */
#define	kp6_scan_101		0x004D	/* 102 */
#define	kp3_scan_101		0x0051	/* 103 */
#define	kpdp_scan_101		0x0053	/* 104 */

#define	minus_scan_101		0x004A	/* 105 */
#define	plus_scan_101		0x004E	/* 106 */
#define	kpEnter_scan_101	0xE01C	/* 108 */

#define	esc_scan_101		0x0001	/* 110 */

#define	f1_scan_101			0x003B	/* 112 */
#define	f2_scan_101			0x003C	/* 113 */
#define	f3_scan_101			0x003D	/* 114 */
#define	f4_scan_101			0x003E	/* 115 */

#define	f5_scan_101			0x003F	/* 116 */
#define	f6_scan_101			0x0040	/* 117 */
#define	f7_scan_101			0x0041	/* 118 */
#define	f8_scan_101			0x0042	/* 119 */

#define	f9_scan_101			0x0043	/* 120 */
#define	f10_scan_101		0x0044	/* 121 */
#define	f11_scan_101		0x0057	/* 122 */
#define	f12_scan_101		0x0058	/* 123 */

#define	prtScr_scan_101		0xE037	/* 124 */
#define	scroll_scan_101		0x0046	/* 125 */
#define	pause_scan_101		0x0045	/* 126 */

/* Aliases */

#define	shift_scan_101		lshift_scan_101
#define	control_scan_101	lcontrol_scan_101
#define	alt_scan_101		lalt_scan_101

#define	sysreq_scan_101		prtScr_scan_101
#define	break_scan_101		pause_scan_101

#define	no_ScanCode			  	0
#define no_scan_101				0



/****************************************************************************

	ScanTable is the lookup table to convert a key by its keynumber to the
	scan code for the key.  The table is padded with key numbers that are
	not currently used.  The table could have been smaller if we wanted to
	not use the same reference of key number as IBM in their technical
	reference materials.  However, I decided to pad it for possible future
	growth in the number of keys, and learning to deal with it.  Also I wanted
	to keep the same key number association as in the technical reference.

	If memory is a problem, then the tables could be compacted by not
	following the same keynumbers as the IBM techincal references.

****************************************************************************/

int	IBMextendedScanCodeSet1[] = {
	 no_scan_101,	  		/*   0 */
	 lquote_scan_101, 		/*   1 */
	 one_scan_101,	  		/*   2 */
	 two_scan_101,	  		/*   3 */
	 three_scan_101,  		/*   4 */
	 four_scan_101,	  		/*   5 */
	 five_scan_101,	  		/*   6 */
	 six_scan_101,	  		/*   7 */
	 seven_scan_101,  		/*   8 */
	 eight_scan_101,  		/*   9 */
	 nine_scan_101,	  		/*  10 */
	 zero_scan_101,	  		/*  11 */
	 hyphen_scan_101, 		/*  12 */
	 equal_scan_101,  		/*  13 */
	 no_scan_101,	  		/*  14 */
	 backspace_scan_101,	/*  15 */
	 tab_scan_101,			/*  16 */
	 q_scan_101,			/*  17 */
	 w_scan_101,			/*  18 */
	 e_scan_101,			/*  19 */
	 r_scan_101,			/*  20 */
	 t_scan_101,			/*  21 */
	 y_scan_101,			/*  22 */
	 u_scan_101,			/*  23 */
	 i_scan_101,			/*  24 */
	 o_scan_101,			/*  25 */
	 p_scan_101,			/*  26 */
	 lbracket_scan_101,		/*  27 */
	 rbracket_scan_101,		/*  28 */
	 bslash_scan_101,		/*  29 */
	 caps_scan_101,			/*  30 */
	 a_scan_101,			/*  31 */
	 s_scan_101,			/*  32 */
	 d_scan_101,			/*  33 */
	 f_scan_101,			/*  34 */
	 g_scan_101,			/*  35 */
	 h_scan_101,			/*  36 */
	 j_scan_101,			/*  37 */
	 k_scan_101,			/*  38 */
	 l_scan_101,			/*  39 */
	 semi_scan_101,			/*  40 */
	 rquote_scan_101,		/*  41 */
	 no_scan_101,			/*  42 */
	 return_scan_101,		/*  43 */
	 lshift_scan_101,		/*  44 */
	 no_scan_101,			/*  45 */
	 z_scan_101,			/*  46 */
	 x_scan_101,			/*  47 */
	 c_scan_101,			/*  48 */
	 v_scan_101,			/*  49 */
	 b_scan_101,			/*  50 */
	 n_scan_101,			/*  51 */
	 m_scan_101,			/*  52 */
	 comma_scan_101,		/*  53 */
	 period_scan_101,		/*  54 */
	 fslash_scan_101,		/*  55 */
	 no_scan_101,			/*  56 */
	 rshift_scan_101,		/*  57 */
	 lcontrol_scan_101,		/*  58 */
	 no_scan_101,			/*  59 */
	 lalt_scan_101,			/*  60 */
	 space_scan_101,		/*  61 */
	 ralt_scan_101,			/*  62 */
	 no_scan_101,			/*  63 */
	 rcontrol_scan_101,		/*  64 */
	 no_scan_101,			/*  65 */
	 no_scan_101,			/*  66 */
	 no_scan_101,			/*  67 */
	 no_scan_101,			/*  68 */
	 no_scan_101,			/*  69 */
	 no_scan_101,			/*  70 */
	 no_scan_101,			/*  71 */
	 no_scan_101,			/*  72 */
	 no_scan_101,			/*  73 */
	 no_scan_101,			/*  74 */
	 insert_scan_101,		/*  75 */
	 delete_scan_101,		/*  76 */
	 no_scan_101,			/*  77 */
	 no_scan_101,			/*  78 */
	 left_scan_101,			/*  79 */
	 home_scan_101,			/*  80 */
	 end_scan_101,			/*  81 */
	 no_scan_101,			/*  82 */
	 up_scan_101,			/*  83 */
	 down_scan_101,			/*  84 */
	 pageup_scan_101,		/*  85 */
	 pagedown_scan_101,		/*  86 */
	 no_scan_101,			/*  87 */
	 no_scan_101,			/*  88 */
	 right_scan_101,		/*  89 */
	 numlock_scan_101,		/*  90 */
	 kp7_scan_101,			/*  91 */
	 kp4_scan_101,			/*  92 */
	 kp1_scan_101,			/*  93 */
	 no_scan_101,			/*  94 */
	 kpDivide_scan_101,		/*  95 */
	 kp8_scan_101,			/*  96 */
	 kp5_scan_101,			/*  97 */
	 kp2_scan_101,			/*  98 */
	 kp0_scan_101,			/*  99 */
	 asterisk_scan_101,		/* 100 */
	 kp9_scan_101,			/* 101 */
	 kp6_scan_101,			/* 102 */
	 kp3_scan_101,			/* 103 */
	 kpdp_scan_101,			/* 104 */
	 minus_scan_101,		/* 105 */
	 plus_scan_101,			/* 106 */
	 no_scan_101,			/* 107 */
	 kpEnter_scan_101,		/* 108 */
	 no_scan_101,			/* 109 */
	 esc_scan_101,			/* 110 */
	 no_scan_101,			/* 111 */
	 f1_scan_101,			/* 112 */
	 f2_scan_101,			/* 113 */
	 f3_scan_101,			/* 114 */
	 f4_scan_101,			/* 115 */
	 f5_scan_101,			/* 116 */
	 f6_scan_101,			/* 117 */
	 f7_scan_101,			/* 118 */
	 f8_scan_101,			/* 119 */
	 f9_scan_101,			/* 120 */
	 f10_scan_101,			/* 121 */
	 f11_scan_101,			/* 122 */
	 f12_scan_101,			/* 123 */
	 prtScr_scan_101,		/* 124 */
	 scroll_scan_101,		/* 125 */
	 pause_scan_101,		/* 126 */
	 no_scan_101			/* 127 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_reg.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_Reg.c
 *
 * PURPOSE:	   	These functions process data to and from the registry
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  --------------------------------------------*/
#include	<windows.h>

#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include	"sk_reg.h"

// Private Functions -------------------------------------------

static DWORD OpenRegistry(int User);
static void CloseRegistry();
static void SetRegistryValues();
static void GetRegistryValues();

// Variables  --------------------------------------------

HKEY	hKeyApp;

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL GetUserValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		Read the registery an collect the data for the current
 *				user.  This Information is then setup in the comm routines.
 *				This is called when someone logs into NT.
 *	
 * INPUTS		User Type Default or Current User
 *
 * RETURNS		TRUE - User wants Serial Keys Enabled
 *				FALSE- User wants Serial Keys Disabled
 *
 *---------------------------------------------------------------*/
BOOL GetUserValues(int User)
{
	DWORD Status;

	DBPRINTF(TEXT("GetUserValues()\r\n"));

	if (!(Status = OpenRegistry(User)))	// Did Open Registry Succed?
		return(FALSE);					// No - Fail

	switch (Status)						// What is status?
	{
		// This case should only be true the frist time
		// the registry is opened for the current user.
		case REG_CREATED_NEW_KEY:		// Is this an empty Registry?
			SetRegistryValues(); 		// Yes - Set Default Values
			break;

		case REG_OPENED_EXISTING_KEY:	// Is this an existing Registry?
			GetRegistryValues();  		// Yes - Get Values
			break;
	}
		
	CloseRegistry();
	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SetUserValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function writes out information to the
 *				registry.
 *	
 * INPUTS		None
 *
 * RETURNS		TRUE - Write Successful
 *				FALSE- Write Failed
 *
 *---------------------------------------------------------------*/
BOOL SetUserValues()
{
	DWORD Status;

	DBPRINTF(TEXT("SetUserValues()\r\n"));

	if (!(Status = OpenRegistry(REG_USER)))		// Did Open Registry Succed?
		return(FALSE);					// No - Fail

	SetRegistryValues();  				// Set New Values
	CloseRegistry();					// Close Registry
	return(TRUE);
}

/*---------------------------------------------------------------
 *
 *	Local Functions - 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	DWORD OpenRegistry()
 *
 *	TYPE		Global
 *
 * PURPOSE		Opens the Registry for reading or writing
 *	
 * INPUTS		User Type Default or Current User
 *
 * RETURNS		0  = Failed
 *				>0 = REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
 *
 *---------------------------------------------------------------*/
static DWORD OpenRegistry(int User)
{
	LONG	ret;
	DWORD	Disposition;

	DBPRINTF(TEXT(" OpenRegistry()\r\n"));

	switch (User)
	{
		case REG_USER:				// Current User
			ret =RegCreateKeyEx
				(
					HKEY_CURRENT_USER,
                    TEXT("Control Panel\\Accessibility\\SerialKeys"),
					0,NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKeyApp,
					&Disposition
				);
			break;

		case REG_DEF:				// Default 
			ret =RegCreateKeyEx
				(
					HKEY_USERS,
                    TEXT(".DEFAULT\\Control Panel\\Accessibility\\SerialKeys"),
					0,NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKeyApp,
					&Disposition
				);
			break;

		default:
			ret = FALSE;
			break;
	}

	if (ret != ERROR_SUCCESS)		// Did open succede?
		return(FALSE);				// No -

	return (Disposition);
	
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void CloseRegistry()
 *
 *	TYPE		Global
 *
 * PURPOSE		Closes the Registry for reading or writing
 *	
 * INPUTS		None
 *
 * RETURNS		0  = Failed
 *				>0 = REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
 *
 *---------------------------------------------------------------*/
static void CloseRegistry()
{
	DBPRINTF(TEXT(" CloseRegistry()\r\n"));
	RegCloseKey(hKeyApp);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Writes the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void SetRegistryValues()
{
	long ret;
	DWORD dwFlags;

	DBPRINTF(TEXT(" SetRegistryValues()\r\n"));

	dwFlags = skNewKey.dwFlags | SERKF_AVAILABLE;
	ret = RegSetValueEx(				// Write dwFlags
			hKeyApp,
			REG_FLAGS,
			0,REG_DWORD,
			(CONST LPBYTE) &dwFlags,
			sizeof(DWORD));
				
	if (ret != ERROR_SUCCESS)		// Did open succede?
	{
		DBPRINTF(TEXT("Unable to Set Registry Value\r\n"));
		return;						// No -
	}


	if (NULL == skNewKey.lpszActivePort)
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_ACTIVEPORT,
				0,
				REG_SZ,
				(CONST LPBYTE) TEXT(""),
				1 * sizeof(*skNewKey.lpszActivePort)); // size of one char, the term null
	}
	else
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_ACTIVEPORT,
				0,
				REG_SZ,
				(CONST LPBYTE) skNewKey.lpszActivePort,
				(lstrlen(skNewKey.lpszActivePort) + 1) * 
					sizeof(*skNewKey.lpszActivePort));
	}			
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -

	if (NULL == skNewKey.lpszPort)
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_PORT,
				0,
				REG_SZ,
				(CONST LPBYTE) TEXT(""),
				1 * sizeof(*skNewKey.lpszPort)); // size of one char, the term null
	}
	else
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_PORT,
				0,
				REG_SZ,
				(CONST LPBYTE)skNewKey.lpszPort,
				(lstrlen(skNewKey.lpszPort) + 1) * sizeof(*skNewKey.lpszPort));
	}
					
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -

	ret = RegSetValueEx				// Write Active Port
		(
			hKeyApp,
			REG_BAUD,
			0,REG_DWORD,
			(CONST LPBYTE) &skNewKey.iBaudRate,
			sizeof(skNewKey.iBaudRate)
		);
				
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Reads the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetRegistryValues()
{
	long lRet;
	DWORD dwType;
	DWORD cbData;
	
	DBPRINTF(TEXT(" GetRegistryValues()\r\n"));

	skNewKey.dwFlags = 0;
	cbData = sizeof(skNewKey.dwFlags);
	lRet = RegQueryValueEx(
			hKeyApp,
			REG_FLAGS,
			0,&dwType,
			(LPBYTE)&skNewKey.dwFlags,
			&cbData);
				
	skNewKey.dwFlags |= SERKF_AVAILABLE;
    
	if (NULL != skNewKey.lpszActivePort)
	{
		cbData = MAX_PATH * sizeof(*skNewKey.lpszActivePort);
		lRet = RegQueryValueEx(
				hKeyApp,
				REG_ACTIVEPORT,
				0,&dwType,
				(LPBYTE)skNewKey.lpszActivePort,
				&cbData);
					
		if (lRet != ERROR_SUCCESS)
		{
			lstrcpy(skNewKey.lpszActivePort, TEXT("COM1"));
		}
	}

	if (NULL != skNewKey.lpszPort)
	{
		cbData = MAX_PATH * sizeof(*skNewKey.lpszPort);
		lRet = RegQueryValueEx(				// Write Active Port
				hKeyApp,
				REG_PORT,
				0,&dwType,
				(LPBYTE)skNewKey.lpszPort,
				&cbData);
					
		if (lRet != ERROR_SUCCESS)
		{
			lstrcpy(skNewKey.lpszPort, TEXT("COM1"));
		}
	}

	cbData = sizeof(skNewKey.iBaudRate);
	lRet = RegQueryValueEx(			// Write Active Port
			hKeyApp,
			REG_BAUD,
			0,&dwType,
			(LPBYTE)&skNewKey.iBaudRate,
			&cbData);
				
	if (ERROR_SUCCESS != lRet)
	{
		skNewKey.iBaudRate = 300;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\vars.c ===
/*  VARS.C  */

//#define     WINVER 0x0300

#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "drivers.h"
#include "vars1.h"
#include "gide.h"

void 	*aliasStack[MAXVECTORSTACK];
void	*vectorStack[MAXVECTORSTACK];

int	stackPointer;
unsigned char lastCode;
void	(*serialVector)();
void	(*codeVector)();
int	(*commandVector)();
struct aliasTable *aliasPtr;

struct aliasTable nullTable[] = 
{
	{ "",		0	},
};

struct listTypes tempList, keyHoldList, keyLockList;
char cAliasString[MAXALIASLEN];
int nullCount;
int blockCount;

char buf[CODEBUFFERLEN];
int spos,rpos;

int passAll, fatalErrorFlag, stdErrorFlag, waitForClear, beginOK;

int mouseX, mouseY;

MOUSEKEYSPARAM mouData = {2, 0, 0, 0};
MOUSEKEYSPARAM *mouseDataPtr = &mouData;
int requestButton1, requestButton2, requestButton3 = FALSE;
int button1Status, button2Status, button3Status = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\sk_reg.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_reg.H							   
 *
 * PURPOSE:			Function prototypes for Serial registry Routines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#define REG_FLAGS		TEXT("Flags")
#define REG_ACTIVEPORT	TEXT("ActivePort")
#define REG_PORT		TEXT("Port")
#define REG_BAUD		TEXT("Baud")

// Public Function ProtoTypes ----------------------------------
BOOL GetUserValues(int User);
BOOL SetUserValues();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\calc.c ===
/**************************************************************************\
 *** SCICALC Scientific Calculator for Windows 3.00.12
 *** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989
 *** (c)1989 Microsoft Corporation.  All Rights Reserved.
 ***
 *** scimain.c
 ***
 *** Definitions of all globals, WinMain procedure
 ***
 *** Last modification
 ***    Fri  22-Nov-1996
 ***
 *** -by- Jonathan Parati. [jonpa]   22-Nov-1996
 *** Converted Calc from floating point to infinite precision.
 *** The new math engine is in ..\ratpak
 ***
 ***
 *** -by- Amit Chatterjee. [amitc]  05-Jan-1990.
 *** Calc did not have a floating point exception signal handler. This
 *** would cause CALC to be forced to exit on a FP exception as that's
 *** the default.
 *** The signal handler is defined in SCIFUNC.C, in WinMain we hook the
 *** the signal.
\**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "signal.h"
#include "unifunc.h"
#include "input.h"
#include "scidisp.h"

#define BOOLIFY(x) ((x)?1:0)

/**************************************************************************/
/*** Global variable declarations and initializations                   ***/
/**************************************************************************/

int        nCalc=0;        /* 0=Scientific, 1=Simple.                      */
BOOL       gbUseSep=FALSE; /* display the number with a separator          */
ANGLE_TYPE nDecMode=ANGLE_DEG;  /* Holder for last used Deg/Rad/Grad mode. */
UINT       gnDecGrouping=0x03;  /* Holds the decimal digit grouping number */
int        nHexMode=0;     /* Holder for last used Dword/Word/Byte mode.   */

int        nTempCom=0,     /* Holding place for the last command.          */
           nParNum=0,      /* Number of parenthases.                       */
           nOpCode=0,      /* ID value of operation.                       */
           nOp[25],        /* Holding array for parenthasis operations.    */
           nPrecOp[25],    /* Holding array for precedence  operations.    */
           nPrecNum=0,     /* Current number of precedence ops in holding. */
           gcIntDigits;    /* Number of digits allowed in the current base */

eNUMOBJ_FMT nFE = FMT_FLOAT; /* Scientific notation conversion flag.       */

HWND       g_hwndDlg=0,     /* Global handle to main window.               */
           hEdit=0,         /* Handle to Clibboard I/O edit control        */
           hStatBox=0,      /* Global handle to statistics box.            */
           hListBox=0;      /* Global handle for statistics list box.      */
            

HMENU      g_hHexMenu=NULL;     // Global handle for hex menu 
HMENU      g_hDecMenu=NULL;     // Global handle for dec menu 

HANDLE     hAccel;              // Accelerator handle.
HINSTANCE  hInst;               // Global instance.

BOOL       bHyp=FALSE,          // Hyperbolic on/off flag.
           bInv=FALSE,          // Inverse on/off flag.
           bError=FALSE,        // Error flag.
           bColor=TRUE;         // Flag indicating if color is available.

HNUMOBJ    ghnoNum=NULL,        // Currently displayed number used everywhere.
           ghnoParNum[25],      // Holding array for parenthasis values.
           ghnoPrecNum[25],     // Holding array for precedence  values.
           ghnoMem=NULL,        // Current memory value.
           ghnoLastNum = NULL;  // Number before operation (left operand).

LONG       nPrecision = 32,         // number of digits to use in decimal mode
           nDecimalPlaces = 10,     // number of decimal places to show
           nRadix=10,               // the current base (2, 8, 10, or 16)
           dwWordBitWidth = 64;     // # of bits in currently selected word size

BOOL       g_fHighContrast = FALSE; // Are we in High Contrast mode?

HNUMOBJ g_ahnoChopNumbers[4];   // word size inforcement

BOOL    bFarEast;       // true if we need to use Far East localization

#ifdef USE_MIRRORING
BOOL    g_fLayoutRTL = FALSE;
#endif

extern CALCINPUTOBJ gcio;
extern BOOL         gbRecord;

/* DO NOT LOCALIZE THESE STRINGS.                                           */

TCHAR      szAppName[10]=TEXT("SciCalc"), /* Application name.              */
           szDec[5]=TEXT("."),            /* Default decimal character      */
           gszSep[5]=TEXT(","),           /* Default thousand seperator     */
           szBlank[6]=TEXT("");           /* Blank space.                   */

LPTSTR     gpszNum = NULL;
static TCHAR szInitNum[] = TEXT("0");      // text to init gpszNum with

/* END WARNING */


/* rgpsz[] is an array of pointers to strings in a locally allocated      */
/* memory block.  This block is fixed such that LocalLock does not need   */
/* to be called to use a string.                                          */

TCHAR     *rgpsz[CSTRINGS];
RECT      rcDeg[6];


void ParseCmdLine( LPSTR pszCmdA );
BOOL InitializeWindowClass( HINSTANCE hPrevInstance );
void InitialOneTimeOnlySetup();
void EverythingResettingNumberSetup();

extern WNDPROC fpOrgDispEditProc;
LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/**************************************************************************/
/*** Main Window Procedure.                                             ***/
/***                                                                    ***/
/*** Important functions:                                               ***/
/***     1)  Gets text dimensions and sets conversion units correctly.  ***/
/***                                                                    ***/
/***     2)  Checks the display device driver for color capability.     ***/
/***         If only 2 colors are available (mono, cga), bColor is      ***/
/***         set to FALSE, and the background brush is gray.  If        ***/
/***         color is available, the background brush colors are read   ***/
/***         from WIN.INI and the brush is created.                     ***/
/***                                                                    ***/
/***     3)  Window and hidden edit control are created.                ***/
/***                                                                    ***/
/***     4)  Contains message loop and deletes the brushes used.        ***/
/***                                                                    ***/
/**************************************************************************/

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    MSG        msg;
    INT        nx;
    LPTSTR     psz;
    int        cch = 0, cchTotal = 0;
    TCHAR      szTempString[100] = {0};
#ifdef USE_MIRRORING
    DWORD      dwLayout;
#endif

    // A bunch of sanity checks to ensure nobody is violating any of the
    // bazillion
    // assumptions calc makes about the order of controls.  Of course these 
    // asserts
    // wouldn't prevent a really dedicated person from messing things up but they
    // should help guide a rational person who might not be aware of calc's 
    // idiosyncrasies.
    // Anyone who modifies the resource file should hit these asserts which
    // will then
    // alert them to the consequences of their actions.

    // IDC_0 to IDC_F must be in sequential increasing order
    ASSERT( 15 == (IDC_F - IDC_0) );
    // Binary operators IDC_AND through IDC_PWR must be in order
    ASSERT( (95-86) == (IDC_PWR - IDC_AND) );
    // Unary operators IDC_CHOP through IDC_EQU must be in order
    ASSERT( (112-96) == (IDC_EQU - IDC_CHOP) );
    // menu item id's must be in order
    ASSERT( 5 == (IDM_LASTMENU - IDM_FIRSTMENU) );

#ifdef USE_MIRRORING
    if (GetProcessDefaultLayout(&dwLayout) && (dwLayout & LAYOUT_RTL))
    {
        SetProcessDefaultLayout(dwLayout & ~LAYOUT_RTL);
        g_fLayoutRTL = TRUE;
    }
#endif

    ParseCmdLine( lpCmdLine );

    hInst = hInstance;

    if ( !InitializeWindowClass( hPrevInstance ) )
        return FALSE;

    // Read strings for keys, errors, trig types, etc.
    // These will be copied from the resources to local memory.  A larger
    // than needed block is allocated first and then reallocated once we
    // know how much is actually used.
    try
    {
        psz = (LPTSTR) LocalAlloc(LPTR, ByteCountOf(CCHSTRINGSMAX));
        if (!psz)
            throw;

        int cchResourceBuffer = CCHSTRINGSMAX, cchLeftInBuffer;

        // build up an offset array in rgpsz
        for (nx = 0; nx <= CSTRINGS; nx++)
        {
            INT_PTR iOffset;
Retry:
            cchLeftInBuffer = cchResourceBuffer - cchTotal;
            cch = 1 + LoadString(hInstance, (UINT)(IDS_FIRSTKEY + nx), psz + cchTotal, cchLeftInBuffer);

            if (cch == (cchResourceBuffer - cchTotal)) // woops: buffer was too small
            {
                LPTSTR pszTmp = (LPTSTR)LocalReAlloc(psz, ByteCountOf(cchResourceBuffer + CCHSTRINGSMAX), LMEM_MOVEABLE);
                if (!pszTmp)
                    throw;
                psz = pszTmp;
                cchResourceBuffer += CCHSTRINGSMAX;
                goto Retry;
            }

            iOffset = (INT_PTR)cchTotal;
            rgpsz[nx] = (LPTSTR)iOffset; // first pass is offset array
            cchTotal += cch;
        }
        LPTSTR pszTmp = (LPTSTR)LocalReAlloc(psz, ByteCountOf(cchTotal), LMEM_MOVEABLE);
        if (!pszTmp)
            throw;
        psz = pszTmp;

        // convert the array of offsets into an array of pointers
        for (nx = 0 ; nx <= CSTRINGS ; nx++)
            rgpsz[nx] = psz + (INT_PTR)rgpsz[nx];
    }
    catch ( ... )
    {
        if (psz)
            LocalFree(psz);
        if (LoadString(hInst, IDS_NOMEM, szTempString, CharSizeOf(szTempString)))
        {
            MessageBox((HWND) NULL, szTempString, NULL, MB_OK | MB_ICONHAND);
        }
        return FALSE;
    }

    // The display in calc isn't really an edit control so we use this edit 
    // control to simplify cutting to the clipboard

    hEdit = CreateWindow( TEXT("EDIT"), TEXT("CalcMsgPumpWnd"), 
                          WS_OVERLAPPED | WS_VISIBLE, 
                          CW_USEDEFAULT,0,CW_USEDEFAULT,0, 
                          NULL, NULL, hInst, NULL );

    // This initializes things that only need to be set up once, including a 
    // call to ratpak so that ratpak can create any constants it needs

    InitialOneTimeOnlySetup();

    // we store in the win.ini file our desired display mode, Scientific 
    //  or Standard

    nCalc = (INT)GetProfileInt(szAppName, TEXT("layout"), 1);

    gbUseSep = (INT)GetProfileInt(szAppName, TEXT("UseSep"), 0);

    // InitSciCalc creates a dialog based on what the value of nCalc is. 
    // A handle to the window that is created is stored in g_hwndDlg

    InitSciCalc(TRUE);

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDA_ACCELTABLE));


    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!hStatBox || !IsDialogMessage(hStatBox, &msg))
        {
            if ( ((msg.hwnd == g_hwndDlg)||IsChild(g_hwndDlg, msg.hwnd)) && TranslateAccelerator (g_hwndDlg, (HACCEL)hAccel, &msg))
                continue;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    LocalFree(psz);
    return (DWORD)msg.wParam;
}


/**************************************************************************\
*
*   Command Line processing routines
*
*   History
*       22-Nov-1996 JonPa       Wrote it
*
\**************************************************************************/

#define IsWhiteSpace( ch )  ((ch) == TEXT(' ') || (ch) == TEXT('\t'))
#define IsDigit( ch )       ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

LPTSTR TtoL( LPTSTR psz, LONG *pl ) {
    LONG l = 0;

    while( IsDigit( *psz ) ) {
        l = l * 10 + (*psz - TEXT('0'));
        psz = CharNext( psz );
    }

    *pl = l;
    return psz;
}

void ParseCmdLine( LPSTR pszCmdA ) {
    BOOL fInQuote;
    LPTSTR pszCmdT = GetCommandLine();

    // parse cmd line
    // usage: -p:## -r:## -w:## -e -x -i
    // -e, -x, and -i currently do nothing.

    // Skip app name
    while( *pszCmdT && IsWhiteSpace( *pszCmdT )) {
        pszCmdT = CharNext( pszCmdT );
    }

    fInQuote = FALSE;
    while( *pszCmdT && (fInQuote || !IsWhiteSpace(*pszCmdT)) ) {
        if (*pszCmdT == TEXT('\"'))
            fInQuote = !fInQuote;
        pszCmdT = CharNext( pszCmdT );
    }

    while( *pszCmdT )
    {
        switch( *pszCmdT )
        {
        case TEXT('p'):
        case TEXT('P'):
            // -p:## precision
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            pszCmdT = TtoL( pszCmdT, &nPrecision );

            // a percision > C_NUM_MAX_DIGITS will allow a string too long for it's buffer
            if ( nPrecision > C_NUM_MAX_DIGITS)
            {
                ASSERT( nPrecision <= C_NUM_MAX_DIGITS );
                nPrecision = C_NUM_MAX_DIGITS;
            }

            // NOTE: this code assumes there MUST be a space after the number
            break;

        case TEXT('r'):
        case TEXT('R'):
            // -r:## Radix
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            pszCmdT = TtoL( pszCmdT, &nRadix );

            // since the UI only has 16 keys for digit input, we only allow upto base 16
            if (nRadix > 16)
            {
                ASSERT( nRadix <= 16 );
                nRadix = 16;
            }
            else if (nRadix < 2)    // you know some fool would try for base zero if you let them
            {
                ASSERT( nRadix >= 2 );
                nRadix = 2;
            }

           // NOTE: this code assumes there MUST be a space after the number
            break;

        case TEXT('e'):
        case TEXT('E'):
            // -e extended mode
            break;

        case TEXT('w'):
        case TEXT('W'):
            // -w:## Word size in bits
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            // Set bit count
            pszCmdT = TtoL( pszCmdT, &dwWordBitWidth );

            // NOTE: this code assumes there MUST be a space after the number
            break;
        }

        pszCmdT = CharNext( pszCmdT );
    }
}

//////////////////////////////////////////////////
//
// InitalizeWindowClass
//
//////////////////////////////////////////////////
BOOL InitializeWindowClass( HINSTANCE hPrevInstance )
{
    WNDCLASSEX wndclass;

    if (!hPrevInstance)
    {
        wndclass.cbSize         = sizeof(wndclass);
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = CalcWndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = DLGWINDOWEXTRA;
        wndclass.hInstance      = hInst;
        wndclass.hIcon          = LoadIcon(hInst, TEXT("SC"));
        wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetSysColorBrush(COLOR_3DFACE);
        wndclass.lpszMenuName   = MAKEINTRESOURCE(IDM_CALCMENU);
        wndclass.lpszClassName  = szAppName;
        wndclass.hIconSm        = NULL;

        if (!RegisterClassEx(&wndclass))
            return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////
//
// InitialOneTimeOnlyNumberSetup
//
//////////////////////////////////////////////////
void InitialOneTimeOnlySetup()
{
    // Initialize the decimal input code.  This ends up getting called twice
    // but it's quick so that shouldn't be a problem.  Needs to be done before
    // SetRadix is called.

    CIO_vClear( &gcio );
    gbRecord = TRUE;

    // we must now setup all the ratpak constants and our arrayed pointers 
    // to these constants.
    BaseOrPrecisionChanged();

    // these rat numbers are set only once and then never change regardless of 
    // base or precision changes
    g_ahnoChopNumbers[0] = rat_qword;
    g_ahnoChopNumbers[1] = rat_dword;
    g_ahnoChopNumbers[2] = rat_word;
    g_ahnoChopNumbers[3] = rat_byte;

    // we can't call this until after we have set the radix (and thus called 
    // ChangeConstants) so we do it last.

    EverythingResettingNumberSetup();

    NumObjAssign( &ghnoMem, HNO_ZERO );
}

//////////////////////////////////////////////////
//
// EverythingResettingNumberSetup
//
//////////////////////////////////////////////////
void EverythingResettingNumberSetup()
{
    int i;

    // Initialize the decimal input code.
    CIO_vClear( &gcio );
    gbRecord = TRUE;

    NumObjAssign( &ghnoNum, HNO_ZERO );
    NumObjAssign( &ghnoLastNum, HNO_ZERO );

    // REVIEW: is it just me, or do we speew major memory wheneven this method
    // executes?

    // array used to handle ( and )
    for( i = 0; i < ARRAYSIZE(ghnoParNum); i++ )
        ghnoParNum[i] = NULL;

    // array used to handle order of operations
    for( i = 0; i < ARRAYSIZE(ghnoPrecNum); i++ )
        ghnoPrecNum[i] = NULL;

    gpszNum = (LPTSTR)NumObjAllocMem( sizeof(szInitNum) );
    if (gpszNum)
    {
        lstrcpy( gpszNum, szInitNum );
    }
}

//////////////////////////////////////////////////
//
// InitSciCalc
//
//////////////////////////////////////////////////
VOID  APIENTRY InitSciCalc(BOOL bViewChange)
{
    TCHAR   chLastDec;
    TCHAR   chLastSep;
    int     nLastSepLen;
    UINT    nLastDecGrouping;
    HMENU   hMenu;
    HWND    hDispEdit;
    BOOL    bRepaint=FALSE;
    RECT    rect = {0,0,0,0};
    TCHAR   szGrouping[32];
    

    EverythingResettingNumberSetup();

    // when we switch modes, we need to remind the ui that we are no longer 
    // inputing the number we were inputting before we switched modes.

    gbRecord = FALSE;    // REVIEW: This should not be needed with the new initialization

    chLastDec = szDec[0];
    chLastSep = gszSep[0];
    nLastDecGrouping=gnDecGrouping;

    GetProfileString(TEXT("intl"), TEXT("sDecimal"), TEXT("."), 
                     szDec, CharSizeOf(szDec));
    GetProfileString(TEXT("intl"), TEXT("sThousand"), TEXT(","), 
                     gszSep, CharSizeOf(gszSep));

    ZeroMemory(szGrouping,sizeof(szGrouping));
    GetProfileString(TEXT("intl"), TEXT("sGrouping"), TEXT("3;0"), 
                     szGrouping, CharSizeOf(szGrouping));

    gnDecGrouping=DigitGroupingStringToGroupingNum(szGrouping);

    // if the grouping pattern changed we always do the following things
    if (gnDecGrouping != nLastDecGrouping)
    {
        nLastDecGrouping=gnDecGrouping;
        bRepaint=TRUE;
    }
    
    
    // if the thousands symbol has changed we always do the following things

    if ( gszSep[0] != chLastSep )
    {
        chLastSep = gszSep[0];

        bRepaint = TRUE;
    }
    
    // if the decimal symbol has changed we always do the following things
    if ( szDec[0] != chLastDec )
    {
        chLastDec = szDec[0];

        // Re-initialize input string's decimal point.
        CIO_vUpdateDecimalSymbol(&gcio, chLastDec);

        // put the new decimal symbol into the table used to draw the decimal
        // key

        *(rgpsz[IDS_DECIMAL]) = chLastDec;

        // we need to redraw to update the decimal point button
        bRepaint = TRUE;
    }

    {
        HIGHCONTRAST hc;
        hc.cbSize = sizeof(hc);
        if ( SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) )
        {
            if ( BOOLIFY(hc.dwFlags & HCF_HIGHCONTRASTON) != g_fHighContrast )
            {
                g_fHighContrast = BOOLIFY(hc.dwFlags & HCF_HIGHCONTRASTON);
                bRepaint = TRUE;
            }
        }
    }

    if ( bViewChange )
    {
        BOOL bUseOldPos = FALSE;

        // if we are changing views we destory the old window and create 
        // a new window

        if ( g_hwndDlg )
        {
            SetMenu(g_hwndDlg, g_hDecMenu);
            bUseOldPos = TRUE;
            GetWindowRect( g_hwndDlg, &rect );
            DestroyWindow( g_hwndDlg );
            DestroyMenu(g_hHexMenu);
            g_hHexMenu=NULL;
        }

        // create the correct window for the mode we're currently in
        if ( nCalc )
        {
            // switch to standard mode
            g_hwndDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STANDARD), 0, 
                                     NULL);
            g_hDecMenu=GetMenu(g_hwndDlg);

#ifdef USE_MIRRORING
            if (g_fLayoutRTL)
            {
                SetWindowLong(g_hwndDlg,
                              GWL_EXSTYLE,
                              GetWindowLong(g_hwndDlg,GWL_EXSTYLE) | \
                              WS_EX_LAYOUTRTL |  WS_EX_NOINHERITLAYOUT);
            }
#endif
        }
        else
        {
            // switch to scientific mode
            g_hwndDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_SCIENTIFIC), 
                                     0, NULL);
            g_hDecMenu=GetMenu(g_hwndDlg);
            g_hHexMenu=LoadMenu(hInst, MAKEINTRESOURCE(IDM_HEXCALCMENU));

#ifdef USE_MIRRORING
            if (g_fLayoutRTL)
            {
                SetWindowLong(g_hwndDlg,
                              GWL_EXSTYLE,
                              GetWindowLong(g_hwndDlg,GWL_EXSTYLE) | WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
            }
#endif

            // Stat box is initially off, disable stat buttons.
            for ( int iID = IDC_AVE; iID <= IDC_DATA; iID++ )
                EnableWindow( GetDlgItem( g_hwndDlg, iID ), FALSE );

            SwitchModes(10, nDecMode, nHexMode);

            // If precision won't fit in display, then resize it
            if (nPrecision > 32)
            {
                HWND hwndDisplay;
                RECT rc, rcMain;

                hwndDisplay=GetDlgItem( g_hwndDlg, IDC_DISPLAY );
                GetWindowRect( hwndDisplay, &rc );
                GetClientRect( g_hwndDlg, &rcMain );
                MapWindowPoints( g_hwndDlg, NULL, (LPPOINT)&rcMain, 2);

                rc.left    = rcMain.left + (rcMain.right - rc.right);
                OffsetRect( &rc, -(rcMain.left), -(rcMain.top) );

                SetWindowPos(hwndDisplay, NULL, 
                             rc.left, rc.top, 
                             rc.right - rc.left, rc.bottom - rc.top,
                             SWP_NOACTIVATE | SWP_NOZORDER );
            }
        }

        if (hDispEdit = GetDlgItem(g_hwndDlg, IDC_DISPLAY))
        {
            // subclass the Edit Control hide caret and filter out mouse msg
            fpOrgDispEditProc = (WNDPROC)GetWindowLongPtr(hDispEdit, GWLP_WNDPROC);
            if (fpOrgDispEditProc)
                SetWindowLongPtr(hDispEdit, GWLP_WNDPROC, (LONG_PTR)(WNDPROC)SubDispEditProc);
        }
        
        // keep calc in the same place it was before
        if ( bUseOldPos )
        {
            SetWindowPos( g_hwndDlg, NULL, rect.left, rect.top, 0,0, 
                          SWP_NOZORDER | SWP_NOSIZE );
        }

        // ensure the menu items for Scientific and Standard are set correctly

        CheckMenuRadioItem(g_hDecMenu, IDM_SC, IDM_SSC, 
                           (nCalc == 0 ? IDM_SC : IDM_SSC), MF_BYCOMMAND); 

        CheckMenuItem(g_hDecMenu, IDM_USE_SEPARATOR, 
                      MF_BYCOMMAND | (gbUseSep ? MF_CHECKED : MF_UNCHECKED));  

        if (g_hHexMenu)
        {
            CheckMenuRadioItem(g_hHexMenu, IDM_SC, IDM_SSC, 
                               (nCalc == 0 ? IDM_SC : IDM_SSC), MF_BYCOMMAND); 

            CheckMenuItem(g_hHexMenu, IDM_USE_SEPARATOR, 
                          MF_BYCOMMAND | (gbUseSep ? MF_CHECKED:MF_UNCHECKED)); 
        }

        // To ensure that the call to SetRadix correctly update the active 
        // state of the buttons on
        // SciCalc we must tell it to forget the previous Radix
        {
            extern long oldRadix;
            oldRadix = (unsigned)-1;
        }

        // this will set the correct buttons on the UI
        SetRadix(10);

        SetDlgItemText(g_hwndDlg, IDC_MEMTEXT, 
                       NumObjIsZero(ghnoMem) ? (szBlank) : (TEXT(" M")) );

        SendMessage(g_hwndDlg, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);

        ShowWindow( g_hwndDlg, SW_SHOW );
        UpdateWindow(g_hwndDlg);

    } // END if ( bViewChanged )
    else if ( bRepaint )
    {
        // no need to repaint if we just changed views
        InvalidateRect( g_hwndDlg, NULL, TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\vars1.h ===
/*  VARS1.H  */


#define MAXALIASLEN 20
#define CODEBUFFERLEN 20
#define MAXVECTORSTACK 20
#define MAXLISTLENGTH 20

struct aliasTable {
	unsigned char *aliasName;
	unsigned char gideiCode;
	};

struct asciiTables {
	unsigned char gideiCode1, gideiCode2;
	};

struct listTypes {
	int len;
	unsigned char list[MAXLISTLENGTH];
	};




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\vars.h ===
/*  VARS.H  */

#include "vars1.h"

typedef  struct tagMouseKeysParam {
	int		NumButtons;		/* holds number of buttons on the mice	*/
	int		Delta_Y;		/* Relative Y motion sign extended		*/
	int		Delta_X;		/* Relative X motion sign extended		*/
	int		Status;			/* status of mouse buttons and motion	*/
} MOUSEKEYSPARAM;


#define TRUE 1
#define FALSE 0

#define TAB 9
#define LINEFEED 10
#define VERTICALTAB 11
#define FORMFEED 12
#define RETURN 13
#define SPACE 32
#define COMMA 44
#define PERIOD 46
#define ESC 27
#define ESCAPE 27

#define notOKstatus 0
#define okStatus 1
#define NOKEY 0

extern void *aliasStack[MAXVECTORSTACK];
extern void *vectorStack[MAXVECTORSTACK];
extern int stackPointer;
extern unsigned char lastCode;
extern void (*serialVector)(unsigned char);
extern void (*codeVector)(unsigned char);
extern void (*commandVector)(unsigned char);
extern struct aliasTable *aliasPtr;

extern struct listTypes tempList, keyHoldList, keyLockList;
extern char cAliasString[MAXALIASLEN];
extern int nullCount;
extern int blockCount;

extern char buf[CODEBUFFERLEN];
extern int spos,rpos;

extern int passAll, fatalErrorFlag, stdErrorFlag, waitForClear, beginOK;

extern int mouseX, mouseY;
extern MOUSEKEYSPARAM mouData;
extern MOUSEKEYSPARAM *mouseDataPtr;
extern int requestButton1, requestButton2, requestButton3;
extern int button1Status, button2Status, button3Status;

extern struct aliasTable nullTable[];


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\calchelp.h ===
/* CalcHelp.h - help codes for Chicago Calculator */

#define CALC_STD_SIGN       80 // beginning of matchup
#define CALC_C              81
#define CALC_CE             82
#define CALC_BACK           83
#define CALC_SCI_STA        84
#define CALC_STD_DECIMAL    85

#define CALC_SCI_AND        86
#define CALC_SCI_OR         87
#define CALC_SCI_XOR        88
#define CALC_SCI_LSH        89
#define CALC_STD_SLASH      90
#define CALC_STD_ASTERISK   91
#define CALC_STD_PLUS       92
#define CALC_STD_MINUS      93
#define CALC_SCI_MOD        94
#define CALC_SCI_XCARETY    95

#define CALC_SCI_INT        96
#define CALC_SCI_NOT        97
#define CALC_SCI_SIN        98
#define CALC_SCI_COS        99
#define CALC_SCI_TAN        100
#define CALC_SCI_LN         101
#define CALC_SCI_LOG        102
#define CALC_STD_SQRT       103
#define CALC_SCI_XCARET2    140
#define CALC_SCI_XCARET3    104
#define CALC_SCI_FACTORIAL  105
#define CALC_1X             106
#define CALC_SCI_DMS        107
#define CALC_STD_PERCENT    108
#define CALC_SCI_FE         109
#define CALC_SCI_PI         110
#define CALC_STD_EQUAL      111

#define CALC_MC             112
#define CALC_MR             113
#define CALC_MS             114
#define CALC_MPLUS          115 /* was CALC_M+ but this breaks the C compiler */

#define CALC_SCI_EXP        116

#define CALC_SCI_AVE        117
#define CALC_SCI_SUM        118
#define CALC_SCI_S          119
#define CALC_SCI_DAT        120

#define CALC_SCI_OPENPAREN  40
#define CALC_SCI_CLOSEPAREN 41

#define CALC_STD_NUMBERS    48 /* are Numbers  48-57*/
#define CALC_SCI_ABCDEF     65 /* Are Numbers 65 - 70 */
// 0 - F are in here, bin should start again at 140

#define CALC_SCI_BIN        121
#define CALC_SCI_OCT        122
#define CALC_SCI_DEC        123
#define CALC_SCI_HEX        124

#define CALC_SCI_INV        125
#define CALC_SCI_HYP        126
#define CALC_SCI_DEG        127
#define CALC_SCI_RAD        128
#define CALC_SCI_GRAD       129

// if Dword, word, and byte followed Deg,rad,grad we could convert by adding three
#define CALC_SCI_OWORD      19   // reserved 128 bit
#define CALC_SCI_QWORD      20
#define CALC_SCI_DWORD      21
#define CALC_SCI_WORD       22
#define CALC_SCI_BYTE       23

#define CALC_SCI_MEM        130     // end of matchup
#define CALC_SCI_PARENS     131
#define CALC_STD_VALUE      9       // this is the display's help text
      
// these are converted seperately:                      
#define CALC_SCI_STATISTICS_VALUE 401
#define CALC_SCI_RET       402
#define CALC_SCI_LOAD      403
#define CALC_SCI_CD        404
#define CALC_SCI_CAD       405
#define CALC_SCI_NUMBER    406
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\access\skeys\tables.h ===
/*  TABLES.H  */


extern	struct aliasTable	gideiAliasTable[];
extern	struct aliasTable	commandsAliasTable[];
extern	struct aliasTable	kbdAliasTable[];
extern	struct aliasTable	kbdModelAliasTable[];
extern	struct aliasTable	kbdDescriptionAliasTable[];
extern	struct aliasTable 	kbdVersionAliasTable[];
extern	struct aliasTable 	kbdIndicatorAliasTable[];



extern	struct aliasTable	mouseAliasTable[];
extern	struct aliasTable	genAliasTable[];
extern	struct aliasTable	commAliasTable[];
extern  struct aliasTable	baudrateAliasTable[];
extern  struct aliasTable	mouButtonAliasTable[];
extern	int	baudrateTable[];

extern	struct asciiTables	asciiTable[];
extern  struct aliasTable	keyAliasTable[];
extern	int	IBMextendedScanCodeSet1[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\input.c ===
/****************************Module*Header***********************************\
* Module Name: INPUT.C
*
* Module Descripton: Decimal floating point input
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"

extern BOOL     gbRecord;
extern TCHAR    szDec[5];       // The decimal point we use
extern INT gcIntDigits;

TCHAR const szZeroInit[] = TEXT("0");

#define CH_BASE_10_EXP          TEXT('e')
#define CH_BASE_X_EXP           TEXT('^')

/****************************************************************************/
void CIO_vClearNSec( PCALCNUMSEC pcns ) {
    pcns->fEmpty = TRUE;
    pcns->fNeg = FALSE;
    lstrcpy( pcns->szVal, szZeroInit );
    pcns->cchVal = lstrlen(pcns->szVal);
}

void CIO_vClear(PCALCINPUTOBJ pcio)
{
    CIO_vClearNSec( &(pcio->cnsNum) );
    CIO_vClearNSec( &(pcio->cnsExp) );
    pcio->fExp = FALSE;
    pcio->iDecPt = -1;
}

/****************************************************************************/

void CIO_vConvertToNumObj(PHNUMOBJ phnoNum, PCALCINPUTOBJ pcio)
{
    HNUMOBJ hnoValue;
    LPTSTR pszExp = NULL;

    // ZTerm the strings
    pcio->cnsNum.szVal[pcio->cnsNum.cchVal] = TEXT('\0');

    if (pcio->fExp ) {
        pszExp = pcio->cnsExp.szVal;
        pszExp[pcio->cnsExp.cchVal] = TEXT('\0');
    }

    hnoValue = NumObjMakeNumber( pcio->cnsNum.fNeg, pcio->cnsNum.szVal,  pcio->cnsExp.fNeg, pszExp );
    NumObjAssign( phnoNum, hnoValue );

    return;
}

/****************************************************************************/

void CIO_vConvertToString(LPTSTR *ppszOut, PCALCINPUTOBJ pcio, int nRadix)
{
    //In theory both the base and exponent could be C_NUM_MAX_DIGITS long.
    TCHAR szTemp[C_NUM_MAX_DIGITS*2+4];
    LPTSTR psz;
    int i;

    // ZTerm the strings
    pcio->cnsNum.szVal[pcio->cnsNum.cchVal] = TEXT('\0');

    if ( pcio->fExp )
        pcio->cnsExp.szVal[pcio->cnsExp.cchVal] = TEXT('\0');

    i = 0;
    if (pcio->cnsNum.fNeg)
        szTemp[i++] = TEXT('-');

    lstrcpy( &szTemp[i], pcio->cnsNum.szVal );
    i += pcio->cnsNum.cchVal;

    // Add a '.' if it is not already there
    if (pcio->iDecPt == -1 )
        szTemp[i++] = szDec[0];

    if (pcio->fExp) {
        szTemp[i++] = nRadix == 10 ? CH_BASE_10_EXP : CH_BASE_X_EXP;

        if (pcio->cnsExp.fNeg)
            szTemp[i++] = TEXT('-');
        else
            szTemp[i++] = TEXT('+');

        lstrcpy( &szTemp[i], pcio->cnsExp.szVal );
        i += pcio->cnsExp.cchVal;
    }

    psz = (LPTSTR)NumObjAllocMem( (lstrlen( szTemp )+1) * sizeof(TCHAR) );
    if (psz) {
        if (*ppszOut != NULL) {
            NumObjFreeMem( *ppszOut );
        }
        *ppszOut = psz;
    }

    // Don't show '.' if in int math
    if (F_INTMATH() && szTemp[i-1] == szDec[0])
        i--;

    szTemp[i] = TEXT('\0');

    lstrcpy( *ppszOut, szTemp );

    return;
}

/****************************************************************************/

BOOL CIO_bAddDigit(PCALCINPUTOBJ pcio, int iValue)
{
    PCALCNUMSEC pcns;
    TCHAR chDigit;
    int cchMaxDigits;

    // convert from an integer into a character
    chDigit = (iValue < 10)?(TEXT('0')+iValue):(TEXT('A')+iValue-10);

    if (pcio->fExp)
    {
        pcns = &(pcio->cnsExp);
        cchMaxDigits = C_EXP_MAX_DIGITS;
    }
    else
    {
        pcns = &(pcio->cnsNum);
        ASSERT( gcIntDigits <= C_NUM_MAX_DIGITS );
        cchMaxDigits = gcIntDigits;
    }

    // Ignore leading zeros
    if ( pcns->fEmpty && (iValue == 0) )
    {
        return TRUE;
    }

    if ( pcns->cchVal < cchMaxDigits )
    {
        if (pcns->fEmpty)
        {
            pcns->cchVal = 0;   // Clobber the default zero
            pcns->fEmpty = FALSE;
        }

        pcns->szVal[pcns->cchVal++] = chDigit;
        return TRUE;
    }

    // if we are in base 8 entering a mantica and we're on the last digit then
    // there are special cases where we can actually add one more digit.
    if ( nRadix == 8 && pcns->cchVal == cchMaxDigits && !pcio->fExp )
    {
        BOOL bAllowExtraDigit = FALSE;

        switch ( dwWordBitWidth % 3 )
        {
            case 1:
                // in 16bit word size, if the first digit is a 1 we can enter 6 digits
                if ( pcns->szVal[0] == TEXT('1') )
                    bAllowExtraDigit = TRUE;
                break;

            case 2:
                // in 8 or 32bit word size we get an extra digit if the first digit is 3 or less
                if ( pcns->szVal[0] <= TEXT('3') )
                    bAllowExtraDigit = TRUE;
                break;
        }

        if ( bAllowExtraDigit )
        {
            pcns->szVal[pcns->cchVal++] = chDigit;
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************/

void CIO_vToggleSign(PCALCINPUTOBJ pcio)
{

    // Zero is always positive
    if (pcio->cnsNum.fEmpty)
    {
        pcio->cnsNum.fNeg = FALSE;
        pcio->cnsExp.fNeg = FALSE;
    }
    else if (pcio->fExp)
    {
        pcio->cnsExp.fNeg = !pcio->cnsExp.fNeg;
    }
    else
    {
        pcio->cnsNum.fNeg = !pcio->cnsNum.fNeg;
    }
}

/****************************************************************************/

BOOL CIO_bAddDecimalPt(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    if (pcio->iDecPt != -1)                      // Already have a decimal pt
        return FALSE;

    if (pcio->fExp)                             // Entering exponent
        return FALSE;

    pcio->cnsNum.fEmpty = FALSE;                // Zeros become significant

    pcio->iDecPt = pcio->cnsNum.cchVal++;
    pcio->cnsNum.szVal[pcio->iDecPt] = szDec[0];

    return TRUE;
}

/****************************************************************************/

BOOL CIO_bExponent(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    // For compatability, add a trailing dec pnt to base num if it doesn't have one
    CIO_bAddDecimalPt( pcio );

    if (pcio->fExp)                             // Already entering exponent
        return FALSE;

    pcio->fExp = TRUE;                          // Entering exponent

    return TRUE;
}

/****************************************************************************/

BOOL CIO_bBackspace(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    if (pcio->fExp)
    {
        if ( !(pcio->cnsExp.fEmpty) )
        {
            pcio->cnsExp.cchVal--;

            if (pcio->cnsExp.cchVal == 0)
            {
                CIO_vClearNSec( &(pcio->cnsExp) );
            }
        }
        else
        {
            pcio->fExp = FALSE;
        }
    }
    else
    {
        if ( !(pcio->cnsNum.fEmpty) )
        {
            pcio->cnsNum.cchVal--;
        }

        if ( pcio->cnsNum.cchVal <= pcio->iDecPt )
            //Backed up over decimal point
            pcio->iDecPt = -1;

        if ((pcio->cnsNum.cchVal == 0) || ((pcio->cnsNum.cchVal == 1) && (pcio->cnsNum.szVal[0] == TEXT('0'))))
            CIO_vClearNSec( &(pcio->cnsNum) );
    }

    return TRUE;
}

/****************************************************************************/

void CIO_vUpdateDecimalSymbol(PCALCINPUTOBJ pcio, TCHAR chLastDP)
{
    int iDP;

    ASSERT(pcio);

    iDP = pcio->iDecPt;                            // Find the DP index

    if (iDP == -1)
        return;

    ASSERT(pcio->cnsNum.szVal[iDP] == chLastDP);

    pcio->cnsNum.szVal[iDP] = szDec[0];                   // Change to new decimal pt
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scidisp.h ===
UINT DigitGroupingStringToGroupingNum(PTSTR szGrouping);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by calc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\input.h ===
/****************************Module*Header***********************************\
* Module Name: INPUT.H
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

// the string must hold, at a minimun, enough digits for a quadword binary number (ie 64)
#define MAX_STRLEN      64          // Seems to be the magic value for calc...

#define C_NUM_MAX_DIGITS    MAX_STRLEN
#define C_EXP_MAX_DIGITS    4

typedef struct
{
    BOOL    fEmpty;                 // TRUE if the number has no digits yet
    BOOL    fNeg;                   // TRUE if number is negative
    INT     cchVal;                 // number of characters in number (including dec. pnt)
    TCHAR   szVal[MAX_STRLEN+1];      //
} CALCNUMSEC, *PCALCNUMSEC;

#if C_NUM_MAX_DIGITS > MAX_STRLEN || C_EXP_MAX_DIGITS > MAX_STRLEN
#   pragma error(CALCNUMSEC.szVal is too small)
#endif

typedef struct
{
    BOOL    fExp;                   // TRUE if number has exponent
    INT     iDecPt;                 // index to decimal point of number portion.  -1 if no dec pnt
    CALCNUMSEC cnsNum;              // base number
    CALCNUMSEC cnsExp;              // exponent if it exists
} CALCINPUTOBJ, *PCALCINPUTOBJ;

#define CIO_bDecimalPt(pcio)    ((pcio)->iDecPt != -1)

void CIO_vClear(PCALCINPUTOBJ pcio);
BOOL CIO_bAddDigit(PCALCINPUTOBJ pcio, int iValue);
void CIO_vToggleSign(PCALCINPUTOBJ pcio);
BOOL CIO_bAddDecimalPt(PCALCINPUTOBJ pcio);
BOOL CIO_bExponent(PCALCINPUTOBJ pcio);
BOOL CIO_bBackspace(PCALCINPUTOBJ pcio);
void CIO_vUpdateDecimalSymbol(PCALCINPUTOBJ pcio, TCHAR chLastDP);
void CIO_vConvertToString(LPTSTR *ppszOut, PCALCINPUTOBJ pcio, int nRadix);
void CIO_vConvertToNumObj(PHNUMOBJ phnoNum, PCALCINPUTOBJ pcio);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scidisp.c ===
/****************************Module*Header***********************************\
* Module Name: SCIDISP.C
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"

#include <tchar.h>
#include <stdlib.h>


extern HNUMOBJ      ghnoNum;
extern eNUMOBJ_FMT  nFE;
extern TCHAR        szDec[5];
extern TCHAR        gszSep[5];
extern UINT         gnDecGrouping;
extern LPTSTR       gpszNum;
extern BOOL         gbRecord;
extern BOOL         gbUseSep;
extern CALCINPUTOBJ gcio;


/****************************************************************************\
* void DisplayNum(void)
*
* Convert ghnoNum to a string in the current radix.
*
* Updates the following globals:
*   ghnoNum, gpszNum
\****************************************************************************/
//
// State of calc last time DisplayNum was called
//
typedef struct {
    HNUMOBJ     hnoNum;
    LONG        nPrecision;
    LONG        nRadix;
    INT         nFE;
    INT         nCalc;
    INT         nHexMode;
    BOOL        fIntMath;
    BOOL        bRecord;
    BOOL        bUseSep;
} LASTDISP;

LASTDISP gldPrevious = { NULL, -1, -1, -1, -1, -1, FALSE, FALSE, FALSE };

#define InvalidLastDisp( pglp ) ((pglp)->hnoNum == NULL )


void GroupDigits(TCHAR sep, 
                 UINT  nGrouping, 
                 BOOL  bIsNumNegative,
                 PTSTR szDisplay, 
                 PTSTR szSepDisplay);


void DisplayNum(void)
{
    SetWaitCursor( TRUE );

    //
    // Only change the display if
    //  we are in record mode                               -OR-
    //  this is the first time DisplayNum has been called,  -OR-
    //  something important has changed since the last time DisplayNum was
    //  called.
    //
    if ( gbRecord || InvalidLastDisp( &gldPrevious ) ||
            !NumObjIsEq( gldPrevious.hnoNum,      ghnoNum     ) ||
            gldPrevious.nPrecision  != nPrecision   ||
            gldPrevious.nRadix      != nRadix       ||
            gldPrevious.nFE         != (int)nFE     ||
            gldPrevious.nCalc       != nCalc        ||
            gldPrevious.bUseSep     != gbUseSep     ||
            gldPrevious.nHexMode    != nHexMode     ||
            gldPrevious.fIntMath    != F_INTMATH()  ||
            gldPrevious.bRecord     != gbRecord )
    {
        // Assign is an expensive operation, only do when really needed
        if ( ghnoNum )
            NumObjAssign( &gldPrevious.hnoNum, ghnoNum );

        gldPrevious.nPrecision = nPrecision;
        gldPrevious.nRadix     = nRadix;
        gldPrevious.nFE        = (int)nFE;
        gldPrevious.nCalc      = nCalc;
        gldPrevious.nHexMode   = nHexMode;

        gldPrevious.fIntMath   = F_INTMATH();
        gldPrevious.bRecord    = gbRecord;
        gldPrevious.bUseSep    = gbUseSep;

        if (gbRecord)
        {
            // Display the string and return.

            CIO_vConvertToString(&gpszNum, &gcio, nRadix);
        }
        else if (!F_INTMATH())
        {
            // Decimal conversion

            NumObjGetSzValue( &gpszNum, ghnoNum, nRadix, nFE );
        }
        else
        {
            // Non-decimal conversion
            int i;

            // Truncate to an integer.  Do not round here.
            intrat( &ghnoNum );

            // Check the range.
            if ( NumObjIsLess( ghnoNum, HNO_ZERO ) )
            {
                // if negative make positive by doing a twos complement
                NumObjNegate( &ghnoNum );
                subrat( &ghnoNum, HNO_ONE );
                NumObjNot( &ghnoNum );
            }

            andrat( &ghnoNum, g_ahnoChopNumbers[nHexMode] );

            NumObjGetSzValue( &gpszNum, ghnoNum, nRadix, FMT_FLOAT );

            // Clobber trailing decimal point
            i = lstrlen( gpszNum ) - 1;
            if ( i >= 0 && gpszNum[i] == szDec[0] )
                gpszNum[i] = TEXT('\0');
        }

        // Display the string and return.

        if (!gbUseSep)
        {
            TCHAR szTrailSpace[256];

            lstrcpyn(szTrailSpace,gpszNum, 254);
            lstrcat(szTrailSpace,TEXT(" "));
            SetDisplayText(g_hwndDlg, szTrailSpace);
        }
        else
        {
            TCHAR szSepNum[256];

            switch(nRadix)
            {

                case 10:
                    GroupDigits(gszSep[0], 
                                gnDecGrouping, 
                                (TEXT('-') == *gpszNum), 
                                gpszNum,
                                szSepNum);
                    break;

                case 8:
                    GroupDigits(TEXT(' '), 0x03, FALSE, gpszNum, szSepNum);
                    break;

                case 2:
                case 16:
                    GroupDigits(TEXT(' '), 0x04, FALSE, gpszNum, szSepNum);
                    break;

                default:
                    lstrcpy(szSepNum,gpszNum);
            }

            lstrcat(szSepNum,TEXT(" "));
            SetDisplayText(g_hwndDlg, szSepNum);
        }
    }

    SetWaitCursor( FALSE );

    return;
}

/****************************************************************************\
*
* WatchDogThread
*
* Thread to look out for functions that take too long.  If it finds one, it
* prompts the user if he wants to abort the function, and asks RATPAK to
* abort if he does.
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
BOOL gfExiting = FALSE;
HANDLE ghCalcStart = NULL;
HANDLE ghCalcDone = NULL;
HANDLE ghDogThread = NULL;

INT_PTR TimeOutMessageBox( void );

DWORD WINAPI WatchDogThread( LPVOID pvParam ) {
    DWORD   cmsWait;
    INT_PTR iRet;

    while( !gfExiting ) {
        WaitForSingleObject( ghCalcStart, INFINITE );
        if (gfExiting)
            break;

        cmsWait = CMS_CALC_TIMEOUT;

        while( WaitForSingleObject( ghCalcDone, cmsWait ) == WAIT_TIMEOUT ) {

            // Put up the msg box
            MessageBeep( MB_ICONEXCLAMATION );
            iRet = TimeOutMessageBox();

            // if user wants to cancel, then stop
            if (gfExiting || iRet == IDYES || iRet == IDCANCEL) {
                NumObjAbortOperation(TRUE);
                break;
            } else {
                cmsWait *= 2;
                if (cmsWait > CMS_MAX_TIMEOUT) {
                    cmsWait = CMS_MAX_TIMEOUT;
                }
            }
        }
    }

    return 42;
}

/****************************************************************************\
*
* TimeCalc
*
*   Function to keep track of how long Calc is taking to do a calculation.
* If calc takes too long (about 10 sec's), then a popup is put up asking the
* user if he wants to abort the operation.
*
* Usage:
*   TimeCalc( TRUE );
*   do a lengthy operation
*   TimeCalc( FALSE );
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
HWND ghwndTimeOutDlg = NULL;

void TimeCalc( BOOL fStart ) {
    if (ghCalcStart == NULL) {
        ghCalcStart = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    if (ghCalcDone == NULL) {
        ghCalcDone = CreateEvent( NULL, TRUE, FALSE, NULL );
    }

    if (ghDogThread == NULL) {
        DWORD tid;
        ghDogThread = CreateThread( NULL, 0, WatchDogThread, NULL, 0, &tid );
    }

    if (fStart) {
        NumObjAbortOperation(FALSE);
        ResetEvent( ghCalcDone );
        SetEvent( ghCalcStart );
    } else {

        SetEvent( ghCalcDone );

        if( ghwndTimeOutDlg != NULL ) {
            SendMessage( ghwndTimeOutDlg, WM_COMMAND, IDRETRY, 0L );
        }

        if( NumObjWasAborted() ) {
            DisplayError(SCERR_ABORTED);
        }
    }
}


/****************************************************************************\
*
* KillTimeCalc
*
* Should be called only at the end of the program, just before exiting, to
* kill the background timer thread and free its resources.
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
void KillTimeCalc( void ) {
    gfExiting = TRUE;
    SetEvent( ghCalcStart );
    SetEvent( ghCalcDone );

    WaitForSingleObject( ghDogThread, CMS_MAX_TIMEOUT );

    CloseHandle( ghCalcStart );
    CloseHandle( ghCalcDone );
    CloseHandle( ghDogThread );
}


/****************************************************************************\
*
* TimeOutMessageBox
*
*   Puts up a dialog that looks like a message box.  If the operation returns
* before the user has responded to the dialog, the dialog gets taken away.
*
* History
*   04-Dec-1996 JonPa   Wrote it.
*
\****************************************************************************/
INT_PTR
CALLBACK TimeOutDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    RECT rc;
    int y;

    switch( uMsg ) {
    case WM_INITDIALOG:
        ghwndTimeOutDlg = hwndDlg;

        //
        // Move ourselves to be over the main calc window
        //

        // Find the display window so we don't cover it up.
        GetWindowRect(GetDlgItem(g_hwndDlg, IDC_DISPLAY), &rc );
        y = rc.bottom;

        // Get the main calc window pos
        GetWindowRect( g_hwndDlg, &rc );

        SetWindowPos( hwndDlg, 0, rc.left + 15, y + 40, 0, 0,
                      SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
        break;

    case WM_COMMAND:
        EndDialog( hwndDlg, LOWORD(wParam) );
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR TimeOutMessageBox( void ) {
    return (int)DialogBox( hInst, MAKEINTRESOURCE(IDD_TIMEOUT), NULL, TimeOutDlgProc );
}


/****************************************************************************\
* 
* DigitGroupingStringToGroupingNum
* 
* Description:
*   This will take the digit grouping string found in the regional applet and 
*   represent this string as a hex value.  The grouping numbers are represented
*   as 4 bit numbers logically shifted and or'd to together so:
*
*   Grouping_string GroupingNum
*   0;0             0x000          - no grouping
*   3;0             0x003          - group every 3 digits
*   3;2;0           0x023          - group 1st 3 and then every 2 digits
*   4;0             0x004          - group every 4 digits
*   5;3;2;0         0x235          - group 5, then 3, then every 2
* 
* Returns: the grouping number
* 
* History
*   10-Sept-1999 KPeery - Wrote it to fix grouping on Hindi
*
\****************************************************************************/
UINT
DigitGroupingStringToGroupingNum(PTSTR szGrouping)
{
    PTSTR p,q;
    UINT  n, nGrouping, shift;

    if (NULL == szGrouping)
        return 0;

    nGrouping=0;
    shift=0;
    for(p=szGrouping; *p != TEXT('\0'); /* nothing */)
    {
        n=_tcstoul(p,&q,10);

        if ((n > 0) && (n < 16))
        {
            n<<=shift;
            shift+=4;

            nGrouping|=n;
        }

        if (q)
            p=q+1;
        else
            p++;
    }

    return nGrouping;
}


/****************************************************************************\
*
* GroupDigits
*
* Description:
*   This routine will take a grouping number and the display string and
*   add the separator according to the pattern indicated by the separator.
*  
*   GroupingNum
*     0x000          - no grouping
*     0x003          - group every 3 digits
*     0x023          - group 1st 3 and then every 2 digits
*     0x004          - group every 4 digits
*     0x235          - group 5, then 3, then every 2
*
* History
*   08-Sept-1998 KPeery - Wrote orignal add num separator routine
*   10-Sept-1999 KPeery - Re-wrote it to do digit grouping in general
*
\***************************************************************************/
void
GroupDigits(TCHAR sep, 
            UINT  nGrouping, 
            BOOL  bIsNumNegative, 
            PTSTR szDisplay, 
            PTSTR szSepDisplay)
{
    PTSTR  src,dest, dec;
    size_t len;
    int    nDigits, nOrgDigits, count; 
    UINT   nOrgGrouping, nCurrGrouping;

    if ((sep == TEXT('\0')) || (nGrouping == 0))
    {
        lstrcpy(szSepDisplay,szDisplay);
        return;
    }

    // find decimal point

    for(dec=szDisplay; (*dec != szDec[0]) && (*dec != TEXT('\0')); dec++)
        ; // do nothing

    // at this point dec should point to '\0' or '.' we will add the left
    // side of the number to the final string

    // length of left half of number
    len=(dec-szDisplay);

    // num of digits
    nDigits=len-(bIsNumNegative ? 1 : 0);


    nOrgDigits=nDigits;
    nOrgGrouping=nGrouping;

    //
    // ok, we must now find the adjusted len, to do that we loop
    // through the grouping while keeping track of where we are in the
    // number.  When the nGrouping reaches 0 then we simply repeat the 
    // last grouping for the rest of the digits.
    //
    nCurrGrouping=nGrouping % 0x10;

    for ( ; nDigits > 0; )
    {
        if ((UINT)nDigits > nCurrGrouping)
        {
            nDigits-=nCurrGrouping;
            len++;                      // add one for comma

            nGrouping>>=4;

            if (nGrouping > 0)
                nCurrGrouping=nGrouping % 0x10;
        }
        else
            nDigits-=nCurrGrouping;
    }

    //
    // restore the saved nDigits and grouping pattern
    //
    nDigits=nOrgDigits;
    nGrouping=nOrgGrouping;
    nCurrGrouping=nGrouping % 0x10;

    //
    // ok, now we know the length copy the digits, at the same time
    // repeat the grouping pattern and place the seperator appropiatly, 
    // repeating the last grouping until we are done
    //
        
    src=dec-1;
    dest=szSepDisplay+len-1;

    count=0;
    for( ; nDigits > 0;  ) 
    {
        *dest=*src;
        nDigits--;
        count++;

        if (((count % nCurrGrouping) == 0) && (nDigits > 0))
        {
            dest--;
            *dest=sep;

            count=0;  // account for comma

            nGrouping>>=4;

            if (nGrouping > 0)
                nCurrGrouping=nGrouping % 0x10;
        }

        dest--;
        src--;
    }

    // now copy the minus sign if it is there
    if (bIsNumNegative)
        *szSepDisplay=*szDisplay;
    
    //
    // ok, now add the right (fractional) part of the number to the final
    // string.
    //
    dest=szSepDisplay+len;

    lstrcpy(dest,dec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scifunc.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scifunc.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SciCalcFunctions--do sin, cos, tan, com, log, ln, rec, fac, etc.***/
/***    DisplayError--Error display driver.                             ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SciCalcFunctions call DisplayError.                             ***/
/***                                                                    ***/
/*** Last modification. Fri  05-Jan-1990.                               ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee. [amitc]  05-Jan-1990.                                                      ***/
/*** Calc did not have a floating point exception signal handler. This  ***/
/*** would cause CALC to be forced to exit on a FP exception as that's  ***/
/*** the default.                                                                                                                                                  ***/
/*** The signal handler is defined in here, in SCIMAIN.C we hook the    ***/
/*** the signal.                                                                                                                                    ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee. [amitc] 14-Dec-1989                                                   ***/
/*** The REC function will not depend on the bInv flag. It used to ret  ***/
/*** a random number when the bInv flag was set.                                                 ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee.      [amitc] 08-Dec-1989                                                   ***/
/*** Did a minor bug fix. The EnableToggles routine now sets the focus  ***/
/*** back to the main window before disabling HEX,DEC etc.. Without this***/
/*** the window with the focus would get disable and cause MOVE to not  ***/
/*** work right.                                                                                                                ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
//#include "float.h"

extern HNUMOBJ     ghnoLastNum;
extern BOOL        bError;
extern TCHAR       *rgpsz[CSTRINGS];
INT                gnPendingError ;

/* Routines for more complex mathematical functions/error checking.       */

VOID  APIENTRY SciCalcFunctions (PHNUMOBJ phnoNum, DWORD wOp)
{
    try
    {
        switch (wOp)
        {
            case IDC_CHOP:
                if (bInv)
                {
                    // fractional portion
                    fracrat( phnoNum );
                }
                else
                {
                    // integer portion
                    intrat( phnoNum );
                }
                return;

            /* Return complement.                                             */
            case IDC_COM:
                NumObjNot( phnoNum );
                return;


            case IDC_PERCENT:
                {
                    DECLARE_HNUMOBJ( hno );
                    DECLARE_HNUMOBJ( hno100 );

                    try
                    {
                        NumObjAssign( &hno, ghnoLastNum );
                        NumObjSetIntValue( &hno100, 100 );

                        divrat( &hno, hno100 );

                        NumObjDestroy( &hno100 );

                        mulrat( phnoNum, hno );

                        NumObjDestroy( &hno );
                    }
                    catch ( DWORD nErrCode )
                    {
                        if ( hno != NULL )
                            NumObjDestroy( &hno );
                        if ( hno100 != NULL ) 
                            NumObjDestroy( &hno100 );
                        throw nErrCode;
                    }
                    return;
                }

            case IDC_SIN: /* Sine; normal, hyperbolic, arc, and archyperbolic     */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        asinhrat( phnoNum );
                    }
                    else
                    {
                        asinanglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                    {
                        // hyperbolic sine
                        sinhrat( phnoNum );
                    }
                    else
                    {
                        NumObjSin( phnoNum );
                    }
                }
                return;

            case IDC_COS: /* Cosine, follows convention of sine function.         */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        acoshrat( phnoNum );
                    }
                    else
                    {
                        acosanglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                        coshrat( phnoNum );
                    else
                    {
                        // cos()
                        NumObjCos( phnoNum );
                    }
                }
                return;

            case IDC_TAN: /* Same as sine and cosine.                             */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        atanhrat( phnoNum );
                    }
                    else
                    {
                        atananglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                        tanhrat( phnoNum );
                    else
                    {
                        // Get the answer
                        NumObjTan( phnoNum );
                    }
                }
                return;

            case IDC_REC: /* Reciprocal.                                          */
                NumObjInvert( phnoNum );
                return;

            case IDC_SQR: /* Square and square root.                              */
            case IDC_SQRT:
                if(bInv || nCalc)
                {
                    rootrat( phnoNum, HNO_TWO );
                }
                else
                {
                    ratpowlong( phnoNum, 2 );
                }
                return;

            case IDC_CUB: /* Cubing and cube root functions.                      */
                if(bInv) {
                    DECLARE_HNUMOBJ( hno );

                    // REVIEW: if constants like 3 are going to be used repeatedly, it will be
                    // much quicker to define them once and then keep around the definition.
                    try
                    {
                        NumObjAssign( &hno, HNO_ONE );
                        addrat( &hno, HNO_TWO );

                        rootrat( phnoNum, hno );

                        NumObjDestroy( &hno );
                    }
                    catch ( DWORD nErrCode )
                    {
                        if ( hno != NULL )
                            NumObjDestroy( &hno );

                        throw nErrCode;
                    }
                }
                else {
                    /* Cube it, you dig?       */
                    ratpowlong( phnoNum, 3 );
                }
                return;

            case IDC_LOG: /* Functions for common and natural log.                */
            case IDC_LN:
                if(bInv)
                {
                    /* Check maximum for exponentiation for 10 and e.       */
                    if (wOp==IDC_LOG) /* Do exponentiation.                       */
                        NumObjAntiLog10( phnoNum ); // 10.
                    else
                        exprat( phnoNum );  // e.
                }
                else
                {
                    // ratpak checks for valid range and throws error code if needed
                    if (wOp==IDC_LOG)
                        log10rat( phnoNum );
                    else
                        lograt( phnoNum );

                    // REVIEW: Is conversion of epsilon still needed?
                    NumObjCvtEpsilonToZero( phnoNum );
                }
                return;

            case IDC_FAC: /* Calculate factorial.  Inverse is ineffective.        */
                factrat( phnoNum );
                return;

            case IDC_DMS:
                {
                    if (F_INTMATH())
                    {
                        MessageBeep(0);
                    } 
                    else 
                    {
                        DECLARE_HNUMOBJ(hnoMin);
                        DECLARE_HNUMOBJ(hnoSec);
                        DECLARE_HNUMOBJ(hnoShft);

                        try
                        {
                            NumObjSetIntValue( &hnoShft, bInv ? 100 : 60 );

                            NumObjAssign( &hnoMin, *phnoNum );
                            intrat( phnoNum );

                            subrat( &hnoMin, *phnoNum );
                            mulrat( &hnoMin, hnoShft );
                            NumObjAssign( &hnoSec, hnoMin );
                            intrat( &hnoMin );

                            subrat( &hnoSec, hnoMin );
                            mulrat( &hnoSec, hnoShft );

                            //
                            // *phnoNum == degrees, hnoMin == minutes, hnoSec == seconds
                            //

                            NumObjSetIntValue( &hnoShft, bInv ? 60 : 100 );
                            divrat( &hnoSec, hnoShft );
                            addrat( &hnoMin, hnoSec );

                            divrat( &hnoMin, hnoShft );
                            addrat( phnoNum, hnoMin );

                            NumObjDestroy( &hnoShft );
                            NumObjDestroy( &hnoMin );
                            NumObjDestroy( &hnoSec );
                        }
                        catch ( DWORD nErrCode )
                        {
                            if ( hnoShft != NULL )
                                NumObjDestroy( &hnoShft );
                            if ( hnoMin != NULL )
                                NumObjDestroy( &hnoMin );
                            if ( hnoSec != NULL )
                                NumObjDestroy( &hnoSec );
                            throw nErrCode;
                        }
                    }
                    return;
                }
        }   // end switch( nOp )
    }
    catch( DWORD nErrCode )
    {
        DisplayError( nErrCode );
    }

    return;
}



/* Routine to display error messages and set bError flag.  Errors are     */
/* called with DisplayError (n), where n is a INT   between 0 and 5.      */

VOID  APIENTRY DisplayError (INT   nError)
{
    SetDisplayText(g_hwndDlg, rgpsz[IDS_ERRORS+nError]);
    bError=TRUE; /* Set error flag.  Only cleared with CLEAR or CENTR.    */
    
    /* save the pending error */
    gnPendingError = nError ;
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scicomm.c ===
/****************************Module*Header***********************************\
* Module Name: SCICOMM.C
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"
#include "input.h"

extern HWND        hStatBox;
extern HNUMOBJ     ghnoNum, ghnoLastNum, ghnoMem;
extern HNUMOBJ     ghnoParNum[25], ghnoPrecNum[25];

extern eNUMOBJ_FMT nFE;
extern INT         nTempCom, nParNum, nPrecNum, gcIntDigits,
                   nOpCode, nOp[25], nPrecOp[25];
extern BOOL        bError;
extern TCHAR       szBlank[6];
extern TCHAR      *rgpsz[CSTRINGS];


int             nLastCom;   // Last command entered.
CALCINPUTOBJ    gcio;       // Global calc input object for decimal strings
BOOL            gbRecord;   // Global mode: recording or displaying


/* Puts up the wait cursor if the calc will take a long time */
HCURSOR ghcurOld = NULL;

BOOL SetWaitCursor( BOOL fOn ) {
    if (fOn && ghcurOld == NULL) {
        ghcurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );
    } else if (!fOn && ghcurOld != NULL) {
        SetCursor( ghcurOld );
        ghcurOld = NULL;
    }

    return (fOn && ghcurOld != NULL);
}

/* Process all keyclicks whether by mouse or accelerator.                 */
VOID NEAR RealProcessCommands(WPARAM wParam);

VOID NEAR ProcessCommands(WPARAM wParam)
{
    if (wParam != IDM_ABOUT)
    {
        TimeCalc(TRUE);
    }

    try
    {
        RealProcessCommands( wParam );
    }
    catch( ... )
    {
        // note:  it should be impossible for a throw to reach this level, this is put here as an
        // emergency backup only.  Throws are normally caught at the boundry between calc and ratpak.
        ASSERT( 0 );
        MessageBox( g_hwndDlg, TEXT("An unknown error has occured."), TEXT("Error"), MB_OK );
    }

    if (wParam != IDM_ABOUT)
    {
        TimeCalc(FALSE);
    }
}

VOID NEAR RealProcessCommands(WPARAM wParam)
{
    static BOOL    bNoPrevEqu=TRUE, /* Flag for previous equals.          */
                   bChangeOp=FALSE; /* Flag for changing operation.       */
    INT            nx, ni;
    TCHAR          szJunk[50], szTemp[50];
    static BYTE    rgbPrec[24]={      0,0,  IDC_OR,0, IDC_XOR,0,  IDC_AND,1, 
                                IDC_ADD,2, IDC_SUB,2,    RSHF,3, IDC_LSHF,3,
                                IDC_MOD,3, IDC_DIV,3, IDC_MUL,3,  IDC_PWR,4};

    // Make sure we're only getting commands we understand.

    ASSERT( xwParam(IDC_FIRSTCONTROL, IDC_LASTCONTROL) || // Is it a button?
            xwParam(IDM_FIRSTMENU,    IDM_LASTMENU) );    // or a menu command?

    // Save the last command.  Some commands are not saved in this manor, these
    // commands are:
    // Inv, Hyp, Deg, Rad, Grad, Stat, FE, MClear, Back, and Exp.  The excluded
    // commands are not
    // really mathematical operations, rather they are GUI mode settings.

    if ( !xwParam(IDC_INV, IDC_HYP)    && !xwParam(IDM_HEX, IDM_BIN)  &&
         !xwParam(IDM_QWORD, IDM_BYTE) && !xwParam(IDM_DEG, IDM_GRAD) &&
         wParam!=IDC_STAT && wParam!=IDC_FE &&
         wParam!=IDC_MCLEAR && wParam!=IDC_BACK && wParam!=IDC_EXP)
    {
        nLastCom=nTempCom;
        nTempCom=(INT)wParam;
    }

    // If error and not a clear key or help key, BEEP.

    if (bError && (wParam !=IDC_CLEAR) && (wParam !=IDC_CENTR) &&
        (wParam != IDM_HELPTOPICS))
    {
        MessageBeep(0);
        return;
    }

    // Toggle Record/Display mode if appropriate.

    if (gbRecord)
    {
        if (xwParam(IDC_AND, IDC_MPLUS)        ||
            xwParam(IDC_AVE, IDC_CLOSEP)       ||
            xwParam(IDC_INV, IDC_HYP)          ||
            xwParam(IDM_HEX, IDM_BIN)          ||
            xwParam(IDM_QWORD, IDM_BYTE)       ||
            xwParam(IDM_DEG, IDM_GRAD)         ||
            wParam == IDM_PASTE)
        {
            gbRecord = FALSE;
            SetWaitCursor(TRUE);
            CIO_vConvertToNumObj(&ghnoNum, &gcio);
            DisplayNum();   // Causes 3.000 to shrink to 3. on first op.
            SetWaitCursor(FALSE);
        }
    }
    else
    {
        if ( xwParam(IDC_0, IDC_F) || wParam == IDC_PNT)
        {
            gbRecord = TRUE;
            CIO_vClear(&gcio);
        }
    }

    // Interpret digit keys.

    if (xwParam(IDC_0, IDC_F))
    {
        int iValue = (int)(wParam-IDC_0);

        // this is redundant, illegal keys are disabled
        if (iValue >= nRadix)
        {
            //ASSERT( 0 );
            MessageBeep(0);
            return;
        }


        if (!CIO_bAddDigit(&gcio, iValue))
        {
            MessageBeep(0);
            return;
        }

        DisplayNum();
        return;
    }


    // STATISTICAL FUNCTIONS:
    if (xwParam(IDC_AVE,IDC_DATA))
    {
        /* Do statistics functions on data in fpStatNum array.        */
        if (hStatBox)
        {
            DisplayNum();       // Make sure gpszNum has the correct string
            try
            {
                StatFunctions (wParam);
            }
            catch ( ... )
            {
                ASSERT( 0 );    // the only thing stat box should be able to throw is out of memory
                        // which in previous versions of calc caused a program crash
            }
            if (!bError)
                DisplayNum ();
        }
        else
            /* Beep if the stat box is not active.                    */
            MessageBeep(0);

        /* Reset the inverse flag since some functions use it.        */
        SetBox (IDC_INV, bInv=FALSE);
        return;
    }


    // BINARY OPERATORS:
    if (xwParam(IDC_AND,IDC_PWR))
    {
        if (bInv && wParam==IDC_LSHF)
        {
            SetBox (IDC_INV, bInv=FALSE);
            wParam=RSHF;
        }

        /* Change the operation if last input was operation.          */
        if (nLastCom >=IDC_AND && nLastCom <=IDC_PWR)
        {
            nOpCode=(INT)wParam;
            return;
        }

        /* bChangeOp is true if there was an operation done and the   */
        /* current ghnoNum is the result of that operation.  This is so */
        /* entering 3+4+5= gives 7 after the first + and 12 after the */
        /* the =.  The rest of this stuff attempts to do precedence in*/
        /* Scientific mode.                                           */
        if (bChangeOp)
        {
        DoPrecedenceCheckAgain:

            nx=0;
            while (wParam!=rgbPrec[nx*2] && nx <12)
                nx++;

            ni=0;
            while (nOpCode!=rgbPrec[ni*2] && ni <12)
                ni++;

            if (nx==12) nx=0;
            if (ni==12) ni=0;

            if (rgbPrec[nx*2+1] > rgbPrec[ni*2+1] && nCalc==0)
            {
                if (nPrecNum <25)
                {
                    NumObjAssign( &ghnoPrecNum[nPrecNum], ghnoLastNum );
                    nPrecOp[nPrecNum]=nOpCode;
                }
                else
                {
                    nPrecNum=24;
                    MessageBeep(0);
                }
                nPrecNum++;
            }
            else
            {
                /* do the last operation and then if the precedence array is not
                 * empty or the top is not the '(' demarcator then pop the top
                 * of the array and recheck precedence against the new operator
                 */

                SetWaitCursor(TRUE);

                DoOperation(nOpCode, &ghnoNum, ghnoLastNum);

                SetWaitCursor(FALSE);

                if ((nPrecNum !=0) && (nPrecOp[nPrecNum-1]))
                {
                    nPrecNum--;
                    nOpCode=nPrecOp[nPrecNum] ;
                    if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                        NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                    else
                        NumObjAssign(&ghnoLastNum, HNO_ZERO);

                    goto DoPrecedenceCheckAgain ;
                }

                if (!bError)
                    DisplayNum ();
            }
        }

        NumObjAssign(&ghnoLastNum, ghnoNum);
        NumObjAssign(&ghnoNum, HNO_ZERO);
        nOpCode=(INT)wParam;
        bNoPrevEqu=bChangeOp=TRUE;
        return;
    }

    // UNARY OPERATORS:
    if (xwParam(IDC_CHOP,IDC_PERCENT))
    {
        /* Functions are unary operations.                            */

        /* If the last thing done was an operator, ghnoNum was cleared. */
        /* In that case we better use the number before the operator  */
        /* was entered, otherwise, things like 5+ 1/x give Divide By  */
        /* zero.  This way 5+=gives 10 like most calculators do.      */
        if (nLastCom >= IDC_AND && nLastCom <= IDC_PWR)
            NumObjAssign( &ghnoNum, ghnoLastNum );

        SetWaitCursor(TRUE);
        SciCalcFunctions ( &ghnoNum, (DWORD)wParam);
        SetWaitCursor(FALSE);

        if (bError)
            return;

        /* Display the result, reset flags, and reset indicators.     */
        DisplayNum ();

        /* reset the bInv and bHyp flags and indicators if they are set
            and have been used */

        if (bInv &&
            (wParam == IDC_CHOP || wParam == IDC_SIN || wParam == IDC_COS ||
             wParam == IDC_TAN  || wParam == IDC_SQR || wParam == IDC_CUB ||
             wParam == IDC_LOG  || wParam == IDC_LN  || wParam == IDC_DMS))
        {
            bInv=FALSE;
            SetBox (IDC_INV, FALSE);
        }

        if (bHyp &&
            (wParam == IDC_SIN || wParam == IDC_COS || wParam == IDC_TAN))
        {
            bHyp = FALSE;
            SetBox (IDC_HYP, FALSE);
        }
        bNoPrevEqu=TRUE;
        return;
    }

    // BASE CHANGES:
    if (xwParam(IDM_HEX, IDM_BIN))
    {
        // Change radix and update display.
        if (nCalc==1)
        {
            wParam=IDM_DEC;
        }

        SetRadix((DWORD)wParam);
        return;
    }

    SetWaitCursor(TRUE);

    /* Now branch off to do other commands and functions.                 */
    switch(wParam)
    {
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_ABOUT:
        case IDM_SC:
        case IDM_SSC:
        case IDM_USE_SEPARATOR:
        case IDM_HELPTOPICS:
            // Jump to menu command handler in scimenu.c.
            MenuFunctions((DWORD)wParam);
            DisplayNum();
            break;

        case IDC_CLEAR: /* Total clear.                                       */
            NumObjAssign( &ghnoLastNum, HNO_ZERO );
            nPrecNum=nTempCom=nLastCom=nOpCode=nParNum=bChangeOp=FALSE;
            nFE = FMT_FLOAT;    // back to the default number format
            bNoPrevEqu=TRUE;

            /* clear the paranthesis status box indicator, this will not be
                cleared for CENTR */

            SetDlgItemText(g_hwndDlg, IDC_PARTEXT, szBlank);

            /* fall through */

        case IDC_CENTR: /* Clear only temporary values.                       */
            NumObjAssign( &ghnoNum, HNO_ZERO );

            if (!nCalc)
            {
                // Clear the INV, HYP indicators & leave (=xx indicator active

                SetBox (IDC_INV, bInv=FALSE);
                SetBox (IDC_HYP, bHyp=FALSE);
            }

            bError=FALSE;
            CIO_vClear(&gcio);
            gbRecord = TRUE;
            DisplayNum ();
            break;

        case IDC_STAT: /* Shift focus to Statistix Box if it's active.       */
            if (hStatBox)
                SetFocus(hStatBox);
            else
                SetStat (TRUE);
            break;

        case IDC_BACK:
            // Divide number by the current radix and truncate.
            // Only allow backspace if we're recording.
            if (gbRecord)
            {
                if (!CIO_bBackspace(&gcio))
                    MessageBeep(0);

                DisplayNum();
            }
            else
                MessageBeep(0);
            break;

        /* EQU enables the user to press it multiple times after and      */
        /* operation to enable repeats of the last operation.  I don't    */
        /* know if I can explain what the [censored] I did here...        */
        case IDC_EQU:
            do {
                // NOTE: the number pointed to by hnoHold won't get freed until process termination.
                static HNUMOBJ  hnoHold;

                /* Last thing keyed in was an operator.  Lets do the op on*/
                /* a duplicate of the last entry.                         */
                if ((nLastCom >= IDC_AND) && (nLastCom <= IDC_PWR))
                    NumObjAssign( &ghnoNum, ghnoLastNum );

                if (nOpCode) /* Is there a valid operation around?        */
                {
                    /* If this is the first EQU in a string, set hnoHold=ghnoNum */
                    /* Otherwise let ghnoNum=hnoTemp.  This keeps ghnoNum constant */
                    /* through all EQUs in a row.                         */
                    if (bNoPrevEqu)
                        NumObjAssign(&hnoHold, ghnoNum);
                    else
                        NumObjAssign(&ghnoNum, hnoHold);

                    /* Do the current or last operation.                  */
                    DoOperation (nOpCode, &ghnoNum, ghnoLastNum);
                    NumObjAssign(&ghnoLastNum, ghnoNum );

                    /* Check for errors.  If this wasn't done, DisplayNum */
                    /* would immediately overwrite any error message.     */
                    if (!bError)
                        DisplayNum ();

                    /* No longer the first EQU.                           */
                    bNoPrevEqu=FALSE;
                }
                else if (!bError)
                    DisplayNum();

                if (nPrecNum==0 || nCalc==1)
                    break;

                nOpCode=nPrecOp[--nPrecNum];
                if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                    NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                else
                    NumObjAssign(&ghnoLastNum, HNO_ZERO);
                bNoPrevEqu=TRUE;
            } while (nPrecNum >= 0);

            bChangeOp=FALSE;
            break;


        case IDC_OPENP:
        case IDC_CLOSEP:
            nx=0;
            if (wParam==IDC_OPENP)
                nx=1;

            // -IF- the Paren holding array is full and we try to add a paren
            // -OR- the paren holding array is empty and we try to remove a
            //      paren
            // -OR- the the precidence holding array is full
            if ((nParNum >= 25 && nx) || (!nParNum && !nx)
                || ( (nPrecNum >= 25 && nPrecOp[nPrecNum-1]!=0) ) )
            {
                MessageBeep(0);
                break;
            }

            if (nx)
            {
                /* Open level of parentheses, save number and operation.   */
                NumObjAssign( &ghnoParNum[nParNum], ghnoLastNum);
                nOp[nParNum++]=nOpCode;

                /* save a special marker on the precedence array */
                nPrecOp[nPrecNum++]=0 ;

                NumObjAssign( &ghnoLastNum, HNO_ZERO );
                nTempCom=0;
                nOpCode=IDC_ADD;
            }
            else
            {
                /* Get the operation and number and return result.         */
                DoOperation (nOpCode, &ghnoNum, ghnoLastNum);

                /* now process the precedence stack till we get to an
                    opcode which is zero. */

                while (nOpCode = nPrecOp[--nPrecNum])
                {
                    if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                        NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                    else
                        NumObjAssign(&ghnoLastNum, HNO_ZERO);

                    DoOperation (nOpCode, &ghnoNum, ghnoLastNum);
                }

                /* now get back the operation and opcode at the begining
                    of this paranthesis pair */

                nParNum -= 1;
                NumObjAssign( &ghnoLastNum, ghnoParNum[nParNum] );
                nOpCode=nOp[nParNum];

                /* if nOpCode is a valid operator then set bChangeOp to
                    be true else set it false */

                if  (nOpCode)
                    bChangeOp=TRUE;
                else
                    bChangeOp=FALSE ;
            }

            /* Set the "(=xx" indicator.                     */
            lstrcpy(szJunk, TEXT("(="));
            lstrcat(szJunk, UToDecT(nParNum, szTemp));
            SetDlgItemText(g_hwndDlg, IDC_PARTEXT,
                           (nParNum) ? (szJunk) : (szBlank));

            if (bError)
                break;

            if (nx)
            {
                /* Build a display string of nParNum "("'s.  */
                for (nx=0; nx < nParNum; nx++)
                    szJunk[nx]=TEXT('(');

                szJunk[nx]=0; /* Null-terminate.  */
                SetDisplayText(g_hwndDlg, szJunk);
                bChangeOp=FALSE;
            }
            else
                DisplayNum ();
            break;

        case IDM_QWORD:
        case IDM_DWORD:
        case IDM_WORD:
        case IDM_BYTE:
        case IDM_DEG:
        case IDM_RAD:
        case IDM_GRAD:

            if (!F_INTMATH())
            {
                // in decimal mode, these buttons simply set a flag which is
                // passed to the ratpak to handle angle conversions

                if (xwParam(IDM_DEG, IDM_GRAD))
                {
                    nDecMode = (ANGLE_TYPE)(wParam - IDM_DEG);

                    CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg), 1),
                                       IDM_DEG, IDM_GRAD, IDM_DEG+nDecMode,
                                       MF_BYCOMMAND);
                
                    CheckRadioButton(g_hwndDlg, IDC_DEG, IDC_GRAD, 
                                     IDC_DEG+nDecMode);
                }
            }
            else
            {
                if (xwParam(IDM_DEG, IDM_GRAD))
                {
                    // if in hex mode, but we got a decimal key press this
                    // likely is the accelorator.  map this to the correct key

                    wParam=IDM_DWORD+(wParam-IDM_DEG);
                }
                
                if ( gbRecord )
                {
                    CIO_vConvertToNumObj(&ghnoNum, &gcio);
                    gbRecord = FALSE;
                }

                // Compat. mode BaseX: Qword, Dword, Word, Byte
                nHexMode = (int)(wParam - IDM_QWORD);
                switch (nHexMode)
                {
                    case 0: dwWordBitWidth = 64; break;
                    case 1: dwWordBitWidth = 32; break;
                    case 2: dwWordBitWidth = 16; break;
                    case 3: dwWordBitWidth =  8; break;
                    default:
                        ASSERT( 0 );    // Invalid Word Size
                        break;
                }

                // different wordsize means the new wordsize determines
                // the precision

                BaseOrPrecisionChanged();

                CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg), 1),
                                   IDM_QWORD, IDM_BYTE, IDM_QWORD+nHexMode,
                                   MF_BYCOMMAND);

                CheckRadioButton(g_hwndDlg, IDC_QWORD, IDC_BYTE, 
                                 IDC_QWORD+nHexMode);
               
            }


            // REARCHITECT: the call to display number is what actually does the
            // chop. it would make more sense to do the chop here when the
            // wordsize changes. the chop must be done when a different
            // wordsize is selected AND when the base is changed to non-decimal
            DisplayNum();
            break;

        case IDC_SIGN:
            // Change the sign.
            if (gbRecord)
                CIO_vToggleSign(&gcio);
            else {
                NumObjNegate( &ghnoNum );
            }

            DisplayNum();
            break;

        case IDC_RECALL:
            /* Recall immediate memory value.                             */
            NumObjAssign( &ghnoNum, ghnoMem );

            DisplayNum ();
            break;

        case IDC_MPLUS:
            /* MPLUS adds ghnoNum to immediate memory and kills the "mem"   */
            /* indicator if the result is zero.                           */
            addrat( &ghnoMem, ghnoNum);
            SetDlgItemText(g_hwndDlg,IDC_MEMTEXT,
                           !NumObjIsZero(ghnoMem) ? (TEXT(" M")):(szBlank));
            break;

        case IDC_STORE:
        case IDC_MCLEAR:
            if (wParam==IDC_STORE)
            {
                NumObjAssign( &ghnoMem, ghnoNum );
            }
            else
            {
                NumObjAssign( &ghnoMem, HNO_ZERO );
            }
            SetDlgItemText(g_hwndDlg,IDC_MEMTEXT,
                           !NumObjIsZero(ghnoMem) ? (TEXT(" M")):(szBlank));
            break;

        case IDC_PI:
            if (!F_INTMATH())
            {
                /* Return PI if bInv==FALSE, or 2PI if bInv==TRUE.          */
                if (bInv)
                    NumObjAssign( &ghnoNum, HNO_2PI );
                else
                    NumObjAssign( &ghnoNum, HNO_PI );

                DisplayNum();
                SetBox(IDC_INV, bInv=FALSE);
            }
            else
                MessageBeep(0);
            break;

        case IDC_FE:
            // Toggle exponential notation display.
            nFE = NUMOBJ_FMT(!(int)nFE);
            DisplayNum();
            break;

        case IDC_EXP:
            if (gbRecord && !F_INTMATH())
                if (CIO_bExponent(&gcio))
                {
                    DisplayNum();
                    break;
                }
            MessageBeep(0);
            break;

        case IDC_PNT:
            if (gbRecord && !F_INTMATH()) {
                if (CIO_bAddDecimalPt(&gcio)) {

                    DisplayNum();
                    break;
                }
            }
            MessageBeep(0);
            break;

        case IDC_INV:
            SetBox((int)wParam, bInv=!bInv);
            break;

        case IDC_HYP:
            SetBox((int)wParam, bHyp=!bHyp);
            break;
    }

    SetWaitCursor(FALSE);
}


// change the display area from a static text to an editbox, which has the focus can make
// Magnifer (Accessibility tool) work
BOOL SetDisplayText(HWND hDlg, LPCTSTR szText)
{
    HWND    hDispEdit = GetDlgItem(hDlg, IDC_DISPLAY);
    int     nLen = lstrlen(szText);

    SetWindowText(hDispEdit, szText);
    SetFocus(hDispEdit);
    
    // make sure the number just typed is shown at the center of Magnifier
    SendMessage(hDispEdit, EM_SETSEL, nLen, nLen);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\resource.h ===
// Resources for Calculator

// Dialog IDs:
#define IDD_SCIENTIFIC    101
#define IDD_STANDARD      102
#define IDD_SB            103
#define IDD_TIMEOUT       104

// accelerator table:
#define IDA_ACCELTABLE    105

// Menu item constants:
#define IDM_CALCMENU      106
#define IDM_DECCALCMENU   107     // alternate menu
#define IDM_HEXCALCMENU   108     // alternate menu
#define IDM_HELPPOPUP     109     // "What's this?" menu


#define IDM_FIRSTMENU     IDM_COPY
#define IDM_COPY          300   // menu command IDs must be in one consecutive block
#define IDM_PASTE         301
#define IDM_ABOUT         302
#define IDM_USE_SEPARATOR 303
#define IDM_SC            304
#define IDM_SSC           305
#define IDM_HEX           306
#define IDM_DEC           307
#define IDM_OCT           308
#define IDM_BIN           309
#define IDM_QWORD         310 
#define IDM_DWORD         311
#define IDM_WORD          312
#define IDM_BYTE          313
#define IDM_DEG           314
#define IDM_RAD           315
#define IDM_GRAD          316
#define IDM_HELPTOPICS    317
#define IDM_LASTMENU      IDM_HELPTOPICS


#define IDC_HEX           IDM_HEX
#define IDC_DEC           IDM_DEC
#define IDC_OCT           IDM_OCT
#define IDC_BIN           IDM_BIN

#define IDC_DEG           IDM_DEG
#define IDC_RAD           IDM_RAD
#define IDC_GRAD          IDM_GRAD

#define IDC_QWORD         IDM_QWORD
#define IDC_DWORD         IDM_DWORD
#define IDC_WORD          IDM_WORD
#define IDC_BYTE          IDM_BYTE


// Key IDs:
// These id's must be consecutive from IDC_FIRSTCONTROL to IDC_LASTCONTROL. 
// The actual values don't matter but the order and sequence are very important.
// Also, the order of the controls must match the order of the control names
// in the string table.
#define IDC_FIRSTCONTROL IDC_SIGN
#define IDC_SIGN         80
#define IDC_CLEAR        81
#define IDC_CENTR        82
#define IDC_BACK         83
#define IDC_STAT         84
#define IDC_PNT          85

#define IDC_AND          86     // Binary operators must be between IDC_AND and IDC_PWR
#define IDC_OR           87
#define IDC_XOR          88
#define IDC_LSHF         89
#define IDC_DIV          90
#define IDC_MUL          91
#define IDC_ADD          92
#define IDC_SUB          93
#define IDC_MOD          94
#define IDC_PWR          95

#define IDC_CHOP         96     // Unary operators must be between IDC_CHOP and IDC_EQU
#define IDC_COM          97
#define IDC_SIN          98
#define IDC_COS          99
#define IDC_TAN         100
#define IDC_LN          101
#define IDC_LOG         102
#define IDC_SQRT        103
#define IDC_SQR         104
#define IDC_CUB         105
#define IDC_FAC         106
#define IDC_REC         107
#define IDC_DMS         108
#define IDC_PERCENT     109
#define IDC_FE          110
#define IDC_PI          111
#define IDC_EQU         112

#define IDC_MCLEAR      113
#define IDC_RECALL      114
#define IDC_STORE       115
#define IDC_MPLUS       116

#define IDC_EXP         117

#define IDC_AVE         118
#define IDC_B_SUM       119
#define IDC_DEV         120
#define IDC_DATA        121

#define IDC_OPENP       122
#define IDC_CLOSEP      123

#define IDC_0           124    // The controls for 0 through F must be consecutive and in order
#define IDC_1           125
#define IDC_2           126
#define IDC_3           127
#define IDC_4           128
#define IDC_5           129
#define IDC_6           130
#define IDC_7           131
#define IDC_8           132
#define IDC_9           133
#define IDC_A           134
#define IDC_B           135
#define IDC_C           136
#define IDC_D           137
#define IDC_E           138
#define IDC_F           139     // this is last control ID which must match the string table

#define IDC_INV         140
#define IDC_HYP         141

#define IDC_LASTCONTROL IDC_HYP

// Edit control ID's for the various controls
#define IDC_MEMTEXT      401
#define IDC_PARTEXT      402
#define IDC_DISPLAY      403

// statbox control IDs:
#define IDC_CD           404
#define IDC_CAD          405
#define ENDBOX           406
#define IDC_STATLIST     407
#define IDC_NUMTEXT      408
#define IDC_NTEXT        409
#define IDC_LOAD         410
#define IDC_FOCUS        411

#define IDC_SIZERCONTROL 1000

#define CW_USEDEFAULT_X  0x8000
#define IDC_STATIC       -1

// These are defs for the stringtable.  Values are made to be sequential for each section.
// All strings must be in sequential order from 0 to CSTRINGS
#define IDS_FIRSTKEY    0
#define IDS_DECIMAL     5
#define IDS_RADIX       60
#define IDS_HEX_MODES   64
#define IDS_DEC_MODES   68
#define IDS_ERRORS      71 
#define IDS_OUTOFMEM    77
#define IDS_TIMEOUT     78
#define IDS_HELPFILE    79 
#define IDS_NOPASTE     80 
#define IDS_STATMEM     81 
#define IDS_CHMHELPFILE 82 
#define IDS_CALC        83
#define IDS_NOMEM       84
#define CSTRINGS     IDS_NOMEM  // Count of Strings.  If you add strings update this value.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scicalc.h ===
/****************************Module*Header***********************************\
* Module Name: SCICALC.H
*
* Module Descripton: Main header file
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#define CALC_COMPILE

/* To keep a buncha junk outa compiles */
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NODRAWFRAME
#define NOKEYSTATES
#define OEMRESOURCE
#define NOATOM
#define NOMETAFILE
#define NOOPENFILE
#define NOSOUND
#define NOWH
#define NOCOMM
#define NOKANJI

#include <windows.h>
#include <windowsx.h>
#include "scimath.h"
#include "resource.h"
#include "wassert.h"    // our own simple little assert
#include <htmlhelp.h>

#define CSTRMAX        256   /* Maximum length of any one string.         */
#ifdef DEBUG
#define CCHSTRINGSMAX  3
#else
#define CCHSTRINGSMAX  1024  /* Initial bytes to allocate for strings.    */
#endif

#define CMS_CALC_TIMEOUT     (10 * 1000) // initial timeout == 10 secs
#define CMS_MAX_TIMEOUT      (40 * 1000) // Max timeout == 40 secs

#define xwParam(x,y) ((wParam >=x) && (wParam <=y))

#define RSHF        7

/* Error values.                                                          */
#define SCERR_DIVIDEZERO    0
#define SCERR_DOMAIN        1
#define SCERR_UNDEFINED     2
#define SCERR_POS_INFINITY  3
#define SCERR_NEG_INFINITY  4
#define SCERR_ABORTED       5


/* F_INTMATH()  returns TRUE if math should be intiger mode               */
//
// Do int math if we are not in base ten
//
#define F_INTMATH() (nRadix != 10)

////////////////////////////////////////////////////////////////////////////
//
// Function prototypes.
//
////////////////////////////////////////////////////////////////////////////

/* Exports.                                                               */
LRESULT APIENTRY CalcWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY StatBoxProc(HWND, UINT, WPARAM, LPARAM);

/* Functions called from several modules.  Must be FAR.                   */
VOID    APIENTRY DisplayError (INT);
VOID    APIENTRY EnableToggles(BOOL bEnable);
VOID    APIENTRY InitSciCalc (BOOL);
VOID    APIENTRY MenuFunctions(DWORD);
VOID    APIENTRY SciCalcFunctions (PHNUMOBJ phnoNum, DWORD wOp);
VOID    APIENTRY SetStat (BOOL);
VOID    APIENTRY StatFunctions (WPARAM);

VOID   DisplayNum (VOID);

/* Internal near calls.                                                   */
void        DoOperation (INT   nOperation, HNUMOBJ *phnoNum, HNUMOBJ hnoX);

VOID   NEAR ProcessCommands(WPARAM);
VOID   NEAR SetBox (int, BOOL);
VOID   NEAR SetRadix (DWORD);
LONG   NEAR StatAlloc (WORD, DWORD);
VOID   NEAR StatError (VOID);

void   SwitchModes(DWORD wRadix, int nDecMode, int nHexMode);

void RecalcNumObjConstants(void);
BOOL SetWaitCursor( BOOL fOn );

void KillTimeCalc( void );
void TimeCalc( BOOL fStart );
BOOL SetDisplayText(HWND, LPCTSTR);

// these functions are from SciKeys.c and are used to access data stored 
// in the key array
COLORREF   GetKeyColor( int iID );
ULONG_PTR  GetHelpID( int iID );

#define  INDEXFROMID( x )    (x-IDC_FIRSTCONTROL)


////////////////////////////////////////////////////////////////////////////
//
// Global Variables
//
////////////////////////////////////////////////////////////////////////////

extern HWND         g_hwndDlg;
extern HINSTANCE    hInst;
extern ANGLE_TYPE   nDecMode;

extern long nRadix;
extern long nPrecision;
extern long dwWordBitWidth;

extern BOOL     bInv;
extern BOOL     bHyp;

extern int      nCalc;
extern int      nHexMode;

extern HNUMOBJ  g_ahnoChopNumbers[];

extern BOOL     bFarEast;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scimenu.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scimenu.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    MenuFunctions--handles menu options.                            ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    DisplayNum                                                      ***/
/***                                                                    ***/
/*** Last modification Thu  06-Dec-1989                                 ***/
/*** (-by- Amit Chatterjee [amitc])                                     ***/
/***                                                                    ***/
/*** Modified the 'PASTE' menu to check for unary minus, e, e+ & e-     ***/
/*** in DEC mode.                                                       ***/
/***                                                                    ***/
/*** Also modified the COPY code to not copy the last '.' in the display***/
/*** if a decimal point has not been hit.                               ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"
#include <shellapi.h>
#include <ctype.h>

#define CHARSCAN    66

extern HWND        hEdit, hStatBox;
extern TCHAR       szAppName[10], szDec[5], gszSep[5], *rgpsz[CSTRINGS];
extern LPTSTR      gpszNum;
extern BOOL        bError;
extern INT         nLayout;

extern HMENU       g_hDecMenu;
extern HMENU       g_hHexMenu;

extern CALCINPUTOBJ gcio;
extern BOOL         gbRecord;
extern BOOL         gbUseSep;

/* Menu handling routine for COPY, PASTE, ABOUT, and HELP.                */
VOID NEAR PASCAL MemErrorMessage(VOID)
{
    MessageBeep(0);
    MessageBox(g_hwndDlg,rgpsz[IDS_STATMEM],NULL,MB_OK|MB_ICONHAND);
}

VOID  APIENTRY MenuFunctions(DWORD nFunc)
{
    INT              nx;
    static const int rgbMap[CHARSCAN * 2]=
    {
        TEXT('0'),IDC_0,    TEXT('1'),IDC_1,    
        TEXT('2'),IDC_2,    TEXT('3'),IDC_3,

        TEXT('4'),IDC_4,    TEXT('5'),IDC_5,
        TEXT('6'),IDC_6,    TEXT('7'),IDC_7,

        TEXT('8'),IDC_8,    TEXT('9'),IDC_9,
        TEXT('A'),IDC_A,    TEXT('B'),IDC_B,

        TEXT('C'),IDC_C,    TEXT('D'),IDC_D,
        TEXT('E'),IDC_E,    TEXT('F'),IDC_F,

        TEXT('!'),IDC_FAC,  TEXT('S'),IDC_SIN,
        TEXT('O'),IDC_COS,  TEXT('T'),IDC_TAN,

        TEXT('R'),IDC_REC,  TEXT('Y'),IDC_PWR,
        TEXT('#'),IDC_CUB,  TEXT('@'),IDC_SQR,
                        
        TEXT('M'),IDM_DEG,  TEXT('N'),IDC_LN,
        TEXT('L'),IDC_LOG,  TEXT('V'),IDC_FE,

        TEXT('X'),IDC_EXP,  TEXT('I'),IDC_INV,
        TEXT('H'),IDC_HYP,  TEXT('P'),IDC_PI,

        TEXT('/'),IDC_DIV,  TEXT('*'),IDC_MUL,
        TEXT('%'),IDC_MOD,  TEXT('-'),IDC_SUB,

        TEXT('='),IDC_EQU,  TEXT('+'),IDC_ADD,
        TEXT('&'),IDC_AND,  TEXT('|'),IDC_OR,

        TEXT('^'),IDC_XOR,  TEXT('~'),IDC_COM,
        TEXT(';'),IDC_CHOP, TEXT('<'),IDC_LSHF,


        TEXT('('),IDC_OPENP,TEXT(')'),IDC_CLOSEP,

        TEXT('\\'),    IDC_DATA,
        TEXT('Q'),     IDC_CLEAR,
        TEXT('Q')+128, IDC_CLEAR,   // ":Q"=="Q"=>CLEAR
        TEXT('S')+128, IDC_STAT,    // ":S"=>CTRL-S
        TEXT('M')+128, IDC_STORE,   // ":M"=>CTRL-M
        TEXT('P')+128, IDC_MPLUS,   // ":P"=>CTRL-P
        TEXT('C')+128, IDC_MCLEAR,  // ":C"=>CTRL-C
        TEXT('R')+128, IDC_RECALL,  // ":R"=>CTRL-R
        TEXT('A')+128, IDC_AVE,     // ":A"=>CTRL-A
        TEXT('T')+128, IDC_B_SUM,   // ":T"=>CTRL-T
        TEXT('D')+128, IDC_DEV,     // ":D"=>CTRL-D
        TEXT('2')+128, IDC_DWORD,   // ":2"=>F2     IDC_DWORD
        TEXT('3')+128, IDC_RAD,     // ":3"=>F3     IDC_WORD
        TEXT('4')+128, IDC_GRAD,    // ":4"=>F4     IDC_BYTE
        TEXT('5')+128, IDC_HEX,     // ":5"=>F5
        TEXT('6')+128, IDC_DEC,     // ":6"=>F6
        TEXT('7')+128, IDC_OCT,     // ":7"=>F7
        TEXT('8')+128, IDC_BIN,     // ":8"=>F8
        TEXT('9')+128, IDC_SIGN,    // ":9"=>F9
        TEXT('9')+3+128, IDC_QWORD  // ":9"+2=>F12 (64 bit)
   };

    switch (nFunc)
    {
        case IDM_COPY:
        {
            TCHAR  szJunk[256];

            // Copy the string into a work buffer.  It may be modified.
            if (gbRecord)
                CIO_vConvertToString(&gpszNum, &gcio, nRadix);

            lstrcpy(szJunk, gpszNum);

            // Strip a trailing decimal point if it wasn't explicitly entered.
            if (!gbRecord || !CIO_bDecimalPt(&gcio))
            {
                nx = lstrlen(szJunk);
                if (szJunk[nx - 1] == szDec[0])
                    szJunk[nx - 1] = 0;
            }

            /* Copy text to the clipboard through the hidden edit control.*/
            SetWindowText(hEdit, szJunk);
            SendMessage(hEdit, EM_SETSEL, 0, -1);   // select all text
            SendMessage(hEdit, WM_CUT, 0, 0L);
            break;
        }

        case IDM_PASTE:
        {
            HANDLE  hClipData;
            char *  lpClipData;
            char *  lpEndOfBuffer;  // used to ensure we don't GPF even if the clipboard data isn't NULL terminated
            WORD    b, bLast;
            INT     nControl;
            BOOL    bNeedIDC_SIGN = FALSE;

            /* Get a handle on the clipboard data and paste by sending the*/
            /* contents one character at a time like it was typed.        */
            if (!OpenClipboard(g_hwndDlg))
            {
                MessageBox(g_hwndDlg, rgpsz[IDS_NOPASTE], rgpsz[IDS_CALC],
                           MB_OK | MB_ICONEXCLAMATION);
                break;
            }

            hClipData=GetClipboardData(CF_TEXT);
            if (hClipData)
            {
                lpClipData=(char *)GlobalLock(hClipData);
                if (lpClipData)
                {
                    lpEndOfBuffer = lpClipData + GlobalSize(hClipData);
                    bLast=0;

                    /* Continue this as long as no error occurs.  If one      */
                    /* does then it's useless to continue pasting.            */
                    while (!bError && lpClipData < lpEndOfBuffer)
                    {
                        // we know that lpClipData points to a NULL terminated ansi 
                        // string because this is the format we requested the data in.
                        // As a result we call CharNextA.

                        b = *lpClipData;
                        lpClipData = CharNextA( lpClipData );

                        /* Skip spaces and LF and CR.                             */
                        if (b==32 || b==10 || b==13 || b==gszSep[0])
                            continue;

                        /* We're done if we get to a NULL character */
                        if ( b==0 )
                            break;

                        if (b == szDec[0])
                        {
                            bLast = b;
                            b = IDC_PNT;
                            goto MappingDone;
                        }

/*-----------------------------------------------------------------------------;
; Now we will check for certain special cases. These are:                      ;
;                                                                              ;
;       (1) Unary Minus. If bLast is still 0 and b is '-' we will force b to   ;
;         be the code for 'SIGN'.                                              ;
;       (2) If b is 'x' we will make it the code for EXP                       ;
;       (3) if bLast is 'x' and b is '+' we will ignore b, as '+' is the dflt. ;
;       (4) if bLast is 'x' and b is '-' we will force b to be SIGN.           ;
;                                                                              ;
;  In case (3) we will go back to the top of the loop else we will jmp off     ;
;  to the sendmessage point, bypassing the table lookup.                       ;
;-----------------------------------------------------------------------------*/

                        /* check for unary minuses */
                        if  (!bLast && b == TEXT('-'))
                        {
                            /* Doesn't work.
                            bLast = b ;
                            b = IDC_SIGN ;
                            goto MappingDone ;
                            */
                            bNeedIDC_SIGN = TRUE ;
                            continue ;
                        }

                        /* check for 'x' */
                        if  ((b == TEXT('x') || b == TEXT('e')) && nRadix == 10)
                        {
                            bLast = TEXT('x') ;
                            b = IDC_EXP ;
                            goto MappingDone ;
                        }

                        /* if the last character was a 'x' & this is '+' - ignore */
                        if  (bLast==TEXT('x') && b ==TEXT('+') && nRadix == 10)
                            continue ;

                        /* if the last character was a 'x' & this is '-' - change
                        it to be the code for SIGN */
                        if  (bLast==TEXT('x') && b==TEXT('-') && nRadix == 10)
                        {
                            bLast = b ;
                            b = IDC_SIGN ;
                            goto MappingDone ;
                        }

/* -by- AmitC   */
/*--------------------------------------------------------------------------*/


                        /* Check for control character.                           */
                        if (bLast==TEXT(':'))
                            nControl=128;
                        else
                            nControl=0;

                        bLast=b;
                        if (b==TEXT(':'))
                            continue;

                        b=toupper(b)+nControl;

                        nx=0;
                        while (b!=rgbMap[nx*2] && nx < CHARSCAN)
                            nx++;

                        if (nx==CHARSCAN)
                            break;

                        b=(WORD)rgbMap[(nx*2)+1];

                        if (nRadix != 10)
                        {
                            switch(b)
                            {
                                case IDC_DEG:
                                case IDC_RAD:
                                case IDC_GRAD:
                                    b=IDC_DWORD+(b-IDC_DEG);
                                break;
                            }
                        }
                                
                        // REVIEW NOTE: 
                        //   Conversion of IDC_MOD to IDC_PERCENT done in WM_COMMAND
                        //   processing so that keyboard accelerator and paste are
                        //   handled in the same place.  The old conversion was broken
                        //   anyway and actually happened in

        MappingDone:
                        /* Send the message to the window.                        */
                        SendMessage(g_hwndDlg, WM_COMMAND, GET_WM_COMMAND_MPS(b, 0, 1));
                        /* Note that we may need to apply the "+/-" key (IDC_SIGN)
                           now.  (If it had been applied earlier, it would have
                           been ignored.)  Note further that it can't be applied if we
                           have seen only the "-0" of something like "-0.1". */
                        if(bNeedIDC_SIGN && (IDC_0 != b))
                            {
                            SendMessage(g_hwndDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDC_SIGN, 0, 1));
                            bNeedIDC_SIGN = FALSE;
                            }
                    }
                    GlobalUnlock(hClipData);
                }    
            }    
            CloseClipboard();
            break;
        }

        case IDM_ABOUT:
            /* Start the About Box.                                       */
            if(ShellAbout(g_hwndDlg, rgpsz[IDS_CALC], NULL, LoadIcon(hInst, (LPTSTR)TEXT("SC"))) == -1)
                MemErrorMessage();

            break;

        case IDM_SC:
        case IDM_SSC:
        {
            INT     nTemp;
            TCHAR   szWinIni[2];

            nTemp = (INT) nFunc - IDM_SC;
            if (nCalc != nTemp)
            {
                szWinIni[0] = TEXT('0') + nTemp;
                szWinIni[1]=0;
                WriteProfileString(szAppName, TEXT("layout"), szWinIni);

                if (hStatBox && !nCalc)
                    SetStat(FALSE);

                nCalc = nTemp;
                InitSciCalc(TRUE);
            }
            break;
        }

        case IDM_USE_SEPARATOR:
        {
            gbUseSep = !gbUseSep;

            CheckMenuItem(g_hDecMenu, IDM_USE_SEPARATOR,
                          MF_BYCOMMAND|(gbUseSep ? MF_CHECKED : MF_UNCHECKED));

            if (g_hHexMenu)
            {
                CheckMenuItem(g_hHexMenu, IDM_USE_SEPARATOR,
                              MF_BYCOMMAND | \
                              (gbUseSep ? MF_CHECKED:MF_UNCHECKED));
            }

            WriteProfileString(szAppName,TEXT("UseSep"),
                               (gbUseSep ? TEXT("1") : TEXT("0")));

            break;
        }

        case IDM_HELPTOPICS:
            HtmlHelp(GetDesktopWindow(), rgpsz[IDS_CHMHELPFILE], HH_DISPLAY_TOPIC, 0L);
            break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\sciproc.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** sciproc.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    CalcWndProc--Main window procedure.                             ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SetRadix,                                                       ***/
/***    ProcessCommands.                                                ***/
/***                                                                    ***/
/*** Last modification Fri  08-Dec-1989                                 ***/
/*** -by- Amit Chatterjee. [amitc]                                      ***/
/*** Last modification July-21-1994                                     ***/
/*** -by- Arthur Bierer [t-arthb] or abierer@ucsd.edu                   ***/
/***                                                                    ***/
/*** Modified WM_PAINT processing to display ghnoLastNum rather than    ***/
/*** ghnoNum if the last key hit was an operator.                       ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "commctrl.h"

extern HWND     hStatBox;
extern HBRUSH   hBrushBk;
extern BOOL     bFocus, bError;
extern TCHAR    szDec[5], *rgpsz[CSTRINGS];
extern HNUMOBJ  ghnoNum, ghnoLastNum;
extern INT      nTempCom ;
extern INT      gnPendingError ;
extern BOOL     gbRecord;

WNDPROC fpOrgDispEditProc;
LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL FireUpPopupMenu( HWND hwnd, HINSTANCE hInstanceWin, LPARAM lParam)
{
    HMENU hmenu;

    if ((hmenu = LoadMenu(hInstanceWin, MAKEINTRESOURCE(IDM_HELPPOPUP))))
    {
        int cmd = TrackPopupMenuEx(GetSubMenu(hmenu, 0),
            TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
            LOWORD(lParam), HIWORD(lParam), hwnd, NULL);
        DestroyMenu(hmenu);
        return ( cmd == HELP_CONTEXTPOPUP ) ? TRUE : FALSE;

    }
    else
        return FALSE;
}

extern BOOL IsValidID( int iID );

LRESULT APIENTRY CalcWndProc (
HWND           hWnd,
UINT           iMessage,
WPARAM         wParam,
LPARAM         lParam)
{
    INT         nID, nTemp;       /* Return value from GetKey & temp.  */
    HANDLE      hTempBrush; // a brush to play with in WM_CTLCOLORSTATIC

    switch (iMessage)
    {
        case WM_INITMENUPOPUP:
            /* Gray out the PASTE option if CF_TEXT is not available.     */
            /* nTemp is used here so we only call EnableMenuItem once.    */
            if (!IsClipboardFormatAvailable(CF_TEXT))
                nTemp=MF_GRAYED | MF_DISABLED;
            else
                nTemp=MF_ENABLED;

            EnableMenuItem(GetMenu(hWnd),IDM_PASTE, nTemp);
            break;

        case WM_CONTEXTMENU:
            // If the user clicked on the dialog face and not one of the
            // buttons then do nothing.  If the id of the button is IDC_STATIC
            // then do nothing. 

            if ( (HWND)wParam == g_hwndDlg )
            {
                // check for clicks on disabled buttons.  These aren't seen 
                // by WindowFromPoint but are seen by ChildWindowFromPoint.
                // As a result, the value of wParam will be g_hwndDlg 
                // if the WM_RBUTTONUP event occured on a disabled button.

                POINT pt;
                HWND  hwnd;

                // convert from short values to long values
                pt.x = MAKEPOINTS(lParam).x;   
                pt.y = MAKEPOINTS(lParam).y;

                // then convert to client coordinates
                ScreenToClient( g_hwndDlg, &pt );  

                hwnd = ChildWindowFromPoint( g_hwndDlg, pt );

                if ( !hwnd || (hwnd == g_hwndDlg) || 
                     (IDC_STATIC == GetDlgCtrlID( hwnd )))
                {
                    return (DefWindowProc(hWnd, iMessage, wParam, lParam));
                }

                wParam = (WPARAM)hwnd;
            }

            if ( FireUpPopupMenu( g_hwndDlg, hInst, lParam ) )
            {
                nID = GetDlgCtrlID( (HWND)wParam );

                WinHelp((HWND) wParam, rgpsz[IDS_HELPFILE], HELP_CONTEXTPOPUP,
                        GetHelpID( nID ));
            }
            break;

        case WM_HELP:
            HtmlHelp(GetDesktopWindow(), rgpsz[IDS_CHMHELPFILE], HH_DISPLAY_TOPIC, 0L);
            return 0;

        case WM_COMMAND: /* Interpret all buttons on calculator.          */
        {
            WORD wNotifyCode = HIWORD(wParam); // notification code
            WORD wID = LOWORD(wParam);         // item, control, or accelerator identifier

            // the accelerator table feeds us IDC_MOD in response to the 
            // "%" key.  This same accelerator is used for the percent function
            // in Standard view so translate here.

            if ( (wID == IDC_MOD) && (nCalc == 1) )
                wID = IDC_PERCENT;

            // when we get an accelerator keystroke we fake a button press to provide feedback
            if ( wNotifyCode == 1 )
            {
                // For an accelerator the hwnd is not passed in the lParam so ask the dialog
                HWND hwndCtl = GetDlgItem( g_hwndDlg, wID );
                SendMessage( hwndCtl, BM_SETSTATE, 1, 0 );  // push the button down
                Sleep( 20 );                                // wait a bit
                SendMessage( hwndCtl, BM_SETSTATE, 0, 0 );  // push the button up
            }

            // we turn on notify for the text controls to automate the handling of context
            // help but we don't care about any commands we recieve from these controls. As
            // a result, only process commands that are not from a text control.
            if ( (wID != IDC_DISPLAY) && (wID != IDC_MEMTEXT) && (wID != IDC_PARTEXT) )
                ProcessCommands(wID);
            break;
        }

        case WM_CLOSE:
            if ( hStatBox )
            {
                SendMessage(hStatBox, WM_CLOSE, 0, 0L) ;
                hStatBox = NULL;
            }

            DestroyWindow(g_hwndDlg);
            KillTimeCalc();
            WinHelp(g_hwndDlg, rgpsz[IDS_HELPFILE], HELP_QUIT, 0L);
            PostQuitMessage(0);
            break;

        case WM_SYSCOMMAND:
            if ( (wParam & 0xFFF0) == SC_CLOSE )
            {
                PostQuitMessage(0);
            }
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));

        case WM_NOTIFY:
        {
            NMCUSTOMDRAW* nm = (NMCUSTOMDRAW*)lParam;
            int iBtnID = (int)nm->hdr.idFrom;
            if (nm->hdr.code == NM_CUSTOMDRAW && IsValidID(iBtnID))
            {
                if (nm->dwDrawStage == CDDS_PREERASE)
                {
                    return CDRF_NOTIFYITEMDRAW;
                }
                else if (nm->dwDrawStage == CDDS_PREPAINT)
                {
                    int bkMode = SetBkMode(nm->hdc, TRANSPARENT);
                    LPCTSTR psz = rgpsz[INDEXFROMID(iBtnID)];
                    SetTextColor( nm->hdc, (nm->uItemState & CDIS_DISABLED)?GetSysColor(COLOR_GRAYTEXT):GetKeyColor( iBtnID ) );
                    DrawText( nm->hdc, psz, -1, &nm->rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
                    SetBkMode(nm->hdc, bkMode);
                    return CDRF_SKIPDEFAULT;
                }
            }
            break;
        }

        case WM_CTLCOLORSTATIC:
            // get the Control's id from its handle in lParam
            if ( IDC_DISPLAY == GetWindowID( (HWND) lParam) )
            {
                // we set this window to a white backround
                hTempBrush = GetSysColorBrush( COLOR_WINDOW );
                SetBkColor( (HDC) wParam, GetSysColor( COLOR_WINDOW ) );
                SetTextColor( (HDC) wParam, GetSysColor( COLOR_WINDOWTEXT ) );

                return (LRESULT) hTempBrush;
            }
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));

        case WM_SETTINGCHANGE:
            if (lParam!=0)
            {
                // we only care about changes to color and internation settings, ignore all others
                if (lstrcmp((LPCTSTR)lParam, TEXT("colors")) &&
                        lstrcmp((LPCTSTR)lParam, TEXT("intl")))
                    break;
            }

            // Always call if lParam==0.  This is simply for safety and isn't strictly needed
            InitSciCalc (FALSE);
            break;

        case WM_SIZE:
            {
                HWND hwndSizer;

                nTemp=SW_SHOW;
                if (wParam==SIZEICONIC)
                    nTemp=SW_HIDE;

                if (hStatBox!=0 && (wParam==SIZEICONIC || wParam==SIZENORMAL))
                    ShowWindow(hStatBox, nTemp);

                // A special control has been added to both dialogs with an ID of
                // IDC_SIZERCONTROL.  This control is possitioned such that the bottom of
                // the control determines the height of the dialog.  If a really large menu
                // font is selected then the menu might wrap to two lines, which exposes a
                // bug in Windows that causes the client area to be too small.  By checking
                // that IDC_SIZERCONTROL is fully visible we can compensate for this bug.
                hwndSizer = GetDlgItem( g_hwndDlg, IDC_SIZERCONTROL );
                if ( hwndSizer )
                {
                    RECT rc;
                    int iDelta;
                    GetClientRect( hwndSizer, &rc );
                    MapWindowPoints( hwndSizer, g_hwndDlg, (LPPOINT)&rc, 2 );

                    // if the difference between the current height of the client area
                    // (MAKEPOINTS(lParam).y) and the desired height of the client
                    // area (rc.bottom) is non-zero then we must adjust the size of the
                    // client area.  This will enlarge the client area if you switch
                    // from a regular menu font to a jumbo menu font and shrink the
                    // client area if you switch from a jumbo menu font to a regular
                    // menu font.
                    iDelta = rc.bottom - HIWORD(lParam);
                    if ( iDelta )
                    {
                        GetWindowRect( g_hwndDlg, &rc );
                        SetWindowPos( g_hwndDlg, NULL,
                            0, 0,                       // these are ingored due to SWP_NOMOVE
                            rc.right-rc.left,           // the width remains the same
                            rc.bottom-rc.top+iDelta,    // the heigth changes by iDelta
                            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
                        return 0;
                    }
                }
            }
            /* Fall through.                                              */

        default:
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));
    }

    return 0L;
}


LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // prevent right button to cut/del/paste... messes up the calculation
    if (uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST)
        return 0;

    // FEATURE: You can still begin a selection by holding down shift and using the arrow keys.  This should also be disabled.

    HideCaret(hWnd);
    return CallWindowProc(fpOrgDispEditProc, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scioper.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scioper.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    DoOperation--Does common operations.                            ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    DisplayError                                                    ***/
/***                                                                    ***/
/*** Last modification Thu  31-Aug-1989                                 ***/
/**************************************************************************/

#include "scicalc.h"

extern BOOL        bInv;
extern LONG        nPrecision;


/****************************************************************************\
* HNUMOBJ NEAR DoOperation (short nOperation, HNUMOBJ fpx)
*
* Routines to perform standard operations &|^~<<>>+-/*% and pwr.
*
\****************************************************************************/

void DoOperation (INT nOperation, HNUMOBJ *phnoNum, HNUMOBJ hnoX)
{
    // NOTE: volatile is used here because of a compiler bug! vc 5 AND 6.  This has no effect on the funcationality.
    volatile PRAT hno = NULL;

    try
    {
        switch (nOperation)
        {
        /* Buncha ops.  Hope *this* doesn't confuse anyone <smirk>.       */
        case IDC_AND:
            andrat( phnoNum, hnoX );
            return;

        case IDC_OR:
            orrat( phnoNum, hnoX );
            return;

        case IDC_XOR:
            xorrat( phnoNum, hnoX );
            return;

        case RSHF:
            NumObjAssign( &hno, *phnoNum );
            NumObjAssign( phnoNum, hnoX );

            rshrat( phnoNum, hno );
            break;

        case IDC_LSHF:
            NumObjAssign( &hno, *phnoNum );
            NumObjAssign( phnoNum, hnoX );

            lshrat( phnoNum, hno );
            break;

        case IDC_ADD:
            addrat( phnoNum, hnoX );
            return;

        case IDC_SUB:
            // in order to do ( hnoX - phnoNum ) we actually do -(phnoNum - hnoX ) cause it's quicker
            subrat( phnoNum, hnoX );
            NumObjNegate( phnoNum );
            return;

        case IDC_MUL:
            mulrat( phnoNum, hnoX );
            return;

        case IDC_DIV:
        case IDC_MOD:
            {
                // REVIEW:  These lengthly number assignments can be replaced with some quick pointer swaps.
                // the swaps cannot change the value of hnoX unless we also modify the code that calls
                // the DoOperation function.
                NumObjAssign( &hno, *phnoNum );
                NumObjAssign( phnoNum, hnoX );

                if (nOperation==IDC_DIV) {
                    divrat(phnoNum, hno );   /* Do division.                       */
                } else {
                    modrat( phnoNum, hno );
                }

                break;
            }

        case IDC_PWR:       /* Calculates hnoX to the hnoNum(th) power or root.   */
            {
                NumObjAssign( &hno, *phnoNum );
                NumObjAssign( phnoNum, hnoX );

                if (bInv)   /* Switch for hnoNum(th) root. Null root illegal.    */
                {
                    SetBox (IDC_INV, bInv=FALSE);
                    rootrat( phnoNum, hno);        /* Root.                           */
                }
                else 
                {
                    powrat( phnoNum, hno );    /* Power.                          */
                }

                break;
            }
        }

        if ( hno != NULL )
            NumObjDestroy( &hno );
    }
    catch ( DWORD dwErrCode )
    {
        // if ratpak throws an error, we may need to free the memory used by hno
        if ( hno != NULL )
            NumObjDestroy( &hno );

        DisplayError( dwErrCode );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scikeys.c ===
#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"

#define RED         RGB(255,0,0)       /* Red                           */
#define PURPLE      RGB(255,0,255)     /* Dark Purple                   */
#define BLUE        RGB(0,0,255)       /* Blue                          */
#define DKBLUE      RGB(0,0,255)       /* Dark Blue                     */
#define MAGENTA     RGB(255,0,255)     /* Magenta                       */
#define DKRED       RGB(255,0,0)       /* Dark Red.                     */
#define WHITE       RGB(255,255,255)   /* White                         */
#define BLACK       RGB(0,0,0)         /* Black                         */

extern BOOL g_fHighContrast;

typedef struct
{
    COLORREF    crColor;    // text color
    DWORD       iHelpID;    // the helpfile ID for this key
//    int         bUnary  :1, // true if this key is treated as a unary operator
//                bBinary :1, // true if this key is a binary operator
//                bUseInv :1, // true if this key deactivates the Inv checkbox when used
//                bUseHyp :1; // true if this key deactivates the Hyp checkbox when used
} KEYDATA;

//    Control ID,       Color,  Help ID,            Unary,  Binary, Inv,    Hyp
KEYDATA keys[] = {
    { /*IDC_SIGN,   */  BLUE,   CALC_STD_SIGN,      /*false,  false,  false,  false*/ },
    { /*IDC_CLEAR,  */  DKRED,  CALC_C,             /*false,  false,  false,  false*/ },
    { /*IDC_CENTR,  */  DKRED,  CALC_CE,            /*false,  false,  false,  false*/ },
    { /*IDC_BACK,   */  DKRED,  CALC_BACK,          /*false,  false,  false,  false*/ },
    { /*IDC_STAT,   */  DKBLUE, CALC_SCI_STA,       /*false,  false,  false,  false*/ },
    { /*IDC_PNT,    */  BLUE,   CALC_STD_DECIMAL,   /*false,  false,  false,  false*/ },
    { /*IDC_AND,    */  RED,    CALC_SCI_AND,       /*false,  false,  false,  false*/ },
    { /*IDC_OR,     */  RED,    CALC_SCI_OR,        /*false,  false,  false,  false*/ },
    { /*IDC_XOR,    */  RED,    CALC_SCI_XOR,       /*false,  false,  false,  false*/ },
    { /*IDC_LSHF,   */  RED,    CALC_SCI_LSH,       /*false,  false,  false,  false*/ },
    { /*IDC_DIV,    */  RED,    CALC_STD_SLASH,     /*false,  false,  false,  false*/ },
    { /*IDC_MUL,    */  RED,    CALC_STD_ASTERISK,  /*false,  false,  false,  false*/ },
    { /*IDC_ADD,    */  RED,    CALC_STD_PLUS,      /*false,  false,  false,  false*/ },
    { /*IDC_SUB,    */  RED,    CALC_STD_MINUS,     /*false,  false,  false,  false*/ },
    { /*IDC_MOD,    */  RED,    CALC_SCI_MOD,       /*false,  false,  false,  false*/ },
    { /*IDC_PWR,    */  PURPLE, CALC_SCI_XCARETY,   /*false,  false,  false,  false*/ },
    { /*IDC_CHOP,   */  RED,    CALC_SCI_INT,       /*false,  false,  false,  false*/ },
    { /*IDC_COM,    */  RED,    CALC_SCI_NOT,       /*false,  false,  false,  false*/ },
    { /*IDC_SIN,    */  PURPLE, CALC_SCI_SIN,       /*false,  false,  false,  false*/ },
    { /*IDC_COS,    */  PURPLE, CALC_SCI_COS,       /*false,  false,  false,  false*/ },
    { /*IDC_TAN,    */  PURPLE, CALC_SCI_TAN,       /*false,  false,  false,  false*/ },
    { /*IDC_LN,     */  PURPLE, CALC_SCI_LN,        /*false,  false,  false,  false*/ },
    { /*IDC_LOG,    */  PURPLE, CALC_SCI_LOG,       /*false,  false,  false,  false*/ },
    { /*IDC_SQRT,   */  DKBLUE, CALC_STD_SQRT,      /*false,  false,  false,  false*/ },
    { /*IDC_SQR,    */  PURPLE, CALC_SCI_XCARET2,   /*false,  false,  false,  false*/ },
    { /*IDC_CUB,    */  PURPLE, CALC_SCI_XCARET3,   /*false,  false,  false,  false*/ },
    { /*IDC_FAC,    */  PURPLE, CALC_SCI_FACTORIAL, /*false,  false,  false,  false*/ },
    { /*IDC_REC,    */  PURPLE, CALC_1X,            /*false,  false,  false,  false*/ },
    { /*IDC_DMS,    */  PURPLE, CALC_SCI_DMS,       /*false,  false,  false,  false*/ },
    { /*IDC_PERCENT,*/  DKBLUE, CALC_STD_PERCENT,   /*false,  false,  false,  false*/ },
    { /*IDC_FE,     */  PURPLE, CALC_SCI_FE,        /*false,  false,  false,  false*/ },
    { /*IDC_PI,     */  DKBLUE, CALC_SCI_PI,        /*false,  false,  false,  false*/ },
    { /*IDC_EQU,    */  RED,    CALC_STD_EQUAL,     /*false,  false,  false,  false*/ },
    { /*IDC_MCLEAR, */  RED,    CALC_MC,            /*false,  false,  false,  false*/ },
    { /*IDC_RECALL, */  RED,    CALC_MR,            /*false,  false,  false,  false*/ },
    { /*IDC_STORE,  */  RED,    CALC_MS,            /*false,  false,  false,  false*/ },
    { /*IDC_MPLUS,  */  RED,    CALC_MPLUS,         /*false,  false,  false,  false*/ },
    { /*IDC_EXP,    */  PURPLE, CALC_SCI_EXP,       /*false,  false,  false,  false*/ },
    { /*IDC_AVE,    */  DKBLUE, CALC_SCI_AVE,       /*false,  false,  false,  false*/ },
    { /*IDC_B_SUM,  */  DKBLUE, CALC_SCI_SUM,       /*false,  false,  false,  false*/ },
    { /*IDC_DEV,    */  DKBLUE, CALC_SCI_S,         /*false,  false,  false,  false*/ },
    { /*IDC_DATA,   */  DKBLUE, CALC_SCI_DAT,       /*false,  false,  false,  false*/ },
    { /*IDC_OPENP,  */  PURPLE, CALC_SCI_OPENPAREN, /*false,  false,  false,  false*/ },
    { /*IDC_CLOSEP, */  PURPLE, CALC_SCI_CLOSEPAREN,/*false,  false,  false,  false*/ },
    { /*IDC_0,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_1,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_2,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_3,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_4,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_5,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_6,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_7,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_8,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_9,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_A,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_B,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_C,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_D,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_E,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_F,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ }
};

// Returns true if the given ID is one of Calc's command buttons
BOOL IsValidID( int iID )
{
    if ( (iID >= IDC_SIGN) && (iID <= IDC_F) )
        return TRUE;

    return FALSE;
}

// Used when processing WM_DRAWITEM to get the key color
COLORREF GetKeyColor( int iID )
{
    if ( g_fHighContrast || !IsValidID( iID ))
        return GetSysColor(COLOR_BTNTEXT);

    if ( nCalc && (iID == IDC_REC) )
        return DKBLUE;

    return keys[INDEXFROMID(iID)].crColor;
}

// Used when processing WM_CONTEXTHELP to get the Help ID.
// This works for any control ID, not just the command buttons.
ULONG_PTR GetHelpID( int iID )
{
    if ( IsValidID( iID ) )
    {
        return keys[INDEXFROMID(iID)].iHelpID;
    }

    switch( iID )
    {
    case IDC_HEX:
        return CALC_SCI_HEX;
    case IDC_DEC:
        return CALC_SCI_DEC;
    case IDC_OCT:
        return CALC_SCI_OCT;
    case IDC_BIN:
        return CALC_SCI_BIN;
    case IDC_DEG:
        return CALC_SCI_DEG;
    case IDC_RAD:
        return CALC_SCI_RAD;
    case IDC_GRAD:
        return CALC_SCI_GRAD;
    case IDC_QWORD:
        return CALC_SCI_QWORD; 
    case IDC_DWORD:
        return CALC_SCI_DWORD; 
    case IDC_WORD:
        return CALC_SCI_WORD; 
    case IDC_BYTE:
        return CALC_SCI_BYTE; 
    case IDC_INV:
        return CALC_SCI_INV;
    case IDC_HYP:
        return CALC_SCI_HYP;
    case IDC_DISPLAY:
        return CALC_STD_VALUE;
    case IDC_MEMTEXT:
        return CALC_SCI_MEM;
    case IDC_PARTEXT:
        return CALC_SCI_PARENS;
    }

    ASSERT( 0 );    // an invalid help ID has been used.
    return 0;
}


/*
BOOL IsUnaryOperator( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUnary;
}

BOOL IsBinaryOperator( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bBinary;
}

BOOL UsesInvKey( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUseInv;
}

BOOL UsesHypKey( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUseHyp;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scimath.c ===
#include <windows.h>
#include <stdlib.h>
#include "scicalc.h"
#include "unifunc.h"
#include "..\ratpak\debug.h"

/**************************************************************************\
*                                                                          *
*                                                                          *
*                                                                          *
*    #          #                           #####                          *
*    #         #              #             #    #                         *
*    #         #  #        #  #             #    #                         *
*    #        ###            ###            #    #                         *
*    # # ###   #  # # ###  #  #   ###       #####  # ###  ###   ###        *
*    # ##   #  #  # ##   # #  #  #   #      #      ##    #   # #           *
*    # #    #  #  # #    # #  #  #####      #      #     ##### #           *
*    # #    #  #  # #    # #  #  #          #      #     #     #    ##     *
*    # #    #  #  # #    # #   #  ###       #      #      ###   ### ##     *
*                                                                          *
*                                                                          *
*              Infinte Precision Production Version                        *
*                                                                          *
\**************************************************************************/
//
// RETAIL version of NUMOBJ math that uses Infinite Precision
//
// History
//
//  16-Nov-1996 JonPa   Wrote it
//  whenever-97 ToddB   Rewrote it using improved ratpak model
//

/*****************************************************************\
*
* Generic Math Package support routines and variables
*
* History:
*   01-Dec-1996 JonPa   Wrote them
*   whenever-97 ToddB   Rewrote them
*
\*****************************************************************/

//
// Worker for NumObjRecalcConstants
//
//  Returns the nearest power of two
//
int QuickLog2( int iNum )
{
    int iRes = 0;

    // while first digit is a zero
    while ( !(iNum & 1) )
    {
        iRes++;
        iNum >>= 1;
    }

    // if our number isn't a perfect square
    if ( iNum = iNum >> 1 )
    {
        // find the largest digit
        while ( iNum = iNum >> 1 )
           ++iRes;

        // and then add two
        iRes += 2;
    }

    return iRes;
}

////////////////////////////////////////////////////////////////////////
//
//  UpdateMaxIntDigits
//
// determine the maximum number of digits needed for the current precision,
// word size, and base.  This number is conservative towards the small side
// such that there may be some extra bits left over.  The number of extra
// bits is returned.  For example, base 8 requires 3 bits per digit.  A word
// size of 32 bits allows for 10 digits with a remainder of two bits.  Bases
// that require variable numnber of bits (non-power-of-two bases) are approximated
// by the next highest power-of-two base (again, to be conservative and gaurentee
// there will be no over flow verse the current word size for numbers entered).
// Base 10 is a special case and always uses the base 10 precision (nPrecision).
void UpdateMaxIntDigits()
{
    extern int gcIntDigits;
    int iRemainderBits;

    if ( nRadix == 10 )
    {
        gcIntDigits = nPrecision;
        iRemainderBits = 0;
    }
    else
    {
        int log2;

        log2 = QuickLog2( nRadix );

        ASSERT( 0 != log2 );     // same as ASSERT( nRadix != 1 )

        gcIntDigits = dwWordBitWidth / log2;
        iRemainderBits = dwWordBitWidth % log2;
    }
}

void BaseOrPrecisionChanged( void ) 
{
    extern LONG dwWordBitWidth;
    extern int  gcIntDigits;

    UpdateMaxIntDigits();
    if ( 10 == nRadix )
    {
        // to prevent unwanted rounded digits from showing up in the
        // gcIntDigits + 1 spot during non-integer mode we don't want
        // to add the extra 1 that we ortherwise add
        ChangeConstants( nRadix, gcIntDigits );
    }
    else
    {
        ChangeConstants( nRadix, gcIntDigits+1 );
    }
}

/*****************************************************************\
*
* Unary functions
*
* History:
*   01-Dec-1996 JonPa   Wrote them
*   whenever-97 ToddB   Rewrote them
*
\*****************************************************************/

void NumObjInvert( PHNUMOBJ phno ) {
    DECLARE_HNUMOBJ( hno );

    NumObjAssign( &hno, HNO_ONE );
    divrat( &hno, *phno );
    NumObjAssign( phno, hno );
    NumObjDestroy( &hno );
}

void NumObjAntiLog10( PHNUMOBJ phno ) {
    DECLARE_HNUMOBJ( hno );

    NumObjSetIntValue( &hno, 10 );
    powrat( &hno, *phno );
    NumObjAssign( phno, hno );
    NumObjDestroy( &hno );
}

void NumObjNot( PHNUMOBJ phno )
{
    if ( nRadix == 10 )
    {
        intrat( phno );
        addrat( phno, HNO_ONE );
        NumObjNegate( phno );
    }
    else
    {
        ASSERT( (nHexMode >= 0) && (nHexMode <= 3) );
        ASSERT( phno );
        ASSERT( *phno );
        ASSERT( g_ahnoChopNumbers[ nHexMode ] );

        xorrat( phno, g_ahnoChopNumbers[ nHexMode ] );
    }
}

void NumObjSin( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    sinanglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

void NumObjCos( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    cosanglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

void NumObjTan( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    tananglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

/******************************************************************\
*
* Number format conversion routines
*
* History:
*   06-Dec-1996 JonPa   wrote them
\******************************************************************/
void NumObjSetIntValue( PHNUMOBJ phnol, LONG i ) {
    PRAT pr = NULL;

    pr = longtorat( i );
    NumObjAssign( phnol, (HNUMOBJ)pr );
    destroyrat(pr);
}

void NumObjGetSzValue( LPTSTR *ppszNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT fmt ) {
    LPTSTR psz;

    psz = putrat( &hnoNum, nRadix, fmt );

    if (psz != NULL) {
        if (*ppszNum != NULL) {
            NumObjFreeMem( *ppszNum );
        }
        *ppszNum = psz;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\sciset.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** sciset.c                                                           ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SetRadix--Changes the number base and the radiobuttons.         ***/
/***    SetBox--Handles the checkboxes for inv/hyp.                     ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    none                                                            ***/
/***                                                                    ***/
/*** History:
 ***    12-Dec-1996 JonPa   -   Added SetMaxIntDigits
 ***    Whenever-97 ToddB   -   Removed SetMaxIntDigits
 ***/
/**************************************************************************/

#include "scicalc.h"
#include "unifunc.h"

extern TCHAR    szBlank[6];
extern INT      gcIntDigits;
extern TCHAR    *rgpsz[CSTRINGS];
extern TCHAR    szDec[];
extern RECT     rcDeg[6];
extern HMENU    g_hDecMenu;
extern HMENU    g_hHexMenu;

long oldRadix = (unsigned)-1;

void ActivateButtons()
{
    static int  aDecOnlyKeys[] = { IDC_FE, IDC_DMS, IDC_SIN, IDC_COS, IDC_TAN, IDC_EXP, IDC_PI };   // controls used only in Decimal mode

    if (oldRadix != nRadix)
    {
        int i;
        BOOL bDecMode = (nRadix == 10);
        
        // Only send messages to the the "Decimal Only keys" if this change in
        // base effects those keys

        if ((oldRadix == 10) || bDecMode)
        {
            // we are changing to or from decimal mode
            for ( i = 0; i <= ARRAYSIZE(aDecOnlyKeys) ; i++ )
            {
                EnableWindow( GetDlgItem(g_hwndDlg, aDecOnlyKeys[i]), 
                              bDecMode );
            }
        }

        // insure that nRadix is within the allowed range
        ASSERT( (nRadix >= 2) && (nRadix <= 16) );
        
        // turn on digit keys less than nRadix and turn off digit keys >= nRadix
        for (i=2; i<nRadix; i++)
            EnableWindow( GetDlgItem(g_hwndDlg, IDC_0+i), TRUE );

        for ( ; i<16; i++ )
            EnableWindow( GetDlgItem(g_hwndDlg, IDC_0+i), FALSE );
    }
    oldRadix = nRadix;
}

// SetRadix sets the display mode according to the selected button.
// ToddB:  As a hack to allow setting other bases, wRadix can be one of
//         the base buttons OR it can be the desired nRadix.

// MAXIUM: for Dec the precision is limited to the nPrecision, 
//  otherwise it is limited to the word size.

VOID NEAR SetRadix(DWORD wRadix)
{
    static INT  nRadish[4]={2,8,10,16}; /* Number bases.               */

    int   id=IDM_DEC;

    // convert special bases into symbolic values
    switch ( wRadix )
    {
    case 2:
        id=IDM_BIN;
        break;

    case 8:
        id=IDM_OCT;
        break;

    case 10:
        id=IDM_DEC;
        break;

    case 16:
        id=IDM_HEX;
        break;

    case IDM_HEX:
    case IDM_DEC:
    case IDM_OCT:
    case IDM_BIN:
        id=wRadix;
        wRadix = nRadish[IDM_BIN - wRadix];
        break;
    }

    // we select which group of toggles we are setting, decimal mode gets the
    // angular notation buttons (deg, rad, grad) otherwise we get the word size 
    // buttons (dword, word, byte)

    SwitchModes(wRadix, nDecMode, nHexMode);

    CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg),1),IDM_HEX,IDM_BIN,id,
                       MF_BYCOMMAND);

    CheckRadioButton(g_hwndDlg,IDM_HEX, IDM_BIN, id);

    nRadix = wRadix;

    // inform ratpak that a change in base or precision has occured
    BaseOrPrecisionChanged();
    
    // update the UI elements to the correct state
    ActivateButtons();

    // display the correct number for the new state (ie convert displayed 
    //  number to correct base)
    DisplayNum();
}


// Check/uncheck the visible inverse/hyperbolic

VOID NEAR SetBox (int id, BOOL bOnOff)
{
    CheckDlgButton(g_hwndDlg, id, (WORD) bOnOff);
    return;
}

//
// Description:
//   This will switch the displayed/enabled mode buttons.  This also updates
//   The switches the menu under view and sets the correct state.
//
void
SwitchModes(DWORD wRadix, int nDecMode, int nHexMode)
{
    int iID, id;

    if (10 == wRadix)
    {
        id=IDM_DEG+nDecMode;

        if (NULL != g_hDecMenu)
            SetMenu(g_hwndDlg, g_hDecMenu);

        CheckMenuRadioItem(g_hDecMenu, IDM_DEG, IDM_GRAD, id, MF_BYCOMMAND);
        CheckRadioButton(g_hwndDlg,IDC_DEG, IDC_GRAD, id);
    }
    else
    {
        id=IDM_QWORD+nHexMode;

        if (NULL != g_hHexMenu)
            SetMenu(g_hwndDlg, g_hHexMenu);

        CheckMenuRadioItem(g_hHexMenu, IDM_QWORD, IDM_BYTE, id, MF_BYCOMMAND);
        CheckRadioButton(g_hwndDlg,IDC_QWORD, IDC_BYTE, id);
    }

    for (iID = IDC_QWORD; iID <= IDC_BYTE; iID++)
    {
        EnableWindow( GetDlgItem( g_hwndDlg, iID ), (wRadix != 10) );
        ShowWindow( GetDlgItem( g_hwndDlg, iID ),
                    (wRadix == 10) ? SW_HIDE : SW_SHOW );
    }

    for (iID = IDC_DEG; iID <= IDC_GRAD; iID++)
    {
        EnableWindow( GetDlgItem( g_hwndDlg, iID ), (wRadix == 10) );
        ShowWindow( GetDlgItem( g_hwndDlg, iID ), 
                    (wRadix != 10) ? SW_HIDE : SW_SHOW );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scimath.h ===
/**************************************************************************\
*                                                                          *
*                                                                          *
*                                                                          *
*    #          #                           #####                          *
*    #         #              #             #    #                         *
*    #         #  #        #  #             #    #                         *
*    #        ###            ###            #    #                         *
*    # # ###   #  # # ###  #  #   ###       #####  # ###  ###   ###        *
*    # ##   #  #  # ##   # #  #  #   #      #      ##    #   # #           *
*    # #    #  #  # #    # #  #  #####      #      #     ##### #           *
*    # #    #  #  # #    # #  #  #          #      #     #     #    ##     *
*    # #    #  #  # #    # #   #  ###       #      #      ###   ### ##     *
*                                                                          *
*                                                                          *
*              Infinte Precision Production Version                        *
*                                                                          *
\**************************************************************************/
//
// RETAIL version of NUMOBJ math that uses Infinite Precision
//
#include "..\ratpak\ratpak.h"

#define HNUMOBJ   PRAT
typedef HNUMOBJ * PHNUMOBJ;


//
// Memory Alloc functions
//
#define NumObjAllocMem( cb )         zmalloc( cb )
#define NumObjFreeMem( h )           zfree( h ),(h=NULL)

//
// Unary functions
//

void NumObjInvert( PHNUMOBJ phno );

#define NumObjNegate( phno )                ( ((PRAT)*phno)->pp->sign= -(((PRAT)*phno)->pp->sign) )
#define NumObjAbs( phno )                   ( ((PRAT)*phno)->pp->sign=1, ((PRAT)*phno)->pq->sign=1 )

extern void NumObjSin( PHNUMOBJ phno );
extern void NumObjCos( PHNUMOBJ phno );
extern void NumObjTan( PHNUMOBJ phno );
extern void NumObjAntiLog10( PHNUMOBJ phno );

extern void NumObjNot( PHNUMOBJ phno );

//
// Comparison functions
//
#define NumObjIsZero( hno )                 zerrat( hno )
#define NumObjIsLess( hno1, hno2 )          rat_lt( hno1, hno2 )
#define NumObjIsLessEq( hno1, hno2 )        rat_le( hno1, hno2 )
#define NumObjIsGreaterEq( hno1, hno2 )     rat_ge( hno1, hno2 )
#define NumObjIsEq( hno1, hno2 )            rat_equ(hno1, hno2 )

//
// Assignment operator.  ('=' in C language)
//
#define NumObjAssign( phnol, hnor )         if (1) { DUPRAT( (*phnol), hnor ); } else 


//
// Data type conversion functions
//
void NumObjSetIntValue( PHNUMOBJ phnol, LONG i );


//
//  NumObjMakeNumber
//
//      HNUMOBJ NumObjMakeNumber( LPTSTR psz );
//
//  Converts psz to a number and returns it.  Call NumObjDestroy()
//  when you are done using the returned NumObj.
//
#define     NumObjMakeNumber( fMantNeg, pszMant, fExpNeg, pszExp )      inrat( fMantNeg, pszMant, fExpNeg, pszExp )

//
//  NumObjGetSzValue
//
//      void NumObjGetSzValue( LPTSTR *ppszNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT gafmt );
//
//  Converts hnoNum to a string and places the pointer into *ppszNum.  If *ppszNum already points
//  to a string, then that string is freed.
//
//  NOTES:  *ppszNum must either be NULL or point to a string previously returned by this function!
//          If you wish to free the string without replacing it.  You MUST use the NumObjFreeMem() function!
//
void NumObjGetSzValue( LPTSTR *ppszNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT gafmt );

//
//  GetObjGetExp
//
//  returns an int that equals the exponent of the NumObj
//
#define NumObjGetExp( hno )         LOGRATRADIX(hno)

//
//  NumObjCvtEpsilonToZero
//
//  if the input is < 1*10^(-nPrecision), then it gets set to zero
//  useful for special cases in ln, log, and sin, and cos
//
#define NumObjCvtEpsilonToZero( phno )
//#define NumObjCvtEpsilonToZero( phno )  if ( NumObjGetExp( *phno ) <= -nPrecision ) { NumObjAssign( phno, HNO_ZERO );} else

//
//  NumObjAbortOperation( fAbort )
//
//  If called with fAbort==TRUE, it will cause RATPAK to abort the current calculation and to return
//  immeadiatly.
//
//  It MUST be called again with fAbort=FALSE after ratpak has aborted to reset ratpak.
//
#define NumObjAbortOperation( fAbort )  (fhalt=fAbort)
#define NumObjWasAborted()              (fhalt)

//
//  NumObjOK( hno )
//
//      returns TRUE if the HNUMOBJ is valid (ie created and initialized)
//
//  Used to check the HNUMOBJ returned from NumObjMakeNumber and NumObjCreate
//
#   define NumObjOK( hno )              ((hno) == NULL ? FALSE : TRUE)

//
//  NumObjDestroy( hno )
//
//      call this when you nolonger need the NumObj.  Failure to do so
//  will result in memory leaks.
//
#   define NumObjDestroy( phno )            destroyrat( (*(phno)) )

//
// DECLARE_HNUMOBJ( hno )
//
//  Use this macro when ever you want to declare a local variable.
//
#   define DECLARE_HNUMOBJ( hno )       HNUMOBJ hno = NULL

//
// Useful Constants.  These have to be recomputed after a base or precision change.
//
void BaseOrPrecisionChanged( void );

#define HNO_ZERO                rat_zero
#define HNO_ONE_OVER_TWO        rat_half
#define HNO_ONE                 rat_one
#define HNO_TWO                 rat_two
#define HNO_180_OVER_PI         rad_to_deg
#define HNO_200_OVER_PI         rad_to_grad
#define HNO_2PI                 two_pi
#define HNO_PI                  pi
#define HNO_PI_OVER_TWO         pi_over_two
#define HNO_THREE_PI_OVER_TWO   one_pt_five_pi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\wassert.h ===
/****************************Module*Header***********************************\
* Module Name: WASSERT
*
* Module Descripton: Quick Win32 assert code.
*
* Warnings:
*
* Created: 15 July 1993
*
* Author: Raymond E. Endres   [rayen@microsoft.com]
\****************************************************************************/

#ifndef _DEBUG
   #define ASSERT(exp) ((void)0)
#else
   void vAssert(TCHAR * pszExp, TCHAR * pszFile, int iLine);
   #define ASSERT(exp) (void)( (exp) || (vAssert(TEXT(#exp), TEXT(__FILE__), __LINE__), 0) )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\scistat.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scistat.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SetStat--Enable/disable the stat box, show or destroy the       ***/
/***        modeless dialog box.                                        ***/
/***    StatBoxProc--procedure for the statbox.  Handles the RET, LOAD, ***/
/***        CD, and CAD buttons, and handles double-clicks.             ***/
/***    StatFunctions--routines for DATA, SUM, AVE, and deviations.     ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SetStat                                                         ***/
/***                                                                    ***/
/*** Last modification Thu  26-Jan-1990                                 ***/
/*** -by- Amit Chatterjee [amitc]  26-Jan-1990.                         ***/
/*** Following bug fix was made:                                        ***/
/***                                                                    ***/
/*** Bug # 8499.                                                        ***/
/*** While fixing numbers in the stat array in memory, instead of using ***/
/*** the following for statement:                                       ***/
/***      for (lIndex=lData; lIndex < lStatNum - 1 ; lIndex++)          ***/
/*** the fix was to use:                                                ***/
/***      for (lIndex=lData; lIndex < lStatNum ; lIndex++)              ***/
/*** This is because lStatNum has already been decremented to care of   ***/
/*** a number being deleted.                                            ***/
/*** This fix will be in build 1.59.                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"

#define GMEMCHUNK 96L  /* Amount of memory to allocate at a time.         */

extern HNUMOBJ  ghnoNum;
extern HWND     hStatBox, hListBox, hEdit;
extern TCHAR    szBlank[6], *rgpsz[CSTRINGS];
extern LPTSTR   gpszNum;
extern INT      nTempCom;
extern BOOL     gbRecord;

extern BOOL FireUpPopupMenu( HWND, HINSTANCE, LPARAM );

GLOBALHANDLE    hgMem, hMem;   /* Coupla global memory handles.        */
BOOL            bFocus=TRUE;
LONG            lStatNum=0,    /* Number of data.                      */
                lReAllocCount; /* Number of data before ReAlloc.       */
HNUMOBJ *       lphnoStatNum;   /* Holding place for stat data.         */


/* Initiate or destroy the Statistics Box.                                */

VOID  APIENTRY SetStat (BOOL bOnOff)
{
    static int aStatOnlyKeys[] = { IDC_AVE, IDC_B_SUM, IDC_DEV, IDC_DATA };
    int i;

    if (bOnOff)
    {
        /* Create.                                                        */
        lReAllocCount=GMEMCHUNK/sizeof(ghnoNum); /* Set up lReAllocCount.   */

        /* Start the box.                                                 */
        hStatBox=CreateDialog(hInst, MAKEINTRESOURCE(IDD_SB), NULL, StatBoxProc);

        /* Get a handle on some memory (16 bytes initially.               */
        if (!(hgMem=GlobalAlloc(GHND, 0L)))
        {
            StatError();
            SendMessage(hStatBox, WM_COMMAND, GET_WM_COMMAND_MPS(ENDBOX, 0, 0));
            return;
        }
        ShowWindow(hStatBox, SW_SHOWNORMAL);
    }
    else
    {
        int lIndex;

        if ( hStatBox )
        {
            DestroyWindow(hStatBox);

            // Free the numobj's
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
            for( lIndex = 0; lIndex < lStatNum; lIndex++ )
                NumObjDestroy( &lphnoStatNum[lIndex] );
            GlobalUnlock(hgMem);
            lStatNum = 0;

            GlobalFree(hgMem);  /* Free up the memory.                        */
            hStatBox=0;         /* Nullify handle.                            */
        }
    }

    // set the active state of the Ave, Sum, s, and Dat buttons
    for ( i=0; i<ARRAYSIZE(aStatOnlyKeys); i++)
        EnableWindow( GetDlgItem(g_hwndDlg, aStatOnlyKeys[i]), bOnOff );

    return;
}



/* Windows procedure for the Dialog Statistix Box.                        */
INT_PTR FAR APIENTRY StatBoxProc (
     HWND           hStatBox,
     UINT           iMessage,
     WPARAM         wParam,
     LPARAM         lParam)
{
    static LONG lData=-1;  /* Data index in listbox.                   */
    LONG        lIndex;    /* Temp index for counting.                 */
    DWORD       dwSize;    /* Holding place for GlobalSize.            */
    static DWORD    control[] = {
        IDC_STATLIST,   CALC_SCI_STATISTICS_VALUE,
        IDC_CAD,        CALC_SCI_CAD,
        IDC_CD,         CALC_SCI_CD,
        IDC_LOAD,       CALC_SCI_LOAD,
        IDC_FOCUS,      CALC_SCI_RET,
        IDC_NTEXT,      CALC_SCI_NUMBER,
        IDC_NUMTEXT,    CALC_SCI_NUMBER,
        0,              0 };

    switch (iMessage)
    {
        case WM_HELP:
        {
            LPHELPINFO phi = (LPHELPINFO)lParam;
            HWND hwndChild = GetDlgItem(hStatBox,phi->iCtrlId);
            WinHelp( hwndChild, rgpsz[IDS_HELPFILE], HELP_WM_HELP, (ULONG_PTR)(void *)control );
            return TRUE;
        }

        case WM_CONTEXTMENU:
            WinHelp( (HWND)wParam, rgpsz[IDS_HELPFILE], HELP_CONTEXTMENU, (ULONG_PTR)(void *)control );
            return TRUE;

        case WM_CLOSE:
            SetStat(FALSE);

        case WM_DESTROY:
            lStatNum=0L; /* Reset data count.                     */
            return(TRUE);

        case WM_INITDIALOG:
            /* Get a handle to this here things listbox display.          */
            hListBox=GetDlgItem(hStatBox, IDC_STATLIST);
            return TRUE;

        case WM_COMMAND:
            /* Check for LOAD or double-click and recall number if so.    */

            if (GET_WM_COMMAND_CMD(wParam, lParam)==LBN_DBLCLK ||
                        GET_WM_COMMAND_ID(wParam, lParam)==IDC_LOAD)
            {
                /* Lock data, get pointer to it, and get index of item.   */
                lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
                lData=(LONG)SendMessage(hListBox,LB_GETCURSEL,0,0L);

                if (lStatNum>0 && lData !=LB_ERR)
                    // SPEED: REVIEW: can we use a pointer instead of Assign?
                    NumObjAssign( &ghnoNum, lphnoStatNum[lData]);  /* Get the data.         */
                else
                    MessageBeep(0); /* Cannodo if no data nor selection.  */

                // Cancel kbd input mode
                gbRecord = FALSE;

                DisplayNum ();
                nTempCom = 32;
                GlobalUnlock(hgMem); /* Let the memory move!              */
                break;
            }

            // switch (wParam)
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_FOCUS:
                    /* Change focus back to main window.  Primarily for   */
                    /* use with the keyboard.                             */
                    SetFocus(g_hwndDlg);
                    return (TRUE);

                case IDC_CD:
                    /* Clear the selected item from the listbox.          */
                    /* Get the index and a pointer to the data.           */
                    lData=(LONG)SendMessage(hListBox,LB_GETCURSEL,0,0L);

                    /* Check for possible error conditions.               */
                    if (lData==LB_ERR || lData > lStatNum-1 || lStatNum==0)
                    {
                        MessageBeep (0);
                        break;
                    }

                    /* Fix listbox strings.                               */
                    lIndex=(LONG)SendMessage(hListBox, LB_DELETESTRING, (WORD)lData, 0L);

                    if ((--lStatNum)==0)
                        goto ClearItAll;

                    /* Place the highlight over the next one.             */
                    if (lData<lIndex || lIndex==0)
                        lIndex=lData+1;

                    SendMessage(hListBox, LB_SETCURSEL, (WORD)lIndex-1, 0L);

                    lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

                    /* Fix numbers in memory.                             */
                    for (lIndex=lData; lIndex < lStatNum ; lIndex++)
                    {
                        NumObjAssign( &lphnoStatNum[lIndex], lphnoStatNum[lIndex+1] );
                    }

                    GlobalUnlock(hgMem);  /* Movin' again.                */

                    /* Update the number by the "n=".                     */
                    SetDlgItemInt(hStatBox, IDC_NUMTEXT, lStatNum, FALSE);

                    dwSize=(DWORD)GlobalSize(hgMem); /* Get size of memory block.*/

                    /* Unallocate memory if not needed after data removal.*/
                    /* hMem is used so we don't possibly trach hgMem.     */
                    if ((lStatNum % lReAllocCount)==0)
                        if ((hMem=GlobalReAlloc(hgMem, dwSize-GMEMCHUNK, GMEM_ZEROINIT)))
                            hgMem=hMem;
                    return(TRUE);

                case IDC_CAD:
ClearItAll:
                    /* Nuke it all!                                       */
                    SendMessage(hListBox, LB_RESETCONTENT, 0L, 0L);
                    SetDlgItemInt(hStatBox, IDC_NUMTEXT, 0, FALSE);;

                    // Free the numobj's
                    lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
                    for( lIndex = 0; lIndex < lStatNum; lIndex++ )
                        NumObjDestroy( &lphnoStatNum[lIndex] );
                    GlobalUnlock(hgMem);

                    GlobalFree(hgMem); /* Drop the memory.                */
                    lStatNum = 0;
                    hgMem=GlobalAlloc(GHND, 0L); /* Get a CLEAN slate.    */
                    return(TRUE);
            }
    }
    return (FALSE);
}



/* Routine for functions AVE, SUM, DEV, and DATA.                         */

VOID  APIENTRY StatFunctions (WPARAM wParam)
    {
    LONG           lIndex; /* Temp index.                                 */
    DWORD          dwSize; /* Return value for GlobalSize.                */

    switch (wParam)
    {
        case IDC_DATA: /* Add current fpNum to listbox.                       */
            if ((lStatNum % lReAllocCount)==0)
            {
                /* If needed, allocate another 96 bytes.                  */

                dwSize=(DWORD)GlobalSize(hgMem);
                if (StatAlloc (1, dwSize))
                {
                    GlobalCompact((DWORD)-1L);
                    if (StatAlloc (1, dwSize))
                    {
                        StatError ();
                        return;
                    }
                }
                hgMem=hMem;
            }

            /* Add the display string to the listbox.                     */
            hListBox=GetDlgItem(hStatBox, IDC_STATLIST);

            lIndex=StatAlloc (2,0L);
            if (lIndex==LB_ERR || lIndex==LB_ERRSPACE)
            {
                GlobalCompact((DWORD)-1L);

                lIndex=StatAlloc (2,0L);
                if (lIndex==LB_ERR || lIndex==LB_ERRSPACE)
                {
                    StatError ();
                    return;
                }
            }

            /* Highlight last entered string.                             */
            SendMessage(hListBox, LB_SETCURSEL, (WORD)lIndex, 0L);

            /* Add the number and increase the "n=" value.                */
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            NumObjAssign( &lphnoStatNum[lStatNum], ghnoNum );

            SetDlgItemInt(hStatBox, IDC_NUMTEXT, ++lStatNum, FALSE);
            break;

        case IDC_AVE: /* Calculate averages and sums.                         */
        case IDC_B_SUM: {
            DECLARE_HNUMOBJ( hnoTemp );

            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            /* Sum the numbers or squares, depending on bInv.             */
            NumObjAssign( &ghnoNum, HNO_ZERO );

            for (lIndex=0L; lIndex < lStatNum; lIndex++)
            {
                NumObjAssign( &hnoTemp, lphnoStatNum[lIndex] );
                if (bInv)
                {
                    DECLARE_HNUMOBJ( hno );
                    /* Get sum of squares.      */
                    NumObjAssign( &hno, hnoTemp );
                    mulrat( &hno, hnoTemp );
                    addrat( &ghnoNum, hno );
                    NumObjDestroy( &hno );
                }
                else
                {
                    /* Get sum.                          */
                    addrat( &ghnoNum, hnoTemp );
                }
            }

            if (wParam==IDC_AVE) /* Divide by lStatNum=# of items for mean.   */
            {
                DECLARE_HNUMOBJ( hno );
                if (lStatNum==0)
                {
                    DisplayError (SCERR_DIVIDEZERO);
                    break;
                }
                NumObjSetIntValue( &hno, lStatNum );
                divrat( &ghnoNum, hno );
                NumObjDestroy( &hno );
            }
            NumObjDestroy( &hnoTemp );
            /* Fall out for sums.                                         */
            break;
        }

        case IDC_DEV: { /* Calculate deviations.                                */
            DECLARE_HNUMOBJ(hnoTemp);
            DECLARE_HNUMOBJ(hnoX);
            DECLARE_HNUMOBJ( hno );

            if (lStatNum <=1) /* 1 item or less, NO deviation.            */
            {
                NumObjAssign( &ghnoNum, HNO_ZERO );
                return;
            }

            /* Get sum and sum of squares.                                */
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            NumObjAssign( &ghnoNum, HNO_ZERO );
            NumObjAssign( &hnoTemp, HNO_ZERO );

            for (lIndex=0L; lIndex < lStatNum; lIndex++)
            {

                NumObjAssign(&hnoX, lphnoStatNum[lIndex]);

                addrat( &hnoTemp, hnoX );

                NumObjAssign( &hno, hnoX );
                mulrat( &hno, hnoX );
                addrat( &ghnoNum, hno );

            }


            /*      x- nx/n                               */
            /* fpTemp=fpNum-(fpTemp*fpTemp/(double)lStatNum);*/
            /*                                               */
            NumObjSetIntValue( &hno, lStatNum );
            NumObjAssign( &hnoX, hnoTemp );
            mulrat( &hnoX, hnoTemp );
            divrat( &hnoX, hno );
            NumObjAssign( &hnoTemp, ghnoNum );
            subrat( &hnoTemp, hnoX );


            /* All numbers are identical if fpTemp==0                     */
            if (NumObjIsZero( hnoTemp))
                NumObjAssign( &ghnoNum, HNO_ZERO); /* No deviation.          */
            else {
                /* If bInv=TRUE, divide by n (number of data) otherwise   */
                /* divide by n-1.                                         */
                /* fpNum=sqrt(fpTemp/(lStatNum-1+(LONG)bInv));            */
                //
                // hno still equals lStatNum
                if (!bInv) {
                    subrat( &hno, HNO_ONE );
                }
                divrat( &hnoTemp, hno );
                rootrat( &hnoTemp, HNO_TWO );
                NumObjAssign( &ghnoNum, hnoTemp );
            }
            NumObjDestroy( &hno );
            NumObjDestroy( &hnoX );
            NumObjDestroy( &hnoTemp );
            break;
        }
    }
    GlobalUnlock(hgMem); /* Da memwry is fwee to move as Findows fishes.  */
    return;
}


LONG NEAR StatAlloc (WORD wType, DWORD dwSize)
{
    LONG           lRet=FALSE;

    if (wType==1)
    {
        if ((hMem=GlobalReAlloc(hgMem, dwSize+GMEMCHUNK, GMEM_ZEROINIT)))
            return 0L;
    }
    else
    {
        lRet=(LONG)SendMessage(hListBox, LB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)gpszNum);
        return lRet;
    }
    return 1L;
}


VOID NEAR StatError (VOID)
{
    TCHAR    szFoo[50];  /* This comes locally. Gets the Stat Box Caption. */

    MessageBeep(0);

    /* Error if out of room.                                              */
    GetWindowText(hStatBox, szFoo, 49);
    MessageBox(hStatBox, rgpsz[IDS_STATMEM], szFoo, MB_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\unifunc.h ===
/*** unifunc.h  ***/

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

TCHAR *UToDecT( UINT value, TCHAR *sz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\unifunc.c ===
/****************************Module*Header***********************************\
* Module Name: UNIFUNC.C
*
* Module Descripton: Number to string conversion routines for Unicode
*
* Warnings:
*
* Created:  22-Aug-1995
*
* Author:   JonPa
\****************************************************************************/
#include <windows.h>
#include "scicalc.h"

#define CCH_DWORD   15  // enough for 9 chars in 2^32 + sign, zterm + slop

//
// NOTE!
//
//  Even though this function uses psz++ and psz--,
//      **IT IS STILL INTERNATIONAL SAFE!**
//
//  That is because we put the chars in the string, and
//  we are only ever using chars that are single byte in ALL
//  code pages ('0'..'9').
//
TCHAR *UToDecT( UINT value, TCHAR *sz) {
    TCHAR szTmp[CCH_DWORD];
    LPTSTR psz = szTmp;
    LPTSTR pszOut;

    do {
        *psz++ = TEXT('0') + (value % 10);

        value = value / 10;
    } while( value != 0 );

    for( psz--, pszOut = sz; psz >= szTmp; psz-- )
        *pszOut++ = *psz;

    *pszOut = TEXT('\0');

    return sz;
}

#ifdef UNICODE
#   if 0
double MyAtof( const WCHAR *string ) {
    char szAnsi[MAX_PATH];

    WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK, string, -1, szAnsi, sizeof(szAnsi), NULL, NULL );
    return atof( szAnsi );
}


WCHAR *MyGcvt( double value, int digits, WCHAR *buffer ) {
    char szAnsi[MAX_PATH];

    _gcvt( value, digits, szAnsi);

    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1, buffer, MAX_PATH);
    return buffer;
}

#   endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\cal.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 *   cal.c
 *
 */

#include "cal.h"

BOOL FAR APIENTRY IsDefaultPrinterStillValid(LPSTR);

/**** FCalSize ****/

BOOL APIENTRY FCalSize (
     HWND hwnd,
     INT x,
     INT y,
     INT code)
     {
     INT     cy, ytop, cx, xleft,
             cyUseable, vclnOld, dln = 0,
             tmp, dx, dy;


     if (hwnd==vhwnd0)
	  {
	  /* Store appointment currently being edited so it gets repainted
           *  by DayPaint.
           */

	  if (GetFocus () == vhwnd3)
	  {
	       StoreQd ();
	  }

	  switch (code)
	       {
	       case SIZEFULLSCREEN:
	       case SIZENORMAL:
                    MoveWindow(vhwnd1, xleft=XcoWnd1(),
                                ytop=YcoWnd1(), vcxWnd1,
                                vcyWnd1, TRUE);

                    cy = vcyWnd2B;

                    if (cy > y-ytop-vcyWnd2A)
                        cy=y-ytop-vcyWnd2A;

                    cx = vcxWnd1 - vcxBorder;

                    if (cx > x-xleft)
                        cx=x-xleft;

                    MoveWindow(vhwnd2B, 0, vcyWnd2A, cx, cy, FALSE);

		    /* Reset global variables according to new window size. */
                    cyUseable = cy - 2 * vcyBorder - vcyExtLead ;
		    vclnOld = vcln;
		    vcln = cyUseable/vcyLineToLine;

		    /* Always display at least one line.  In addition to
		       avoiding div by 0 errors, this shows user that there
		       is something that is "trying" to be displayed even if
		       there is not enough space. */
			//- FCalSize: Fixed to handle vcln < 0.
		    if (vcln <= 0)
				vcln = 1;
		    vlnLast = vcln-1;

		    /* If we're in day mode, reset the scroll range so user
		       can scroll 11:00 pm to bottom of window.  (If in month
		       mode, smallest unit of scrolling is one month.) */

		    /* foll. lines set up vertical scroll globals  for month view
		       Set vmScrollMax so that if less than a certain fraction of
		       the bottom line is visible, scrolling should be possible.
                       This has been determined by trial and error
                     */

		    dy = (vcyWnd2BBot - vcyBorder)/ vcWeeksMonth;
                    tmp = y/dy;

		    if ((y%dy) < (5*dy/6))
                       tmp--;

		    vmScrollMax =max ( 0, vcWeeksMonth + 1 - tmp);
		    vmScrollPos = 0;

		    /* foll lines set up horizontal scroll globals for month view
		       Set hmScrollMax so that if less than a certain fraction of
		       the rightmost column is visible, scrolling should be possible.
		       This has been determined by trial and error */
		    dx = (vcxWnd2B + vcxBorder)/7;
                    tmp = x/dx;

		    if ((x%dx) < (5*dx/6))
                       tmp-- ;

		    hmScrollMax = max (0, 6 - tmp);
		    hmScrollPos = 0;

                    if (vfDayMode)
                        {
			SetDayScrollRange();

			/* If our resizing made window bigger, pick up extra
			   ld records that need to be put in tld.  */
                        if ((dln = vcln - vclnOld) > 0)
                            {
                            while (dln && FGetNextLd(vtld[vlnLast-dln].tm, &vtld[vlnLast-dln+1]))
				dln--;

			    /* If there is going to be extra space at bottom
			       of window, scroll to fill that space. */
			    ScrollDownDay(dln, TRUE, TRUE);

                            }

                        }
                    else
                       {
		       /* set up horiz. and vertical scroll bars in monthmode */

		       SetScrollPos (vhwnd2B, SB_VERT, vmScrollPos, TRUE);
		       SetScrollRange (vhwnd2B, SB_VERT, 0, vmScrollMax,TRUE);

		       SetScrollPos (vhwnd2B, SB_HORZ, hmScrollPos, TRUE);
		       SetScrollRange (vhwnd2B, SB_HORZ, 0, hmScrollMax, TRUE);
                        }
               return (TRUE);
	       }
	  }
     return (FALSE);
     }



/**** CalWndProc ****/

LRESULT APIENTRY CalWndProc (
     HWND       hwnd,
     UINT   message,
     WPARAM     wParam,
     LPARAM     lParam)
     {
     PAINTSTRUCT    ps;
     register BOOL  fActed;         /* TRUE if we acted on the message. */
     HCURSOR        hcsr;
     register WORD  wlParamHi;
     INT            lnT;

     fActed=TRUE;
     wlParamHi=HIWORD(lParam);

     switch(message)
	  {
	  case WM_CLOSE:
	       if (FCheckSave (FALSE))
		    DestroyWindow (vhwnd0);
	       break;

	  case WM_QUERYENDSESSION:
	       return (FCheckSave (TRUE));

	  case WM_DESTROY:
	       if (hwnd == vhwnd0)
		    {
		    /* Time to say goodbye - only field this message
		       for our main window.
                    */

                



		    /* Get rid of the change file - ignore errors since
		       there is nothing to be done about it now and the
		       the user has either said to discard the changes
		       or they have already been saved.
		    */
		    DeleteChangeFile ();

            WinHelp(hwnd, vszHelpFile, HELP_QUIT, 0L);

		    /* Free all global objects */
		    CalTerminate(2);

		    /* Terminate with exit code 0, meaning no errors. */
		    PostQuitMessage (0);
		    }
	       else
                    fActed = FALSE;

	       break;

	  case WM_ENDSESSION:
	       /* If wParam is TRUE, we are never coming back again. */
               if (wParam)
                    DeleteChangeFile ();
		    /* Get rid of the change file - ignore errors since
		       there is nothing to be done about it now and the
		       the user has either said to discard the changes
		       or they have already been saved.
		    */


	       break;

	  case WM_SIZE:
               fActed=FCalSize(hwnd, (SHORT)LOWORD(lParam),
                                  (SHORT)HIWORD(lParam), (int)wParam);
	       break;

	  case WM_PAINT:
	       /* Hiding the caret of the appointment description edit
		  control before painting wnd2B in day mode is necessary
		  to prevent leaving cursor droppings around.  So hide
		  the caret here, and show it after painting.  Note that
		  this is OK even if we're not painting wnd2B, so no
		  extra code is used here to only do it for the wnd2B
		  case.
	       */
	       HideCaret (vhwnd3);

	       BeginPaint (hwnd, &ps);
	       SetDefaultColors (ps.hdc);
	       CalPaint (hwnd, ps.hdc);
	       EndPaint (hwnd, &ps);

	       ShowCaret (vhwnd3);
	       break;

	  case WM_COMMAND:
	       /* HIWORD (lParam) == 0 means a command has been selected
		  via the menu.  1 means a command has been selected
		  via an accelerator.  Something other than 0 or 1 is
		  the window handle of a control sending a notification.
	       */
	       if (GET_WM_COMMAND_CMD (wParam, lParam) <= 1)
		    {
		    /* A menu item has been selected. */
		    CalCommand (hwnd, GET_WM_MENUSELECT_CMD (wParam, lParam));
		    }
	       else
		    {
		    /* Handle notifications from edit controls. */
		    //- EcNotification (wParam, GET_WM_COMMAND_ID(wParam, lParam));
		    EcNotification ((WORD)wParam, (WORD)HIWORD (wParam));

		    /* Even if we handled the message, say we didn't
		       in case something else needs to be done with it.
		    */
		    fActed = FALSE;
		    }
	       break;

          case WM_SYSCOMMAND:

            





		    fActed = FALSE;
	       break;

	  case WM_TIMER:
	       CalTimer (FALSE);
	       break;

	  case WM_TIMECHANGE:
	       CalTimer(TRUE);
	       break;

	  case WM_VSCROLL:
	       if (IsWindowEnabled(vhwnd0))
	       {
		   if (fActed == vfDayMode)
		   {
			FScrollDay (GET_WM_VSCROLL_CODE(wParam, lParam),
				GET_WM_VSCROLL_POS(wParam, lParam));
		   }
		   else
		   {
			FScrollMonth (GET_WM_VSCROLL_CODE(wParam, lParam),
				GET_WM_VSCROLL_POS(wParam, lParam));
		   }
	       }
	       break;

	  case WM_HSCROLL:   /* added  11/3/88 for horiz. scroll in month view */

   /* We have replaced the bitmap arrows with a scrollbar control; So, the
    * following code handles the scroll messages from it
    * Fix for Bug #8560 -- SANKAR -- 01-28-90
    */
#ifndef BUG_8560
	       /* Check if this is the Horizontal Scroll bar control */
	       if(GET_WM_HSCROLL_HWND(wParam, lParam) == vhScrollWnd)
	         {
		    switch(GET_WM_HSCROLL_CODE(wParam, lParam))
		      {
		        case SB_LINEUP:
                          CalCommand (vhwnd0, IDCM_PREVIOUS);
                          break;
			case SB_LINEDOWN:
                          CalCommand (vhwnd0, IDCM_NEXT);
                          break;
                      }
		   break;
		 }
#endif
               if (IsWindowEnabled(vhwnd0))
                  {
		  if (fActed != vfDayMode)
		    FHorizScrollMonth (GET_WM_HSCROLL_CODE(wParam, lParam),
					GET_WM_HSCROLL_POS(wParam, lParam));
		  }


	  case WM_MOUSEMOVE:
	       /* The mouse cursor is an arrow everywhere except when
		  in an appointment description or in the notes area, when
		  it must be the Ibeam.  There are two reasons we can't just
		  let the edit controls take care of this:
		  1) The appointment description edit control only covers
		     one appointment description, and we want the Ibeam
		     to appear on all the descriptions.
		  2) The notes edit control does not use up the entire
		     bottom box of the calendar, and we want the Ibeam in the
		     entire box.  Note that we make the Ibeam start if the
		     cursor is below the line we drew at vycoNotesBox.
	       */
	       hcsr = vhcsrArrow;
	       if (hwnd == vhwnd2B && vfDayMode
                   && (INT)LOWORD (lParam) >= vxcoQdFirst
                   || hwnd == vhwnd1 && (INT)HIWORD (lParam) > vycoNotesBox)

                   hcsr = vhcsrIbeam;

	       SetCursor (hcsr);
	       break;

	  case WM_LBUTTONDBLCLK:
	  case WM_LBUTTONDOWN:
	       if (hwnd == vhwnd1 && (INT)HIWORD (lParam) > vycoNotesBox)
		    {
		    /* Click in the bottom box (below the line at vycoNotesBox)
		       but not in the notes edit control.  Pass the click
		       to the notes edit control.
		       The mouse coordinates we were passed are
		       relative to the origin of wnd1.	Make
		       them relative to the origin of the notes
		       edit control.
		    */
		    ((POINTS*)&lParam)->x -= (short)vxcoWnd2C;
		    ((POINTS*)&lParam)->y -= (short)vycoWnd2C;
		    PostMessage (vhwnd2C, message, wParam, lParam);
		    break;
		    }

	       if (hwnd == vhwnd2A )
		    {

		    /* Double clicking in the date field is the same as
		       using the View Month command (i.e., switch to
		       month mode).
		    */
                    if (message == WM_LBUTTONDBLCLK &&
			   (INT)LOWORD (lParam) >= vxcoDate)
                        {
                        if (vfDayMode)
                            CalCommand (vhwnd0, IDCM_MONTH);
                        else
                            /* Switch back to today */
                            DayMode (&vd3Sel);
                        }

		    break;
		    }

	       if (hwnd == vhwnd2B)
		    {
		    if (vfDayMode)
			 {
			 /* If we just clicked on a new line, "move" edit ctl
			    window to new line.  Otherwise, just pass mouse
			    message to edit ctl. */
			 if ((lnT = LnFromYco (wlParamHi)) != vlnCur) {
			    /* Suppose that the appointment window is not clean.
			      In particular, we are concerned about the
			      rectangle that we are about to put the appointment
			      description edit control on top of.  SetQdEc
			      validates the edit control after moving it to
			      prevent it from repainting, and the ValidateRect
			      call in turn validates that portion of the parent.
			      This means that if it was dirty before calling
			      SetQdEc, it won't get repainted by DayPaint, which
			      it should.  In order to get around this problem,
			      make sure everything is clean before calling
			      SetQdEc.  An example of where this was a problem:
			      Zoom and immediately click on a new appointment.
			      The click was seen before all painting has been
			      done, so a hole was left where the edit control
			      was moved.
			      Force everthing to be clean by calling
			      UpdateWindow for our main window (using
			      wnd2B caused out-of-sequence painting and
			      really left a mess on the screen).
			    */
			    UpdateWindow (vhwnd0);

			    SetQdEc (lnT);
			 }

			 /* Let the edit control see the click too.
			    The mouse coordinates we were passed are
			    relative to the origin of wnd2B.  Make
			    them relative to the origin of the QD
			    edit control.
			 */
			 ((POINTS*)&lParam)->x -= (short)vxcoQdFirst;
			 ((POINTS*)&lParam)->y -= (short)YcoFromLn(vlnCur);
			 PostMessage (vhwnd3, message, wParam, lParam);
			 }
		    else
			 {
			 /* Note - if the mouse position is not on a box for a
			    valid day of the month, the click is ignored.
			    However, we still leave fActed == TRUE since the
			    mouse click has been acted on by us in the sense
			    that we do not expect Windows to do anything
			    further with it.
			 */
			 MouseSelectDay(MAKEMPOINT(lParam),
			      message == WM_LBUTTONDBLCLK);
			 }
		    }
	       else
		    {
		    fActed = FALSE;
		    }
	       break;

	  case WM_KEYDOWN:
	       fActed = FCalKey (hwnd, wParam);
	       break;

	  case WM_ACTIVATE:
	  		if (!fInitComplete)
			{
				fActed = FALSE;
				break;
			}	
				

	       if (GET_WM_ACTIVATE_STATE(wParam, lParam))
		    {
		    /* Becoming active. */

		    /* If not iconic, give the focus to the last one who
		       had it.
		    */
		    if (GET_WM_ACTIVATE_FMINIMIZED(wParam, lParam))
			 CalSetFocus (vhwndFocus);

		    /* Tell the user about any alarms that went off while
		       we were inactive.
		    */
		    PostMessage(hwnd, CM_PROCALARMS, 0, 0L);
		    }
	       else
		    {
		    /* Becoming inactive - pass this off to DefWindowProc. */
		    fActed = FALSE;
		    }
	       break;

	  case CM_PROCALARMS:
                uProcessAlarms ();
		break;

	  case WM_SETFOCUS:
	       /* If the monthly calendar is getting the focus, create,
		  position, and show its caret.  Otherwise, do not process
		  this message.
	       */
	       if (hwnd == vhwnd2B && !vfDayMode)
		    {
		    /* Create a caret for month mode.  Specifying NULL for the
		       second parameter gives a black caret.  The third
		       parameter is the width, and by making the fourth
		       parameter 0, we get a height of a horizontal border
		       (same as vcyBorder).
		    */
		    CreateCaret (vhwnd2B, (HBITMAP)NULL, 2 * vcxFont, 0);

		    /* Position the caret to the selected day. */
		    PositionCaret ();

		    /* Make the caret visible. */
		    ShowCaret (vhwnd2B);

		    /* Remember we last had the focus so we get it
		       back when re-activated.
		    */
		    vhwndFocus = vhwnd2B;
		    }
               else if (hwnd == vhwnd0)
                    /* 12-Mar-1987. to make sure focus set somewhere when
                     * parent gets focus.
                     */
                    CalSetFocus (vhwndFocus);
	       else
		    fActed = FALSE;
	       break;

	  case WM_KILLFOCUS:
	       /* If the monthly calendar is losing the focus,
		  destroy its caret.  Otherwise, do not process this message.
	       */
	       if (hwnd == vhwnd2B && !vfDayMode)
		    DestroyCaret ();
	       else
		    fActed = FALSE;
	       break;

	  case WM_SYSCOLORCHANGE:
	       /* The system colors have changed.  Destroy and recreate
		  the brushes.
	       */
	       DestroyBrushes ();
               CreateBrushes ();

               /* Repaint since AppWorkspace color may have changed */
               InvalidateRect(hwnd, NULL, TRUE);
	       break;

	  case WM_ERASEBKGND:
	       PaintBack (hwnd, (HDC)wParam);
	       break;

	  case WM_INITMENU:
	       /* Menu is being pulled down.  Enable/disable, check/uncheck
		  menu items.
	       */
	       InitMenuItems ();
	       break;

	 case WM_WININICHANGE:
	     CalWinIniChange();
	     break;

	 default:
	     fActed = FALSE;
	     break;
	 }

     return (fActed ? 0L : DefWindowProc (hwnd, message, wParam, lParam));
     }


/**** XcoWnd1 - return the xco of where to put Wnd1 */

INT APIENTRY XcoWnd1 ()
     {
     RECT  rect;
     int cxDesired, cxAvailable, xcoLeft;

     GetClientRect (vhwnd0, &rect);
     cxDesired = vcxWnd1;
     cxAvailable = rect.right - rect.left;
     xcoLeft = 0;
     if (cxAvailable > cxDesired)
          xcoLeft = (cxAvailable - cxDesired) / 2;

#ifdef DISABLE
     return (max (xcoLeft, vcxFont));
#endif
     return (xcoLeft);
     }




/**** YcoWnd1 - return the yco of where to put Wnd1 */

INT APIENTRY YcoWnd1 ()
     {
     RECT  rect;
     INT   cyAvailable;
     INT   ycoTop;

     GetClientRect (vhwnd0, &rect);
     cyAvailable = rect.bottom - rect.top;
     ycoTop = 0;
     if (cyAvailable > vcyWnd1)
	  ycoTop = (cyAvailable - vcyWnd1) / 2;
#ifdef DISABLE
     return (max (ycoTop, vcyBorder));
#endif
     return (ycoTop);
     }




/**** CalSetFocus - Set the focus unless vfNoGrabFocus is set.	This
      is used to prevent Calendar from grabbing the focus if brought
      up iconic.
*/

VOID APIENTRY FAR CalSetFocus (HWND hwnd)
     {
     if (!vfNoGrabFocus)
	  SetFocus (hwnd);
     }


/**** InitMenuItems */

VOID APIENTRY InitMenuItems ()
     {
     register WORD mf1;
     register WORD mf2;
     HMENU         hMenu;
     WORD2DWORD    iSelFirst;
     WORD2DWORD    iSelLast;
     UINT      wFmt;

     /* Get a handle to the menu. */
     hMenu = GetMenu (vhwnd0);

     /* Cut and Copy - enable iff edit control has focus and
	some text is selected.
	Paste - enable iff edit control has focus and the clipboard
	is not empty.
     */
     mf1 = mf2 = MF_GRAYED;
     if (vhwndFocus != vhwnd2B)
	  {
	  /* Focus is not on monthly calendar so it must be on either
	     the appointment edit control or the notes edit control.
	  */

	  /* Enable Cut and Copy if the selection isn't null. */
	  MSendMsgEM_GETSEL(vhwndFocus, &iSelFirst, &iSelLast);
	  if (iSelFirst != iSelLast)
	       mf1 = MF_ENABLED;

	  /* Enable Paste if the clipboard isn't empty. */
	  if (OpenClipboard (vhwnd0))
	       {
		wFmt = 0;
		/* If clipboard has any text data, enable paste item.  otherwise
		   leave it grayed. */
		while ((wFmt = EnumClipboardFormats(wFmt)) != 0)
		    {
		    if (wFmt == CF_TEXT)
			{
			mf2 = MF_ENABLED;
			break;
			}
		    }
	       CloseClipboard ();
	       }
	  }
     EnableMenuItem (hMenu, IDCM_CUT, mf1);
     EnableMenuItem (hMenu, IDCM_COPY, mf1);
     EnableMenuItem (hMenu, IDCM_PASTE, mf2);

     /* Check day if in day mode, check month if in month mode.
	Uncheck the other.
     */
     mf1 = MF_CHECKED;
     mf2 = MF_UNCHECKED;
     if (!vfDayMode)
	  {
	  mf1 = MF_UNCHECKED;
	  mf2 = MF_CHECKED;
	  }
     CheckMenuItem (hMenu, IDCM_DAY, mf1);
     CheckMenuItem (hMenu, IDCM_MONTH, mf2);

     /* Alarm Set - enable iff focus is on an appointment.
	If enabled, check iff appointment has alarm set.
     */
     mf1 = MF_GRAYED;
     mf2 = MF_UNCHECKED;
     if (vhwndFocus == vhwnd3)
	  {
	  mf1 = MF_ENABLED;
	  if (FAlarm (vlnCur))
	       mf2 = MF_CHECKED;
	  }
     EnableMenuItem (hMenu, IDCM_SET, mf1);
     CheckMenuItem (hMenu, IDCM_SET, mf2);

     /* Options special time - enable if in day mode. */
     mf1 = MF_GRAYED;
     if (vfDayMode)
	  mf1 = MF_ENABLED;
     EnableMenuItem (hMenu, IDCM_SPECIALTIME, mf1);

     }



VOID APIENTRY CalWinIniChange()
    {
    HMENU hMenu;
    SHORT id, nx;
    CHAR  ch;
    static bszDecRead=FALSE;

    /* Set decimal to scan for */
    if (bszDecRead)
        ch=szDec[0]; /* If we already changed it. */
    else
        ch='.';  /* First time. */

    bszDecRead=TRUE;

    /* Get the intl decimal character for use in Page Setup Box. */
    GetProfileString("intl", "sDecimal", ".", szDec, 4);

    /* Scan for . and replace with intl decimal */
    for (id=2; id<6; id++)
        {

        for (nx=0; nx < lstrlen((LPSTR)chPageText[id]); nx++)
            if (chPageText[id][nx]==ch)
                chPageText[id][nx]=szDec[0];
        }


    hMenu = GetMenu(vhwnd0);
    /* Check if a default printer exists */
    /* Fix for Bug #5607 --SANKAR-- 10-30-89 */
    if(bPrinterSetupDone)
      {
        if(!IsDefaultPrinterStillValid((LPSTR)szPrinter))
	    bPrinterSetupDone = FALSE; /* No longer valid */
      }
#ifdef SLOWTHINGSDOWN
    if (!(hdc = GetPrinterDC()))
	{
	EnableMenuItem(hMenu, IDCM_PRINT, MF_GRAYED);
	}
    else
	{
	DeleteDC(hdc);
	EnableMenuItem(hMenu, IDCM_PRINT, MF_ENABLED);
	}
#endif
    InitTimeDate (vhInstance, vfHour24 ? GTS_24HOUR : GTS_12HOUR);


    /* Force repainting of windows that contain date time strings. */
    InvalidateRect(vhwnd0,  NULL, TRUE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calc\wassert.c ===
/****************************Module*Header***********************************\
* Module Name: WASSERT
*
* Module Descripton: Quick Win32 assert code.
*
* Warnings:
*
* Created: 15 July 1993
*
* Author: Raymond E. Endres   [rayen@microsoft.com]
\****************************************************************************/

#include <windows.h>
#include "wassert.h"

#ifdef _DEBUG

void vAssert(TCHAR * pszExp, TCHAR * pszFile, int iLine)
{
   TCHAR  szTmp[1024];
   int iReply;

   wsprintf(szTmp, TEXT("Assertion (%s) at line %d, file %s failed.\nPress Abort to quit the program, Retry to debug the program, or Ignore to continue."),
            pszExp, iLine, pszFile);
   iReply = MessageBox(NULL, szTmp, TEXT("Assertion failed:"), MB_ABORTRETRYIGNORE | MB_TASKMODAL );
   switch ( iReply )
   {
   case IDABORT:
       PostQuitMessage( -1 );
       break;
 
   case IDRETRY:
       DebugBreak();
       break;

   case IDIGNORE:
   default:
       // do nothing, program will try to continue;
       break;
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\cal.h ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** cal.h
 *
*/



/* Get rid of some stuff from windows.h. */
#define NOGDICAPMASKS
#define NOATOM
#define NOWH
#define NOSOUND
#define NOATOM
#define NOCOMM
#define NOMETAFILE
#define NOREGION
#define NOKANJI

#include <stdlib.h>	 /* Get declaration for errno. */
#include <windows.h>
#ifndef RC_INVOKED
#include <port1632.h>
#endif
#include <commdlg.h>

#define LSTRING
#include "..\\common\\date.h"        /* Common date/time stuff */
#include <io.h>                      /* Get I/O function declarations. */
#include <errno.h>                   /* Get definitions of error codes. */

typedef short   SINT;

/* Note - I have avoided using frequently occuring sequences of letters
   for data types.  While the loss of mnemonic value is regrettable,
   it is less important than being able to easily search for occurences of
   the data type.  For example, an appointment record is QR instead of AR,
   because searching for "ar" doesn't work well (char, far, and all sorts
   of English words in comments).
*/

typedef WORD DT;	      /*** DT - date packed into 2 bytes - the number
                                   of days since January 1, 1980. */

#define PT_LEN 50


#define DTNIL (DT)0xFFFF	      /* An impossible DT.  Note that by making this
				 the largest possible value, it can safely
				 be used in vftAlarmFirst.dt and
				 vftAlarmNext.dt and have comparisons work
				 properly.  For example, if vftAlarmNext.dt
				 == DTNIL, there is no next alarm, and
				 the current FT will never look greater or
				 equal, so the alarm can't go off.
			      */
#define DTFIRST (DT)0	      /* The DT for January 1, 1980. */
#define DTLAST (DT)0xAB35	      /* The DT for December 31, 2099. */

typedef SINT OBK;	      /*** Offset in Blocks within a file -
				   From 0 through 32765, so it
				   uses only 15 bits and does not include
				   DLNIL or DLNOCHANGE.
				*/

typedef WORD DL;	      /*** DL - Date Location.	Bit 15 is 0
				   if the date is in the original file,
				   1 if it's in the change file.  Bits
				   0 through 14 contain the OBK.
				   If the date is in neither file, the
				   DL is DLNIL.
			      */
#define DLNIL (DL)0xFFFF	      /* An impossible DL - it means the date is
				 not in a file.
			      */
#define DLNOCHANGE (DL)0xFFFE     /* An impossible DL that means don't change
				 the old DL.
			      */
#define DLSPECIALLOW (DL)0xFFFE   /* The lowest special DL. */

#define DLFCHANGEFILEMASK (DL)0x8000   /* Mask for getting at the change file
				      flag in a DL.
				   */
#define DLOBKMASK (DL)0x7FFF	   /* Mask for getting at the OBK in a DL. */
#define BLOCKWRITE 0x0010	   /* mask for disallowing other copies of
				      calendar from writing the same file */
typedef struct
	  {
	  DT	    dt; 		/* Date */
	  SINT	    fMarked;		/* appropriate bit is set if
					   date is marked. */
	  SINT	    cAlarms;		/* Count of alarms set. */
	  DL	    dl; 		/* Where the date is stored. */
	  WORD	    idr;		/* The index into vrghlmDr if
					   the date is in memory.  If not
					   in memory, this is IDRNIL.
					*/
	  DL	    dlSave;		/* Used to hold the previous DL
					   during a Save operation.  This
					   is used for error recovery.
					*/
	  } DD; 	      /*** DD - Date Descriptor */


typedef struct			   /*** D3 - date in three parts */
	   {
	   WORD     wMonth;	   /* 0 through 11 */
	   WORD     wDay;	   /* 0 through 30 */
	   WORD     wYear;	   /* 0 (1980) through 119 (2099) */
	   } D3;

#define MONTHJAN 0	      /* Representation of January in a D3.wMonth */
#define MONTHFEB 1	      /* Representation of February in a D3.wMonth */
#define MONTHDEC 11	      /* Representation of December in a D3.wMonth */
#define YEAR1980 0	      /* Representation of 1980 in a D3.wYear */
#define YEAR2099 119	      /* Representation of 2099 in a D3.wYear */

typedef SINT TM; 	      /*** - Time packed into an int - the number of
				     minutes since midnight.
			      */
#define TMLAST (TM)(24 * 60 - 1)
#define TMNILHIGH (TM)(TMLAST + 1)
#define TMNILLOW (TM)-1
#define TMNOON (TM)(12 * 60)

typedef struct
     {
     DT   dt;		      /* Date */
     TM   tm;		      /* Time */
     } FT;		      /*** FT - Full Time (date and time) */

#define OTQRNIL 0xFFFF

#ifndef RC_INVOKED
#pragma pack(1)
typedef struct
     {
     SINT  cb : 8;	      /* Count of bytes in this QR. */
     SINT  fAlarm : 1;	      /* TRUE if alarm set. */
     SINT  fSpecial : 1;      /* TRUE if special time. */
     SINT  reserved : 6;      /* Reserved for future use - 0 filled. */
     TM        tm;	      /* Appointment Time. */
     CHAR      qd [1];	      /*** -  QD - Appointment Description.  Up to
				      CCHQDMAX + 1 chars but declared as a
				      single char here since storage is
				      dynamically allocated.  Not AD since
				      we want to be able to search for this
				      data type.
			      */
     } QR;
     typedef QR UNALIGNED *PQR;    /*** QR - Appointment Record - not AR since
			       we want to be able to search for this data type.
			      */
#pragma pack()
#endif /* RC_INVOKED */

/* Count of bytes in a QR header (everything except the QD). */
#define CBQRHEAD (sizeof (QR) - sizeof (char))




/* !!! WARNING - If CCHQDMAX is changed, be sure to adjust the ACKALARM
   dialog in CALENDAR.RC (since the resource compiler can't multiply or
   divide, and it also seems that it doesn't support the use of symbolic
   constants for specifying the positions or sizes of controls.  Note
   that this value also affects the forced word-wrap in calprint.c!
 */

#define CCHQDMAX 80           /* Maximum number of text characters in
				 an appointment description (does not
				 include the zero byte terminator).
                               */

#define PAGENUMMAX  4	      /* max num. digits of page number displayable
                                 in header or footer */

#define CCHJUST     3	      /* size of array containing justified
                                 header/footer info */

#define CCHNONJUST  10	      /* size of array containing non-justified
                                 header/footer info */

/* !!! WARNING END */



#define CBNOTESMAX 400        /* Maximum length of notes including unformatted
				 text, soft line breaks, and 0 terminator.
                               */

#define CLNNOTES 3	      /* The number of lines of notes. */

/* A soft line break takes 3 characters <CR,CR,LF>.  All but the last line
   of the notes area can end with a soft line break.  This is the count
   of bytes needed to accomodate that case.
 */
#define CBSOFTBREAKSMAX (3 * (CLNNOTES - 1))


/* The maximum length of the unformatted text of the notes (reserve
   space for 0 terminator and soft line breaks).
 */
#define CBNOTESTEXTMAX (CBNOTESMAX - 1 - CBSOFTBREAKSMAX)



typedef struct
     {
     TM        tm;	      /* Appointment time. */
     WORD     otqr;	      /* Offset into tqr. */
     } LD;		      /*** - Line Descriptor. */


#define CBBK 64     /*** BK - disk block.  The size of a disk block
			 (Calendar's fundamental unit of allocation).
		    */


/* !!! WARNING - Be sure to adjust CDRHEAD when when modifying the
   definition of a DR.	Also note that except for the dt member,
   all members can be initialized to 0 (dt must be set to DTNIL).
 */

/* The maximum size of a DR.  Must be a multiple of CBBK. */
#define CBKDRMAX 32
#define CBDRMAX (CBKDRMAX * CBBK)

/* The size of the header. */
#define CBDRHEAD (sizeof (SINT) + sizeof (DT) + sizeof (SINT) + sizeof (SINT) + sizeof (SINT))

/* The count of bytes allocatable for the notes and the tqr. */
#define CBDRDATAMAX (CBDRMAX - CBDRHEAD)

/* The count of bytes available for the tqr. */
#define CBTQRMAX (CBDRDATAMAX - CBNOTESMAX)

typedef struct
     {
     SINT wReserved;		   /* Reserved for future use - written out
				      as 0.
				   */
     DT   dt;			   /* The associated dt.  DTNIL means this
				      DR is not in use.
				   */
     SINT fDirty;		   /* TRUE if modifications have been made. */
     WORD cbNotes;		   /* Length of notes. */
     WORD cbTqr;		   /* Length of tqr. */
     BYTE rgbData [CBDRDATAMAX];   /* Room for the notes and the tqr. */
     } DR;		 /*** DR - Date Record */

/* !!! WARNING END */

#define CDR 3		      /* The number of DRs in memory. */
#define IDRNIL (WORD)0xFFFF	      /* An inpossible idr. */

/* The maximum length of a file specification in DOS 3.0, including
   the device, directories, filename, and extension.
*/
#define CCHFILESPECMAX 128
#define CCHFILTERMAX   64      /* max. length of filter string for Fileopen */


/* Filename (8) plus period (1) plus extension (3). */
#define CCHFILENAMEANDEXTMAX 12

/* Enough room for "Calendar - filename.cal" plus the terminator (which
   is included in CCHSZCALENDARDASH).
*/
#define CCHSZWINDOWTEXTMAX (CCHSZCALENDARDASH + CCHFILENAMEANDEXTMAX)

/* The sizes of the items in the header BK. */
#define CBMAGIC 8
#define CBCDD sizeof (SINT)
#define CBMINEARLYRING sizeof (SINT)
#define CBFSOUND sizeof (SINT)
#define CBMDINTERVAL sizeof (SINT)
#define CBMININTERVAL sizeof (SINT)
#define CBFHOUR24 sizeof (SINT)
#define CBTMSTART sizeof (TM)

/* Offsets into the file header BK. */
#define OBMAGIC 0
#define OBCDD (OBMAGIC + CBMAGIC)
#define OBMINEARLYRING (OBCDD + CBCDD)
#define OBFSOUND (OBMINEARLYRING + CBMINEARLYRING)
#define OBMDINTERVAL (OBFSOUND + CBFSOUND)
#define OBMININTERVAL (OBMDINTERVAL + CBMDINTERVAL)
#define OBFHOUR24 (OBMININTERVAL + CBMININTERVAL)
#define OBTMSTART (OBFHOUR24 + CBFHOUR24)


#define CBMONTHARRAY 56       /* Number of bytes in the month array. was 49 */

#define GRAYOUT (DWORD)0x00FA0089  /* dest = dest OR pattern */

#define CCHMONTH 20	      /* The longest month name. */
#define CCHYEAR 4	      /* Chars in a year (e.g., 1985). */
#define CCHTIMESZ 12	      /* Absolute maximum number of chars in a zero
				 terminated time string, taking into account
				 international formats.  4 plus space plus
				 6 CHAR AM/PM string plus 0 at end.
			      */
#define SAMPLETIME 600	      /* arbitrary time used for calculating
				 length of a time string in daymode */

#define CCHDATEDISP 64	      /* The number of characters in a zero
				 terminated ASCII date string.
				 30 is large enough for US style
				 strings, so 64 ought to do it for all
				 else.
			      */
#define CCHBUFMAX 256
#define LRMARGINMAX 30	      /* max. allowable left+right margin */
#define TBMARGINMAX 15	      /* max. allowabe top+bottom margin */
#define CCHDASHDATE 11	      /* Maximum length of zero terminated
				 dashed date string.  For example,
				 "10-28-1985" (10 + zero byte).
			      */
#define MAXHDRFTRLENGTH 80     /* maximum length of header/footer */

#define MARK_BOX	  128  /* Bit indicating the date is marked. */
#define MARK_PARENTHESES  256  /* Bit indicating the date is marked. */
#define MARK_CIRCLE	  512  /* Bit indicating the date is marked. */
#define MARK_CROSS	 1024  /* Bit indicating the date is marked. */
#define MARK_UNDERSCORE  2048  /* Bit indicating the date is marked. */


#define TODAY  64	      /* Bit indicating the date is today. */

#define CLEARMARKEDBITS 127   /* bit mask for clearing marked bits */

#define SCROLLMONTHLAST 1439  /* Can scroll from 0 to SCROLLMONTHLAST while
				 in month mode.  (2099 - 1980 + 1) * 12 - 1.
			      */
#define TWELVEHOURS  720      /* number of minutes in half a day */
#define MDINTERVAL15 0	      /* Interval is 15 minutes. */
#define MDINTERVAL30 1	      /* Interval is 30 minutes. */
#define MDINTERVAL60 2	      /* Interval is 60 minutes. */

#define LNNIL (LN)-1	      /* An invalid ln. */

#define ALARMBEEP 0	      /* Value sent to MessageBeep. */
#define CALARMBEEPS 4	      /* The total number of beeps in an alarm. */


/* Menu command ids. */

#define IDCM_NEW	      0
#define IDCM_OPEN	      1
#define IDCM_SAVE	      2
#define IDCM_SAVEAS	      3
#define IDCM_PRINT	      4
#define IDCM_REMOVE	      5

#define IDCM_CUT	      6
#define IDCM_COPY	      7
#define IDCM_PASTE	      8

#define IDCM_DAY	      9
#define IDCM_MONTH	      10

#define IDCM_TODAY	      11
#define IDCM_PREVIOUS	      12
#define IDCM_NEXT	      13
#define IDCM_DATE	      14

#define IDCM_SET	      15
#define IDCM_CONTROLS	      16

#define IDCM_MARK	      17
#define IDCM_SPECIALTIME      18
#define IDCM_DAYSETTINGS      19

#define IDCM_ABOUT	      20
#define IDCM_DEL	      21
#define IDCM_EXIT             22

/* 26-Mar-1987 */
#define IDCM_START            23
#define IDCM_START12          24

/* 18-Nov-88 page setup and help menu ids */

#define IDCM_PAGESETUP       132
#define IDCM_PRINTERSETUP    100
#define IDCM_ACTIVEWINDOW    134

/* Standard IDS */

#define IDCM_SEARCH          33

#define IDCM_USINGHELP       40
#define IDCM_HELP            41

/* Dialog ids.
   !!! WARNING - The dialog ids are also used to index vrglpfnDialog
   so they must be consecutive integers starting at 1, and must match
   the entries in vrglpfnDialog.  Apparently a dialog id of 0 is unacceptable,
   so they begin with 1, and we subtract 1 to get the index into
   vrglpfnDialog.
*/
#define CIDD                 10     /* The number of dialog ids in
				      vrglpfnDialog. Changed from 9 to
				      10 on 11/8/88  on adding new dialog
				      box for multiple symbol day marking.
				   */
#define IDD_SAVEAS	      1
#define IDD_PRINT	      2
#define IDD_REMOVE	      3
#define IDD_DATE	      4
#define IDD_CONTROLS	      5
#define IDD_SPECIALTIME       6
#define IDD_DAYSETTINGS       7
#define IDD_ABOUT	      8
#define IDD_ACKALARMS         9
#define IDD_PAGESETUP         10   /* for the new Page Setup Dialog */

#define IDD_OPEN              11   /* The open dialog is not included in
                                    * vrglpfnDialog since it is taken
                                    * care of by dlgopen.c.
                                    */

#define IDD_MARK              12   /* putting this in vrglpfnDialog and
				      increasing CIDD did not work */

#define IDD_ABORTPRINT        14   /* The abort print dialog is not included
                                      in vrglpfnDialog.
				   */



/* !!! WARNING END */

/* Control ids */

#define IDCN_IGNORE	      -1

/* IDOK is 1, and IDCANCEL is 2 from windows.h */

#define IDCN_EDIT	      3
#define IDCN_LISTBOX	      4
#define IDCN_PATH	      5
#define IDCN_FROMDATE	      6
#define IDCN_TODATE	      7
#define IDCN_EARLYRING	      8
#define IDCN_SOUND	      9
#define IDCN_INSERT	      10
#define IDCN_DELETE	      11
#define IDCN_MIN15	      12
#define IDCN_MIN30	      13
#define IDCN_MIN60	      14
#define IDCN_HOUR12	      15
#define IDCN_HOUR24	      16
#define IDCN_STARTINGTIME     17

/* foll ids added 11/8/88 for multiple-symbol marking */

#define IDCN_MARKBOX	      18
#define IDCN_MARKPARENTHESES  19
#define IDCN_MARKCIRCLE       20
#define IDCN_MARKCROSS	      21
#define IDCN_MARKUNDERSCORE   22

#define IDCN_AM 	      23
#define IDCN_PM 	      24
#define IDCN_LISTBOXDIR       25  /* for the new Open File Dialog */
#define IDCN_TEXT	      26  /* for new Open File Dialog */
#define IDCN_READONLY         27  /* for new Open File Dialog */

/* Keep these in sequence. */
/* for Page Setup Dialog   */
#define IDCN_EDITHEADER       28
#define IDCN_EDITFOOTER       29
#define IDCN_EDITMARGINLEFT   30
#define IDCN_EDITMARGINRIGHT  31
#define IDCN_EDITMARGINTOP    32
#define IDCN_EDITMARGINBOT    33


#define IDECQD		      100	/* ID of appointment description
					   edit control.
					*/
#define IDECNOTES	      101	/* ID of notes area edit control. */

#ifndef  BUG_8560
/* The Child window Id for the scrollbar control  */
#define IDHORZSCROLL   201
#endif


/* File ids.
   !!! WARNING - if the order of these is changed, the GIVEME string IDS must
       also be changed.
*/
#define IDFILEORIGINAL 0
#define IDFILECHANGE 1
#define IDFILENEW 2
#define CFILE 3 	      /* Number of files. */
/* !!! WARNING END */

#define CCHSZCALENDARDASH          50   /* Length of string "Calendar - ",
					   including the termintor.  If the
					   string is changed in the .RC file,
					   this must be changed accordingly.
					*/

/* String ids. */

#define IDS_UNTITLED		   0
#define IDS_CALENDAR		   1
#define IDS_BADDATE		   2
#define IDS_BADDATERANGE	   3
#define IDS_BADTIME		   4
#define IDS_NOCREATECHANGEFILE	   5
#define IDS_NOCHANGEFILE	   6
#define IDS_ERRORWRITINGCHANGES    7
#define IDS_ERRORREADINGDATE	   8
#define IDS_TIMETOSAVE		   9
#define IDS_OUTOFMEMORY 	   10
#define IDS_RENAMEFAILED	   11
#define IDS_SAVEFAILED		   12
#define IDS_DISKFULL		   13
#define IDS_FILEEXISTS		   14
#define IDS_SAVECHANGES 	   15
#define IDS_FILENOTFOUND	   16
#define IDS_NOTCALFILE		   17
#define IDS_CANNOTREADFILE	   18
#define IDS_BADEARLYRING	   19
#define IDS_NOTSPECIALTIME	   20
#define IDS_NOSUCHTIME		   21
#define IDS_TIMEALREADYINUSE	   22
#define IDS_CANNOTPRINT 	   23
#define IDS_CALENDARDASH	   24
#define IDS_TOOMANYDATES           25
#define IDS_DATEISFULL             26
#define IDS_TEXTTRUNCATED          27


/* The GIVEME strings must be ordered according to the order of the
   IDFILEs (which are defined earlier in this file).
*/
#define IDS_GIVEMEFIRST            28
#define IDS_GIVEMEORIGINAL         28
#define IDS_GIVEMECHANGEFILE       29
#define IDS_GIVEMENEW              30

#define IDS_BADFILENAME            31

#define IDS_NEDSTP                 32
#define IDS_NEMTP                  33
#define IDS_ALARMSYNC              34
#define IDS_NOTIMER                35
#define IDS_DATERANGE              36
#define IDS_DATESUBRANGE           37
#define IDS_TIMESUBRANGE           38
#define IDS_NOCREATE               39
#define IDS_MERGE1                 40
#define IDS_FILEEXTENSION          41

#define IDS_FILEREADONLY           42  /* string id for Read Only error msg */
#define IDS_BLANK                  43  /*   "     "  "  a blank character */
#define IDS_MARKCIRCLE             44  /*   "     "  "  a "o" mark symbol */
#define IDS_MARKLEFTPAREN          45  /*   "     "  "  a "(" mark symbol */
#define IDS_MARKRIGHTPAREN         46  /*   "     "  "  a ")" mark symbol */
#define IDS_MARKCROSS              47  /*   "     "  "  a "*" mark symbol */
#define IDS_PNAMEPREFIX            48  /*   "     "  "  "\\*" string */
#define IDS_BLANKSTRING            49  /* string composed of blank characters */
#define IDS_HELPFILE               50  /* Help filename */
#define IDS_INCORRECTSYNTAX        51
#define IDS_LETTERS                52  /* letters used in Page Setup */
#define IDS_FILTERTEXT		   53  /* Filter text for File/Open dialog */
#define IDS_ALLFILES  		   54  /* more Filter text */
#define IDS_OPENCAPTION 	   55  /* caption text for fileopen dlg */
#define IDS_SAVEASCAPTION	   56  /* caption text for saveas dlg */

#define IDS_HEADER             100  /* Page Setup stuff. */
#define IDS_FOOTER             101
#define IDS_LEFT               102
#define IDS_RIGHT              103
#define IDS_TOP                104
#define IDS_BOTTOM             105


#define CSTRINGS 56		   /* The number of strings loaded from the
				      resource file.
				   */

#define CCHSTRINGSMAX 3500         /* The total length of all loaded strings
				      must be less than or equal to this.
				      If this is exceeded, CalInit will fail,
				      preventing Calendar from running.  If
				      this should occur, CCHSTRINGSMAX should
				      be increased as necessary and the initial
				      heap size in CALENDAR.DEF should also
				      be increased accordingly.  was 2048
				   */

/* Message posted to self upon receiving activate message */
#define CM_PROCALARMS		  WM_USER+100


#ifndef RESOURCE
/* Abbreviations for referencing the loaded strings. */
#define vszUntitled		   vrgsz [IDS_UNTITLED]
#define vszCalendar		   vrgsz [IDS_CALENDAR]
#define vszBadDate		   vrgsz [IDS_BADDATE]
#define vszBadDateRange 	   vrgsz [IDS_BADDATERANGE]
#define vszBadTime		   vrgsz [IDS_BADTIME]
#define vszNoCreateChangeFile	   vrgsz [IDS_NOCREATECHANGEFILE]
#define vszNoChangeFile 	   vrgsz [IDS_NOCHANGEFILE]
#define vszErrorWritingChanges	   vrgsz [IDS_ERRORWRITINGCHANGES]
#define vszErrorReadingDate	   vrgsz [IDS_ERRORREADINGDATE]
#define vszTimeToSave		   vrgsz [IDS_TIMETOSAVE]
#define vszOutOfMemory		   vrgsz [IDS_OUTOFMEMORY]
#define vszRenameFailed 	   vrgsz [IDS_RENAMEFAILED]
#define vszFileExtension	   vrgsz [IDS_FILEEXTENSION]
#define vszSaveFailed		   vrgsz [IDS_SAVEFAILED]
#define vszDiskFull		   vrgsz [IDS_DISKFULL]
#define vszFileExists		   vrgsz [IDS_FILEEXISTS]
#define vszSaveChanges		   vrgsz [IDS_SAVECHANGES]
#define vszFileNotFound 	   vrgsz [IDS_FILENOTFOUND]
#define vszNotCalFile		   vrgsz [IDS_NOTCALFILE]
#define vszCannotReadFile	   vrgsz [IDS_CANNOTREADFILE]
#define vszBadEarlyRing 	   vrgsz [IDS_BADEARLYRING]
#define vszNotSpecialTime	   vrgsz [IDS_NOTSPECIALTIME]
#define vszNoSuchTime		   vrgsz [IDS_NOSUCHTIME]
#define vszTimeAlreadyInUse	   vrgsz [IDS_TIMEALREADYINUSE]
#define vszCannotPrint		   vrgsz [IDS_CANNOTPRINT]
#define vszCalendarDash 	   vrgsz [IDS_CALENDARDASH]
#define vszTooManyDates 	   vrgsz [IDS_TOOMANYDATES]
#define vszDateIsFull		   vrgsz [IDS_DATEISFULL]
#define vszTextTruncated	   vrgsz [IDS_TEXTTRUNCATED]
#define vszBadFileName		   vrgsz [IDS_BADFILENAME]
#define vszAlarmSync		   vrgsz [IDS_ALARMSYNC]
#define vszFileReadOnly 	   vrgsz [IDS_FILEREADONLY]
#define vszBlank		   vrgsz [IDS_BLANK]
#define vszPathnamePrefix	   vrgsz [IDS_PNAMEPREFIX]
#define vszMarkLeftParen	   vrgsz [IDS_MARKLEFTPAREN]
#define vszMarkRightParen	   vrgsz [IDS_MARKRIGHTPAREN]
#define vszMarkCircle		   vrgsz [IDS_MARKCIRCLE]
#define vszMarkCross		   vrgsz [IDS_MARKCROSS]
#define vszBlankString             vrgsz [IDS_BLANKSTRING]
#define vszHelpFile                vrgsz [IDS_HELPFILE]
#define vszIncorrectSyntax         vrgsz [IDS_INCORRECTSYNTAX]
#define vszTooManyDates            vrgsz [IDS_TOOMANYDATES]
#define vszDateIsFull              vrgsz [IDS_DATEISFULL]
#define vszTextTruncated           vrgsz [IDS_TEXTTRUNCATED]
#define vszFilterText		   vrgsz [IDS_FILTERTEXT]
#define vszAllFiles  		   vrgsz [IDS_ALLFILES]
#define vszOpenCaption		   vrgsz [IDS_OPENCAPTION]
#define vszSaveasCaption	   vrgsz [IDS_SAVEASCAPTION]

/* This must go at the end since it may use typedefs from cal.h */
#include "declare.h"
#include "..\\common\\common.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\cal2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** cal2.c
 *
 */

#include "cal.h"
#include <time.h>


HDC vhDCTemp;            /* Save code by not having to pass the HDC on each
                            call to DrawArrow and DrawArrowBorder. */


/**** CalPaint ****/

VOID APIENTRY CalPaint (
     HWND hwnd,
     HDC  hDC)
     {
     register D3  *pd3;

     if (hwnd == vhwnd1)
	  PatBlt (hDC, 0, vycoNotesBox, vcxWnd2A , vcyBorder, PATCOPY);

     if (hwnd == vhwnd2A)
          {
          DispTime (hDC);

          /* Assume we are in month mode so we will display the
             current date.
           */
          pd3 = &vd3Cur;

	  /* Set up global for DrawArrow and DrawArrowBorder. */
	  vhDCTemp = hDC;

#ifdef BUG_8560
	  /* We want the arrows to have the border color. */
	  SetTextColor (hDC, GetSysColor (COLOR_WINDOWFRAME));

	  /* Draw left arrow. */
	  DrawArrow (vhbmLeftArrow, vxcoLeftArrowFirst);

	  /* Draw border at left end of left arrow. */
	  DrawArrowBorder (vxcoLeftArrowFirst);

	  /* Draw border between left and right arrows. */
	  DrawArrowBorder (vxcoLeftArrowMax);

	  /* Draw right arrow. */
	  DrawArrow (vhbmRightArrow, vxcoRightArrowFirst);

	  /* Draw border to right of right arrow. */
	  DrawArrowBorder (vxcoRightArrowMax - vcxBorder);
#endif

	  /* Set colors back to defaults. */
	  SetDefaultColors (hDC);

	  /* Want to display the page date, not the current date. */
	  pd3 = &vd3Sel;

          DispDate (hDC, pd3);
          return;
          }

     if (hwnd == vhwnd2B)
	  {
	  PatBlt (hDC, 0, 0, vcxWnd2B+ vcxVScrollBar, vcyBorder, PATCOPY);

          if (vfDayMode)
               DayPaint (hDC);
          else
               {
               PaintMonthGrid (hDC);
               PaintMonth (hDC);
               }
          }
     }



#ifdef  BUG_8560
******************* The following are no longer required ********************

/**** DrawArrow ****/

VOID APIENTRY DrawArrow (
     HBITMAP hbm,
     INT     xco)
     {
     SelectObject (vhDCMemory, hbm);
     BitBlt (vhDCTemp, xco, vcyBorder, vcxHScrollBar, vcyHScrollBar,
             vhDCMemory, 0, 0, SRCCOPY);
     }




/**** DrawArrowBorder ****/

VOID APIENTRY DrawArrowBorder (INT  xco)
     {
     PatBlt (vhDCTemp, xco, 0, vcxBorder, vcyWnd2A, PATCOPY);
     }
************************ No longer required ********************************
#endif




/**** DispTime - Display the current time. ****/

VOID APIENTRY FAR DispTime (HDC  hDC)
     {
     CHAR sz [CCHTIMESZ + 2];   /* added 2 for spaces.  19 Sep 89 Clark Cyr */

     /* Convert the time into an ASCII string. */
     GetTimeSz (vftCur.tm, sz);
     lstrcat((LPSTR)sz, (LPSTR)"  ");

     /* Output the time. */
     TextOut (hDC, vcxFont, vcyExtLead, (LPSTR)sz,  lstrlen((LPSTR)sz));
     }




/**** GetTimeSz - convert the time into a zero terminated ASCII string. ****/
INT APIENTRY GetTimeSz (
     TM   tm,            /* The time to convert. */
     CHAR *sz)           /* pointer to the buffer to receive the string -
                            the caller should allocate CCHTIMESZ chars. */
     {
#ifndef NOCOMMON
    DOSTIME dt;

    dt.minutes = tm % 60;
    dt.hour = tm / 60;
    return(GetTimeString(&dt, sz, GTS_LEADINGZEROS | GTS_LEADINGSPACE));
#else
     WORD wHour;

     /* Put in the boiler plate. */
     lstrcpy (sz + 2, ":    ");

     wHour = tm / 60;

     if (!vfHour24)
          {
          lstrcpy (sz + 5, "am");
          if (wHour > 11)
               {
               /* Change to pm, and adjust down the hour. */
               *(sz + 5) = 'p';
               wHour -= 12;
               }
          /* Convert the 0 hour (midnight) to 12 (am is already selected). */
          if (wHour == 0)
               wHour = 12;
          }

     /* Convert the hours to ASCII. */
     ByteTo2Digs ((BYTE)wHour, sz);

     /* Change leading 0 to space if in 12 hour mode. */
     if (!vfHour24 && *sz == '0')
          *sz = ' ';

     /* Convert the minutes to ASCII. */
     ByteTo2Digs ((BYTE)(tm % 60), sz + 3);
#endif
     }



/****  ByteTo2Digs - convert byte to 2 decimal ASCII digits. ****/

VOID APIENTRY ByteTo2Digs (
     BYTE b,             /* The byte to convert from binary to ASCII. */
     CHAR *pch)          /* Pointer to output buffer (must be at least 2
                            chars long.
                          */
     {
     *pch++ = b / 10 + '0';
     *pch = b % 10 + '0';
     }



/**** DispDate - Display date in Wnd2A. */
VOID APIENTRY FAR DispDate (
     HDC  hDC,
     D3   *pd3)
     {
     RECT   rc;
     HBRUSH hbr;

     CHAR sz [CCHDATEDISP];

     /* Convert the current date into an ASCII string. */
     GetDateDisp (pd3, sz);

     /* Erase the background */
     GetClientRect(vhwnd2A, (LPRECT)&rc);
     rc.left = vxcoDate;
     if (hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)))
         {
         FillRect(hDC, (LPRECT)&rc, hbr);
         DeleteObject(hbr);
         }
     else
         FillRect(hDC, (LPRECT)&rc, GetStockObject(WHITE_BRUSH));

     SetBkMode(hDC,TRANSPARENT);
     /*	Output the date. Use transparent mode so we don't erase the background
      * color.
      */
     TextOut (hDC, vxcoDate+2, vcyExtLead, (LPSTR)sz, lstrlen ((LPSTR)sz));
     SetBkMode(hDC,OPAQUE);
     }




/**** GetDateDisp - convert the date to an ASCII string of the form:
      weekday, month, day, year.  For example, "Sunday, March 30, 1985".
****/

VOID APIENTRY GetDateDisp (
    D3   *pd3,
    CHAR *sz)
    {
    DOSDATE dd;

    dd.dayofweek = 0xff;        /* so it'll calculate day of week */
    dd.year = pd3->wYear + 1980;
    dd.month = pd3->wMonth + 1;
    dd.day = pd3->wDay + 1;

    GetLongDateString(&dd, sz, GDS_LONG | GDS_DAYOFWEEK);
    }


/**** FillBuf - fill buffer with specified count of specified byte.
      Return a pointer to the buffer position following the filled bytes.
****/

BYTE * APIENTRY FillBuf (
     BYTE *pb,
     INT  cb,
     BYTE b)
     {
     while (cb--)
          *pb++ = b;

     return (pb);
     }


#ifndef NOCOMMON
/**** WordToASCII - convert word to ASCII digits - return a pointer
      to the first character following the generated digits.
****/

CHAR * APIENTRY WordToASCII (
     WORD  w,                      /* Word to convert. */
     CHAR *pch,                    /* Pointer to output buffer. */
     BOOL  fLeadZero)              /* TRUE for leading zeroes,
                                      FALSE to suppress leading zeroes.
                                    */
     {
     WORD wPlace;
     WORD wDig;

     for (wPlace = 10000; wPlace > 0; wPlace /= 10)
          {
          wDig = w / wPlace;
          w %= wPlace;
          if (wDig != 0 || fLeadZero || wPlace == 1)
               {
               *pch++ = wDig + '0';

               /* After the first digit gets put down, we're no longer
                  going to see leading zeros.  Prevent additional zeroes
                  from being suppressed by setting fLeadZero to TRUE.
               */
               fLeadZero = TRUE;
               }
          }

     return (pch);
     }

#endif




/**** GetDashDateSel - convert the selected date to an ASCII string
      of the form: mm-dd-yyyy.  For example, "4-21-1985".
****/

VOID APIENTRY GetDashDateSel (CHAR *sz)
     {
#ifndef NOCOMMON
    DOSDATE dd;

    dd.month = vd3Sel.wMonth + 1;
    dd.day = vd3Sel.wDay + 1;
    dd.year = vd3Sel.wYear + 1980;
    GetDateString(&dd, sz, GDS_SHORT);
#else
     sz = WordToASCII ((WORD)(vd3Sel.wMonth + 1), sz, FALSE);
     *sz++ = '-';
     sz = WordToASCII ((WORD)(vd3Sel.wDay + 1), sz, FALSE);
     *sz++ = '-';
     *(WordToASCII ((WORD)(vd3Sel.wYear + 1980), sz, FALSE)) = '\0';
#endif
     }



/**** FGetTmFromTimeSz
      The format for inputting the time is: [h]h[:mm][a|am|p|pm]
      In other words:
      - at least one digit must be used to specify the hour (even if it's 0)
      - the minutes are optional but if specified must be two digits preceded
        by a colon
      - the am/pm designation is optional and can be abbreviated by just a or p
      - The am/pm designation can use any combination of upper and lower case
      - If hours > 12 then OK if pm specified, but error if am specified.
      - if hours == 0 then OK if am specified, but error if pm specified.
      - If 1 <= hour <= 12 then default to am if no am/pm specification.
****/

INT  APIENTRY FGetTmFromTimeSz (
    CHAR *sz,           /* INPUT - ASCII time string. */
    TM   *ptm)          /* OUTPUT - converted time - unchanged if we
                           return FALSE.
                         */
    {
    DOSTIME dt;
    INT     iErr;

    if ((iErr = ParseTimeString(&dt, sz)) == 0)
    {
        *ptm = dt.hour * 60 + dt.minutes;
        return(TRUE);
    }

    return(iErr);
    }



/**** SkipSpace - skip spaces in a sz. ****/

VOID APIENTRY SkipSpace (CHAR **psz)
     {
     while (**psz == ' ')
          (*psz)++;
     }

#ifdef NOCOMMON

/**** FGetWord - convert ASCII digits into a word
      in the range 0 to 65535 inclusive.
****/

BOOL APIENTRY FGetWord (
     CHAR **ppch,
     WORD *pw)
     {
     LONG l;
     CHAR ch;

     l = 0;

     /* Must see at least one digit. */
     if (!isdigit (**ppch))
          return (FALSE);

     while (isdigit (ch = **ppch))
          {
          l = l * 10 + (ch - '0');
          (*ppch)++;
          if (l > 65535)
               return (FALSE);
          }

     *pw = (WORD)l;
     return (TRUE);
     }

#endif



/**** ChUpperCase - convert from lower to upper case. ****/

#ifdef DISABLE
CHAR APIENTRY ChUpperCase (CHAR ch)
     {
     return (ch >= 'a' && ch <= 'z' ? ch - 'a' + 'A' : ch);
     }
#endif



/**** FD3FromDateSz
      Format supported: mm-dd-yyyy
      (Slashes (/) may be used instead of dashes.)
      If the year is in the range 0 through 99, it is assumed that the
      low order digits of 19yy have been specified.
****/

BOOL APIENTRY FD3FromDateSz (
    CHAR *sz,           /* INPUT - ASCII date string. */
    D3   *pd3)          /* OUTPUT - converted date.  Unchanged if
                           we return FALSE.
                         */
    {
    DOSDATE dd;
    INT     iErr;

    if ((iErr = ParseDateString(&dd, sz)) == 0)
        {
        pd3->wMonth = dd.month - 1;
        pd3->wDay = dd.day - 1;
        pd3->wYear = dd.year - 1980;
        }

    return(iErr);
    }




/**** GetD3FromDt ****/

VOID APIENTRY GetD3FromDt (
     DT   dt,
     D3   *pd3)
     {
     register INT  cDaysYear;
     register INT  i;
     INT  cDaysMonth;

     /* See how many 4 year periods are in it (366 for leap year, 3 * 365
        for the next 3 years.
     */
     pd3 -> wYear = 4 * (dt / 1461);
     dt = dt % 1461;

     /* Account for the individual years.  Again, the first year is
       a leap year, the next two are normal (only two since we already
       divided by groups of 4 years).
     */
     cDaysYear = 366;
     while ((INT)dt >= cDaysYear)
          {
          dt -= (DT)cDaysYear;
          pd3 -> wYear++;
          cDaysYear = 365;
          }

     /* Subtract out days of each month.  Note that we add one
        to the count of days in the month for February in a leap year.
     */
     for (i = MONTHJAN; (INT)dt >= (cDaysMonth = vrgcDaysMonth [i] +
      (cDaysYear == 366 && i == MONTHFEB ? 1 : 0)); i++)
          dt -= (DT)cDaysMonth;

     pd3 -> wMonth = (WORD)i;

     /* Whatever's left is the offset into the month. */
     pd3 -> wDay = (WORD)dt;
     }



/**** Set text of an edit ctl and then place selection at end. */
VOID APIENTRY SetEcText(
     HWND    hwnd,
     CHAR *  sz)
     {
     WPARAM        iSelFirst;
     WPARAM        iSelLast;

     SetWindowText(hwnd, sz);
     iSelFirst = iSelLast = -1;
     SendMessage(hwnd, EM_SETSEL, iSelFirst, iSelLast);
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calalarm.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calalarm.c
 *****
*/

#include "cal.h"


/**** FAlarm - return TRUE if the ln has an alarm set. */

BOOL APIENTRY FAlarm (INT  ln)

     {

     BOOL fAlarm;
     WORD otqr;

     fAlarm = FALSE;
     if ((otqr = vtld [ln].otqr) != OTQRNIL)
          {
          fAlarm = ((PQR )(PbTqrLock () + otqr)) -> fAlarm;
          DrUnlockCur ();
          }
     return (fAlarm);
     }


/**** AlarmToggle - Here on Alarm Set command.
      Since the command is only enabled
      when the focus in on an ln, we know that all we need to do is
      toggle the alarm state for the ln that has the focus.
*/

VOID APIENTRY AlarmToggle ()

     {

     QR   qrNew;
     WORD otqr;
     register PQR pqr;
     TM   tm;
     RECT rect;
     BOOL fAlarm;
     BOOL fEmpty;
     register INT ln;
     DT   dt;
     INT  itdd;
     FT   ftTemp;
     DR   *pdr;

     if ((otqr = vtld [ln = vlnCur].otqr) == OTQRNIL)
          {
          /* There is no QR for this ln, so we know that it can't
             have an alarm set.  We create a QR for it with the
             alarm flag set.
          */
          qrNew.cb = CBQRHEAD + 1;
          fAlarm = qrNew.fAlarm = TRUE;
          qrNew.fSpecial = FALSE;
          qrNew.tm = tm = vtld [ln].tm;
          qrNew.qd [0] = '\0';

          /* Since we know there
             was no old QR, we know FSearchTqr will not find a
             match - so we ignore it's return value.
             We call it to set up the insertion point in votqrNext.
          */
          FSearchTqr (tm);

          /* If there's not enough room to insert the new QR,
             then the alarm cannot get set, so we don't want to
             alter cAlarm (or any of the
             other stuff that gets altered if the QR is inserted).
             Note that FinsertQr puts up the alert.
          */
          if (!FInsertQr (votqrNext, &qrNew))
               return;

          vtld [ln].otqr = votqrNext;

          /* Adjust up the otqrs in the tld beyond the current ln. */
          AdjustOtqr (ln, CBQRHEAD + 1);
          }

     else

          {
          /* There is a QR for this ln.  Toggle its alarm flag. */
          pqr = (PQR )(PbTqrLock () + otqr);
          fAlarm = pqr -> fAlarm = !pqr -> fAlarm;
          fEmpty = !fAlarm && !pqr -> fSpecial && pqr -> cb == CBQRHEAD + 1;
          DrUnlockCur ();

          if (fEmpty)
               {
               /* We can get rid of this QR now since it has no flags
                  set and it has a null appointment description.
               */
               DeleteQr (otqr);
               vtld [ln].otqr = OTQRNIL;

               /* Adjust down the otqrs in the tld beyond the current ln. */
               AdjustOtqr (ln, -(int)(CBQRHEAD + 1));
               }
          }

     /* Get rid of or display the alarm bell icon. */
     rect.top = YcoFromLn (ln);
     rect.bottom = rect.top + vcyLineToLine;
     rect.right = (rect.left = vxcoBell) + vcxBell;
     InvalidateRect (vhwnd2B, (LPRECT)&rect, TRUE);
     UpdateWindow (vhwnd2B);

     /* Set the dirty flags, and adjust the count of alarms for this date. */
     (pdr = PdrLockCur ()) -> fDirty = vfDirty = TRUE;
     dt = pdr -> dt;
     DrUnlockCur ();
     FSearchTdd (dt, &itdd);
     (TddLock () + itdd) -> cAlarms += fAlarm ? 1 : -1;
     TddUnlock ();

     ftTemp.dt = dt;
     ftTemp.tm = vtld [ln].tm;
     if (fAlarm)
          {
          /* Setting an alarm. */
          if (CompareFt (&ftTemp, &vftAlarmNext) == -1
           && CompareFt (&ftTemp, &vftCur) > -1)
               {
               /* The alarm being set is less than the next armed alarm
                  and it is greater than or equal to the current time.
                  Make it the next alarm, and see if it needs to go off
                  right now.  (Waiting for it to go off "naturally" could
                  result in its being a minutue too late since the alarms
                  are only checked when the minute changes.)
               */
               vftAlarmNext = ftTemp;
               AlarmCheck ();
               }
          }
     else
          {
          /* Cancelling an alarm. */
          if (CompareFt (&ftTemp, &vftAlarmNext) == 0)
               {
               /* Cancelling the next armed alarm.  Need to arm the one
                  after it.  Since the one we are cancelling has not yet
                  gone off, it can't be time for the one after it to
                  go off either, so there is no need to call AlarmCheck -
                  just let it go off naturally.
               */
               GetNextAlarm (&vftCur, &vftCur, TRUE, NULL);
               }
          }
     }




/**** ProcessAlarms */

VOID APIENTRY FAR uProcessAlarms ()

     {
     static BOOL vfLocked = FALSE;


     /* This routine is locked to prevent reentry.  This is done to prevent
        an alarm dialog from getting put up on top of another one.  In
        addition to being less confusing for the user, this avoids the nasty
        problems of running out of resources (such as stack and heap).
        The reason that reentry may occur is that we arm the next alarm
        in the process of putting up the dialog, and while the dialog is
        waiting for input, timer messages can come in and the next alarm
        can be triggered.  This is a desirable feature
        since it means the user still hears the audible alarm and we flash
        the window if the next alarm goes off before the OK button is pressed
        for the current alarm dialog (a likely scenario if the user is
        not at the machine but left it with the focus on Calendar).
        As soon as the user pushes the OK button for the current dialog,
        another dialog will be put up to show the new alarms.  This is
        done by looping here until there are no new alarms.
     */

     /* Only enter if the routine is not locked. */
     if (!vfLocked)
          {
          /* Lock this routine to prevent reentry. */
          vfLocked = TRUE;

          /* vftAlarmFirst.dt will get set to DTNIL when the next alarm
             gets armed (during the ACKALARMS dialog).  If that alarm
             gets triggered while the dialog box is up, vdtAlarmFirst
             will get set to that alarm time by AlarmCheck.  We continue
             putting up dialog boxes as long as alarms go off while
             the previous one is up.
          */
          while (vftAlarmFirst.dt != DTNIL)
               {
               /* Quit flashing. */
               StartStopFlash (FALSE);

               if (vfMustSyncAlarm)
                  {
                  /* The system clock was changed so we need to
                     resynchronize the alarms.  Tell the user about it.
                  */
                  AlertBox (vszAlarmSync, (CHAR *)NULL,
                   MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION);

                  /* Now that the user has had his last chance to mess
                     with the clock (could have changed it again
                     during the application modal alert), reset the
                     flag.  We will resync to the latest time that's
                     been read by CalTimer.
                  */
                  vfMustSyncAlarm = FALSE;

                  /* Arm the first alarm >= the current time. */
                  GetNextAlarm (&vftCur, &vftCur, TRUE, NULL);

                  /* Say there are no unacknowledged alarms. */
                  vftAlarmFirst.dt = DTNIL;

                  /* See if the alarm must go off immediately.  If so,
                     AlarmCheck will make vftAlarmFirst something other
                     than DTNIL, so this loop will continue.
                  */
                  AlarmCheck();
                  }
               else
                  {
                   /* Show the alarms that have been triggered, returning
                      here after the user presses the OK button.
                   */
                   FDoDialog (IDD_ACKALARMS);
                  }
               }

          /* Unlock this routine. */
          vfLocked = FALSE;
          }
     }




/**** FnAckAlarms */

INT_PTR CALLBACK FnAckAlarms (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)

     {

     FT   ftTemp;

     switch (message)
          {
          case WM_INITDIALOG:
               /* Remember the window handle of the dialog for AlertBox. */
               vhwndDialog = hwnd;

               /* Fill the list box, and arm the next alarm.  The first
                  alarm to put in the list box is the first unacknowledged
                  one (which is in vftAlarmFirst).  The next alarm to arm
                  (the one following the last one to go into the list
                  box), is the first one > the current time + the early
                  ring period.  Since GetNextAlarm works with >=, add
                  one more than the early ring period.
               */
               ftTemp = vftCur;
               AddMinsToFt (&ftTemp, vcMinEarlyRing + 1);
               GetNextAlarm (&vftAlarmFirst, &ftTemp, TRUE, hwnd);

               /* Say there are no unacknowledged alarms.  Note that
                  there has not been an opportunity for the alarm just
                  armed by GetNextAlarm to be triggered, since the last
                  thing that routine does is arm the alarm so no error
                  dialogs could have occurred after arming, and consequently
                  we could not have yielded and processed a timer message.
               */
               vftAlarmFirst.dt = DTNIL;
               return (TRUE);

          case WM_COMMAND:
               if (GET_WM_COMMAND_ID(wParam, lParam) == IDOK)
                    {
                    EndDialog (hwnd, TRUE);
                    return (TRUE);
                    }
               /* Fall into default case if WM_COMMAND is not from IDOK. */
          default:
               /* Tell Windows we did not process the message. */
               return (FALSE);
          }
     }


/**** GetNextAlarm */

VOID APIENTRY FAR GetNextAlarm (

    FT   *pftStart,     /* Start looking at alarms >= this. */
    FT   *pftStop,      /* Stop when find alarm >= this.  If an alarm >=
			   this is found, arm it.
			*/
    BOOL fDisk,         /* Ok to read from disk if this is TRUE.  If FALSE,
			   give up if the next alarm is not in memory.
			*/
    HWND hwnd)          /* If not null, use this handle to send the triggered
			   alarms to the list box in the alarm acknowledgement
			   dialog box.
			*/
     {

     /* Need enough space for a time sz (we overwrite the terminating 0
        with a space), a maximum length appointment description, and a
        terminating 0.
     */
     CHAR rgchAlarm [CCHTIMESZ + CCHQDMAX + 1];
     INT  itdd;
     INT  cch;
     DD   *pdd;
     FT   ftTemp;
     FT   ftStart;
     FT   ftStop;
     INT  cAlarms;
     DL   dl;
     register WORD  idr;
     register PQR	pqr;
     WORD  idrFree;

     /* This could take some time if we hit the disk. */
     HourGlassOn();

     /* Make local copies of the FTs we were passed pointers to so we
        don't overwrite them (suppose we are passed a pointer to vftAlarmNext
        for example).
     */
     ftStart = *pftStart;
     ftStop = *pftStop;

     /* Say there is no next alarm. */
     vftAlarmNext.dt = DTNIL;

     /* Find a free DR in case we need to read in from disk. */
     idrFree = IdrFree ();

     for (FSearchTdd (ftStart.dt, &itdd); itdd < vcddUsed; itdd++)
          {
          pdd = TddLock () + itdd;
          ftTemp.dt = pdd -> dt;
          cAlarms = pdd -> cAlarms;
          dl = pdd -> dl;
          idr = pdd -> idr;
          TddUnlock ();

          if (cAlarms == 0)
               continue;

          if (idr == IDRNIL)
               {
               /* The next alarm is not in memory.  If we're not supposed
                  to hit the disk, we've done all we can do.
               */
               if (!fDisk)
                    goto Exit0;

               /* Note - since cAlarms was not zero, there must be some
                  data for this date somewhere.  It isn't in memory, so
                  it must be on disk.  Therefore, dl cannot be DLNIL, so
                  we don't need check to see if it is.
               */
               ReadTempDr (idr = idrFree, dl);
               }

          pqr = (PQR)PbTqrFromPdr(PdrLock(idr));

          for ( ; cAlarms; pqr = (PQR )((BYTE *)pqr + pqr -> cb))
               {
               if (pqr -> fAlarm)
                    {
                    cAlarms--;

                    /* Remember the time of the alarm. */
                    ftTemp.tm = pqr -> tm;

                    if (CompareFt (&ftTemp, &ftStart) != -1)
                         {
                         /* This ft is greater than or equal to ftStart. */
                         if (CompareFt (&ftTemp, &ftStop) != -1)
                              {
                              /* This ft is greater than or equal
                                 to ftStop, so this is the next alarm.
                              */
                              vftAlarmNext = ftTemp;
                              DrUnlock (idr);
                              goto Exit0;
                              }

                         /* This is a triggered alarm, so put it into the
                            list box of the alarm acknowledgement dialog box.
                         */
                         if (hwnd != NULL)
                              {
                              cch = GetTimeSz(pqr -> tm, rgchAlarm);
                              rgchAlarm[cch] = ' ';
                              lstrcpy(&rgchAlarm[cch + 1], pqr -> qd);
                              if (SendDlgItemMessage (hwnd, IDCN_LISTBOX,
                               LB_ADDSTRING, 0, (LPARAM)rgchAlarm)
                               == LB_ERRSPACE)
                                   {
                                   /* ??? Not enough memory.  Be sure to unlock
                                      if bail out due to this error.
                                   */
                                   }
                              }
                         }
                    }
               }

          DrUnlock (idr);

          }

     /* End of tdd reached - there is no next alarm. */
Exit0:
     HourGlassOff ();

     }


/**** IdrFree - find a free DR. */

WORD  APIENTRY IdrFree ()

     {

     register WORD   idr;
     register DT    dt;

     /* Find a free DR to read the date into.  There is guaranteed
        to be at least one free one since there are 3 and we keep at
        most 2 dates in memory at one time, so finding a free one
        will terminate this loop with idr containing the index of the
        free DR.
     */
     idr = CDR;
     do
          {
          idr--;
          dt = PdrLock(idr)->dt;
          DrUnlock (idr);
          }
     while (dt != DTNIL);

     return (idr);

     }


/**** ReadTempDr - read date into DR for temporary use. */

VOID APIENTRY ReadTempDr (
    WORD  idr,
    DL   dl)
     {

     register DR *pdr;

     pdr = PdrLock (idr);

     if (!FReadDrFromFile (TRUE, pdr, dl))
          {
          /* ??? Error trying to read date - what now? */
          }

     /* Make the DR still look free since we are only using it
        temporarily.
     */
     pdr -> dt = DTNIL;
     DrUnlock (idr);

     }


/**** StartStopFlash */

VOID APIENTRY StartStopFlash (BOOL fStart)
    /* FALSE means stop flashing, TRUE means start flashing. */
     {
     if (fStart != vfFlashing)
          FlashWindow (vhwnd0, vfFlashing = fStart);
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\caldata.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** caldata.c
 *****
*/

#include "cal.h"

// While processing command line options, there may be errors
// (e.g. can't open file) which need to be put up using AlertBox(). Once
// alert box completes, the focus is set to the parent window which results
// in WM_ACTIVATE. If WM_ACTIVATE is processed before a file is loaded
// it results in GP Faults. 
// Prevent processing WM_ACTIVATE when initialization is not yet complete
// Set after CalInit() completes. 
BYTE fInitComplete = FALSE;

BYTE vrgcDaysMonth [12] =
     {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

BOOL vfDayMode = FALSE;  /* TRUE if in day mode, FALSE if in month mode.
                            Note - it's important that be initialize to
                            FALSE so the first call to DayMode () sets
                            everything up.
                         */

HINSTANCE vhInstance;    /* Current instance handle. */

HBRUSH vhbrBorder = 0;       /* Brush to use for borders - this uses the system
                            window borders color.
                         */
HBRUSH vhbrBackMain = 0;     /* Background brush for the main window - this
                            uses a fixed color defined by Tandy.
                         */
HBRUSH vhbrBackSub = 0;      /* Background brush for all sub windows - this uses
                            the system window background color.
                         */

HCURSOR vhcsrArrow;
HCURSOR vhcsrIbeam;
HCURSOR vhcsrWait;

INT  vcxFont;		 /* Width of fixed font. */
INT  vcxFontMax;	 /* Maximum font width */
INT  vcyFont;            /* Height of fixed font. */
INT  vcyDescent;         /* The descent of the fixed font. */
INT  vcyExtLead;         /* External leading of fixed font.  Pronounced
                            as in the metal lead, this is the blank space
                            separating two lines of text.  This space "belongs"
                            to the first of two lines (i.e., it follows the
                            text rather than preceding it).
                         */
INT  vcyLineToLine;      /* Base line to base line of fixed font
                            (Same as vcyFont + vcyExtLead).
                         */

INT  vcxBorder;
INT  vcxVScrollBar;
INT  vcyBorder;
INT  vcxHScrollBar;
INT  vcyHScrollBar;

/* Window heights.  Note that all heights are  of client areas except for
   vcyWnd1, which includes the top and bottom borders.
*/
INT  vcyWnd1;
INT  vcyWnd2A;
INT  vcyWnd2BTop;
INT  vcyWnd2BBot;
INT  vcyWnd2B;

/* Window widths.  Note that all widths are  of client areas except for
   vcxWnd1, which includes the left and right borders.
*/
INT  vcxWnd1;
INT  vcxWnd2A;
INT  vcxWnd2B;

INT  vxcoBell;           /* Where alarm bell bitmap starts. */
INT  vcxBell;            /* Width of the alarm bell bitmap. */
INT  vcyBell;            /* Height of the alarm bell bitmap. */
INT  vxcoApptTime;       /* Where the appointment time starts. */
INT  vxcoAmPm;           /* Where the am or pm string starts. */

/* The limits of the appointment description portion of wnd2B. */
INT  vxcoQdFirst;
INT  vxcoQdMax;
INT  vycoQdFirst;
INT  vycoQdMax;

INT  vxcoDate; /* Where the date begins in wnd2A. */

/* The bottom box of the calendar encloses the notes edit control, but the
   edit control does not take up the entire box.  We draw a double line
   above the notes.  The upper line is in wnd2B, the lower is drawn
   in wnd1 at vycoNotesBox.
*/
INT  vycoNotesBox;

/* Coordinates of the notes edit control within wnd1. */
INT  vxcoWnd2C;
INT  vycoWnd2C;

INT  vcln;     /*** ln - a line in the appointments window (0 through
                    vcln - 1).
               */
INT  vlnLast;  /* The highest line number. */

LD vtld [25];       /* The table of line descriptors. */
/* Window handles. */
HWND vhwnd0;
HWND vhwnd1;
HWND vhwnd2A;
HWND vhwnd2B;
HWND vhwnd2C;
HWND vhwnd3;
HWND hEditHide;
#ifndef BUG_8560
HWND vhScrollWnd;	/* Window handle of the scrollbar handle */
#endif

D3   vd3Cur;                       /* Date when we last called ReadClock. */
FT   vftCur;                       /* Date and time when we last called
                                      ReadClock.
                                   */

UINT vcMinEarlyRing;               /* Alarm early ring period. */
BOOL vfSound;                      /* TRUE if the audio alarm is enabled. */
BOOL vfHour24;                     /* TRUE for 24 hour format, FALSE for
                                      12 hour format.
                                   */
INT  vmdInterval;                  /* Interval between appointments:
                                      MDINTERVAL15, MDINTERVAL30, or
                                      MDINTERVAL60.
				   */

INT viMarkSymbol    = 0;
BOOL vfOpenFileReadOnly = FALSE;

INT  vcMinInterval;		   /* Interval stored in minutes. */
TM   vtmStart;                     /* Starting time of day mode. */

DLGPROC vrglpfnDialog [CIDD] =
     {
     0,  /* FnSaveAs, removed by L.Raman 12/12/90 (common dlg. support) */
     FnPrint,
     FnRemove,
     FnDate,
     FnControls,
     FnSpecialTime,
     FnDaySettings,
     0,    // FnAbout, removed by TG 12/17/90 (ShellAbout support)
     FnAckAlarms,
     FnPageSetup
     };

INT  vlnCur;		      /* The current ln. */

FT   vftAlarmNext;            /* The next alarm to go off.  vftAlarmNext.dt
                                 == DTNIL means there is no next alarm.
                              */
FT   vftAlarmFirst;           /* The first unacknowledged alarm.
                                 vftAlarmFirst.dt == DTNIL means there are
                                 no unacknowledged alarms.
                              */
BOOL vfFlashing = FALSE;      /* If TRUE, we are flashing the window (title
                                 bar or icon to tell the user to make us
                                 the active window.
                              */
INT  vcAlarmBeeps = 0;        /* The number of beeps remaining for the
                                 alarm.
                              */

BOOL vfInsert;                /* Only valid during a special time command.
                                 FALSE means Delete, TRUE means insert.
                              */
TM   vtmSpecial;              /* Only valid during a special time command.
                                 The tm to delete or insert.
                              */

BOOL vfNoGrabFocus;           /* If Calendar is brought up iconic this flag
                                 gets set by CalInit in order to prevent the
                                 focus from being grabbed.  Instead of calling
                                 SetFocus directly, all routines call
                                 CalSetFocus, which only calls SetFocus
                                 if vfNoGrabFocus is FALSE.
                              */

HANDLE vhAccel;               /* Handle to the accelerator table. */
INT viAMorPM = IDCN_AM;

/* AlertBox needs to know what window is the parent of the message box.
   If there is a dialog in progress, the parent is the dialog box.
   Otherwise, the parent window is Calendar's tiled window.
   In order to avoid having to pass down the parent window handle
   through numerous levels of calls, we simply remember the window
   handle of the active dialog in vhwndDialog.  It is initially set
   to (HWND)NULL and gets reset to this at the end of FDoDialog.
   Each dialog stores it's window handle into vhwndDialog when it
   handles the WM_INITDIALOG.  Note that there are no cases of nested
   dialogs, so having a single global works.
   (As an example of where the parent window handle would have to be
   passed down numerous levels, consider the FSaveFile case.  It can
   be called while the SaveAs dialog is up, or from Save (in which
   case there is no dialog.  It in turn goes several layers deep
   and gets into routines like FWriteFile which can call AlertBox to
   report a Disk Full error.  So using a global makes a lot of sense.)
*/
HWND vhwndDialog = (HWND)NULL;

/* If the system clock is set back by one or more minutes, or it is
   set ahead by 1440 (the number of minutes in a day) or more minutes,
   this flag gets set so we know we have to resynchronize the next alarm.
*/
BOOL vfMustSyncAlarm = FALSE;

/* globals for file page setup and file print */

CHAR chPageText[6][PT_LEN];
CHAR szDec[5];
CHAR szPrinter[128];
BOOL bPrinterSetupDone=FALSE;

INT viLeftMarginLen;      /* page left margin length   */
INT viRightMarginLen;     /* page right margin length  */
INT viTopMarginLen;       /* page top margin length    */
INT viBotMarginLen;       /* page bottom margin length */

INT viCurrentPage = 0;		    /* current page being printed */

OPENFILENAME vOFN;		    /* struct. for the common
				     * file open and saveas dialogs
				     */
INT vFilterIndex = 1;		    /* default filter index in File/Open
				     * dialog
				     */
PRINTDLG vPD;			    /* struct. passed into PrintDlg */
INT vHlpMsg;			    /* message nummer to invoke Help appl. from
				     * common dialogs
				     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calcolor.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calcolor.c
 *****
*/

#include "cal.h"


/**** CreateBrushes */

BOOL APIENTRY CreateBrushes ()

     {

     if (!(vhbrBackMain = CreateSolidBrush(GetSysColor (COLOR_APPWORKSPACE))))
            return FALSE;
     if (!(vhbrBackSub = CreateSolidBrush(GetSysColor (COLOR_WINDOW))))
        return FALSE;
     if (!(vhbrBorder = CreateSolidBrush(GetSysColor (COLOR_WINDOWFRAME))))
        return FALSE;

     return TRUE;
     }


/**** DestroyBrushes */

VOID APIENTRY DestroyBrushes ()

     {
     if (vhbrBackMain)
         DeleteObject (vhbrBackMain);
     if (vhbrBackSub)
         DeleteObject (vhbrBackSub);
     if (vhbrBorder)
         DeleteObject (vhbrBorder);

     }


/**** PaintBack - paint the window background. */

VOID APIENTRY PaintBack (
    HWND hwnd,
    HDC  hDC)
     {

     RECT rect;
     register HBRUSH hbr;

     GetClientRect (hwnd, (LPRECT)&rect);
     hbr = vhbrBackMain;
     if (hwnd != vhwnd0)
          hbr = vhbrBackSub;
     MUnrealizeObject(hbr);
     FillRect (hDC, (LPRECT)&rect, hbr);

     }


/**** CalGetDC */

HDC  APIENTRY FAR CalGetDC (HWND hwnd)
     {

     register HDC hDC;

     hDC = GetDC (hwnd);
     SetDefaultColors (hDC);
     return (hDC);

     }


/**** SetDefaultColors */

VOID APIENTRY SetDefaultColors (HDC  hDC)
     {

     SetTextColor (hDC, GetSysColor (COLOR_WINDOWTEXT));
     SetBkColor (hDC, GetSysColor (COLOR_WINDOW));
     SelectObject (hDC, vhbrBorder);

     }


/**** DrawAlarmBell */

VOID APIENTRY DrawAlarmBell (
    HDC  hDC,
    INT  yco)
     {

     /* Note - the bell will be drawn the same color as the text, which
        is what we want.
     */
     SelectObject (vhDCMemory, vhbmBell);
     BitBlt (hDC, vxcoBell , yco, vcxBell,
             (vcyBell > vcyLineToLine ? vcyLineToLine : vcyBell),
             vhDCMemory, 0, 0, SRCCOPY);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calday.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calday.c
 *****
*/

#include "cal.h"

#define FIXEDFONTWIDTH 0

UINT wID;

BOOL vfUpdate = TRUE;   /* flag to disable setqdec() update fix. 27-Oct-1987 */

/**** DayMode - Switch to day mode. */

VOID APIENTRY DayMode (D3 *pd3)
     {

     RECT rect;
     HDC  hDC;

     if (!vfDayMode)
	  {
	  /* Say we are in day mode. */
	  vfDayMode = TRUE;

	  /* Disable focus for now.  If in notes area, leave it there,
	     otherwise set up to give focus to appointment description.
	  */
	  CalSetFocus ((HWND)NULL);
	  if (vhwndFocus != vhwnd2C)
	       vhwndFocus = vhwnd3;

	  /* Clear the window so we don't get a blank region appearing
	     in the middle of the monthly calendar when we ShowWindow
	     the appointment description edit control.
	  */
	  GetClientRect (vhwnd2B, (LPRECT)&rect);
	  rect.bottom -= vcyBorder;

	  hDC = CalGetDC (vhwnd2B);
	  FillRect (hDC, (LPRECT)&rect, vhbrBackSub);
	  ReleaseDC (vhwnd2B, hDC);
	  /* Make the appointment description edit control visible. */
	  SetEcText(vhwnd3, "");

	  SetScrollRange (vhwnd2B, SB_HORZ, 0, 0, TRUE);
      SetScrollPos (vhwnd2B, SB_HORZ, 0,TRUE);

          /*InvalidateRect (vhwnd2B, (LPRECT)NULL, FALSE);*/
		  UpdateWindow (vhwnd2B);
          ShowWindow (vhwnd3, SHOW_OPENWINDOW);



	  }

     /* Switch to the specified date.  Note that this gets done even if
	we were already in day mode.  This means that the View Day command
	can be used to get back to the starting time of the currently
	displayed day.	It also is necessary because there callers who
	want the day redisplayed even if already in day mode (like New).
     */
     SwitchToDate (pd3);
     }


/**** SwitchToDate - the ONLY routine that changes the selected day in
      day mode.
*/

VOID APIENTRY SwitchToDate ( D3   *pd3 )
     {
     RECT rect;

     register BOOL fNewMonth;

     if (FGetDateDr (DtFromPd3 (pd3)))
	  {
	  fNewMonth = vd3Sel.wMonth != pd3 -> wMonth
	   || vd3Sel.wYear != pd3 -> wYear;
	  vd3Sel = *pd3;
	  if (fNewMonth)
	       SetUpMonth ();
	  }

     FillTld (vtmStart);
     SetQdEc (0);

     /* If focus is on notes area put it there.  Otherwise it has already
	been set up by SetQdEc.
     */
     if (vhwndFocus == vhwnd2C)
	  CalSetFocus (vhwnd2C);

     /* Set the scroll bar range and thumb position.  (The scroll bar range
	depends on the number of TM in the day, so it must be set up each
	time the day is changed.)
     */

     SetDayScrollRange ();
     SetDayScrollPos (-1);

    /* Repaint Wnd2A to display "Schedule for: ..." message. */
     InvalidateRect (vhwnd2A, (LPRECT)NULL, TRUE);
     UpdateWindow (vhwnd2A);

    /* Redraw the appointments. */
     GetClientRect (vhwnd1, (LPRECT)&rect);
     rect.bottom = vycoWnd2C;
     rect.top = vcyWnd2A;

     InvalidateRect (vhwnd1, (LPRECT)&rect, TRUE);
/*   UpdateWindow (vhwnd1);   */

     /* Set up the notes area. */
     SetNotesEc ();
     }


/**** DayPaint */

VOID APIENTRY DayPaint (HDC  hDC)
     {

     CHAR sz [CCHTIMESZ];
     register INT  ycoText;
     register INT  ln;
     INT  cch;
     TM   tm;
     CHAR *pchQd;
     RECT rectQd;
     BYTE *pbTqr;
     DWORD        iSelFirst;
     DWORD        iSelLast;
#ifdef DISABLE
     DWORD        iSelFirstT;
     DWORD        iSelLastT;
#endif

     pbTqr = PbTqrLock ();
     rectQd.right = vxcoQdMax ;
     rectQd.left = vxcoQdFirst;

     for (ln = 0; ln < vcln; ln++)
	  {
	  ycoText = YcoFromLn (ln);

	  if (FAlarm (ln))
	       DrawAlarmBell (hDC, ycoText);

	  cch = GetTimeSz (tm = vtld [ln].tm, sz);

	  /* Display am or pm only for the first appointment in the window
	     and for noon.
	  */
	  if (ln != 0 && tm != TMNOON)
	      cch = 5;

	  TextOut (hDC, vxcoApptTime, ycoText, (LPSTR)sz, cch);

	  rectQd.top = YcoFromLn (ln);
	  rectQd.bottom = rectQd.top + vcyFont;
	  pchQd = "";
	  if (vtld [ln].otqr != OTQRNIL)
	       pchQd = (CHAR *)(pbTqr + vtld [ln].otqr + CBQRHEAD);

	  DrawText (hDC, (LPSTR)pchQd, -1, (LPRECT)&rectQd,
		    DT_NOPREFIX | DT_SINGLELINE | DT_LEFT | DT_TOP);
	  if (ln == vlnCur)
	       {
	       /* We have just painted the appointment that has the
		  edit control.  In order to keep "flashing" to a minimum,
		  we want to prevent the edit control from repainting,
		  but we do need to get the highlight back up.
		  So:
		  1) Validate the edit control to prevent repainting.
		  2) Disable redraw.
		  3) Fetch and save the current selection.
		  4) Set the selection to null (redraw is off, so this
		     will not affect the highlight).
		  5) Enable redraw.
		  6) Set the selection back to the saved value.  Since redraw
		     is enabled this will highlight the selected characters.
	       */
#ifdef DISABLE
	       ValidateRect (vhwnd3, (LPRECT)NULL);
	       SendMessage (vhwnd3, WM_SETREDRAW, FALSE, 0L);
	       MSendMsgEM_GETSEL(vhwnd3, &iSelFirst, &iSelLast);
	       iselFirstT = iSelFirst;
	       iselLastT = iSelLast;
	       iselFirst = iSelLast = 0;
	       SendMessage(vhwnd3, EM_SETSEL, iSelFirst, (LONG)iSelLast);
	       SendMessage(vhwnd3, WM_SETREDRAW, TRUE, 0L);
	       SendMessage(vhwnd3, EM_SETSEL, iSelFirstT, (LONG)iSelLastT);
#else
               /* don't try to be fancy.  If only part of hilight in update
                * region, there was bug with selection being half inverted,
                * half normal.  This solved it.  10-Jun-1987.
                */
	       MSendMsgEM_GETSEL(vhwnd3, &iSelFirst, &iSelLast);
	       SendMessage(vhwnd3, EM_SETSEL, iSelFirst, (LONG)iSelLast);
#endif
	       }
	  }
     DrUnlockCur ();
     }


/**** FillTld */

VOID APIENTRY FillTld (TM tmFirst)
     {

     LD   *pldCur;
     LD   *pldLast;
     INT  cldEmpty;

     /* Find the first appointment less than or equal to the specified
	one.  Note that since tmFirst must be greater than or equal to
	0 (midnight), calling FGetPrevLd with tmFirst + 1 is guaranteed
	to find something, so there is no need to check the return value.
     */
     FGetPrevLd (tmFirst + 1, vtld);

     /* Work forward filling in the tld.  Stop when the end of the
	table is reached or the end of the day is reached.
     */
     for (pldLast = (pldCur = vtld) + vlnLast; pldCur < pldLast
      && FGetNextLd (pldCur -> tm, pldCur + 1); pldCur++)
			;


     /* If we stopped going forward because we reached the end of the day
	instead of the end of the tld, there are empty entries at the end
	of the tld.  In this case, we scroll the tld down to put the
	empty space at the top, and then we fill in the empty space by
	getting the earlier appointment times.	There will always be
	enough appointment times to fill the tld since the maximum interval
	(1 hour) gives 24 appointment times, and we don't have that many
	lines for displaying appointments.  So there is no need to check
	the return value of FGetPrevLd below, and we can rest assured that
	the tld will get completely filled.
     */
     if ((cldEmpty = (INT)(pldLast - pldCur)) > 0)
	  {
	  ScrollDownTld (cldEmpty);
	  for (pldCur = vtld + cldEmpty; pldCur > vtld; pldCur--)
	       FGetPrevLd (pldCur -> tm, pldCur - 1);
	  }
     }


/**** ScrollDownTld - Scroll the tld down (towards the bottom of the screen,
      but higher in memory) the specified number of ld,
      making room for new lds at the top of the tld.
*/

VOID APIENTRY ScrollDownTld (INT cld)
     {
     BltByte ((BYTE *)vtld, (BYTE *)(vtld + cld),
      (WORD)((vcln - cld) * sizeof (LD)));
     }


/**** ScrollUpTld - Scroll the tld up (towards the top of the screen,
      but lower in memory) the specified number of ld,
      making room for new lds at the bottom of the tld.
*/

VOID APIENTRY ScrollUpTld (INT  cld)
     {
     BltByte ((BYTE *)(vtld + cld), (BYTE *)vtld,
      (WORD)((vcln - cld) * sizeof (LD)));
     }


/**** FGetNextLd */

BOOL APIENTRY FGetNextLd (
    TM   tm,
    LD   *pld)
     {

     TM   tmFromTqr;
     DR   *pdr;


     FSearchTqr (tm);
     tmFromTqr = TMNILHIGH;
     if (votqrNext != (pdr = PdrLockCur ()) -> cbTqr)
	  tmFromTqr = ((PQR )(PbTqrFromPdr (pdr) + votqrNext)) -> tm;
     DrUnlockCur ();

     if ((tm = min (tmFromTqr, TmNextRegular (tm))) == TMNILHIGH)
	  return (FALSE);

     pld -> tm = tm;
     pld -> otqr = tm == tmFromTqr ? votqrNext : OTQRNIL;
     return (TRUE);

     }


/**** FGetPrevLd */

BOOL APIENTRY FGetPrevLd (
    TM   tm,
    LD   *pld)
     {

     TM   tmFromTqr;
     TM   tmInterval;

     FSearchTqr (tm);
     tmFromTqr = TMNILLOW;
     if ((WORD)votqrPrev != OTQRNIL)
	  {
	  tmFromTqr = ((PQR )(PbTqrLock () + votqrPrev)) -> tm;
	  DrUnlockCur ();
	  }

     /* Calculate the previous regular appointment time. */
     tmInterval = tm - 1;
     if (tm == 0 || (tmInterval -= tmInterval % vcMinInterval) < 0)
	  tmInterval = TMNILLOW;

     if ((tm = max (tmFromTqr, tmInterval)) == TMNILLOW)
	  return (FALSE);

     pld -> tm = tm;
     pld -> otqr = tm == tmFromTqr ? votqrPrev : OTQRNIL;
     return (TRUE);

     }


/**** FScrollDay */

BOOL APIENTRY FScrollDay (
    INT  code,
    UINT posNew)
     {

     wID=code;

     switch (code)
	  {
	  case SB_LINEUP:
	       ScrollDownDay (1, TRUE, FALSE);
	       break;

          case SB_LINEDOWN:
               ScrollUpDay (1, TRUE);
	       break;

	  case SB_PAGEUP:
	       ScrollDownDay (vlnLast, TRUE, FALSE);
	       break;

	  case SB_PAGEDOWN:
               ScrollUpDay (vlnLast, TRUE);
	       break;

	  case SB_THUMBPOSITION:
	       /* Record current edits (before changing the tld). */
	       if (vhwndFocus == vhwnd3)
		    CalSetFocus ((HWND)NULL);
	       FillTld (TmFromItm (posNew));

/* Move the call to SetQdEc() after the call to SetDayScrollPos(), and
   use GetScrollPos() to find out if the location passed was beyond the
   end of the scrollbar.  If not, 0 will be passed as before.  If true,
   the call to SetQdEc() will step down to the appropriate location on
   the display.  Tracked down to solve Bug #2502.
                          16 July 1989     Clark Cyr                   */

#if DISABLE
	       SetQdEc (0);
#endif
	       SetDayScrollPos (posNew);
               SetQdEc(posNew - GetScrollPos(vhwnd2B, SB_VERT));
	       InvalidateRect (vhwnd2B, (LPRECT)NULL, TRUE);
	       break;

	  default:
	       return (FALSE);
	  }

     return (TRUE);
     }


/**** ScrollDownDay
	  ctNew is number of lines to scroll.  fScrollBar is true if we
	  are not being scrolled by cursor movement.  fSizing is true iff
	  we are scrolling as a result of resizing. */
VOID APIENTRY ScrollDownDay (
    INT  ctmNew,
    BOOL fScrollBar,
    BOOL fSizing)

     {

     register INT ctm;
     register INT ln;
     LD   ldTemp;
     RECT rect;
     HDC  hDC;
     TM   tmFirstOld;
     extern INT cchTimeMax;
     CHAR sz[CCHTIMESZ];
     INT cch;
     INT iHeight;
     INT iWidth;

     /* Register current changes and hide the caret. */
     if (vhwndFocus == vhwnd3)
	  CalSetFocus ((HWND)NULL);

     tmFirstOld = vtld [0].tm;


     for (ctm = 0; ctm <(ctmNew) && FGetPrevLd (vtld [0].tm, &ldTemp) ; ctm++)
	  {
	  ScrollDownTld (1);
	  vtld [0] = ldTemp;
     }

     if (ctm != 0)
	  {
	  /* Get rid of am or pm on top line of window if it's not noon.
	     Note - it's OK to execute this code even if in 24 hour mode
	     since we will just be putting spaces over spaces.
	  */
          if (tmFirstOld != TMNOON)
	       {
	       hDC = CalGetDC (vhwnd2B);
	       cch = GetTimeSz (tmFirstOld, sz);
               MGetTextExtent(hDC, sz, 5, &iHeight, &iWidth); /* width of time string
							       + the blank following it */
               //- KLUDGE: TextOut (hDC, vxcoApptTime + iWidth, vycoQdFirst,
			   //- KLUDGE:		(LPSTR)vszBlankString,cchTimeMax+3);
			   //- For some reason, the above code no longer blanks out the
			   //- correct area.  It puts a space in the center of the time.
               TextOut (hDC, vxcoApptTime + iWidth + 19, vycoQdFirst,
                                 (LPSTR)"              ",12);
	       ReleaseDC (vhwnd2B, hDC);
	       }

	  GetClientRect (vhwnd2B, (LPRECT)&rect);
	  rect.top = vycoQdFirst;
	  rect.bottom = vycoQdMax;
          ScrollWindow (vhwnd2B, 0, ctm * vcyLineToLine, &rect,&rect);
          }

     /* Need to reset focus even if nothing has scrolled since
	the focus got turned off above.
     */
     ln = 0;
     if (fScrollBar)
          ln = min (vlnCur + ctm , vlnLast);

     vfUpdate = FALSE;
     SetQdEc (ln);
     vfUpdate = TRUE;

     /* When SetQdEc validates the appointment edit control, the
	corresponding rectangle of its parent (wnd2B) gets validated
	too.  If this is in the portion of wnd2B that was invalidated
	by the scroll, we must invalidate it now so it gets painted
	by DayPaint.
	We brought in ctm new lines at the top of wnd2B, so if the
	new ln (the position of the appointment edit control) is
	less than ctm, it's in the invalidated portion of wnd2B.
	Note that if ctm == 0, ln can't be less, so this case is OK.
	If we are resizing, whole window will be repainted.
     */
     if (ln < ctm || fSizing)
          InvalidateParentQdEc (ln);

     if (ctm != 0)
          {
	  UpdateWindow (vhwnd2B);
	  AdjustDayScrollPos (-ctm);

	  /* Need to update edit ctl window incase obscurred by popup. */
          if (AnyPopup() && vhwnd3)
	      {
	      InvalidateRect(vhwnd3, (LPRECT)NULL, TRUE);
	      UpdateWindow(vhwnd3);
              }
	  }
     }


/**** ScrollUpDay */

VOID APIENTRY ScrollUpDay (
    INT  ctmNew,
    BOOL fScrollBar)
     {

     register INT ctm;
     register INT ln;
     LD   ldTemp;
     RECT rect;
     HDC  hDC;


     /* Register current edits and hide the caret. */
     if (vhwndFocus == vhwnd3)
	  CalSetFocus ((HWND)NULL);

     for (ctm = 0; ctm < (ctmNew) && FGetNextLd (vtld [vlnLast].tm, &ldTemp);
      ctm++)
	  {
	  ScrollUpTld (1);
	  vtld [vlnLast] = ldTemp;
	  }

     if (ctm != 0)
	  {
	  GetClientRect (vhwnd2B, (LPRECT)&rect);
	  rect.top = vycoQdFirst;
	  rect.bottom = vycoQdMax;
          ScrollWindow (vhwnd2B, 0, -ctm * vcyLineToLine, &rect, &rect);

          if (wID==SB_PAGEDOWN)
              {
              /* Fix the problem of not repainting some times when scrolling */
              rect.top=vycoQdFirst;
              rect.bottom =vycoQdMax-(ctm*vcyLineToLine);
              rect.right=vxcoQdMax;
              rect.left=0;
              InvalidateRect(vhwnd2B, &rect, TRUE);
              }

	  /* If in 12 hour mode, put am/pm on first appointment in the window. */
	  if (!vfHour24)
	       {
#if FIXEDFONTWIDTH
               CHAR *sz;
	       extern CHAR sz1159[];
               extern CHAR sz2359[];
#else
               CHAR sz[CCHTIMESZ];
               INT cch;
#endif

               hDC = CalGetDC (vhwnd2B);

/* This has the problem that spaces do not have the same width as numbers
   in the new system fonts.  Depending on vxcoAmPm as the constant position
   for where AM and PM should be offset is no longer safe.  This is just a
   bandaid and should be written correctly later.  17 July 1989  Clark Cyr */

#if FIXEDFONTWIDTH
               sz=(vtld[0].tm < TMNOON ? sz1159 : sz2359);
               TextOut(hDC, vxcoAmPm, vycoQdFirst, sz , lstrlen(sz));
#else
	       cch = GetTimeSz (vtld[0].tm, sz);
               TextOut (hDC, vxcoApptTime, vycoQdFirst, (LPSTR)sz, cch);
#endif
	       ReleaseDC (vhwnd2B, hDC);
               }

         }
     /* Need to reset focus even if nothing has scrolled since
	the focus got turned off above.
     */
     ln = vlnLast;
     if (fScrollBar)
          ln = max (vlnCur - ctm, 0);

     vfUpdate = FALSE;
     SetQdEc (ln);
     vfUpdate = TRUE;

     /* When SetQdEc validates the appointment edit control, the
	corresponding rectangle of its parent (wnd2B) gets validated
	too.  If this is in the portion of wnd2B that was invalidated
	by the scroll, we must invalidate it now so it gets painted
	by DayPaint.
	We brought in ctm new lines at the bottom of wnd2B, so if the
	new ln (the position of the appointment edit control) is
	greater than vlnLast - ctm, it's in the invalidated portion of wnd2B.
	Note that if ctm == 0, ln can't be greater, so this case is OK.
     */
     if (ln > vlnLast - ctm)
	  InvalidateParentQdEc (ln);

     if (ctm != 0)
	  {
	  rect.top = YcoFromLn(vlnLast);
	  rect.bottom = rect.top + vcyLineToLine;
	  InvalidateRect(vhwnd2B, (LPRECT)&rect, TRUE);
	  UpdateWindow (vhwnd2B);
	  AdjustDayScrollPos (ctm);

	  /* Need to update edit ctl window incase obscurred by popup. */
	  if (AnyPopup() && vhwnd3)
	      {
	      InvalidateRect(vhwnd3, (LPRECT)NULL, TRUE);
	      UpdateWindow(vhwnd3);
	      }
	  }
     }


/**** InvalidateParentQdEc */

VOID APIENTRY InvalidateParentQdEc (INT ln)
     {

     RECT rect;

     rect.top = YcoFromLn (ln);
     rect.bottom = rect.top + vcyFont;
     rect.left = vxcoQdFirst;
     rect.right = vxcoQdMax;

     InvalidateRect (vhwnd2B, &rect, TRUE);
     OffsetRect(&rect, 0, vcyWnd2A);
     InvalidateRect (vhwnd1, &rect, TRUE);

     }


/**** YcoFromLn - given line number, return yco within Wnd2B */

INT  APIENTRY YcoFromLn (INT ln)
     {
     return (vycoQdFirst + ln * vcyLineToLine);
     }


/**** LnFromYco - given yco within Wnd2B, return line number. */

INT  APIENTRY LnFromYco (INT yco)
     {
     return (min (max (yco - vycoQdFirst, 0) / vcyLineToLine, vlnLast));
     }


/**** SetQdEc - Position and set the text of the appointment description
      edit control.
*/

VOID APIENTRY SetQdEc (INT ln)
     {

     register BYTE *pbTqr;
     register CHAR *pchQd;
     RECT rc;

     /* Store edits for current appointment description. */
     if (vhwndFocus == vhwnd3)
	  CalSetFocus ((HWND)NULL);

     /* Set the new current ln. */
     vlnCur = ln;

     /* do this to fix bug when scrolling before window is
      * actually painted on screen.  the movewindow below
      * forces the parents update region to clip out where
      * the child window was, and it would not get erased.
      * if in the scrollup/dn code, don't do the update or
      * you get an unnecessary flash.  vfUpdate will be false.
      * 27-Oct-1987. davidhab.
      */
     if (vfUpdate && GetUpdateRect(vhwnd2B, (LPRECT)&rc, FALSE)) {
        GetWindowRect(vhwnd3, (LPRECT)&rc);
        UpdateWindow(vhwnd2B);
     }


     ShowWindow(vhwnd3, SW_HIDE);
     MoveWindow (vhwnd3, vxcoQdFirst, YcoFromLn (ln),
		vxcoQdMax - vxcoQdFirst , vcyFont, FALSE);

     pbTqr = PbTqrLock ();
     pchQd = "";
     if (vtld [ln].otqr != OTQRNIL)
	  pchQd = (CHAR *)(pbTqr + vtld [ln].otqr + CBQRHEAD);
     /*SendMessage (vhwnd3, WM_SETREDRAW, FALSE, 0L);*/
     SetEcText(vhwnd3, pchQd);
     ShowWindow(vhwnd3, SW_SHOW);
     /*SendMessage (vhwnd3, WM_SETREDRAW, TRUE, 0L);
     ValidateRect (vhwnd3, (LPRECT)NULL);*/
     DrUnlockCur ();

     /* If not in the notes area, give the focus to the appointment
	description edit control.
     */
     if (vhwndFocus == vhwnd3)
          CalSetFocus (vhwnd3);



     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calcmd.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calcmd.c
 *
*/

#include "cal.h"
#include <shellapi.h>



/**** CalCommand - process menu command. */

VOID APIENTRY CalCommand (
     HWND hwnd,
     INT  idcm)
     {
     register HDC  hDC;
     register DT   dt;
     HWND          hwndFocus;
     DWORD        iSelFirst;
     DWORD        iSelLast;
     INT           tmStart12;
     INT           itdd;
     DD            *pdd;
     BOOL          fTemp;

     /* Make the target date the same as the selected date.  Several
        commands depend on this.
     */
     vd3To = vd3Sel;

     switch (idcm)
	  {
          case IDCM_ABOUT:
               ShellAbout(hwnd, vrgsz[IDS_CALENDAR], "", 
                          LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
						  MAKEINTRESOURCE(1)));
               break;

          case IDCM_EXIT:
               PostMessage(hwnd, WM_CLOSE, 0, 0L);
               break;

	  case IDCM_NEW:

               if (FCheckSave (FALSE))
                   {
                   vfOpenFileReadOnly = FALSE;  /* in case earlier file was readonly */
                   CleanSlate (TRUE);
                   }
               break;

          case IDCM_OPEN:
               if (FCheckSave (FALSE))
                   {
                   vfOpenFileReadOnly = FALSE;  /* in case earlier file was readonly */
                   OpenCal ();
                   }
	       break;

	  case IDCM_SAVE:
	       if (vfOpenFileReadOnly)
		  {
		  AlertBox (vszFileReadOnly, (CHAR *)NULL,MB_APPLMODAL|MB_OK|
							  MB_ICONEXCLAMATION);
		  break;
                   }
               else
                   if (vfOriginalFile)
                       {
                       hwndFocus = GetFocus();
                       FSaveFile (vszFileSpec, TRUE);
                       SetFocus(hwndFocus);
                       break;
                       }

               /* There is no original file, which means we are still
                  untitled, so we can't do a Save without getting a file
                  name from the user.  Fall into the Save As to do so.
               */


	  case IDCM_SAVEAS:
	       CallSaveAsDialog();
               break;

          case IDCM_PAGESETUP:
               FDoDialog (IDD_PAGESETUP);
	       break;

          case IDCM_PRINT:
	       if (FDoDialog (IDD_PRINT))
                    Print ();
               break;

	  case IDCM_PRINTERSETUP:
	       vPD.Flags |= PD_PRINTSETUP;  /* invoke only the Setup dialog */
	       bPrinterSetupDone = PrintDlg ((LPPRINTDLG)&vPD);
               break;


          case IDCM_REMOVE:
               if (FDoDialog (IDD_REMOVE))
                    Remove ();
               break;

          /* Guy hit delete key - either shifted or unshifted. */
          case IDCM_DEL:

               /* If window with focus is not edit ctl, nop. */
               if ((hwndFocus = GetFocus()) == vhwnd2B)
                    break;

               /* Do something only if there is a non-null selection. */
	       MSendMsgEM_GETSEL(hwndFocus, &iSelFirst, &iSelLast);
               if (iSelFirst != iSelLast)
                    {
                    /* If shifted delete, do a cut (which is a menu function.) */
                    if ((GetKeyState(VK_SHIFT) < 0) || (GetKeyState(VK_DELETE) >= 0))
                        {
                        HiliteMenuItem(vhwnd0, GetMenu(vhwnd0), IDCM_CUT, MF_HILITE | MF_BYCOMMAND);
                        SendMessage(hwndFocus, WM_CUT, (WORD)0, 0L);
                        HiliteMenuItem(vhwnd0, GetMenu(vhwnd0), IDCM_CUT, MF_BYCOMMAND);

                    /* Otherwise, do a clear (which is not a menu function.) */
                        }
                    else
                        SendMessage(hwndFocus, WM_CLEAR, (WORD)0, 0L);

                   }
               break;

          /* Note - Cut, Copy, and Paste are only enabled when
             one of the edit controls has the focus, so we know
             it's OK to just send the command to the edit control.
          */
          case IDCM_CUT:
               SendMessage (GetFocus (), WM_CUT, (WORD)0, 0L);
               break;

          case IDCM_COPY:
               SendMessage (GetFocus (), WM_COPY, (WORD)0, 0L);
               break;

          case IDCM_PASTE:
               SendMessage (GetFocus (), WM_PASTE, (WORD)0, 0L);
               break;

          case IDCM_DAY:
               DayMode (&vd3Sel);
               break;

	  case IDCM_MONTH:

	       vmScrollPos = 0;
	       hmScrollPos = 0;
	       MonthMode();
               break;

          case IDCM_TODAY:
               if (vfDayMode)
                    SwitchToDate (&vd3Cur);
               else
                   {
                   /* added setfocus to fix bug where if in another month,
                    * and focus in notes area, today's notes would get
                    * overwritten with the current notes. why? who knows!
                    */
                   CalSetFocus(vhwnd2B);
                   JumpDate (&vd3Cur);
                   }
               break;

          case IDCM_PREVIOUS:
               if (vfDayMode)
                    {
                    if ((dt = DtFromPd3 (&vd3Sel)) != DTFIRST)
                         {
                         GetD3FromDt (--dt, &vd3To);
                         SwitchToDate (&vd3To);
                         }
                    }
               else
                    {
		    /* Show the previous month . */
		    /* This  causes the new month window to be displayed
		       from week 1 */
		    vmScrollPos = 0;
		    SetScrollPos (vhwnd2B, SB_VERT, vmScrollPos,TRUE);
                    ShowMonthPrevNext (FALSE);
                    }
               break;

          case IDCM_NEXT:
               if (vfDayMode)
                    {
                    if ((dt = DtFromPd3 (&vd3Sel)) != DTLAST)
                         {
                         GetD3FromDt (++dt, &vd3To);
                         SwitchToDate (&vd3To);
                         }
                    }
               else
                    {
		    /* Show the next month. */
		    vmScrollPos = 0;
		    SetScrollPos (vhwnd2B, SB_VERT, vmScrollPos, TRUE);
                    ShowMonthPrevNext (TRUE);
                    }
               break;

          case IDCM_DATE:
               if (FDoDialog (IDD_DATE))
                    {
                    if (vfDayMode)
                         SwitchToDate (&vd3To);
                    else {
                         /* added setfocus to fix bug where if in another month,
                          * and focus in notes area, today's notes would get
                          * overwritten with the current notes. why? who knows!
                          */
                         CalSetFocus(vhwnd2B);
                         JumpDate (&vd3To);
                         }
                    }
               break;

          case IDCM_SET:
               AlarmToggle ();
               break;

          case IDCM_CONTROLS:
               if (FDoDialog (IDD_CONTROLS))
                    {
                    /* It's possible that the user just increased the
                       Early Ring period.  If so, it may be time for the
                       next alarm to go off.  Call AlarmCheck directly since
                       CalTimer won't do it until the minute changes, and
                       that might not be soon enough.
                       Note that shortening the Early Ring period does not
                       cause alarms that have previously gone off (due to
                       the older, longer Early Ring period) to go off again.
                       For example if the Early Ring period was 10, at 9:20
                       the 9:30 alarm went off.  If at 9:23 the user changes
                       the Early Ring period to 5 minutes, the 9:30 alarm
                       will not go off again at 9:25.  The user has already
                       seen the alarm.
                    */
                    AlarmCheck ();

                    /* Changing the alarm controls makes the file dirty.
                       Note that the user may not have actually changed
                       the settings, but he did push the OK button, and
                       that's close enough.  It would be a waste of code
                       to only set the dirty flag when the settings are
                       actually different.
		    */
                    vfDirty = TRUE;
                    }
               break;



	  case IDCM_MARK:
	       dt = DtFromPd3(&vd3Sel);    /* fetch selected day */
	       FSearchTdd (dt, &itdd);
	       pdd = TddLock() + itdd;
	       TddUnlock();

	       viMarkSymbol = pdd->fMarked;   /* set viMarkSymbol with active
					       marks on selected day */
	       /* show mark dialog */
	       fTemp =	(BOOL)DialogBox(vhInstance,
			MAKEINTRESOURCE(IDD_MARK), vhwnd0,
			FnMarkDay);
               vhwndDialog = NULL;

	       if (fTemp)
                  CmdMark ();

	       break;

          /* Go Do help.  Since menu items match numbers in help file,
           * no need to change them before calling help.
           */
          case IDCM_HELP:
               WinHelp(hwnd, vszHelpFile, HELP_INDEX, 0L);
               break;

          case IDCM_USINGHELP:
               WinHelp(hwnd, NULL, HELP_HELPONHELP, 0L);
               break;

          case IDCM_SEARCH:
               WinHelp(hwnd, vszHelpFile, HELP_PARTIALKEY, (DWORD_PTR)"");
               break;

          case IDCM_SPECIALTIME:
               if (FDoDialog (IDD_SPECIALTIME))
                    {
		    if (vfInsert)
                         InsertSpecial ();
                    else
                         DeleteSpecial ();
                    }
               break;

          case IDCM_DAYSETTINGS:
               if (FDoDialog (IDD_DAYSETTINGS))
                    {
                    /* Changing the day settings makes the file dirty.
                       Note that the user may not have actually changed
                       the settings, but he did push the OK button, and
                       that's close enough.  It would be a waste of code
                       to only set the dirty flag when the settings are
                       actually different.
                    */
                    vfDirty = TRUE;

                    /* Redisplay the time since the clock format
                       may have been changed.
                    */
                    hDC = CalGetDC (vhwnd2A);
                    DispTime (hDC);
                    ReleaseDC (vhwnd2A, hDC);

                    if (vfDayMode)
                         {
                         /* Since the clock format, interval, and starting
                            hour all affect the day mode display, just
                            call DayMode to redisplay the whole works.
                         */
                         DayMode (&vd3Sel);
                         }
                    }
               break;

    /* Added new key functionality.  Ctrl+Home scrolls appointment
     * window to StartTime.  Ctrl+End scrolls to StartTime + 12 hours.
     * 26-Mar-1987.
     */
        case IDCM_START12:
                tmStart12 = vtmStart + 12 * 60; /* 12 hours later */
                if (tmStart12 > TMLAST-61)
                    tmStart12 = TMLAST-61;
                /* fall thru... */

        case IDCM_START:
            if (vfDayMode && (GetFocus() == vhwnd3))
                FScrollDay(SB_THUMBPOSITION,
                           ItmFromTm(idcm==IDCM_START ? vtmStart : tmStart12));
            break;
          }
     }




/**** FDoDialog - Do modal dialog. */

BOOL APIENTRY FDoDialog (INT  idd)
     {
     INT fTemp;

     fTemp = (INT)DialogBox(vhInstance, MAKEINTRESOURCE(idd),
			vhwnd0, vrglpfnDialog[idd-1]);
     /* Tell AlertBox there is no longer a dialog active. */
     vhwndDialog = NULL;

     return (fTemp);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\caldata2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** caldata2.c
 *****
*/

#include "cal.h"


CHAR *vrgsz [CSTRINGS+1];  /* Strings loaded in from the resource file. */

D3   vd3Sel;		 /* Selected date. */
WORD vwDaySticky;	 /* The sticky selected day. */

INT vrgbMonth [CBMONTHARRAY];	  /* Days of the month being displayed.
				     Changed from BYTE to int  */
INT  vcDaysMonth;	 /* Number of days in the month being displayed. */
INT  vcWeeksMonth;	 /* Number of weeks in the month being displayed. */
WORD vwWeekdayFirst;	 /* The weekday of the first day of the month. */

INT  vrgxcoGrid [8];	 /* Month grid xco - maximum of 7 days, so 8 lines. */
INT  vrgycoGrid [7];	 /* Month grid yco - maximum of 6 weeks, so 7 lines. */

WORD votqrPrev;
WORD votqrCur;
WORD votqrNext;

WORD vidrCur;		      /* The index into vrghlmdr for the current DR. */
LOCALHANDLE vrghlmDr [CDR];   /* The handles of the DRs. */

LOCALHANDLE  vhlmTdd = 0; /* Handle to table of date descriptors. */
INT  vcddAllocated = 0;	  /* Count of allocated date descriptors. */
INT  vcddUsed = 0;		  /* Count of date descriptors in use. */

/* Used for passing dates from dialogs to command handlers. */
DT   vdtFrom;
D3   vd3To;
DT   vdtTo;
INT  vitddFirst;
INT  vitddMax;

/* The handle of the window that should get the focus when we get
   activated via a WM_ACTIVATE with wParam == TRUE.  When the
   appointment description edit control or the notes area
   edit control notifies us that it is getting the focus, we store
   its window handle in vhwndFocus.  When we set focus to the monthly
   calendar, we also set up vhwndFocus.
*/
HWND vhwndFocus = (HWND)NULL;


/* File handles. */
INT  hFile[CFILE];

/* ReOpen Buffers. */
OFSTRUCT  OFStruct [CFILE];

BOOL vfChangeFile = FALSE;    /* FALSE if couldn't create the change file,
				 TRUE if change file exists.
				 Must be initialized to FALSE so the first
				 call to CreateChangeFile doesn't attempt
				 to delete an old change file (since there
				 isn't one).
			      */
INT vobkEODChange;	 /* Offset in blocks of the end of data in the
			    change file.
			 */

CHAR vszFileSpec   [CCHFILESPECMAX];	/* Name of original file. */
CHAR vszFilterSpec [CCHFILTERMAX];	/* Filter string for File Open */
CHAR vszCustFilterSpec [CCHFILTERMAX];/* custom Filter string for File Open */

BOOL vfOriginalFile;	      /* FALSE means untitled, TRUE means there
				 is an original file.
			      */
INT  vobkEODNew;	 /* Offset in blocks of the end of data in the
			    new file.
			 */

BOOL vfDirty;		 /* FALSE means no changes since the last Save. */

/* This is the magic number we put at the beginning of a calendar file
   so no one fools us into using some other sort of file.
*/
BYTE vrgbMagic [CBMAGIC] =
     {
     'C' + 'r',
     'A' + 'a',
     'L' + 'd',
     'E' + 'n',
     'N' + 'e',
     'D' + 'l',
     'A' + 'a',
     'R' + 'c'
     };

HDC vhDCMemory = 0;		  /* Memory DC for BitBlts. */
HBITMAP vhbmLeftArrow = 0;	  /* Handle to bitmap for left arrow. */
HBITMAP vhbmRightArrow = 0;	  /* Handle to bitmap for left arrow. */
HBITMAP vhbmBell = 0;		  /* Handle to alarm bell bitmap. */

/* x coordinates within Wnd2A of the day switching arrows. */
INT  vxcoLeftArrowFirst;
INT  vxcoLeftArrowMax;
INT  vxcoRightArrowFirst;
INT  vxcoRightArrowMax;


/* Merge spec - two byte string */
//- Merge Bytes: This is used to grab two chars from a string, make it string.
char vszMergeStr [3];

INT vmScrollPos=0;  /* Thumb position for vertical month scroll */
INT vmScrollInc=0;  /* step size for vertical month scroll */
INT vmScrollMax=0;  /* maximum vertical scroll position */
INT hmScrollPos=0;  /* Thumb position for horiz. month scroll */
INT hmScrollInc=0;  /* step size for horiz. month scroll */
INT hmScrollMax=0;  /* maximum horiz. scroll position */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calday2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calday2.c
 *****
*/

#include "cal.h"


/**** SetDayScrollRange */

VOID APIENTRY SetDayScrollRange ()

     {

     /* Set the range so that the minimum thumb position corresponds to
        having the first TM of the day at the top of the window and
        the maximum thumb position corresponds to having the last TM
        of the day at the bottom of the window.  We want to always be
        able to work from the first TM in the window, so we observe
        that the last TM of the day is at the bottom of the window
        when the last windowful (or page) of TMs is up, and this
        is when the (ctmDay - vcln)th TM is at the top of the window.
        For example, if there are 100 TMs (0 - 99), and we can display
        10 TMs in the window (vcln == 10), we are maxed out when
        90 through 99 are in the window.
        Note that calling ItmFromTm with TMNILHIGH returns the count
        of TMs in the day.
     */
     SetScrollRange (vhwnd2B, SB_VERT, 0, ItmFromTm (TMNILHIGH) - vcln, FALSE);

     }


/**** AdjustDayScrollRange - adjust the scroll bar range by the specified
      number of TMs.
*/

VOID APIENTRY AdjustDayScrollRange (INT ctm)
     {

     INT  itmMin;
     INT  itmMax;

     GetScrollRange (vhwnd2B, SB_VERT, (LPINT)&itmMin, (LPINT)&itmMax);
     SetScrollRange (vhwnd2B, SB_VERT, 0, itmMax + ctm, FALSE);

     }


/**** SetDayScrollPos - position the thumb. */

VOID APIENTRY SetDayScrollPos (register INT itm)
     {

     /* If called with itm == -1, position the thumb based on the TM
        at the top of the window.
     */
     if (itm == -1)
          itm = ItmFromTm (vtld [0].tm);

     SetScrollPos (vhwnd2B, SB_VERT, itm, TRUE);

     }


/**** AdjustDayScrollPos - adjust the position of the thumb relative
      to its old position.
*/

VOID APIENTRY AdjustDayScrollPos (INT ctm)
			/* Positive to increase thumb position (towards
                            bottom of window), negative to decrease thumb
                            (towards top of window).
                         */

     {

     SetDayScrollPos (GetScrollPos (vhwnd2B, SB_VERT) + ctm);

     }



/**** ItmFromTm - map a TM to an index within the range of TMs for the day.
      If tmToMap does not exist within the day (not a regular time and
      not in the tqr), we return the index of the next
      highest TM.  Therefore, to find out how many TMs there are in
      the day, call ItmFromTm with tmToMap == TMNILHIGH.  SetDayScrollRange
      depends on this.

      Note - tmToMap must be in the closed interval 0 through TMNILHIGH.
*/

INT  APIENTRY ItmFromTm (TM tmToMap)
     {

     INT  itm;

     itm = -1;

     MapTmAndItm (&tmToMap, &itm);
     return (itm);

     }


/**** TmFromItm - map TM to an index within the range of TMs for this date. */

TM   APIENTRY TmFromItm (INT  itm)
     {

     TM   tm;

     MapTmAndItm (&tm, &itm);
     return (tm);

     }


/**** MapTmAndItm - map TM to itm and vice versa.
      To map a TM to an itm:  *ptmMap == TM to map,  *pitmMap == -1.
      To map an itm to a TM:: *ptmMap == don't care, *pitmMap == itm to map.

*/

VOID APIENTRY MapTmAndItm (
    TM   *ptmMap,
    INT  *pitmMap)

     {

     register TM tmCur;
     register TM tmFromQr;
     TM   tmMap;
     DR   *pdr;
     PQR	pqrCur;
     PQR	pqrMax;
     INT  itm;
     BOOL fMapTmToItm;

     tmMap = ((fMapTmToItm = *pitmMap) == -1) ? *ptmMap : TMNILHIGH;

     /* Lock the DR, and get First and Max pointers for the tqr. */
     pdr = PdrLockCur ();

     pqrMax = (PQR)((BYTE*)(pqrCur = (PQR)PbTqrFromPdr(pdr)) + pdr->cbTqr);

     /* Find the first QR time. */
     tmFromQr = TmFromQr (&pqrCur, pqrMax);

     /* Starting at the first possible TM of the day (0), keep going
        until we find a TM greater than or equal to the one we're mapping.
     */
     for (itm = (INT)(tmCur = 0); tmCur < tmMap && itm != *pitmMap; itm++)
          {
          if ((tmCur = TmNextRegular (tmCur)) >= tmFromQr)
               {
               /* The QR TM is less than or equal to the next
                  regular TM, so use the one from the QR in order to
                  skip over it.

                  Note - At this point, both tmCur and tmFromQr could
                  be TMNILHIGH (because there aren't anymore QRs
                  and there are no more regular times.  This works OK
                  since we end up using TMNILHIGH which will terminate
                  terminate the loop since TMNILHIGH is the highest value
                  the caller is permitted to pass.  Calling TmFromQr
                  with pqrCur == pqrMax works OK too, so no problem there.
               */
               if ((tmFromQr = TmFromQr (&pqrCur, pqrMax)) < tmCur)
                    tmCur = tmFromQr;
               }
          }

     DrUnlockCur ();

     /* Pass back the mapped value to the caller. */
     if (fMapTmToItm)
          *pitmMap = itm;
     else
          *ptmMap = tmCur;

     }


/**** TmFromQr - return TM of the current QR or TMNILHIGH if there
      isn't one.  Also update pqrCur to point past the last QR we inspect.

      Note - Guaranteed to do the right thing if called with
      pqrCur == pqrMax.  In this case we return TMNILHIGH and pqrCur
      is unchanged.
*/

TM   APIENTRY TmFromQr (
    PQR	*ppqrCur,          /* Input - pqrCur points to the current QR.
				Output - pqrCur points to the next QR or
				is equal to pqrMax if no next QR.
			     */
    PQR	pqrMax)

     {

     register PQR pqr;
     register TM tm;

     /* Assume there are no more QRs. */
     tm = TMNILHIGH;

     if ((pqr = *ppqrCur) < pqrMax)
          {
          tm = pqr -> tm;
          *ppqrCur = (PQR)((BYTE*)pqr + pqr->cb);
          }

     return (tm);

     }


/**** TmNextRegular - return the next regular TM or TMNILHIGH if there
      is no next regular TM.
*/

TM   APIENTRY TmNextRegular (register TM tm)
     {

     register TM tmNext;

     /* Calculate the next regular appointment time. */
     tmNext = tm + vcMinInterval - (tm % vcMinInterval);

     /* Return TMNILHIGH if beyond the end of the day. */
     if (tmNext > TMLAST)
          tmNext = TMNILHIGH;

     return (tmNext);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calcmd2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calcmd2.c
 *
 */

#include "cal.h"
#define ATTRDIR   0xC010        /* added for the revised SaveAs dialog */
#include <ctype.h>
#include <fcntl.h>       /* Get O_RDONLY definition for open call. */
CHAR rgch[256];    /* moved out of FnSaveAs because of 512 byte limit of local variables */
CHAR szFullPathName[120];

INT CheckMarginNums(HWND hWnd);

BOOL APIENTRY CallSaveAsDialog ()
{
     CHAR szSaveFileSpec [CCHFILESPECMAX] = "";
     CHAR szAnsiFileSpec [CCHFILESPECMAX];
     extern CHAR szLastDir[];

     /* default selection in edit window */
     lstrcpy (szSaveFileSpec, OFStruct[IDFILEORIGINAL].szPathName);

     /* set up the variable fields of the OPENFILENAME struct. (the constant
      * fields have been sel in CalInit()
      */
     vOFN.lpstrFile	    = szSaveFileSpec;
     vOFN.lpstrInitialDir   = szLastDir;
     vOFN.lpstrTitle	    = vszSaveasCaption;
     vOFN.Flags 	    = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;	   /* always 0 for SaveAs */

     /* All long pointers should be defined immediately before the call.
      * L.Raman - 2/12/91
      */
     vOFN.lpstrFilter	    = vszFilterSpec;
     vOFN.lpstrCustomFilter = vszCustFilterSpec;
     vOFN.lpstrDefExt	    = vszFileExtension + 1;   /* point to "CAL" */

     if ( GetSaveFileName ((LPOPENFILENAME)&vOFN))
     {
// on NT, don't do the oemtoansi, just copy the file into new buffer.
// OemToAnsi(vOFN.lpstrFile, szAnsiFileSpec);

     strcpy(szAnsiFileSpec, vOFN.lpstrFile);
	 return FSaveFile (szAnsiFileSpec, FALSE);
     }
     return FALSE;
}

/****************************************************************************
 *
 * INT_PTR FnPageSetup (hwnd, message, wParam, lParam)
 *
 * purpose : Dialog function for page setup dialog. Accepts header/footer
 *	     formatting instructions and margin lengths.
 *
 * params  : same as for all dialog functions
 *
 *
 ***************************************************************************/

INT_PTR CALLBACK FnPageSetup (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int      id;
    WORD2DWORD          iSelFirst;
    WORD2DWORD          iSelLast;

    switch (message)
    {
        case WM_INITDIALOG :
            EnableWindow (GetDlgItem (hwnd, IDOK), TRUE);

            /* Set the Dialog Items to what they were before.  Also handles case
             * when Page Setup is chosen for the first time. */

            for (id=IDCN_EDITHEADER; id < IDCN_EDITHEADER+6; id++)
            {
                SendDlgItemMessage(hwnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hwnd, id, chPageText[id-IDCN_EDITHEADER]);
            }

            iSelLast = PT_LEN-1;
            iSelFirst = 0;
	    MSendMsgEM_GETSEL(GetDlgItem(hwnd, IDCN_EDITHEADER),
				&iSelFirst, &iSelLast);
            CalSetFocus (GetDlgItem (hwnd, IDCN_EDITHEADER));
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    /* Store the changes made only if margins are valid nums. */
                    id = CheckMarginNums(hwnd);
                    if (id <= 0)       /* invalid margins */
                    {
                        MessageBox(hwnd, vszIncorrectSyntax, vszCalendar, MB_OK | MB_ICONEXCLAMATION);
                        if (id == 0)   /* can't guess invalid margin */
                            return TRUE;    /* continue the dialog */
                        else
                        {
                            CalSetFocus(GetDlgItem (hwnd, -id));
                            return FALSE;
                        }
                    }
                    /* store the margin values */

                    for (id = IDCN_EDITHEADER; id <= IDCN_EDITHEADER+6; id++)
                        GetDlgItemText(hwnd, id, chPageText[id-IDCN_EDITHEADER], PT_LEN-1);

                    EndDialog (hwnd, TRUE);
                    break;

              case IDCANCEL :
                 EndDialog (hwnd, FALSE);
                 break;
            }
            return TRUE;
    }

    return FALSE;
}

/* Check valididity of margin values specified.
 *  return TRUE if margins are valid.
 *
 *  returns  -IDCN_EDITMARGINLEFT if Left margin is invalid,
 *           -IDCN_EDITMARGINRIGHT if Right margin is invalid
 *           -IDCN_EDITMARGINTOP   if Top margin is invalid
 *           -IDCN_EDITMARGINBOTTOM if Bottom margin is invalid
 *           0/FALSE if it cannot guess the invalid margin
 */

INT CheckMarginNums(HWND hWnd)
    {
    SHORT   n;
    CHAR    *pStr;
    CHAR    szStr[PT_LEN];
    UINT    Left, Right, Top, Bottom;
    HDC     hPrintDC;
    UINT    xPixInch, yPixInch, xPrintRes, yPrintRes;

    for (n = IDCN_EDITHEADER+2; n < IDCN_EDITHEADER+6; n++)
        {
        GetDlgItemText(hWnd, n, szStr, PT_LEN);
        pStr = szStr;

        while (*pStr)
            if (isdigit(*pStr) || *pStr == szDec[0])
                pStr = AnsiNext(pStr);
            else
                return (-n);
        }

    if (!(hPrintDC = GetPrinterDC()))
        return FALSE;

    xPrintRes = GetDeviceCaps(hPrintDC, HORZRES);
    yPrintRes = GetDeviceCaps(hPrintDC, VERTRES);
    xPixInch  = GetDeviceCaps(hPrintDC, LOGPIXELSX);
    yPixInch  = GetDeviceCaps(hPrintDC, LOGPIXELSY);

    DeleteDC(hPrintDC);

    /* margin values have int/float values. Do range check */
    GetDlgItemText(hWnd, IDCN_EDITMARGINLEFT, szStr, PT_LEN);
    Left     = atopix(szStr,xPixInch);

    GetDlgItemText(hWnd, IDCN_EDITMARGINRIGHT, szStr, PT_LEN);
    Right    = atopix(szStr, xPixInch);

    GetDlgItemText(hWnd, IDCN_EDITMARGINTOP, szStr, PT_LEN);
    Top      = atopix(szStr, yPixInch);

    GetDlgItemText(hWnd, IDCN_EDITMARGINBOT, szStr, PT_LEN);
    Bottom   = atopix(szStr, yPixInch);

    /* try to guess the invalid margin */

    if (Left >= xPrintRes)
        return -IDCN_EDITMARGINLEFT;        /* Left margin is invalid */
    else if (Right >= xPrintRes)
        return -IDCN_EDITMARGINRIGHT;       /* Right margin is invalid */
    else if (Top >= yPrintRes)
        return -IDCN_EDITMARGINTOP;         /* Top margin is invalid */
    else if (Bottom >= yPrintRes)
        return -IDCN_EDITMARGINBOT;         /* Bottom margin is invalid */
    else if (Left >= (xPrintRes-Right))
        return FALSE;                   /* can't guess, return FALSE */
    else if (Top >= (yPrintRes-Bottom))
        return FALSE;                   /* can't guess, return FALSE */

    return TRUE;
    }

/**** FnDate */

INT_PTR CALLBACK FnDate (
     HWND hwnd,
     UINT message,
     WPARAM wParam,
     LPARAM lParam)
     {
     CHAR szDate [CCHDASHDATE];
     INT    iErr;

     switch (message)
	  {
	  case WM_INITDIALOG:
	       /* Remember the window handle of the dialog for AlertBox. */
	       vhwndDialog = hwnd;

	       SetDlgItemText (hwnd, IDCN_TODATE, "");
	       return (TRUE);

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		   case IDOK:
			 GetDlgItemText (hwnd, IDCN_TODATE, szDate, CCHDASHDATE);

			 if ((iErr = FD3FromDateSz (szDate, &vd3To)) == 0)
			      EndDialog (hwnd, TRUE);
			 else
			      {
			      /* Error in date - put up message box. */
			      DateTimeAlert(TRUE, iErr);
			      /* line added to fix keyboard hang problem
				 when running under 1.11 */
			      CalSetFocus (GetDlgItem(hwnd, IDCN_TODATE));
                              /* Select entire contents of edit control. */
                              /*  16 July 1989  Clark Cyr                */
			      SendDlgItemMessage(hwnd, IDCN_TODATE, EM_SETSEL,
                                      0, (DWORD)(-1L));
			      }
			 break;

		    case IDCANCEL:
			 EndDialog (hwnd, FALSE);
			 break;
		    }
	       return (TRUE);
	  }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }



/**** FnControls */

INT_PTR CALLBACK FnControls (
     HWND hwnd,
     UINT message,
     WPARAM wParam,
     LPARAM lParam)
     {
     static BOOL fSound;
     static UINT cMinEarlyRing;

     BOOL fOk;

     switch (message)
	  {
	  case WM_INITDIALOG:
	       /* Remember the window handle of the dialog for AlertBox. */
	       vhwndDialog = hwnd;

	       CheckDlgButton (hwnd, IDCN_SOUND, fSound = vfSound);
	       SetDlgItemInt (hwnd, IDCN_EARLYRING,
		cMinEarlyRing = vcMinEarlyRing, FALSE);
	       return (TRUE);

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		    case IDOK:
			 cMinEarlyRing = GetDlgItemInt (hwnd, IDCN_EARLYRING,
			      &fOk, FALSE);

			 if (!fOk || cMinEarlyRing > 10)
			      {
			      /* The value didn't parse or it's not within
				 range.  Put up an error message.
			      */
			      AlertBox (vszBadEarlyRing,
			       (CHAR *)NULL,
			       MB_APPLMODAL | MB_OK | MB_ICONASTERISK);

			      /* Don't end the dialog - they will have to
				 enter a proper time or cancel.
			      */
			      /* line added to fix keyboard hanging problem
				 in ver 1.11 */
			      CalSetFocus (GetDlgItem( hwnd, IDCN_EARLYRING));
			      break;
			      }

			 /* Assign the new values. */
			 vfSound = fSound;
			 vcMinEarlyRing = cMinEarlyRing;

			 EndDialog (hwnd, TRUE);
			 break;

		    case IDCANCEL:
			 EndDialog (hwnd, FALSE);
			 break;

		    case IDCN_SOUND:
			 CheckDlgButton (hwnd, IDCN_SOUND,
			  !IsDlgButtonChecked (hwnd, IDCN_SOUND));
			 fSound = !fSound;
			 break;
		    }
	       return (TRUE);
	  }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }




/**** FnSpecialTime */

INT_PTR CALLBACK FnSpecialTime (
     HWND hwnd,
     UINT message,
     WPARAM wParam,
     LPARAM lParam)
     {
     static INT idcheck;
     CHAR szTime [CCHTIMESZ];
     register CHAR *szError;
     register TM tm;
     INT	iErr;

     switch (message)
	  {
	  case WM_INITDIALOG:
	       /* Remember the window handle of the dialog for AlertBox. */
	       vhwndDialog = hwnd;

	       /* If the currently selected appointment is not for a regular
		  time, put the time into the edit control as the default.
		  This makes it easy for the user to delete the special time.
	       */
	       if ((tm = vtld [vlnCur].tm) % vcMinInterval != 0)
		    {
		    GetTimeSz (tm, szTime);
		    SetDlgItemText (hwnd, IDCN_EDIT, szTime);
		    }

	       /* Enable or disable the Insert and Delete buttons. */
	       CheckButtonEnable (hwnd, IDCN_INSERT, EN_CHANGE);
	       CheckButtonEnable (hwnd, IDCN_DELETE, EN_CHANGE);

	       /* Check if the display is in 24Hr format; If so, disable the
	        * AM/PM radio buttons;
		* Fix for Bug #5447 --SANKAR-- 10-19-89;
		*/
	       if(vfHour24)
	         {
		   EnableWindow(GetDlgItem(hwnd, IDCN_AM), FALSE);
		   EnableWindow(GetDlgItem(hwnd, IDCN_PM), FALSE);
		 }
	       else
	           CheckRadioButton (hwnd, IDCN_AM, IDCN_PM, viAMorPM);
	       return (TRUE);


	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		    case IDCN_EDIT:
			 CheckButtonEnable (hwnd, IDCN_INSERT, EN_CHANGE);
				//- FnSpecialTime: Changed GetParam to EN_CHANGE.
				//- Not sure why the old one ever worked.
				//- GET_WM_COMMAND_ID(wParam, lParam));
			 CheckButtonEnable (hwnd, IDCN_DELETE, EN_CHANGE);
				//- FnSpecialTime: Changed GetParam to EN_CHANGE.
				//- GET_WM_COMMAND_ID(wParam, lParam));
			 break;

		    case IDCANCEL:
			 EndDialog (hwnd, FALSE);
			 break;

		    case IDCN_AM:
		    case IDCN_PM:
			 viAMorPM = GET_WM_COMMAND_ID(wParam, lParam);
			 CheckRadioButton (hwnd, IDCN_AM, IDCN_PM, viAMorPM);
			 break;

		    case IDOK:
		    case IDCN_INSERT:
			 vfInsert = TRUE;
			 szError = vszTimeAlreadyInUse;
			 goto InsDel;

		    case IDCN_DELETE:
			 vfInsert = FALSE;
			 szError = vszNoSuchTime;
InsDel:

			 GetDlgItemText (hwnd, IDCN_EDIT,
			  szTime, CCHTIMESZ);
			 if ((iErr = FGetTmFromTimeSz (szTime, &vtmSpecial)) < 0)
			      {
			      /* Error in time - put up message box. */
			      DateTimeAlert(FALSE, iErr);
			      /* Don't end the dialog - they will have to
				 enter a proper time or cancel.
			      */
			      CalSetFocus (GetDlgItem (hwnd, IDCN_EDIT));

			      break;
			      }

			 /* If we are in 24Hr format, then we should not allow
			  * the AM/PM radiobuttons to override;
			  * Fix for Bug #5447 --SANKAR-- 10-19-89
			  */
			 if(!vfHour24)
			   {
			     /* AM or PM value on radiobutton overrides
			        text text in edit window */

                             if (vtmSpecial < TWELVEHOURS)
                               {
                                 if (viAMorPM == IDCN_PM)
                                     vtmSpecial += TWELVEHOURS;
                               }
                             else if (vtmSpecial > TWELVEHOURS)
                               {
                                 if (viAMorPM == IDCN_AM)
                                     vtmSpecial -= TWELVEHOURS;
                               }
			   }

			 /* Don't allow a regular time to be inserted or
			    deleted.  Note
			    that it's possible for the special time bit for
			    a regular time to be set, but it still can't
			    be deleted.  For example, while the interval
			    in 60, insert a special time of 8:30.  Then
			    switch the interval to 30.	While the interval
			    is 30 (or 15), the 8:30 time cannot be deleted.
			 */
			 if (vtmSpecial % vcMinInterval == 0)
			      {
			      /* Not a special time. */
			      AlertBox (vszNotSpecialTime,
			       (CHAR *)NULL, MB_APPLMODAL | MB_OK
			       | MB_ICONASTERISK);
			      break;
			      }

			 /* Don't allow insert if time already in tqr.
			    Don't allow delete if time not in tqr.
			    OK to use bitwise xor since TRUE == 1 and
			    FALSE == 0.
			 */
			 if (!(FSearchTqr (vtmSpecial) ^ vfInsert))
			      {
			      AlertBox (szError, (CHAR *)NULL,
			       MB_APPLMODAL | MB_OK| MB_ICONASTERISK);
			      break;
			      }

			 EndDialog (hwnd, TRUE);
			 break;
		    }
	       return (TRUE);
	  }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }




/**** FnDaySettings */

INT_PTR CALLBACK FnDaySettings (
     HWND hwnd,
     UINT message,
     WPARAM wParam,
     LPARAM lParam)
     {
     static INT idcnInterval;
     static INT idcnHourFormat;
     INT    vfHour24New;
     INT    iErr;
     CHAR szTime [CCHTIMESZ];

     switch (message)
	  {
	  case WM_INITDIALOG:
	       /* Remember the window handle of the dialog for AlertBox. */
	       vhwndDialog = hwnd;

	       CheckRadioButton (hwnd, IDCN_HOUR12, IDCN_HOUR24,
		idcnHourFormat = IDCN_HOUR12 + vfHour24);
	       GetTimeSz (vtmStart, szTime);
	       SetDlgItemText (hwnd, IDCN_STARTINGTIME, szTime);

	       /* We want the current setting of interval to be checked,
		  and we want the interval group of radio buttons to have
		  the focus.  It doesn't work to call CheckRadioButton
		  here and then let Windows set the focus to the first
		  TABGRP in the dialog box, since when it sets the focus,
		  it also sends us a message to check the first button in
		  the group (so we would always get 15 checked instead
		  of the current setting).  So we do our own SetFocus
		  to the interval button we want to check.  We then return
		  FALSE to tell Windows that we have done our own SetFocus.
	       */
	       CalSetFocus (GetDlgItem (hwnd, idcnInterval = IDCN_MIN15 +
		vmdInterval));
	       return (FALSE);

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		    case IDOK:
			 GetDlgItemText (hwnd, IDCN_STARTINGTIME,
                                         szTime, CCHTIMESZ);
			 /* Note - FGetTmFromTimeSz does not affect
			    vtmStart if it returns FALSE (i.e., if it detects
			    an error in the time string).
			 */
			 if ((iErr = FGetTmFromTimeSz (szTime, &vtmStart)) < 0)
			      {
			      /* Error in time - put up message box. */
			      DateTimeAlert(FALSE, iErr);

			      /* Don't end the dialog - they will have to
				 enter a proper time or cancel.
			      */
			      /* line added to fix keyboard hang problem
				 while running under 3.0 ver 1.11 */
			      CalSetFocus (GetDlgItem (hwnd, IDCN_STARTINGTIME));
			      break;
			      }

			 vfHour24New = idcnHourFormat - IDCN_HOUR12;
                         if (vfHour24 != vfHour24New)
                            {
			    vfHour24 = vfHour24New;
			    InitTimeDate(vhInstance, vfHour24 ? GTS_24HOUR : GTS_12HOUR);
                             }

			 switch (vmdInterval = idcnInterval - IDCN_MIN15)
			      {
			      case MDINTERVAL15:
				   vcMinInterval = 15;
				   break;

			      case MDINTERVAL30:
				   vcMinInterval = 30;
				   break;

			      case MDINTERVAL60:
				   vcMinInterval = 60;
				   break;
			      }
			 EndDialog (hwnd, TRUE);
			 break;

		    case IDCANCEL:
			 EndDialog (hwnd, FALSE);
			 break;

		    case IDCN_MIN15:
		    case IDCN_MIN30:
		    case IDCN_MIN60:
			 CheckRadioButton (hwnd, IDCN_MIN15, IDCN_MIN60,
			    idcnInterval = GET_WM_COMMAND_ID(wParam, lParam));
			 break;

		    case IDCN_HOUR12:
		    case IDCN_HOUR24:
			 CheckRadioButton (hwnd, IDCN_HOUR12, IDCN_HOUR24,
			    idcnHourFormat = GET_WM_COMMAND_ID(wParam, lParam));
			 break;
		    }
	       return (TRUE);
	  }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }


/****************************************************************
 *
 * INT_PTR FAR PASCAL FnMarkDay ( hwnd, message, wParam, lParam)
 *
 * purpose : puts up Options Mark dialog box and receives the
 *	     marks that are to be put up against the current day.
 *
 ***************************************************************/

INT_PTR APIENTRY FnMarkDay (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    BOOL checkbutton = FALSE;

    switch (message)
	{
	case WM_INITDIALOG:

	    /* check buttons corresp. to active marks on selected day */

	    CheckDlgButton( hwnd, IDCN_MARKBOX,  (viMarkSymbol & MARK_BOX));
	    CheckDlgButton( hwnd, IDCN_MARKPARENTHESES, (viMarkSymbol & MARK_PARENTHESES));
	    CheckDlgButton( hwnd, IDCN_MARKCIRCLE, (viMarkSymbol & MARK_CIRCLE));
	    CheckDlgButton( hwnd, IDCN_MARKCROSS, (viMarkSymbol & MARK_CROSS));
	    CheckDlgButton( hwnd, IDCN_MARKUNDERSCORE, (viMarkSymbol & MARK_UNDERSCORE));

	    CalSetFocus (GetDlgItem (hwnd, IDCN_MARKBOX));
	    return FALSE;

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		case IDOK:

		    viMarkSymbol = 0; /* clear existing bit pattern. This
				      is done so that only the marks specified
				      in dialog will appear on current day */

		    /* bits corresp. to selected mark symbols are set in MarkSymbol */

		    if (IsDlgButtonChecked(hwnd, IDCN_MARKBOX))
			viMarkSymbol |= MARK_BOX;

		    if (IsDlgButtonChecked(hwnd, IDCN_MARKPARENTHESES))
			viMarkSymbol |= MARK_PARENTHESES;

		    if (IsDlgButtonChecked(hwnd, IDCN_MARKCIRCLE))
			viMarkSymbol |= MARK_CIRCLE;

		    if (IsDlgButtonChecked(hwnd, IDCN_MARKCROSS))
			viMarkSymbol |= MARK_CROSS;

		    if (IsDlgButtonChecked(hwnd, IDCN_MARKUNDERSCORE))
			viMarkSymbol |= MARK_UNDERSCORE;

		    EndDialog (hwnd, TRUE);

		    break;

		case IDCANCEL:
		    EndDialog (hwnd, FALSE);
		    break;

		default :
		    return FALSE;
		} /* switch wParam */
            break;

	default :
            return FALSE;

	} /* switch message */
    return TRUE;

    } /* FnMark */



/**** AlertBox */

INT  APIENTRY AlertBox (
     CHAR *szText1,
     CHAR *szText2,
     UINT wStyle)
     {
     CHAR szMessage [160+128];
     register CHAR *pch;
     register HWND hwnd;

     MergeStrings(szText1, szText2, szMessage);

     MessageBeep (wStyle);

     /* The parent window is the active dialog if there is one.  If no
	active dialog, the parent window is Calendar's tiled window.
     */
     if ((hwnd = vhwndDialog) == NULL)
	  hwnd = vhwnd0;
     return (MessageBox (hwnd, szMessage, vszCalendar, wStyle));
     }



/**** Scan sz1 for merge spec.	If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL  APIENTRY MergeStrings(
    CHAR    *szSrc,
    CHAR    *szMerge,
    CHAR    *szDst)
    {
    register	CHAR *pchSrc;
    register	CHAR *pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

#ifdef DBCS
    /* Find merge spec if there is one. */
    //- Merge Bytes: Changed to string to avoid word boundry crossing.
    while (*pchSrc != *vszMergeStr || *(pchSrc + 1) != *(vszMergeStr + 1))
        {
        if( IsDBCSLeadByte( *pchSrc ) )
            *pchDst++ = *pchSrc++;
        *pchDst++ = *pchSrc;

	/* If we reach end of string before merge spec, just return. */
        if(!*pchSrc++)
            return FALSE;
    }
#else
    /* Find merge spec if there is one. */
    //- Merge Bytes: Changed to string to avoid word boundry crossing.
    while (*pchSrc != *vszMergeStr || *(pchSrc + 1) != *(vszMergeStr + 1))
        {
	*pchDst++ = *pchSrc;

	/* If we reach end of string before merge spec, just return. */
	if (!*pchSrc++)
	    return FALSE;

        }
#endif

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
	while (*szMerge)
	    *pchDst++ = *szMerge++;

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while (*pchDst++ = *pchSrc++);
    return TRUE;
    }




/**** If sz does not have extension, append ".TXT" */
VOID APIENTRY AddDefExt (LPSTR sz)
    {
    LPSTR pch1;
    register INT ch;

    pch1 = sz + lstrlen(sz);

    while ((ch = *pch1) != '.' && ch != '\\' && ch != ':' && pch1 > sz)
	pch1 = AnsiPrev(sz, pch1);

    if (*pch1 != '.')
	lstrcat(sz, vrgsz[IDS_FILEEXTENSION]);
    }


/**** CheckButtonEnable - Enable specified button if edit field not null,
      disable the button if the edit field is null.
*/

VOID APIENTRY CheckButtonEnable (
     HWND hwnd,
     INT  idButton,
     WORD message)
     {
     if (message == EN_CHANGE)
	  {
	  EnableWindow (GetDlgItem (hwnd, idButton),
	   (BOOL)(SendMessage (GetDlgItem (hwnd, IDCN_EDIT),
	   WM_GETTEXTLENGTH, 0, 0L)));
	  }
     }


/* FCheckSave - if the calendar is dirty see if the user wants to Save the
   the changes.
*/

BOOL APIENTRY FCheckSave (BOOL fSysModal)
     {
     /* Force current edits to be recorded right away since this may cause
	the file to be dirty.
      */

     RecordEdits ();

     if (vfDirty)
	  {
	  /* if file has been opened as read only, warn user and return */

          if (vfOpenFileReadOnly)
              {
              AlertBox (vszFileReadOnly, (CHAR *)NULL, MB_APPLMODAL|MB_OK|
                        MB_ICONEXCLAMATION);

              /* Force the Save As dialog letting user save under a
               * different name, thus not losing changes. */

	      CallSaveAsDialog();
	      return (TRUE);
              }

	  switch (AlertBox (vszSaveChanges, vszFileSpec,
                 (fSysModal ? MB_SYSTEMMODAL : MB_APPLMODAL) | MB_YESNOCANCEL
                 | MB_ICONEXCLAMATION))
	       {
	       case IDYES:
		    if (vfOriginalFile)
			 return (FSaveFile (vszFileSpec, TRUE));
		    else
			 return CallSaveAsDialog();

	       case IDCANCEL:
		    return (FALSE);

	       /* The IDNO case falls through to return TRUE. */
	       }
	  }
    return (TRUE);
    }




/**** RecordEdits - if the notes or the appointment description edit
      control has the focus, record the contents of the edit control
      without changing the focus.
*/

VOID APIENTRY RecordEdits ()
     {
     register HWND hwndFocus;

     if ((hwndFocus = GetFocus ()) == vhwnd2C)
	  StoreNotes ();
     else if (hwndFocus == vhwnd3)
	  StoreQd ();
     }



/**** Display error when user types date or time in wrong Format */
VOID APIENTRY DateTimeAlert(
    BOOL    fDate,
    INT     iErr)
    {
    CHAR    sz[256];
    CHAR    *pch1;
    CHAR    *pch2 = 0;
    DOSDATE dd;

    switch (iErr)
        {
	/* Range error only occurs for dates */
	case PD_ERRRANGE:
	    pch1 = vrgsz[IDS_DATERANGE];
	    break;

	case PD_ERRSUBRANGE:
	    pch1 = vrgsz[fDate ? IDS_DATESUBRANGE : IDS_TIMESUBRANGE];
	    break;

	case PD_ERRFORMAT:
	    pch1 = fDate ? vrgsz[IDS_BADDATE] : vrgsz[IDS_BADTIME];
	    pch2 = sz;
	    if (fDate)
		{
		dd.month = vd3Sel.wMonth + 1;
		dd.day = vd3Sel.wDay + 1;
		dd.year = vd3Sel.wYear + 1980;
		GetDateString(&dd, pch2, GDS_SHORT);
		}
	    else
		GetTimeSz(vftCur.tm, pch2);
	    break;
        }

    AlertBox (pch1, pch2, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\caldos.c ===
/*
 * caldos.c
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *              This file is/was ported from ..\..\progman\pmdos.c
 *              It contains two routines used by
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90 Author Unknown, since he didn't feel
 *                       like commenting the code...
 *
 *      NT 32b Version:  1/9/91 Jeff Pack
 *                       Intitial port to begin.
 *
 *  WARNING:  since this is NOT for DOS, I'm making it soley 32bit aware.
 *            Following functions not ported
 *              IsRemovable() is in pmcomman.c (already ifdef'd in asm code)
 *              IsRemote()  is in pmcomman.c   (ditto!)
 *
 */

#include "cal.h"
#include <string.h>
#include <time.h>

/*** GetCurDrive --     get current drive number.
 *
 *
 *
 * INT GetCurDrive(VOID)
 *
 * ENTRY -      VOID
 *
 * EXIT  -      INT CurrentDrive - drive number of current drive (0=a, etc).
 *
 * SYNOPSIS - calls GetCurrentDirectory, must parse returned string
 *            for either drive letter, or UNC path.  If UNC I gotta
 *            somehow, covert UNC path to drive letter to drive number.
 * WARNINGS - not DBCS aware!
 * EFFECTS  -
 *
 */

INT GetCurDrive(VOID)
{
    DWORD   nBufferLength = 128;
    DWORD   dwReturnCode;
    LPSTR   lpszLocalBuffer;
    INT     iDriveNumber;

    /* alloc local, non-moveable, zero filled buffer */
    lpszLocalBuffer = (LPSTR) LocalAlloc(LMEM_ZEROINIT, nBufferLength);
    if(lpszLocalBuffer == NULL){
        OutputDebugStringA("<GetCurDrive> LocalAlloc FAILed\n");
    }

GetCurDrive1:
    dwReturnCode = GetCurrentDirectory(nBufferLength, lpszLocalBuffer);

    /*
     * Failed for reason other than bufferlength too small
     */
    if(dwReturnCode == 0){
        OutputDebugStringA("<GetCurDrive>  GetCurrentDirectory() FAILed\n");
    }

    /*
     * test for success, if dwReturnCode is > buffer, then need
     * increase buffer
     */
    if(dwReturnCode > nBufferLength){
        lpszLocalBuffer = (LPSTR) LocalReAlloc(lpszLocalBuffer,
                                               nBufferLength + 128,
                                               LMEM_ZEROINIT | LMEM_MOVEABLE);
        if(lpszLocalBuffer == NULL){
            OutputDebugStringA("<GetCurDrive> LocalAlloc FAILed\n");
        }
        else{
            nBufferLength += 128;
        }
        goto GetCurDrive1;
    }

    /*
     * Finally lpszLocalBuffer has string containing current directory.
     * Now must parse string for ":" or "\\" for drive letter or UNC
     * If : then get drive letter, and convert to number a=0, b=1, etc.
     * If \\ then gotta enumerate net drives, to learn what drive letter
     * corresponds to that UNC path.
     */

    /* check for drive letter */
    if(lpszLocalBuffer[1] == ':'){

        /* is drive letter, proceed */
        iDriveNumber = lpszLocalBuffer[1] - 'A'; /* convert letter > number */
    }
    else{
        /* must be UNC path */

        /* BUG BUG need write code to convert UNC path   */
        OutputDebugStringA("<GetCurDrive> Got UNC path, didnt expect, and no code!\n");
    }

    LocalFree(lpszLocalBuffer);
    return(iDriveNumber);
}

/*** FDosDelete -- Delete named file.
 *
 * INT FDosDelete(LPSTR lpszFileToDelete)
 *
 * ENTRY -      LPSTR lpszFileToDelete - filename to delete.
 *
 * EXIT  -      INT xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 DeleteFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT FDosDelete(LPSTR lpszFileToDelete)
{
    BOOL    bReturnCode;

    bReturnCode = DeleteFile(lpszFileToDelete);

    if(bReturnCode){
        return(0);
    }
    else{
        return(1);
    }
}


/*** FDosRename -- Rename file.
 *
 * INT FDosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName)
 *
 * ENTRY -      LPSTR lpszOrgFileName - origianl filename.
 *              LPSTR lpszNewFileName - New filename.
 *
 * EXIT  -      INT xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 MoveFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT FDosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName)
{

    BOOL    bReturnCode;

    /* rename file */
    bReturnCode = MoveFile(lpszOrgFileName, lpszNewFileName);

    if(bReturnCode){
        return(0);  /* success */
    }
    else{
        return(1);
    }
}


VOID ReadClock(D3*pd3, TM*pmin)
{
    time_t t;
    struct tm *ptm;

    time(&t);
    ptm = localtime(&t);
    *pmin = (TM)(ptm->tm_min + ptm->tm_hour * 60);
    pd3->wMonth = (WORD)ptm->tm_mon;

    //- ReadClock: fixed to be day of month 0-30.
    pd3->wDay =  ptm->tm_mday - 1;

    //- ReadClock: fixed to be years since 1980 instead of since 0.
    pd3->wYear = ptm->tm_year - 80;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calinit.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calinit.c
 *
 */

#include "cal.h"
#include "string.h"

#define DOTIMER

//- OBM_RGARROW & OBM_LFARROW: Use the new arrows instead of old ones.
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750


extern INT cchLongDateMax;
extern INT cchTimeMax;
extern BOOL f24Time;

#define GSM(SM) GetSystemMetrics(SM)

BOOL APIENTRY   ProcessShellOptions(
        LPSTR lpszCmdLine);

/**** CalInit ****/

BOOL APIENTRY CalInit (
     HANDLE hInstance,
     HANDLE hPrevInstance,
     LPSTR  lpszCmdLine,
     INT    cmdShow)
     {
     BITMAP         bmBell;
     WNDCLASS   WndClass;
     HDC            hDC;
     TEXTMETRIC Metrics;
     INT i;
     INT cyUseable;
     CHAR   *pch;
     INT    cchRemaining, cch, cxWnd2C, cyWnd2C;
     HANDLE hStrings;
     INT    tm, TimeSetting;
     INT    BlankWidth;   /* width (in pixels) of a blank char */
     CHAR * pszFilterSpec = vszFilterSpec;  /* temp. var. for creating filter text */

     CHAR   sz[10];
     CHAR   *psz=sz;
     INT        iHeight;
     INT    iWidth;


     /* Remember our instance handle. */
     vhInstance = hInstance;

     /* Assume this string is longer for initialization. */
     vfHour24    = FALSE;
     TimeSetting = GTS_12HOUR;

     /* determine time setting from "International" section of win.ini */
     tm = 1;
     if (tm=GetProfileInt("intl", "iTime", tm))
        if (tm = 1)
            {
            TimeSetting = GTS_24HOUR;
            vfHour24 = TRUE;
            }

     InitTimeDate(vhInstance, TimeSetting);
     InitLongTimeDate(TimeSetting);

     /* Load strings from resource file. */
     hStrings=LocalAlloc(LPTR, cchRemaining=CCHSTRINGSMAX);

     pch=(CHAR *)(hStrings);
     if (!pch)
          return (FALSE);


     for (i=0; i<CSTRINGS; i++)
          {
          cch=1+LoadString(hInstance, i, pch, cchRemaining);

          /* If LoadString failed, not enough memory. */
          if (cch < 2)
              {
              MessageBeep(0);
              return FALSE;
              }
          vrgsz [i] = pch;
          pch += cch;

          /* If we run out of space it means that CCHSTRINGSMAX is too small.
             This should only happen when someone changes the strings in the
             .RC file, and returning FALSE should prevent them from shipping
             the new version without increasing CCHSTRINGSMAX (and possibly
             the initial heap size in the .DEF file).
             Note - we fail on the boundary condition that cchRemaining == 0
             because last loadstring will trim the size of the string loaded
             to be <= cchRemaining.
          */
          if ((cchRemaining -= cch) <= 0)
               return (FALSE);
          }


     //- CalInit: Eliminate Realloc because it seems to trash string pointers.
         //- Only lose 800 bytes anyway.
     //- LocalReAlloc(hStrings, CCHSTRINGSMAX-cchRemaining, LPTR);

     //- MergeStr: Changed to string to avoid crossing word boundries.
     strncpy (vszMergeStr, vrgsz [IDS_MERGE1], 2);


     /* Get default Page Setup stuff. */
     for (i=IDS_HEADER; i<=IDS_BOTTOM; i++)
         LoadString(hInstance, i, chPageText[i-IDS_HEADER], PT_LEN);

     /* Allocate the DRs. */
     if (!AllocDr ())
        return FALSE;

     /* Create the brushes. */
     if (!CreateBrushes ())
        /* Destroy any brushes that were created on failure. */
        return CalTerminate(0);

     /* construct default filter string in the required format for
      * the new FileOpen and FileSaveAs dialogs
      */
     lstrcpy(vszFilterSpec, vszFilterText);
     pszFilterSpec += lstrlen (vszFilterSpec) + 1;
     lstrcpy(pszFilterSpec++, "*");
     lstrcpy(pszFilterSpec, vszFileExtension);
     pszFilterSpec += lstrlen(pszFilterSpec) + 1;
     lstrcpy(pszFilterSpec, vszAllFiles);
     pszFilterSpec += lstrlen(pszFilterSpec) + 1;
     lstrcpy(pszFilterSpec, "*.*");
     pszFilterSpec += lstrlen(pszFilterSpec) + 1;
     *pszFilterSpec = '\0';
     *vszCustFilterSpec = '\0';

     /* Get cursors. */
     if (!(vhcsrArrow = LoadCursor (NULL, IDC_ARROW)))
        return CalTerminate(0);

     if (!(vhcsrIbeam = LoadCursor (NULL, IDC_IBEAM)))
        return CalTerminate(0);

     if (!(vhcsrWait = LoadCursor (NULL, IDC_WAIT)))
        return CalTerminate(0);



     if (hPrevInstance == NULL)
          {
          /* There is no previous instance, so we must register our
           * window classes.
           */

          FillBuf ((BYTE *)&WndClass, sizeof (WNDCLASS), 0);

          if (!(WndClass.hIcon = LoadIcon (hInstance, MAKEINTRESOURCE(1))))
            return CalTerminate(0);

          WndClass.lpszMenuName  = MAKEINTRESOURCE(1);
          WndClass.lpszClassName = "CalWndMain",
          WndClass.hInstance    = hInstance;
          WndClass.style         = CS_VREDRAW | CS_HREDRAW |
                                   CS_DBLCLKS | CS_BYTEALIGNCLIENT;
          WndClass.lpfnWndProc   = CalWndProc;

          /* Register CalWndMain. */
          if (!RegisterClass (&WndClass))
               return CalTerminate(0);

          WndClass.lpszMenuName  = NULL;
          WndClass.lpszClassName = "CalWndSub";

          /* Register CalWndSub. */
          if (!RegisterClass (&WndClass))
               return CalTerminate(0);
          }

     /* Load in the accelerators. */
     vhAccel=LoadAccelerators(hInstance, MAKEINTRESOURCE(1));
     if (!vhAccel)
        return CalTerminate(0);

     /*   Get bitmaps.
      *   If LoadBitmaps returns false, must delete those that were loaded.
      */
     if (!LoadBitmaps(hInstance))
        return CalTerminate(1);


     /* Get a screen DC. */
     hDC=GetDC(NULL);

     /* Fetch the text metrics of the system font. */
     GetTextMetrics (hDC, &Metrics);

     /* Create a memory DC for BitBlts. */
     vhDCMemory=CreateCompatibleDC(hDC);

     ReleaseDC (NULL, hDC);

     if (!vhDCMemory)
        return CalTerminate(1);

     /* Remember the text metrics we care about. */
     vcyFont    = Metrics.tmHeight;
     vcxFont    = Metrics.tmAveCharWidth;
     vcxFontMax = Metrics.tmMaxCharWidth;
     vcyDescent = Metrics.tmDescent;
     vcyExtLead = Metrics.tmExternalLeading;

     if (vcyExtLead == 0)
          vcyExtLead=max(1, vcyFont/8);

     vcyLineToLine=vcyExtLead+vcyFont;

     /* Fetch some system metrics. */
     vcxBorder     = GSM(SM_CXBORDER);
     vcyBorder     = GSM(SM_CYBORDER);
     vcxVScrollBar = GSM(SM_CXVSCROLL);
     vcxHScrollBar = GSM(SM_CXHSCROLL);
     vcyHScrollBar = GSM(SM_CYHSCROLL);

     /* Find out how big the the bell bitmap is. */
     GetObject(vhbmBell, sizeof(BITMAP), &bmBell);
     vcxBell = bmBell.bmWidth;
     vcyBell = bmBell.bmHeight;

     /* Calculate the window heights.  All heights are client rectangle
        heights, except for vcyWnd1, which includes the top and bottom
        borders.
     */
     vcyWnd2A=max(vcyExtLead + vcyLineToLine,
                   vcyHScrollBar + 2 * vcyBorder);

     vcyWnd2BTop=vcyBorder+vcyExtLead+2*vcyLineToLine;

     /* Note - the assumption is that numeric digits will not have
        descenders.  Therefore, we subtract out the descent when
        calculating the space below the date digits in the monthly
        calendar display.
     */
     /* changed from 6 to 9   */
     vcyWnd2BBot = 9*(6*vcyBorder+max(vcyBorder-vcyDescent, 0)
                   +vcyFont)+vcyBorder;

#ifdef DISABLE
     cyT = 11*vcyLineToLine+vcyBorder+vcyBorder;
     if (vcyWnd2BBot < cyT)
        vcyWnd2BBot = cyT;
#endif

     /* The idea is to make the boxes not look very different in size
        on the last week of the month for the 4, 5, and 6 week cases.
     */
     vcyWnd2BBot++;
     vcyWnd2B = vcyWnd2BTop + vcyWnd2BBot + vcyHScrollBar; /* last item added lsr */

     cyWnd2C = CLNNOTES * vcyLineToLine;
     vcyWnd1 = vcyBorder + (vycoNotesBox = vcyWnd2A + vcyWnd2B)
               + vcyBorder + vcyExtLead + cyWnd2C + vcyBorder;

     /* Calculate the window widths.  All widths are client rectangle
        widths, except for vcxWnd1, which includes the left and right
        borders.
        The width is determined by:
        Needed for Wnd2A in day mode:
        "<border> <time> <left arrow><border><right arrow>
            Wednesday, September 25, 1985 <border>"
        Needed for Wnd2B in day mode:
        "<border> <Bell> <time> <40 chars appointment description> \
            <scroll bar>"
        Note that the right border of the scroll bar aligns with the right
        border of Wnd1, so it shouldn't be added in twice.
     */
     vcxWnd1 = max(
                    /* width of header */
                    (cchLongDateMax + cchTimeMax + 4) * vcxFont
                                    + 2 * vcxHScrollBar + 3 * vcxBorder,
                    /* width of line of display */

                    vcxBorder + vcxBell + (40 + 4 + cchTimeMax)
                                    * vcxFont +vcxVScrollBar);


     vcxWnd2A = vcxWnd1 - 2 * vcxBorder ;


     /* Note that by adding in vcxBorder here we force the right
        border of the scroll bar to align with the border of the
        enclosing window Wnd1.
     */

     vcxWnd2B = vcxWnd2A - vcxVScrollBar + vcxBorder;

     /* Note - we know there are at least 40+4+1+cchTimeMax characters (from the width of
        wnd1) and we assume that the rest of the stuff (like the scroll
        bar and alarm bell bitmap totals at least one extra character
        (a very safe assumption).
        Leave room to the right of the last character for showing the
        caret when the edit control is full (the caret is vcxBorder
        pixels wide).
     */
     cxWnd2C = (40 + 4 + 1 + cchTimeMax) * vcxFont + vcxBorder;

     /* Calculate some x coordinates within Wnd2A.  */
#ifdef BUG_8560
     vxcoLeftArrowMax  = (vxcoLeftArrowFirst  = (7 + cchTimeMax) * vcxFont)  + vcxHScrollBar;
     vxcoRightArrowMax = (vxcoRightArrowFirst = vxcoLeftArrowMax + vcxBorder)+ vcxHScrollBar;
#else
     vxcoLeftArrowMax  = (vxcoLeftArrowFirst  = (7 + cchTimeMax) * vcxFont)  + vcxHScrollBar + vcxBorder;
     vxcoRightArrowMax = (vxcoRightArrowFirst = vxcoLeftArrowMax)+ vcxHScrollBar + vcxBorder;
#endif

     hDC=GetDC(NULL);

     vxcoDate = vxcoRightArrowMax + vcxFont;

     /* Calculate some coordinates within wnd2B for day mode. */
     GetTimeSz ( SAMPLETIME, psz);
     MGetTextExtent(hDC, vszBlank, 1, &iHeight, &iWidth);
     BlankWidth = iWidth;

     MGetTextExtent(hDC, psz, 1, &iHeight, &iWidth);
         //- KLUDGE: Divide the width of a character by two because it seems to
         //- be too large.
     //- TEMP: vxcoBell     = iWidth;
     //- TEMP: vxcoApptTime = vxcoBell + vcxBell + iWidth;
     vxcoBell     = iWidth / 2;
     vxcoApptTime = vxcoBell + vcxBell + iWidth / 2;

     MGetTextExtent(hDC, psz, 6, &iHeight, &iWidth);
     vxcoAmPm     = vxcoApptTime + iWidth -1;
     cchTimeMax   = 2*vcxFontMax / BlankWidth;

     /* Release the the DC.  */
     ReleaseDC (NULL, hDC);

     /* Calculate the x boundaries of the appointment descriptions.
        Leave room to the right of the last character for showing the
        caret when the edit control is full (the caret is vcxBorder
        pixels wide).
     */
    /*
     vxcoQdMax = (vxcoQdFirst = vxcoAmPm + 3 * vcxFont)
      + CCHQDMAX * vcxFont + vcxBorder;
    */

     //- KLUDGE: vxcoQdFirst = vxcoAmPm + 3 * vcxFontMax;
     vxcoQdFirst = vxcoAmPm + 6 * vcxFontMax;

     /* This formula limits the Moving edit control to what is visible
        and not to a number of characters.  The -2 at the end is simply
        so the caret is not flush with the scrollbar.  c-kraigb */

     vxcoQdMax=vcxWnd1 - vcxBorder - GSM(SM_CXVSCROLL)-2;

     /* Calculate the number of ln and the y boundaries of the appointment
        descriptions.  Subtract out the top and bottom borders, and subtract
        out the external leading before the first ln to see how much useable
        space there is.  Then divide to see how many ln will fit, and
        split the extra pixels between the top and the bottom.
     */
     cyUseable = vcyWnd2B - 2 * vcyBorder - vcyExtLead;
     vlnLast = (vcln = cyUseable / vcyLineToLine) - 1;
     vycoQdMax = (vycoQdFirst = 2 + (cyUseable % vcyLineToLine) / 2)
                  + vcln * vcyLineToLine;

     /* Create window CalWnd0. */
     if(!(vhwnd0 = CreateWindow("CalWndMain",
                               NULL,
                               WS_TILEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
                               min(vcxWnd1+GSM(SM_CXFRAME)*2+vcxFont*3,
                                                        GSM(SM_CXSCREEN)),
                               min(vcyWnd1+GSM(SM_CYCAPTION)+ GSM(SM_CYFRAME)*2+
                                           GSM(SM_CYMENU)+(vcyFont*2),
                                                              GSM(SM_CYSCREEN)),
                               NULL, NULL,
                               hInstance, NULL)))

        return CalTerminate(2);


     /* Create window CalWnd1. */
     if (!(vhwnd1 = CreateWindow ( "CalWndSub",
                                   NULL,
                                  WS_VISIBLE | WS_CHILD | WS_BORDER,
                                  XcoWnd1 (), YcoWnd1 (), vcxWnd1, vcyWnd1,
                                  vhwnd0, NULL, hInstance, NULL)))
        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }


     /* Create window CalWnd2A. */
     if (!(vhwnd2A = CreateWindow ( "CalWndSub",
                                    NULL,
                                   WS_VISIBLE | WS_CHILD,
                                   0, 0, vcxWnd2A, vcyWnd2A,
                                   vhwnd1, NULL, hInstance, NULL)))
        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }

#ifndef BUG_8560
     /* Create the scrollbar control as a child of hwnd2A */
     if (!(vhScrollWnd = CreateWindow ( "scrollbar",
                                    NULL,
                                   WS_VISIBLE | WS_CHILD | SBS_HORZ,
                                   vxcoLeftArrowFirst, 0, (vcxHScrollBar + vcxBorder)<<1, vcyWnd2A,
                                   vhwnd2A, (HMENU)IDHORZSCROLL, hInstance, NULL)))
        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }
#endif



     /* Create window CalWnd2B.  Note - use width of vcxWnd1 - vcxBorder
        in order to overlay the right border of the scroll bar with the
        right border of Wnd1.
     */
     if (!(vhwnd2B = CreateWindow ( "CalWndSub",
                                   NULL,
                                   WS_VISIBLE | WS_CHILD | WS_VSCROLL| WS_HSCROLL,
                                   0, vcyWnd2A, vcxWnd1 - vcxBorder, vcyWnd2B,
                                   vhwnd1, NULL, hInstance, NULL)))
        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }

     hmScrollMax = 0;
     vmScrollPos = 0;
     vmScrollMax = 0;
     hmScrollPos = 0;

     /* Create window CalWnd2C. */
     if (!(vhwnd2C = CreateWindow ( "Edit",
                                   NULL,
                                   WS_VISIBLE | WS_CHILD | ES_MULTILINE,
                                   vxcoWnd2C = (vcxWnd2A - cxWnd2C) / 2,
                                   vycoWnd2C = vcyWnd1 - 2 * vcyBorder - cyWnd2C,
                                   cxWnd2C, cyWnd2C,
                                   vhwnd1, (HMENU)IDECNOTES, hInstance, NULL)))
        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }



     /* limit text in notes area to number of chars that fit.
      * this is done to get around a bug in edit controls when
      * you paste in text which has tabs.
      * 05-Oct-1987. davidhab.
      */
#if VARIABLENOTELENGTH
     SendMessage(vhwnd2C, EM_LIMITTEXT, (cyWnd2C / vcyFont) * (cxWnd2C / vcxFont)*2, 0L);
#else
     SendMessage(vhwnd2C, EM_LIMITTEXT, CBNOTESMAX, 0L);
#endif


     /* Create window CalWnd3. c-kraigb : ES_AUTOHSCROLL added to allow
        more text in the appointment area without having to alter the
        size of the entire layout.*/

     if (!(vhwnd3 = CreateWindow ( "Edit",
                                  NULL,
                                  WS_CHILD | ES_AUTOHSCROLL,
                                  0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                  vhwnd2B, (HMENU)IDECQD, hInstance, NULL)))

        {
        DestroyWindow(vhwnd0);
        return FALSE;
        }



     /* Limit the Appoinment Edit to it's maximum.  80 chars should be
        sufficient for all intensive purposes , c-kraigb
      */
     SendMessage(vhwnd3, EM_LIMITTEXT, CCHQDMAX, 0L);

     /* Make all the files look closed. */
     for (i=0; i < CFILE; i++)
         hFile[i]=-1;

     /* Get a handle for the tdd.  Note - the tdd will get initialized
            when we call CleanSlate or LoadCal below.
      */
         //- Calinit: Changed Allocation because of bug in LocalReAlloc.
     //- vhlmTdd = LocalAlloc (LMEM_MOVEABLE, 0);

     /* Fetch the current date and time. */
     ReadClock(&vd3Cur, &vftCur.tm);
     vftCur.dt = DtFromPd3 (&vd3Cur);

     /* Set up the timer event for updating the time and date. */

#ifdef DOTIMER
     if (!SetTimer (vhwnd0, 0, 1000, NULL))
        {
        AlertBox (vrgsz[IDS_NOTIMER], (CHAR *)NULL,
                  MB_SYSTEMMODAL | MB_OK | MB_ICONHAND);
        DestroyWindow(vhwnd0);
        return FALSE;
        }
#endif /* #ifdef DOTIMER */

     /* init. some fields of the OPENFILENAME struct used by fileopen and
      * filesaveas
      */
/* changed to sizeof instead of constant.  18 Jan 1991  clarkc */
     vOFN.lStructSize       = sizeof(OPENFILENAME);
     vOFN.hwndOwner         = vhwnd0;
     vOFN.lpstrFileTitle    = 0;
     vOFN.nMaxCustFilter    = CCHFILTERMAX;
     vOFN.nFilterIndex      = vFilterIndex;
     vOFN.nMaxFile          = CCHFILESPECMAX;
     vOFN.lpfnHook          = NULL;

     /* init fields of the PRINTDLG structure */
/* changed to sizeof instead of constant.  18 Jan 1991  clarkc */
     vPD.lStructSize        = sizeof(PRINTDLG);
     vPD.hwndOwner          = vhwnd0;
     vPD.hDevMode           = NULL;
     vPD.hDevNames          = NULL;
     vPD.hDC                = NULL;
     vPD.Flags              = PD_NOSELECTION | PD_NOPAGENUMS; /* disable "pages" and "Selection" radiobuttons */
     vPD.nFromPage          = 0;
     vPD.nToPage            = 0;
     vPD.nMinPage           = 0;
     vPD.nMaxPage           = 0;
     vPD.nCopies            = 1;

     /* determine the message number to be used for communication with
      * Find dialog
      */
     if (!(vHlpMsg = RegisterWindowMessage (HELPMSGSTRING)))
          return FALSE;

     /* Prevent grabbing of focus if we are coming up iconic. */
     vfNoGrabFocus = (cmdShow == SW_SHOWMINNOACTIVE);


     /* Initialize according to values from win.ini */
     CalWinIniChange();

    if (ProcessShellOptions(lpszCmdLine))
    {
        PostMessage(vhwnd0, WM_CLOSE, 0, 0L);
        return (TRUE);
    }
    else if (*lpszCmdLine == '\0')      /* Not invoked with a file. */
    {
        CleanSlate (TRUE);
    }
    else
    {
            /* Try to load the file. */
            AddDefExt(lpszCmdLine);

            hFile [IDFILEORIGINAL] = MOpenFile (lpszCmdLine,
                    (OFSTRUCT FAR *)&OFStruct [IDFILEORIGINAL], OF_READ);
            LoadCal ();
    }

    /* If we didn't grab the focus we need to set up vhwndFocus so
                we correctly set the focus when we get activated later on.
                Initially we are in day mode with the focus on the appointment
                edit control.
    */
    if (vfNoGrabFocus)
    {
        vhwndFocus = vhwnd3;
        vfNoGrabFocus = FALSE;
    }


    /* Make the windows visible. */
    ShowWindow (vhwnd0, cmdShow);
    return (TRUE);
}


BOOL APIENTRY   ProcessShellOptions(
        LPSTR lpszCmdLine)
{
        CHAR szFileName[80];

        AnsiUpper(lpszCmdLine);

        if (*lpszCmdLine != '/' || *lpszCmdLine != 'P')
                return FALSE;

        lpszCmdLine += 2;

        // skip blanks
    while (*lpszCmdLine == ' ' || *lpszCmdLine == '\t')
        lpszCmdLine++;

        if (!*lpszCmdLine)
                return FALSE;

    /* Get the filename. */
        lstrcpy(szFileName, lpszCmdLine);
        AddDefExt(szFileName);

        hFile[IDFILEORIGINAL] = MOpenFile (szFileName, &OFStruct [IDFILEORIGINAL],
                        OF_READ);
        if (hFile[IDFILEORIGINAL] == -1)
        {
        AlertBox (vszCannotReadFile, szFileName, MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION);
                return TRUE;
        }

        LoadCal();

        // need to set the first and last dates for which appts have to be
        // printed.
        // Since the data structures are utterly incomprehensible,
        // the following method appeared to provide the easiest solution
        vdtFrom = DTFIRST;              // from 1/1/1980
        vdtTo = DTLAST;                 // to December 31, 2099.

    FSearchTdd (vdtFrom, &vitddFirst);  // first day in the file
    FSearchTdd (vdtTo, &vitddMax);              // last day in the file
        Print ();

        return TRUE;
}

/**** AllocDr ****/

BOOL APIENTRY AllocDr ()
     {
     register INT i;

     for (i=0; i < CDR; i++)
          {
          /* Note - the DRs get marked free by New. */
          if (!(vrghlmDr [i] = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, CBDRMAX)))
                return FALSE;
          }
          return TRUE;
     }




/**** Return TRUE iff all bitmaps loaded.  If we fail to load any bitmap,
      DeleteBitmaps will deleted the ones already loaded. */
BOOL APIENTRY LoadBitmaps(HANDLE  hInstance)
    {
    vhbmLeftArrow = LoadBitmap (NULL, MAKEINTRESOURCE (OBM_LFARROW));
    vhbmRightArrow = LoadBitmap (NULL, MAKEINTRESOURCE (OBM_RGARROW));
    vhbmBell = LoadBitmap (hInstance, MAKEINTRESOURCE(1));
    return (vhbmBell && vhbmLeftArrow && vhbmRightArrow);
    }



/**** Delete bitmaps that have been loaded.  Depends on handles having been
      initialized to 0. */
VOID APIENTRY DeleteBitmaps()
    {
    if (vhbmBell)
        DeleteObject(vhbmBell);

    if (vhbmLeftArrow)
        DeleteObject(vhbmLeftArrow);

    if (vhbmRightArrow)
        DeleteObject(vhbmRightArrow);
    }

/**** Destroy Global Objects.
      iLevel determines which objects will be deleted.
      Always returns FALSE */
BOOL APIENTRY CalTerminate(INT iLevel)
    {
    /* Note case statement falls thru every arm. */
    switch (iLevel)
        {
        case 2:
            DeleteDC (vhDCMemory);

        case 1:
            DeleteBitmaps();

        case 0:
            DestroyBrushes();
        }

    /* Leave handy value in ax for calinit to return. */
    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calmon2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 *   ***** calmon2.c
 *
 */

#include "cal.h"



/**** FMonthPrev ****/
BOOL APIENTRY FMonthPrev ()
     {
     if (vd3To.wMonth != MONTHJAN)
          vd3To.wMonth--;
     else
          {
          if (vd3To.wYear == YEAR1980)
               return (FALSE);

          vd3To.wYear--;
          vd3To.wMonth = MONTHDEC;
          }

     return (TRUE);
     }



/**** FMonthNext ****/
BOOL APIENTRY FMonthNext ()
     {
     if (vd3To.wMonth != MONTHDEC)
          vd3To.wMonth++;
     else
          {
          if (vd3To.wYear == YEAR2099)
               return (FALSE);

          vd3To.wYear++;
          vd3To.wMonth = MONTHJAN;
          }

     return (TRUE);
     }




/**** ShowMonthPrevNext ****/
VOID APIENTRY ShowMonthPrevNext (BOOL fNext)
     {
     /* First see if able to move to previous or next month.  (Can't
        move back if already January 1980, can't move forward if already
        December 2099.)
     */
     if (fNext ? FMonthNext () : FMonthPrev ())
          UpdateMonth ();
     }




/**** UpdateMonth - update the month display after the month has been
      changed, or when switching from day mode to month mode.
      Set the selected day to the minimum of the sticky day or the
      last day of the month.
****/

VOID APIENTRY FAR UpdateMonth ()
     {
     HDC    hDC;

     /* See if the data can be fetched for the target date.  If not,
        don't switch to that date.  If so, switch.
     */
     vd3To.wDay = (WORD)min ((INT)(CDaysMonth (&vd3To) - 1), (INT)vwDaySticky);
     if (FFetchTargetDate ())
          {
          vd3Sel=vd3To;
          SetScrollPos(vhwnd2B, SB_VERT, vd3Sel.wYear*12+vd3Sel.wMonth, TRUE);

          SetUpMonth ();
          InvalidateMonth ();
	  UpdateWindow (vhwnd0);   /* changed from vhwnd2B to fix scrollbar
				      repaint problems */
          SetNotesEc ();

          hDC=GetDC(vhwnd2A);
          DispDate (hDC, &vd3To);
          ReleaseDC(vhwnd2A, hDC);
          }
     }




/**** MouseSelectDay  - we have a click in the monthly calendar.  Map
      it to a day and move the selection.
*****/
VOID APIENTRY MouseSelectDay (
     MPOINT     point,             /* Screen coordinates of mouse where click
                                     occurred.
                                    */
     BOOL      fDblClk)            /* TRUE for double click. */
     {
     INT  ixco, iyco, irgb;

     if (FMapCoToIGrid (point.x, vrgxcoGrid, 7, &ixco) &&
          FMapCoToIGrid (point.y, vrgycoGrid, vcWeeksMonth, &iyco) &&
          vrgbMonth [irgb = 7 * iyco + ixco +7*vmScrollPos + hmScrollPos]
          != 0)
	  {
	  vd3To = vd3Sel;
	  MoveSelCurMonth (irgb - vwWeekdayFirst );

          /* Give the focus to the calendar if it doesn't already have it. */
          if (GetFocus () != vhwnd2B)
               CalSetFocus (vhwnd2B);

          /* Switch to day mode for the day the user double clicked on. */
	  if (fDblClk)
               DayMode (&vd3Sel);
          }

     }



/**** FScrollMonth */
/************************************************************************
 *
 * VOID PASCAL FScrollMonth (code, posNew)
 *
 * purpose : calculates sone vertical scroll globals and scrolls
 *	     the month display vertically.
 *
 ***********************************************************************/
VOID APIENTRY FScrollMonth (
     INT  code,
     UINT posNew)
     {
     INT dy;
     RECT rect;

     /* calculate the step size for the scroll. The step size is
        approximately the height of the month grid  */

     if (hmScrollMax == 0)
         dy = (vcyWnd2BBot - vcyBorder +vcyHScrollBar)/ vcWeeksMonth;
     else
         dy = (vcyWnd2BBot - vcyBorder)/ vcWeeksMonth;


     switch (code)
         {
         case SB_LINEUP :
             vmScrollInc = -1;
             break;

         case SB_LINEDOWN:
             vmScrollInc = 1;
             break;

         case SB_TOP:
             vmScrollInc = -vmScrollPos;
             break;

         case SB_BOTTOM :
             vmScrollInc = vmScrollMax - vmScrollPos;
             break;

         case SB_PAGEUP :
         case SB_PAGEDOWN :
             break;

         case SB_THUMBTRACK :
             vmScrollInc = posNew -vmScrollPos;
             break;

         default:
              vmScrollInc = 0;
         }

     if ((vmScrollInc = max(-vmScrollPos,
                            min (vmScrollInc, vmScrollMax-vmScrollPos))) != 0)
         {
         GetClientRect (vhwnd2B, (LPRECT)&rect);
         rect.top = vcyWnd2BTop;
         rect.bottom = vcyWnd2BBot + 2*dy;

         if (vmScrollMax ==1)
             rect.bottom += dy;

         vmScrollPos +=vmScrollInc;
         ScrollWindow (vhwnd2B, 0, -dy * vmScrollInc, &rect, &rect);
         SetScrollPos (vhwnd2B, SB_VERT, vmScrollPos, TRUE);

         /* refresh screen to get rid of caret droppings */
         rect.bottom = vcyWnd2BBot;
         rect.top -= 3*vcyLineToLine;
         InvalidateRect(vhwnd2B, (LPRECT)&rect, TRUE);
         UpdateWindow (vhwnd2B);
         }
    }




/************************************************************************
 *
 * VOID PASCAL FHorizScrollMonth (code, posNew)
 *
 * purpose : calculates some horizontal scroll globals and scrolls the
 *	     month display vertically.
 *
 ***********************************************************************/
VOID APIENTRY FHorizScrollMonth (
    INT code,
    WORD posNew)
    {
    RECT rect;
    INT dx;
    /* calculate the step size for the scroll. The step size
       is approximately the width of the month grid */

    if (vmScrollMax == 0)
	dx = (vcxWnd2B + vcxBorder+ vcxVScrollBar)/7;
    else
	dx = (vcxWnd2B + vcxBorder)/7;

    switch (code)
        {
	case SB_LINEUP:
	    hmScrollInc = -1;
            break;

	case SB_LINEDOWN:
	    hmScrollInc = 1;
            break;

	case SB_TOP :
	    hmScrollInc = -hmScrollPos;
            break;

	case SB_BOTTOM:
	    hmScrollInc = hmScrollMax -hmScrollPos;
            break;

	case SB_PAGEUP:
	case SB_PAGEDOWN:
            break;

	case SB_THUMBTRACK:
	    hmScrollInc = posNew - hmScrollPos;
            break;

	default:
	    hmScrollInc = 0;
        }

    if ((hmScrollInc = max(-hmScrollPos,
			   min(hmScrollInc, hmScrollMax - hmScrollPos))) != 0)
	{
	GetClientRect (vhwnd2B, (LPRECT)&rect);
	rect.top = vcyWnd2BTop - vcyLineToLine;
	rect.bottom = vycoQdMax;
	hmScrollPos += hmScrollInc;
        ScrollWindow ( vhwnd2B , -dx*hmScrollInc, 0, &rect, &rect);
	SetScrollPos ( vhwnd2B, SB_HORZ, hmScrollPos, TRUE );

	/* refresh screen to get rid of caret droppings */
	rect.bottom += vcyHScrollBar;
	rect.top -= 2* vcyLineToLine;
	InvalidateRect(vhwnd2B, (LPRECT)&rect, TRUE);
	UpdateWindow ( vhwnd2B );
        }
    }





/**** FCalKey ****/
BOOL APIENTRY FCalKey (
     HWND hwnd,
     WPARAM kc)       /* The virtual key code. */
     {
     register INT  iTemp;

     if (!vfDayMode && hwnd == vhwnd2B)
          {
          vd3To = vd3Sel;
          switch (kc)
               {
               case VK_LEFT:
                    if (vd3To.wDay != 0)
                         MoveSelCurMonth (vd3To.wDay - 1);
                    else
                        if (FMonthPrev ())
                            MoveSelNewMonth (CDaysMonth (&vd3To) - 1);
                    break;

               case VK_RIGHT:
                    if ((iTemp = vd3To.wDay + 1) < vcDaysMonth)
                         MoveSelCurMonth (iTemp);
                    else
                        if (FMonthNext ())
                            MoveSelNewMonth (0);
                    break;

               case VK_UP:
                    if ((iTemp = vd3To.wDay - 7) >= 0)
                         MoveSelCurMonth (iTemp);
                    else
                        if (FMonthPrev ())
                            MoveSelNewMonth (CDaysMonth (&vd3To) + iTemp);
                    break;


               case VK_DOWN:
                    if ((iTemp = vd3To.wDay + 7) < vcDaysMonth)
                         MoveSelCurMonth (iTemp);
                    else
                         {
                         iTemp -= vcDaysMonth;
                         if (FMonthNext ())
                              MoveSelNewMonth (iTemp);
                         }
                    break;

               case VK_PRIOR:
                    ShowMonthPrevNext (FALSE);
                    break;

               case VK_NEXT:
                    ShowMonthPrevNext (TRUE);
                    break;

               case VK_TAB:
                    /* Switch to the notes area. */
                    CalSetFocus (vhwnd2C);
                    break;

               case VK_RETURN:
		    /* Switch to day mode for the selected day. */
                    DayMode (&vd3Sel);
                    break;

               default:
                    return (FALSE);
               }
          return (TRUE);
          }
     return (FALSE);
     }




/**** MoveSelCurMonth  ****/
VOID APIENTRY MoveSelCurMonth (UINT uiDaySel)
     {
     HDC  hDC;
     WORD wDaySel = (WORD)uiDaySel;

     /* Only switch if we can fetch the data for the target date. */
     vd3To.wDay = wDaySel;
     if (FFetchTargetDate ())
          {
          hDC = CalGetDC (vhwnd2B);
          InvertDay (hDC, vd3Sel.wDay);
          InvertDay (hDC, vwDaySticky = vd3Sel.wDay = wDaySel);
          ReleaseDC (vhwnd2B, hDC);

          hDC=GetDC(vhwnd2A);
          DispDate (hDC, &vd3Sel);
          ReleaseDC(vhwnd2A, hDC);


          PositionCaret ();
          SetNotesEc ();
          }
     }



/**** MoveSelNewMonth ****/
VOID APIENTRY MoveSelNewMonth (UINT uiDaySel)
     {
     WORD wDaySel = (WORD)uiDaySel;

     vd3To.wDay = wDaySel;

     /* Don't change vwDaySticky unless we can successfully switch to the
        target date.
      */

     if (FFetchTargetDate ())
          {
          vwDaySticky = wDaySel;
          UpdateMonth ();
          }
     }



/**** JumpDate - Jump to specified date in month mode. ****/
VOID APIENTRY JumpDate (D3*pd3)
     {
     register WORD wDay;

     wDay = pd3 -> wDay;

     if (pd3 -> wMonth == vd3Sel.wMonth && pd3 -> wYear == vd3Sel.wYear)
          {
          /* The target date is in the same month as the one we are
             currently displaying - just move the highlight.
          */
          MoveSelCurMonth (wDay);
          }
     else
          {
          /* The target date is not in the current month.  Need to
             update the entire month display.
          */
          vd3To = *pd3;
          MoveSelNewMonth (wDay);
          }
     }



/**** InvalidateMonth ****/
VOID APIENTRY InvalidateMonth ()
     {
     InvalidateRect (vhwnd2B, NULL, TRUE);
     }



/**** FFetchTargetDate ****/
BOOL APIENTRY FFetchTargetDate ()
     {
     register HWND hwndFocus;
     register BOOL fOk;

     /* FGetDateDr leaves the focus NULL if it succeeds, so remember who
        has it now, and set it back when finished.
     */
     hwndFocus = GetFocus ();
     fOk = FGetDateDr (DtFromPd3 (&vd3To));
     CalSetFocus (hwndFocus);
     return (fOk);
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calmark.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calmark.c
 *****
*/

#include "cal.h"


/**** CmdMark - mark or unmark the selected day. */

VOID APIENTRY CmdMark ()

     {

     register DT   dt;
     INT  itdd;
     RECT rect;
     register DD *pdd;

     /* Note that the Mark command only operates on the selected date,
        and this must be in the tdd, so there is no need to check the
        return result of FSearchTdd.
     */
     dt = DtFromPd3 (&vd3Sel);
     FSearchTdd (dt, &itdd);

     /* Mark or unmark the DD (toggle its state). */
     pdd = TddLock () + itdd;

     /* Update the month array by toggling the marked bit for the current
        day.
     */
     /* clear old marked bits on day */
     vrgbMonth [vwWeekdayFirst + vd3Sel.wDay] &= CLEARMARKEDBITS;

     /* set new marked bits */
     vrgbMonth [vwWeekdayFirst + vd3Sel.wDay] |= viMarkSymbol;
     pdd -> fMarked = (SINT)viMarkSymbol;

     TddUnlock();
     /* If in month mode, cause the marking box to be drawn or erased. */
     if (!vfDayMode)
          {
          MapDayToRect (vd3Sel.wDay, &rect);
          InvalidateRect (vhwnd2B, (LPRECT)&rect, TRUE);
          }


     /* Marking a date makes the file dirty. */
     vfDirty = TRUE;
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calmonth.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calmonth.c
 *
 */

#include "cal.h"


/**** GetWeekday - calculate day of week from D3. */

WORD APIENTRY GetWeekday (D3*pd3)
     {
     /* Add 2 since January 1, 1980 was a Tuesday. */
     return ((DtFromPd3 (pd3) + 2) % 7);
     }




/**** CDaysMonth - return the number of days in the month specified
      by the month and year of the D3 argument.
****/

INT APIENTRY CDaysMonth (D3*pd3)
     {
     register INT cDays;

     /* Calculate the number of days in the current month (adding in
        one if this is a leap year and the month is past February.
      */
     cDays = vrgcDaysMonth [pd3 -> wMonth];
     if (pd3 -> wYear % 4 == 0 && pd3 -> wMonth == MONTHFEB)
          cDays++;

     return (cDays);
     }



/**** SetUpMonth - Based on vd3Sel, set up the following:
      - vcDaysMonth - number of days in the month being displayed.
      - vcWeeksMonth - the number of weeks needed to display the month
        (4, 5, or 6).
      - vrgbMonth - the array of days.  0's indicate unused entries.

****/

VOID APIENTRY SetUpMonth ()
     {
     WORD wDay;
     INT  *pb;		      /* changed from BYTE to int */
     D3   d3Temp;
     INT i;

     for (i=0; i< CBMONTHARRAY;i++)
	vrgbMonth[i]=0;

    /* FillBuf (vrgbMonth, CBMONTHARRAY*sizeof(int), 0);  */

     /* Set up the count of days in the month. */
     vcDaysMonth = CDaysMonth (&vd3Sel);

     /* Get the weekday of the the first day of the month. */
     d3Temp = vd3Sel;
     d3Temp.wDay = 0;
     vwWeekdayFirst = GetWeekday (&d3Temp);

     /* Calculate the number of weeks we will need to display. */
     vcWeeksMonth = (vwWeekdayFirst + 6 + vcDaysMonth) / 7;

     /* Fill in the days. */
     pb = vrgbMonth + vwWeekdayFirst;

     for (wDay = 1; (WORD)wDay <= (WORD)vcDaysMonth; wDay++)
       /* *pb++ = (BYTE)wDay;	 */
          *pb++ = wDay;

     /* Set the TODAY bit of the appropriate day if today
        is in this month.
      */
     if (vd3Cur.wMonth == vd3Sel.wMonth && vd3Cur.wYear == vd3Sel.wYear)
          vrgbMonth [vwWeekdayFirst + vd3Cur.wDay] |= TODAY;

     /* Set the marked bits for the marked days in this month. */
     GetMarkedDays ();
     }



/**** BuildMonthGrid */

VOID APIENTRY BuildMonthGrid ()
     {
     INT  dx;
     INT  dy;
     INT  xco;
     INT  yco;
     INT  cLines;

     /* Calculate the x coordinates if vertical scrollbar is absent */
     if (vmScrollMax == 0)
         {
	 dx = (vcxWnd2B + vcxBorder + vcxVScrollBar)/ 7;
	 vrgxcoGrid [7] = vcxWnd2B + vcxHScrollBar;
         }
     else
         {
         /* Calculate the x coordinates if vertical scrollbar is present */
         dx = (vcxWnd2B + vcxBorder) / 7;
         vrgxcoGrid [7] = vcxWnd2B ;
         }

     xco = - vcxBorder;

     for (cLines = 0; cLines < 7; cLines++)
          {
          vrgxcoGrid [cLines] = xco;
          xco += dx;
	  }

     /* Calculate the y coordinates if horiz. scrollbar is absent. */
     if (hmScrollMax == 0)
         {
         dy = (vcyWnd2BBot - vcyBorder + vcyHScrollBar)/vcWeeksMonth;
         vrgycoGrid [vcWeeksMonth] = vcyWnd2B;
         }
     /* Calculate the y coordinates if horiz. scrollbar is present. */
     else
         {
         dy = (vcyWnd2BBot - vcyBorder) / vcWeeksMonth;
         vrgycoGrid [vcWeeksMonth] = vcyWnd2B - vcyHScrollBar;
         }

     yco = vcyWnd2BTop;

     for (cLines = 0; cLines < vcWeeksMonth; cLines++)
          {
          vrgycoGrid [cLines] = yco;
          yco += dy;
          }
     }




/**** PaintMonthGrid - Paint the grid for the monthly calendar display. */

VOID APIENTRY PaintMonthGrid (HDC  hDC)
     {
     INT  *pcoCur;
     INT  *pcoMax;

     BuildMonthGrid ();

     /* Draw the horizontal lines. */

     pcoCur = vrgycoGrid;
     for (pcoMax = pcoCur+vcWeeksMonth; pcoCur < pcoMax; pcoCur++)
	  PatBlt (hDC, 0, *pcoCur, vcxWnd2B + vcxVScrollBar, vcyBorder, PATCOPY);

     /* Draw the vertical lines. */
     pcoCur = vrgxcoGrid + 1;
     for (pcoMax = pcoCur+6; pcoCur < pcoMax; pcoCur++)
         PatBlt(hDC, *pcoCur, vcyWnd2BTop, vcxBorder, vcyWnd2BBot + vcyHScrollBar, PATCOPY);

     }



/**** PaintMonth */

VOID APIENTRY PaintMonth (HDC hDC)
     {
     INT  xcoBox;
     INT  ycoBox;
     INT  dx;
     INT  dy;
     INT  xcoText;
     INT  ycoText;
     INT  cDay;
     INT  cWeek;
     INT  cch;
     CHAR *pch;
     INT  *pb;	    /* changed from BYTE to int */
     INT  *pxcoCur;
     INT  *pycoCur;
     CHAR rgchDayAbbrevs[4];
     CHAR rgch[CCHDATEDISP];
     DOSDATE dd;
     extern HANDLE hinstTimeDate;
     INT iWeekStart;	  /* week no. of month which will appear on top row
			    in monthview */
     INT iWeekEnd;	  /* week no. which will appear on last row of
			    month view	*/
     INT iDayStart;	  /* weekday which will appear on leftmost column */
     INT iDayEnd;	  /* weekday which will appear on rightmost column */
     INT MarkedBits;	  /* the marked bits extracted from a day */

     dd.year  = vd3Sel.wYear + 1980;
     dd.month = vd3Sel.wMonth + 1;

     cch = GetLongDateString(&dd, rgch, GDS_LONG | GDS_NODAY);

     xcoText = (vcxWnd2B - cch * vcxFont) / 2;
     ycoText = 2;

     TextOut(hDC, xcoText, ycoText, (LPSTR)rgch, cch );

     iDayEnd = 7;
     iWeekEnd = vcWeeksMonth + 2;

     /* for an unscrolled window */
     if ((vmScrollPos == 0) && (hmScrollPos == 0))
         {
	 iWeekStart = 0;
	 iDayStart = 0;
	 pb =  vrgbMonth;
	 pycoCur = vrgycoGrid;
         }
     else       /* scrolled window */
         {
	 iWeekStart = vmScrollPos +1;
	 iDayStart  = hmScrollPos;
	 pycoCur   = vrgycoGrid + iWeekStart -(vmScrollPos + 1);
	 pb	   = vrgbMonth + (iWeekStart -1)*7 + iDayStart;
         }

     ycoBox = *pycoCur;
     dy = *pycoCur -ycoBox;
     pxcoCur = vrgxcoGrid;
     pb -= iDayStart - hmScrollPos ;

     /* display "S M T W ..." above month grid */
     for (cDay = iDayStart; cDay < iDayEnd; cDay++ )
         {
         INT cchT;
         xcoBox = *pxcoCur++;
         dx = *pxcoCur -xcoBox;
               cchT = LoadString(hinstTimeDate, IDS_DAYABBREVS+cDay,
                                 (LPSTR)rgchDayAbbrevs, 4);

         xcoText = xcoBox + (dx - cchT*vcxFont)/2;
         ycoText = vcyWnd2BTop -vcyLineToLine;
         TextOut (hDC, xcoText, ycoText, (LPSTR)rgchDayAbbrevs, cchT);
         }

     /* draw the month grid and fill in the dates */
     for (cWeek = iWeekStart ; cWeek < iWeekEnd ; cWeek++,pb+=iDayStart)
	  {
	  ycoBox = *pycoCur++;
          dy = *pycoCur - ycoBox;
	  pxcoCur = vrgxcoGrid;

	  for (cDay = iDayStart; cDay < iDayEnd ; cDay++, pb++)
               {
               xcoBox = *pxcoCur++;
               dx = *pxcoCur - xcoBox;

	       if  (*pb !=0)
                    {
                    cch = 2;
		    ByteTo2Digs (*pb & ~(MARK_BOX| TODAY), pch = rgch);

		    if (*pch == '0')
                         {
                         cch--;
			 pch++;
                         }
                    xcoText = xcoBox + (dx - cch * vcxFont) / 2;
		    ycoText = ycoBox + vcyBorder + (dy	- vcyFont) / 2;

		    /* draw mark symbols, if any */
		    if ((MarkedBits = ((~CLEARMARKEDBITS) & (*pb))) != 0)
			DrawMark (hDC, xcoBox, ycoText, dx, MarkedBits);

		    if (*pb & TODAY)
			 ShowToday (hDC, xcoBox, ycoText, dx);

                    TextOut (hDC, xcoText, ycoText, (LPSTR)pch, cch);
                    }
               }
	  }

     InvertDay (hDC, vd3Sel.wDay);
     /* Don't mess with the caret position if the notes have the focus. */
     if (vhwndFocus == vhwnd2B)
	  PositionCaret ();
     }



/**** DrawMark ***/
/***********************************************************************
 *
 * VOID PASCAL DrawMark (hDC, xcoBox, ycoText, dx, MarkedBits)
 *
 * purpose : To extract the marked bits one by one and draw the corresp.
 *	     mark symbols next to the selected day in month mode.
 *
 * paramteters : hDC	    - the display context
 *		 xcoBox     - the x-coordinate of the left vertical edge
 *			      of box containing selected day
 *		 ycoText    - y-coordinate of text to be written in box
 *		 dx	    - width of box
 *		 MarkedBits - variable with bits set corresp. to marks on
 *			      selected day
 *
 * returns     : none
 *
 * called by   : PaintMonth
 *
 ***********************************************************************/


VOID APIENTRY DrawMark (
     HDC  hDC,
     INT  xcoBox,
     INT  ycoText,
     INT  dx,
     INT  MarkedBits)
     {
     INT  xcoLeft;	  /* left x coordinate of box mark */
     INT  xcoRight;	  /* right x coordinate of box mark */
     INT  ycoTop;	  /* top y coordinate of box mark */
     INT  ycoBottom;	  /* bottom y coordinate of box mark */

     /* Note - the assumption is that numeric digits will not have
        descenders.  Therefore, we subtract out the descent when
        calculating the space below the date digits in the monthly
        calendar display.
     */
     xcoLeft = xcoBox + (dx - 2 * vcxFont) / 2 - 2 * vcxBorder;
     xcoRight = xcoLeft + 2 * vcxFont + 6 * vcxBorder;
     ycoTop = ycoText - 2 * vcyBorder;
     ycoBottom = ycoText + vcyFont + max (vcyBorder - vcyDescent, 0);

     if (MarkedBits & MARK_BOX)   /* a box-type mark */
         {
         PatBlt (hDC, xcoLeft, ycoTop, xcoRight - xcoLeft + 1, vcyBorder, PATCOPY);
         PatBlt (hDC, xcoLeft, ycoBottom, xcoRight - xcoLeft + 1, vcyBorder, PATCOPY);

         PatBlt (hDC, xcoLeft, ycoTop, vcxBorder, ycoBottom - ycoTop + 1, PATCOPY);
         PatBlt (hDC, xcoRight, ycoTop, vcxBorder, ycoBottom - ycoTop + 1, PATCOPY);
         }

     if (MarkedBits & MARK_CIRCLE)	 /* a "o" -type mark */
	    Ellipse (hDC, xcoLeft - 7*vcxBorder, ycoBottom +2*vcyBorder,
		     xcoLeft - 3*vcxBorder, ycoBottom + 6*vcyBorder);

     if (MarkedBits & MARK_PARENTHESES)  /* a parentheses-type mark */
         {
         TextOut ( hDC, xcoLeft - 4*vcxFont/3,ycoText, vszMarkLeftParen, 1);
         TextOut ( hDC, xcoRight + 2*vcxBorder,ycoText, vszMarkRightParen,1);
         }

     if (MarkedBits & MARK_CROSS)     /* an "x" mark */
         {
         (void)MMoveTo (hDC, xcoLeft - 2*vcxBorder, ycoTop - 2*vcxBorder);
         LineTo (hDC, xcoLeft - 7*vcxBorder, ycoTop -6*vcxBorder);
         (void)MMoveTo (hDC, xcoLeft - 6*vcxBorder, ycoTop - 2*vcxBorder);
         LineTo (hDC, xcoLeft - vcxBorder, ycoTop -6*vcxBorder);
         }

     if (MarkedBits & MARK_UNDERSCORE)  /* a "_" mark */
         {
/*
         ycoBottom = ycoText + 14 * vcyBorder;
*/
         PatBlt (hDC, xcoLeft, ycoBottom, xcoRight - xcoLeft + 1, vcyBorder, PATCOPY);
         }
     }


/**** ShowToday */

VOID APIENTRY ShowToday (
     HDC  hDC,
     INT  xcoBox,
     INT  ycoText,
     INT  dx)
     {
     TextOut (hDC, xcoBox + 1, ycoText, (LPSTR)">", 1);
     TextOut (hDC, xcoBox + dx - vcxFont - 2, ycoText, (LPSTR)"<", 1);
     }



/**** InvertDay - Invert the specified day. */

VOID APIENTRY InvertDay (
     HDC  hDC,
     WORD wDay)
     {
     RECT rect;

     MapDayToRect (wDay, &rect);
     InvertRect (hDC, (LPRECT)&rect);
     }




/**** PositionCaret */

VOID APIENTRY PositionCaret ()
     {
     RECT rect;
     INT xcoCaret;
     INT ycoCaret;

     MapDayToRect (vd3Sel.wDay, &rect);

     /* Center the caret horizontally (it is 2 * vcxFont wide),
        and put it just above the bottom of the date box.
      */
     xcoCaret = (rect.left + rect.right) / 2 - vcxFont;
     ycoCaret = rect.bottom - vcyBorder;
     SetCaretPos (xcoCaret, ycoCaret);
     }



/****  MapDayToRect */

VOID APIENTRY MapDayToRect (
     WORD wDay,
     RECT *prect)
     {
     INT  ixco;
     INT  iyco;
     INT  irgb;

     ixco = (irgb = vwWeekdayFirst + wDay - vmScrollPos*7 - hmScrollPos)%7 ;
     iyco = irgb / 7;
     if ((ixco < 0)||(ixco > 6)||(iyco < 0) ||(iyco > vcWeeksMonth))
         {
         prect->left = prect->right = 0;
         prect->top = prect->bottom = 0;
         }
     else
         {
         prect -> left = vrgxcoGrid [ixco] + vcxBorder;
         prect -> right = vrgxcoGrid [ixco + 1 ];
         prect -> top = vrgycoGrid [iyco] + vcyBorder;
         prect -> bottom = vrgycoGrid [iyco + 1];
         }
     }




/**** FMapCoToIGrid */

BOOL APIENTRY FMapCoToIGrid (
     INT  co,            /* INPUT - the coordinate to map. */
     INT  *pco,          /* INPUT - Coordinates of the grid. */
     INT  cco,           /* INPUT - Count of coordinates in the grid. */
     INT  *pico)         /* OUTPUT - the index of the grid coordinate. */
     {
     /* Note - by using co >= *pco in the loop control, we map the
        the leftmost pixel of the calendar to the first column and
        the topmost pixel to the first row.  Then, because inside
        the loop we use co <= *++pco, the rightmost and bottommost
        pixels get mapped to the last column and bottom row.
        A click on the border between two adjacent date boxes is
        mapped to the one to the right (for vertical borders),
        or bottom (for horizontal borders).
     */

     for (*pico = 0; *pico < cco && co >= *pco; (*pico)++)
          {
          if (co <= *++pco)
               return (TRUE);
          }

     return (FALSE);

     }




/**** DtFromPd3 - convert D3 to DT. */

DT   APIENTRY FAR DtFromPd3 (D3 *pd3)
     {
     static INT cDaysAccum [12] =
      {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

     DT   dt;

     dt = (pd3 -> wYear) * 365;

     /* Add in the days for the preceding leap years. */
     if (pd3 -> wYear != 0)
          dt += 1 + (pd3 -> wYear - 1) / 4;

     /* Add in the days for the full months before the current one. */
     dt += (DT)(cDaysAccum [pd3 -> wMonth]);

     /* If this is a leap year and the current month is beyond February,
        add in an extra day.
     */
     if (pd3 -> wYear % 4 == 0 && pd3 -> wMonth > MONTHFEB)
          dt++;

     /* Add in the days of the current month (prior to the current one). */
     dt += pd3 -> wDay;

     return (dt);
     }



/**** GetMarkedDays - set the marked bits in vrgbMonth for the days
      of the current month that are marked.
****/

VOID APIENTRY GetMarkedDays ()
     {
     D3   d3Temp;
     DT   dtFirst;       /* First day of month. */
     DT   dtMax;         /* Last day of month + 1. */
     DT   dtCur;         /* Day of month of current dd. */
     INT  itdd;          /* Index into the tdd. */
     DD   *pdd;          /* Pointer into the tdd. */

     /* Get the DTs of the first and (last + 1) days of the month. */
     d3Temp = vd3Sel;
     d3Temp.wDay = 0;
     dtMax = (dtFirst = DtFromPd3 (&d3Temp)) + vcDaysMonth;

     /* Look for the first day of the month.  If it's found, itdd will
        be its index.  If it's not found, itdd will be the index of the
        first entry in the tdd that is beyond the first day of the month.
        In either case, this is the place where we start looking for marked
        days within the current month.
     */
     FSearchTdd (dtFirst, &itdd);

     /* Lock the tdd and looking at all dates in the current month,
        set their marked bits in vrgbMonth if they are marked in the
        tdd.
     */
     for (pdd = TddLock () + itdd;
      itdd < vcddUsed && (dtCur = pdd -> dt) < dtMax; pdd++, itdd++)
       /* set marked bits on each day */
          if (pdd -> fMarked)
	      vrgbMonth [vwWeekdayFirst + (dtCur - dtFirst)] |= pdd -> fMarked;

     TddUnlock ();
     }




/**** MonthMode - Switch to month mode. */

VOID APIENTRY MonthMode ()
     {

     if (vfDayMode)
          {
          /* Record edits and disable focus for now.  (When UpdateMonth
             calls FFetchNewDate the focus should be NULL so it doesn't
             get set to the wrong thing (like Wnd3)).
          */
          CalSetFocus ((HWND)NULL);

          /* Say we are in Month mode. */
          vfDayMode = FALSE;

          SetScrollRange (vhwnd2B, SB_VERT, 0, SCROLLMONTHLAST, FALSE);
          SetScrollPos (vhwnd2B, SB_VERT, vd3Sel.wYear * 12 + vd3Sel.wMonth,
            TRUE);

          /* Hide the appointment description edit control. */
          ShowWindow (vhwnd3, HIDE_WINDOW);

          /* Repaint Wnd2A to display "Today is: ..." message. */
          InvalidateRect (vhwnd2A, (LPRECT)NULL, TRUE);

          /* Note - we are coming from View Month in CalCommand, so
             vd3To == vd3Sel.  This, along with setting vwDaySticky
             to the current selected day will insure that the selected
             date does not change when we call UpDateMonth.
          */
	  vwDaySticky = vd3Sel.wDay;
	  SetScrollPos (vhwnd2B, SB_HORZ, hmScrollPos, TRUE);
	  SetScrollPos (vhwnd2B, SB_VERT, vmScrollPos, TRUE);
	  SetScrollRange (vhwnd2B, SB_HORZ, 0, hmScrollMax, TRUE);
	  SetScrollRange (vhwnd2B, SB_VERT, 0, vmScrollMax, TRUE);

	  UpdateMonth ();

          /* If the focus was in the notes area in day mode, leave it in
             the notes area in month mode.  Otherwise put the focus on
             the calendar.
          */
          CalSetFocus (vhwndFocus == vhwnd2C ? vhwnd2C : vhwnd2B);
          }
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calendar.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ***** calmain.c - small segment containing main loop and caltimer stuff
 *
 */

#include "cal.h"


/**** WinMain ****/

MMain(hInstance, hPrevInstance, lpszCmdLine, cmdShow)
/* { */
    MSG  msg;


    if (!CalInit (hInstance, hPrevInstance, lpszCmdLine, cmdShow))
         return (FALSE);

        // OK to process WM_ACTIVATE from now onwards
        fInitComplete = TRUE;

    while (GetMessage (&msg, NULL, 0, 0))
        {
        /* Filter the special keys BEFORE calling translate message.
         * This way, the WM_KEYDOWN messages will get trapped before
         * the WM_CHAR messages are created so we need not worry about
         * trapping the latter messages.
         */
        if (!FKeyFiltered (&msg))
            {
            if (TranslateAccelerator (vhwnd0, vhAccel, &msg) == 0)
                {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
                }
            }
        }

    return (int)msg.wParam;
    }




/**** FKeyFiltered - return TRUE if the key has been filtered. ****/

BOOL APIENTRY FKeyFiltered (MSG *pmsg)
    {
    register WPARAM wParam;

    wParam = pmsg -> wParam;

    /* Handle TIMER message here so we don't pull in another segment. */
    if (pmsg -> message == WM_TIMER)
       {
       CalTimer(FALSE);
       return TRUE;
       }

    /* Look for key down messages going to the edit controls.
       Karl Stock says there is no need to filter out the
       key up messages, and we will not call TranslateMessage
       for the filtered keys so there will be no WM_CHAR messages
       to filter.
    */
    if (pmsg -> message == WM_KEYDOWN)
        {
        if (pmsg -> hwnd == vhwnd2C)
            {
            /* In the notes area.  Tab means leave the notes area. */
            if (wParam == VK_TAB)
                {
                /* Leave the notes area. */
                if (!vfDayMode)
                    {
                    /* Give the focus to the monthly calendar. */
                    CalSetFocus (vhwnd2B);
                    }
                else
                    {
                    /* In day mode - give focus to the appointment
                       description edit control.
                    */
                    CalSetFocus (vhwnd3);
                    }
                return (TRUE);
                }
            return (FALSE);
            }

        else if (vfDayMode)
            {
            switch (wParam)
                {
                case VK_RETURN:
                case VK_DOWN:
                    /* If on last appointment, scroll up one appoinment.
                     * If not on last appointment in window, change
                     * focus to next appointment in window.
                     */
                    if (vlnCur == vlnLast)
                         ScrollUpDay (1, FALSE);
                    else
                         SetQdEc (vlnCur + 1);

                    break;

                case VK_UP:
                    /* If on first appointment in window, scroll down
                     * one appointment.
                     * If not on first appointment in window, change
                     * focus to previous appointment in window.
                     */
                    if (vlnCur == 0)
                        ScrollDownDay (1, FALSE, FALSE);
                    else
                        SetQdEc (vlnCur-1);

                    break;

                case VK_NEXT:
                case VK_PRIOR:
                    if (GetKeyState (VK_CONTROL) < 0)
                        {
                        /* Control Pg Up and Control Pg Dn are
                         * the accelerators for Show Previous and
                         * Show Next.  We want TranslateAccelerator
                         * to see them, so return FALSE.
                         */
                        return (FALSE);
                        }

                    /* Translate into a scroll command (as if area
                     * below or above thumb had been clicked).
                     */
                    SendMessage(vhwnd2B, WM_VSCROLL,
                                wParam==VK_NEXT ? SB_PAGEDOWN : SB_PAGEUP, 0L);
                    break;

                case VK_TAB:
                    /* Switch to the notes area. */
                    CalSetFocus (vhwnd2C);
                    break;

                default:
                    return (FALSE);
                }
            return (TRUE);
            }
        }

    return (FALSE);
    }


/**** CalTimer ****/

VOID APIENTRY CalTimer (BOOL fAdjust)
    {
    HDC  hDC;
    D3   d3New;
    DT   dtNew;
    TM   tmNew;
    FT   ftPrev;

    if (vfFlashing)
         FlashWindow (vhwnd0, TRUE);

    if (vcAlarmBeeps != 0)
         {
         MessageBeep (ALARMBEEP);
         vcAlarmBeeps--;
         }

    /* Fetch the date and time. */
    ReadClock (&d3New, &tmNew);

    /* See if the time or date has changed.  Note that it's necessary
     * to check all parts in order to immediartely detect all changes.
     * (I used to just check the time, but that meant a date change was
     * not detected until the minute changed.)
     */

    if (tmNew != vftCur.tm || d3New.wMonth != vd3Cur.wMonth
         || d3New.wDay != vd3Cur.wDay || d3New.wYear != vd3Cur.wYear)
         {
         /* Remember the old date and time */
         ftPrev = vftCur;
         vftCur.tm = tmNew;

         /* Show new date/time only if not iconic */
         if (!IsIconic(vhwnd0))
           {
           hDC = CalGetDC (vhwnd2A);
           DispTime (hDC);

           if ((dtNew = DtFromPd3 (&d3New)) != vftCur.dt)
                {
                vftCur.dt = dtNew;
                vd3Cur = d3New;
                if (!vfDayMode)
                     {
                     /* Display the new date. */
                     DispDate (hDC, &vd3Cur);

                     /* If the old or new date is in the
                        month currently being displayed, redisplay to get rid of
                        the >< on the old date.
                        Also, if the new date is in the month being displayed,
                        it will get marked with the >< as a result.
                     */
                     if ((vd3Cur.wMonth == vd3Sel.wMonth && vd3Cur.wYear ==
                      vd3Sel.wYear) || (d3New.wMonth == vd3Sel.wMonth
                      && d3New.wYear == vd3Sel.wYear))
                           {
                           /* Note - neither vcDaysMonth nor vwDaySticky
                              has changed, so UpdateMonth will end up selecting
                              the same day that's currently selected (which
                              is what we want).
                           */
                           vd3To = vd3Sel;
                           UpdateMonth ();
                           }
                     }
                }

           ReleaseDC (vhwnd2A, hDC);
           }

         /* If the new date/time is less than the previous one, or the
            new one is a day (1440 minutes) or more greater than the
            previous one, we want to resynchronize the next alarm.
            Obviously, if the date/time is less than the previouse one,
            the system clock has been adjusted (except in the case
            where it wraps on December 31, 2099, which I am not worried
            about).  However, it is not obvious when the clock has been
            set forward.  For example, if the user is running Calendar
            and then switches to an old application that grabs the
            whole machine (.g., Lotus 123), Calendar will not get
            timer messages while the olf app is running.  It is completely
            reasonable to expect that the user may not return to Windows
            for a long time (on the order of hours), so we only assume
            the clock has been set forward if it changes by a day or
            more (1440 minutes).  We don't want to make this period
            too great either since if we don't think the clock has been
            set ahead, we will put all the alarms that have passed into
            the alarm acknowledgement listbox.  In fact, avoiding this
            was the main reason for detecting clock adjustments.  Without
            setting the date/time on a machine without a hardware clock,
            the date/time would start out back in January, 1980.  If he
            then noticed the date was wrong and set it, all the alarms
            since January 1980 would be put into the listbox, which is
            not only rediculous, but could take a long time to read
            the disk for a bunch of old dates.  With the one day adjustment
            period, this is no longer a problem, because we ignore alarms
            that go off due to a forward clock adjustment.
            Note - do not set vfMustSyncAlarm FALSE in any case since
            it may already be TRUE and hasn't been serviced yet
            (because uProcessAlarms is locked).
         */

         /* If there is no NextAlarm present, then we dont have to resync
          * any alaram at all;
          * Fix for Bug #6196 --SANKAR-- 11-14-89
          */
         if (fAdjust && CompareFt (&vftCur, &ftPrev) != 0
              && vftAlarmNext.dt != DTNIL)
             {
             /* The clock has been adjusted - set flag to tell
                uProcessAlarms we want to resync, and force the
                call to AlarmCheck (below) to trigger an alarm
                immediately by setting the alarm time to the current
                time.
              */

             vfMustSyncAlarm=TRUE;
             vftAlarmNext=vftCur;
             }

         /* See if it's time to trigger the alarm (also handle
            resynchronization).
         */
         AlarmCheck ();
         }
    }


/**** AlarmCheck ****/

VOID APIENTRY AlarmCheck ()
     {

     FT   ftTemp;

     /* If the current time plus the early ring period is greater than or
        equal to the next alarm time, trigger the alarm.
     */
     ftTemp = vftCur;
     AddMinsToFt (&ftTemp, vcMinEarlyRing);
     if (CompareFt (&ftTemp, &vftAlarmNext) > -1)
          {
          /* Sound the alarm if sound is enabled.  Give the first beep
             right now and the rest at one second intervals in the timer
             message routine.
          */
          if (vfSound)
               {
               MessageBeep (ALARMBEEP);
               vcAlarmBeeps = CALARMBEEPS - 1;
               }

          if (vftAlarmFirst.dt == DTNIL)
               {
               /* This is the first unacknowledged alarm - remember it. */
               vftAlarmFirst = vftAlarmNext;

               if (GetActiveWindow () == vhwnd0)
                    {
                    /* We are the active window, so process the alarm now. */
                    uProcessAlarms ();
                    return;
                    }

               /* Not the active window, so fall through. */
               }

          /* Let the user know there are unacknowledged alarms. */
          StartStopFlash (TRUE);

          /* The next alarm is the first one > the one that just went off.
             GetNextAlarm looks for >=, so add one minute.
             Do not go to the disk - only arm the next alarm if it's in
             memory.  Note that this is absolutely necessary in the case
             where we don't have the focus (the user is doing something
             else, so it would be rude to start spinning the the disk and
             possibly asking for the correct floppy to be inserted).  In
             the case where we are active but the alarm acknowledgement
             dialog is already up, it would actually be OK to go to the disk,
             but I have decided it would be too confusing for the user if
             a disk I/O error were to occur at this point.
          */
          ftTemp = vftAlarmNext;
          AddMinsToFt (&ftTemp, 1);
          GetNextAlarm (&vftAlarmNext, &ftTemp, FALSE, (HWND)NULL);
          }
     }


/**** AddMinsToFt ****/

VOID APIENTRY AddMinsToFt (
    FT   *pft,
    UINT cMin)          /* Not to exceed the minutes in one day (1440). */
    {
    /* Add cMin to the time.  Note that the highest legitimate
       TM and the largest cMin cannot overflow a WORD, which
       is what a TM is, so we needn't worry about overflow here.
    */
    if ((pft -> tm += (TM)cMin) > TMLAST)
         {
         /* The time wrapped into the next day.  Adjust down the time,
            and increment the day.  If the date goes beyond DTLAST (that
            of December 31, 2099, the value should still be OK for the
            caller since it will only be used for comparison purposes.
            Anyway, I will be dead when that case comes up, so if it doesn't
            work correctly, it won't be my problem.
         */
         pft -> tm -= TMLAST + 1;
         pft -> dt++;
         }
    }



/**** CompareFt - compare the two FTs returning:
      -1 iff ft1 < ft2
      0  iff ft1 = ft2
      +1 iff ft1 > ft2
****/

INT  APIENTRY CompareFt (
    FT   *pft1,
    FT   *pft2)
    {
    register FT *pft1Temp;
    register FT *pft2Temp;

    if ((pft1Temp = pft1) -> dt < (pft2Temp = pft2) -> dt)
         return (-1);

    if (pft1Temp -> dt > pft2Temp -> dt)
         return (1);

    /* DTs are equal, compare the TMs. */
    if (pft1Temp -> tm < pft2Temp -> tm)
         return (-1);

    if (pft1Temp -> tm > pft2Temp -> tm)
         return (1);

    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calfile2.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calfile2.c
 *
 */

#include "cal.h"
#include "memory.h"

extern BOOL f24Time;


CHAR * APIENTRY PFileInPath(
    CHAR *sz);


/**** FCopyToNewFile - copy the active dates from the specified file
      (original or change) to the new file.
****/

BOOL APIENTRY FCopyToNewFile (
     INT  idFileSource,            /* The id of the source file. */
     DR   *pdr,                    /* Pointer to DR to use as a buffer. */
     DD   *pddFirst,               /* Pointer to locked tdd. */
     DD   *pddMax)                 /* Pointer beyond locked tdd. */
     {
     register BOOL fSwap;
     register DD *pddCur;
     DL   dl;

     /* If the source file does not exist, there is no work to be done,
        so return right away, indicating success.  (The original file
        doesn't exist if we're as yet untitled, and the change file
        doesn't exist if it was impossible to create it (and the user
        was told of the error when the attempt to create the change
        file failed).)
      */

     if (idFileSource == IDFILEORIGINAL && !vfOriginalFile
             || idFileSource == IDFILECHANGE && !vfChangeFile)
         return (TRUE);

     /* Try to reopen the source file, returning an error if the open fails. */
     if (!FReopenFile (idFileSource, OF_PROMPT | OF_CANCEL | OF_REOPEN | OF_READWRITE))
          goto error1;


     /* See if the destination file is available without swapping diskettes.
        If it is, leave the source and destination files both open.
        If it is not available, leave both files closed.
      */

     if (fSwap = !FReopenFile (IDFILENEW, OF_REOPEN | OF_READWRITE))
          {
          /* Don't worry about errors closing the files.
             If there's really a problem, it will be detected when we try
             to use the files below.
           */
          FCloseFile (idFileSource);
          FCloseFile (IDFILENEW);
          }



     /*  Make a pass through the tdd looking for dates that are
         in the source file.  Copy these dates into the destination file.
      */
     for (pddCur = pddFirst; pddCur < pddMax; pddCur++)
          {
          /* If this date has not already been transferred, and it's not
             a special DL, and it resides in the source file we're working
             on, copy the data for the date.
          */
          if (pddCur -> dlSave == DLNOCHANGE
                   && (dl = pddCur -> dl) < DLSPECIALLOW
                   && ((dl & DLFCHANGEFILEMASK) && idFileSource == IDFILECHANGE
                   || !(dl & DLFCHANGEFILEMASK) && idFileSource == IDFILEORIGINAL))
               {
               if (!FReadDrFromFile (fSwap, pdr, dl))
                    {
                    /* An error occurred,
                       so we tell the caller to give up the Save.
                    */
                    goto error1;
                    }

               /* Remember the current DL, and set the new one to be the
                  place where we are about to write the date to in the
                  new file.
               */
               pddCur -> dlSave = dl;
               pddCur -> dl = (DL)vobkEODNew;

               /* Try to write the date to the new file.  If an error
                  occurs, the Save will be aborted.  It may be due
                  to a disk full condition or some I/O error.
               */
               if (!FWriteDrToFile (fSwap, IDFILENEW, pdr))
                    goto error1;
               }
          }


     /* If we weren't swapping, we need to close the files (and it's harmless
        to call FCloseFile for an unopen file).
        We ignore errors closing the source file since no modifications
        were made to it, we are done with it, and an error here has no
        effect on the integrity of the new file (which is what the user
        really cares about now).  And anyway, what sort of error could
        occur when closing a file that has only been read from?
        As for closing the new file, if an error occurs, we return it
        as an I/O error, which will cause the Save to be aborted.
        (Can't ignore error closing the new file, since an error here
        means there may be something wrong with it.)  By the way, according
        to Chris Peters, close cannot cause a Disk Full error since it
        cannot cause any disk space allocation.  Close does update the
        directory entry though.  Therefore, the only the only
        kind of error that can occur during a close is an I/O error.
        Chris says most programmers do not bother to check for errors
        when closing files.  I still think it's the prudent thing to
        to when closing a file that one has written to.
      */

     FCloseFile (idFileSource);
     return (FCloseFile (IDFILENEW));


error1:   /* An error occurred - close all files, and return FALSE. */
     FCloseFile (idFileSource);
     FCloseFile (IDFILENEW);
     return (FALSE);
     }




/**** FSaveFile - the guts of Save and Save As. ****/
BOOL APIENTRY FSaveFile (
    CHAR *szFileSpec,             /* Name of the file to save to. ANSI STRING. */
    BOOL fOverwrite)              /* TRUE means the old copy of the file with
                                     same name in the same directory as the new
                                     file should be overwritten by the new one
                                     if the Save is successful.
                                   */
     {
     DD   *pddFirst, *pddMax, *pddCur;
     WORD idr;
     INT  FileHandle, fp;
     DR   *pdr;
     BOOL fOk;
     DL   dl;

     /* Show the hour glass cursor. */
     HourGlassOn ();

     if ((fp = M_lopen((LPSTR)szFileSpec, 2)) < 0)   /* fgd 9/20/89  */
         fp = M_lcreat((LPSTR)szFileSpec, 0);                 /* _lopen & _lcreat */
                                                             /* use ANSI chrs */
     if (fp >  0)
        M_lclose(fp);
     else
        {
        AlertBox (vrgsz[IDS_NOCREATE], szFileSpec,
                  MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        HourGlassOff();
        return FALSE;
        }

     /* Force edits to be recorded prior to flushing the DRs.  Note that
        leaving the focus as is will work OK since the DR corresponding
        to vidrCur remains in memory during the Save.  This means that
        if the focus is changed later, the correct date will still be
        around for use by StoreQd or StoreNotes.  Since Save does not
        change the mode (day or month) we want the focus to stay where
        it was, so we don't do a CalSetFocus ((HWND)NULL) here.
      */
     RecordEdits ();


     /* Create the new file as a temporary - we will rename it when the
        save is finished.  Note that we must force the temp file to
        be on the drive we want the new file on, since, of course, we can't
        rename across drives.  Surprizingly though, we can rename across
        directories.
      */
     if (!FCreateTempFile (IDFILENEW, GetDrive (szFileSpec) | TF_FORCEDRIVE))
          goto error1;


     /* Calculate the number of BK required to hold the header and the
        index.  Set the end of data of the new file in
        order to reserve the required space.  Note that we don't actually
        write the header or the index until after the dates have been
        successfully written to the new file.  This is done for two reasons:

        1) By not writing the magic number until the end, we reduce the
           risk of ever trying to use a file that has the correct magic
           number but which is corrupt.  (In other words, if an error
           causes the Save to be aborted, and for some reason the new
           file cannot be deleted, it probably won't look like a valid
           calendar file (although I suppose the disk space allocated
           to the file could contain the correct magic number - but I
           am not going to to bother to write something into the first byte
           of the file just to handle this unbelievably pathological case.

        2) More importantly - we cannot write the index now because
           it does not yet contain the new DLs.  These will be set as
           the dates are moved into the new file.

        Note that adding CBBK - 1 prior to dividing by CBBK has the
        effect of rounding up to the next bk.
      */
     vobkEODNew = 1 + (vcddUsed * sizeof (DD) + CBBK - 1) / CBBK;



     /* Mark each DD to indicate that its data has not yet been copied to
        the new file.
      */
     for (pddMax = (pddCur = TddLock ()) + vcddUsed; pddCur < pddMax; pddCur++)
          pddCur -> dlSave = DLNOCHANGE;

     TddUnlock ();


     /* Now we flush any dates that are in memory to the new file. */
     fOk = FFlushDr ();


     /* The tdd may have become smaller during FFlushDr since we may
        have deleted some empty DDs.  Lock it, and set up First and Max
        pointers.  These pointers are needed for error recovery, so we
        must do this prior to bailing out if FFlushDr failed.
      */
     pddMax = (pddFirst = TddLock ()) + vcddUsed;


     /* Bail out if FFlushDr encountered an error trying to write out
        one of the DRs.
      */
     if (!fOk)
         goto error2;


     /* Find a free DR to use as a buffer, and lock it.  */
     idr = IdrFree ();
     pdr = PdrLock (idr);


     /* Copy the dates from the change file to the new file, then
        copy the dates from the original file to the new file.
      */
     fOk = FCopyToNewFile (IDFILECHANGE, pdr, pddFirst, pddMax)
      && FCopyToNewFile (IDFILEORIGINAL, pdr, pddFirst, pddMax);

     /* Make sure the DR we used as a buffer looks free, then
        unlock it.
     */
     pdr -> dt = DTNIL;
     DrUnlock (idr);

     /* If dates were copied OK, then try to write the header.  If either
        operation failed, abort the Save.
     */
     if (!fOk || !FWriteHeader (pddFirst))
          goto error2;

     /* Finished with the tdd - unlock it. */
     TddUnlock ();

     /* Reconnect the DRs with their DDs. */
     Reconnect (TRUE);


      /* Delete the file being overwritten.  Note that this is the
         file on the same device and directory with the same name
         as what our new file is to be named - it is not necessarily
         the original file.  However, we use the reo of the original
         file since it is available at this point.  So we call
         OpenFile to get the user to swap diskettes if necessary,
         and then we delete the file.
         If an error occurs during the delete, ignore it.
         The new file is in good shape, the only problem is that
         we won't be able to rename it to it's correct name since
         we couldn't delete the old copy.  This will get detected
         when we attempt the rename (below), and the user will be
         told about the problem then.  Bear in mind that if we can't
         delete the old file, we probably can't access it at all,
         and since it could be the original file, it would be a bad
         idea to abort the Save now.
       */
      if ((FileHandle = MOpenFile ((LPSTR)szFileSpec,
                            (OFSTRUCT FAR *)&OFStruct [IDFILEORIGINAL],
                            OF_PROMPT | OF_CANCEL | OF_READWRITE))
           != -1)
           {
           M_lclose (FileHandle);
           FDosDelete (OFStruct [IDFILEORIGINAL].szPathName);
           }

     /* Rename the new file. */
     fOk = FReopenFile (IDFILENEW, OF_REOPEN | OF_PROMPT | OF_CANCEL | OF_READWRITE);
     FCloseFile (IDFILENEW);

     if (!fOk || FDosRename (OFStruct [IDFILENEW].szPathName, szFileSpec))
          {
          /* Could not rename the file.  Tell the user that his data is
             in the temp file with the funny name.  Also change szFileSpec
             to point to the temporary file name since this is what we will
             be using now.
             This should rarely, if ever, occur.  What could
             have gone wrong?  An I/O error perhaps while trying to
             rewrite the directory entry?  Anyway, we do our best
             to recover from the situation.
           */

          /* delete the file we created which the user wanted to save as.
           * bug fix. we were leaving it in existence with 0 length.
           * don't delete if we were just doing a save.
           * 21-Jun-1987. davidhab
           */

          if (!fOverwrite)
              FDosDelete(szFileSpec);

          szFileSpec = OFStruct [IDFILENEW].szPathName;

          AlertBox (vszRenameFailed, szFileSpec,
                    MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
          }

     /* The new file is now the original file.  We need to set up
        OFStruct [IDFILEORIGINAL] accordingly.  The simplest way to do this
        is to call OpenFile using szFileSpec - this will set up the reo.
        Call with OF_EXIST since this means the file will not be left open.
        Don't bother to check for errors since all we care about at this
        point is getting the reo set up, and this will presumably happen
        no matter what.
      */
     MOpenFile ((LPSTR)szFileSpec, (OFSTRUCT FAR *)&OFStruct [IDFILEORIGINAL], OF_EXIST);

     /* Delete and recreate the change file.  If the delete fails, ignore
        it.  If the new one can't be created CreateChangeFile will tell
        the user about the problem.  (Note that it may be possible to
        create the new change file even if the old one can't be deleted
        since a different temporary file name will be used.)
        The point is, the Save has successfully completed, and not being
        able to delete the old change file or create the new change file
        should not abort the Save at this point.
        The only problem is, the user may think the Save was not successful
        if he sees the error message generated by CreateChangeFile.  I am
        assuming that the chances of this failure occuring are extremely
        remote, and in any case the result is not catastrophic.
      */
     CreateChangeFile ();

     /* Everything is clean now. */
     vfDirty = FALSE;

     /* Set the new title. */
     SetTitle (szFileSpec);

     /* The waiting is over. */
     HourGlassOff ();

     return (TRUE);


error2:   /* Error while trying to flush the DRs, copy the dates,
             or write the header.
           */
     /* Set the DLs back to their old values. */
     for (pddCur = pddFirst; pddCur < pddMax; pddCur++)
          {
          if ((dl = pddCur -> dlSave) != DLNOCHANGE)
               pddCur -> dl = dl;
          }

     /* Unlock the tdd. */
     TddUnlock ();

     /* Try to delete the new file.  If an error occurs, ignore it.
        We are already going to tell the user that a problem has occurred,
        and there is nothing we can do about it if the new file (which
        has a funny name) can't be deleted.
      */
     FDeleteFile (IDFILENEW);

     /* delete the file we created which the user wanted to save as.
      * bug fix. we were leaving it in existence with 0 length.
      * don't delete if we were doing just a save.
      * 21-Jun-1987. davidhab
      */
     if (!fOverwrite)
         FDosDelete(szFileSpec);


     /* Reconnect the DRs with their DDs. */
     Reconnect (FALSE);

error1:   /* Error attempting to create the new file. */
     /* Tell the user that the Save failed. */
     AlertBox (vszSaveFailed, (CHAR *)NULL,
               MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);

     /* The waiting is over. */
     HourGlassOff ();

     return (FALSE);

     }




/**** Reconnect - reconnect DRs with their DDs, and make sure the
      selected date is in memory.
****/

VOID APIENTRY Reconnect (BOOL fSaveOk)
     {
     register WORD idr;
     register DR *pdr;
     INT  itdd;
     HWND   hwndFocus;

     /* Look at all the DRs. */
     for (idr = 0; idr < CDR; idr++)
          {
          /* Get a pointer to the DR. */
          pdr = PdrLock (idr);

          /* Skip over DRs that are not in use. */
          if (pdr -> dt != DTNIL)
               {
               /* Reconnect it to its DD.  Note that there must be a
                  DD for it since when FFlushDr deleted a DD it had
                  already marked the DR as free (which this one is not).
               */
               FSearchTdd (pdr -> dt, &itdd);
               (TddLock () + itdd) -> idr = idr;
               TddUnlock ();

               /* If the Save succeeded then the DR is now clean.  If
                  it failed we leave the dirty flag alone (it could be
                  be either dirty or clean, depending on it's state
                  before the Save was attempted).
               */
               if (fSaveOk)
                    pdr -> fDirty = FALSE;
               }

          DrUnlock (idr);
          }

     /* We need to make sure the selected date is in memory.  We know
        that this call to FGetDateDr cannot fail since the date is
        already in one of the DRs we just reconnected, or it has no
        data associated with it.  In either case, it cannot require
        a disk read so no error can occur.  It may no longer be in the
        tdd (FFlushDr may have deleted it), but in that case FGetDateDr
        will build a new DD for it, and we know there will be room for
        the new DD since it was in the tdd before the Save started
        and the DD could only have gotten smaller not larger.
        Also note that FGetDateDr will not have to kick out another
        date since the selected date was in a DR before the Save and
        we have not reassigned any of them, so no disk writes will
        be done either.  So no errors can occur.
     */
     hwndFocus = GetFocus();
     FGetDateDr (DtFromPd3 (&vd3Sel));
     CalSetFocus(hwndFocus);
     }




/**** GetDrive - extract the drive letter from a file spec.
      if none specified, return the current drive.
****/

INT  APIENTRY GetDrive (CHAR *szFileSpec)
     {
     CHAR *pch;

     /* Skip leading spaces. */
     pch = szFileSpec;
     SkipSpace (&pch);

     /* If the second character is a colon, the first character is a drive
        letter.  Otherwise return the current drive.
      */
#ifdef DBCS
     if( IsDBCSLeadByte(*pch) )
         return GetCurDrive();
     else
         return (*(pch + 1) == ':' ? *pch : GetCurDrive ());
#else
     return (*(pch + 1) == ':' ? *pch : GetCurDrive ());
#endif
     }





/**** FFlushDr - iterate the DRs to:
      1) free up empty ones (no data) and get rid of the associated DD
         if it too is empty.
      2) write out non-empty dirty DRs to the new file.

      Return TRUE if no errors, FALSE if an error
      occurs while trying to flush one of the DRs.
****/
BOOL APIENTRY FFlushDr ()
     {
     WORD idr;
     register DR *pdr;
     BOOL fOk;
     INT  itdd;
     register DD *pdd;

     /* Look at all the DRs - stop if an error occurs while trying
        to write one of them to the new file.
      */

     for (idr = 0, fOk = TRUE; idr < CDR && fOk; idr++)
          {
          /* Get a pointer to the DR. */
          pdr = PdrLock (idr);

          /* Skip over DRs that are not in use. */
          if (pdr -> dt != DTNIL)
               {
               /* Break the connection between the DD and the DR.
                  Note - the owner of the DR must be in the
                  tdd, so don't bother checking the return value
                  of FSearchTdd.
               */
               FSearchTdd (pdr -> dt, &itdd);
               (pdd = TddLock () + itdd) -> idr = IDRNIL;

               if (pdr -> cbNotes + pdr -> cbTqr == 0)
                    {
                    /* The DR is empty.  Free it up. */
                    pdr -> dt = DTNIL;

                    /* Say the date is no longer on disk either.  Since
                       there is no longer any data associated with the
                       date, even if the Save fails we want the DL to
                       be DLNIL, so make both dlSave and dl DLNIL.
                    */
                    pdd -> dlSave = pdd -> dl = DLNIL;

                    /* The DD may now be empty (if the data is not marked).
                       If this is the case, get rid of
                       the DD since we don't want to write it out to
                       the new file.  Even if the Save fails this is OK.
                       If it's the selected date it will get reinserted
                       into the DD, and if it's not the selected date it
                       it not needed and will get reinserted if the user
                       ever switches to it.
                       Note that it's OK to call DeleteEmptyDd even though
                       the tdd is locked since if it does a ReAlloc it
                       will only be to make the tdd smaller.
                    */
                    DeleteEmptyDd (itdd);
                    }
               else
                    {
                    /* The DR is not empty - see if it's dirty. */
                    if (pdr -> fDirty)
                         {
                         /* Remember old disk location, set new one. */
                         pdd -> dlSave = pdd -> dl;
                         pdd -> dl = (DL)vobkEODNew;

                         /* Write it to the new file.  Note that we
                            intentionally leave fDirty TRUE.  This is
                            necessary for putting things back the way
                            they were if the Save fails.
                         */
                         fOk = FWriteDrToFile (TRUE, IDFILENEW, pdr);
                         }
                    }

               /* Unlock the tdd. */
               TddUnlock ();
               }

          /* Unlock the DR. */
          DrUnlock (idr);
          }

     return (fOk);

     }


/**** FCloseFile - close he specified file if it's open.  Return TRUE
      if the file is successfully closed. Assume this happens since
      M_lclose does not give us an error return anyway.

      Note -
      According to Chris Peters, close cannot cause a Disk Full error since
      it cannot cause any disk space allocation.  Close does update the
      directory entry though.  Therefore, the only the only
      kind of error that can occur during a close is an I/O error.
      Chris says most programmers do not bother to check for errors
      when closing files.  I still think it's the prudent thing to
      to when closing a file that one has written to.
****/

BOOL APIENTRY FCloseFile (INT idFile)
    {
    INT FileHandle;

     if ((FileHandle = hFile[idFile]) == -1)	// Q: no valid handle?
          return (TRUE);						//   Y: no need to close file
     else
          {
          hFile[idFile] = -1;					
          M_lclose(FileHandle);					// close file,
          return TRUE;							// return success always
          }
     }




/**** FWriteHeader - write out the file header and index.
      Return TRUE if successful, FALSE if an error occurs.
****/

BOOL APIENTRY FWriteHeader (DD*pddFirst)
{
    BYTE bkBuf [CBBK];
    register BYTE *pb;
    register BOOL fOk;
    INT FileHandle;

     /* Reopen the file, seek to the beginning of the second BK, and write
        the index (tdd).
     */
     fOk=FReopenFile(IDFILENEW, OF_REOPEN | OF_PROMPT | OF_CANCEL | OF_READWRITE)
          && M_llseek ((FileHandle = hFile [IDFILENEW]), (LONG)CBBK, 0) != -1
          && FWriteFile (FileHandle, (BYTE *)pddFirst, (WORD)(vcddUsed * sizeof (DD)));

	if (fOk)
	{
		//- Save Header: Need a 16 bit word to copy the header info into.
		WORD  wTemp;

		/* Build a header bk containing the magic number, the
		   size of the index, and the options.
		   Unused bytes are set to 0 and are reserved for future use.
		*/
		FillBuf (bkBuf, CBBK, 0);

		pb = BltByte ((BYTE *)vrgbMagic,       (BYTE *)bkBuf, CBMAGIC);

		//- Save Header: Copy to temporary 16 bit storage then assign.
		wTemp = (WORD)vcddUsed;
		pb = BltByte ((BYTE *)&wTemp,       (BYTE *)pb, CBCDD);

		wTemp = (WORD)vcMinEarlyRing;
		pb = BltByte ((BYTE *)&wTemp, 	(BYTE *)pb, CBMINEARLYRING);

		wTemp = (WORD)vfSound;
		pb = BltByte ((BYTE *)&wTemp,        (BYTE *)pb, CBFSOUND);

		wTemp = (WORD)vmdInterval;
		pb = BltByte ((BYTE *)&wTemp,    	(BYTE *)pb, CBMDINTERVAL);

		wTemp = (WORD)vcMinInterval;
		pb = BltByte ((BYTE *)&wTemp,  	(BYTE *)pb, CBMININTERVAL);

		wTemp = (WORD)vfHour24;
		pb = BltByte ((BYTE *)&wTemp,       	(BYTE *)pb, CBFHOUR24);

		pb = BltByte ((BYTE *)&vtmStart,      (BYTE *)pb, CBTMSTART);

		/* Write the header into the first BK of the file. */
		fOk = M_llseek (FileHandle, (LONG)0, 0) != -1
				&& FWriteFile (FileHandle, bkBuf, CBBK);
	}

     /* Close the file.  Note that calling FCloseFile is Ok even if the
        file was not successfully opened.  Also note that the FCloseFile
        call must be separate from the other operations and must be done
        before checking fOk since we want the file to be closed regardless
        of whether an error has occurred.
     */
    return (FCloseFile (IDFILENEW) && fOk);
}




/**** FWriteFile - write to file.
      If a disk full error occurs, put up a message box for the user.
      If some other type of error occurs (I/O error), assume that the user
      has already seen the INT 24 Abort, Retry, Ignore dialog, so no need
      to put up another message.  Return FALSE if error occurs, TRUE if
      write is successful.
****/

BOOL APIENTRY FWriteFile (
     INT  FileHandle,         /* Handle of file to write to. */
     BYTE *pb,           /* Pointer to bytes to be writeen. */
     UINT cb)            /* COunt of bytes to write. */
     {
     /* Do the write.  Return TRUE if it's successful.
        Note that due to some ambiquity about what write returns
        if it runs out of disk space (the C manual talks about -1 for
        an error, but at the same time says the count of bytes written
        could be less than specified but positive if the write runs
        out of disk space), we call it a bad write if the return value
        (count of bytes written) is not cb (the number of bytes we say to
        write).  This works for both cases.
      */
     if ((WORD)_lwrite (FileHandle, (LPSTR)pb, cb) == cb)
          return (TRUE);

     /* Put up disk full message if that's the error that occurred. */
     /* Assume out of disk space. */
#ifdef DISABLE
     if (_errno == ENOSPC)
          {
#endif
          /* Need to make this system modal since the file is still
             open and it's against the rules to relinquish control with
             files open.
          */
          AlertBox (vszDiskFull, (CHAR *)NULL,
               MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION);
#ifdef DISABLE
          }
#endif

     return (FALSE);

     }




/**** FDeleteFile - delete the specified file.  Return TRUE if successful,
      FALSE if an error occurs.
****/
BOOL APIENTRY FDeleteFile (INT idFile)
    {
    register BOOL fOk;

     /* Make sure the file exists, prompting for it if necessary.  Then
        try to delete it.
     */
     fOk=FReopenFile(idFile, OF_REOPEN | OF_PROMPT | OF_CANCEL |  OF_READWRITE);

     FCloseFile (idFile);
     return (fOk && FDosDelete (OFStruct [idFile].szPathName));
     }




/**** FReopenFile - */
BOOL APIENTRY FReopenFile (
     INT  idFile,
     WORD wFlags)
     {
     hFile[idFile]= MOpenFile ((LPSTR)vrgsz [IDS_GIVEMEFIRST + idFile],
                         (OFSTRUCT FAR *)&OFStruct[idFile], wFlags);

     return (hFile[idFile]!=-1);
     }




/**** SetTitle ****/
VOID APIENTRY SetTitle (CHAR *sz)
     {
     /* We know that the sz we are being passed has been through
        DlgCheckFilename at some point, so it has to contain a valid
        filename and extension and no longer has any trailing blanks.
        Therefore we know that this buffer is large enough.
     */
     CHAR szWindowText [CCHSZWINDOWTEXTMAX];

     /* Set the flag indicating if there is an open calendar file. */
     if (vfOriginalFile = sz != vszUntitled)
          {
          /* Convert file name to upper case.  Note - "(untitled)" should
             not be converted to upper case.
          */
          lstrcpy( vszFileSpec, sz);
          AnsiUpper ((LPSTR)vszFileSpec);
          }

     else
        lstrcpy (vszFileSpec, sz);


     /* Strip the path name, build the title string,
        and tell Windows about it.
     */
     lstrcat (lstrcpy (szWindowText, vszCalendarDash), PFileInPath (vszFileSpec));
     SetWindowText (vhwnd0, (LPSTR)szWindowText);
     }




/**** FCondClose - conditionally close the specified file. */

BOOL APIENTRY FCondClose (
     BOOL fClose,        /* FALSE means don't close the file, TRUE means do. */
     INT  idFile)        /* The id of the file to close. */
     {
     /* If we're not supposed to close the file, just return TRUE.
         If we are, return the result of FCloseFile.
     */
     return (!fClose || FCloseFile (idFile));
     }




/**** CleanSlate ****/

VOID APIENTRY CleanSlate (BOOL fShowDate)
     {
     register WORD idr;

     /* Show the hour glass cursor. */
     HourGlassOn ();

     /* Take the focus away so that the current edits get recorded now
        and not later when the slate is suppose to be clean.  (We don't
        care about the current edits since we are about to throw away
        everything, but if we were to leave the focus on an edit control,
        its contents would get stored when the focus gets set later.  This
        would make the file dirty with data that's supposed to
        be gone.)
      */
     CalSetFocus ((HWND)NULL);


     /* Say everything is clean. */
     vfDirty = FALSE;

     /* Say there is no next alarm, and forget about any unacknowledged
        ones.
      */
     vftAlarmNext.dt = vftAlarmFirst.dt = DTNIL;

     /* Mark all DR as available. */
     for (idr = 0; idr < CDR; idr++)
          {
          PdrLock (idr) -> dt = DTNIL;
          DrUnlock (idr);
          }

     /* Get rid of all entries in the tdd. */
     InitTdd ();

     /* Set all options to their default values. */
     vcMinEarlyRing = 0;
     vfSound = TRUE;
     vmdInterval = MDINTERVAL60;
     vcMinInterval = 60;
     InitTimeDate(vhInstance, 0);
     vfHour24 = f24Time;
     vtmStart = 7 * 60;       /* changed from 8 to 7 11/27/88 */

     /* Say there is no current file. */
     SetTitle (vszUntitled);

     /* Delete old change file (if there is one), and create the new
        one.  If a Save has just been done, the change file has
        already been recreated, but I guess this is OK.  We must
        recreate the change file now because we don't know whether
        the the user said to ignore old edits (in which case the
        Save didn't get done and the old change file is still around).
        This CreateChangeFile is also needed here for the call from
        CalInit, in which case it creates the change file for the
        first time.
     */
     CreateChangeFile ();

     /* Go into day mode for today.  Set the selected month to an
        impossible one - this will cause SwitchToDate (called by
        DayMode) to call SetUpMonth.  Note that the SwitchToDate call
        cannot fail since it will not attempt to read from a file.
     */
     if (fShowDate)
          {
          vd3Sel.wMonth = MONTHDEC + 1;
	  DayMode (&vd3Cur);
          }
     /* The waiting is over. */
     HourGlassOff ();
     }




#if 0
  /* old version commented out - L.Raman */
/**** OpenCal - open a calendar file. ****/

VOID APIENTRY OpenCal ()
     {
     CHAR szNewFileSpec [CCHFILESPECMAX];
     INT wResult;
     CHAR szExtension[8];

     lstrcpy((LPSTR)szExtension, (LPSTR)"\\*");
     lstrcat((LPSTR)szExtension, (LPSTR)vrgsz[IDS_FILEEXTENSION]);

     wResult = cDlgOpen (vhInstance, vhwnd0, IDD_OPEN,	IDCN_EDIT,
	    	             IDCN_LISTBOX, IDCN_PATH, szExtension, CCHFILESPECMAX,
    	    	         szNewFileSpec, (OFSTRUCT *)&OFStruct[IDFILEORIGINAL], &hFile[IDFILEORIGINAL]);


     switch (wResult)
        {
	case 1: /* hit ok, legal name */
            LoadCal ();
            break;

	case 2:  /*hit ok, illegal name */
            AlertBox (vszBadFileName, szNewFileSpec, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
            break;

	case -1:  /*out of memory   */
            AlertBox (vszOutOfMemory, (CHAR *) NULL, MB_SYSTEMMODAL | MB_OK | MB_ICONHAND);
	    break;
         }

     }
#endif

VOID APIENTRY OpenCal ()
{
     CHAR szNewFileSpec [CCHFILESPECMAX] = "";
     extern CHAR szLastDir[];

     /* set up the variable fields of the OPENFILENAME struct. (the constant
      * fields have been sel in CalInit()
      */
     vOFN.lpstrFile	    = szNewFileSpec;
     vOFN.lpstrInitialDir   = szLastDir;
     vOFN.lpstrTitle	    = vszOpenCaption;
     vOFN.Flags 	    = vfOpenFileReadOnly ? OFN_READONLY : 0L;

     /* All long pointers should be defined immediately before the call.
      * L.Raman - 2/12/91
      */
     vOFN.lpstrFilter	    = (LPSTR)vszFilterSpec;
     vOFN.lpstrCustomFilter = (LPSTR)vszCustFilterSpec;
     vOFN.lpstrDefExt 	    = vszFileExtension + 1;   /* point to "CAL" */

     if ( GetOpenFileName ((LPOPENFILENAME)&vOFN))
     {
	 /* set the read-only flag depending on the state of Flags field */
	 vfOpenFileReadOnly = (vOFN.Flags & OFN_READONLY ? TRUE : FALSE);
	 hFile [IDFILEORIGINAL] = MOpenFile ( vOFN.lpstrFile,
					     (LPOFSTRUCT)&OFStruct [IDFILEORIGINAL],
					     OF_PROMPT+OF_CANCEL);
	 LoadCal ();
     }

     /* GetOpenFilename doesn't return if the supplied filename is bad */
}


/**** LoadCal ****/

VOID APIENTRY LoadCal ()
     {
     INT i;
     INT FileHandle;
     BYTE bkBuf [CBBK];
     BOOL fOk;
     UINT cb;
     INT  cdd;
     DD * pdd;
     D3   d3First;
     BOOL fLoadToday = TRUE;  /* Intilaise it; Fix for a Bug by SANKAR */
     CHAR szNewFileSpec [CCHFILESPECMAX];
     //- Save Header: Need temporary 16 bit buffer.
     WORD wTemp;

     /* Show the hour glass cursor. */
     HourGlassOn ();

     /* Start with a clean slate.  Note that if the load fails, we will
        end up in untitled mode, and this is OK since even if there is
        another file open, it has either been saved or the user said not
        to save the changes.  In other words, the user has said it is
        Ok to switch to another file, so there is no reason to be concerned
        about what happens to the current file if the new file can't be
        loaded.
     */
     CleanSlate(FALSE);

     if ((FileHandle = hFile[IDFILEORIGINAL]) == -1)
		goto loadfin;

     /* try opening file in READWRITE mode. If it fails, try opening it
	in READ mode. If it works the file must have been marked read only
	Set vfOpenFileReadOnly so that Calendar knows about this and does
	not attempt to save in the end */

     /* the file must be closed before a BLOCKWRITE call can successfully
        be executed.  The call to FCloseFile() was moved from inside the
        following if conditional to in front of it.  1 Sept 1989 clarkc */

     FCloseFile (IDFILEORIGINAL);
     lstrcpy((LPSTR)szNewFileSpec, (LPSTR)OFStruct[IDFILEORIGINAL].szPathName);

// on win32, don't do the OemToAnsi -- ianja
//     OemToAnsi((LPSTR)OFStruct[IDFILEORIGINAL].szPathName, (LPSTR)szNewFileSpec);


     if((FileHandle = MOpenFile (szNewFileSpec,
		       (OFSTRUCT FAR *)&OFStruct[IDFILEORIGINAL],
                        OF_READWRITE|BLOCKWRITE))== -1)
         {
         FileHandle = MOpenFile (szNewFileSpec,
		       (OFSTRUCT FAR *)&OFStruct[IDFILEORIGINAL],
		       OF_READ);
	 vfOpenFileReadOnly = TRUE;
         }
     /*
      *  The opened file's handle must be stored sothat the file will get
      *  closed when FCloseFile() is called latter in this function;
      * Otherwise the file handle in hFile[] will be -1 and the file will
      * remain open cause "sharing violations" when run under SHARE.EXE.
      * Fix for Bugs #5135, #5305 and #1848  --SANKAR-- 10-13-89
      */
     hFile[IDFILEORIGINAL] = FileHandle;

     if (!(fOk = M_llseek (FileHandle, (LONG)0, 0) != -1
            && _lread (FileHandle, bkBuf, CBBK) == CBBK))
        goto error1;


     /* Check the magic number. */

       for (i = 6; i < CBMAGIC; i++)
	  {
	  if (bkBuf [i] != vrgbMagic [i])
	       {
               /* File is open so this must be system modal. */
		AlertBox (vszNotCalFile, (CHAR *)NULL,
                MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION);
               goto error0;
               }
	  }

     /* Try to make the tdd large enough to hold the DDs from the file.
        Note that if successful, FGrowTdd will set vcddUsed to cdd since
        CleanSlate had set it to 0 by calling InitTdd.
     */
     BltByte ((BYTE *)(bkBuf + OBCDD), (BYTE *)&wTemp, CBCDD);
     cdd = (INT)wTemp;
     if (!FGrowTdd (0, cdd))
          {
          /* Couldn't grow the tdd.  The error message has already been
             displayed by FGrowTdd.
          */
          goto error0;
          }

     /* Set up the rest of the items from the header. */
     //- Get Header: Store the values in temporary 16-bit buffer.
     BltByte ((BYTE *)(bkBuf + OBMINEARLYRING),(BYTE *)&wTemp,  CBMINEARLYRING);
     vcMinEarlyRing = (INT)wTemp;

     BltByte ((BYTE *)(bkBuf + OBFSOUND),      (BYTE *)&wTemp, CBFSOUND);
     vfSound = (INT)wTemp;

     BltByte ((BYTE *)(bkBuf + OBMDINTERVAL),  (BYTE *)&wTemp, CBMDINTERVAL);
     vmdInterval = (INT)wTemp;

     BltByte ((BYTE *)(bkBuf + OBMININTERVAL), (BYTE *)&wTemp, CBMININTERVAL);
     vcMinInterval = (INT)wTemp;

     BltByte ((BYTE *)(bkBuf + OBFHOUR24),     (BYTE *)&wTemp, CBFHOUR24);
     vfHour24 = (INT)wTemp;

     BltByte ((BYTE *)(bkBuf + OBTMSTART),     (BYTE *)&vtmStart, CBTMSTART);

     /* Set format of time display according to vfHour24 */
     InitTimeDate(vhInstance, vfHour24 ? GTS_24HOUR : GTS_12HOUR);

     /* Read in the tdd, and close the file.  Ignore errors on close
        (very unlikely) because if the data has been successfully read
        there is no reason to give up now.  If there's a real problem
        we should find out about it when we try to read dates from the
        file later on.
     */
     cb = cdd * sizeof (DD);
     fOk = _lread (FileHandle, TddLock (), cb) == cb;
     TddUnlock ();
     FCloseFile (IDFILEORIGINAL);

     if (!fOk)
          goto error2;

     /* if can't load today, goto first record in file. 27-Oct-1987. davidhab */
     fLoadToday = TRUE;
     if (!FGetDateDr (vftCur.dt))
        {
        fLoadToday = FALSE;
        pdd = TddLock();

        if (!FGetDateDr(pdd->dt))
            {
            TddUnlock();
            goto error2;
            }

        GetD3FromDt(pdd->dt, &d3First);
        TddUnlock();
        }

     /* Arm the first alarm >= the current time.
        Also see if the first alarm must go off immediately.
      */
     GetNextAlarm (&vftCur, &vftCur, TRUE, (HWND)NULL);
     AlarmCheck ();

     /* The load went Ok - make this the open calendar file. */
     SetTitle ((CHAR *)OFStruct [IDFILEORIGINAL].szPathName);

loadfin:
     /* Go into day mode for today.  Set the selected month to an
        impossible one - this will cause SwitchToDate (called by
        DayMode) to call SetUpMonth.  Note that the SwitchToDate call
        cannot fail since we have already read in the data for today
        if there is any.
      */
     vd3Sel.wMonth = MONTHDEC + 1;
     if (fLoadToday)
         DayMode (&vd3Cur);
     else
         DayMode (&d3First);

     /* The waiting is over. */
     HourGlassOff ();
     return;



error2:   /* Error occurred while attempting to read the tdd or the data
             for today.
          */
     /* Get rid of the partially loaded garbage. */
     CleanSlate (FALSE);


error1:   /* Error occurred attempting to read the header - nothing
             has been changed, so no need to call CleanSlate again.
          */
     /* Error attempting to read file.  File is still open, so this
        alert must be system modal.
     */
     MessageBeep(0);

     AlertBox (vszCannotReadFile, (CHAR *)NULL,
      MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION);

error0:   /* Not a calendar file, or couldn't make tdd big enough.  The
             error message has already been displayed so the only thing
             we must do is close the file.  It's OK for other cases
             (where the file has already been closed) to come through
             here since FCloseFile properly handles an already closed file.
          */
     /* Make sure the file is closed. */
     FCloseFile (IDFILEORIGINAL);

     goto loadfin;
     }

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
CHAR * APIENTRY PFileInPath(register CHAR *sz)
    {
    register CHAR *pch;

    /* Strip path/drive specification from name if there is one */
    pch = (CHAR *)AnsiPrev((LPSTR)sz, (LPSTR)(sz + lstrlen((LPSTR)sz)));
    while (pch > sz)
        {
	pch = (CHAR *)AnsiPrev((LPSTR)sz, (LPSTR)pch);
        if (*pch == '\\' || *pch == ':')
            {
	    pch = (CHAR *)AnsiNext((LPSTR)pch);
	    break;
            }
        }
    return(pch);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calfile.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 ****** calfile.c
 *
 */

#include "cal.h"


/**** CreateChangeFile *****/
VOID APIENTRY CreateChangeFile ()
     {
     /* If there is already a change file, delete it, ignoring any errors
        since we will be creating a new one, and that's the important one.
     */
     DeleteChangeFile ();

     /* Set the end-of-data of the change file to block 0. */
     vobkEODChange = 0;

     /* By passing the drive letter as 0 we tell GetTempFileName
        to decide where to put the temp file.
     */
     if (!(vfChangeFile = FCreateTempFile (IDFILECHANGE, 0)))
          {
          /* Post error saying edits will not be recorded. */
		  OutputDebugString ("Message Box Is Broken\n");

          //AlertBox (vszNoCreateChangeFile, (CHAR *)NULL,
           //MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
          }
     }




/**** DeleteChangeFile - delete the change file if there is one. ****/
VOID APIENTRY DeleteChangeFile ()
     {
     if (vfChangeFile)
          {
          /* Ignore errors since callers don't care about them. */
          vfChangeFile = FALSE;
          FDeleteFile (IDFILECHANGE);
          }
     }




/**** FCreateTempFile ****/

BOOL APIENTRY FCreateTempFile (
     INT  idFile,
     INT  iDrive)        /* 0 means let GetTempFileName decide where to put
                            the temp file.
                            Otherwise, this is the drive letter, and it should
                            also have the TF_FORCEDRIVE bit set to make sure that
                            the temp file is created on the specified drive.
                          */
{
    CHAR szFileSpec [CCHFILESPECMAX];
    INT  FileHandle;

	/* Create a temp file with a unique name.
	 * 0 for the third parameter means GetTempFileName should
	 * produce a unique file name and create the file.
	 * GetTempFileName returns the random number it used, which Steve Wood
	 * guarantees is 0 iff the call fails (he does not allow the random
	 * number to be 0).  If the file is created OK by GetTempFileName,
	 * open it to set up the reopen buffer.
	 */
	if (MGetTempFileName ((BYTE)iDrive, "CAL", 0, szFileSpec) == 0)
	{
		return (FALSE);
	}

	if ((FileHandle = MOpenFile (szFileSpec, &OFStruct [idFile],
			OF_READWRITE )) != -1)
	{
		/* File is OK.  Close it, and return TRUE. */
		M_lclose (FileHandle);
		return (TRUE);
	}

	/* GetTempFileName failed or OpenFile failed. */
	return (FALSE);

}


/**** FFreeUpDr - Free up the specified DR. ****/

BOOL APIENTRY FFreeUpDr (
     DR   *pdr,          /* Pointer to the DR to be written out. */
     DL   *pdl)          /* OUTPUT - DL indicating where the occupant was put. */
     {
     DL   dlNew;

     if (!pdr -> fDirty)
          {
          /* It's not dirty so don't change the date's location. */
          *pdl = DLNOCHANGE;
          return (TRUE);
          }

     /* The DR is dirty.  However, it may be empty, in which case
        we tell the caller it is not on disk.
     */
     if (pdr -> cbNotes + pdr -> cbTqr == 0)
          {
          *pdl = DLNIL;
          return (TRUE);
          }

     /* It's not empty. */
     if (!vfChangeFile)
          {
          /* Tell the user that the edits are not being recorded.
             We already warned the turkey when we couldn't create
             the change file, but he didn't listen.  Now just
             throw away his edits.
          */
          AlertBox (vszNoChangeFile,
           (CHAR *)NULL, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
          *pdl = DLNOCHANGE;
          return (TRUE);
          }

     /* Set up the new DL using vobkEODChange before FWriteDrToFile
        changes it.
     */
     dlNew = DLFCHANGEFILEMASK | vobkEODChange;
     if (FWriteDrToFile (TRUE, IDFILECHANGE, pdr))
          {
          /* The write was successful - tell the caller about the
             new DL.
          */
          *pdl = dlNew;
          return (TRUE);
          }
     else
          {
          /* An error occured while attempting to write the date. */
          AlertBox (vszErrorWritingChanges, (CHAR *)NULL,
           MB_APPLMODAL | MB_OK | MB_ICONHAND);
          return (FALSE);
          }
     }




/**** FWriteDrToFile *****/
BOOL APIENTRY FWriteDrToFile (
     BOOL fOpenClose,    /* If TRUE, the file must be opened and then closed.
                            If FALSE, the file is already open and should be
                            left open.
                          */
     INT  idFile,        /* Which file to write to. */
     DR   *pdr)          /* Which DR to write from. */
     {
     INT  *pobkEOD;
     INT  cbkTransfer;
     INT  cbTransfer;
     INT  FileHandle;
     BOOL fOk;

     /* Set up a pointer to the appropriate EOD. */
     pobkEOD = &vobkEODNew;

     if (idFile == IDFILECHANGE)
          pobkEOD = &vobkEODChange;

     /* Try to reopen the file. */
     if (!fOpenClose || FReopenFile (idFile, OF_PROMPT | OF_CANCEL | OF_REOPEN | OF_READWRITE))
          {
          /* Make a local copy of the file handle to save code below. */
          FileHandle = hFile [idFile];

          /* Calculate the minimum number of BKs we must
             write out.  Do this by taking the count of
             bytes in use in the DR and adding the count
             of bytes in a BK minus 1 in order to round up
             to the next BK.  Then divide by the count
             of bytes in a BK to get the number of BKs
             to be written.
           */
          cbkTransfer = (pdr -> cbNotes + pdr -> cbTqr
           + CBDRHEAD + CBBK - 1) / CBBK;

          /* Clear the reserved word. */
          pdr -> wReserved = 0;

          /* Seek to the current end of data, write the
             current DR, and close the file.
          */
          cbTransfer = CBBK * cbkTransfer;
          fOk = M_llseek (FileHandle, (LONG)(CBBK*(*pobkEOD)), 0) != -1
                       && FWriteFile (FileHandle, (BYTE *)pdr, cbTransfer);

          if (FCondClose (fOpenClose, idFile) && fOk)
               {
               /* The DR has been successfully written to the file.
                  Update the EOD of the file.
               */
               *pobkEOD += cbkTransfer;
               return (TRUE);
               }
          }

     return (FALSE);

     }




/**** FReadDrFromFile ****/

BOOL APIENTRY FReadDrFromFile (
     BOOL fOpenClose,      /* If TRUE, the file must be opened and then closed.
                              If FALSE, the file is already open and should be
                              left open.
                              */
     DR   *pdr,               /* Where to read it into. */
     DL   dl)                 /* File location of date. */
     {
     INT  idFile;
     INT  FileHandle;
     WORD cbData;
     OBK  obk;
     BOOL fOk;

     /* Assume we will be reading from the original file. */
     idFile = IDFILEORIGINAL;

     /* Separate the block offset, and switch to the change file if the
        change file flag is set in the DL.
     */
     obk = dl & DLOBKMASK;
     if (dl & DLFCHANGEFILEMASK)
          idFile = IDFILECHANGE;

     /* Try to reopen the file. */
     if (fOpenClose && !FReopenFile (idFile, OF_PROMPT | OF_CANCEL | OF_REOPEN
                                     | OF_READ))
          return (FALSE);



     /* Reopen was successful - seek to the beginning of the DR, and
        read its header in order to know how much data there is.
      */

     FileHandle = hFile [idFile];
     if (M_llseek (FileHandle, (LONG)(CBBK * obk), 0) == -1
              || M_lread (FileHandle, (LPSTR)pdr, CBDRHEAD) != CBDRHEAD)
     {
          FCondClose (fOpenClose, idFile);
          return (FALSE);
     }

     /* Header was successfully read.  Now read in the rest. */
     cbData = pdr -> cbNotes + pdr -> cbTqr;
     fOk = (WORD)M_lread (FileHandle, (LPSTR)pdr + CBDRHEAD, cbData) == cbData;

     /* Close the file. */
     return (FCondClose (fOpenClose, idFile) && fOk);
     }




/**** FGetDateDr ****/

BOOL APIENTRY FGetDateDr (DT dtTarget)
     {
     DR   *pdr;
     INT  itdd;
     DD   *pdd;
     DL   dlTarget;
     WORD  idrTarget;
     WORD  idrNew;
     WORD  idrKickOut;
     DL   dlKickOut;
     DT   dtKickOut;
     HWND hwndFocus;

     /* If this routine succeeds in getting the requested date, the
        focus is left NULL.  If it fails, the focus is set back to its
        previous window.  Remember who has the focus now, then set it
        NULL to record the current edits into the current date. This MUST be
        done before switching dates so the data goes into the correct
        date.  It's important to leave the focus NULL in the success case
        so that the data doesn't get recorded again (into the wrong date)
        when the caller changes the focus later.
     */
     hwndFocus = GetFocus ();
     CalSetFocus ((HWND)NULL);

     /* See if this date is already in the tdd. */
     if (!FSearchTdd (dtTarget, &itdd))
          {
          /* Not found, try to insert it. */
          if (!FGrowTdd (itdd, 1))
               {
               /* Cannot grow tdd to include the new date.  FGrowTdd has
                  already put up the error message.
               */
               CalSetFocus (hwndFocus);
               return (FALSE);
               }

          /* Put the date into the new entry, say it is not marked,
             it has no alarms, it's not on disk, and it's not in memory.
          */
          pdd = TddLock () + itdd;
          pdd -> dt = dtTarget;
          pdd -> fMarked = FALSE;
          pdd -> cAlarms = 0;
          pdd -> dl = DLNIL;
          pdd -> idr = IDRNIL;
          TddUnlock ();
          }

     /* At this point itdd is the index of the target date
        within the tdd.  See if the target date is already in memory.
     */
     dlTarget = (pdd = TddLock () + itdd) -> dl;
     idrTarget = pdd -> idr;
     TddUnlock ();
     if ((WORD)idrTarget != IDRNIL)
          {
          /* The target date is already in memory.  Make the DR it
             is stored in the current DR, and return TRUE.
          */
          vidrCur = idrTarget;
          return (TRUE);
          }

     /* Find a free DR to put the target date in.  */
     idrNew = IdrFree ();

     /* In order to comply with the rule that there is always one
        free DR, we have to kick out a date if the 2 DRs other
        than idrNew are both in use.  Here's how we decide which, if
        any, date must be kicked out of memory:
        - Look at each DR:
          - If it's idrNew, or it's in use for today, skip it.
        So we end up either kicking nothing out (if we find a second
        free DR), or kicking out a date that's not today.
        Since the same date can't be in two DRs
        at the same time, we know that we will either find another
        free DR or one that contains a date other than today, so this
        loop will terminate.
        Note - 9/2/85 - MLC - I originally kept today in memory at all
        times because in month mode I always displayed the notes for
        today, regardless of which day was selected.  Some time ago I
        changed month mode so it shows the notes for the selected date.
        I decided to still keep today around since I assume the user
        will be refering to it more than any other date, so it seemed
        better than just keeping the two most recently accessed dates
        around.
     */
     idrKickOut = CDR;
     do
          {
          idrKickOut--;
          dtKickOut = PdrLock (idrKickOut) -> dt;
          DrUnlock (idrKickOut);
          }
     while (idrKickOut == idrNew || dtKickOut == vftCur.dt);

     if (dtKickOut != DTNIL)
          {
          /* We must kick out a date to free up a DR. */
          pdr = PdrLock (idrKickOut);
          if (!FFreeUpDr (pdr, &dlKickOut))
               {
               /* If we just created the DD for the target date,
                  it is still empty, so we will get rid of it if so.
               */
               DrUnlock (idrKickOut);
               DeleteEmptyDd (itdd);
               CalSetFocus (hwndFocus);
               return (FALSE);
               }
          pdr -> fDirty = FALSE;
          DrUnlock (idrKickOut);
          }

     pdr = PdrLock (idrNew);
     if (dlTarget == DLNIL)
          {
          /* No previous data for this date so create an empty DR for it. */
          pdr -> cbNotes = pdr -> cbTqr = 0;
          }
     else
          {
          if (!FReadDrFromFile (TRUE, pdr, dlTarget))
               {
               /* Mark the DR as still not in use. */
               pdr -> dt = DTNIL;
               DrUnlock (idrNew);

               /* If we just created the DD for the target date,
                  it is still empty, so we will get rid of it if so.
               */
               DeleteEmptyDd (itdd);
               CalSetFocus (hwndFocus);
               return (FALSE);
               }
          }

     /* Could be here if no previous data or
        where date was successfully read from file.
        Therefore, set the dt, since in the first case it has not
        been set.
     */
     pdr -> dt = dtTarget;
     pdr -> fDirty = FALSE;
     DrUnlock (idrNew);
     (TddLock () + itdd) -> idr = idrNew;
     TddUnlock ();

     if (dtKickOut != DTNIL)
          {
          /* We kicked out a date.  Mark that DR free. */
          PdrLock (idrKickOut) -> dt = DTNIL;
          DrUnlock (idrKickOut);

          /* Search for the DD of the date we kicked out.  It's OK to
             ignore the return value of FSearchTdd since the date we
             kicked out must be in the tdd.
          */
          FSearchTdd (dtKickOut, &itdd);

          /* Say the kicked out date is no longer in memory, and change
             the DL if the date's location has changed.
          */
          (pdd = TddLock () + itdd) -> idr = IDRNIL;
          if (dlKickOut != DLNOCHANGE)
               pdd -> dl = dlKickOut;
          TddUnlock ();

          /* Get rid of the DD of the kicked out date if it's "empty". */
          DeleteEmptyDd (itdd);
          }

     vidrCur = idrNew;
     return (TRUE);
     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calspecl.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calspecl.c
 *****
*/

#include "cal.h"

/* Notes about special times - 9/13/85 - MLC:

   I want to explain some things about special times because the design
   is not as clean as it should be and can lead to some confusion.
   As I originally planned it, a special time was defined to be an
   appointment time that had been inserted with the Options Special Time
   Insert command.  An appointment time inserted this way had the fSpecial
   bit set in its associated QR.  This is still the case, but from the
   user's point of view the definition of a special time is different.
   The problem was that user confusion could result from the original
   definition.  For example, suppose that with the interval set to 15
   minutes, the user types text into a 9:15 appointment.  At some
   point he switches the interval to 60 minutes.  The 9:15 appointment
   is still present because it has data associated with it, and given
   the 60 minute interval, it sure looks like a special time to the
   user (particularly if he is looking at it days later and doesn't
   remember that it was inserted when he had the interval set to 15
   minutes).  He tries to deleted it with the Options Special Time
   Delete command, but since its fSpecial bit is not set, he is
   told that it is not a special time, which totally confuses him,
   and he sues Tandy Trower.  The only way to get rid of the 9:15
   appointment is to make it "empty" (no text, no alarm).
   So to avoid user confusion I ended up saying that for purposes
   of the Options Special Time Delete command, a special time is
   any time that does not fall on a regular interval given the
   current interval setting.
   The fSpecial bit now serves only one semi-rediculous purpose:
   With the interval set to 60, the user inserts the special time
   of 10:30.  He types no text into that time, and there is no
   alarm set.  He switches to 30 minute interval, and then back
   to 60 minute interval.  Were it not for the fSpecial bit, the
   appointment would have disappeared because in 30 minute mode
   it would not look like a special time.  But the fSpecial bit
   keeps the appointment from going away.
   I now consider the whole business of the fSpecial
   bit to be unnecessary baggage, and I am tempted to get rid of it.
   I am short on time, and it's not really worth making such a change
   at this late stage, so I won't, but if I had it to do
   over, I would not have the fSpecial bit.
   My apologies in advance to anyone who has to work on special times -
   I hope this explanation helps.
*/


/**** InsertSpecial - insert a special time. */

VOID APIENTRY InsertSpecial ()

     {

     QR   qrNew;

     /* Record the current edits and prevent them from later using an
        invalid tld (which we are about to invalidate by fooling around
        with the tqr).
     */
     CalSetFocus ((HWND)NULL);

     /* Insert a new QR for the special time with the special time bit set.
        The special time bit prevents keeps the QR in the tqr even though
        it has no appointment text and the alarm is not set.
        Note that FSearchTqr was called by the Special Time dialog so
        votqrNext is already set up.
     */
     qrNew.cb = CBQRHEAD + 1;
     qrNew.fAlarm = FALSE;
     qrNew.fSpecial = TRUE;
     qrNew.tm = vtmSpecial;
     qrNew.qd [0] = '\0';

     if (FInsertQr (votqrNext, &qrNew))
          {
          /* Adjust up the scroll bar range. */
          AdjustDayScrollRange (1);

          /* Fix up the display. */
          SpecialTimeFin ();
          }
     }


/**** DeleteSpecial - delete a special time. */

VOID APIENTRY DeleteSpecial ()

     {

     register BOOL fAlarm;
     register DR   *pdr;
     INT  itdd;
     FT   ftTemp;

     /* Note that FSearchTqr was
        called by the special time dialog code, and the result was
        TRUE.  Therefore, votqrCur has been set up.
     */

     /* Record the current edits and prevent them from later using an
        invalid tld (which we are about to invalidate by fooling around
        with the tqr).
     */
     CalSetFocus ((HWND)NULL);

     /* Before deleting the QR, see if it had an alarm. */
     fAlarm = ((PQR )(PbTqrFromPdr (pdr = PdrLockCur ()) + votqrCur))
      -> fAlarm;
     ftTemp.dt = pdr -> dt;
     DrUnlockCur ();

     /* Delete the QR for the special time. */
     DeleteQr (votqrCur);

     if (fAlarm)
          {
          /* There is an alarm for the special time we're deleting.
             Decrement the count of alarms for this date.
          */
          FSearchTdd (ftTemp.dt, &itdd);
          (TddLock () + itdd) -> cAlarms--;
          TddUnlock ();

          ftTemp.tm = vtmSpecial;
          if (CompareFt (&ftTemp, &vftAlarmNext) == 0)
               {
               /* Cancelling the next armed alarm.  Need to arm the one
                  after it.  Since the one we are cancelling has not yet
                  gone off, it can't be time for the one after it to
                  go off either, so there is no need to call AlarmCheck -
                  just let it go off naturally.
                  Note this be done AFTER the QR has been deleted and
                  the count has been decremented so
                  GetNextAlarm doesn't find the same alarm again.
               */
               GetNextAlarm (&vftCur, &vftCur, TRUE, (HWND)NULL);
               }
          }

     /* Adjust down the range of the scroll bar. */
     AdjustDayScrollRange (-1);

     /* Fix up the display. */
     SpecialTimeFin ();

     }


/**** SpecialTimeFin */

VOID APIENTRY SpecialTimeFin ()

     {

     register INT ln;

     /* Mark the DR and the file as dirty. */
     PdrLockCur () -> fDirty = vfDirty = TRUE;
     DrUnlockCur ();

     /* Fill the tld, using the special time as the starting time.
        In the insert case, FillTld will use the new special time.
        In the delete case, FillTld will use the first appointment
        time greater than the special time that was just deleted.
     */
     FillTld (vtmSpecial);

     /* Find the ln of the new special time (insert) or of the appointment
        time following the old special time (delete).  It's not
        necessarily on the top line since there may not have been
        enough appointment times following it to fill up the screen.
     */
     for (ln = 0; ln < vlnLast && vtld [ln].tm < vtmSpecial; ln++)
          ;

     /* Give it the focus.  (Need to set vhwndFocus before calling
        SetQdEc because we want the focus to go to the appointment
        even if it's currently in the notes area.
     */
     vhwndFocus = vhwnd3;
     SetQdEc (ln);

     /* Set the thumb, and repaint the appointments. */
     SetDayScrollPos (-1);
     InvalidateRect (vhwnd2B, (LPRECT)NULL, TRUE);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calprint.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/


/*
 *****
 ***** calprint.c
 *****
*/

#include "cal.h"
#include <string.h>
#include <ctype.h>
#include <time.h>

int TranslateString(CHAR *);
CHAR * APIENTRY PFileInPath(CHAR *sz);
VOID   APIENTRY DestroyAbortWnd(VOID);

/* We'll dynamically allocate this */
HANDLE   hHeadFoot=NULL;
LPSTR    szHeadFoot;
SHORT    xCharPage, dyHeadFoot;
int      dyTop,dyBottom,dxLeft ,dxRight;
int      CharPrintWidth, CharPrintHeight;
HDC      vhDCPrint;
BOOL     vfAbortPrint;
HWND     vhwndAbortPrint;

INT      vcyPrintLineToLine;
INT      xPrintRes, yPrintRes, xPixInch, yPixInch;
INT      hChars;
INT      vclnPage;
INT      nSpace;
INT      vclnPrinted;
INT      vclnDate;
INT      vlnFooter;         /* footer line */
INT      vlnBottom;         /* last line of calendar text */
INT      vlnTop;            /* first line of calendar text */
BOOL     vfPrint;
CHAR     szCurDateBuf[9];   /* buffer containing date string for header/footer */
CHAR     *szcurDptr = szCurDateBuf;
INT      iCurDateLength ;
DOSDATE  CurDD;

CHAR     *vpchPrintBuf;

#define CLNHEADING 1
#define CLNAFTERHEADING 1
#define CLNAFTERAPPOINTMENTS 1
#define CLNBETWEENDATES 2

/* 1 - blank or asterisk for alarm
   1 - blank
   CCHTIMESZ - appointment time (includes 0 terminator, which is used
    to hold a blank here)
   CCHQDMAX - room for a maximum length appointment description
   1 - room for the 0 terminator

   The print buffer is also used for outputting the heading, so it
   must be long enough for that too.  To make sure this is the case,
   add in CCHDATEDISP.
*/

#define CCHPRINTBUF (1 + 1 + CCHTIMESZ + CCHQDMAX + 1 + CCHDATEDISP)



/* Format of a printed date:
   if not at top of page, CLNBETWEENDATES blank lines
   Heading (e.g., Thursday, July 11, 1985)
   CLNAFTERHEADING blank lines
   Appointments (e.g., * 10:00 Call Tandy to report progress (asterisk
    indicates alarm set)
   CLNAFTERAPPOINTMENTS blank lines
   notes
 */




/**** FnPrint ****/

INT_PTR CALLBACK FnPrint (
     HWND hwnd,
     UINT message,
     WPARAM wParam,
     LPARAM lParam)
     {
     CHAR szFromDate [CCHDASHDATE];

     switch (message)
	  {
	  case WM_INITDIALOG:
	       /* Remember the window handle of the dialog for AlertBox. */
	       vhwndDialog = hwnd;

               GetDashDateSel (szFromDate);
	       SetDlgItemText (hwnd, IDCN_FROMDATE, szFromDate);
	       return (TRUE);

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
		    case IDOK:
			 GetRangeOfDates (hwnd);
			 /* line added to fix keyboard hanging when Calendar
			    is run under ver3.0 rel 1.11 */
			 CalSetFocus (GetDlgItem(hwnd, IDCN_FROMDATE));
			 break;

		    case IDCANCEL:
			 EndDialog (hwnd, FALSE);
			 break;
		    }

	       return (TRUE);
	  }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }




/**** Print */

VOID FAR APIENTRY Print ()
     {
     TEXTMETRIC     Metrics;
     WORD  idrFree;
     INT  itdd;

     DD   *pdd;
     DT   dt;
     DL   dl;
     WORD  idr;
     CHAR rgchPrintBuf [CCHPRINTBUF];
     INT iDateLen;
     INT        iHeight;
     INT        iWidth;

     /* Note - there is no need to force edits to be recorded here.
	We got here after the Print dialog, which took over the focus
	and therefore has recorded the edits.  We are not going to
	modify the current DR, so we do not need to set the focus
	to NULL (as we sometimes do to prevent recording data into
	the wrong DR).
     */


     if (BeginPrint () < 0)
	  {
	  /* Unable to get print DC - display error and give up. */
	  CalPrintAlert(SP_ERROR);
	  return;
	  }

     /* Determine the number of lines per page. */
     GetTextMetrics (vhDCPrint, &Metrics);
     CharPrintHeight = Metrics.tmHeight + Metrics.tmExternalLeading;
     CharPrintWidth = (Metrics.tmAveCharWidth + Metrics.tmMaxCharWidth)/2;             /* character width */

     xPrintRes = GetDeviceCaps(vhDCPrint, HORZRES);
     yPrintRes = GetDeviceCaps(vhDCPrint, VERTRES);
     xPixInch  = GetDeviceCaps(vhDCPrint, LOGPIXELSX);
     yPixInch  = GetDeviceCaps(vhDCPrint, LOGPIXELSY);

     dyHeadFoot = yPixInch / 2;                  /* 1/2 an inch */

     dyTop      = atopix(chPageText[4], yPixInch);
     dyBottom   = atopix(chPageText[5], yPixInch);
     dxLeft     = atopix(chPageText[2], xPixInch);
     dxRight    = atopix(chPageText[3], xPixInch);

/* There's some recalculating here entirely unneeded.  The call to
   GetDeviceCaps for hChars isn't needed since xPrintRes already has
   that value.  CharPrintHeight already has the value desired for
   vcyPrintLineToLine.  (I'd pull one of them out entirely, but that
   requres a lot of code review without the time.)  The call to
   GetDeviceCaps for vlnFooter isn't needed since yPrintRes already
   has that value.                           21 Sept 1989  Clark Cyr */
#if 0
     hChars=GetDeviceCaps(vhDCPrint, HORZRES)/Metrics.tmAveCharWidth;
     vcyPrintLineToLine = Metrics.tmHeight + Metrics.tmExternalLeading;
     vlnFooter = GetDeviceCaps(vhDCPrint, VERTRES) / vcyPrintLineToLine - 1;
#endif
     hChars = xPrintRes / Metrics.tmAveCharWidth;
     vlnFooter = yPrintRes / (vcyPrintLineToLine = CharPrintHeight) - 1;

     MGetTextExtent(vhDCPrint, " ", 1, &iHeight, &iWidth);
     nSpace = iWidth;

     viLeftMarginLen =dxLeft/nSpace;
     viRightMarginLen=dxRight/nSpace;
     viTopMarginLen  =dyTop/vcyPrintLineToLine;
     viBotMarginLen  =dyBottom/vcyPrintLineToLine;

     /* Number of characters between margins */
     xCharPage=(xPrintRes/CharPrintWidth)-viLeftMarginLen-viRightMarginLen;


     /* Allocate memory for the header.footer string.  Will allow any size
      * of paper and still have enough for the string.
      */
     hHeadFoot=GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD)xCharPage+2);

     if (!hHeadFoot)
         {
         /* Tell user that there's not memory to do this... */
         CalPrintAlert(SP_OUTOFMEMORY);
         return;
         }



/* Change 2 to 3.  Leave room for footer itself.  21 Sept 1989 Clark Cyr */
     vclnPage  = vlnFooter - 3;
     vlnTop    = viTopMarginLen;
     vlnBottom = vclnPage - viBotMarginLen;

     CurDD.dayofweek = 0xff;
     CurDD.year =  vd3Cur.wYear + 1980;
     CurDD.month = vd3Cur.wMonth + 1;
     CurDD.day = vd3Cur.wDay + 1;
     iDateLen = GetDateString(&CurDD, szCurDateBuf, GDS_LONG|GDS_DAYOFWEEK);
     *(szcurDptr + iDateLen) = '\0';

     /* Find a free DR in case we need to read from the disk. */
     idrFree = IdrFree ();

     /* Say we are at the top of the page. */
     /* vclnPrinted = 0; */
     /* print out header string */

     viCurrentPage = 1;
     vpchPrintBuf = rgchPrintBuf;
     PrintHeaderFooter(TRUE);

     vclnPrinted = vlnTop;

     for (itdd = vitddFirst; !vfAbortPrint && itdd < vitddMax; itdd++)
	  {
	  pdd = TddLock () + itdd;
	  dt = pdd -> dt;
	  dl = pdd -> dl;
	  idr = pdd -> idr;
	  TddUnlock ();

	  if (idr == IDRNIL)
	       {
	       /* The date is not in memory, see if it's on disk. */
	       if (dl == DLNIL)
		    {
		    /*
		       Not on disk either - this is an empty DD.  Skip
		       over this date.
		    */
		    continue;
		    }

	       /* Read the date from disk into the free DR. */
	       ReadTempDr (idr = idrFree, dl);
	       }

	  /* Calculate how many lines are needed to print this date. */
	  if (!PrintDate (idr, dt, FALSE))
	      return;
	  if (vclnDate == 0)
	       {
	       /* There's nothing to print in this date (must just
		  be special times without alarms or text and no notes).
	       */
	       continue;
	       }

/* Change 0 to vlnTop + 2.   21 Sept 1989   Clark Cyr */
	  if (vclnPrinted > vlnTop + 2)
	       {
	       /* Not at top of page - see if this entire date will fit
		  on the remainder of this page.  If it won't fit, start
		  a new page.
	       */
	       /* print out the footer if bottom of page is reached */

	       if (vclnPrinted + vclnDate > vlnBottom ){

		    PrintHeaderFooter( FALSE );
		    if (!NewPage ())
			return;
		    viCurrentPage++;

		    /* print out the header on top of new page */
		    PrintHeaderFooter( TRUE );
		    vclnPrinted = vlnTop;
	       }
	       }
	  /* Print the schedule for the date. */
	  if (!PrintDate (idr, dt, TRUE))
	      return;
	  }
     /* print out the footer if bottom of page is reached */

    if (vclnPrinted < vlnFooter - 3)
	PrintHeaderFooter(FALSE);

     if (NewPage ())
	 EndPrint ();


     GlobalFree(hHeadFoot);
     hHeadFoot=NULL;
     }



/*
 * convert floating point strings (like 2.75 1.5 2) into number of pixels
 * given the number of pixels per inch
 */

INT atopix(CHAR *ptr, INT pix_per_in)
    {
    CHAR *dot_ptr;
    CHAR sz[20];
    INT decimal;

    lstrcpy(sz, ptr);

    dot_ptr = strchr(sz, szDec[0]);

    if (dot_ptr)
        {
    	*dot_ptr++ = 0;		/* terminate the inches */
        if (*(dot_ptr + 1) == 0)
            {
            *(dot_ptr + 1) = '0';   /* convert decimal part to hundredths */
            *(dot_ptr + 2) = 0;
            }
	decimal = ((INT)atol(dot_ptr) * pix_per_in) / 100;	/* first part */
        }
    else
    	decimal = 0;		/* there is not fraction part */

    return ((INT)atol(sz) * pix_per_in) + decimal;     /* second part */
    }




/**** PrintDate - Print the specified date.  If fPrint == FALSE then
      don't actually print - just set up vclnDate with the number of
      lines required to print the date.
*/

BOOL APIENTRY PrintDate (
     INT      idr,
     DT       dt,
     BOOL     fPrint)
     {
     CHAR     rgchPrintBuf [CCHPRINTBUF];
     CHAR     szTemp[CCHPRINTBUF];
     DR       *pdr;
     register PQR pqr;
     PQR	pqrMax;
     CHAR     *pchTemp;
     register CHAR *pchSrc;
     CHAR     *pchDest;
     CHAR     c;
     BOOL     fSameLine;
     INT      cchTime, i, nx;
     BOOL     fFirstLine;
     BOOL     fFirstPM;

     /* Set up global print flag for routines to be called. */
     vfPrint = fPrint;

     /* Set up a global pointer to the print buffer. */
     vpchPrintBuf = rgchPrintBuf;

     /* Initialize the count of lines required to print this date. */
     vclnDate = 0;

     pdr = PdrLock (idr);
     fFirstLine = TRUE;
     fFirstPM = TRUE;
     for (pqrMax = (PQR)((BYTE UNALIGNED*)(pqr = (PQR)PbTqrFromPdr(pdr)) +
	pdr->cbTqr); pqr<pqrMax; pqr = (PQR)((BYTE UNALIGNED*)pqr + pqr->cb))
	  {
	  /* Don't print special times that don't have an alarm
	     or an appointment description.
	  */
	  if (pqr -> fAlarm || pqr -> cb != CBQRHEAD)
	       {
	       if (!PrintHeading (dt))
		  goto error0;

	       FillBuf (vpchPrintBuf, CCHPRINTBUF, ' ');
	       if (pqr -> fAlarm)
		    *(vpchPrintBuf+viLeftMarginLen) = '*';

	       cchTime = GetTimeSz (pqr -> tm, vpchPrintBuf + viLeftMarginLen + 2);

	       /* Print am/pm strings only for first line printed and noon */
	       if (!(fFirstLine || ((fFirstPM && pqr->tm >= TMNOON))))
		   FillBuf (vpchPrintBuf+viLeftMarginLen+5+2, cchTime-5, ' ');

	       FillBuf (vpchPrintBuf, viLeftMarginLen, ' '); /* pad margin space
							      with blanks */
	       pchTemp = vpchPrintBuf + viLeftMarginLen + cchTime+2;
	       *pchTemp++ = ' ';
	       *pchTemp = '\0';
	       if (pqr -> cb > CBQRHEAD)
		    lstrcpy (pchTemp, (CHAR *)((BYTE *)pqr + CBQRHEAD));


CheckMarg:
               if (lstrlen(vpchPrintBuf) > (hChars-viRightMarginLen))
                   {
                   lstrcpy(szTemp, vpchPrintBuf+hChars-viRightMarginLen);
                   vpchPrintBuf[hChars-viRightMarginLen]=0;

                   if (!PrintLine ())
                       goto error0;

                   /* CHeck for one space at the beginning and strip if needed */
                   nx=0;
                   if (szTemp[0]==' ' && szTemp[1]!=' ')
                       nx=1;

                   /* Note that 11 = strlen[* + Time + AM/PM + Space] */

                   FillBuf (vpchPrintBuf, viLeftMarginLen+11-nx, ' ');
                   vpchPrintBuf[viLeftMarginLen+11-nx]=0;
                   lstrcat(vpchPrintBuf, szTemp);
                   goto CheckMarg;
                   }

	       if (!PrintLine ())
		    goto error0;
	       fFirstLine = FALSE;
	       if (pqr->tm >= TMNOON)
		   fFirstPM = FALSE;
	       }
	  }

     if (pdr -> cbNotes != 0)
	  {
          if (vclnDate != 0)
              {
              if (!PrintBlankLn (CLNAFTERAPPOINTMENTS))
                   goto error0;
              }
          else
              if (!PrintHeading (dt))
                 goto error0;

	  /* The notes are split into lines as follows:
	     '\0' terminates a line and terminates the notes.
	     <CR,LF> is a hard line break (user typed Enter key).
	     <CR,CR,LF> is a soft line break (caused by word wrap).
	     In order to do something reasonable no matter what is seen,
	     this code skips an abitrary number of CRs followed by an
	     arbitrary number of LFs.
	  */
	  pchSrc = (CHAR *)((BYTE *)pdr + CBDRHEAD);
	  while (*pchSrc != '\0')
               {
	       pchDest = rgchPrintBuf;
	       fSameLine = TRUE;

	       i=0;		  /* fill margin space with blanks */
               while (i<viLeftMarginLen)
                  {
		  *pchDest++ = ' ';
		  i++;
                  }

	       while (fSameLine)
                    {
                    c=*pchSrc;
#ifdef DBCS
                    if( IsDBCSLeadByte(*pchSrc) )
                        *pchDest++ = *pchSrc++;
                    *pchDest++ = *pchSrc++;
#else
                    *pchDest++ = *pchSrc++;
#endif

                    if (c=='\r')
                        {
                        /* Eat multiple CRs if present. */
                        while (*pchSrc == '\r')
                             pchSrc++;

                        /* Eat line feeds following carriage return if
                           there are any.
                        */
                        while (*pchSrc == '\n')
                             *pchSrc++;
                        /* Terminate the line. */
                        *(pchDest - 1) = 0;

                        fSameLine = FALSE;
                        }
                    else
                        {
                        if (c=='\0')
                            {
                            /* Backup to point to the 0 so the outer
                               loop terminates. */
                            pchSrc--;
                            fSameLine = FALSE;
                            }
                        }

                    i++;
                    if ( i >= (hChars - viRightMarginLen))
                        fSameLine = FALSE;
		    }

               while (*(vpchPrintBuf+viLeftMarginLen)==' ')
                    vpchPrintBuf++;

	       if (!PrintLine ())
                    goto error0;

               vpchPrintBuf=rgchPrintBuf;
	       }
	  }
     DrUnlock (idr);
     return TRUE;
error0:
     DrUnlock(idr);
     return FALSE;
     }




/**** PrintHeading - print the heading if it hasn't been printed yet. */

BOOL APIENTRY PrintHeading (DT dt)
     {
     D3   d3;
     if (vclnDate == 0)
	  {
	  /* The heading has not yet been printed - print it out
	     now since we now know that the date is not empty.
	  */

	  /* First put out the lines between dates if this date is
	     not being printed at the top of a page.
	  */
	  vclnPrinted++;
	  /* Convert the date into an ASCII string. */
	  GetD3FromDt (dt, &d3);

	  FillBuf (vpchPrintBuf, viLeftMarginLen, ' '); /* pad margin space
							   with blanks */
	  GetDateDisp (&d3, vpchPrintBuf + viLeftMarginLen);

	  if (!PrintLine ())
		return FALSE;
	  if (!PrintBlankLn (CLNAFTERHEADING))
		return FALSE;
	  }

     return TRUE;
     }




/**** PrintBlankLn */

INT  APIENTRY PrintBlankLn (INT cln)
     {
     *vpchPrintBuf = '\0';
     while (cln--)
         if (!PrintLine ())
             return FALSE;

     return TRUE;
     }




/**** PrintLine */

BOOL APIENTRY PrintLine ()
     {
     if (vfPrint)
	  {
	  /* print footer if bottom of page is reached */

          if (vclnPrinted >= vclnPage)
                {
		PrintHeaderFooter(FALSE);
		if (!NewPage ())
		    return FALSE;
		viCurrentPage++;
		PrintHeaderFooter(TRUE);     /* print header */
		vclnPrinted = vlnTop;
              }

	  TextOut (vhDCPrint, 0, vclnPrinted * vcyPrintLineToLine,
		   vpchPrintBuf,  lstrlen (vpchPrintBuf));
	  vclnPrinted++;
	  }

     vclnDate++;
     return TRUE;

     }

/****************************************************************************
 *
 *  BOOL PASCAL PrintHeaderFooter ( hdr )
 *
 *  function : generates and formats the header/footer strings and copies
 *	       them to the print buffer
 *
 *  params   : IN hdr : boolean indicating if header(TRUE) or footer(FALSE)
 *			is to be generated
 *
 *  called by: Print(), PrintLine()
 *
 *  returns  : none
 *
 ***************************************************************************/

BOOL APIENTRY PrintHeaderFooter(BOOL bHeader)
    {
    CHAR    buf[80];
    int     len;

    /* 1-bHeader gives 0 for header, 1 for footer. */
    lstrcpy(buf, chPageText[1-bHeader]);

    szHeadFoot=GlobalLock(hHeadFoot);
    len=TranslateString(buf);

    if (*szHeadFoot)
        {
        if (bHeader)
            TextOut(vhDCPrint, dxLeft, dyHeadFoot - CharPrintHeight, szHeadFoot, len);
        else
            TextOut(vhDCPrint, dxLeft, yPrintRes-CharPrintHeight-dyHeadFoot, szHeadFoot, len);
        }
    GlobalUnlock(hHeadFoot);
    return TRUE;
    }


/***************************************************************************
 * int TranslateString(char *src)
 *
 * purpose:
 *	translate a header/footer strings
 *
 * 	supports the following:
 *
 *	&&	insert a & char
 *	&f	current file name or (untitiled)
 *	&d	date in Day Month Year
 *	&t	time
 *	&p	page number
 *	&p+num	set first page number to num
 *
 * params:
 *	IN/OUT	src	this is the string to translate, gets filled with
 *			translate string.  limited by len chars
 *	IN	len	# chars src pts to
 *
 * used by:
 *	Header Footer stuff
 *
 * uses:
 *	lots of c lib stuff
 *
 * restrictions:
 * 	this function uses the following global data
 *
 *	iPageNum
 *	text from main window caption
 *
 ***************************************************************************/

int TranslateString(CHAR *src)
    {
    CHAR         letters[15];
    CHAR         chBuff[3][80], buf[80];
    CHAR         *ptr, *dst=buf, *save_src=src;
    INT          page;
    int          nAlign=1, foo, nx,
                 nIndex[3];
    struct tm    *newtime;
    time_t       long_time;

    nIndex[0]=0;
    nIndex[1]=0;
    nIndex[2]=0;

    /* Get the time we need in case we use &t. */
    time(&long_time);
    newtime=localtime(&long_time);

    LoadString(vhInstance, IDS_LETTERS, letters, 15);

    while (*src)   /* look at all of source */
        {
        while (*src && *src != '&')
            {
            chBuff[nAlign][nIndex[nAlign]]=*src++;
            nIndex[nAlign] += 1;
            }

        if (*src == '&')   /* is it the escape char? */
            {
            src++;

            if (*src == letters[0] || *src == letters[1])
                {                      /* &f file name (no path) */

                    /* a bit of sleez... get the caption from
                     * the main window.  search for the '-' and
                     * look two chars beyond, there is the
                     * file name or (untitiled) (cute hu?)
                     */

                    GetWindowText(vhwnd0, buf, 80);
                    ptr=strchr(buf, '-') + 2;

                    /* Copy to the currently aligned string. */
                    lstrcpy((chBuff[nAlign]+nIndex[nAlign]), ptr);

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen(ptr);
                }
            else

            if (*src == letters[2] || *src == letters[3])
                {                      /* &P or &P+num page */
                    src++;
                    page = 0;
                    if (*src == '+')       /* &p+num case */
                        {
                        src++;
                        while (isdigit(*src))
                            {
                            /* Convert to int on-the-fly*/
                            page = (10*page)+(UCHAR)(*src)-48;
                            src++;
                            }

                        }

                    _itoa(viCurrentPage+page, buf, 10);
                    lstrcpy((chBuff[nAlign]+nIndex[nAlign]), buf);
                    nIndex[nAlign] += lstrlen(buf);
                    src--;
                }
            else

            if (*src == letters[4] || *src == letters[5])
                {                      /* &t time */

                    ptr = asctime(newtime);

                    /* extract time */
                    strncpy(chBuff[nAlign]+nIndex[nAlign], ptr+11, 8);
                    nIndex[nAlign] += 8;

                }
            else

            if (*src == letters[6] || *src == letters[7])
                {                      /* &d date */

                    ptr = asctime(newtime);

                    /* extract day month day */
                    strncpy(chBuff[nAlign]+nIndex[nAlign], ptr, 11);
                    nIndex[nAlign] += 11;

                    /* extract year */
                    strncpy(chBuff[nAlign]+nIndex[nAlign], ptr+20, 4);
                    nIndex[nAlign] += 4;

                }
            else

            if (*src == '&')
                {               /* quote a single & */

                    chBuff[nAlign][nIndex[nAlign]]='&';
                    nIndex[nAlign] += 1;

                }
            else

                /* Set the alignment for whichever has last occured. */

            if (*src == letters[8] || *src == letters[9])
                                       /* &c center */

                    nAlign=1;

            else

            if (*src == letters[10] || *src == letters[11])
                                       /* &r right */
                    nAlign=2;

            else

            if (*src == letters[12] || *src == letters[13])
                                       /* &d date */
                    nAlign=0;


            src++;


            }
        }
        /* Make sure all strings are null-terminated. */
        for (nAlign=0; nAlign<3; nAlign++)
            chBuff[nAlign][nIndex[nAlign]]=0;

        /* Initialize Header/Footer string */
        for (nx=0; nx<xCharPage; nx++)
            *(szHeadFoot+nx)=32;

        /* Copy Left aligned text. */
        for (nx=0; nx < nIndex[0]; nx++)
            *(szHeadFoot+nx)=chBuff[0][nx];

        /* Calculate where the centered text should go. */
        foo=(xCharPage-nIndex[1])/2;
        for (nx=0; nx<nIndex[1]; nx++)
            *(szHeadFoot+foo+nx)=(CHAR)chBuff[1][nx];

        /* Calculate where the right aligned text should go. */
        foo=xCharPage-nIndex[2];
        for (nx=0; nx<nIndex[2]; nx++)
            *(szHeadFoot+foo+nx)=(CHAR)chBuff[2][nx];


        return lstrlen(szHeadFoot);
    }




/**** NewPage */
BOOL APIENTRY NewPage ()

     {
     INT    iErr;

     if ((iErr = Escape(vhDCPrint, NEWFRAME, 0, NULL, 0)) < 0) {
	 EndPrint();
	 CalPrintAlert(iErr);
	 return FALSE;
     }
     vclnPrinted = 0;
     return TRUE;
     }


/**** BeginPrint - code taken from Cardfile - inprint.c - modified
      as necessary. Returns 0 if successful, SP_errorcode (which is
      < 0 for error.
*/

INT APIENTRY BeginPrint ()

     {

     CHAR rgchWindowText [CCHSZWINDOWTEXTMAX];
     INT	iErr;

     /* If can't create print DC, return FALSE to indicate can't print. */
     if (!(vhDCPrint = GetPrinterDC()))
	  return (SP_ERROR);

     /* Show the hour glass cursor. */
     HourGlassOn ();

     vfAbortPrint = FALSE;
     SetAbortProc(vhDCPrint, FnProcAbortPrint);
     GetWindowText (vhwnd0, rgchWindowText, CCHSZWINDOWTEXTMAX);

    /* Gotta disable the window before doing the start doc so that the user
     * can't quickly do multiple prints.
     */
     EnableWindow (vhwnd0, FALSE);

     if ((iErr = Escape(vhDCPrint, STARTDOC, lstrlen((LPSTR)rgchWindowText),
			(LPSTR)rgchWindowText, (LPSTR)0)) < 0) {
     	     EnableWindow (vhwnd0, TRUE);
	     DeleteDC(vhDCPrint);
	     HourGlassOff();
	     return iErr;
     }

     vhwndAbortPrint = CreateDialog(vhInstance, MAKEINTRESOURCE(IDD_ABORTPRINT),
	  vhwnd0,FnDlgAbortPrint);

     return (0);

     }


/**** EndPrint - code taken from Cardfile - inprint.c - modified
      as necessary.
*/

VOID APIENTRY EndPrint ()

     {


     if (!vfAbortPrint)
	Escape(vhDCPrint, ENDDOC, 0, (LPSTR)0, (LPSTR)0);

     /* The previous Escape could have changed the value of vfAbortPrint;
      * So, this has to be tested again;
      * Fix for Bug #6029 --SANKAR-- 11-9-89
      */
     if(!vfAbortPrint)
	DestroyAbortWnd();

     DeleteDC (vhDCPrint);

     /* The waiting is over. */
     HourGlassOff ();

     }


/**** FnProcAbortPrint - code taken from Cardfile - inprint.c - modified
      as necessary.
*/

INT  APIENTRY FnProcAbortPrint (
    HDC  hDC,
    INT  iReserved)
     {

     MSG msg;

     while (!vfAbortPrint && PeekMessage(&msg, NULL, 0L, 0L, TRUE))
	  if (vhwndAbortPrint == NULL || !IsDialogMessage(vhwndAbortPrint, &msg))
	       {
	       TranslateMessage (&msg);
	       DispatchMessage (&msg);
	       }
     return (!vfAbortPrint);

     }


/**** FnDlgAbortPrint - code taken from Cardfile - inprint.c - modified
      as necessary.
*/

INT_PTR CALLBACK FnDlgAbortPrint (
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
    {

    static HMENU hMenuSys;

     switch (msg)
	  {
	  case WM_COMMAND:
	       vfAbortPrint = TRUE;
	       DestroyAbortWnd();
	       vhwndAbortPrint = NULL;
	       return (TRUE);

	  case WM_INITDIALOG:
	       hMenuSys = GetSystemMenu (hwnd, FALSE);
	       SetDlgItemText (hwnd, IDCN_PATH,
		(LPSTR)PFileInPath (vszFileSpec));
	       CalSetFocus (hwnd);
	       return (TRUE);

	  case WM_INITMENU:
	       EnableMenuItem (hMenuSys, SC_CLOSE, MF_GRAYED);
	       return(TRUE);
	  }

     return(FALSE);

     }

/**** Enable Tiled window, THEN destroy dialog window. */
VOID DestroyAbortWnd()
{
    EnableWindow (vhwnd0, TRUE);
    DestroyWindow (vhwndAbortPrint);
    vhwndAbortPrint = NULL;
}

/**** Post printing error message box */
VOID APIENTRY CalPrintAlert(INT iErr)
    {
    INT     iszErr;

    /* Map error code to string index */
    if (iErr == SP_OUTOFDISK)
	iszErr = IDS_NEDSTP;
    else if (iErr == SP_OUTOFMEMORY)
	iszErr = IDS_NEMTP;
    else iszErr = IDS_CANNOTPRINT;

    AlertBox (vrgsz[iszErr], PFileInPath (vszFileSpec),
	      MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
    }



/* ** GetPrinterDc()
        Get Dc for current device on current output port according to
        info in win.ini.
            returns
                DC if success
                NULL if failure

*/
HDC APIENTRY GetPrinterDC()
    {
    extern BOOL bPrinterSetupDone;
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;

    if(!bPrinterSetupDone){ /* Retrieve default printer if none selected. */
    	vPD.Flags = PD_RETURNDEFAULT|PD_PRINTSETUP;
	vPD.hDevNames = NULL;
	vPD.hDevMode  = NULL;
	PrintDlg(&vPD);
    }

    if(!vPD.hDevNames)
    	return NULL;

    lpDevNames  = (LPDEVNAMES)GlobalLock(vPD.hDevNames);

    if(vPD.hDevMode)
    	lpDevMode = (LPDEVMODE)GlobalLock(vPD.hDevMode);
    else
    	lpDevMode = NULL;


    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *	will be NULL after GlobalLock()
     */

    vPD.hDC = CreateDC((LPSTR)lpDevNames+lpDevNames->wDriverOffset,
                           (LPSTR)lpDevNames+lpDevNames->wDeviceOffset,
			   (LPSTR)lpDevNames+lpDevNames->wOutputOffset,
			   lpDevMode);

    GlobalUnlock(vPD.hDevNames);

    if (vPD.hDevMode)
    	GlobalUnlock(vPD.hDevMode);

    return vPD.hDC;
    }

/****************************************************************************
**  IsDefaultPrinterStillValid()
**	The user might setup the app for a particular printer and a port
**	using the Printer Setup available in the application command menu;
**	But later, he might go to control panel and delete that printer
**	driver altogether or he might connect it to a different port;
**  So, the application must process the WININICHANGE message and at that
**  time, it must check whether the printer setup is still valid or not!
**  This function is used to make that check;
**     The input parameter is a string containing the printer name, driver,
**  port selected by the printer setup; This function checks if the printer
**  name is still present under the [Devices] section of Win.INI and if so,
**  it will check if the port selected is listed among the ports to which
**  this printer is connected; If not, it will automatically select the
**  first port listed as the default port and modify the input "lpszPrinter"
**  string accordingly;
**    If the default printer is not listed in WIN.INI at all, then this
**    function return FALSE;
**  Fix for Bug #5607 -- SANKAR -- 10-30-89
**
****************************************************************************/
BOOL FAR APIENTRY  IsDefaultPrinterStillValid(LPSTR lpszPrinter)
{
    CHAR  PrinterBuff[128];
    CHAR  DeviceBuff[128];
    LPSTR lpPort;	/* Default port name */
    LPSTR lpFirstPort = NULL;
    LPSTR lpch;
    LPSTR lpListedPorts;

    /* lpszPrinter contains "PrinterName,DriverName,Port" */
    lstrcpy(PrinterBuff, lpszPrinter);  /* Make a local copy of the default printer name */

    /* Search for the  end of printer name */
    for(lpch = PrinterBuff; (*lpch)&&(*lpch != ','); lpch = AnsiNext(lpch))
        ;
    if(*lpch)
        *lpch++ = '\0';
    /* Skip the Driver name; We do not need it! */
    while(*lpch && *lpch <= ' ')  /* Skip the blanks preceeding the driver name */
        lpch = AnsiNext(lpch);
    while(*lpch && *lpch != ',' && *lpch > ' ') /* Search for ',' following driver name */
        lpch = AnsiNext(lpch);
    while (*lpch && (*lpch <= ' ' || *lpch == ',')) /* Search for begining of port name */
        lpch = AnsiNext(lpch);
    lpPort = lpch;	/* Default port name */

    /* Search for the printer name among the [devices] section */
    if (!GetProfileString("devices", PrinterBuff, "", DeviceBuff, 128))
        return(FALSE);  /* Default printer no longer exists */

    lpch = DeviceBuff;

    /* Skip the Driver filename */
    while(*lpch && *lpch != ',')
        lpch = AnsiNext(lpch);

    while(*lpch)
      {
        /* Skip all blanks */
	while(*lpch && (*lpch <= ' ' || *lpch == ','))
	    lpch = AnsiNext(lpch);
	lpListedPorts = lpch;
	if(!lpFirstPort)
	    lpFirstPort = lpch; /* Save the first port in the list */
        /* Search for the end of the Port name */
	while(*lpch && *lpch != ',' && *lpch > ' ')
	    lpch = AnsiNext(lpch);
	if(*lpch)
	    *lpch++ = '\0';

	/* Check if the port names are the same */
	if(lstrcmp(lpPort, lpListedPorts) == 0)
	    return(TRUE); /* Default port exists among the listed ones */
      }

     /* The default port does not exist among the listed ports; So, change
      * the default port to the first port in the list;
      */
     if(*lpFirstPort)
       {
         /* Search for the end of the printer name */
	 for (lpch = szPrinter; (*lpch)&&(*lpch != ','); lpch = AnsiNext(lpch))
	     ;
	 /* Skip the driver file name */
	 if(*lpch)
	     lpch++;
	 while(*lpch && *lpch != ',')
	     lpch = AnsiNext(lpch);
	 if(*lpch)
	     lpch++;
	 lstrcpy(lpch, lpFirstPort);
	 return(TRUE);
       }
     return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\declare.h ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
 *   ***** declare.h
 *
 */

#define PT_LEN 50  /* Maximum of Page Setup strings in dialog. */

/* From caldata.c : */
extern BYTE	fInitComplete;
extern BYTE     vrgcDaysMonth [];
extern BOOL     vfDayMode;
extern HINSTANCE vhInstance;
extern HBRUSH   vhbrBorder;
extern HBRUSH   vhbrBackMain;
extern HBRUSH   vhbrBackSub;
extern HCURSOR  vhcsrArrow;
extern HCURSOR  vhcsrIbeam;
extern HCURSOR  vhcsrWait;
extern INT      vcxFont;
extern INT      vcxFontMax;
extern INT      vcyFont;
extern INT      vcyDescent;
extern INT      vcyExtLead;
extern INT      vcyLineToLine;
extern INT      vcxBorder;
extern INT      vcxVScrollBar;
extern INT      vcyBorder;
extern INT      vcxHScrollBar;
extern INT      vcyHScrollBar;
extern INT      vcyWnd1;
extern INT      vcyWnd2A;
extern INT      vcyWnd2BTop;
extern INT      vcyWnd2BBot;
extern INT      vcyWnd2B;
extern INT      vcxWnd1;
extern INT      vcxWnd2A;
extern INT      vcxWnd2B;
extern INT      vxcoBell;
extern INT      vcxBell;
extern INT      vcyBell;
extern INT      vxcoApptTime;
extern INT      vxcoAmPm;
extern INT      vxcoQdFirst;
extern INT      vxcoQdMax;
extern INT      vycoQdFirst;
extern INT      vycoQdMax;
extern INT      vxcoDate;
extern INT      vycoNotesBox;
extern INT      vxcoWnd2C;
extern INT      vycoWnd2C;
extern INT      vcln;
extern INT      vlnLast;
extern LD       vtld [];
extern HWND     vhwnd0;
extern HWND     vhwnd1;
extern HWND     vhwnd2A;
extern HWND     vhwnd2B;
extern HWND     vhwnd2C;
extern HWND     vhwnd3;
#ifndef BUG_8560
extern HWND	vhScrollWnd;
#endif
extern D3       vd3Cur;
extern FT       vftCur;
extern UINT     vcMinEarlyRing;
extern BOOL     vfSound;
extern BOOL     vfHour24;
extern INT      vmdInterval;
extern INT      vcMinInterval;
extern TM       vtmStart;
extern DLGPROC  vrglpfnDialog [];
extern INT      vlnCur;
extern FT       vftAlarmNext;
extern FT       vftAlarmFirst;
extern BOOL     vfFlashing;
extern INT      vcAlarmBeeps;
extern BOOL     vfInsert;
extern TM       vtmSpecial;
extern BOOL     vfNoGrabFocus;
extern HANDLE   vhAccel;
extern HWND     vhwndDialog;
extern BOOL     vfMustSyncAlarm;
extern INT      viLeftMarginLen;
extern INT      viRightMarginLen;
extern INT      viTopMarginLen;
extern INT      viBotMarginLen;
extern INT      viCurrentPage;
extern INT      viAMorPM;
extern CHAR     chPageText[6][PT_LEN];
extern CHAR     szDec[5];
extern CHAR     szPrinter[128];
extern BOOL     bPrinterSetupDone;
extern OPENFILENAME vOFN;
extern PRINTDLG vPD;
extern INT	vFilterIndex;
extern INT	vHlpMsg;



/* From caldata2.c : */

extern CHAR     *vrgsz [];
extern D3       vd3Sel;
extern WORD     vwDaySticky;
extern INT      vrgbMonth [];
extern INT      vcDaysMonth;
extern INT      vcWeeksMonth;
extern WORD     vwWeekdayFirst;
extern INT      vrgxcoGrid [];
extern INT      vrgycoGrid [];
extern WORD     votqrPrev;
extern WORD     votqrCur;
extern WORD     votqrNext;
extern WORD     vidrCur;
extern LOCALHANDLE vrghlmDr [];
extern LOCALHANDLE vhlmTdd;
extern INT      vcddAllocated;
extern INT      vcddUsed;
extern DT       vdtFrom;
extern D3       vd3To;
extern DT       vdtTo;
extern INT      vitddFirst;
extern INT      vitddMax;
extern HWND     vhwndFocus;
extern INT      hFile [];
extern OFSTRUCT OFStruct [];
extern BOOL     vfChangeFile;
extern INT      vobkEODChange;
extern CHAR     vszFileSpec [];
extern BOOL     vfOriginalFile;
extern INT      vobkEODNew;
extern BOOL     vfDirty;
extern BYTE     vrgbMagic [];
extern HDC      vhDCMemory;
extern HBITMAP  vhbmLeftArrow;
extern HBITMAP  vhbmRightArrow;
extern HBITMAP  vhbmBell;
extern INT      vxcoLeftArrowFirst;
extern INT      vxcoLeftArrowMax;
extern INT      vxcoRightArrowFirst;
extern INT      vxcoRightArrowMax;
extern char	vszMergeStr [];

extern INT      vmScrollPos;
extern INT      vmScrollInc;
extern INT      vmScrollMax;
extern INT      hmScrollPos;
extern INT      hmScrollMax;
extern INT      hmScrollInc;
extern INT      viMarkSymbol;
extern BOOL     vfOpenFileReadOnly;
extern CHAR	vszFilterSpec [];
extern CHAR	vszCustFilterSpec [];

/* From cal.c : */
BOOL APIENTRY     FCalSize (HWND, INT, INT, INT);
LRESULT CALLBACK  CalWndProc (HWND, UINT, WPARAM, LPARAM);
INT  APIENTRY     XcoWnd1 (VOID);
INT  APIENTRY     YcoWnd1 (VOID);
VOID APIENTRY     CalSetFocus (HWND);
VOID APIENTRY     InitMenuItems (VOID);
VOID APIENTRY     CalWinIniChange(VOID);


/* From cal2.c : */
VOID APIENTRY     CalPaint (HWND, HDC);
VOID APIENTRY     DrawArrow (HBITMAP, INT);
VOID APIENTRY     DrawArrowBorder (INT);
VOID APIENTRY     DispTime (HDC);
INT  APIENTRY     GetTimeSz (TM, CHAR *);
VOID APIENTRY     ByteTo2Digs (BYTE, CHAR *);
CHAR * APIENTRY   CopySz (CHAR *, CHAR *);
VOID APIENTRY     DispDate (HDC, D3 *);
VOID APIENTRY     GetDateDisp (D3 *, CHAR *);
BYTE * APIENTRY   FillBuf (BYTE *, INT, BYTE);
CHAR * APIENTRY   WordToASCII (WORD, CHAR *, BOOL);
VOID APIENTRY     GetDashDateSel (CHAR *);
BOOL APIENTRY     FGetTmFromTimeSz (CHAR *, TM *);
VOID APIENTRY     SkipSpace (CHAR **);
BOOL APIENTRY     FGetWord (CHAR **, WORD *);
CHAR APIENTRY     ChUpperCase (CHAR);
BOOL APIENTRY     FDigit (CHAR);
BOOL APIENTRY     FD3FromDateSz (CHAR *, D3 *);
VOID APIENTRY     GetD3FromDt (DT, D3 *);
VOID APIENTRY     SetEcText(HWND, CHAR *);


/* From calcolor.c : */
BOOL APIENTRY     CreateBrushes (VOID);
VOID APIENTRY     DestroyBrushes (VOID);
VOID APIENTRY     PaintBack (HWND, HDC);
HDC  APIENTRY     CalGetDC (HWND);
VOID APIENTRY     SetDefaultColors (HDC);
VOID APIENTRY     DrawAlarmBell (HDC, INT);


/* From calmonth.c : */
WORD APIENTRY     GetWeekday (D3 *);
INT  APIENTRY     CDaysMonth (D3 *);
VOID APIENTRY     SetUpMonth (VOID);
VOID APIENTRY     BuildMonthGrid (VOID);
VOID APIENTRY     PaintMonthGrid (HDC);
VOID APIENTRY     PaintMonth (HDC);
VOID APIENTRY     DrawMark (HDC, INT, INT, INT, INT);
VOID APIENTRY     ShowToday (HDC, INT, INT, INT);
VOID APIENTRY     InvertDay (HDC, WORD);
VOID APIENTRY     PositionCaret (VOID);
VOID APIENTRY     MapDayToRect (WORD, RECT *);
BOOL APIENTRY     FMapCoToIGrid (INT, INT *, INT, INT *);
DT APIENTRY       DtFromPd3 (D3 *);
VOID APIENTRY     GetMarkedDays (VOID);
VOID APIENTRY     MonthMode (VOID);


/* From calmon2.c : */
BOOL APIENTRY     FMonthPrev (VOID);
BOOL APIENTRY     FMonthNext (VOID);
VOID APIENTRY     ShowMonthPrevNext (BOOL);
VOID APIENTRY     UpdateMonth (VOID);
VOID APIENTRY     MouseSelectDay (MPOINT, BOOL);
VOID APIENTRY     FScrollMonth (INT, UINT);
VOID APIENTRY     FHorizScrollMonth (INT, WORD); /* added 11/3/88 for hscroll */
BOOL APIENTRY     FCalKey (HWND, WPARAM);
VOID APIENTRY     MoveSelCurMonth (UINT);
VOID APIENTRY     InvalidateMonth (VOID);
VOID APIENTRY     MoveSelNewMonth (UINT);
VOID APIENTRY     JumpDate (D3 *);
BOOL APIENTRY     FFetchTargetDate (VOID);


/* From calday.c : */
VOID APIENTRY     DayMode (D3 *);
VOID APIENTRY     SwitchToDate (D3 *);
VOID APIENTRY     DayPaint (HDC);
VOID APIENTRY     FillTld (TM);
VOID APIENTRY     ScrollDownTld (INT);
BOOL APIENTRY     FGetNextLd (TM, LD *);
BOOL APIENTRY     FGetPrevLd (TM, LD *);
BOOL APIENTRY     FScrollDay (INT, UINT);
VOID APIENTRY     ScrollUpDay (INT, BOOL);
VOID APIENTRY     ScrollDownDay (INT, BOOL, BOOL);
VOID APIENTRY     InvalidateParentQdEc (INT);
INT  APIENTRY     YcoFromLn (INT);
INT  APIENTRY     LnFromYco (INT);
VOID APIENTRY     SetQdEc (INT);


/* From calday2.c : */
VOID APIENTRY     SetDayScrollRange (VOID);
VOID APIENTRY     AdjustDayScrollRange (INT);
VOID APIENTRY     SetDayScrollPos (INT);
VOID APIENTRY     AdjustDayScrollPos (INT);
INT  APIENTRY     ItmFromTm (TM);
TM   APIENTRY     TmFromItm (INT);
VOID APIENTRY     MapTmAndItm (TM *, INT *);
TM   APIENTRY     TmFromQr (PQR*, PQR);
TM   APIENTRY     TmNextRegular (TM);


/* From caltqr.c : */

BOOL APIENTRY     FSearchTqr (TM);
VOID APIENTRY     StoreQd (VOID);
VOID APIENTRY     AdjustOtqr (INT, INT);
VOID APIENTRY     DeleteQr (WORD);
BOOL APIENTRY     FInsertQr (WORD, PQR);
BYTE * APIENTRY   PbTqrLock (VOID);
DR   * APIENTRY   PdrLockCur (VOID);
VOID APIENTRY     DrUnlockCur (VOID);
DR   * APIENTRY   PdrLock (UINT);
VOID APIENTRY     DrUnlock (UINT);
BYTE * APIENTRY   PbTqrFromPdr (DR *);
VOID APIENTRY     StoreNotes (VOID);
VOID APIENTRY     SetNotesEc (VOID);
VOID APIENTRY     EcNotification (WORD, WORD);
VOID APIENTRY     PruneEcText (VOID);


/* From calrem.c : */
INT_PTR CALLBACK  FnRemove (HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY     Remove (VOID);
VOID APIENTRY     HourGlassOn (VOID);
VOID APIENTRY     HourGlassOff (VOID);


/* From calcmd.c : */
VOID APIENTRY     CalCommand (HWND, INT);
BOOL APIENTRY     FDoDialog (INT);


/* From calcmd2.c : */
INT_PTR CALLBACK  FnSaveAs (HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY     GetRangeOfDates (HWND);
INT_PTR CALLBACK  FnDate (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK  FnControls (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK  FnSpecialTime (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK  FnPageSetup (HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY     ProcessDlgText(BOOL);
INT  APIENTRY     ChangeToPM ( TM *);
INT_PTR CALLBACK  FnDaySettings (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK  FnMarkDay ( HWND, UINT, WPARAM, LPARAM); /* added 11/8/88 */
INT  APIENTRY     cDlgfnOpen ( HWND, UINT, WPARAM, LPARAM);
INT  APIENTRY     cDlgOpenFile (HANDLE, HWND, INT, CHAR *, INT,
                                CHAR *, CHAR * , INT);
BOOL APIENTRY     cDlgCheckFilename (CHAR *);  /* removed from ..\common\dlgopen.c */
VOID APIENTRY     cDlgCheckOkEnable (HWND, INT, WORD);
BOOL APIENTRY     cIsChLegal (INT);
BOOL APIENTRY     cFSearchSpec (CHAR *);
INT  APIENTRY     AlertBox (CHAR *, CHAR *, UINT);
VOID APIENTRY     ConvertUpperSz (CHAR *);
VOID APIENTRY     AddDefExt (LPSTR);
VOID APIENTRY     CheckButtonEnable (HWND, INT, WORD);
BOOL APIENTRY     FCheckSave (BOOL);
VOID APIENTRY     RecordEdits (VOID);
VOID APIENTRY     DateTimeAlert(BOOL, INT);
BOOL APIENTRY     MergeStrings();
BOOL APIENTRY	  CallSaveAsDialog ();



/* From calmark.c : */
VOID APIENTRY     CmdMark (VOID);


/* From caltdd.c : */
VOID APIENTRY     InitTdd (VOID);
BOOL APIENTRY     FSearchTdd (DT, INT *);
BOOL APIENTRY     FGrowTdd (INT, INT);
VOID APIENTRY     ShrinkTdd (INT, INT);
BYTE * APIENTRY   BltByte (BYTE *, BYTE *, UINT);
VOID APIENTRY     DeleteEmptyDd (INT);
DD   * APIENTRY   TddLock (VOID);
VOID APIENTRY     TddUnlock (VOID);


/* From calfile.c : */
VOID APIENTRY     CreateChangeFile (VOID);
VOID APIENTRY     DeleteChangeFile (VOID);
BOOL APIENTRY     FCreateTempFile (INT, INT);
BOOL APIENTRY     FFreeUpDr (DR *, DL *);
BOOL APIENTRY     FWriteDrToFile (BOOL, INT, DR *);
BOOL APIENTRY     FReadDrFromFile (BOOL, DR *, DL);
BOOL APIENTRY     FGetDateDr (DT);


/* From calfile2.c : */
BOOL APIENTRY     FCopyToNewFile (INT, DR *, DD *, DD *);
BOOL APIENTRY     FSaveFile (CHAR *, BOOL);
VOID APIENTRY     Reconnect (BOOL);
INT  APIENTRY     GetDrive (CHAR *);
CHAR * APIENTRY   PchFileName (CHAR *);
BOOL APIENTRY     FFlushDr (VOID);
BOOL APIENTRY     FCloseFile (INT);
BOOL APIENTRY     FWriteHeader (DD *);
BOOL APIENTRY     FWriteFile (INT, BYTE *, UINT);
BOOL APIENTRY     FDeleteFile (INT);
BOOL APIENTRY     FReopenFile (INT, WORD);
VOID APIENTRY     SetTitle (CHAR *);
BOOL APIENTRY     FCondClose (BOOL, BOOL);
VOID APIENTRY     CleanSlate (BOOL);
VOID APIENTRY     OpenCal (VOID);
VOID APIENTRY     LoadCal (VOID);



/* From calalarm.c : */
BOOL APIENTRY     FAlarm (INT);
VOID APIENTRY     AlarmToggle (VOID);
VOID APIENTRY     uProcessAlarms (VOID);
INT_PTR CALLBACK  FnAckAlarms (HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY     GetNextAlarm (FT *, FT *, BOOL, HWND);
WORD APIENTRY     IdrFree (VOID);
VOID APIENTRY     ReadTempDr (WORD, DL);
VOID APIENTRY     StartStopFlash (BOOL);



/* From calspecl.c : */
VOID APIENTRY     InsertSpecial (VOID);
VOID APIENTRY     DeleteSpecial (VOID);
VOID APIENTRY     SpecialTimeFin (VOID);


/* From calprint.c : */
INT_PTR CALLBACK  FnPrint (HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY     Print (VOID);
BOOL APIENTRY     PrintDate (INT, DT, BOOL);
BOOL APIENTRY     PrintHeading (DT);
BOOL APIENTRY     PrintBlankLn (INT);
BOOL APIENTRY     PrintLine (VOID);
BOOL APIENTRY     NewPage (VOID);
BOOL APIENTRY     PrintHeaderFooter(BOOL);
INT  APIENTRY     BeginPrint (VOID);
VOID APIENTRY     EndPrint (VOID);
INT  APIENTRY     FnProcAbortPrint (HDC, INT);
INT_PTR CALLBACK  FnDlgAbortPrint (HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY     CalPrintAlert(INT);
INT               atopix(CHAR *, INT);


/* From calinit.c : */
BOOL APIENTRY     CalInit (HANDLE, HANDLE, LPSTR, INT);
BOOL APIENTRY     AllocDr ();
BOOL APIENTRY     CalTerminate(INT);
BOOL APIENTRY     LoadBitmaps(HANDLE);
VOID APIENTRY     DeleteBitmaps(VOID);



/* From calmain.c */
BOOL APIENTRY     FKeyFiltered (MSG *);
VOID APIENTRY     CalTimer (BOOL);
VOID APIENTRY     AlarmCheck (VOID);
VOID APIENTRY     AddMinsToFt (FT *, UINT);
INT  APIENTRY     CompareFt (FT *, FT *);


/* From callib.asm : */
VOID APIENTRY     ReadClock(D3 *pd3, TM *ptm);
INT  APIENTRY     FDosDelete(LPSTR lpszFileToDelete);
INT  APIENTRY     FDosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName);
INT  APIENTRY     GetCurDrive (VOID);
LONG APIENTRY     mylmul(INT, INT);


/* From common.h */
/* include file for common routines */

INT APIENTRY cDlgOpen(HANDLE, HWND, INT, INT, INT, INT,
		      CHAR *, INT, CHAR *, OFSTRUCT *, INT *);

BOOL APIENTRY   cDlgCheckFileName(CHAR *);
VOID APIENTRY   DlgCheckOkEnable(HWND, INT, WORD);
HDC  APIENTRY   GetPrinterDC(VOID);
VOID APIENTRY   DlgInitSaveAs(HWND, INT, INT, INT, LPOFSTRUCT);
CHAR * APIENTRY PFileInPath(CHAR *);
CHAR * APIENTRY Int2Ascii (INT, CHAR *, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\auditchk.c ===
/*****************************************************************************

                                A U D I T

    Name:       audit.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:

*****************************************************************************/



#include <windows.h>
#include "clipbook.h"
#include "auditchk.h"



//////////////////////////////////////////////////////////////////////////
//
// Purpose: Tests, enables, or disables the Security privilege, which
//    allows auditing to take place.
//
// Parameters:
//    fAudit - Flag, which can take on one of these values:
//       AUDIT_PRIVILEGE_CHECK - Turns on Security, then turns it off.
//          Used to test whether you CAN edit auditing.
//       AUDIT_PRIVILEGE_ON    - Turns on auditing privilege.
//       AUDIT_PRIVILEGE_OFF   - Turns off auditing privilege.
//
// Return: TRUE if the function succeeds, FALSE on failure.
//
//////////////////////////////////////////////////////////////////////////

BOOL AuditPrivilege(
    int fAudit)
{
HANDLE              hToken;
LUID                SecurityValue;
TOKEN_PRIVILEGES    tkp;
BOOL                fOK = FALSE;


    /* Retrieve a handle of the access token. */

    if (OpenProcessToken (GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
        {
        /*
         * Enable the SE_SECURITY_NAME privilege or disable
         * all privileges, depending on the fEnable flag.
         */

        if (LookupPrivilegeValue ((LPSTR)NULL,
                                  SE_SECURITY_NAME,
                                  &SecurityValue))
            {
            tkp.PrivilegeCount     = 1;
            tkp.Privileges[0].Luid = SecurityValue;


            // Try to turn on audit privilege

            if (AUDIT_PRIVILEGE_CHECK == fAudit || AUDIT_PRIVILEGE_ON == fAudit)
                {
                tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                AdjustTokenPrivileges (hToken,
                                       FALSE,
                                       &tkp,
                                       sizeof(TOKEN_PRIVILEGES),
                                       (PTOKEN_PRIVILEGES)NULL,
                                       (PDWORD)NULL);

                /* The return value of AdjustTokenPrivileges be texted. */
                if (GetLastError () == ERROR_SUCCESS)
                    {
                    fOK = TRUE;
                    }
                }


            // Try to turn OFF audit privilege

            if (AUDIT_PRIVILEGE_CHECK == fAudit || AUDIT_PRIVILEGE_OFF == fAudit)
                {
                AdjustTokenPrivileges (hToken,
                                       TRUE,
                                       NULL,
                                       0L,
                                       (PTOKEN_PRIVILEGES)NULL,
                                       (PDWORD)NULL);

                if (ERROR_SUCCESS == GetLastError () &&
                    AUDIT_PRIVILEGE_OFF == fAudit)
                    {
                    fOK = TRUE;
                    }
                }
            }
        }

    return fOK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\cdlgopen.c ===
/* ** This file contains routines required to display a standard open
      dialog box.  Apps can directly link to object file or modify this
      source for slightly different dialog box.

      Note - in order to use these routines, the application must
      export DlgfnOpen().  Also, an app that uses these routines must
      be running ss=ds, since they use near pointers into stack.
*/

#include "cal.h"

#define ATTRDIRLIST	0xC010	/* include directories and drives in listbox */
#define ATTRFILELIST	0x0000
#define ID_LISTBOX	10
#define ID_EDIT 	11
#define CBEXTMAX	6  /* Number of bytes in "\*.txt" */

CHAR szLastDir[120];    /* Dir where the last open occurred */
                        /* useful if file is picked up from other than current dir e.g path */
INT idEditSave;
INT idListboxSave;
INT idPathSave;
CHAR *	 szExtSave;
CHAR *	 szFileNameSave;
INT	*pfpSave;
OFSTRUCT *	rgbOpenSave;
INT	cbRootNameMax;
#define CCHNG	    15
CHAR	rgchNg[CCHNG] =  {'"', '\\', '/', '[', ']', ':', '|',
			  '<', '>', '+', '=', ';', ',', ' ', 0};


/*
 *  Function prototypes
 */

VOID cDlgAddCorrectExtension(CHAR *szEdit, WORD fSearching);


/*
 *  Functions
 */

#if 0
/************************* commented out unused code . L.Raman 12/12/90 */

/* int far DlgfnOpen(); */
/* void far cDlgCheckOkEnable(); */
/* BOOL far cDlgCheckFileName();*/

/* ** Display dialog box for opening files.  Allow user to interact with
      dialogbox, change directories as necessary, and try to open file if user
      selects one.  Automatically append extension to filename if necessary.
      The open dialog box contains an edit field, listbox, static field,
      and OK and CANCEL buttons.

      This routine correctly parses filenames containing KANJI characters.

      Input -	hInstance if app module instance handle.
		hwndParent is window handle of parent window
		idDlgIn is dialog id
		idEditIn is id of edit field
		idListboxIn is id of listbox
		idPathIn is id of static field which gets path name
		szExtIn is pointer to zero terminated string containing
			default extension to be added to filenames.
		cbFileNameMaxIn is number of bytes in edit field buffer.

      Output - *pfp gets value of file handle if file is opened.
		    or -1 if file could not be opened.
	       *rgbOpenIn is initialized with file info by OpenFile()
	       *szFileNameIn gets name of selected file (fully qualified)
	       Any leading blanks are removed from sszFileName.
	       Trailing blanks are replaced with a 0 terminator.

      Returns -     -1 if dialogbox() fails (out of memory).
		     0 if user presses cancel
		     1 if user enters legal filename and presses ok
                     2 if user enters illegal file name and presses ok
*/
INT APIENTRY cDlgOpen(
    HANDLE	hInstance,
    HWND	hwndParent,
    INT		idDlgIn,
    INT		idEditIn,
    INT		idListboxIn,
    INT		idPathIn,
    CHAR	*szExtIn,
    INT		cbFileNameMaxIn,
    CHAR	*szFileNameIn,
    OFSTRUCT *	 rgbOpenIn,
    INT		*pfp)
{
    BOOL    fResult;

    idEditSave = idEditIn;
    idListboxSave = idListboxIn;
    idPathSave = idPathIn;
    szExtSave = szExtIn;
    /* Limit for bytes in filename is max bytes in filename less
       space for extension and 0 terminator. */
    cbRootNameMax = cbFileNameMaxIn - CBEXTMAX - 1;
    szFileNameSave = szFileNameIn;
    rgbOpenSave = rgbOpenIn;
    pfpSave = pfp;
    fResult = (BOOL)DialogBox(hInstance, MAKEINTRESOURCE(idDlgIn), hwndParent, cDlgfnOpen );
    return fResult;
}


/* ** Dialog function for Open File */
INT_PTR CALLBACK cDlgfnOpen(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT item;
    CHAR rgch[256];
    INT cchFile, cchDir;
    CHAR *pchFile;
    BOOL    fWild;
    static BOOL bRO=FALSE;
    INT     result = 2;    /* Assume illegal filename */
    INT len, nx;

    switch (msg) {
    case WM_INITDIALOG:
        /* Save the global read-only status. */
        bRO=vfOpenFileReadOnly;

	/* Set edit field with default search spec */
        SetDlgItemText(hwnd, idEditSave, g(szExtSave+1));
        SendDlgItemMessage(hwnd, idEditSave, +++EM_SETSEL(use macros)+++, 0, MAKELONG(6,0));

	/* Don't let user type more than cbRootNameMax bytes in edit ctl. */
        SendDlgItemMessage(hwnd, idEditSave, EM_LIMITTEXT, cbRootNameMax-1, 0L);

	/* fill list box with filenames that match spec, and fill static
	   field with path name */
	if (!DlgDirList(hwnd, g(szExtSave+1), IDCN_LISTBOXDIR, idPathSave, ATTRDIRLIST))
	    EndDialog(hwnd, 0);
	if (!DlgDirList(hwnd, g(szExtSave+1), IDCN_LISTBOX, idPathSave, ATTRFILELIST))
	    EndDialog(hwnd, 0);
	break;

      case WM_COMMAND:
	wParam = GET_WM_COMMAND_ID(wParam, lParam);
#ifdef NEVER
/*  The following lines are commented out because they introduce this bug:
    When the edit field becomes empty, OK button is not greyed
    SANKAR 06-21-89.
*/
	if (wParam == idEditSave)
	    wParam = ID_EDIT;
#endif
	switch (wParam) {
        case IDOK:
LoadIt:
            vfOpenFileReadOnly=IsDlgButtonChecked(hwnd, IDCN_READONLY);

            if (IsWindowEnabled(GetDlgItem(hwnd, IDOK)))
                {
		/* Get contents of edit field */
		/* Add search spec if it does not contain one. */
		len = 7 + GetWindowTextLength (GetDlgItem(hwnd, IDCN_EDIT));
		GetDlgItemText(hwnd, idEditSave, gszFileNameSave, len);
		lstrcpy(grgch, szFileNameSave);

		/* Append appropriate extension to user's entry */
		cDlgAddCorrectExtension(rgch, TRUE);

		/* Try to open directory.  If successful, fill listbox with
		   contents of new directory.  Otherwise, open datafile. */
                if (cFSearchSpec(rgch))
                    {
                    if (DlgDirList(hwnd, grgch, IDCN_LISTBOXDIR, idPathSave, ATTRDIRLIST))
                        {
                        lstrcpy(gszFileNameSave, rgch);
                        DlgDirList(hwnd, grgch, IDCN_LISTBOX, idPathSave, ATTRFILELIST);
			SetDlgItemText(hwnd, idEditSave, gszFileNameSave);
			break;
                        }
                    }


		cDlgAddCorrectExtension(szFileNameSave, FALSE);
		/* If no directory list and filename contained search spec,
		   honk and don't try to open. */
		if (cFSearchSpec(szFileNameSave)) {
		    MessageBeep(0);
		    break;
		}

		/* Make filename upper case and if it's a legal dos
		   name, try to open the file. */
		AnsiUpper(gszFileNameSave);
		if (cDlgCheckFileName(szFileNameSave)) {
		    result = 1;
		    *pfpSave = MOpenFile(gszFileNameSave, (LPOFSTRUCT)rgbOpenSave, OF_PROMPT+OF_CANCEL);
		    if ((*pfpSave == -1) &&
			(((LPOFSTRUCT)rgbOpenSave)->nErrCode == 0))
                            result = 2;
            else    {        /* successful file open */
                strcpy(szLastDir, ((LPOFSTRUCT)rgbOpenSave)->szPathName);
                szLastDir[strlen(szLastDir)-strlen(szFileNameSave)] = 0;
            }
        }
		EndDialog(hwnd, result);
	    }
	    break;

	case IDCANCEL:
            /* User pressed cancel.  Just take down dialog box. */
            vfOpenFileReadOnly=bRO; /* And restore this. */
	    EndDialog(hwnd, 0);
	    break;

	/* User single clicked or doubled clicked in listbox -
	   Single click means fill edit box with selection.
	   Double click means go ahead and open the selection. */
	case IDCN_LISTBOX:
	case IDCN_LISTBOXDIR:
	    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

	    /* Single click case */
	    case 1:
                GetDlgItemText(hwnd, idEditSave, grgch, cbRootNameMax+1);

		/* Get selection, which may be either a prefix to a new search
		   path or a filename. DlgDirSelectEx parses selection, and
                   appends a backslash if selection is a prefix */

                if (wParam==IDCN_LISTBOXDIR)
                    SendDlgItemMessage(hwnd, IDCN_LISTBOX, LB_SETCURSEL, -1, 0L);
                else
                    SendDlgItemMessage(hwnd, IDCN_LISTBOXDIR, LB_SETCURSEL, -1, 0L);

                nx=DLGDIRSELECT(hwnd, szFileNameSave, +++nLen+++, wParam);

                if (nx)
                    {
		    cchDir = lstrlen(gszFileNameSave);
		    cchFile = lstrlen(grgch);
		    pchFile = rgch+cchFile;

                    /* Now see if there are any wild characters (* or ?) in
		       edit field.  If so, append to prefix. If edit field
		       contains no wild cards append default search spec
		       which is  "*.TXT" for notepad. */
		    fWild = (*pchFile == '*' || *pchFile == ':');
		    while (pchFile > rgch) {
			pchFile = (CHAR *)LOWORD((LONG)AnsiPrev(g(rgch), pchFile));
			if (*pchFile == '*' || *pchFile == '?')
			    fWild = TRUE;
			if (*pchFile == '\\' || *pchFile == ':') {
			    pchFile = (CHAR *)LOWORD((LONG)AnsiNext(gpchFile));
			    break;
			}
		    }
		    if (fWild)
			lstrcpy(gszFileNameSave + cchDir, pchFile);
		    else
			lstrcpy(gszFileNameSave + cchDir, (szExtSave+1));
		}

		/* Set edit field to entire file/path name. */
		SetDlgItemText(hwnd, idEditSave, gszFileNameSave);

		break;

	    /* Double click case - first click has already been processed
	       as single click */
	    case 2:
		/* Basically the same as ok.  If new selection is directory,
                   open it and list it.  Otherwise, open file. */
#if NEVER
/* None of this code is necessary.  A double click is more than basically the
   same as pressing OK, it is EXACTLY the same as pressing OK.  No point in
   duplicating all this code, especially since it will bring up 2 consecutive
   System-Modal Dialogs if the path investigated references drive A with the
   door open.   Clark Cyr, 14 August 1989                                     */

                DlgDirList(hwnd, szFileNameSave, IDCN_LISTBOX, idPathSave,ATTRFILELIST);

                if (DlgDirList (hwnd, szFileNameSave, IDCN_LISTBOXDIR,IDCN_PATH, ATTRDIRLIST))
                    {
		    SetDlgItemText(hwnd, idEditSave, gszFileNameSave);
		    break;
                    }
#endif
		goto LoadIt;	/* go load it up */
	    }
	    break;

	case IDCN_EDIT:
	    cDlgCheckOkEnable(hwnd, idEditSave, GET_WM_COMMAND_ID(wParam, lParam));
		
	    break;

	default:
	    return(FALSE);
	}
    default:
	return FALSE;
    }
    return(TRUE);
}


/* ** Enable ok button in a dialog box if and only if edit item
      contains text.  Edit item must have id of idEditSave */
VOID APIENTRY cDlgCheckOkEnable(
    HWND	hwnd,
    INT	idEdit,
    WORD message)
{
    if (message == EN_CHANGE) {
	EnableWindow(GetDlgItem(hwnd, IDOK), (SendMessage(GetDlgItem(hwnd, idEdit), WM_GETTEXTLENGTH, 0, 0L)));
    }
}

/* ** Given filename or partial filename or search spec or partial
      search spec, add appropriate extension. */
VOID cDlgAddCorrectExtension(CHAR *szEdit, WORD fSearching)
{
    register CHAR    *pchLast;
    register CHAR    *pchT;
    INT ichExt;
    BOOL    fDone = FALSE;
    INT     cchEdit;

    pchT = pchLast = (CHAR *)LOWORD((LONG)AnsiPrev(gszEdit, (szEdit + (cchEdit = lstrlen(szEdit)))));

    if ((*pchLast == '.' && *(AnsiPrev(gszEdit, pchLast)) == '.') && cchEdit == 2)
	ichExt = 0;
    else if (*pchLast == '\\' || *pchLast == ':')
	ichExt = 1;
    else {
	ichExt = fSearching ? 0 : 2;
	for (; pchT > szEdit; pchT = (CHAR *)LOWORD((LONG)AnsiPrev(gszEdit, pchT))) {
	    /* If we're not searching and we encounter a period, don't add
	       any extension.  If we are searching, period is assumed to be
	       part of directory name, so go ahead and add extension. However,
	       if we are searching and find a search spec, do not add any
	       extension. */
	    if (fSearching) {
		if (*pchT == '*' || *pchT == '?')
		    return;
	    } else if (*pchT == '.'){
		return;
	    }
	    /* Quit when we get to beginning of last node. */
	    if (*pchT == '\\')
		break;
	}
	/* Special case hack fix since AnsiPrev can not return value less than
	   szEdit. If first char is wild card, return without appending. */
	if (fSearching && (*pchT == '*' || *pchT == '?'))
	    return;
    }
#ifdef DBCS
    lstrcpy(gAnsiNext(pchLast), (szExtSave+ichExt));
#else
    lstrcpy(g(pchLast+1), (szExtSave+ichExt));
#endif
}

/* ** Check for legal filename. Strip leading blanks and
      0 terminate */
BOOL  APIENTRY cDlgCheckFilename(register CHAR	*pch)
{
#ifndef CRISPY

    OFSTRUCT	ofT;
    return (MOpenFile(gpch, (LPOFSTRUCT)&ofT, OF_PARSE) == 0);
}
#else


    INT     cchFN;
    register INT     cchT;
    CHAR	*pchIn;
    CHAR	*pchFirst;
    CHAR	*pchSave;
    INT     s;
    BOOL	fBackSlash;

    s = 0;
    fBackSlash = FALSE;
    pchIn = pch;
    for (;; pch = AnsiNext(gpch)) {

	switch (s) {

	/* Trim leading blanks */
	case 0:
	    if (*pch == ' ')
		break;

	    if (*pch == '\\') {
		pchFirst = pch;
		cchT = 0;
		s = 2;
	    } else if (*pch == 0 || !cIsChLegal(*pch)) {
		return FALSE;

	    } else {
		pchFirst = pch;
		cchT = 1;
		if (*pch == '.')
		    s = 5;
		else
		    s = 1;
	    }
	    break;

	/* Volume, drive, subdirectory	node or filename */
	case 1:
	    if (*pch == ':' && cchT == 1) {
		if (*(pch-1) < 'A' || *(pch-1) > 'Z')
		    return FALSE;
		s = 2;
		cchT--;
	    } else if (*pch == '\\') {
		if (*(pch+1) == '\\')
		    return FALSE;
		cchT = 0;
	     } else if (*pch == '.') {
		cchT = 0;
		s = 3;
	    } else if (!cIsChLegal(*pch))
		return FALSE;
	    else if (*pch == 0)
		goto RetGood;
	    else if (cchT++) {
		s++;
	    }
	    break;

	/* sub directory node or filename */
	case 2:
	    if (*pch == '\\') {
		if (*(pch+1) == '\\')
		    return FALSE;
		fBackSlash = TRUE;
		cchT = 0;
	    } else if (*pch == '.') {
		if (*pch+1 == '.') {
		    if (fBackSlash || cchT)
			return FALSE;
		    s = 5;
		    cchT = 1;
		} else {
		    s++;
		    cchT = 0;
		}
	    } else if (*pch == 0)
		goto RetGood;
	    else if (cchT++ > 7 || *pch == ' ' || !IsChLegal(*pch))
		return FALSE;
	    break;

	/* up to three characters in extension */
	case 3:
	    if (*pch == 0) {
		goto   RetGood;
	    }

	    if (cchT++ > 2 || *pch == '.' || !IsChLegal(*pch))
		return FALSE;

	    if (*pch == ' ') {
		pchSave = pch;
		s++;
	    }
	    break;

	/* Trim trailing blanks */
	case 4:
	    if (*pch == 0) {
		*pchSave = 0;
		goto RetGood;
	    } else if (*pch != ' ')
		return FALSE;
	    break;

	/* check for ..\ */
	case 5:
	    if (*pch++ != '.' || *pch != '\\')
		return FALSE;
	    cchT = 0;
	    fBackSlash = TRUE;
	    s = 2;
	    break;
	}
    }
RetGood:
    if (pchFirst != pchIn)
	lstrcpy(gpchIn, pchFirst);
    return TRUE;
}

/* ** Check for legal MS-DOS filename characters.
      return TRUE if legal, FALSE otherwise. */
BOOL APIENTRY cIsChLegal(INT	ch)
{
	register CHAR	 *pch = rgchNg;
	register INT ich = 0;

	if (ch < ' ')
	    return FALSE;

	rgchNg[CCHNG-1] = ch;
#ifdef DBCS
        while (ch != *pch){
	    if( IsDBCSLeadByte( *pch ) )
		ich++;
            ich++;
            pch = AnsiNext(pch);
        }
#else
	while (ch != *pch++)
	    ich++;
#endif

	return (ich == CCHNG-1);
}
#endif

/* ** return TRUE iff 0 terminated string contains a '*' or '\' */
BOOL  APIENTRY cFSearchSpec(register CHAR *sz)
{
#ifdef DBCS
    for (; *sz;sz=AnsiNext(sz)){
	if (*sz == '*' || *sz == '?')
	    return TRUE;
    }
#else
    for (; *sz;sz++) {
	if (*sz == '*' || *sz == '?')
	    return TRUE;
    }
#endif
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\calrem.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** calrem.c
 *****
*/

#include "cal.h"


/**** FnRemove */

INT_PTR CALLBACK FnRemove (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
     {
     DOSDATE dd;
     CHAR   sz[CCHDASHDATE];

     switch (message)
          {
          case WM_INITDIALOG:
               /* Remember the window handle of the dialog for AlertBox. */
               vhwndDialog = hwnd;

#ifdef OLDWAY
               /*
                * NT Bug 9019 says this should start from today's date,
                * but I personally think the function is more useful this way,
                * so I will leave the code here and just ifdef it out incase
                * I can convince others to let me put it back in.
                * 30-Jan-1993 JonPa
                */

               /* Get date string for 1-1-1980 */
               dd.month = 1;
               dd.day = 1;
               dd.year = 1980;
               GetDateString(&dd, sz, GDS_SHORT);
#else
               /* Get date string for currently selected day */
               GetDashDateSel (sz);
#endif
               SetDlgItemText (hwnd, IDCN_FROMDATE, sz);
               return (TRUE);

	  case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                    case IDOK:
			 GetRangeOfDates (hwnd);
			 /* line added to fix keyboard hanging problem when
			    Calendar is run under ver 3.0 rel 1.11 */
			 CalSetFocus (GetDlgItem (hwnd, IDCN_FROMDATE));
                         break;

                    case IDCANCEL:
                         EndDialog (hwnd, FALSE);
                         break;
                    }

               return (TRUE);
          }

     /* Tell Windows we did not process the message. */
     return (FALSE);
     }


/**** GetRangeOfDates */

VOID APIENTRY GetRangeOfDates (HWND hwnd)
     {

     CHAR szDateFrom [CCHDASHDATE];
     CHAR szDateTo [CCHDASHDATE];
     D3   d3From;

     GetDlgItemText (hwnd, IDCN_FROMDATE, szDateFrom, CCHDASHDATE);
     if (GetDlgItemText (hwnd, IDCN_TODATE, szDateTo, CCHDASHDATE) == 0)
          lstrcpy (szDateTo, szDateFrom);

     if (FD3FromDateSz (szDateFrom, &d3From) == 0
      && FD3FromDateSz (szDateTo, &vd3To) == 0
      && (vdtFrom = DtFromPd3 (&d3From)) <= (vdtTo = DtFromPd3 (&vd3To)))
          {
          /* Get the index of the first date in the range.  Note that if the
             date doesn't exist in the tdd, the index of the first date
             higher than it is returned.
          */
          FSearchTdd (vdtFrom, &vitddFirst);

          /* Get the index of the last date in the range + 1.  If an exact
             match is found, increment to get the one beyond the range.
           */
          if (FSearchTdd (vdtTo, &vitddMax))
               vitddMax++;

          EndDialog (hwnd, TRUE);
          }
     else
          {
          /* Error in date - put up message box. */
          AlertBox (vszBadDateRange,
           NULL, MB_APPLMODAL | MB_OK | MB_ICONASTERISK);
          }
     }


/**** Remove  - remove the dates within the range vd3From through vd3To.
      Call with vdtFrom <= vdtTo since Remove depends on this.
      Also, vitddFirst <= vitddLast.
*/

VOID APIENTRY Remove ()

     {

     register WORD idr;
     register DR *pdr;

     /* Show the hour glass cursor. */
     HourGlassOn ();

     /* Record edits and disable focus so edits don't get recorded later
        into a DR that has been removed.
     */
     CalSetFocus (NULL);

     /* Free up any DRs within the range of dates to be removed. */
     for (idr = 0; idr < CDR; idr++)
          {
          /* Get a pointer to the DR. */
          pdr = PdrLock (idr);

          if (pdr -> dt >= vdtFrom && pdr -> dt <= vdtTo)
               pdr -> dt = DTNIL;

          /* Unlock the DR. */
          DrUnlock (idr);
          }

     /* Get rid of the dates. */
     ShrinkTdd (vitddFirst, vitddMax - vitddFirst);

     /* It's possible that the armed alarm has just been wiped out.  If so,
        we need to arm a higher one (if there is one).  By calling GetNextAlarm
        with vftAlarmNext, the current alarm will be kept if it hasn't been
        removed.  If it has been removed, the next highest alarm will get
        armed.  Note - there is no need to call AlarmCheck here - the
        new alarm is greater than or equal to the old one, and the old
        one had not gone off yet.
     */
     GetNextAlarm (&vftAlarmNext, &vftAlarmNext, TRUE, NULL);

     /* The date being displayed may have been removed, so update the
        display accordingly.  In day mode, only removing the day being
        displayed matters, but in month mode, removing any marked days
        in the current month requires a redisplay.  It doesn't seem worth
        the trouble to check for these cases and only update the display
        for them, so the display is updated in all cases.
     */
     if (vfDayMode)
          {
          /* This can't fail since the selected date is either still in
             memory (it wasn't removed) or it was removed and won't require
             disk I/O to create (since it has no longer has any data).
             Note that SwitchToDate will set the focus (which we turned
             off above).
          */
          SwitchToDate (&vd3Sel);
          }
     else
          {
          /* Reset the focus.
             Call UpdateMonth since marked days in the current month may
             have been removed.  UpdateMonth will also call SetNotesEc,
             which is necessary since the notes for the selected date may
             have been removed.  Note that vwDaySticky has not changed,
             so the correct day will get selected by UpdateMonth.
          */
          CalSetFocus (vhwndFocus);
          vd3To = vd3Sel;
          UpdateMonth ();
          }

     /* Remove makes the file dirty. */
     vfDirty = TRUE;

     /* The waiting is over. */
     HourGlassOff ();

     }


/* Calls to HourGlassOn and HourGlassOff are always balanced, but they
   may be nested.  For example, LoadCal calls HourGlassOn, then it
   calls CleanSlate.  Cleanslate calls HourGlassOn, does its stuff,
   calls HourGlassOff, and returns to LoadCal.  LoadCal does the
   rest of its stuff and calls HourGlassOff.  To handle this nesting
   cleanly and without flicker, a count of calls to HourGlassOn
   is kept.  When HourGlassOn increments this count from 0 to 1,
   the handle of the current cursor is saved away.  When HourGlassOff
   decrements this count from 1 to 0, the cursor is restored to the
   saved one.
*/

INT  vcHourGlassOn = 0;
HCURSOR vhcsrPrev;

/**** HourGlassOn - put up the hour glass cursor and remember what
      the cursor was before.
*/

VOID APIENTRY HourGlassOn ()

     {

     register HCURSOR hcsrTemp;

     hcsrTemp = SetCursor (vhcsrWait);
     if (vcHourGlassOn++ == 0)
          vhcsrPrev = hcsrTemp;

     }


/**** HourGlassOff - restore the cursor to what it was before we put
      up the hour glass.
*/

VOID APIENTRY HourGlassOff ()

     {

     if (--vcHourGlassOn == 0)
          SetCursor (vhcsrPrev);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\caltdd.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** caltdd.c
 *****
*/

#include "cal.h"


#define CDDMAX 512       /* Max number of DD in the tdd. */
#define CDDEXTRA 8       /* When grabbing more memory for the tdd,
                            allocate CDDEXTRA extra DDs.  This avoids
                            doing a ReAlloc for each DD needed, so
                            things happen faster.
                         */


/**** InitTdd - Initialize the tdd.  */

VOID APIENTRY InitTdd ()
{
	//- InitTdd: Fixed to take care of bug with LocalReAlloc of returning
	//- NULL when the original block is already of size zero.
	//- Now just free and allocate later.
	if (vcddAllocated != 0 && vhlmTdd)
	{
		LocalFree (vhlmTdd);
	}
	vcddUsed = vcddAllocated = 0;
	vhlmTdd = (LOCALHANDLE)NULL;
}


/**** FSearchTdd - Search the tdd for the specified DT.
      If found, return TRUE and the index of the matching entry.
      If not found, return FALSE and the index of where to insert (the
      first dd having a DT greater than the one searched for).
*/

BOOL APIENTRY FSearchTdd (
    DT   dt,            /* Input - Date to search for. */
    INT  *pitdd)        /* Output - index of match or insertion point if no
			   match.
			*/
     {

     /* Note - it's important that the indices be declared as signed
        ints since it's possible for itddHigh to go to -1 (if the
        item being searched for is less than the first entry in the
        table).  If it were necessary for the indices to be unsigned
        (to allow a larger table size), some coding changes would be
        necessary, but for this application ints will work fine since
        the table will not be allowed to exceed 32767 entries (in fact,
        the limit will be much lower).
     */
     register INT  itddLow;
     register INT  itddHigh;
     BOOL fFound;
     DD   *pddFirst;
     DT   dtTemp;
     BOOL fGreater;

     /* Lock down the tdd and get the address of the first dd in it. */
     pddFirst = TddLock ();

     /* Note - in case the tdd is empty, initialize the insertion point
        to 0 for the caller.  Also set fGreater to FALSE so if the tdd is
        empty, the 0 in itdd will get returned without being incremented.
     */
     *pitdd =  itddLow = 0;
     itddHigh = vcddUsed - 1;
     fFound = fGreater = FALSE;

     while (itddLow <= itddHigh && !fFound)
          {
          fGreater = FALSE;
          *pitdd = (itddLow + itddHigh) / 2;

          if (dt == (dtTemp = (pddFirst + *pitdd) -> dt))
               fFound = TRUE;

          else if (dt > dtTemp)
               {
               fGreater = TRUE;
               itddLow = *pitdd + 1;
               }

          else
               itddHigh = *pitdd - 1;
          }

     TddUnlock ();

     /* The search item was greater than the table item on the last
        comparison made.  Return the index of the next higher table
        entry, since this is the insertion point.  Note that if
        dt == dtTemp, the index is already that of the matching item,
        and if dt < dtTemp, the index is already that of the insertion
        point.
     */
     if (fGreater)
          (*pitdd)++;

     return (fFound);
     }


/**** FGrowTdd - Grow the tdd by the specified number of DD at the specified
      place.  If can't grow that much, put up an error message then return
      FALSE.  If successful, return TRUE.
*/
BOOL APIENTRY FGrowTdd (
    INT  itdd,               /* INPUT - Where the insertion occurs. */
    INT  cdd)                /* INPUT - How many DD to insert. */
{

	DD   *pdd;
	register  INT cddUsedNew;
	register  INT cddAllocatedNew;

	if ((cddUsedNew = vcddUsed + cdd) > CDDMAX)
	{
		/* Can't make it that big. */
		AlertBox (vszTooManyDates, (CHAR *)NULL,
				MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
		return (FALSE);
	}

	if (cddUsedNew > vcddAllocated)
	{
		/* We must allocate some more memory to the tdd.  Allocate
		   more than we need right now to avoid always having to allocate
		   for each new DD.
		*/
		cddAllocatedNew = cddUsedNew + CDDEXTRA;


		//- GrowTdd: Fixed to call LocalAlloc instead of LocalReAlloc because
		//- of bug in LocalReAlloc with zero size allocation.
		if (vcddAllocated == 0 || vhlmTdd == 0)
		{
			if ((vhlmTdd = LocalAlloc (LMEM_MOVEABLE,
					cddAllocatedNew * sizeof (DD))) == (LOCALHANDLE)NULL)
			{
				/* Could not get the requested memory. */
				AlertBox (vszOutOfMemory, (CHAR *)NULL,
						MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
				return (FALSE);
			}
		}
		else
		{
			if ((vhlmTdd = LocalReAlloc (vhlmTdd, cddAllocatedNew * sizeof (DD),
					LMEM_MOVEABLE)) == (LOCALHANDLE)NULL)
			{
				/* Could not get the requested memory. */
				AlertBox (vszOutOfMemory, (CHAR *)NULL,
						MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
				return (FALSE);
			}
		}

		vcddAllocated = cddAllocatedNew;
	}

	/* Block transfer up all DD at or beyond the insertion point. */
	pdd = TddLock () + itdd;
	BltByte ((BYTE *)pdd, (BYTE *)(pdd + cdd),
			(WORD)(sizeof (DD) * (vcddUsed - itdd)));
	TddUnlock ();

	vcddUsed = cddUsedNew;
	return (TRUE);
}


/**** ShrinkTdd - Shrink the tdd by the specified number of DD. */

VOID APIENTRY ShrinkTdd (
    INT  itdd,               /* The index of the first DD to be deleted. */
    INT  cdd)                /* The number of DD to be deleted. */
{

	register DD   *pdd;
	register INT  cddAllocatedNew;

	/* Lock the tdd, and get a pointer to the deletion point. */
	pdd = TddLock () + itdd;

	/* Block transfer down all dd beyond the deletion point. */
	BltByte ((BYTE *)(pdd + cdd), (BYTE *)pdd,
			(WORD)(sizeof (DD) * (vcddUsed - (itdd + cdd))));

	/* Adjust the count of dd. */
	vcddUsed -= cdd;

	TddUnlock ();

	if (vcddAllocated > (cddAllocatedNew = vcddUsed + CDDEXTRA))
	{
		/* There's more than CDDEXTRA free DDs now, so free up the
		   extra ones.
		*/
		//- ShrinkTdd: Fixed to handle bug in LocalReAlloc when trying to do
		//- realloc of size zero.
		if ((vcddAllocated = cddAllocatedNew) == 0)
		{

			if (vhlmTdd)
				vhlmTdd = LocalFree (vhlmTdd);
		}
		else
		{
			if (vhlmTdd)
				vhlmTdd = LocalReAlloc (vhlmTdd, cddAllocatedNew * sizeof (DD),
						LMEM_MOVEABLE);
		}
	}
}


/**** BltByte - Block transfer a range of bytes either up or down. */

BYTE * APIENTRY BltByte (
    BYTE *pbSrc,
    BYTE *pbDst,
    UINT cb)
{

	register BYTE *pbMax;

	pbMax = pbDst + cb;

	if (pbSrc >= pbDst)
	{
		/* Transferring down (from high to low addresses).
		   Start at the beginning of the block and work
		   towards higher addresses to avoid overwrite.
		*/
		while (cb-- != 0)
			*pbDst++ = *pbSrc++;
	}
	else
	{
		/* Transferring up (from low to high addresses).
		   Start at the end of the block and work towards lower
		   addresses to avoid overwrite.
		*/
		pbSrc += cb;
		pbDst = pbMax;
		while (cb-- != 0)
			*--pbDst = *--pbSrc;
	}

	/* Return a pointer to the first byte following those moved to the
	   destination.
	*/
	return (pbMax);
}


/**** DeleteEmptyDd - delete DD from tdd if the DD is "empty".
      The DD is "empty" if the date is not marked and it has
      no longer has any data (on disk or in memory).  Note that
      it cannot have any alarms if there are no Qrs for it, so
      there is no need to check cAlarms.  If it is empty, get rid of the DD.
*/

VOID APIENTRY DeleteEmptyDd (INT itdd)
{

	register DD *pdd;
	register BOOL fEmpty;

	pdd = TddLock () + itdd;
	fEmpty = !pdd -> fMarked && pdd -> dl == DLNIL && pdd -> idr == IDRNIL;
	TddUnlock ();
	if (fEmpty)
		ShrinkTdd (itdd, 1);
}


/**** TddLock */

DD   * APIENTRY TddLock ()

{
	return ((DD *)LocalLock (vhlmTdd));
}


/**** TddUnlock */

VOID APIENTRY TddUnlock ()

{
	LocalUnlock (vhlmTdd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\calendar\caltqr.c ===
/*
 *   Windows Calendar
 *   Copyright (c) 1985 by Microsoft Corporation, all rights reserved.
 *   Written by Mark L. Chamberlin, consultant to Microsoft.
 *
*/

/*
 *****
 ***** caltqr.c
 *****
*/

#include "cal.h"


/**** FSearchTqr */

BOOL APIENTRY FSearchTqr (TM tm)
     {

     BYTE *pbPrev;
     BYTE *pbCur;
     BYTE *pbNext;
     BYTE *pbFirst;
     BYTE *pbMax;
     BOOL fFound;
     DR   *pdr;

     pdr = PdrLockCur ();
     votqrPrev = votqrCur = OTQRNIL;
     votqrNext = pdr -> cbTqr;
     pbMax = (pbCur = pbFirst = PbTqrFromPdr (pdr)) + pdr -> cbTqr;
     fFound = FALSE;

     while (pbCur < pbMax)
          {
          pbNext = pbCur + ((PQR )pbCur) -> cb;

          if (((PQR )pbCur) -> tm == tm)
               {
               votqrCur = (WORD)(pbCur - pbFirst);
               votqrNext = (WORD)(pbNext - pbFirst);
               fFound = TRUE;
               break;
               }

          else if (((PQR )pbCur) -> tm > tm)
               {
               votqrNext = (WORD)(pbCur - pbFirst);
               break;
               }

          pbPrev = pbCur;
          pbCur = pbNext;

          }

     if (pbCur != pbFirst)
          votqrPrev = (WORD)(pbPrev - pbFirst);

     DrUnlockCur ();
     return (fFound);
     }


/**** StoreQd - Move the appointment description from the edit control
      into the tqr.
      No need to check for room in DR here since we have been monitoring
      key strokes and checking for room.
*/

VOID APIENTRY StoreQd ()

     {

     BYTE rgbQrBuf [CBQRHEAD + CCHQDMAX + 1];
     CHAR szqdOld [CCHQDMAX + 1];
     INT  cchqdOld;
     INT  cchqdNew;
     WORD otqr;
     BYTE *pb;
     BOOL fSame;
     register INT ln;

     /* Copy into register variable to save code. */
     ln = vlnCur;

     /* Fetch the text from the edit control. */
     cchqdNew = (int)SendMessage (vhwnd3, WM_GETTEXT, CCHQDMAX + 1,
      (LPARAM)(rgbQrBuf + CBQRHEAD));

     *szqdOld = '\0';
     cchqdOld = 0;
     pb = PbTqrLock ();
     if ((otqr = vtld [ln].otqr) != OTQRNIL)
          {
          cchqdOld = ((PQR )(pb + otqr)) -> cb - CBQRHEAD - 1;
          lstrcpy (szqdOld, (CHAR *)(pb + otqr + CBQRHEAD));
          }
     fSame = cchqdOld == cchqdNew
      && lstrcmp ((LPSTR)szqdOld, (LPSTR)(rgbQrBuf + CBQRHEAD)) == 0;
     DrUnlockCur ();
     if (fSame)
          {
          /* This thing hasn't changed, so don't waste alot of time. */
          return;
          }

     /* The QD has changed, so mark the DR and the file dirty. */
     PdrLockCur () -> fDirty = vfDirty = TRUE;
     DrUnlockCur ();

     if (otqr == OTQRNIL)
          {
          /* There was no previous QR.  Say there is no alarm set,
             say it's not a special time, and copy in the appointment
             time from the tld.
          */
          ((PQR )rgbQrBuf) -> fAlarm = ((PQR )rgbQrBuf) -> fSpecial = FALSE;
          ((PQR )rgbQrBuf) -> tm = vtld [ln].tm;
          }
     else
          {
          /* There was a previous QR.  Copy it's header information
             (we want the flags and the appointment time) into the
             new QR we're building.
          */
          BltByte (PbTqrLock () + otqr, rgbQrBuf, CBQRHEAD);
          DrUnlockCur ();

          /* Delete the old QR. */
          DeleteQr (otqr);

          /* In case we don't insert a new qr. */
          vtld [ln].otqr = OTQRNIL;

          /* Adjust down the otqrs in the tld beyond the current ln. */
          AdjustOtqr (ln, -((PQR )rgbQrBuf) -> cb);
          }

     /* Set the length of the new QR. */
     ((PQR )rgbQrBuf) -> cb = (WORD)(CBQRHEAD + cchqdNew + 1);

     if (cchqdNew != 0 || ((PQR )rgbQrBuf) -> fAlarm
      || ((PQR )rgbQrBuf) -> fSpecial)
          {
          if (otqr == OTQRNIL)
               {
               /* There was no previous QR, so search the tqr to find
                  out where to put the new one.  Since we know there
                  was no old QR, we know FSearchTqr will not find a
                  match - so we ignore its return value.
               */
               FSearchTqr (vtld [ln].tm);
               otqr = votqrNext;
               }

          FInsertQr (otqr, (PQR )rgbQrBuf);
          vtld [ln].otqr = otqr;

          /* Adjust up the otqrs in the tld beyond the current ln. */
          AdjustOtqr (ln, ((PQR )rgbQrBuf) -> cb);

          }
     }


/**** AdjustOtqr */

VOID APIENTRY AdjustOtqr (
    INT  ln,        /* otqr starting with vtld [ln + 1] are adjusted. */
    INT  cb)        /* The amount to adjust the otqr by (can be negative). */
     {
     while (++ln < vcln)
          {
          if (vtld [ln].otqr != OTQRNIL)
               vtld [ln].otqr += (WORD)cb;
          }
     }


/**** DeleteQr - delete qr from tqr. */

VOID APIENTRY DeleteQr (WORD otqr)
     {

     BYTE *pbTqr;
     BYTE *pbSrc;
     BYTE *pbDst;
     WORD cb;
     DR   *pdr;

     pdr = PdrLockCur ();
     pbDst = (pbTqr = PbTqrFromPdr (pdr)) + otqr;
     pbSrc = pbDst + (cb = ((PQR )pbDst) -> cb);
     BltByte (pbSrc, pbDst, (WORD)(pbTqr + pdr -> cbTqr - pbSrc));
     pdr -> cbTqr -= cb;
     DrUnlockCur ();

     }


/**** FInsertQr - insert qr into tqr. */

BOOL APIENTRY FInsertQr (
    WORD otqr,
    PQR	pqr)
     {

     BYTE *pbTqr;
     register BYTE *pbSrc;
     BYTE *pbDst;
     WORD cb;
     register DR   *pdr;
     BOOL fOk;

     /* Make sure there's enough room. */
     pdr = PdrLockCur ();
     if ((WORD)(fOk = cb = pqr->cb) <= (WORD)(CBTQRMAX - pdr -> cbTqr))
          {
          /* Zero the unused bits. */
          pqr -> reserved = 0;

          pbSrc = (pbTqr = PbTqrFromPdr (pdr)) + otqr;
          pbDst = pbSrc + cb;
          BltByte (pbSrc, pbDst, (WORD)(pbTqr + pdr -> cbTqr - pbSrc));
          BltByte ((BYTE *)(pqr), pbSrc, cb);
          pdr -> cbTqr += cb;
          }
     else
          {
          /* Tell the user the date is full. */
          AlertBox (vszDateIsFull, (CHAR *)NULL,
           MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
          }

     DrUnlockCur ();
     return (fOk);

     }


/**** PbTqrLock - Lock the current DR, returning a pointer to the first
      byte of the embedded Tqr.
*/

BYTE * APIENTRY PbTqrLock ()

     {

     register DR *pdr;

     pdr = PdrLockCur ();
     return (PbTqrFromPdr (pdr));

     }


/**** PdrLockCur - Lock the current DR, returning a pointer to it. */

DR   * APIENTRY PdrLockCur ()

     {

     return (PdrLock (vidrCur));

     }


/**** DrUnlockCur - Unlock the current DR. */

VOID APIENTRY DrUnlockCur ()

     {

     DrUnlock (vidrCur);

     }


/**** PdrLock - lock and return a pointer to the specified DR. */

DR   * APIENTRY PdrLock (UINT idr)
     {
     return ((DR *)LocalLock (vrghlmDr [idr]));
     }


/**** DrUnlock - unlock the specified DR. */

VOID APIENTRY DrUnlock (UINT idr)
     {
     LocalUnlock (vrghlmDr [idr]);
     }


/**** PbTqrFromPdr - Given a pdr, return a pointer to the first byte
      of the embedded tqr.
*/

BYTE * APIENTRY PbTqrFromPdr (DR*pdr)
     {
     return ((BYTE *)pdr + CBDRHEAD + pdr -> cbNotes);
     }


/**** StoreNotes - store the notes into the DR.
      No need to check for room in DR here since we have been monitoring
      key strokes and checking for room.
*/

VOID APIENTRY StoreNotes ()

     {

     BYTE rgbEcNotes [CBNOTESMAX];
     CHAR *szNew;
     CHAR *szOld;
     register INT  cbNew;
     INT  cbMore;
     register DR *pdr;
     BOOL fFormatted;

     /* Set up a pointer to the old notes, using the null string if there
        were no old notes.  Also assume the new notes are empty.
     */
     szNew = szOld = "";
     pdr = PdrLockCur ();
     if (pdr -> cbNotes != 0)
          szOld = (CHAR *)((BYTE *)pdr + CBDRHEAD);

     /* Format the new text.  This inserts <CR,CR,LF> where soft line breaks
        are.  (Hard line breaks are represented by <CR,LF>.)
     */
     fFormatted = (BOOL)SendMessage (vhwnd2C, EM_FMTLINES, TRUE, 0L);

     /* Find out how long the text is (not including the string
        terminator).
     */
     cbNew = (int)SendMessage (vhwnd2C, WM_GETTEXTLENGTH, 0, 0L);

     if (cbNew != 0)
          {
          /* String is not null - will need an extra byte to store the zero
             terminator (which is why we ++cbNew here).
          */
          SendMessage (vhwndFocus, WM_GETTEXT, ++cbNew,
           (LPARAM)(szNew = rgbEcNotes));
          }

     /* If the notes have not changed don't mark the DR dirty or store the
        new (unchanged) text.  (For speed, don't strcmp if length not same.)
     */
     if ((cbMore = cbNew - pdr -> cbNotes) != 0 || lstrcmp ((LPSTR)szOld, (LPSTR)szNew) != 0)
          {
          /* Adjust the hole for the notes if necessary by moving the tqr
             up or down.  Note that the same length case works OK too.
          */
          BltByte (PbTqrFromPdr (pdr), PbTqrFromPdr (pdr) + cbMore,
           pdr -> cbTqr);

          /* Copy in the new string.  Note - can't copy to szOld since
             it is not in the DR if the old string was null.
          */
          BltByte ((BYTE *)szNew, (BYTE *)pdr + CBDRHEAD, cbNew);

          /* Set the new length. */
          pdr -> cbNotes = (WORD)cbNew;

          /* Mark the DR and the file dirty. */
          pdr -> fDirty = vfDirty = TRUE;
          }

     DrUnlockCur ();

     /* Remove soft line breaks. */
     if (fFormatted)
	  SendMessage (vhwnd2C, EM_FMTLINES, FALSE, 0L);

     }


/**** SetNotesEc - Set the text of the notes edit control. */

VOID APIENTRY SetNotesEc ()

     {
     register CHAR *szNotes;
     register DR *pdr;


     szNotes = "";
     if ((pdr = PdrLockCur ()) -> cbNotes != 0)
          szNotes = (CHAR *)((BYTE *)pdr + CBDRHEAD);
     SetEcText(vhwnd2C, szNotes);
     DrUnlockCur ();

     /* Length of text in edit ctl will probably be different than cbNotes
        since formatting info has been removed.  Set selection to end of text
        based on new length. */

     }


/**** EcNotification - handle notifications from edit controls.
      Note - all of the vcbEcTextMax code assumes that the data in the
      DR is up-to-date.  This is the case as long as my assumption that
      you can't get an EN_SETFOCUS for the same edit control without
      having seen an EN_KILLFOCUS in the intervening time.
      (The KILLFOCUS will bring the DR up-to-date because that's when
      we store the data.)
*/

INT  vcbEcTextMax = 32767;    /* This is the maximum number of bytes we can
                                 allow the text of the edit control to grow to.
                                 This does NOT include the zero terminator,
                                 only the space used by the text itself.
                                 We reserve space for the terminator outside
                                 of this count.
                                 Keep it set very large when not otherwise
                                 set up so an EN_CHANGE (which can come in
                                 from a WM_SETTEXT for example) won't
                                 erroneously trigger a DR full situation.
                              */

VOID APIENTRY EcNotification (
    WORD idec,          /* ID of the edit control. */
    WORD en)            /* The notification code. */
     {

     register DR *pdr;
     WORD otqr;
     register BOOL fQd;

     if ((fQd = idec == IDECQD) || idec == IDECNOTES)
          {
          switch (en)
               {
               case EN_SETFOCUS:
                    if (fQd)
                         {
                         vhwndFocus = vhwnd3;

                         /* Assuming there is no QR for this appointment time,
                            we will need room to insert one (CBQRHEAD + 1 (for
                            the string terminator)).  Subtract this from the
                            available space for the tqr to grow to determine
                            the maximum
                            size we can allow for the edit control text.
                            (The available space is given by CBTQRMAX -
                            cbTqr.)
                         */
                         pdr = PdrLockCur ();
                         vcbEcTextMax = CBTQRMAX - CBQRHEAD - 1 - pdr -> cbTqr;
                         if ((otqr = vtld [vlnCur].otqr) != OTQRNIL)
                              {
                              /* There is already a QR for this appointment
                                 time, so the space it's occupying will also
                                 be available.
                              */
                              vcbEcTextMax +=
                               ((PQR )(PbTqrFromPdr (pdr) + otqr)) -> cb;
                              }
                         DrUnlockCur ();

                         /* Don't allow vcbEcTextMax to be negative (which
                            it could be right now if there's no QR for this
                            appointment and the amount of free space for
                            the tqr is less than CBQRHEAD + 1).  By setting it
                            to zero we will prevent any characters from
                            being typed, and the pruning process will work
                            correctly (which it wouldn't for a negative
                            value).
                         */
                         if (vcbEcTextMax < 0)
                              vcbEcTextMax = 0;
                         }
                    else
                         {
                         vhwndFocus = vhwnd2C;

                         /* The notes edit control is not allowed to grow
                            beyond CBNOTESTESTMAX bytes.
                         */
                         vcbEcTextMax = CBNOTESTEXTMAX;
                         }

                    break;

               case EN_KILLFOCUS:
                    /* Put big value in while not in use. */
                    vcbEcTextMax = 32767;

                    if (fQd)
                         {
                         /* Leaving appointment edit control - store away
                            the text if it has changed.
                         */
                         StoreQd ();
                         }
                    else
                         {
                         /* Leaving notes edit control - store away the
                            text if it has changed.
                         */
                         StoreNotes ();
                         }

                    break;

               case EN_ERRSPACE:
                    AlertBox (vszOutOfMemory, (CHAR *) NULL,
                     MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
                    break;

               case EN_MAXTEXT:
                    AlertBox (vszTextTruncated, (CHAR *) NULL,
                     MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
                    break;

               case EN_CHANGE:
                    /* If this change is not for the edit control that has
                       the focus, ignore it.  (This happens for example
                       when we have set the focus to a QD and then set the
                       text of the notes - as when switching to a new date.)
                       If we didn't ignore it we would be comparing the
                       wrong lengths against each other.
                       Also check out of here if we haven't exceeded the
                       maximum text length yet.
                    */
                    if (vhwndFocus == (fQd ? vhwnd3 : vhwnd2C)
                        && ((INT)SendMessage (vhwndFocus, WM_GETTEXTLENGTH,0,0L) > vcbEcTextMax))
                        PruneEcText ();

                    /* Fall into the return. */
               }
          }
     }


/**** PruneEcText - truncate edit control text since it won't fit in the DR.
      This is a separate routine so that the large buffer on the stack
      would not be allocated in EcNotification.  This is because EcNotification
      gets called recursively (because WM_SETTEXT causes an EN_CHANGE) and
      it also calls StoreNotes which also uses a large buffer on the stack.
*/

VOID APIENTRY PruneEcText ()

     {

     BYTE rgbEcTextBuf [CBNOTESMAX];
     register BYTE *pbCur;
     INT  cbEcText;
     INT  cbTemp;

     /* That last change made the text too big to fit in
        the DR.  Truncate the text, and tell the user about it.
     */
     SendMessage (vhwndFocus, WM_GETTEXT, CBNOTESMAX, (LPARAM)rgbEcTextBuf);

     /* Truncate what doesn't fit, being careful not
        to truncate in the middle of a multi-byte
        character (Kanji).
        Note that this loop is guaranteed to execute at
        least once (since 0 has to be <= vcbEcTectMax), so
        cbEcText will definitely get set.
     */
     for (pbCur = rgbEcTextBuf;
         (cbTemp = (int)(pbCur - rgbEcTextBuf)) <= vcbEcTextMax;
         pbCur = (BYTE *)AnsiNext ((LPSTR)pbCur))
             cbEcText = cbTemp;

     /* cbEcText now contains the count of bytes in the
        the characters that would fit (not including the
        string terminator).  Put in the terminator.
     */
     rgbEcTextBuf [cbEcText] = '\0';

     /* Put the shortened text back into the edit control.
        This will put the caret
        at the end of the text and redisplay.  (Putting
        the caret at the end is good since it draws the
        user's attention to where the chopping occurred.)

        Note that this WM_SETTEXT will cause an EN_CHANGE, but the
        text will no longer be too long so we will not end up
        recursing into PruneEcText (which we want to avoid due
        to the large buffer on the stack).
     */
     SetEcText(vhwndFocus, rgbEcTextBuf);

     /* Tell the user the bad news. */
     AlertBox (vszDateIsFull, vszTextTruncated,
      MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);

     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\auditchk.h ===
/******************************************************************************

                        A U D I T   C H E C K

    Name:       auditchk.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for auditchk.c

******************************************************************************/




#define AUDIT_PRIVILEGE_CHECK 0
#define AUDIT_PRIVILEGE_ON    1
#define AUDIT_PRIVILEGE_OFF   2



BOOL AuditPrivilege(
    int fAudit);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\callback.h ===
/*****************************************************************************

                        D D E   C A L L B A C K

    Name:       callback.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for callback.c

*****************************************************************************/



HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2);


DWORD GetClipsrvVersion(
    HWND    hwndChild);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\callback.c ===
/*****************************************************************************

                            D D E   C A L L B A C K

    Name:       callback.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:

    History:
        Date        Description
        ----------- -------------------------------------------------------
        10-Apr-1996 johnfu, added retry count for RQ_PREVBITMAP
        03-Nov-1997 drewm, added code to fix bug 3168
*****************************************************************************/





#include <windows.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "callback.h"
#include "debugout.h"
#include "cvutil.h"





// internal forwards

static HWND GetConvHwnd ( HCONV hConv );




/*
 *      DdeCallback
 *
 *  ddeml callback routine
 */

HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2)
{
HWND        hwndTmp;
CONVINFO    ConvInfo;
PDATAREQ    pDataReq;


    switch (wType)
        {
        case XTYP_ADVDATA:
            if ( hwndTmp = GetConvHwnd ( hConv ) )
                {
                InitListBox ( hwndTmp, hData );
                }
            return FALSE;
            break;

        case XTYP_DISCONNECT:
            ConvInfo.cb = sizeof(CONVINFO);
            if (DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0)
                {
                PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
                   (DWORD_PTR)hConv, DdeGetLastError(idInst));
                break;
                }
            if (pDataReq = (PDATAREQ)ConvInfo.hUser)
                {
                PINFO(TEXT("Freeing data req on %lx at disconnect time\n\r"), hConv);
                MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                              MB_OK | MB_ICONSTOP);
                ProcessDataReq   (0, pDataReq);
                DeleteDataReq    (pDataReq);
                DdeSetUserHandle (hConv, (DWORD)QID_SYNC, 0L);
                }
            else
                {
                PINFO(TEXT("Disconnect received on %lx - no datareq\n\r"), hConv );
                }
            break;

        case XTYP_XACT_COMPLETE:
            ConvInfo.cb = sizeof(CONVINFO);
            if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
                {
                PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
                   (DWORD_PTR)hConv, DdeGetLastError(idInst));
                break;
                }

            PINFO(TEXT("dde callback: got %lx data from conv handle %p\n\r"),
                ConvInfo.hUser, (DWORD_PTR)hConv );

            pDataReq = (PDATAREQ)ConvInfo.hUser;

            if (hData)
                ProcessDataReq (hData,  pDataReq);
            else
                {
                if (RQ_PREVBITMAP == pDataReq->rqType &&
                    pDataReq->wRetryCnt)
                    {
                    LPLISTENTRY lpLE;
                    HWND        hwnd;
                    INT         iItem;
                    WORD        wRetryCnt;

                    wRetryCnt = pDataReq->wRetryCnt;
                    hwnd      = pDataReq->hwndMDI;
                    iItem     = pDataReq->iListbox;

                    SendMessage (GETMDIINFO(hwnd)->hWndListbox,
                                 LB_GETTEXT,
                                 iItem,
                                 (LPARAM)&lpLE);

                    GetPreviewBitmap (hwnd, lpLE->name, iItem);

                    pDataReq->wRetryCnt = wRetryCnt -1;
                    break;
                    }

                RequestXactError (hConv);
                XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                }


            DdeSetUserHandle (hConv, (DWORD)QID_SYNC, 0L);


            if (pDataReq->fDisconnect)
                {
                DdeDisconnect (hConv);
                }

            DeleteDataReq (pDataReq);
            break;

        case XTYP_REGISTER:
        case XTYP_UNREGISTER:
        case XTYP_ADVREQ:
        case XTYP_REQUEST:
        case XTYP_ADVSTART:
        case XTYP_CONNECT_CONFIRM:
        case XTYP_CONNECT:
        default:
            break;
        }

    return 0;

}






/*
 *      GetConvHwnd
 *
 *  this function retrieves the window handle associated with
 *  a conversation handle - the hande is put there by
 *  using DdeSetUserHandle at DdeConnect time
 */

static HWND GetConvHwnd ( HCONV hConv )
{
CONVINFO    ConvInfo;
PDATAREQ    pDataReq;


    ConvInfo.cb = sizeof(CONVINFO);
    if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
        {
        PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
           (DWORD_PTR)hConv, DdeGetLastError(idInst));
        }

    pDataReq = (PDATAREQ)ConvInfo.hUser;

    PINFO(TEXT("GetConvHwnd: got %p as conv handle\r\n"), pDataReq);

    if ( !IsWindow ( pDataReq->hwndMDI ) )
        {
        PERROR(TEXT("Invalid window %p in conv Uhandle: %p!\n\r"),
           (DWORD_PTR)pDataReq->hwndMDI, (DWORD_PTR)hConv );
        return NULL;
        }

    return pDataReq->hwndMDI;

}









/*
 *      GetClipsrvVersion
 *
 *  Purpose: Get the version of Clipsrv connected to the given MDI
 *     child.
 *
 *  Parameters:
 *     hwndChild - The child window.
 *
 *  Returns:
 *     A version number with the Clipsrv OS version in the hiword, and
 *     the Clipsrv version in the loword.
 *
 *     Hiword values:
 *        0 - Win 3.x
 *        1 - NT 1.x
 *
 *     Loword values:
 *        0 - WFW 1.0 Clipsrv
 *        1 - NT  1.0 Clipsrv, adds [version] and [security] executes
 */

DWORD GetClipsrvVersion(
    HWND    hwndChild)
{
MDIINFO     *pMDI;
HDDEDATA    hdde;
DWORD       dwRet;
char        *lpszDDE;


    dwRet = 0;

    if (!(pMDI = GETMDIINFO(hwndChild)))
        return 0;


    if (!(pMDI->flags & F_CLPBRD))
        {
        hdde = MySyncXact (SZCMD_VERSION,
                           lstrlen(SZCMD_VERSION) + 1,
                           pMDI->hExeConv,
                           0L,
                           CF_TEXT,
                           XTYP_EXECUTE,
                           SHORT_SYNC_TIMEOUT, NULL);

        if (hdde)
            {
            lpszDDE = (char *)DdeAccessData(hdde, &dwRet);

            if (lpszDDE)
                {
                dwRet = MAKELONG(lpszDDE[0] - '0', lpszDDE[2] - '0');
                }
            else
                {
                dwRet = 0L;
                }

            DdeUnaccessData (hdde);
            DdeFreeDataHandle (hdde);
            }
        else
            {
            PINFO(TEXT("Clipsrv didn't like version execute\r\n"));
            }
        }
    else
        {
        PERROR(TEXT("No Clipsrv for clipboard!\r\n"));
        }

    return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clipbook.h ===
/*****************************************************************************

                        C L I P B O O K   H E A D E R

    Name:       clipbook.h
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for all files in clipview directory.

    History:
        21-Jan-1994     John Fu, reformat, cleanup, and removed all externs.

*****************************************************************************/




#include   <commdlg.h>
#include   <ddeml.h>
#include   <nddeapi.h>
#include   "clpbkrc.h"
#include   "vclpbrd.h"






#define SetStatusBarText(x) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM)(LPSTR)(x));







/**********************

    Data structures

**********************/



/*
 *  Per MDI client data
 */

struct MdiInfo {
   HCONV    hExeConv;                       // Used for sync transaction only
   HCONV    hClpConv;                       // Used for async transaction only
   HSZ      hszClpTopic;
   HSZ      hszConvPartner;
   HSZ      hszConvPartnerNP;
   HWND     hWndListbox;
   WORD     DisplayMode;
   WORD     OldDisplayMode;
   DWORD    flags;

   TCHAR    szBaseName[ (MAX_COMPUTERNAME_LENGTH+1) * 2];

   TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

   UINT     CurSelFormat;
   LONG     cyScrollLast;
   LONG     cyScrollNow;
   int      cxScrollLast;
   int      cxScrollNow;
   RECT     rcWindow;
   WORD     cyLine, cxChar, cxMaxCharWidth; // Size of a standard text char
   WORD     cxMargin, cyMargin;             // White border size around clip data area
   BOOL     fDisplayFormatChanged;

   PVCLPBRD pVClpbrd;
   HCONV    hVClpConv;
   HSZ      hszVClpTopic;

   // scrollbars, etc. for the paging control

   HWND     hwndVscroll;
   HWND     hwndHscroll;
   HWND     hwndSizeBox;
   HWND     hwndPgUp;
   HWND     hwndPgDown;
};





typedef struct MdiInfo   MDIINFO;
typedef struct MdiInfo * PMDIINFO;
typedef struct MdiInfo FAR * LPMDIINFO;










/*
 *  data request record
 */

#define      RQ_PREVBITMAP   10
#define      RQ_COPY         11
#define      RQ_SETPAGE      12
#define      RQ_EXECONV      13

struct DataRequest_tag
   {
   WORD   rqType;      // one of above defines
   HWND   hwndMDI;
   HWND   hwndList;
   UINT   iListbox;
   BOOL   fDisconnect;
   WORD   wFmt;
   WORD   wRetryCnt;
   };

typedef struct DataRequest_tag DATAREQ;
typedef struct DataRequest_tag * PDATAREQ;







/*
 *  Owner draw listbox data structure
 */

#define MAX_PAGENAME_LENGTH MAX_NDDESHARENAME

struct ListEntry_tag
   {
   TCHAR name[MAX_PAGENAME_LENGTH + 1];
   HBITMAP hbmp;
   BOOL fDelete;
   BOOL fTriedGettingPreview;
   };

typedef struct ListEntry_tag LISTENTRY;
typedef struct ListEntry_tag * PLISTENTRY;
typedef struct ListEntry_tag FAR * LPLISTENTRY;








/*
 *  Extra window data for MDI child registerclass
 *  contains a pointer to above MDIINFO struct
 */

#define GWL_MDIINFO     0
#define CBWNDEXTRA      sizeof(LONG_PTR)

// per MDI window flags - used for MDIINFO.flags

#define F_LOCAL         0x00000001
#define F_CLPBRD        0x00000002

// per MDI display mode - MDIINFO.DisplayMode

#define DSP_LIST        10
#define DSP_PREV        11
#define DSP_PAGE        12






/*
 *  Data structure used to pass share info to SedCallback
 */

typedef struct
   {
   SECURITY_INFORMATION si;
   WCHAR awchCName[MAX_COMPUTERNAME_LENGTH + 3];
   WCHAR awchSName[MAX_NDDESHARENAME + 1];
   }
   SEDCALLBACKCONTEXT;








/*
 *  Data structure passed to KeepAsDialogProc (Paste)
 */

typedef struct
    {
    BOOL    bAlreadyExist;
    BOOL    bAlreadyShared;
    TCHAR   ShareName[MAX_NDDESHARENAME +2];
    }
    KEEPASDLG_PARAM, *PKEEPASDLG_PARAM;






/*************

    Macros

*************/



#define PRIVATE_FORMAT(fmt)     ((fmt) >= 0xC000)
#define GETMDIINFO(x)           (x? (PMDIINFO)(GetWindowLongPtr((x),GWL_MDIINFO)): NULL)



// parameter codes for MyGetFormat()
#define GETFORMAT_LIE       200
#define GETFORMAT_DONTLIE   201


// default DDEML synchronous transaction timeouts
// note these should be generous
#define SHORT_SYNC_TIMEOUT  (24L*1000L)
#define LONG_SYNC_TIMEOUT   (60L*1000L)


// owner draw listbox and bitmap metrics constants
#define LSTBTDX             16              // width of folder ( with or without hand )
#define LSTBTDY             16              // height of folder ( with or without hand )

#define SHR_PICT_X          0               // offsets of shared folder bitmap
#define SHR_PICT_Y          0
#define SAV_PICT_X          16              // offsets of non-shared folder bitmap
#define SAV_PICT_Y          0

#define PREVBRD             4               // border around preview bitmaps

#define BTNBARBORDER        2
#define DEF_WIDTH           400             // initial app size
#define DEF_HEIGHT          300

#define SZBUFSIZ            MAX_DDE_EXEC

#define ARRAYSIZE(a)        (sizeof(a)/sizeof((a)[0]))




// combined styles for owner draw listbox variants
#define LBS_LISTVIEW        (LBS_OWNERDRAWFIXED|LBS_DISABLENOSCROLL)
#define LBS_PREVIEW         (LBS_MULTICOLUMN|LBS_OWNERDRAWFIXED)





//////////// compile options //////////////
#define MAX_ALLOWED_PAGES       127



#define WINDOW_MENU_INDEX       4
#define DISPLAY_MENU_INDEX      3   // submenu to put format entries i.e. "&Text"
#define SECURITY_MENU_INDEX     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clipbrd.h ===
/******************************************************************************

                        C L I P B R D   H E A D E R

    Name:       clipbrd.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header for clipbrd.c

    History:
        19-Apr-1994 John Fu     Add DDE_DIB2BITMAP.

******************************************************************************/




// used for winnet server browse call

#define WNETBROWSEENTRYPOINT    146
#define BIGRCBUF                64
#define SMLRCBUF                32

#define DDE_DIB2BITMAP          0xFFFFFFFF




extern  HANDLE  hmutexClp;
extern  HANDLE  hXacting;
extern  HANDLE  hmodNetDriver;


extern  HICON   hicClipbrd;
extern  HICON   hicClipbook;
extern  HICON   hicRemote;




extern  HICON   hicLock;                    // Icon for Lock on thumbnail bitmaps
extern  HFONT   hfontUni;                   // Handle for Unicode font, if it exists




// Application-wide flags

extern  BOOL    fStatus;                    // status bar shown?
extern  BOOL    fToolBar;                   // tool bar shown?
extern  BOOL    fShareEnabled;              // sharing allowed in system.ini?
extern  BOOL    fNetDDEActive;              // NetDDE detected?
extern  BOOL    fAppLockedState;            // app UI locked (see LockApp())
extern  BOOL    fClipboardNeedsPainting;    // indicates deferred clp paint
extern  BOOL    fSharePreference;           // shared checked on paste?
extern  BOOL    fNeedToTileWindows;         // need to tile windows on size
extern  BOOL    fAppShuttingDown;           // in process of closing
extern  BOOL    fFillingClpFromDde;         // in process of adding clp formats
extern  BOOL    fAuditEnabled;

extern  HWND    hwndNextViewer;             // for clpbrd viewer chain
extern  HWND    hwndDummy;                  // used as dummy SetCapture target



// special case clipboard formats

extern  UINT    cf_bitmap;                      // we send/receive these in private 'packed' format
extern  UINT    cf_metafilepict;
extern  UINT    cf_palette;

extern  UINT    cf_preview;                     // PREVBMPSIZxPREVBMPSIZ preview bitmap private format



// these are formats that contain untranslated copies of link and objlink data

extern  UINT    cf_objectlinkcopy;
extern  UINT    cf_objectlink;
extern  UINT    cf_linkcopy;
extern  UINT    cf_link;




// DDEML

// These are effective constants created once and destroyed when we die

extern  HSZ     hszSystem;
extern  HSZ     hszTopics;
extern  HSZ     hszDataSrv;
extern  HSZ     hszFormatList;
extern  HSZ     hszClpBookShare;


extern  DWORD   dwCurrentHelpId ;



// instance proc from MSGF_DDEMGR filter

extern  WINDOWPLACEMENT Wpl;
extern  HOOKPROC        lpMsgFilterProc;
extern  HINSTANCE       hInst;
extern  HACCEL          hAccel;

extern  HFONT           hOldFont;
extern  HFONT           hFontStatus;
extern  HFONT           hFontPreview;



extern  HWND        hwndActiveChild;    // this handle identifies the currently active MDI window

extern  PMDIINFO    pActiveMDI;         // this pointer points to the MDI info struct of the
                                        // active MDI window IT SHOULD ALWAYS ==
                                        // GETMDIINFO(hwndActiveChild)


extern  HWND        hwndClpbrd;         // this handle identifies the clipboard window
extern  HWND        hwndLocal;          // this handle identifies the local clipbook window
extern  HWND        hwndClpOwner;       // this handle identifies the clipboard owning MDI child (if any)
extern  HWND        hwndMDIClient;      // handle to MDI Client window
extern  HWND        hwndApp;            // global app window
extern  HDC         hBtnDC;             // memory DC used for owner draw stuff
extern  HBITMAP     hOldBitmap;
extern  HBITMAP     hPreviewBmp;
extern  HBITMAP     hPgUpBmp;
extern  HBITMAP     hPgDnBmp;
extern  HBITMAP     hPgUpDBmp;
extern  HBITMAP     hPgDnDBmp;

extern  int         dyStatus;           // height of status bar
extern  int         dyButtonBar;        // height of button bar
extern  int         dyPrevFont;         // height of listbox font - height+external



extern  TCHAR       szHelpFile[];
extern  TCHAR       szChmHelpFile[];

extern  TCHAR       szClipBookClass[];  // frame window class
extern  TCHAR       szChild[];          // Class name for MDI window
extern  TCHAR       szDummy[];          // class name of hidden dummy window

extern  TCHAR       szNDDEcode[];
extern  TCHAR       szNDDEcode1[];
extern  TCHAR       szClpBookShare[];


// localized strings
extern  TCHAR       szHelv[SMLRCBUF];   // status line font
extern  TCHAR       szAppName[SMLRCBUF];
extern  TCHAR       szLocalClpBk[SMLRCBUF];
extern  TCHAR       szSysClpBrd[SMLRCBUF];
extern  TCHAR       szDataUnavail[BIGRCBUF];
extern  TCHAR       szReadingItem[BIGRCBUF];
extern  TCHAR       szViewHelpFmt[BIGRCBUF];
extern  TCHAR       szActivateFmt[BIGRCBUF];
extern  TCHAR       szRendering[BIGRCBUF];
extern  TCHAR       szDefaultFormat[BIGRCBUF];
extern  TCHAR       szGettingData[BIGRCBUF];
extern  TCHAR       szEstablishingConn[BIGRCBUF];
extern  TCHAR       szClipBookOnFmt[BIGRCBUF];
extern  TCHAR       szPageFmt[SMLRCBUF];
extern  TCHAR       szPageFmtPl[SMLRCBUF];
extern  TCHAR       szPageOfPageFmt[SMLRCBUF];
extern  TCHAR       szDelete[SMLRCBUF];
extern  TCHAR       szDeleteConfirmFmt[SMLRCBUF];
extern  TCHAR       szFileFilter[BIGRCBUF];
extern  TCHAR       *szFilter;




// Registry key strings
extern  TCHAR       szPref[];
extern  TCHAR       szConn[];
extern  TCHAR       szStatusbar[];
extern  TCHAR       szToolbar[];
extern  TCHAR       szShPref[];
extern  TCHAR       szEnableShr[];
extern  TCHAR       szDefView[];


#if DEBUG
extern  TCHAR       szDebug[];
#endif
extern  TCHAR       szNull[];



HKEY hkeyRoot;


// buffers
extern  TCHAR       szBuf[SZBUFSIZ];
extern  TCHAR       szBuf2[SZBUFSIZ];

extern  TCHAR       szConvPartner[128];                 // bigger than max server name
extern  TCHAR       szKeepAs[MAX_NDDESHARENAME + 2];


// DDEML stuff

extern  DWORD      idInst;                              // DDEML handle







//
// function prototypes
//

void OnDrawClipboard(
    HWND    hwnd);


LRESULT OnEraseBkgnd(
    HWND    hwnd,
    HDC     hdc);


LRESULT OnPaint(
    HWND    hwnd);


LRESULT CALLBACK FrameWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


LRESULT CALLBACK ChildWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


VOID SendMessageToKids (
    WORD    msg,
    WPARAM  wParam,
    LPARAM  lParam);


BOOL SyncOpenClipboard(
    HWND    hwnd);


BOOL SyncCloseClipboard(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clipdsp.c ===
/*****************************************************************************

                        C L I P B O O K   D I S P L A Y

    Name:       clipdsp.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This module handles the drawing of the clipbook displays.

    History:
        19-Apr-1994 John Fu     Changed the priority of CF_UNICODETEXT to
                                be higher than CF_TEXT.
                                Changed DIB display to use DIB_RGB_COLORS.
                                Made menus for all displayable formats above
                                all nondisplayables.

        16-Jun-1994 John Fu     Fix ShowString() to allocate bigger buffer
                                if the buffer is filled out completely.

        15-Mar-1995 John Fu     Changed DrawDib to use DIB_RGB_COLORS only.

*****************************************************************************/





#define WIN31
#include <windows.h>
#include "common.h"
#include "clipbook.h"
#include "clpbkrc.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "debugout.h"
#include "cvutil.h"




#define MAXBITSPERPIXEL     24
#define ifmtMax             (sizeof(rgfmt)/sizeof(WORD))



static MFENUMPROC   lpEnumMetaProc;


BOOL                fOwnerDisplay;
TCHAR               szMemErr[100];
HBRUSH              hbrBackground;
HMENU               hDispMenu;




/* The scroll information for OWNER display is to be preserved, whenever
 * the display changes between OWNER and NON-OWNER; The following globals
 * are used to save and restore the scroll info.
 */

// winball: since only the Clipboard window supports owner display,
// this info is not replicated for each MDI child...

int   OwnVerMin;
int   OwnVerMax;
int   OwnHorMin;
int   OwnHorMax;

int   OwnVerPos;
int   OwnHorPos;



/* Defines priority order for show format */
WORD   rgfmt[] = {
                  CF_OWNERDISPLAY,

                  CF_UNICODETEXT,   // JYF, moved CF_UNICODETEXT above CF_TEXT
                  CF_TEXT,
                  CF_OEMTEXT,


                  CF_ENHMETAFILE,
                  CF_METAFILEPICT,
                  CF_DIB,
                  CF_BITMAP,

                  CF_DSPTEXT,
                  CF_DSPBITMAP,
                  CF_DSPMETAFILEPICT,
                  CF_DSPENHMETAFILE,

                  CF_PALETTE,
                  CF_RIFF,
                  CF_WAVE,
                  CF_PENDATA,
                  CF_SYLK,
                  CF_DIF,
                  CF_TIFF,
                  CF_LOCALE
                  };



void ShowString( HWND, HDC, WORD);










/*
 *      MyOpenClipBoard
 */

BOOL MyOpenClipboard(
    HWND    hWnd)
{
HDC   hDC;
RECT  Rect;

    if( VOpenClipboard( GETMDIINFO(hWnd)->pVClpbrd, hWnd ))
        return(TRUE);


    PERROR(TEXT("MyOpenClipboard fail\r\n"));


    /* Some app forgot to close the clipboard */
    hDC = GetDC(hWnd);

    GetClientRect(hWnd, (LPRECT)&Rect);
    FillRect(hDC, (LPRECT)&Rect, hbrBackground);
    ShowString( hWnd, hDC, IDS_ALREADYOPEN);

    ReleaseDC(hWnd, hDC);


    return(FALSE);

}






/*
 *      SetCharDimensions
 */

void SetCharDimensions(
    HWND    hWnd,
    HFONT   hFont)

{
register HDC    hdc;
TEXTMETRIC      tm;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hWnd);

    if (pMDI)
    {
        hdc = GetDC(hWnd);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
        ReleaseDC(hWnd, hdc);

        pMDI->cxChar         = (WORD)tm.tmAveCharWidth;
        pMDI->cxMaxCharWidth = (WORD)tm.tmMaxCharWidth;
        pMDI->cyLine         = (WORD)(tm.tmHeight + tm.tmExternalLeading);
        pMDI->cxMargin       = pMDI->cxChar / 2;
        pMDI->cyMargin       = pMDI->cyLine / 4;
    }

}






/*
 *      ChangeCharDimensions
 */

void ChangeCharDimensions(
    HWND    hwnd,
    UINT    wOldFormat,
    UINT    wNewFormat)
{
    /* Check if the font has changed. */
    if (wOldFormat == CF_OEMTEXT)
        {
        if (wNewFormat != CF_OEMTEXT)       // Select default system font sizes
            SetCharDimensions(hwnd, GetStockObject ( SYSTEM_FONT ) );
        }
    else if (wNewFormat == CF_OEMTEXT)      // Select OEM font sizes
        SetCharDimensions(hwnd, GetStockObject ( OEM_FIXED_FONT ) );
}






/*
 *      ClipbrdVScroll
 *
 *  Scroll contents of window vertically, according to action code in wParam.
 */

void ClipbrdVScroll (
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb)
{
int         cyWindow;
long        dyScroll;
long        cyScrollT;
long        dyScrollAbs;
long        cyPartialChar;
PMDIINFO    pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        /* Ensure that all the bits are valid first, before scrolling them */
        UpdateWindow(hwnd);

        cyScrollT = pMDI->cyScrollNow;
        cyWindow = pMDI->rcWindow.bottom - pMDI->rcWindow.top;

        /* Compute scroll results as an effect on cyScrollNow */
        switch (wParam)
            {
            case SB_LINEUP:
                cyScrollT -= pMDI->cyLine;
                break;

            case SB_LINEDOWN:
                cyScrollT += pMDI->cyLine;
                break;

            case SB_THUMBPOSITION:
                cyScrollT = (LONG)(((LONG)wThumb * pMDI->cyScrollLast) / VPOSLAST);
                break;

            case SB_PAGEUP:
            case SB_PAGEDOWN:
                {
                int   cyPageScroll;

                cyPageScroll = cyWindow - pMDI->cyLine;

                if (cyPageScroll < (int)(pMDI->cyLine))
                    cyPageScroll = pMDI->cyLine;

                cyScrollT += (wParam == SB_PAGEUP) ? -cyPageScroll : cyPageScroll;
                break;
                }

            default:
                return;
            }



        if ((cyScrollT < 0) || (pMDI->cyScrollLast <= 0))
            cyScrollT = 0;
        else if (cyScrollT > pMDI->cyScrollLast)
            cyScrollT = pMDI->cyScrollLast;
        else if (cyPartialChar = cyScrollT % pMDI->cyLine)
            {
            /* Round to the nearest character increment. */
            if (cyPartialChar > ((int)(pMDI->cyLine) >> 1))
                cyScrollT += pMDI->cyLine;
                cyScrollT -= cyPartialChar;
            }



        dyScroll = pMDI->cyScrollNow - cyScrollT;

        if (dyScroll > 0)
            dyScrollAbs = dyScroll;
        else if (dyScroll < 0)
            dyScrollAbs = -dyScroll;
        else
            return;             /* Scrolling has no effect here. */

        pMDI->cyScrollNow = cyScrollT;

        if (dyScrollAbs >= pMDI->rcWindow.bottom - pMDI->rcWindow.top)
            /* ScrollWindow does not handle this case */
            InvalidateRect(hwnd, (LPRECT)&(pMDI->rcWindow), TRUE);
        else
            ScrollWindow(hwnd, 0,(int)dyScroll, &(pMDI->rcWindow), &(pMDI->rcWindow));


        UpdateWindow(hwnd);

        SetScrollPos (pMDI->hwndVscroll,
                      SB_CTL,
                      (pMDI->cyScrollLast <= 0) ?
                      0 :
                      (int)((cyScrollT * (DWORD)VPOSLAST) / pMDI->cyScrollLast),
                      TRUE);
    }

}







/*
 *      ClipbrdHScroll
 *
 *  Scroll contents of window horizontally, according to op code in wParam.
 */

void ClipbrdHScroll (
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb)
{
register int    dxScroll;
register int    cxScrollT;
int             cxWindow;
int             dxScrollAbs;
int             cxPartialChar;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        cxScrollT = pMDI->cxScrollNow;
        cxWindow = pMDI->rcWindow.right - pMDI->rcWindow.left;

        /* Compute scroll results as an effect on cxScrollNow */
        switch (wParam)
            {
            case SB_LINEUP:
                cxScrollT -= pMDI->cxChar;
                break;

            case SB_LINEDOWN:
                cxScrollT += pMDI->cxChar;
                break;

            case SB_THUMBPOSITION:
                cxScrollT = (int)(((LONG)wThumb * (LONG)pMDI->cxScrollLast) / HPOSLAST);
                break;

            case SB_PAGEUP:
            case SB_PAGEDOWN:
                {
                int   cxPageScroll;

                cxPageScroll = cxWindow - pMDI->cxChar;
                if (cxPageScroll < (int)(pMDI->cxChar))
                    cxPageScroll = pMDI->cxChar;

                cxScrollT += (wParam == SB_PAGEUP) ? -cxPageScroll : cxPageScroll;
                break;
                }

            default:
                return;
            }



        if ((cxScrollT < 0) || (pMDI->cxScrollLast <= 0))
            cxScrollT = 0;
        else if (cxScrollT > pMDI->cxScrollLast)
            cxScrollT = pMDI->cxScrollLast;
        else if (cxPartialChar = cxScrollT % pMDI->cxChar)
            { /* Round to the nearest character increment */
            if (cxPartialChar > ((int)(pMDI->cxChar) >> 1))
                cxScrollT += pMDI->cxChar;
                cxScrollT -= cxPartialChar;
            }



        /* Now we have a good cxScrollT value */

        dxScroll = pMDI->cxScrollNow - cxScrollT;
        if (dxScroll > 0)
            dxScrollAbs = dxScroll;
        else if (dxScroll < 0)
            dxScrollAbs = -dxScroll;
        else
            return;             /* Scrolling has no effect here. */


        pMDI->cxScrollNow = cxScrollT;

        if (dxScrollAbs >= pMDI->rcWindow.right - pMDI->rcWindow.left)
            /* ScrollWindow does not handle this case */
            InvalidateRect( hwnd, (LPRECT) &(pMDI->rcWindow), TRUE );
        else
            ScrollWindow(hwnd, dxScroll, 0, (LPRECT)&(pMDI->rcWindow),
            (LPRECT)&(pMDI->rcWindow));

        UpdateWindow(hwnd);

        SetScrollPos (pMDI->hwndHscroll,
                      SB_CTL,
                      (pMDI->cxScrollLast <= 0) ?
                      0 :
                      (int)(((DWORD)cxScrollT * (DWORD)HPOSLAST) / (DWORD)(pMDI->cxScrollLast)),
                      TRUE);
    }
}






/*
 *      DibPaletteSize
 */

int DibPaletteSize(
    LPBITMAPINFOHEADER  lpbi)
{
register int bits;
register int nRet;

    /* With the new format headers, the size of the palette is in biClrUsed
     * else is dependent on bits per pixel.
     */

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
       {
       if (lpbi->biClrUsed != 0)
          {
          nRet = lpbi->biClrUsed * sizeof(RGBQUAD);
          }
       else
          {
          bits = lpbi->biBitCount;

          if (24 == bits)
             {
             nRet = 0;
             }
          else if (16 == bits || 32 == bits)
             {
             nRet = 3 * sizeof(DWORD);
             }
          else
             {
             nRet = (1 << bits) * sizeof(RGBQUAD);
             }
          }
       }
    else
       {
       bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
       nRet = (bits == 24) ? 0 : (1 << bits) * sizeof(RGBTRIPLE);
       }


    return(nRet);

}








/*
 *      DibGetInfo
 */

void DibGetInfo(
    HANDLE      hdib,
    LPBITMAP    pbm)

{
LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
        {
        pbm->bmWidth  = (int)lpbi->biWidth;
        pbm->bmHeight = (int)lpbi->biHeight;
        }
    else
        {
        pbm->bmWidth  = (int)((LPBITMAPCOREHEADER)lpbi)->bcWidth;
        pbm->bmHeight = (int)((LPBITMAPCOREHEADER)lpbi)->bcHeight;
        }

    GlobalUnlock(hdib);
}








/*
 *      DrawDib
 */

BOOL DrawDib(
    HWND    hwnd,
    HDC     hdc,
    int     x0,
    int     y0,
    HANDLE  hdib)
{
LPBITMAPINFOHEADER  lpbi;
BITMAP              bm;
LPSTR               lpBits;
BOOL                fOK = FALSE;

    if (hdib)
        {
        lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

        if (lpbi)
            {
            DibGetInfo(hdib, (LPBITMAP)&bm);

            lpBits = (LPSTR)lpbi + (WORD)lpbi->biSize + DibPaletteSize(lpbi);

            SetDIBitsToDevice (hdc,
                               x0,
                               y0,
                               bm.bmWidth,
                               bm.bmHeight,
                               0,
                               0,
                               0,
                               bm.bmHeight,
                               lpBits,
                               (LPBITMAPINFO)lpbi,
                               DIB_RGB_COLORS);

            GlobalUnlock(hdib);
            fOK = TRUE;
            }
        }

    return(fOK);

}








/*
 *      FShowDIBitmap
 */

BOOL FShowDIBitmap (
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          hdib,   //Bitmap in DIB format
    int             cxScroll,
    int             cyScroll)
{
BITMAP    bm;
PMDIINFO pMDI;

    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {
        DibGetInfo(hdib, (LPBITMAP)&bm);


        // If window's been resized, determine maximum scroll positions.
        if (pMDI->cyScrollLast == -1)
            {
            /* Compute last scroll offset into bitmap */
            pMDI->cyScrollLast = bm.bmHeight -
                (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
            if (pMDI->cyScrollLast < 0)
               {
               pMDI->cyScrollLast = 0;
               }
            }

        if (pMDI->cxScrollLast == -1)
            {
            /* Compute last scroll offset into bitmap */
            pMDI->cxScrollLast = bm.bmWidth -
                (pMDI->rcWindow.right - pMDI->rcWindow.left);
            if (pMDI->cxScrollLast < 0)
               {
               pMDI->cxScrollLast = 0;
               }
            }
    }

    SaveDC(hdc);
    IntersectClipRect (hdc, prc->left, prc->top, prc->right, prc->bottom);
    SetViewportOrgEx (hdc,prc->left - cxScroll, prc->top - cyScroll,NULL);
    DrawDib (hwnd, hdc, 0, 0, hdib);
    RestoreDC(hdc, -1);

    return(TRUE);

}







/*
 *      FShowBitmap
 */

BOOL FShowBitmap (
    HWND            hwnd,
    HDC             hdc,
    register PRECT  prc,
    HBITMAP         hbm,
    int             cxScroll,
    int             cyScroll)
{
register HDC    hMemDC;
BITMAP          bitmap;
int             cxBlt, cyBlt;
int             cxRect, cyRect;
PMDIINFO        pMDI;

    pMDI = GETMDIINFO(hwnd);

    if ((hMemDC = CreateCompatibleDC(hdc)) == NULL)
        return(FALSE);

    if (!SelectObject(hMemDC, (HBITMAP)hbm))
        {
        DeleteDC(hMemDC);
        // kind of a hack... want to display a more informative
        // message, so put up our own message and return OK
        ShowString( hwnd, hdc, IDS_BADBMPFMT );
        return TRUE;
        }

    GetObject((HBITMAP)hbm, sizeof(BITMAP), (LPSTR)&bitmap);

    // does this DDB match the DC? (clausgi)
    //  if ( bitmap.bmPlanes != GetDeviceCaps(hMemDC, PLANES) ||
    //         bitmap.bmBitsPixel != GetDeviceCaps(hMemDC, BITSPIXEL ) ) {
    //      DeleteDC(hMemDC);
          // kind of a hack... want to display a more informative
          // message, so put up our own message and return OK
    //       ShowString( hwnd, hdc, IDS_BADBMPFMT );
    //      return TRUE;
    //   }

    if (pMDI->cyScrollLast == -1)
        {
        /* Compute last scroll offset into bitmap */
        pMDI->cyScrollLast = bitmap.bmHeight - (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
        if (pMDI->cyScrollLast < 0)
            pMDI->cyScrollLast = 0;
        }

    if ( pMDI->cxScrollLast == -1)
        {
         /* Compute last scroll offset into bitmap */
        pMDI->cxScrollLast = bitmap.bmWidth - (pMDI->rcWindow.right - pMDI->rcWindow.left);
        if ( pMDI->cxScrollLast < 0)
            pMDI->cxScrollLast = 0;
        }


    cxRect = prc->right - prc->left;
    cyRect = prc->bottom - prc->top;
    cxBlt = min(cxRect, bitmap.bmWidth - cxScroll);
    cyBlt = min(cyRect, bitmap.bmHeight - cyScroll);

    BitBlt (hdc,
            prc->left,
            prc->top,
            cxBlt,
            cyBlt,
            hMemDC,
            cxScroll,
            cyScroll,    /* X,Y offset into source DC */
            SRCCOPY);

    DeleteDC(hMemDC);

    return(TRUE);

}






#define DXPAL  (pMDI->cyLine)
#define DYPAL  (pMDI->cyLine)

////////////////////////////////////////////////////////////////////////////
//
//  FShowPalette()
//
//  Parameters:
//    hwnd - The wMDI child we're drawing in.
//    hdc - DC for the window.
//    prc - Rectangle to draw.
//    hpal - The palette to display.
//    cxScroll, cyScroll - Scroll position in pels OF PRC. NOT OF THE WINDOW.
//       Derive window scroll position by doing a cxScroll -= pMDI->cxScrollNow
//
////////////////////////////////////////////////////////////////////////////

BOOL FShowPalette(
    HWND hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HPALETTE        hpal,
    int             cxScroll,
    int             cyScroll)
{
int         n;
int         x, y;
int         nx, ny;
int         nNumEntries;
RECT        rc;
HBRUSH      hbr;
PMDIINFO    pMDI;
BOOL        fOK = FALSE;
TCHAR       achHex[] = TEXT("0123456789ABCDEF");
int         nFirstLineDrawn;



    PINFO(TEXT("Palette: (%d,%d-%d,%d),cx %d, cy %d\r\n"),
       prc->left, prc->top, prc->right, prc->bottom, cxScroll, cyScroll);


    pMDI = GETMDIINFO(hwnd);

    if (hpal)
       {
       // Correct cyScroll to show window's scroll position, not prc's.
       cyScroll -= prc->top - pMDI->rcWindow.top;
       PINFO(TEXT("Corrected cyScroll %d\r\n"), cyScroll);

       // GetObject does not return an int-- it returns a USHORT. Thus,
       // we zero out nNumEntries before getobjecting the palette.
       nNumEntries = 0;
       GetObject(hpal, sizeof(int), (LPSTR)&nNumEntries);

       // Figure how many boxes across and tall the array of color boxes
       // is
       nx = ((pMDI->rcWindow.right - pMDI->rcWindow.left) / DXPAL);
       if (nx == 0)
          {
          nx = 1;
          }
       ny = (nNumEntries + nx - 1) / nx;
       PINFO(TEXT("%d entries, %d by %d array\r\n"), nNumEntries, nx, ny);

       // If the window's been resized, we have to tell it how far you
       // can scroll off to the right and down.
       if ( pMDI->cyScrollLast == -1)
          {
          pMDI->cyScrollLast = ny * DYPAL -                  // Height of palette minus
                pMDI->rcWindow.bottom - pMDI->rcWindow.top + // height of window plus
                DYPAL;                                       // one palette entry height.

          if ( pMDI->cyScrollLast < 0)
             {
             pMDI->cyScrollLast = 0;
             }
          PINFO(TEXT("Last allowed scroll: %d\r\n"), pMDI->cyScrollLast);
          }
       if ( pMDI->cxScrollLast == -1)
          {
          /* Can't scroll palettes horizontally. */
          pMDI->cxScrollLast = 0;
          }

       SaveDC(hdc);
       IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
       // SetMapMode(hdc, MM_TEXT);
       SetWindowOrgEx(hdc, -pMDI->rcWindow.left, -pMDI->rcWindow.top, NULL);

       // Set up the x and y positions of the first palette entry to draw
       // and figure out which palette entry IS the first that needs drawing.
       x = 0;
       nFirstLineDrawn = (cyScroll + prc->top - pMDI->rcWindow.top)/ DYPAL;
       n = nx * nFirstLineDrawn;
       y = DYPAL * nFirstLineDrawn - cyScroll; // + pMDI->rcWindow.top;
       PINFO(TEXT("First entry %d at %d, %d\r\n"), n, x, y);

       // While n < number of entries and the current entry isn't off the bottom
       // of the window
       while (n < nNumEntries && y < prc->bottom)
          {
          // Figure out a DXPAL by DYPAL rect going down/right from x,y
          rc.left   = x;
          rc.top    = y;
          rc.right  = rc.left + DXPAL;
          rc.bottom = rc.top + DYPAL;
          // PINFO(TEXT("(%d,%d) "), rc.left, rc.top);

          // Draw a black box with the appropriate color inside.
          if (RectVisible(hdc, &rc))
             {
             // PINFO(TEXT("<"));

             // If you change this one to zero, you get a text display of
             // the palette indices-- I used it to debug the draw code, 'cause
             // it's near impossible, when you've got little colored
             // squares, to figure out just which color is on the bottom of THAT
             // square THERE, the one that was scrolled halfway off the bottom
             // of the window, and you just scrolled it on. ("Well, it's sorta
             // purple... of course, this entire palette is sorta purple..")
             #if 1
             InflateRect(&rc, -1, -1);
             FrameRect(hdc, &rc, GetStockObject(BLACK_BRUSH));
             InflateRect(&rc, -1, -1);
             hbr = CreateSolidBrush(PALETTEINDEX(n));
             FillRect(hdc, &rc, hbr);
             DeleteObject(hbr);
             #else
             SetBkMode(hdc, TRANSPARENT);
             TextOut(hdc, rc.left + 2, rc.top + 2, &achHex[(n / 16)&0x0f], 1);
             TextOut(hdc, (rc.left + rc.right) / 2, rc.top + 2,
                   &achHex[n & 0x0f], 1);
             #endif
             }

          // Go to next entry and advance x to the next position, "word
          // wrapping" to next line if we need to
          n++;
          x += DXPAL;
          if (0 == n % nx)
             {
             x = 0;
             y += DYPAL;
             PINFO(TEXT("Wrap at %d\r\n"), n);
             }
          }
       RestoreDC(hdc, -1);
       fOK = TRUE;
       }
    else
       {
       PERROR(TEXT("Bad palette!\r\n"));
       }
    return(fOK);
}








/*
 *      PxlConvert
 *
 * Return the # of pixels spanned by 'val', a measurement in coordinates
 * appropriate to mapping mode mm.  'pxlDeviceRes' gives the resolution
 * of the device in pixels, along the axis of 'val'. 'milDeviceRes' gives
 * the same resolution measurement, but in millimeters.
 */

int PxlConvert(
    int mm,
    int val,
    int pxlDeviceRes,
    int milDeviceRes)
{
register WORD   wMult = 1;
register WORD   wDiv = 1;
DWORD           ulPxl;
DWORD           ulDenom;
/* Should be a constant!  This works around a compiler bug as of 07/14/85. */
DWORD           ulMaxInt = 0x7FFF;

    if (milDeviceRes == 0)
        {
        /* to make sure we don't get divide-by-0 */
        return(0);
        }

    switch (mm)
        {
        case MM_LOMETRIC:
            wDiv = 10;
            break;

        case MM_HIMETRIC:
            wDiv = 100;
            break;

        case MM_TWIPS:
            wMult = 254;
            wDiv = 14400;
            break;

        case MM_LOENGLISH:
            wMult = 2540;
            wDiv = 10000;
            break;

        case MM_HIENGLISH:
            wMult = 254;
            wDiv = 10000;
            break;

        case MM_TEXT:
            return(val);

        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
            /* These picture types have no original size */
        default:
            return(0);
        }

    /* Add denominator - 1 to numerator, to avoid roundoff */

    ulDenom = (DWORD)wDiv * (DWORD)milDeviceRes;
    ulPxl = (((DWORD)((DWORD)wMult * (DWORD)val * (DWORD)pxlDeviceRes)) + ulDenom - 1) / ulDenom;

    return((ulPxl > ulMaxInt) ? 0 : (int)ulPxl);
}









/*
 *      FShowEnhMetaFile
 *
 * Display an enhanced metafile in the specified rectangle.
 */

BOOL FShowEnhMetaFile(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hemf,
    int             cxScroll,
    int             cyScroll)
{
int         cxBitmap;
int         cyBitmap;
RECT        rcWindow;
int         f = FALSE;
PMDIINFO    pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        /* Not scrollable.  Resize these into the given rect. */

        pMDI->cyScrollLast = 0;
        pMDI->cxScrollLast = 0;

        cxBitmap = pMDI->rcWindow.right - pMDI->rcWindow.left;
        cyBitmap = pMDI->rcWindow.bottom - pMDI->rcWindow.top;


        /* We make the "viewport" to be an area the same size as the
         * clipboard object, and set the origin and clip region so as
         * to show the area we want. Note that the viewport may well be
         * bigger than the window.
         */

        SetMapMode(hdc, MM_TEXT);

        rcWindow.left   = prc->left - cxScroll;
        rcWindow.top    = prc->top  - cyScroll;
        rcWindow.right  = rcWindow.left + cxBitmap;
        rcWindow.bottom = rcWindow.top  + cyBitmap;

        f = PlayEnhMetaFile (hdc, hemf, &rcWindow);



        // Always return TRUE. PlayEnhMetaFile() can return
        // FALSE even when the metafile can be displayed
        // properly.  Things such as printer escap can cause
        // the call to return FALSE when painting to screen
        // but the image will be displayed fine.
        //
        // We return TRUE so we don't blank the display and
        // put "Clipbook can't display..." message.
    }

    return TRUE;

}





/*
 *      EnumMetafileProc
 *
 *  Metafile record play callback function used to work around problem
 *  with non active MDI children playing a metafile that causes a foreground
 *  palette selection
 */

BOOL CALLBACK EnumMetafileProc (
    HDC             hdc,
    HANDLETABLE FAR *lpht,
    METARECORD FAR  *lpmr,
    int             cObj,
    LPARAM          lParam )
{
    if ( lpmr->rdFunction == META_SELECTPALETTE )
       {
       return SelectPalette ( hdc, lpht[(lpmr->rdParm[0])].objectHandle[0],
             TRUE ) != NULL;
       }
    else
       {
       PlayMetaFileRecord ( hdc, lpht, lpmr, cObj );
       return TRUE;
       }
}








/*
 *      FShowMetaFilePict
 *
 *  Display a metafile in the specified rectangle.
 */

BOOL FShowMetaFilePict(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hmfp,
    int             cxScroll,
    int             cyScroll)
{
int             level;
int             cxBitmap;
int             cyBitmap;
int             f = FALSE;
LPMETAFILEPICT  lpmfp;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        if ((lpmfp = (LPMETAFILEPICT)GlobalLock( hmfp )) != NULL)
            {
            METAFILEPICT mfp;

            mfp = *lpmfp;
            GlobalUnlock( hmfp );

            if ((level = SaveDC( hdc )) != 0)
                {

                /* Compute size of picture to be displayed */
                switch (mfp.mm)
                    {
                    case MM_ISOTROPIC:
                    case MM_ANISOTROPIC:
                        /* Not scrollable.  Resize these into the given rect. */
                        pMDI->cyScrollLast = 0;
                        pMDI->cxScrollLast = 0;
                        cxBitmap = pMDI->rcWindow.right - pMDI->rcWindow.left;
                        cyBitmap = pMDI->rcWindow.bottom - pMDI->rcWindow.top;
                        break;

                    default:
                        cxBitmap = PxlConvert(mfp.mm, mfp.xExt, GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, HORZSIZE));
                        cyBitmap = PxlConvert(mfp.mm, mfp.yExt, GetDeviceCaps(hdc, VERTRES), GetDeviceCaps(hdc, VERTSIZE));
                        if (!cxBitmap || !cyBitmap)
                            {
                            goto NoDisplay;
                            }

                        if ( pMDI->cxScrollLast == -1)
                            {
                            pMDI->cxScrollLast =
                                cxBitmap - (pMDI->rcWindow.right - pMDI->rcWindow.left);
                            if ( pMDI->cxScrollLast < 0)
                                {
                                pMDI->cxScrollLast = 0;
                                }
                            }

                        if (pMDI->cyScrollLast == -1)
                            {
                            pMDI->cyScrollLast =
                                cyBitmap - (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
                            if (pMDI->cyScrollLast < 0)
                                {
                                pMDI->cyScrollLast = 0;
                                }
                            }
                        break;
                    }

                    /* We make the "viewport" to be an area the same size as the
                     * clipboard object, and set the origin and clip region so as
                     * to show the area we want. Note that the viewport may well be
                     * bigger than the window.
                     */
                    // IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
                    SetMapMode(hdc, mfp.mm);

                    SetViewportOrgEx(hdc, prc->left - cxScroll, prc->top - cyScroll, NULL);
                    switch (mfp.mm)
                        {
                        case MM_ISOTROPIC:
                            if (mfp.xExt && mfp.yExt)
                               {
                               // So we get the correct shape rectangle when
                               // SetViewportExt gets called.
                               //
                               SetWindowExtEx(hdc, mfp.xExt, mfp.yExt, NULL);
                               }
                            //else
                            //  FALL THRU

                        case MM_ANISOTROPIC:
                            SetViewportExtEx(hdc, cxBitmap, cyBitmap, NULL);
                            break;
                        }

                /* Since we may have scrolled, force brushes to align */
                SetBrushOrgEx(hdc, cxScroll - prc->left, cyScroll - prc->top, NULL);

                // f = PlayMetaFile(hdc, mfp.hMF);
                f = EnumMetaFile(hdc, mfp.hMF, EnumMetafileProc, 0L );
                FreeProcInstance ( (FARPROC) lpEnumMetaProc );

          NoDisplay:
                RestoreDC(hdc, level);
               }
            }
    }


    return(f);
}






/*
 *      ShowString
 *
 *  Blank rcWindow and show the string on the top line of the client area
 */

void ShowString(
    HWND    hwnd,
    HDC     hdc,
    WORD    id)
{
TCHAR   szBuffer[BUFFERLEN];
LPTSTR  pszBuffer   = szBuffer;
INT     iBufferSize = BUFFERLEN;

INT     iStringLen;


    /* Cancel any scrolling effects. */
    GETMDIINFO(hwnd)->cyScrollNow = 0;
    GETMDIINFO(hwnd)->cxScrollNow = 0;


    iStringLen = LoadString(hInst, id, pszBuffer, BUFFERLEN);


    // Is the buffer completely filled out?
    // We need a bigger one if yes.

    while (iStringLen == BUFFERLEN -1)
        {
        if (pszBuffer != szBuffer && pszBuffer)
            LocalFree (pszBuffer);

        iBufferSize *= 2;
        pszBuffer = LocalAlloc (LPTR, iBufferSize);

        if (!pszBuffer)
            goto done;

        iStringLen = LoadString (hInst, id, pszBuffer, iBufferSize);
        }



    FillRect (hdc, &(GETMDIINFO(hwnd)->rcWindow), hbrBackground);
    DrawText (hdc, pszBuffer, -1, &(GETMDIINFO(hwnd)->rcWindow),
              DT_CENTER | DT_WORDBREAK | DT_TOP);



done:

    if (pszBuffer != szBuffer && pszBuffer)
        LocalFree (pszBuffer);

}









/*
 *      CchLineA
 *
 *
 * Determine the # of characters in one display line's worth of lpch.
 * lpch is assumed to be an ansi string.
 *
 * Return the following:
 *       HI WORD:    # of chars to display (excludes CR, LF; will not
 *                   exceed cchLine)
 *       LO WORD:    offset of start of next line in lpch; If the current line
 *                   is NULL terminated, this contains offset to the NULL char;
 *       In RgchBuf: characters to display
 *
 *   Expands Tabs
 *
 *   Accepts any of the following as valid end-of-line terminators:
 *       CR, LF, CR-LF, LF-CR, NULL
 *   Callers may test for having reached NULL by (lpch[LOWORD] == '\0')
 */

LONG CchLineA(
    PMDIINFO    pMDI,
    HDC         hDC,
    CHAR        rgchBuf[],
    CHAR FAR    *lpch,
    INT         cchLine,
    WORD        wWidth)
{
CHAR            ch;
CHAR            *pch = rgchBuf;
register INT    cchIn = 0;
register INT    cchOut = 0;
INT             iMinNoOfChars;
SIZE            size;
INT             iTextWidth = 0;



    iMinNoOfChars = wWidth / pMDI->cxMaxCharWidth;

    while (cchOut < cchLine)
        {
        switch (ch = *(lpch + (DWORD)cchIn++))
            {
            case '\0':
                /* cchIn is already incremented; So, it is pointing to
                 * a character beyond the NULL; So, decrement it.
                 */
                cchIn--;
                goto DoubleBreak;

            case '\015':  /* CR */
            case '\012':  /* LF */
                if ((lpch[cchIn] == '\015') || (lpch[cchIn] == '\012'))
                    cchIn++;
                goto DoubleBreak;

            case '\011':  /* TAB */
                {
                INT   cchT = 8 - (cchOut % 8);

                /* Check if the width has exceeded or the total
                 * number of characters has exceeded
                 */
                if (((WORD)(iTextWidth + cchT * pMDI->cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                   /* Tab causes wrap to next line */
                    goto DoubleBreak;

                while (cchT--)
                    rgchBuf[cchOut++] = ' ';
                break;
                }

            default:
                rgchBuf[cchOut++] = ch;
                if( IsDBCSLeadByte(ch) )
                    rgchBuf[cchOut++] = *(lpch + (DWORD)cchIn++);

            break;
            }

        /* Check if the width has been exceeded. */
        if (cchOut >= iMinNoOfChars)
            {
            GetTextExtentPointA(hDC, rgchBuf, cchOut, (LPSIZE)&size);
            iTextWidth = size.cx;
            if ((WORD)iTextWidth == wWidth)
                break;
            else if((WORD)iTextWidth > wWidth)
                {
                    if (IsDBCSLeadByte(ch))
                        {
                        cchOut--;
                        cchIn--;
                        }

                cchOut--;
                cchIn--;
                break;
                }

            iMinNoOfChars += (wWidth - iTextWidth) / pMDI->cxMaxCharWidth;
            }
        }


DoubleBreak:
    return(MAKELONG(cchIn, cchOut));

}






/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  CchLineW() -                                                             */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/*Same as previous function but takes unicode strings.
 */

LONG CchLineW(
    PMDIINFO    pMDI,
    HDC         hDC,
    WCHAR       rgchBuf[],
    WCHAR FAR   *lpch,
    INT         cchLine,
    WORD        wWidth)
{
register INT    cchIn = 0;
register INT    cchOut = 0;
WCHAR           ch;
WCHAR           *pch = rgchBuf;
INT             iMinNoOfChars;
INT             iTextWidth = 0;
SIZE            size;


    iMinNoOfChars = wWidth / pMDI->cxMaxCharWidth;

    while (cchOut < cchLine)
        {
        switch (ch = *(lpch + (DWORD)cchIn++))
            {
            case L'\0':
                 /* cchIn is already incremented; So, it is pointing to
                 * a character beyond the NULL; So, decrement it.
                 */
                cchIn--;
                goto DoubleBreak;

            case L'\015':  /* CR */
            case L'\012':  /* LF */
                if ((lpch[cchIn] == L'\015') || (lpch[cchIn] == L'\012'))
                    cchIn++;
                goto DoubleBreak;

            case L'\011':  /* TAB */
                {
                INT   cchT = 8 - (cchOut % 8);

                /* Check if the width has exceeded or the total
                 * number of characters has exceeded
                 */
                if (((WORD)(iTextWidth + cchT * pMDI->cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                    /* Tab causes wrap to next line */
                    goto DoubleBreak;

                while (cchT--)
                    rgchBuf[cchOut++] = L' ';
                break;
                }

            default:
                rgchBuf[cchOut++] = ch;
                break;
            }


        /* Check if the width has been exceeded. */
        if (cchOut >= iMinNoOfChars)
            {
            GetTextExtentPointW(hDC, rgchBuf, cchOut, &size);
            iTextWidth = size.cx;
            if ((WORD)iTextWidth == wWidth)
                break;
            else if((WORD)iTextWidth > wWidth)
                {
                  cchOut--;
                  cchIn--;
                  break;
                }

            iMinNoOfChars += (wWidth - iTextWidth) / pMDI->cxMaxCharWidth;
            }
        }


DoubleBreak:

  return(MAKELONG(cchIn, cchOut));

}






#define cchLineMax  200

/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ShowText() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void ShowText(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          h,
    INT             cyScroll,
    BOOL            fUnicode)
{
#ifdef WIN16
  CHAR huge *lpch;
#else
  CHAR FAR  *lpch;
#endif

INT       yT;
INT       cLine;
INT       cLineAllText = 0;
RECT      rc;
INT       yLine;
INT       iLineFirstShow;
WORD      wLen;
WORD      wWidth;
CHAR      rgch[cchLineMax*sizeof(WCHAR)];
PMDIINFO  pMDI;





    pMDI= GETMDIINFO(hwnd);

    rc = *prc;

    /* Expand repaint rectangle as necessary to hold an exact number of
     * lines and start on an even line boundary. This is because we may
     * get arbitrarily weird repaint rectangles when popups are moved.
     * Scrolling repaint areas should require no adjustment.
     */

    rc.top -= (rc.top - pMDI->rcWindow.top) % pMDI->cyLine;



    /* If expanding the repaint rectangle to the next line expands it */
    /* beyond the bottom of my window, contract it one line.          */
    if ((yT = (rc.bottom - rc.top) % pMDI->cyLine) != 0)
        if ((rc.bottom += pMDI->cyLine - yT) > pMDI->rcWindow.bottom)
            rc.bottom -= pMDI->cyLine;

    if (rc.bottom <= rc.top)
        return;

    if (((wWidth = (WORD)(pMDI->rcWindow.right - pMDI->rcWindow.left)) <= 0) ||
        ((cLine = (rc.bottom - rc.top) / pMDI->cyLine) <= 0)         ||
        (NULL == (lpch = (LPSTR)GlobalLock(h))) )
        {
        /* Bad Rectangle or Bad Text Handle */
        ShowString(hwnd, hdc, IDS_ERROR);
        return;
        }



    /* Advance lpch to point at the text for the first line to show. */
    iLineFirstShow = cyScroll / pMDI->cyLine;


    /* Advance lpch to point at text for that line. */
    if (!fUnicode)
        while ((*lpch) && (iLineFirstShow--))
            {
            lpch += LOWORD(CchLineA(pMDI,hdc, rgch, lpch, cchLineMax, wWidth));
            cLineAllText++;
            }
    else
        while ((*((WCHAR *)lpch)) && (iLineFirstShow--))
            {
            lpch += ((LOWORD(CchLineW(pMDI, hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch,
                  cchLineMax, wWidth)))*sizeof(WCHAR));
            cLineAllText++;
            }


    /* Display string, line by line */
    yLine = rc.top;
    while (cLine--)
        {
        LONG lT;

        if (!fUnicode)
            {
            lT = CchLineA(pMDI, hdc, rgch, lpch, cchLineMax, wWidth);
            }
        else
            {
            lT = CchLineW(pMDI, hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch, cchLineMax, wWidth);
            }
        wLen = LOWORD(lT);
        if (!fUnicode)
            {
            TextOutA(hdc, rc.left, yLine, (LPSTR) rgch, HIWORD(lT));
            lpch += wLen;
            }
        else
            {
            if (!TextOutW(hdc, rc.left, yLine, (LPCWSTR) rgch, HIWORD(lT)))
                {
                GetLastError();
                }
            lpch += (wLen * sizeof(WCHAR));
            }
        yLine += pMDI->cyLine;
        cLineAllText++;
        if ((!fUnicode && (*lpch == 0)) || (fUnicode && (*((WCHAR *)lpch) == L'\0')))
            {
            break;
            }
        }


    if (pMDI->cxScrollLast == -1)
        {
        /* We don't use horiz scroll for text */
        pMDI->cxScrollLast = 0;
        }

    if (pMDI->cyScrollLast == -1)
        {
        INT   cLineInRcWindow;

        /* Validate y-size of text in clipboard. */
        /* Adjust rcWindow dimensions for text display */
        cLineInRcWindow = (pMDI->rcWindow.bottom - pMDI->rcWindow.top) / pMDI->cyLine;

        do {
           if (!fUnicode)
               {
               lpch += LOWORD(CchLineA(pMDI, hdc, rgch, lpch, cchLineMax, wWidth));
               }
           else
               {
               lpch += ((LOWORD(CchLineW(pMDI, hdc, (WCHAR *)rgch,
                   (WCHAR FAR *)lpch, cchLineMax, wWidth)))*sizeof(WCHAR));
               }
           cLineAllText++;
           }
           while ((!fUnicode && (*lpch != 0)) || (fUnicode && ((*lpch != 0) || (*(lpch+1) != 0))));

        pMDI->cyScrollLast = (cLineAllText - cLineInRcWindow) * pMDI->cyLine;
        if (pMDI->cyScrollLast < 0)
            {
            pMDI->cyScrollLast = 0;
            }

       /* Restrict rcWindow so that it holds an exact # of text lines */
        pMDI->rcWindow.bottom = pMDI->rcWindow.top + (cLineInRcWindow * pMDI->cyLine);
        }


    GlobalUnlock(h);

}











/*
 *      SendOwnerMessage
 */

void SendOwnerMessage(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
register HWND hwndOwner;

    /* Send a message to the clipboard owner, if there is one */
    hwndOwner = GetClipboardOwner();

    if (hwndOwner != NULL)
        SendMessage(hwndOwner, message, wParam, lParam);

}









/*
 *      SendOwnerSizeMessage
 *
 *  Send WM_SIZECLIPBOARD message to clipboard owner.
 *    wParam is a handle to the clipboard window
 *    LOWORD(lParam) is a handle to the passed rect
 */

void SendOwnerSizeMessage (
    HWND    hwnd,
    int     left,
    int     top,
    int     right,
    int     bottom)
{
register HANDLE hrc;
LPRECT          lprc;



    if ((hrc = GlobalAlloc (GMEM_MOVEABLE | GMEM_LOWER, (LONG)sizeof(RECT))) != NULL )
        {
        if ((lprc = (LPRECT)GlobalLock(hrc)) != NULL )
            {
            lprc->top    = top;
            lprc->bottom = bottom;
            lprc->left   = left;
            lprc->right  = right;
            GlobalUnlock(hrc);
            SendOwnerMessage(WM_SIZECLIPBOARD, (WPARAM)hwnd, (LPARAM)hrc);
            }
        GlobalFree(hrc);
        }

}









/*
 *      GetBestFormat
 *
 *  This routine decides which one of the existing formats is to be
 *  displayed in the viewer.
 */

UINT GetBestFormat(
    HWND    hwnd,
    UINT    wFormat)
{
register WORD   cFmt;
register WORD   *pfmt;


    // PINFO(TEXT("GBFormat %d\r\n"), wFormat);

    if (wFormat == CBM_AUTO)
        {
        for (cFmt=ifmtMax, pfmt=&rgfmt[0]; cFmt--; pfmt++)
            {
            // PINFO(TEXT("Looking at # %d, (%d)\r\n"), cFmt, *pfmt);
            if ( VIsClipboardFormatAvailable( GETMDIINFO(hwnd)->pVClpbrd, *pfmt ))
                {
                return(*pfmt);
                }
            }
        return(0);              /* Just in case... */
        }

    return(wFormat);

}











/*
 *      GetClipboardName
 */

void GetClipboardName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize)
{
LPTSTR  lprgch;
HANDLE  hrgch;



    *szName = '\0';


    /* Get global memory that everyone can get to */
    if ((hrgch = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)(iSize + 1))) == NULL)
        {
        PERROR(TEXT("GetClipboardName: alloc failure\n\r"));
        return;
        }

    if (!(lprgch = (LPTSTR)GlobalLock(hrgch)))
        goto ExitPoint;

    switch (fmt)
        {
        // These are all of the formats we have know the names of.
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:

        case CF_TEXT:
        case CF_UNICODETEXT:
        case CF_OEMTEXT:
        case CF_DSPTEXT:
        case CF_LOCALE:

        case CF_BITMAP:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPBITMAP:

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
        case CF_HDROP:
            LoadString(hInst, fmt, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            *lprgch = '\0';
            SendOwnerMessage(WM_ASKCBFORMATNAME, (WPARAM)iSize, (LPARAM)(LPSTR)lprgch);

            if (!*lprgch)
                LoadString(hInst, fmt, lprgch, iSize);
            break;

        default:
            *lprgch = '\0';
            GetClipboardFormatName(fmt, lprgch, iSize);
            break;
        }

    lstrcpy(szName, lprgch);

    GlobalUnlock(hrgch);


ExitPoint:
    GlobalFree(hrgch);

}



//Seperate menu item and DDE transaction Data.

/*
 *      GetClipboardMenuName
 */

void GetClipboardMenuName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize)
{
LPTSTR  lprgch;
HANDLE  hrgch;



    *szName = '\0';


    /* Get global memory that everyone can get to */
    if ((hrgch = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)(iSize + 1))) == NULL)
        {
        PERROR(TEXT("GetClipboardName: alloc failure\n\r"));
        return;
        }

    if (!(lprgch = (LPTSTR)GlobalLock(hrgch)))
        goto ExitPoint;

    switch (fmt)
        {
        // These are all of the formats we have know the names of.
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:

        case CF_TEXT:
        case CF_UNICODETEXT:
        case CF_OEMTEXT:
        case CF_DSPTEXT:

        case CF_BITMAP:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPBITMAP:

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:

        case CF_HDROP:
        case CF_LOCALE:
            LoadString(hInst, fmt+MNDELTA, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            *lprgch = '\0';
            SendOwnerMessage(WM_ASKCBFORMATNAME, (WPARAM)iSize, (LPARAM)(LPSTR)lprgch);

            if (!*lprgch)
                LoadString(hInst, CF_MN_OWNERDISPLAY, lprgch, iSize);
            break;

        default:
            GetClipboardFormatName(fmt, lprgch, iSize);
            break;
        }

    lstrcpy(szName, lprgch);

    GlobalUnlock(hrgch);


ExitPoint:
    GlobalFree(hrgch);

}








/*
 *      DrawFormat
 *
 * Parameters:
 *    hdc - the hdc to draw in.
 *    prc - The rectangle to paint
 *    cxScroll - The scroll position of the window.
 *    cyScroll - The scroll position OF THE PAINT RECTANGLE. NOT THE WINDOW.
 *       (Gawd. Who DESIGNED this?) Measured in pels.
 *    BestFormat - The format to draw.
 *    hwndMDI - The window we're drawing in.
 *
 */

void DrawFormat(
    register HDC    hdc,
    PRECT           prc,
    int             cxScroll,
    int             cyScroll,
    WORD            BestFormat,
    HWND            hwndMDI)
{
register HANDLE h;
HFONT           hFont;
int             fOK = TRUE;
WORD            wFormat = 0;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwndMDI);

    PINFO(TEXT("DrawFormat: (%d, %d), %d"), cxScroll, cyScroll, BestFormat);

    if (hwndMDI == hwndClpbrd && pMDI->pVClpbrd)
        {
        PERROR(TEXT("Clipboard window shouldn't have vClp!\r\n"));
        }


    /* If "Auto" is chosen and only data in unrecognised formats is
     * available, then display "Can't display data in this format".
     */
    if ((BestFormat == 0) &&
        VCountClipboardFormats( pMDI->pVClpbrd ))
        {
        if ((wFormat = (WORD)RegisterClipboardFormat(TEXT("FileName"))) &&
             VIsClipboardFormatAvailable(pMDI->pVClpbrd, wFormat))
            {
            BestFormat = CF_TEXT;
            }
        else
            {
            PINFO(TEXT("no displayable format\n\r"));
            ShowString( hwndMDI, hdc, IDS_CANTDISPLAY);
            return;
            }
        }


    PINFO(TEXT("format %x\n\r"), BestFormat);

    h = VGetClipboardData( pMDI->pVClpbrd, wFormat ? wFormat : BestFormat );




    if ( h != NULL)
        {
        PINFO(TEXT("Got format %x from VGetClipboardData\n\r"), BestFormat );

        switch (BestFormat)
            {

            case CF_DSPTEXT:
            case CF_TEXT:
                ShowText( hwndMDI, hdc, prc, h, cyScroll, FALSE);
                break;

            case CF_UNICODETEXT:
                hFont = SelectObject(hdc, hfontUni);
                ShowText(hwndMDI, hdc, prc, h, cyScroll, TRUE);
                SelectObject(hdc, hFont);
                break;

            case CF_OEMTEXT:
                hFont = SelectObject(hdc, GetStockObject ( OEM_FIXED_FONT ) );
                ShowText(hwndMDI, hdc, prc, h, cyScroll, FALSE);
                SelectObject(hdc, hFont);
                break;

            case CF_DSPBITMAP:
            case CF_BITMAP:
                fOK = FShowBitmap( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_DIB:
                fOK = FShowDIBitmap( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_PALETTE:
                fOK = FShowPalette( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_WAVE:
            case CF_RIFF:
            case CF_PENDATA:
            case CF_DIF:
            case CF_SYLK:
            case CF_TIFF:
            case CF_LOCALE:
                ShowString( hwndMDI, hdc, IDS_BINARY);
                break;

            case CF_DSPMETAFILEPICT:
            case CF_METAFILEPICT:
                fOK = FShowMetaFilePict( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_DSPENHMETAFILE:
            case CF_ENHMETAFILE:
                fOK = FShowEnhMetaFile( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            default:
                ShowString( hwndMDI, hdc, IDS_BINARY);
                break;
            }

        // Disable scroll bars that don't work
        EnableWindow(pMDI->hwndVscroll, pMDI->cyScrollLast > 1 ? TRUE : FALSE);
        EnableWindow(pMDI->hwndHscroll, pMDI->cxScrollLast > 1 ? TRUE : FALSE);
        }
    else
        {
        PERROR(TEXT("VGetClpDta fail\r\n"));
        }

    /* Check if the Data was not rendered by the application */
    if ((h == NULL) &&
        VCountClipboardFormats( pMDI->pVClpbrd ))
        {
        ShowString( hwndMDI, hdc, IDS_NOTRENDERED);
        }
    else
        {
        /* If we are unable to display the data, display "<Error>" */
        if (!fOK)
            {
            ShowString( hwndMDI, hdc, IDS_ERROR);
            }
        }

}









/*
 *      DrawStuff
 *
 *  Paint portion of current clipboard contents given by PAINT struct
 *  NOTE: If the paintstruct rectangle includes any part of the header, the
 *    whole header is redrawn.
 */

void DrawStuff(
    HWND                    hwnd,
    register PAINTSTRUCT    *pps,
    HWND                    hwndMDI)
{
register HDC    hdc;
RECT            rcPaint;
RECT            rcClient;
WORD            BestFormat;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {
        hdc  = pps->hdc;


        if (pps->fErase)
            FillRect(hdc, (LPRECT)&pps->rcPaint, hbrBackground);

        GetClientRect(hwnd, (LPRECT)&rcClient);




        // make room for scroll controls:

        BestFormat = (WORD)GetBestFormat( hwnd, pMDI->CurSelFormat );

        fOwnerDisplay = (BestFormat == CF_OWNERDISPLAY);

        if ( !fOwnerDisplay )
            {
            ShowScrollBar ( hwnd, SB_BOTH, FALSE );
            rcClient.right  -= GetSystemMetrics ( SM_CXVSCROLL );
            rcClient.bottom -= GetSystemMetrics ( SM_CYHSCROLL );
            }




        /* If the display format has changed, Set rcWindow,
         * the display area for clip info.
         */

        if ( pMDI->fDisplayFormatChanged )
            {
            CopyRect((LPRECT)&(pMDI->rcWindow), (LPRECT)&rcClient);

            /* We have changed the size of the clipboard. Tell the owner,
             * if fOwnerDisplay is active.
             */

            // ShowHideControls ( hwnd );

            if (fOwnerDisplay)
                {
                SendOwnerSizeMessage(hwnd,
                                     pMDI->rcWindow.left,
                                     pMDI->rcWindow.top,
                                     pMDI->rcWindow.right,
                                     pMDI->rcWindow.bottom);
                }
            else
                {
                /* Give the window a small margin, for looks */
                InflateRect (&(pMDI->rcWindow),
                             -(int)(pMDI->cxMargin),
                             -(int)(pMDI->cyMargin));
                }

            pMDI->fDisplayFormatChanged = FALSE;
            }

        if (fOwnerDisplay)
            {
            /* Clipboard Owner handles display */
            HANDLE hps;

            hps = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)sizeof(PAINTSTRUCT));

            if (hps != NULL)
                {
                LPPAINTSTRUCT lppsT;

                if ((lppsT = (LPPAINTSTRUCT)GlobalLock(hps)) != NULL)
                    {
                    *lppsT = *pps;
                    IntersectRect(&lppsT->rcPaint, &pps->rcPaint, &(pMDI->rcWindow));
                    GlobalUnlock(hps);
                    SendOwnerMessage(WM_PAINTCLIPBOARD, (WPARAM)hwnd, (LPARAM)hps);
                    GlobalFree(hps);
                    }
                }
            }
        else
            {
            /* We handle display */
            /* Redraw the portion of the paint rectangle that is in the clipbrd rect */
            IntersectRect(&rcPaint, &pps->rcPaint, &(pMDI->rcWindow));

            /* Always draw from left edge of window */
            rcPaint.left = pMDI->rcWindow.left;

            if ((rcPaint.bottom > rcPaint.top) && (rcPaint.right > rcPaint.left))
                {
                DrawFormat (hdc,
                            &rcPaint,
                            (int)(pMDI->cxScrollNow),
                            (int)(pMDI->cyScrollNow + rcPaint.top - pMDI->rcWindow.top),
                            BestFormat,
                            hwndMDI );
                }
            }
    }

}







/*
 *      SaveOwnerScrollInfo
 *
 * When the user switched the clipboard display from owner disp to
 *  a non-owner display, all the information about the scroll bar
 *  positions are to be saved. This routine does that.
 *  This is required because, when the user returns back to owner
 *  display, the scroll bar positions are to be restored.
 */

void SaveOwnerScrollInfo (
    register HWND   hwnd)

{
    GetScrollRange (hwnd, SB_VERT, (LPINT) & OwnVerMin, (LPINT) & OwnVerMax);
    GetScrollRange (hwnd, SB_HORZ, (LPINT) & OwnHorMin, (LPINT) & OwnHorMax);

    OwnVerPos = GetScrollPos( hwnd, SB_VERT );
    OwnHorPos = GetScrollPos( hwnd, SB_HORZ );
}






/*
 *      RestoreOwnerScrollInfo
 *
 *  When the user sitches back to owner-display, the scroll bar
 *  positions are restored by this routine.
 */

void RestoreOwnerScrollInfo (
    register HWND   hwnd)

{
    PINFO(TEXT("SETSCROLLRANGE in RestoreOwnerScrollInfo\n\r"));
    SetScrollRange( hwnd, SB_VERT, OwnVerMin, OwnVerMax, FALSE);
    SetScrollRange( hwnd, SB_HORZ, OwnHorMin, OwnHorMax, FALSE);

    SetScrollPos( hwnd, SB_VERT, OwnVerPos, TRUE);
    SetScrollPos( hwnd, SB_HORZ, OwnHorPos, TRUE);
}







/*
 *      InitOwnerScrollInfo
 */

void InitOwnerScrollInfo(void)

{
    OwnVerPos = OwnHorPos = OwnVerMin = OwnHorMin = 0;
    OwnVerMax = VPOSLAST;
    OwnHorMax = HPOSLAST;
}






/*
 *      UpdateCBMenu
 *
 * This routine is called once during initialisation and everytime
 * the contents of the clipboard change. This updates the entries
 * in the "Display" popup menu and the "grey" and "checked" status
 * based on the data formats available in the clipboard.
 */
void UpdateCBMenu(
    HWND    hwnd,
    HWND    hwndMDI)
{
register WORD   wFlags;         // Used to store the status flags for menu items
register UINT   fmt;
WORD            cFmt;
WORD            cCBCount;       // Number of data items in CB
int             iIndex;
int             nPopupCount;
BOOL            bAutoSelect;
TCHAR           szName[40];



    // Now clipboard contains at least one item...
    // Find out the number entries in the popup menu at present.

    // make sure child window is valid
    if ( !hwndMDI || !IsWindow(hwndMDI))
        {
        PERROR(TEXT("bad window arg to UpdateCBMenu\n\r"));
        return;
        }

    nPopupCount = GetMenuItemCount(hDispMenu);

    if (nPopupCount > 6)
        {
        // Delete all the entries in the popup menu below menu break. */
        for (iIndex = 6; iIndex < nPopupCount; iIndex++)
            {
            // NOTE: The second parameter must always be 6! (because we use
            // MF_BYPOSITION, when 6 is deleted, 7 becomes 6!).
            DeleteMenu(hDispMenu, 6, MF_BYPOSITION | MF_DELETE);
            }
        }


    // If this is not a page MDI window we don't want to show any entries
    if ( GETMDIINFO(hwndMDI)->DisplayMode  != DSP_PAGE )
        {
        return;
        }

    bAutoSelect = TRUE;



    if ((cCBCount = (WORD)VCountClipboardFormats( GETMDIINFO(hwndMDI)->pVClpbrd ))
        && VOpenClipboard( GETMDIINFO(hwndMDI)->pVClpbrd, hwnd))
        {
        AppendMenu ( hDispMenu, MF_SEPARATOR, 0, 0 );
        AppendMenu ( hDispMenu, MF_STRING, CBM_AUTO, szDefaultFormat );
        AppendMenu ( hDispMenu, MF_SEPARATOR, 0, 0 );

        for (fmt=0, cFmt=1; cFmt <= cCBCount; cFmt++)
            {
            wFlags = 0;
            fmt = VEnumClipboardFormats( GETMDIINFO(hwndMDI)->pVClpbrd, fmt );

            // don't show preview format in menu...
            if ( fmt != cf_preview )
                {
                switch (fmt)
                    {
                    case CF_TEXT:
                    case CF_OEMTEXT:
                    case CF_DSPTEXT:
                    case CF_UNICODETEXT:
                    case CF_DSPBITMAP:

                    case CF_DIB:
                    case CF_BITMAP:

                    case CF_METAFILEPICT:
                    case CF_DSPMETAFILEPICT:
                    case CF_ENHMETAFILE:
                    case CF_DSPENHMETAFILE:

                    case CF_OWNERDISPLAY:
                    case CF_PALETTE:
                    case CF_HDROP:
                    case CF_LOCALE:

                        /* can display all of these, put them on menu */

                        // Check if the current format is the one selected by the user
                        if (GETMDIINFO(hwndMDI)->CurSelFormat == fmt)
                            {
                            bAutoSelect = FALSE;
                            wFlags |= MF_CHECKED;
                            }

                        GetClipboardMenuName(fmt, szName, sizeof(szName));
                        AppendMenu (hDispMenu, wFlags, fmt, (LPTSTR)szName);

                        break;

                    default:        /* all the rest... later */
                        break;
                    }
                }
            }



        for (fmt=VEnumClipboardFormats (GETMDIINFO(hwndMDI)->pVClpbrd, 0);
             fmt;
             fmt=VEnumClipboardFormats (GETMDIINFO(hwndMDI)->pVClpbrd, fmt))
            if ( fmt != cf_preview )
                switch (fmt)
                    {
                    case CF_TEXT:
                    case CF_OEMTEXT:
                    case CF_DSPTEXT:
                    case CF_UNICODETEXT:
                    case CF_DSPBITMAP:
                    case CF_DIB:
                    case CF_BITMAP:
                    case CF_METAFILEPICT:
                    case CF_DSPMETAFILEPICT:
                    case CF_ENHMETAFILE:
                    case CF_DSPENHMETAFILE:
                    case CF_OWNERDISPLAY:
                    case CF_PALETTE:
                    case CF_HDROP:
                    case CF_LOCALE:
                        break;

                    default:
                        /* can't display this, put it on menu and gray it */

                        GetClipboardName(fmt, szName, sizeof(szName));
                        AppendMenu (hDispMenu, MF_GRAYED, fmt, (LPTSTR)szName);

                    //  NTRAID#DB-344956-2001/04/14-mdesai : add support for V5 bitmaps requires new strings, help changes, code to convert, etc
                    //  clipbrd was adding an empty string for this format; now we ignore the format
                    case CF_DIBV5:
                        break;
                    }




        VCloseClipboard( GETMDIINFO(hwndMDI)->pVClpbrd );

        if (bAutoSelect)
            {
            GETMDIINFO(hwndMDI)->CurSelFormat = CBM_AUTO;
            CheckMenuItem(hDispMenu, CBM_AUTO, MF_BYCOMMAND | MF_CHECKED);
            }

        // Enable the menu items in the top level menu.
        // EnableMenuItem(hMainMenu, 2, MF_BYPOSITION | MF_ENABLED);
        // EnableMenuItem(hMainMenu, CBM_CLEAR, MF_BYCOMMAND | MF_ENABLED);
        // EnableMenuItem(hMainMenu, CBM_SAVEAS, MF_BYCOMMAND | MF_ENABLED);
        }
    else
        {
        PERROR(TEXT("UpdateCBMenu:couldn't open clip, or no data on clip\r\n"));
        }

    DrawMenuBar(hwnd);

}








/*
 *      ClearClipboard
 *
 *  This is called to clear the clipboard.  If the clipboard is not
 *  empty the user is asked if it should be cleared.
 */

BOOL ClearClipboard (
    register HWND   hwnd)

{
register int    RetVal;

    if (CountClipboardFormats() <= 0)
       return(TRUE);

    if ( MessageBoxID( hInst, hwnd, IDS_CONFIRMCLEAR, IDS_CLEARTITLE,
          MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
        {
        if (RetVal = SyncOpenClipboard(hwnd))
            {
            // PINFO("ClearClipboard: emptied clipboard\r\n");
            RetVal &= EmptyClipboard();
            RetVal &= SyncCloseClipboard();
            }
        else
            {
            // PERROR("ClearClipboard: could not open\r\n");

            MessageBoxID (hInst,
                          hwnd,
                          IDS_CLEAR,
                          IDS_ERROR,
                          MB_OK | MB_SYSTEMMODAL | MB_ICONHAND);
            }

        InvalidateRect(hwnd, NULL, TRUE);
        return RetVal;
        }

    return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clipdsp.h ===
/*****************************************************************************

                C L I P B O O K   D I S P L A Y   H E A D E R

    Name:       clipdsp.h
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for clipdsp.c

    History:
        21-Jan-1994     John Fu, reformat and cleanup.

*****************************************************************************/






#define CDEFFMTS        8       // Count of predifined clipboard formats
#define VPOSLAST        100     // Highest vert scroll bar value
#define HPOSLAST        100     // Highest horiz scroll bar value
#define CCHFMTNAMEMAX   79      // Longest clipboard data fmt name, including
                                // terminator
#define cLineAlwaysShow 3       // # of "standard text height" lines to show
                                // when maximally scrolled down
#define BUFFERLEN       160     // String buffer length
#define SMALLBUFFERLEN  90

#define CBMENU          1       // Number for the Clipboard main menu





/* The menu ids */
#define CBM_AUTO        WM_USER
#define CBM_CLEAR       WM_USER+1
#define CBM_OPEN        WM_USER+2
#define CBM_SAVEAS      WM_USER+3
#define CBM_ABOUT       WM_USER+4
#define CBM_EXIT        WM_USER+5

// winball add-ons

#define CBM_SHAREAS		WM_USER+6
#define	CBM_IMPORT		WM_USER+7

// end winball add-ons

#define CBM_HELP	0xFFFF	 /* Standard numbers */
#define CBM_USEHELP     0xFFFC   /* Standard numbers */
#define CBM_SEARCH	0x0021





//  Last parameter to SetDIBits() and GetDIBits() calls

#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

#define IDCLEAR         IDOK







extern  BOOL        fOwnerDisplay;
extern  TCHAR       szMemErr[100];
extern  HBRUSH      hbrBackground;
extern  HMENU       hDispMenu;

extern  int         OwnVerMin;
extern  int         OwnVerMax;
extern  int         OwnHorMin;
extern  int         OwnHorMax;

extern  int         OwnVerPos;
extern  int         OwnHorPos;

extern  WORD        rgfmt[];



BOOL MyOpenClipboard(
    HWND    hWnd);


void SetCharDimensions(
    HWND    hWnd,
    HFONT   hFont);


void ChangeCharDimensions(
    HWND    hwnd,
    UINT    wOldFormat,
    UINT    wNewFormat);


void ClipbrdVScroll(
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb);


void ClipbrdHScroll(
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb);


int DibPaletteSize(
    LPBITMAPINFOHEADER  lpbi);


void DibGetInfo(
    HANDLE      hdib,
    LPBITMAP    pbm);


BOOL DrawDib(
    HWND    hwnd,
    HDC     hdc,
    int     x0,
    int     y0,
    HANDLE  hdib);


BOOL FShowDIBitmap(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          hdib,   //Bitmap in DIB format
    int             cxScroll,
    int             cyScroll);


BOOL FShowBitmap(
    HWND            hwnd,
    HDC             hdc,
    register PRECT  prc,
    HBITMAP         hbm,
    int             cxScroll,
    int             cyScroll);


BOOL FShowPalette(
    HWND hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HPALETTE        hpal,
    int             cxScroll,
    int             cyScroll);


int PxlConvert(
    int mm,
    int val,
    int pxlDeviceRes,
    int milDeviceRes);


BOOL FShowEnhMetaFile(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hemf,
    int             cxScroll,
    int             cyScroll);


BOOL CALLBACK EnumMetafileProc(
    HDC             hdc,
    HANDLETABLE FAR *lpht,
    METARECORD FAR  *lpmr,
    int             cObj,
    LPARAM          lParam);


BOOL FShowMetaFilePict(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hmfp,
    int             cxScroll,
    int             cyScroll);


void ShowString(
    HWND    hwnd,
    HDC     hdc,
    WORD    id);


LONG CchLineA(
    PMDIINFO    pMDI,
    HDC         hDC,
    CHAR        rgchBuf[],
    CHAR FAR    *lpch,
    INT         cchLine,
    WORD        wWidth);


LONG CchLineW(
    PMDIINFO    pMDI,
    HDC         hDC,
    WCHAR       rgchBuf[],
    WCHAR FAR   *lpch,
    INT         cchLine,
    WORD        wWidth);


void ShowText(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          h,
    INT             cyScroll,
    BOOL            fUnicode);


void SendOwnerMessage(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


void SendOwnerSizeMessage (
    HWND    hwnd,
    int     left,
    int     top,
    int     right,
    int     bottom);


UINT GetBestFormat(
    HWND    hwnd,
    UINT    wFormat);


void GetClipboardName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize);


void DrawFormat(
    register HDC    hdc,
    PRECT           prc,
    int             cxScroll,
    int             cyScroll,
    WORD            BestFormat,
    HWND            hwndMDI);


void DrawStuff(
    HWND                    hwnd,
    register PAINTSTRUCT    *pps,
    HWND                    hwndMDI);


void SaveOwnerScrollInfo (
    register HWND   hwnd);


void RestoreOwnerScrollInfo (
    register HWND   hwnd);


void InitOwnerScrollInfo(void);


void UpdateCBMenu(
    HWND    hwnd,
    HWND    hwndMDI);


BOOL ClearClipboard (
    register HWND   hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clpbkdlg.h ===
#define IDD_CONNECT                 100
#define IDC_CONNECTNAME             101
#define IDD_KEEPASDLG               300
#define IDC_KEEPASEDIT              301
#define IDC_STATICPAGENAME          302
#ifndef IDHELP
#define IDHELP                      303
#endif
#define IDC_SHARECHECKBOX           304
#define IDD_SHAREDLG                200
#define IDD_PROPERTYDLG             400
#define IDC_STATICSHRNAME           201
#define IDC_STARTAPP                203
#define IDC_APPINIT                 204
#define IDC_STATICSHARENAME         212
#define IDC_PERMISSIONS             202
#define IDC_MINIMIZED               215
#define IDC_ALLOWLINK               204

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvcomman.h ===
/******************************************************************************

                    C V C O M M A N D   H E A D E R

    Name:       cvcomman.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for cvcomman.c

******************************************************************************/



LRESULT OnIDMDelete(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wparam,
    LPARAM  lparam);


static void CreateClipboardWindow (void);


static void CreateLocalWindow (void);


void UnsharePage (void);


LRESULT OnIdmUnshare (DWORD dwItem);


LRESULT ClipBookCommand(
    HWND        hwnd,
    UINT        msg,
    WPARAM      wParam,
    LPARAM      lParam);


BOOL SetListboxEntryToPageWindow(
    HWND        hwndc,
    PMDIINFO    pMDIc,
    int         lbindex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clipbrd.c ===
/*****************************************************************************

                            C L I P B O A R D

    Name:       clipbrk.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the main clipbrd module.  It has the program entry point,
        the windows procedures and some major supporting functions.

    History:
        19-Apr-1994 John Fu     Add set hourglass cursors in some functions.
                                Fix status bar reset after menu selection.
                                Add code to get CF_BITMAP from CF_DIB.

        09-Aug-1994 John Fu     Mod WM_RENDERFORMAT so will render from file
                                when szSaveFileName is not "".

        03-Nov-1997 DrewM       Added support for context sensitive menus,
                                and shortend tool tips.

*****************************************************************************/





#define WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <lm.h>
#include <nddeapi.h>
#include <nddeagnt.h>
#include <stdio.h>
#include <htmlhelp.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "dialogs.h"
#include "clipdsp.h"
#include "cvutil.h"
#include "cvinit.h"
#include "auditchk.h"
#include "callback.h"
#include "debugout.h"
#include "helpids.h"
#include "initmenu.h"
#include "cvcomman.h"
#include "clipfile.h"
#include "strtok.h"
#include "security.h"










#ifndef UNICODE_CHARSET
#define UNICODE_CHARSET 1
#endif




//
// return code of OnPaint
//

#define ONPAINT_FAIL        0
#define ONPAINT_SUCCESS     1
#define ONPAINT_NOCLIPBRD   2






typedef  UINT (WINAPI *WNETCALL)(HWND, LPSTR, LPSTR, WORD, DWORD );







// Static data

static HHOOK    hMsgFilterHook;

// Stuff for dealing with minimized MDI children

static HCURSOR  hcurClipbook;
static HCURSOR  hcurClipbrd;
static HCURSOR  hcurRemote;
static BOOL     fClpOpen;





WNETCALL WNetServerBrowseDialog;

HANDLE  hmutexClp;                      // clipboard mutex
HANDLE  hXacting;                       // transaction event
HANDLE  hmodNetDriver;


HICON   hicClipbrd;
HICON   hicClipbook;
HICON   hicRemote;




HICON   hicLock;                        // Icon for Lock on thumbnail bitmaps
HFONT   hfontUni;                       // Handle for Unicode font, if it exists




// Application-wide flags

BOOL    fStatus;                         // status bar shown?
BOOL    fToolBar;                        // tool bar shown?
BOOL    fShareEnabled;                   // sharing allowed in system.ini?
BOOL    fNetDDEActive = TRUE;            // NetDDE detected?
BOOL    fAppLockedState = FALSE;         // app UI locked (see LockApp())
BOOL    fClipboardNeedsPainting = FALSE; // indicates deferred clp paint
BOOL    fSharePreference;                // shared checked on paste?
BOOL    fNeedToTileWindows = FALSE;      // need to tile windows on size
BOOL    fAppShuttingDown = FALSE;        // in process of closing
BOOL    fFillingClpFromDde = FALSE;      // in process of adding clp formats
BOOL    fAuditEnabled;

HWND    hwndNextViewer = NULL;           // for clpbrd viewer chain
HWND    hwndDummy;                       // used as dummy SetCapture target



// special case clipboard formats

UINT    cf_bitmap;                      // we send/receive these in private 'packed' format
UINT    cf_metafilepict;
UINT    cf_palette;

UINT    cf_preview;                     // PREVBMPSIZxPREVBMPSIZ preview bitmap private format



// these are formats that contain untranslated copies of link and objlink data

UINT    cf_objectlinkcopy;
UINT    cf_objectlink;
UINT    cf_linkcopy;
UINT    cf_link;




// DDEML

// These are effective constants created once and destroyed when we die

HSZ     hszSystem;
HSZ     hszTopics;
HSZ     hszDataSrv;
HSZ     hszFormatList;
HSZ     hszClpBookShare;


DWORD   dwCurrentHelpId = 0L;



// instance proc from MSGF_DDEMGR filter

WINDOWPLACEMENT Wpl;
HOOKPROC        lpMsgFilterProc;
HINSTANCE       hInst;
HACCEL          hAccel;

HFONT           hOldFont;
HFONT           hFontStatus;
HFONT           hFontPreview;



HWND        hwndActiveChild = 0;    // this handle identifies the currently active MDI window

PMDIINFO    pActiveMDI = NULL;      // this pointer points to the MDI info struct of the
                                    // active MDI window IT SHOULD ALWAYS ==
                                    // GETMDIINFO(hwndActiveChild)


HWND        hwndClpbrd = 0;         // this handle identifies the clipboard window
HWND        hwndLocal = 0;          // this handle identifies the local clipbook window
HWND        hwndClpOwner = 0;       // this handle identifies the clipboard owning MDI child (if any)
HWND        hwndMDIClient;          // handle to MDI Client window
HWND        hwndApp;                // global app window
HDC         hBtnDC;                 // memory DC used for owner draw stuff
HBITMAP     hOldBitmap;
HBITMAP     hPreviewBmp;
HBITMAP     hPgUpBmp;
HBITMAP     hPgDnBmp;
HBITMAP     hPgUpDBmp;
HBITMAP     hPgDnDBmp;

int         dyStatus;               // height of status bar
int         dyButtonBar;            // height of button bar
int         dyPrevFont;             // height of listbox font - height+external



TCHAR       szHelpFile[]      = TEXT("clipbrd.hlp");
TCHAR       szChmHelpFile[]   = TEXT("clipbrd.chm");

TCHAR       szClipBookClass[] = TEXT("ClipBookWClass");     // frame window class
TCHAR       szChild[] = TEXT("CVchild");                    // Class name for MDI window
TCHAR       szDummy[] = TEXT("CVdummy");                    // class name of hidden dummy window

TCHAR       szNDDEcode[] = TEXT("NDDE$");
TCHAR       szNDDEcode1[] = TEXT("NDDE$0001");
TCHAR       szClpBookShare[] = TEXT("CLPBK$");


// localized strings
TCHAR       szHelv[SMLRCBUF];   // status line font
TCHAR       szAppName[SMLRCBUF];
TCHAR       szLocalClpBk[SMLRCBUF];
TCHAR       szSysClpBrd[SMLRCBUF];
TCHAR       szDataUnavail[BIGRCBUF];
TCHAR       szReadingItem[BIGRCBUF];
TCHAR       szViewHelpFmt[BIGRCBUF];
TCHAR       szActivateFmt[BIGRCBUF];
TCHAR       szRendering[BIGRCBUF];
TCHAR       szDefaultFormat[BIGRCBUF];
TCHAR       szGettingData[BIGRCBUF];
TCHAR       szEstablishingConn[BIGRCBUF];
TCHAR       szClipBookOnFmt[BIGRCBUF];
TCHAR       szPageFmt[SMLRCBUF];
TCHAR       szPageFmtPl[SMLRCBUF];
TCHAR       szPageOfPageFmt[SMLRCBUF];
TCHAR       szDelete[SMLRCBUF];
TCHAR       szDeleteConfirmFmt[SMLRCBUF];
TCHAR       szFileFilter[BIGRCBUF];
TCHAR       *szFilter;




// Registry key strings
TCHAR szRoot[128];
TCHAR       szPref[]      = TEXT("Preferences");
TCHAR       szConn[]      = TEXT("Connections");
TCHAR       szStatusbar[] = TEXT("StatusBar");
TCHAR       szToolbar[]   = TEXT("ToolBar");
TCHAR       szShPref[]    = TEXT("AutoShare");
TCHAR       szEnableShr[] = TEXT("EnableShare");
TCHAR       szDefView[]   = TEXT("DefView");


#if DEBUG
TCHAR       szDebug[]     = TEXT("Debug");
#endif
TCHAR       szNull[]      = TEXT("");



HKEY hkeyRoot;


// buffers
TCHAR       szBuf[SZBUFSIZ];
TCHAR       szBuf2[SZBUFSIZ];

TCHAR       szConvPartner[128];                         // bigger than max server name
TCHAR       szKeepAs[ MAX_NDDESHARENAME + 2 ];


// DDEML stuff

DWORD      idInst = 0;                                  // DDEML handle







//
// Static function prototypes
//

static BOOL InitApplication (HINSTANCE hInstance);
static BOOL InitInstance (HINSTANCE hInstance, int nCmdShow);
static VOID StripCharRange (TCHAR *s, char lower, char upper);
static VOID SendMessageToKids (WORD msg, WPARAM wParam, LPARAM lParam);

static VOID StripAcceleratorKey (TCHAR *s);











////////////////////// functions //////////////////////////////////

int WINAPI WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow)
{
MSG         msg;
OFSTRUCT    of;
PMDIINFO    pMDI;

    #if DEBUG
    DebugLevel = 2;
    #endif



    LoadString(hInstance, IDS_APPNAME, szAppName, SMLRCBUF);

    // Only one instance is supported
    // hPrevInstance always == null under NT, so we have to rely on FWin.
    if (hwndApp = FindWindow(szClipBookClass, NULL))
        {
        PINFO(TEXT("Found previous instance\r\n"));

        if (IsIconic(hwndApp))
            {
            ShowWindow(hwndApp, SW_RESTORE);
            SetForegroundWindow(hwndApp);
            }
        else
            {
            SetForegroundWindow(hwndApp);
            }

        return FALSE;
        }



    if (!InitApplication(hInstance))
        {
        PERROR(TEXT("InitApp fail\r\n"));
        return (FALSE);
        }

    if (!InitInstance(hInstance, nCmdShow ))
        {
        PERROR(TEXT("InitInstance fail\r\n"));
        return (FALSE);
        }




    UpdateWindow ( hwndApp );



    // if we were started with the name of a file on the command line,
    // attempt to load the .clp file via an open dde execute

    if (OpenFile (lpCmdLine, &of, OF_EXIST) != HFILE_ERROR )
        {
        if ( ClearClipboard(hwndApp) )
            {
            #ifdef UNICODE
                TCHAR *ptch;

                ptch = (TCHAR *)LocalAlloc (LPTR, (lstrlenA(lpCmdLine) + 1) * sizeof(TCHAR));

                MultiByteToWideChar (CP_ACP,
                                     MB_PRECOMPOSED,
                                     lpCmdLine,
                                     -1,
                                     ptch,
                                     lstrlenA(lpCmdLine)+1);


                lstrcat(lstrcpy(szBuf, SZCMD_OPEN),ptch);
            #else
                lstrcat(lstrcpy(szBuf, SZCMD_OPEN),lpCmdLine);
            #endif

            if (pMDI = GETMDIINFO(hwndLocal))
                {
                MySyncXact ((LPBYTE)szBuf,
                            lstrlen(szBuf) +1,
                            pMDI->hExeConv,
                            0L,
                            CF_TEXT,
                            XTYP_EXECUTE,
                            SHORT_SYNC_TIMEOUT,
                            NULL );
                }

            InitializeMenu ( GetMenu(hwndApp) );
            }
        }




    while (GetMessage (&msg, NULL, 0, 0))
        {
        if (!TranslateMDISysAccel (hwndMDIClient, &msg) &&
           (hAccel? !TranslateAccelerator(hwndApp, hAccel, &msg): 1))
          {
          TranslateMessage (&msg);
          DispatchMessage (&msg);
          }
        }



    // Clear the mutex
    CloseHandle(hmutexClp);


    // free up our HSZ 'constants'
    DdeFreeStringHandle(idInst, hszTopics);
    DdeFreeStringHandle(idInst, hszFormatList );
    DdeFreeStringHandle(idInst, hszSystem);
    DdeFreeStringHandle(idInst, hszDataSrv);
    DdeFreeStringHandle(idInst, hszClpBookShare );
    DdeFreeStringHandle(idInst, hszErrorRequest);


    // Free icons & cursors
    DestroyIcon(hicClipbrd);
    DestroyIcon(hicClipbook);
    DestroyIcon(hicRemote);
    DestroyIcon(hicLock);
    DestroyCursor(hcurClipbrd);
    DestroyCursor(hcurClipbook);
    DestroyCursor(hcurRemote);


    DdeUninitialize(idInst);

    UnhookWindowsHookEx(hMsgFilterHook);

    return (int)(msg.wParam);

}








static BOOL  InitApplication (HINSTANCE hInstance)
{
WNDCLASS    wc;

    // Register the frame window
    wc.style = 0;
    wc.lpfnWndProc   = FrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon ( hInstance, MAKEINTRESOURCE(IDFRAMEICON) );
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;      // will paint whole client area
    wc.lpszMenuName  =  MAKEINTRESOURCE(IDCVMENU);
    wc.lpszClassName = szClipBookClass;

    if (0 == RegisterClass(&wc))
        {
        return FALSE;
        }

    // Register the MDI child class
    wc.lpfnWndProc   = ChildWndProc;
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = CBWNDEXTRA;
    wc.lpszClassName = szChild;
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.style         = CS_DBLCLKS;

    if (0 == RegisterClass(&wc))
        return FALSE;


    // register dummy window for SetCapture target
    wc.lpfnWndProc   = DefWindowProc;
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = 0;
    wc.lpszClassName = szDummy;
    wc.style         = 0;

    if (0 == RegisterClass(&wc))
        return FALSE;


    return TRUE;

}








/*
 *      SetupForFloatingProfile
 *
 *  To allow floating profile to work
 */

static void SetupForFloatingProfile ()
{
TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH+3] = TEXT("\\\\");
DWORD           cbName = sizeof(szComputerName);
NDDESHAREINFO   ShareInfo =
    {
    1,                          // revision
    szClpBookShare,
    SHARE_TYPE_STATIC,
    TEXT("ClipSrv|System\0\0"),
    TRUE,                       // shared
    TRUE,                       // a service
    FALSE,                      // cannot be started
    SW_SHOWNORMAL,
    {0,0},                      // mod id
    0,                          // no item list
    TEXT("")
    };


    START_NETDDE_SERVICES(hwndApp);

    GetComputerName (&szComputerName[2], &cbName);

    NDdeShareAdd (szComputerName,
                  2,
                  NULL,
                  (LPBYTE)&ShareInfo,
                  sizeof (ShareInfo));

    NDdeSetTrustedShare (szComputerName,
                         szClpBookShare,
                         NDDE_TRUST_SHARE_START |
                         NDDE_TRUST_SHARE_INIT);
}







// Purpose: Initialize a given instance of the application.
//
//
//////////////////////////////////////////////////////////////////////
BOOL InitInstance(
    HINSTANCE   hInstance,
    int         nCmdShow)
{
LOGFONT         UniFont;
DWORD           dwKeyStatus;
HMENU           hFileMenu;
SC_HANDLE       hsc;
SC_HANDLE       hsrvWksta;
SERVICE_STATUS  ss;
UINT            ddeErr;

// Stuff used to make the local server's name, "\\<computername>\NDDE$"
TCHAR           atchSrvName[MAX_COMPUTERNAME_LENGTH + 9];
DWORD           dwSize;

static TCHAR  szBuffer[256];
int    cch, i;
LCID        lcid = GetThreadLocale();

    hInst = hInstance;

    hmutexClp = CreateMutex(NULL, FALSE, SZMUTEXCLP);
    hXacting  = CreateEvent (NULL, FALSE, TRUE, NULL);


    hAccel = LoadAccelerators(hInstance, (LPCTSTR)MAKEINTRESOURCE(IDACCELERATORS));

    if (NULL == hAccel)
        {
        PERROR(TEXT("error loading accelerator table\n\r"));
        #ifndef DEBUG
            return FALSE;
        #endif
        }




    // Load cursors for dragging MDI children
    hcurClipbook = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_CLIPBOOK));
    hcurClipbrd  = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_CLIPBRD));
    hcurRemote   = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_REMOTE));


    // Load icons for MDI children
    hicClipbook = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_CLIPBOOK));
    hicClipbrd  = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_CLIPBRD));
    hicRemote   = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_REMOTE));



    // Load Lock icon
    hicLock = LoadIcon ( hInst, MAKEINTRESOURCE(IDLOCKICON));


    // Load the Unicode font, for displaying Unicode text.
    GetObject (GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), (LPBYTE)&UniFont);
    if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)
    {
        UniFont.lfCharSet = ANSI_CHARSET;
        lstrcpy ((LPTSTR)UniFont.lfFaceName, TEXT("Lucida Sans Unicode"));
    }
    else
    {
        UniFont.lfCharSet = UNICODE_CHARSET;
        lstrcpy ((LPTSTR)UniFont.lfFaceName, TEXT("Lucida Sans Unicode Regular"));
    }

    hfontUni = CreateFontIndirect(&UniFont);

    if (hfontUni == NULL)
        {
        hfontUni = (HFONT)GetStockObject(SYSTEM_FONT);
        }


    LoadIntlStrings();

    if(!szBuffer[0])
    {
        cch = LoadString( hInst, IDS_FILTERTEXT, szBuffer, sizeof(szBuffer) );
        for( i = 0; i <= cch; i++ )
            {
                szBuffer[i] = (szBuffer[i] == TEXT('\1')) ? TEXT('\0') : szBuffer[i];
            }
        szFilter = szBuffer;
    }

    // initialize variables in clipdsp.c
    fOwnerDisplay = FALSE;

    // initialize DDEML
    ddeErr = DdeInitialize (&idInst,(PFNCALLBACK)DdeCallback,APPCLASS_STANDARD, 0L);
    if (DMLERR_NO_ERROR != ddeErr)
        {
        PERROR(TEXT("The DDEML did not initialize\n\r"));
        DdeMessageBox (hInst, NULL, ddeErr, IDS_APPNAME, MB_OK|MB_ICONSTOP);
        return FALSE;
        }




    // create our hsz constants
    atchSrvName[0] = atchSrvName[1] = TEXT('\\');
    dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName(atchSrvName + 2, &dwSize);
    lstrcat(atchSrvName, TEXT("\\NDDE$"));

    hszDataSrv      = DdeCreateStringHandleA(idInst, atchSrvName,          CP_WINANSI);
    hszSystem       = DdeCreateStringHandleA(idInst, "CLPBK$",             CP_WINANSI);
    hszTopics       = DdeCreateStringHandleA(idInst, SZDDESYS_ITEM_TOPICS, CP_WINANSI);
    hszFormatList   = DdeCreateStringHandleA(idInst, SZ_FORMAT_LIST,       CP_WINANSI);
    hszClpBookShare = DdeCreateStringHandleA(idInst, szClpBookShare,       CP_WINANSI);
    hszErrorRequest = DdeCreateStringHandleA(idInst, SZ_ERR_REQUEST,       CP_WINANSI);

    if (DdeGetLastError(idInst) != DMLERR_NO_ERROR )
       {
       PERROR(TEXT("DDEML error during init\n\r"));
       return FALSE;
       }



    // We set this hook up so that we can catch the MSGF_DDEMGR message
    // which is called when DDEML is in a modal loop during synchronous
    // transaction processing.

    lpMsgFilterProc = (HOOKPROC)MyMsgFilterProc;
    hMsgFilterHook  = SetWindowsHookEx (WH_MSGFILTER,
                                        lpMsgFilterProc,
                                        hInst,
                                        GetCurrentThreadId());
    if (NULL == hMsgFilterHook)
        {
        PERROR(TEXT("SetWindowsHook failed\n\r"));
        return FALSE;
        }


    // get preference flags
    LoadString(hInst, IDS_CLPBKKEY, szRoot, sizeof(szRoot));
    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER,
                                         szRoot,
                                         0L,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_QUERY_VALUE |
                                         KEY_SET_VALUE   |
                                         KEY_ENUMERATE_SUB_KEYS,
                                         NULL,
                                         &hkeyRoot,
                                         &dwKeyStatus))
        {
        PERROR(TEXT("Could not set up root key\r\n"));
        fStatus          = TRUE;
        fToolBar         = TRUE;
        fSharePreference = TRUE;
        fShareEnabled    = FALSE;
        }
    else
        {
        DWORD iSize = sizeof(fStatus);

        PINFO (TEXT("Root key created. Key Status %ld."),dwKeyStatus);

        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szStatusbar,
                                              NULL, NULL, (LPBYTE)&fStatus, &iSize))
            {
            fStatus = TRUE;
            }

        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szToolbar,
                                              NULL, NULL, (LPBYTE)&fToolBar, &iSize))
            {
            fToolBar = TRUE;
            }

        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szShPref,
                                              NULL, NULL, (LPBYTE)&fSharePreference, &iSize))
             {
             fSharePreference = FALSE;
             }

        #if DEBUG
            if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szDebug, NULL, NULL,
                                                  (LPBYTE)&DebugLevel, &iSize))
                {
                DebugLevel = 2;
                }
        #endif

        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szEnableShr,
                                              NULL, NULL, (LPBYTE)&fShareEnabled, &iSize))
            {
            fShareEnabled = TRUE;
            }
        }






    // Figure out if NetBIOS is active or not, thus if we can net connect

    fNetDDEActive = FALSE;

    hsc = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (NULL != hsc)
        {
        hsrvWksta = OpenService(hsc, "LanmanWorkstation", SERVICE_QUERY_STATUS);
        if (NULL != hsrvWksta)
            {
            if (QueryServiceStatus(hsrvWksta, &ss))
                {
                if (ss.dwCurrentState == SERVICE_RUNNING)
                    {
                    fNetDDEActive = TRUE;
                    }
                }
            CloseServiceHandle(hsrvWksta);
            }
        CloseServiceHandle(hsc);
        }
    else
       {
       PERROR(TEXT("Couldn't open SC mgr\r\n"));
       }


    //  override if not on a domain
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS nsjs;
    
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
        {
            if ( nsjs != NetSetupDomainName)
                fNetDDEActive = FALSE;
            NetApiBufferFree(pszDomain);
        }
    }



    fAuditEnabled = AuditPrivilege(AUDIT_PRIVILEGE_CHECK);

    // Create main window
    if ( !( hwndApp = CreateWindow (szClipBookClass,
                                    szAppName,
                                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    NULL,
                                    NULL,
                                    hInstance,
                                    NULL)))
        {
        PERROR(TEXT("CreateWindow failed!\r\n"));
        return FALSE;
        }




    // To allow floating profile to work

    SetupForFloatingProfile ();




    // Get the handle to the Display popup menu for adding format entries
    hDispMenu = GetSubMenu( GetMenu(hwndApp), DISPLAY_MENU_INDEX);



    hFileMenu = GetSubMenu(GetMenu(hwndApp), 0);

    // get rid of share menu entries?
    if ( !fShareEnabled )
        {
        EnableMenuItem ( hFileMenu, IDM_SHARE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_UNSHARE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
        }



    // get rid of connect/disonnect entries?
    if ( !fNetDDEActive )
        {
        EnableMenuItem ( hFileMenu, IDM_CONNECT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_DISCONNECT, MF_BYCOMMAND | MF_GRAYED);
        }



    DrawMenuBar(hwndApp);

    // window placement...
    if ( ReadWindowPlacement ( szAppName, &Wpl ))
        {
        Wpl.showCmd = nCmdShow;
        Wpl.ptMaxPosition.x = -1;
        Wpl.ptMaxPosition.y = -1;
        SetWindowPlacement ( hwndApp, &Wpl );
        UpdateWindow(hwndApp);
        }
    else
        {
        ShowWindow ( hwndApp, nCmdShow );
        }




    // make our SetCapture target window
    if ( !( hwndDummy = CreateWindow (szDummy,
                                      szNull,
                                      WS_CHILD /*| WS_DISABLED*/ & ~WS_VISIBLE,
                                      0,
                                      0,
                                      0,
                                      0,
                                      hwndApp,
                                      NULL,
                                      hInstance,
                                      NULL )))
       return FALSE;




    // Make clipboard window -- needs to happen BEFORE we SetClipboardViewer,
    // 'cause hwndApp will get a WM_DRAWCLIPBOARD and there won't be any friggin'
    // windows.

    SendMessage ( hwndApp, WM_COMMAND, IDM_CLPWND, 0L );





    // Attach us to the clipboard viewer chain

    hwndNextViewer = SetClipboardViewer(hwndApp);



    // hconv=


    // create initial local window.

    SendMessage ( hwndApp, WM_COMMAND, IDM_LOCAL, 0L );



    // force paint before restoring other connections so we don't
    // have to wait too long. Should we do this earlier?

    UpdateWindow(hwndApp);




    // restore previous connections

    if ( fNetDDEActive )
        RestoreAllSavedConnections();

    return TRUE;

}


//Localized FE build uses "Bitmap(&B)" instead of "&Bitmap" in menu string.

VOID StripCharRange (
    TCHAR   *s,
    char    lower,
    char    upper)
{
    TCHAR *p = s, *q = s;

    while( *p ){

        if (IsDBCSLeadByte(*p)) {
            *q++ = *p++;
            *q++ = *p++;
        }
        else {
            if (*p < lower || *p > upper) *q++ = *p++;
            else
               *p++;
        }
     }
     *q = TEXT('\0');
}

VOID StripAcceleratorKey (
    TCHAR   *s)
{
TCHAR *p = s, *q = s;

    while( *p ) {
#ifndef UNICODE
        if (IsDBCSLeadByte(*p)) {
            *q++ = *p++;
            *q++ = *p++;
        }
        else
        {
            if ( (*p==TEXT('(')) && (*(p+1)==TEXT('&')) && (*(p+3)==TEXT(')')) )
                p += 4;
            else    *q++ = *p++;
        }

#else
        if ( (*p==TEXT('(')) && (*(p+1)==TEXT('&')) && (*(p+3)==TEXT(')')) )
                p += 4;
        else    *q++ = *p++;
#endif

    }
    *q = TEXT('\0');
}







/////////////////////////////////////////////////////////////////////////////
//
// Purpose: Message handler for WM_DRAWCLIPBOARD
//
// Params:
//    hwnd - Window handle
/////////////////////////////////////////////////////////////////////////////

void OnDrawClipboard(
    HWND    hwnd)
{
UINT    wNewFormat;
UINT    wOldFormat;
HCURSOR hCursor;



    // If we are in a transaction, defer processing this message
    // until the next unlock - if we did this now we could cause
    // other apps to break...

    // clipboard may have been empty and now isn't


    InitializeMenu ( GetMenu(hwnd) );



    if (fAppLockedState)
        {
        fClipboardNeedsPainting = TRUE;
        }
    else
        {
        fClipboardNeedsPainting = FALSE;


        hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

        // Update the popup menu entries.
        // UpdateCBMenu( hwnd, hwndClpbrd ); ... NOT

        if (IsWindow ( hwndClpbrd ))
            {
            wOldFormat = GetBestFormat (hwndClpbrd,
                                        GETMDIINFO(hwndClpbrd)->CurSelFormat );

            GETMDIINFO(hwndClpbrd)->CurSelFormat          = CBM_AUTO;
            GETMDIINFO(hwndClpbrd)->fDisplayFormatChanged = TRUE;

            wNewFormat = GetBestFormat( hwndClpbrd, CBM_AUTO );

            // NOTE OwnerDisplay stuff applies only to the "real" clipboard!

            ShowHideControls(hwndClpbrd);

            if (wOldFormat == CF_OWNERDISPLAY)
                {
                /* Save the owner Display Scroll info */
                SaveOwnerScrollInfo(hwndClpbrd);
                ShowScrollBar ( hwndClpbrd, SB_BOTH, FALSE );
                ResetScrollInfo( hwndClpbrd );
                InvalidateRect ( hwndClpbrd, NULL, TRUE );
                }
            else
                {
                if (wNewFormat == CF_OWNERDISPLAY)
                    {
                    /* Restore the owner display scroll info */
                    ShowHideControls(hwndClpbrd);
                    ShowWindow ( pActiveMDI->hwndSizeBox, SW_HIDE );
                    RestoreOwnerScrollInfo(hwndClpbrd);
                    InvalidateRect ( hwndClpbrd, NULL, TRUE );
                    }
                else
                    {
                    // Change the character dimensions based on the format.
                    ChangeCharDimensions(hwndClpbrd, wOldFormat, wNewFormat);

                    // Initialize the owner display scroll info, because the
                    // contents have changed.
                    InitOwnerScrollInfo();

                    // Force a total repaint. fOwnerDisplay gets updated during
                    // a total repaint.
                    InvalidateRect(hwndClpbrd, NULL, TRUE);
                    ResetScrollInfo(hwndClpbrd);

                    // force update here BEFORE sending on WM_DRAWCLIPBOARD
                    UpdateWindow (hwndClpbrd);
                    }
                }
            }

        SetCursor (hCursor);
        }



    // Pass the message on to the next clipboard viewer in the chain.
    if (hwndNextViewer != NULL)
        {
        SendMessage(hwndNextViewer, WM_DRAWCLIPBOARD, 0, 0);
        }

}







LRESULT OnEraseBkgnd(
    HWND    hwnd,
    HDC     hdc)
{
// if (IsIconic(hwnd))
//    return(TRUE);
// else
    return DefMDIChildProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0L);
}








LRESULT OnPaint(
    HWND    hwnd)
{
PMDIINFO    pMDI;
PAINTSTRUCT ps;
HPALETTE    hpal;
HPALETTE    hpalT;
HBRUSH      hbr;
LRESULT     lRet = ONPAINT_FAIL;
HCURSOR     hCursor;



/*****

pMDI = GETMDIINFO(hwnd);
BeginPaint(hwnd, &ps);

if ( IsIconic ( hwnd ))
   {
//   DefMDIChildProc(hwnd, WM_ERASEBKGND, (WPARAM)ps.hdc, 0L);

   if ( pMDI->flags & F_CLPBRD )
      {
      DrawIcon ( ps.hdc, 0, 0, hicClipbrd);
      }
   else if ( pMDI->flags & F_LOCAL )
      {
      DrawIcon ( ps.hdc, 0, 0, hicClipbook);
      }
   else
      {
      DrawIcon ( ps.hdc, 0, 0, hicRemote);
      }
   }
else if ( pMDI->DisplayMode == DSP_PAGE )
   {
   HPALETTE hpal, hpalT;
   HBRUSH   hbr;

   // Fill background with proper color - DefMDIChildProc fills with
   // app_workspace.
   hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
   FillRect(ps.hdc, &ps.rcPaint, hbr);
   DeleteObject(hbr);

   if ( !fAppShuttingDown )
      {
      if ( VOpenClipboard( pMDI->pVClpbrd, hwnd))
         {
         SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
         SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));

         if (hpal = VGetClipboardData( pMDI->pVClpbrd, CF_PALETTE))
            {
            PINFO("Palette found, selecting & realizing\r\n");
            hpalT = SelectPalette(ps.hdc, hpal, pMDI != pActiveMDI );
            RealizePalette(ps.hdc);
            }

         DrawStuff( hwnd, &ps, hwnd );

         if (hpal)
            {
            // We don't want to put the DEFAULT palette in the foreground.
            SelectPalette(ps.hdc, hpalT, FALSE);
            }

         VCloseClipboard( pMDI->pVClpbrd );
         }
#if DEBUG
      else
         {
         SetStatusBarText("Clipboard changed but could not open");
         }
#endif
      }
   }
EndPaint(hwnd, &ps);
return 0L;

*****/


//JYF

    if (!(pMDI = GETMDIINFO(hwnd)))
        {
        return ONPAINT_FAIL;
        }


    hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));


    if ( IsIconic ( hwnd ))
        {
        BeginPaint(hwnd, &ps);

        //DefMDIChildProc(hwnd, WM_ERASEBKGND, (WPARAM)ps.hdc, 0L);

        if ( pMDI->flags & F_CLPBRD )
            {
            DrawIcon ( ps.hdc, 0, 0, hicClipbrd);
            }
        else if ( pMDI->flags & F_LOCAL )
            {
            DrawIcon ( ps.hdc, 0, 0, hicClipbook);
            }
        else
            {
            DrawIcon ( ps.hdc, 0, 0, hicRemote);
            }

        lRet = ONPAINT_SUCCESS;

        goto donePaint;
        }







    if (pMDI->DisplayMode != DSP_PAGE)
        {
        BeginPaint (hwnd, &ps);
        lRet = ONPAINT_FAIL;

        goto donePaint;
        }




    if (fAppShuttingDown)
        {
        BeginPaint (hwnd, &ps);
        lRet = ONPAINT_FAIL;

        goto donePaint;
        }



    if (!VOpenClipboard( pMDI->pVClpbrd, hwnd))
        {
        #if DEBUG
          SetStatusBarText("Clipboard changed but could not open");
        #endif
        lRet = ONPAINT_NOCLIPBRD;

        goto done;
        }



    BeginPaint (hwnd, &ps);


    // Fill background with proper color - DefMDIChildProc fills with
    // app_workspace.

    hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    FillRect(ps.hdc, &ps.rcPaint, hbr);
    DeleteObject(hbr);



    SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
    SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));

    if (hpal = VGetClipboardData( pMDI->pVClpbrd, CF_PALETTE))
        {
        PINFO("Palette found, selecting & realizing\r\n");
        hpalT = SelectPalette(ps.hdc, hpal, pMDI != pActiveMDI );
        RealizePalette(ps.hdc);
        }

    DrawStuff( hwnd, &ps, hwnd );

    if (hpal)
        {
        // We don't want to put the DEFAULT palette in the foreground.
        SelectPalette(ps.hdc, hpalT, FALSE);
        }

    VCloseClipboard( pMDI->pVClpbrd );

    lRet = ONPAINT_SUCCESS;






donePaint:

    EndPaint(hwnd, &ps);


done:
    SetCursor (hCursor);

    return lRet;
}


// window procedures
LRESULT CALLBACK FrameWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
int     tmp;



   // PINFO(TEXT("FrameWnd Msg: %u %ld %ld\r\n"), msg, wParam, lParam);


    switch (msg)
        {
        case WM_CREATE:
            {

            CLIENTCREATESTRUCT ccs;
            RECT               rc;

            /* Find window menu where children will be listed */
            ccs.hWindowMenu  = GetSubMenu (GetMenu(hwnd), WINDOW_MENU_INDEX );
            ccs.idFirstChild = 4100; // IDM_WINDOWCHILD;

            // initialize special case clipboard formats...
            // note that CF_BITMAP, CF_METAFILEPICT, CF_PALETTE are
            // re-registered in a private format because data for these
            // formats is exchanged between this app and clipsrv.exe in
            // a flat DDEML data handle - not the regular DDE interpretation
            // of a handle that carries those format IDs

            if (LoadString (hInst, CF_BITMAP, szBuf, SZBUFSIZ))
                cf_bitmap = RegisterClipboardFormat (szBuf);
            if (LoadString (hInst, CF_METAFILEPICT, szBuf, SZBUFSIZ))
                cf_metafilepict = RegisterClipboardFormat (szBuf);
            if (LoadString (hInst, CF_PALETTE, szBuf, SZBUFSIZ))
                cf_palette = RegisterClipboardFormat (szBuf);

            cf_preview        = RegisterClipboardFormat (SZPREVNAME);
            cf_link           = RegisterClipboardFormat (SZLINK);
            cf_linkcopy       = RegisterClipboardFormat (SZLINKCOPY);
            cf_objectlink     = RegisterClipboardFormat (SZOBJECTLINK);
            cf_objectlinkcopy = RegisterClipboardFormat (SZOBJECTLINKCOPY);

            CreateTools( hwnd );   // creates toolbar window, brushes, etc.

            // determine height of toolbar window and save...
            GetClientRect ( hwndToolbar, &rc );
            dyButtonBar = rc.bottom - rc.top +1;

            // determine height of statusbar window and save...
            GetClientRect ( hwndStatus, &rc );
            dyStatus = rc.bottom - rc.top;

            // Create the MDI client - will be sized later
            hwndMDIClient = CreateWindow ("mdiclient",
                                          NULL,
                                          WS_BORDER|
                                          WS_CHILD|
                                          WS_CLIPCHILDREN|
                                          MDIS_ALLCHILDSTYLES|
                                          WS_HSCROLL|
                                          WS_VSCROLL,
                                          0,
                                          0,
                                          0,
                                          0,
                                          hwnd,
                                          (HMENU)0xCAC,
                                          hInst,
                                          (LPVOID)&ccs);

            ShowWindow ( hwndMDIClient, SW_SHOW );
            }

            break;

        case WM_QUERYNEWPALETTE:
             // Tell the active document to realize in foreground.
            if ( hwndActiveChild )
                tmp = (WORD)SendMessage(hwndActiveChild, WM_QUERYNEWPALETTE,0, 0L);
            else
               break;

            // If mapping is unchanged, other documents could still change,
            // so give them a change to realize.
            if (!tmp)
              SendMessageToKids(WM_PALETTECHANGED, (WPARAM)hwndActiveChild, 0L);
            return(tmp);
            break;


        // System palette has changed, so pass it on to the children.
        case WM_PALETTECHANGED:
            SendMessageToKids(WM_PALETTECHANGED, wParam, lParam);
            break;


        case WM_MENUSELECT:
            PINFO(TEXT("MenuSelect %lx\r\n"), wParam);

            // no context menu help for popup entries
            if ( HIWORD(wParam) & MF_POPUP )
               {
               dwCurrentHelpId = 0;
               }
            else if ( HIWORD(wParam) & MF_SYSMENU )
               {
               dwCurrentHelpId = IDH_SYSMENU;
               }
            else
               {
               // We don't care if the menuitem's disabled, checked, whatever...
               wParam = LOWORD(wParam);

               // was this a dynamically added clipboard entry?
               if (( wParam >= 0xc000 && wParam <= 0xffff ||   // registerd format?
                  wParam >= CF_TEXT && wParam <= CF_ENHMETAFILE || // intrinsic format?
                  wParam >= CF_OWNERDISPLAY && wParam <= CF_DSPMETAFILEPICT )

                  // gotta exclude sc_ stuff - overlaps with formats
                  && ! ( wParam >= SC_SIZE && wParam <= SC_HOTKEY ) )
                  {
                  GetMenuString ( GetMenu(hwnd), (UINT)wParam,
                     szBuf2, SZBUFSIZ, MF_BYCOMMAND );
//Localized FE build uses "Bitmap(&B)" instead of "&Bitmap" in menu string.
                  StripAcceleratorKey( szBuf2 );
//For not localized string
                  StripCharRange ( szBuf2, '&', '&' );
                  wsprintf( szBuf, szViewHelpFmt, (LPSTR)szBuf2 );
                  SendMessage( hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)szBuf );

                  dwCurrentHelpId = (DWORD)(IDH_FORMATS_BASE + wParam);
                  break;
                  }

               if ( wParam >= 4100 && wParam <= 4200 )
                  {
                  GetMenuString (GetMenu(hwnd), (UINT)wParam,szBuf2,SZBUFSIZ, MF_BYCOMMAND);
                  StripCharRange ( szBuf2, '&', '&' );
                  StripCharRange ( szBuf2, '0', '9' );
                  wsprintf( szBuf, szActivateFmt, *szBuf2 == ' ' ? (LPSTR)(szBuf2+1) :
                     (LPSTR)szBuf2 );
                  SendMessage( hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPSTR)szBuf );
                  dwCurrentHelpId = IDH_NAMESWIND;
                  break;
                  }

               dwCurrentHelpId = (DWORD)(IDH_BASE + wParam);
               }

            MenuHelp( (WORD)msg, wParam, lParam, GetMenu(hwnd), hInst, hwndStatus, nIDs );
            break;

        case WM_F1DOWN:
            PINFO(TEXT("Help on context %ld\r\n"), dwCurrentHelpId);
            if ( dwCurrentHelpId )
               {
               WinHelp(hwndApp, szHelpFile, HELP_CONTEXT, dwCurrentHelpId );
               DrawMenuBar(hwndApp);
               }
            break;

        case WM_DRAWITEM:
            HandleOwnerDraw( hwnd, msg, wParam, lParam );
            break;

        case WM_INITMENU:
            InitializeMenu ((HMENU)wParam);
            UpdateCBMenu ( hwnd, hwndActiveChild );
            break;

        case WM_SYSCOLORCHANGE:
            DeleteTools( hwnd );
            CreateTools( hwnd );
            break;

        case WM_COMMAND:
            return ClipBookCommand ( hwnd, msg, wParam, lParam );

        case WM_CLOSE:

            #if DEBUG
               if ( fAppLockedState )
                  PERROR(TEXT("Very bad: WM_CLOSE while locked\n\r"));
            #endif

            // force all clipboard formats rendered before exiting
            // so we don't end up yielding in WM_RENDERALLFORMATS
            // and get into trouble.

            fAppShuttingDown = TRUE;

            ForceRenderAll(hwnd, (PVCLPBRD)NULL );
            PostMessage(hwnd, WM_CLOSE_REALLY, 0, 0L );
            WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);
            break;

        case WM_NOTIFY:
            {
            LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT) lParam;

            if (lpTTT->hdr.code == TTN_NEEDTEXT)
                {
                LoadString (hInst, (UINT)(MH_TOOLTIP + lpTTT->hdr.idFrom), lpTTT->szText, 80);
                return TRUE;
                }
            }
            break;

        case WM_CLOSE_REALLY:
            // this is necessary to avoid processing messages in our
            // queue when we yield getting the clipboard data in
            // ForceRenderAll and destroying the app prematurely
            return DefFrameProc (hwnd,hwndMDIClient,WM_CLOSE,0,0L);

        case WM_DESTROY:

            #if DEBUG
                if ( fAppLockedState )
                   {
                   PERROR(TEXT("Very bad: WM_DESTROY while locked\n\r"));
                   }
            #endif

            // Take us out of the viewer chain
            ChangeClipboardChain(hwnd, hwndNextViewer);

            DeleteTools ( hwnd );

            Wpl.length = sizeof ( Wpl );
            Wpl.flags = 0;
            GetWindowPlacement ( hwnd, &Wpl );
            SaveWindowPlacement ( &Wpl );

            if (hkeyRoot != NULL)
                {
                RegSetValueEx (hkeyRoot, szStatusbar, 0L, REG_DWORD,
                               (LPBYTE)&fStatus, sizeof(fStatus));
                RegSetValueEx (hkeyRoot, szToolbar, 0L, REG_DWORD,
                               (LPBYTE)&fToolBar, sizeof(fToolBar));
                RegSetValueEx (hkeyRoot, szShPref, 0L, REG_DWORD,
                               (LPBYTE)&fSharePreference, sizeof(fSharePreference));
                }

            PostQuitMessage (0);
            break;


        case WM_DRAWCLIPBOARD:
            OnDrawClipboard(hwnd);
            break;

        case WM_CHANGECBCHAIN:

            if (hwndNextViewer == NULL)
                return(FALSE);

            if ( (HWND)wParam == hwndNextViewer)
                {
                hwndNextViewer = (HWND)lParam;
                return(TRUE);
                }
             return(SendMessage(hwndNextViewer, WM_CHANGECBCHAIN, wParam, lParam));

        case WM_RENDERALLFORMATS:

            // WM_DESTROY follows close on the heels of this message, and
            // we will process it and die while another copy of FrameWndProc
            // is in sync DDEML transaction...
            //
            // Note that we now attempt to render all formats in WM_DESTROY
            // before doing the PostQuitMessage so we should not have to
            // respond to this message.

            break;

        case WM_RENDERFORMAT:
            {
            HDDEDATA    hListData = 0L;
            HDDEDATA    hFmtData  = 0L;
            HSZ         hszFmt    = 0L;
            LPTSTR      lpszList  = TEXT("");
            LPTSTR      q;
            DWORD       cbDataLen;
            UINT        RealFmt;
            UINT        uiErr;


            PINFO(TEXT("Frame WM_RENDERFORMAT: %d\r\n"),wParam);



            // If we did File/Save or File/Open then render from file.
            // When we get IDM_COPY, szSaveFileName will assigned ""

            if (szSaveFileName[0])
                {
                SetClipboardData((UINT)wParam, RenderFormatFromFile(szSaveFileName,
                    (WORD)wParam));
                break;
                }



            if ( !IsWindow(hwndClpOwner))
                {
                PERROR(TEXT("Strange?: null clipboard owner window!\n\r"));
                break;
                }


            DdeKeepStringHandle ( idInst, hszFormatList );

            hListData = MySyncXact (NULL,
                                    0L,
                                    GETMDIINFO(hwndClpOwner)->hClpConv,
                                    hszFormatList,
                                    CF_TEXT,
                                    XTYP_REQUEST,
                                    SHORT_SYNC_TIMEOUT,
                                    NULL);


            if (!hListData && !fAppShuttingDown)
                {
                uiErr = DdeGetLastError (idInst);
                PERROR (TEXT("WM_RENDERFORM: REQUEST for formatlist failed: %x\n\r"),uiErr);
                MessageBoxID (hInst,
                              hwnd,
                              IDS_DATAUNAVAIL,
                              IDS_APPNAME,
                              MB_OK|MB_ICONEXCLAMATION);
                break;
                }

            lpszList = (LPTSTR)DdeAccessData ( hListData, &cbDataLen );

            if (!lpszList && !fAppShuttingDown)
                {
                PERROR(TEXT("WM_RENDERFORM: DdeAccessData failed!\n\r"));
                MessageBoxID (hInst,
                              hwnd,
                              IDS_DATAUNAVAIL,
                              IDS_APPNAME,
                              MB_OK|MB_ICONEXCLAMATION);
                break;
                }


            for (q = strtokA (lpszList, "\t"); q; q = strtokA(NULL, "\t"))
                {
                RealFmt = MyGetFormat ( q, GETFORMAT_DONTLIE );

                if ( wParam == RealFmt || msg == WM_RENDERALLFORMATS )
                    {
                    PINFO(TEXT("Getting format %d\r\n"), RealFmt);

                    hszFmt = DdeCreateStringHandle ( idInst, q, 0 );

                    hFmtData = MySyncXact (NULL,
                                           0L,
                                           GETMDIINFO(hwndClpOwner)->hClpConv,
                                           hszFmt,
                                           MyGetFormat (q, GETFORMAT_LIE),
                                           XTYP_REQUEST,
                                           LONG_SYNC_TIMEOUT,
                                           NULL );

                    if (hFmtData)
                        {
                        SetClipboardFormatFromDDE ( hwndClpbrd, RealFmt , hFmtData );
                        // VSetClipboardData(NULL, RealFmt, hFmtData);
                        }
                    else
                        PERROR(TEXT("REQUEST for %s failed %x\n\r"), q, DdeGetLastError(idInst));

                    DdeFreeStringHandle (idInst, hszFmt);
                    }
                }

            DdeUnaccessData( hListData );
            DdeFreeDataHandle ( hListData );


            // Couldn't find Bitmap, try DIB and
            //  and convert it to Bitmap.

            if (wParam == CF_BITMAP && !hFmtData)
                {
                TCHAR   szName[40];

                GetClipboardName (CF_DIB, szName, sizeof (szName));
                hszFmt = DdeCreateStringHandle (idInst, szName, 0);
                hFmtData = MySyncXact (NULL,
                                       0L,
                                       GETMDIINFO (hwndClpOwner)->hClpConv,
                                       hszFmt,
                                       MyGetFormat (szName, GETFORMAT_LIE),
                                       XTYP_REQUEST,
                                       LONG_SYNC_TIMEOUT,
                                       NULL);
                if (hFmtData)
                    SetClipboardFormatFromDDE (hwndClpbrd, DDE_DIB2BITMAP, hFmtData);

                DdeFreeStringHandle (idInst, hszFmt);
                }


            break;
            }

        case WM_SIZE:
            SendMessage (hwndToolbar, WM_SIZE, 0, 0L);
            SendMessage (hwndStatus, WM_SIZE, 0, 0L);
            AdjustMDIClientSize();
            break;

        case WM_PARENTNOTIFY:
            // PINFO(TEXT("Recieved WM_PARENTNOTIFY %d %ld\r\n"), wParam, lParam);
            break;

        default:
            return DefFrameProc (hwnd,hwndMDIClient,msg,wParam,lParam);
        }


    return 0;

}










//////////////////////////////////////////////////////////////////////
LRESULT CALLBACK ChildWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPMEASUREITEMSTRUCT lpmisCtl;
HDC                 hdc;
int                 tmp;
PMDIINFO            pMDI;
int                 i;
HPALETTE            hCurrentPal, hOldPal;




    // PERROR(TEXT("ChildWndProc msg: %u %ld %ld\r\n"),msg, wParam, lParam);

    switch (msg)
        {
        case WM_MDIACTIVATE:
            SendMessage(hwndMDIClient, WM_MDIREFRESHMENU, 0, 0);
            DrawMenuBar(hwndApp);

            if ((HWND)lParam != hwnd)
               break;

            //else
            //   fall through


        case WM_SETFOCUS:
            hwndActiveChild = hwnd;
            if (!(pActiveMDI = GETMDIINFO(hwndActiveChild)))
                break;

            if ( pActiveMDI->DisplayMode != DSP_PAGE &&
                  IsWindow(  pActiveMDI->hWndListbox ))
                {
                SetFocus (  pActiveMDI->hWndListbox );
                }
            else
                {
                SetFocus (  hwndActiveChild );
                }

            InitializeMenu( GetMenu(hwndApp) );
            UpdateNofMStatus(hwndActiveChild);
            return (DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_LBUTTONDBLCLK:
            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO (hwnd)->DisplayMode == DSP_PAGE &&
                !(GETMDIINFO(hwnd)->flags & F_CLPBRD ))
                {
                if (GETMDIINFO(hwnd)->OldDisplayMode == DSP_LIST )
                    SendMessage ( hwndApp, WM_COMMAND, IDM_LISTVIEW, 0L );
                else if ( GETMDIINFO(hwnd)->OldDisplayMode == DSP_PREV )
                    SendMessage ( hwndApp, WM_COMMAND, IDM_PREVIEWS, 0L );
                }
            break;


        case WM_PALETTECHANGED:
            if (hwnd == (HWND)wParam)
                break;
            //else
            //  fall through


        case WM_QUERYNEWPALETTE:

            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO(hwnd)->DisplayMode != DSP_PAGE)
                return 0;

            i = 0;
            if (VOpenClipboard( GETMDIINFO(hwnd)->pVClpbrd, hwnd))
                {
                if ( hCurrentPal = VGetClipboardData( GETMDIINFO(hwnd)->pVClpbrd, CF_PALETTE))
                    {
                    hdc = GetDC(hwnd);
                    hOldPal = SelectPalette (hdc,
                                             hCurrentPal,
                                             (msg == WM_QUERYNEWPALETTE)? FALSE: TRUE);
                    i = RealizePalette(hdc);

                    SelectPalette(hdc, hOldPal, TRUE);
                    RealizePalette(hdc);
                    ReleaseDC(hwnd, hdc);
                    if (i)
                        InvalidateRect(hwnd, NULL, TRUE);
                    }
                VCloseClipboard( GETMDIINFO(hwnd)->pVClpbrd );
                }

            return(i);
            break;


        case WM_MENUSELECT:

            MenuHelp ((WORD)msg,
                      wParam,
                      lParam,
                      GetMenu(hwndApp),
                      hInst,
                      hwndStatus,
                      nIDs);
            break;


        case WM_CREATE:

            if ((pMDI = (LPMDIINFO)GlobalAllocPtr(GPTR, sizeof(MDIINFO))) == NULL)
                {
                PERROR(TEXT("MdiInfo alloc failed\n\r"));
                break;
                }

            SetWindowLongPtr (hwnd, GWL_MDIINFO, (LONG_PTR)pMDI);

            pMDI->DisplayMode           = DSP_LIST;
            pMDI->hExeConv              = 0L;
            pMDI->hClpConv              = 0L;
            pMDI->hVClpConv             = 0L;
            pMDI->flags                 = 0L;
            pMDI->CurSelFormat          = CBM_AUTO;
            pMDI->cyScrollLast          = -1L;
            pMDI->cxScrollLast          = -1;
            pMDI->cyScrollNow           = 0L;
            pMDI->cxScrollNow           = 0;
            pMDI->pVClpbrd              = NULL;
            pMDI->hszConvPartner        = 0L;
            pMDI->hszConvPartnerNP      = 0L;
            pMDI->hszClpTopic           = 0L;
            pMDI->fDisplayFormatChanged = TRUE;
            pMDI->hWndListbox           = CreateWindow (TEXT("listbox"),
                                                        szNull,
                                                        WS_CHILD |
                                                        LBS_STANDARD |
                                                        LBS_NOINTEGRALHEIGHT |
                                                        LBS_LISTVIEW,
                                                        0,
                                                        0,
                                                        100,
                                                        100,   // non zero size to work around
                                                               // possible USER bug which results
                                                               // in divide by zero
                                                        hwnd,
                                                        (HMENU)ID_LISTBOX,
                                                        hInst,
                                                        0L );

            // create the scroll bars
            pMDI->hwndVscroll = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_VERT,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_VSCROLL,
                                               hInst,
                                               0L);

            pMDI->hwndHscroll = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_HORZ,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_VSCROLL,
                                               hInst,
                                               0L);

            // create the corner size box
            pMDI->hwndSizeBox = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_SIZEBOX,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_SIZEBOX,
                                               hInst,
                                               0L);

            // create the page fwd/bkwd buttons
            pMDI->hwndPgUp    = CreateWindowW (L"button",
                                               L"",
                                               WS_CHILD | BS_OWNERDRAW,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_PAGEUP,
                                               hInst,
                                               0L);


            pMDI->hwndPgDown  = CreateWindowW (L"button",
                                               L"",
                                               WS_CHILD | BS_OWNERDRAW,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_PAGEDOWN,
                                               hInst,
                                               0L);

            SetCharDimensions( hwnd, GetStockObject (SYSTEM_FONT));
            break;


        case WM_VSCROLL:
            if (wParam != SB_THUMBTRACK)
                {
                if (fOwnerDisplay)
                    SendOwnerMessage (WM_VSCROLLCLIPBOARD, (WPARAM)hwnd, (LPARAM)wParam);
                else
                    ClipbrdVScroll (hwnd, LOWORD(wParam), HIWORD(wParam));
                }
            break;

        case WM_HSCROLL:
            if (wParam != SB_THUMBTRACK)
                {
                if (fOwnerDisplay)
                    SendOwnerMessage (WM_HSCROLLCLIPBOARD, (WPARAM)hwnd, (LPARAM)wParam);
                else
                    ClipbrdHScroll (hwnd, LOWORD(wParam), HIWORD(wParam));
                }
            break;

        //case WM_ERASEBKGND:
        //    break;
        //    return OnEraseBkgnd(hwnd,(HDC)wParam);

        case WM_QUERYDRAGICON:
            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO(hwnd)->flags & F_CLPBRD)
                return (LRESULT)hcurClipbrd;
            else if ( GETMDIINFO(hwnd)->flags & F_LOCAL )
                return (LRESULT)hcurClipbook;
            else
                return (LRESULT)hcurRemote;

        case WM_CLOSE:
            if (!GETMDIINFO(hwnd))
                {
                if (!(GETMDIINFO(hwnd)->flags & (F_CLPBRD | F_LOCAL)))
                    {
                    PINFO(TEXT("removing reconn for '%s'\n\r"), (LPSTR)GETMDIINFO(hwnd)->szBaseName);
                    // AnsiToOem ( GETMDIINFO(hwnd)->szBaseName, szBuf );

                    if (NULL != hkeyRoot)
                        {
                        lstrcpy(szBuf, GETMDIINFO(hwnd)->szBaseName);
                        lstrcat(szBuf, szConn);
                        RegDeleteValue(hkeyRoot, szBuf);

                        lstrcpy(szBuf, GETMDIINFO(hwnd)->szBaseName);
                        lstrcat(szBuf, szWindows);
                        RegDeleteValue(hkeyRoot, szBuf);
                        }
                    }
                }
            WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);
            return(DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_PAINT:
            switch (OnPaint(hwnd))
                {
                case ONPAINT_SUCCESS:   return TRUE;
                case ONPAINT_FAIL:      return FALSE;
                case ONPAINT_NOCLIPBRD: PostMessage (hwnd, msg, wParam, lParam);
                default:                return FALSE;
                }
            break;

        case WM_KEYDOWN:
            {
            WORD sb;

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            if ( pMDI->DisplayMode != DSP_PAGE )
                return (DefMDIChildProc(hwnd, msg, wParam, lParam));

            switch (wParam)
                {
                case VK_UP:
                    sb = SB_LINEUP;
                    goto VertScroll;
                case VK_DOWN:
                    sb = SB_LINEDOWN;
                    goto VertScroll;
                case VK_PRIOR:
                    sb = SB_PAGEUP;
                    goto VertScroll;
                case VK_NEXT:
                    sb = SB_PAGEDOWN;

                VertScroll:
                    SendMessage(hwnd, WM_VSCROLL, sb, 0L);
                    break;

                case VK_LEFT:
                    sb = SB_LINEUP;
                    goto HorzScroll;
                case VK_RIGHT:
                    sb = SB_LINEDOWN;
                    goto HorzScroll;
                case VK_TAB:
                    sb = (GetKeyState( VK_SHIFT ) < 0) ? SB_PAGEUP : SB_PAGEDOWN;
                HorzScroll:
                    SendMessage( hwnd, WM_HSCROLL, sb, 0L);
                    break;

                default:
                    return (DefMDIChildProc(hwnd, msg, wParam, lParam));
                }
            }
            break;

        case WM_SIZE:

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            AdjustControlSizes( hwnd );
            pMDI->fDisplayFormatChanged = TRUE;
            InvalidateRect (hwnd, NULL, FALSE);

            if ( pMDI->DisplayMode == DSP_PAGE )
                ResetScrollInfo ( hwnd );

            return (DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_DRAWITEM:

            HandleOwnerDraw( hwnd, msg, wParam, lParam );
            break;

        case WM_COMPAREITEM:

            if ( wParam != ID_LISTBOX )
               break;

            tmp = lstrcmpi (&((LPLISTENTRY)((LPCOMPAREITEMSTRUCT)lParam)->itemData1)->name[1],
                            &((LPLISTENTRY)((LPCOMPAREITEMSTRUCT)lParam)->itemData2)->name[1]);

            if ( tmp < 0 )
                {
                return -1;
                }
            else if (tmp > 0)
                {
                return 1;
                }
            else
                {
                return 0;
                }
            break;


        case WM_DELETEITEM:

            if ( wParam != ID_LISTBOX )
                break;

            // if item is marked for saving (for a new listbox), dont delete
            if ( ((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->fDelete == FALSE )
                break;

            // delete preview bmp if there is one
            if (((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->hbmp)
                DeleteObject (((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->hbmp);

            GlobalFreePtr( (LPVOID)((LPDELETEITEMSTRUCT)lParam)->itemData );
            break;

        case WM_MEASUREITEM:

            lpmisCtl = (MEASUREITEMSTRUCT *) lParam;

            switch ( wParam )
                {
                case ID_LISTBOX:
                    if (!GETMDIINFO(hwnd))
                        break;

                    if (GETMDIINFO(hwnd)->DisplayMode == DSP_LIST)
                        lpmisCtl->itemHeight = max( LSTBTDY, dyPrevFont + 1);
                    else
                        lpmisCtl->itemHeight = 3*dyPrevFont + PREVBMPSIZ + 2*PREVBRD;

                    break;
                case ID_PAGEUP:
                case ID_PAGEDOWN:
                    lpmisCtl->itemWidth = GetSystemMetrics ( SM_CXHSCROLL );
                    lpmisCtl->itemHeight = GetSystemMetrics ( SM_CYVSCROLL );
                    break;
                }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case ID_LISTBOX:
                    if (!GETMDIINFO(hwnd))
                        break;

                    if (!(IsWindow(GETMDIINFO(hwnd)->hWndListbox)))
                        break;

                    // InitializeMenu(GetMenu(hwndApp));

                    switch(HIWORD(wParam))
                        {
                        case LBN_SETFOCUS:
                        case LBN_SELCHANGE:
                           UpdateNofMStatus(hwnd);
                           InitializeMenu( GetMenu(hwndApp));
                           break;
                        case LBN_SELCANCEL:
                        case LBN_KILLFOCUS:
                           //UpdateNofMStatus(NULL);
                           break;
                        case LBN_DBLCLK:
                           // Double-clicks cause me to go to page view
                           //SendMessage ( hwndApp, WM_COMMAND, IDM_COPY, 0L );
                           SendMessage (hwndApp, WM_COMMAND, IDM_PAGEVIEW, 0L);
                           break;
                        }
                    break;

                case ID_PAGEUP:
                case ID_PAGEDOWN:
                    SendMessage ( hwndApp, WM_COMMAND, wParam, 0L );
                    break;

                default:
                    return(DefMDIChildProc(hwnd, WM_COMMAND, wParam, lParam));
                }
            break;


        case WM_SYSCOMMAND:
            // The Close menuitem on the system menus of the clipboard and
            // local clipbook windows should be greyed, so we shouldn't get
            // that message.
            switch ( wParam )
                {
                case SC_CLOSE:
                    if (!GETMDIINFO(hwnd))
                        break;

                    // don't allow close of local or clipboard
                    if (GETMDIINFO(hwnd)->flags & (F_LOCAL | F_CLPBRD))
                        wParam = SC_MINIMIZE;
                    break;
                default:
                    break;
                }
            return DefMDIChildProc(hwnd, msg, wParam, lParam );

        case WM_DESTROY:

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            DdeDisconnect( pMDI->hExeConv );

            if (pMDI->hClpConv)
                 DdeDisconnect ( pMDI->hClpConv );
            if (pMDI->hVClpConv)
                 DdeDisconnect ( pMDI->hVClpConv );
            if (pMDI->hszConvPartner)
                 DdeFreeStringHandle ( idInst, pMDI->hszConvPartner );
            if (pMDI->hszConvPartnerNP)
                 DdeFreeStringHandle ( idInst, pMDI->hszConvPartnerNP );
            if (pMDI->hszClpTopic)
                 DdeFreeStringHandle ( idInst, pMDI->hszClpTopic );
            if (pMDI->hszVClpTopic)
                 DdeFreeStringHandle ( idInst, pMDI->hszVClpTopic );

            if (pMDI->pVClpbrd)
                 DestroyVClipboard ( pMDI->pVClpbrd );

            if (hwnd == hwndLocal)
                 hwndLocal = NULL;
            if (hwnd == hwndClpbrd)
                 hwndClpbrd = NULL;

            // free up the MDI info struct
            GlobalFree ( (HGLOBAL)pMDI );

            break;

        default:
            return (DefMDIChildProc(hwnd, msg, wParam, lParam));
        }


    return 0L;

}










/****************************************************************************
 *
 *  FUNCTION   : SendMessageToKids
 *
 *  PURPOSE    : Send the given message with the given parameters to all
 *               of the MDI child windows.
 *
 *  RETURNS    : None.
 *
 ****************************************************************************/

VOID SendMessageToKids(
   WORD    msg,
   WPARAM  wParam,
   LPARAM  lParam)
{
register HWND   hwndT;


    hwndT = GetWindow (hwndMDIClient, GW_CHILD);
    while (hwndT)
        {
        SendMessage (hwndT, msg, wParam, lParam);
        hwndT = GetWindow(hwndT, GW_HWNDNEXT);
        }
}







BOOL SyncOpenClipboard(
    HWND    hwnd)
{
BOOL fOK;

    if (!fClpOpen)
        {
        // PINFO(TEXT("\r\nClipbook: Opening Clipboard\r\n"));

        WaitForSingleObject(hmutexClp, 0); //INFINITE);
        fOK = OpenClipboard(hwnd);

        if (!fOK)
            {
            PERROR("OpenClipboard failed\r\n");
            ReleaseMutex(hmutexClp);
            }
        else
            {
            fClpOpen = TRUE;
            }

        return fOK;
        }
    else
        {
        PERROR("Attempt at opening clipboard twice!\r\n");
        return(FALSE);
        }

    return fOK;
}






BOOL SyncCloseClipboard (void)
{
BOOL fOK;

    // PINFO(TEXT("\r\nClipbook: Closing Clipboard\r\n"));

    fOK = CloseClipboard();
    ReleaseMutex(hmutexClp);

    if (!fOK)
        {
        PERROR("CloseClipboard failed\r\n");
        }

    fClpOpen = FALSE;

    return fOK;

}

// REVIEWPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvinit.c ===
/*****************************************************************************

                    C L I P B O O K   I N I T

    Name:       cvinit.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:

*****************************************************************************/



#define    OEMRESOURCE
#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <math.h>
#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "cvinit.h"
#include "debugout.h"





#define MAXINT 0X80000000



static int SSplit[] = { 200, 500 };
static int SBorders[3] = { 20, 0, 0 };





HWND    hwndToolbar = NULL;
HWND    hwndStatus  = NULL;
HBITMAP hbmStatus   = NULL;


TCHAR   szWindows[]   =   TEXT("Windows");



DWORD nIDs[] =
    {
    MH_BASE ,MH_POPUPBASE, 0, 0   /* This list must be NULL terminated */
    };

TBBUTTON tbButtons[] = {
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {0,  IDM_CONNECT,   TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {1,  IDM_DISCONNECT,TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {2,  IDM_SHARE,     TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {3,  IDM_UNSHARE,   TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
#if 0
    {4,  IDM_UNDO,      TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
#endif
    {5,  IDM_COPY,      TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {6,  IDM_KEEP,      TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {7,  IDM_DELETE,    TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {8,  IDM_LISTVIEW,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0},
    {9,  IDM_PREVIEWS,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0},
    {10, IDM_PAGEVIEW,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0}
};







static int atoi(
    TCHAR   *pch);


static int GetHeightFromPointsString(
    PTSTR   szPoints);








#if 0
static int abs(init x);

int abs(int x)
{
    return (x < 0 ? -x : x);
}
#endif






static int atoi(
    TCHAR   *pch)
{
int n;
int nSign = 1;

    n = 0;
    if (*pch == '-')
        {
        nSign = -1;
        pch++;
        }
    else if (*pch == '+')
        {
        pch++;
        }


    while (*pch)
        {
        n = n * 10 + (*pch - '0');
        pch++;
        }

    return n * nSign;

}






static int GetHeightFromPointsString(PTSTR szPoints)
{
HDC hdc;
int height;

    hdc = GetDC(NULL);
    height = MulDiv(-atoi(szPoints), GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(NULL, hdc);

    return height;
}






VOID LoadIntlStrings (void)
{
    LoadString (hInst,   IDS_HELV, szHelv,32);
    LoadString (hInst, IDS_APPNAME, szAppName, 32);
    LoadString (hInst, IDS_LOCALCLIP, szLocalClpBk, 32);
    LoadString (hInst, IDS_CLIPBOARD, szSysClpBrd, 32);
    LoadString (hInst, IDS_DATAUNAVAIL, szDataUnavail, 64);
    LoadString (hInst, IDS_READINGITEM, szReadingItem, 64);
    LoadString (hInst, IDS_VIEWHELPFMT,
                szViewHelpFmt, sizeof(szViewHelpFmt)/sizeof(szViewHelpFmt[0]));
    LoadString (hInst, IDS_ACTIVATEFMT,
                szActivateFmt, sizeof(szActivateFmt)/sizeof(szActivateFmt[0]));
    LoadString (hInst, IDS_RENDERING, szRendering, 64);
    LoadString (hInst, IDS_DEFFORMAT, szDefaultFormat, 64);
    LoadString (hInst, IDS_GETTINGDATA, szGettingData, 64);
    LoadString (hInst, IDS_ESTABLISHING, szEstablishingConn, 64);
    LoadString (hInst, IDS_CLIPBOOKONFMT, szClipBookOnFmt, 64);
    LoadString (hInst, IDS_PAGEFMT, szPageFmt, 32);
    LoadString (hInst, IDS_PAGEFMTPL, szPageFmtPl, 32);
    LoadString (hInst, IDS_PAGEOFPAGEFMT, szPageOfPageFmt, 32);
    LoadString (hInst, IDS_DELETE, szDelete, 32 );
    LoadString (hInst, IDS_DELETECONFIRMFMT, szDeleteConfirmFmt, 32);
    LoadString (hInst, IDS_FILEFILTER, szFileFilter, 64);
}






VOID SaveWindowPlacement (
    PWINDOWPLACEMENT    pwp )
{
WINDOWPLACEMENT wp;
int             dir_num = 0;
HWND            hwnd;


    // save main window placement

    if (hkeyRoot != NULL)
       {
       pwp->length = sizeof(WINDOWPLACEMENT);
       lstrcat(lstrcpy(szBuf2, szWindows), szAppName);
       RegSetValueEx(hkeyRoot,
             szBuf2,
             0L,
             REG_BINARY,
             (LPBYTE)pwp,
             sizeof(WINDOWPLACEMENT));

       // write out dir window strings in reverse order
       // so that when we read them back in we get the same Z order
       wp.length = sizeof (WINDOWPLACEMENT);
       wp.flags = 0;

       for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
                hwnd = GetWindow(hwnd, GW_HWNDNEXT))
          {
          // don't save MDI icon title windows or search windows,
          // or any dir window which is currently recursing

          if (GetWindow(hwnd, GW_OWNER) == NULL &&
              GetWindowPlacement(hwnd, &wp) )
             {
             wp.length = sizeof(WINDOWPLACEMENT);
             wp.flags = (wp.showCmd == SW_SHOWMINIMIZED)
                   ? WPF_SETMINPOSITION : 0;

             if (GETMDIINFO(hwnd))
                 lstrcat(lstrcpy(szBuf2, szWindows), GETMDIINFO(hwnd)->szBaseName);

             RegSetValueEx(hkeyRoot,
                   szBuf2,
                   0L,
                   REG_BINARY,
                   (LPBYTE)&wp,
                   sizeof(wp));
             }
          }
       }

}







BOOL ReadWindowPlacement(
    LPTSTR              szKey,
    PWINDOWPLACEMENT    pwp)
{

    // AnsiToOem ( szKey, szBuf2 );
    if (hkeyRoot != NULL)
        {
        DWORD dwBufSize = sizeof(WINDOWPLACEMENT);

        lstrcat(lstrcpy(szBuf2, szWindows), szKey);
        RegQueryValueEx(hkeyRoot, szBuf2, NULL, NULL, (LPBYTE)pwp, &dwBufSize);

        if (pwp->length == sizeof(WINDOWPLACEMENT))
           {
           return TRUE;
           }
        else
           {
           PINFO(TEXT("ReadWindowPlacement: QueryValue failed\n\r"));
           }
        return FALSE;
        }

    PINFO(TEXT("ReadWindowPlacement: no entry\n\r"));

    return FALSE;

}









BOOL CreateTools(
    HWND    hwnd)
{
HDC hdc;
TEXTMETRIC tm;
int dyBorder;
int cx,cy;
HFONT hTmpFont;
SIZE  size;




    if ( !(hbrBackground = CreateSolidBrush ( GetSysColor(COLOR_WINDOW) )))
        return FALSE;


    if ( !(hbmStatus = CreateMappedBitmap(hInst, IDSTATUS, FALSE, NULL, 0)))
        return FALSE;


    // create toolbar and status bar windows
    // has all buttons initially...

    if ( !(hwndToolbar = CreateToolbarEx (hwnd,
                                          (fToolBar?WS_VISIBLE:0)|WS_BORDER|TBSTYLE_TOOLTIPS,
                                          IDC_TOOLBAR,
                                          11,
                                          hInst,
                                          IDBITMAP,
                                          tbButtons,
                                          sizeof(tbButtons)/sizeof(TBBUTTON),
                                          0,0,0,0,sizeof(TBBUTTON))))
        return FALSE;



    // get rid of share buttons?
    if (!fShareEnabled)
        {
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        }


    // get rid of connect/disonnect buttons?
    if (!fNetDDEActive)
        {
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        }


    if ( fToolBar )
        ShowWindow ( hwndToolbar, SW_SHOW );




    // create status bar

    if ( !(hwndStatus = CreateStatusWindow ((fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS,
                                            szNull,
                                            hwnd,
                                            IDSTATUS )))
       return FALSE;


    // now build the parameters based on the font we will be using

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    cx = GetSystemMetrics (SM_CXVSCROLL);
    cy = GetSystemMetrics (SM_CYHSCROLL);





    if ( hdc= GetDC(NULL) )
        {
        CHARSETINFO csi;
        DWORD dw = GetACP();
        LOGFONT lfDef; 

        GetObject( GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfDef );

        if (!TranslateCharsetInfo((DWORD*)(DWORD_PTR)dw, &csi, TCI_SRCCODEPAGE))
            csi.ciCharset = ANSI_CHARSET;

        // hPreviewBmp = CreateCompatibleBitmap ( hdc, 64, 64 );
        hPreviewBmp = CreateBitmap ( 64, 64, 1, 1, NULL );

        hBtnDC = CreateCompatibleDC ( hdc );

        hPgUpBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_UPARROW) );
        hPgDnBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_DNARROW) );
        hPgUpDBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_UPARROWD) );
        hPgDnDBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_DNARROWD) );
        // modify arrows
        // hOldBitmap = SelectObject ( hBtnDC, hPgUpBmp );
        // BitBlt ( hBtnDC, 4, cy/2 + 1, cx-8, (cy-8)/2, hBtnDC,
        //    4, cy/2 - 3, SRCCOPY );
        // SelectObject ( hBtnDC, hOldBitmap );

        hFontPreview = CreateFont (lfDef.lfHeight,
                                   0,
                                   0,
                                   0,
                                   400,
                                   0,
                                   0,
                                   0,
                                   csi.ciCharset,
                                   OUT_DEFAULT_PRECIS,
                                   CLIP_DEFAULT_PRECIS,
                                   DEFAULT_QUALITY,
                                   VARIABLE_PITCH | FF_SWISS,
                                   szHelv);


        hOldFont = SelectObject(hdc, hFontPreview);

        GetTextMetrics(hdc, &tm);
        dyPrevFont = tm.tmHeight + tm.tmExternalLeading;



        if (hOldFont)
           SelectObject(hdc, hOldFont);

        // figure out where to put the first status bar splitpoint
        SendMessage ( hwndStatus, SB_GETBORDERS, 0, (LPARAM)(LPBYTE)&SBorders );

        if ( hTmpFont = (HFONT)SendMessage(hwndStatus, WM_GETFONT, 0, 0L ))
            {
            if ( hOldFont = SelectObject ( hdc, hTmpFont ))
                {
                wsprintf ( szBuf, szPageOfPageFmt, 888, 888 );

                GetTextExtentPoint(hdc, szBuf, lstrlen(szBuf),&size);
                SSplit[0] = size.cx + 2 * GetSystemMetrics(SM_CXBORDER)
                   + 2 * SBorders[0];   //doesn't quite wash

                if ( hOldFont )
                    SelectObject( hdc, hOldFont );
                }
            }
        ReleaseDC(NULL, hdc);

        if ( !hTmpFont || !hPgUpBmp || !hPgDnBmp || !hPgUpDBmp ||
           !hFontPreview || !hPreviewBmp || !hBtnDC )
        return FALSE;
        }
    else
        return FALSE;

    //second split point is fixed for now.

    SendMessage ( hwndStatus, SB_SETPARTS, 2, (LPARAM)(LPBYTE)&SSplit );
    return TRUE;

}








VOID DeleteTools (
    HWND    hwnd)
{
    DeleteDC ( hBtnDC );

    DeleteObject ( hPreviewBmp );

    DeleteObject ( hbmStatus );
    DeleteObject ( hFontPreview );
    DeleteObject ( hbrBackground );

    DeleteObject ( hPgUpBmp );
    DeleteObject ( hPgDnBmp );
    DeleteObject ( hPgUpDBmp );
    DeleteObject ( hPgDnDBmp );

    DestroyWindow(hwndToolbar);
    DestroyWindow(hwndStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvinit.h ===
/*****************************************************************************

                    C V I N I T   H E A D E R

    Name:       cvinit.h
    Date:       20-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for cvinit.c

*****************************************************************************/



extern  HWND        hwndToolbar;
extern  HWND        hwndStatus;
extern  HBITMAP     hbmStatus;

extern  TCHAR       szWindows[];

extern  DWORD       nIDs[];
extern  TBBUTTON    tbButtons[];












VOID LoadIntlStrings (void);


VOID SaveWindowPlacement (
    PWINDOWPLACEMENT    pwp);


BOOL ReadWindowPlacement(
    LPTSTR              szKey,
    PWINDOWPLACEMENT    pwp);


BOOL CreateTools(
    HWND    hwnd);


VOID DeleteTools(
    HWND    hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\clpbkrc.h ===
/*****************************************************************************

                C L I P B O O K   R E S O U R C E S   H E A D E R

    Name:       clpblkrc.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This file contains definitions of the resource IDs.

*****************************************************************************/


// resource ID's
#define     IDACCELERATORS      1
#define     IDFRAMEICON         2
#define     IDI_CLIPBRD         3
#define     IDI_CLIPBOOK        4
#define     IDI_REMOTE          5
#define     IDBITMAP            6
#define     IDSTATUS            7
#define     IDCVMENU            8
#define     IBM_UPARROW         9
#define     IBM_DNARROW         10
#define     IBM_UPARROWD        11
#define     IBM_DNARROWD        12
#define     IDLOCKICON          13
#define     IDSHAREICON         14
#define     IDC_TOOLBAR         401

#define     IDC_CLIPBOOK        16
#define     IDC_CLIPBRD         17
#define     IDC_REMOTE          18



// user defined messages
#define     WM_CLOSE_REALLY     WM_USER
#define     WM_F1DOWN           (WM_USER + 1)




// menuhelp constants
#define     MH_BASE             10000
#define     MH_POPUPBASE        0x1100
#define     MH_TOOLTIP          0x1200
#define     IDH_FORMATS_BASE    10400
#define     IDH_BASE            10000


/*
 *  main menu items
 */

#define IDM_FIRST               20

#define IDM_ABOUT               20
#define IDM_EXIT                21
#define IDM_COPY                22
#define IDM_DELETE              23
#define IDM_SHARE               24
#define IDM_LOCAL               25
#define IDM_PROPERTIES          26
#define IDM_OPEN                27
#define IDM_SAVEAS              28
#define IDM_NOP                 29
#define IDM_CONNECT             30
#define IDM_DISCONNECT          31
#define IDM_CONTENTS            32
#define IDM_SEARCHHELP          33
#define IDM_HELPHELP            34
#define IDM_KEEP                35
#define IDM_UNSHARE             36
#define IDM_TOOLBAR             37
#define IDM_STATUSBAR           38
#define IDM_TILEVERT            39
#define IDM_CASCADE             40
#define IDM_ARRANGEICONS        41
#define IDM_CLPWND              43
#define IDM_REFRESH             44
#define IDM_LISTVIEW            45
#define IDM_PREVIEWS            46
#define IDM_PAGEVIEW            47
#define IDM_TILEHORZ            48
#define IDM_PERMISSIONS         49
#define IDM_AUDITING            50
#define IDM_OWNER               51
#define IDM_PASTE_PAGE          52

// following have no actual menu items
#define IDM_UPDATE_PAGEVIEW     53

#define IDM_LAST                53




// strings
#define IDS_HELV                21
#define IDS_APPNAME             22
#define IDS_SHROBJNAME          23
#define IDS_INTERNALERR         26
#define IDS_LOCALCLIP           27
#define IDS_CLIPBOARD           28
#define IDS_DATAUNAVAIL         29
#define IDS_READINGITEM         30
#define IDS_VIEWHELPFMT         31
#define IDS_ACTIVATEFMT         32
#define IDS_RENDERING           33
#define IDS_DEFFORMAT           34
#define IDS_GETTINGDATA         35
#define IDS_NAMEEXISTS          36
#define IDS_NOCONNECTION        38
#define IDS_ESTABLISHING        39
#define IDS_CLIPBOOKONFMT       40
#define IDS_PAGEFMT             41
#define IDS_PAGEFMTPL           42
#define IDS_PAGEOFPAGEFMT       43
#define IDS_DELETE              44
#define IDS_DELETECONFIRMFMT    45
#define IDS_FILEFILTER          46
#define IDS_PASTEDLGTITLE       47
#define IDS_SHAREDLGTITLE       48
#define IDS_PAGENAMESYNTAX      49
#define IDS_PASSWORDSYNTAX      50
#define IDS_SHARINGERROR        51
#define IDS_MAXPAGESERROR       52
#define IDS_PRIVILEGEERROR      53
#define IDS_CB_PAGE             54
#define IDS_NOCLPBOOK           55
#define IDS_GETPERMS            56
#define IDS_FILTERTEXT          57      // Filter string in FileType combo-box
#define IDS_TSNOTSUPPORTED      58      // Not Supported from a remote session

// Header text string ids
#define IDS_ERROR               202     // as string ids.  Be sure to keep these
#define IDS_BINARY              203     // different.
#define IDS_CLEAR               204
#define IDS_CANTDISPLAY         207     // "Can't display data in this format"
#define IDS_NOTRENDERED         208     // "Application Couldn't render data"
#define IDS_ALREADYOPEN         209     // OpenClipboard() fails */
#define IDS_MEMERROR            210

// clausgi addition.. planes/bitsperpixel don't match...
#define IDS_BADBMPFMT           211
#define IDS_CLEARTITLE          212
#define IDS_CONFIRMCLEAR        213

#define IDS_TRUSTSHRKEY         256
#define IDS_CLPBKKEY            257


// First permission name -- starts an array of permnames.
#define IDS_PERMNAMEFIRST       0x0400
#define IDS_AUDITNAMEFIRST      0x0500

// control ID's
#define ID_LISTBOX              200
#define ID_VSCROLL              201
#define ID_HSCROLL              202
#define ID_SIZEBOX              203
#define ID_PAGEUP               204
#define ID_PAGEDOWN             205

// For "Special" Text
#define IDS_SPECIAL             1000

//For Menu string of Clipboard Format name.
#define MNDELTA                 500
#define CF_MN_TEXT              CF_TEXT            + MNDELTA
#define CF_MN_BITMAP            CF_BITMAP          + MNDELTA
#define CF_MN_METAFILEPICT      CF_METAFILEPICT    + MNDELTA
#define CF_MN_SYLK              CF_SYLK            + MNDELTA
#define CF_MN_DIF               CF_DIF             + MNDELTA
#define CF_MN_TIFF              CF_TIFF            + MNDELTA
#define CF_MN_OEMTEXT           CF_OEMTEXT         + MNDELTA
#define CF_MN_DIB               CF_DIB             + MNDELTA
#define CF_MN_PALETTE           CF_PALETTE         + MNDELTA
#define CF_MN_PENDATA           CF_PENDATA         + MNDELTA
#define CF_MN_RIFF              CF_RIFF            + MNDELTA
#define CF_MN_WAVE              CF_WAVE            + MNDELTA
#define CF_MN_OWNERDISPLAY      CF_OWNERDISPLAY    + MNDELTA
#define CF_MN_DSPTEXT           CF_DSPTEXT         + MNDELTA
#define CF_MN_DSPBITMAP         CF_DSPBITMAP       + MNDELTA
#define CF_MN_DSPMETAFILEPICT   CF_DSPMETAFILEPICT + MNDELTA
#define CF_MN_ENHMETAFILE       CF_ENHMETAFILE     + MNDELTA
#define CF_MN_DSPENHMETAFILE    CF_DSPENHMETAFILE  + MNDELTA
#define CF_MN_UNICODETEXT       CF_UNICODETEXT     + MNDELTA
#define CF_MN_HDROP             CF_HDROP           + MNDELTA
#define CF_MN_LOCALE            CF_LOCALE          + MNDELTA

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvcomman.c ===
/*****************************************************************************

                C L I P B O O K   V I E W E R   C O M M A N D S

    Name:       cvcomman.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This module handles all WM_COMMAND's.

    History:
        19-Apr-1994 John Fu     Add defines for FOCUSDLG_ to allow wider
                                browse in remote connect dialog.

        30-Jun-1994 John Fu     Add better cleanup in OnIDMDelete and OnIDMKeep
                                Now will delete the trust share and if problem
                                creating a page will ask server to delete it
                                as well.

        09-Aug-1994 John Fu     Changed IDM_SAVEAS, IDM_OPEN to save/open file
                                directly without the clipbook server.
                                Changed IDM_COPY to assign szSaveFileName to
                                "" so when WM_RENDERFORMAT will render through
                                DDE from clipbook server.

        13-Mar-1995 John Fu     Add hXacting event for timing related problems
                                Add capability to Paste to Page
                                Add IDM_UPDATE_PAGEVIEW

        03-Nov-1997 DrewM       Add support for context sensitive help
                                Add support for 15 character computer names
                                    (bug 2767)
                                Add call to UpdateListBox to remove the hand
                                    icon when a page is unshared. (bug 41147)

*****************************************************************************/





#define    NOAUTOUPDATE 1
#define    MAX_FILENAME_LENGTH 255

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <nddeapi.h>
#include <shellapi.h>
#include <assert.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "dialogs.h"
#include "clpbkdlg.h"
#include "cvcomman.h"
#include "cvinit.h"
#include "cvutil.h"
#include "helpids.h"
#include "debugout.h"
#include "initmenu.h"
#include "shares.h"
#include "clipfile.h"

#include <htmlhelp.h>


// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPTSTR, LPTSTR, HICON);




// Flags and typedef for the NT LanMan computer browser dialog.
// The actual function is I_SystemFocusDialog, in NTLANMAN.DLL.
#define FOCUSDLG_DOMAINS_ONLY        (1)
#define FOCUSDLG_SERVERS_ONLY        (2)
#define FOCUSDLG_SERVERS_AND_DOMAINS (3)

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

typedef UINT (APIENTRY *LPFNSYSFOCUS)(HWND, UINT, LPWSTR, UINT, PBOOL, LPWSTR, DWORD);


static TCHAR szDirName[256] = {'\0',};









///////////////////////////////////////////////////////////////////////
//
// Purpose: Delete the selected share.
//
///////////////////////////////////////////////////////////////////////
LRESULT OnIDMDelete(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wparam,
    LPARAM  lparam)
{
int         tmp;
LPLISTENTRY lpLE;
LISTENTRY   LE;
LRESULT     ret = FALSE;
TCHAR       PageName[MAX_PAGENAME_LENGTH+1];


    if (!pActiveMDI)
        return 0L;



    // Doing a "delete" on the clipboard window clears clipboard
    if (pActiveMDI->flags & F_CLPBRD)
        {
        if ( ClearClipboard(hwndApp) == IDOK )
            {
            EmptyClipboard();
            InitializeMenu ( GetMenu(hwnd) );

            // Force redraw of clipboard window
            if (hwndClpbrd)
                {
                InvalidateRect(hwndClpbrd, NULL, TRUE);
                ret = TRUE;
                }
            }

        return ret;
        }





    tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (tmp == LB_ERR)
        {
        PERROR("Could not figure out which item was selected!\r\n");
        return ret;
        }



    SendMessage ( pActiveMDI->hWndListbox, LB_GETTEXT, tmp, (LPARAM)(LPCSTR)&lpLE);
    memcpy(&LE, lpLE, sizeof(LE));

    wsprintf(szBuf, szDeleteConfirmFmt, (LPTSTR)((lpLE->name)+1) );
    MessageBeep ( MB_ICONEXCLAMATION );

    lstrcpy (PageName, lpLE->name);

    if (MessageBox ( hwndApp, szBuf, szDelete, MB_ICONEXCLAMATION|MB_OKCANCEL ) != IDCANCEL)
        {
        AssertConnection ( hwndActiveChild );

        if ( hwndActiveChild == hwndClpOwner )
            {
            ForceRenderAll( hwnd, NULL );
            }


        // Perform an execute to the server to let it know that
        // we're not sharing anymore.

        wsprintf(szBuf,TEXT("%s%s"), SZCMD_DELETE, lpLE->name);

        if (MySyncXact (szBuf,
                        lstrlen(szBuf) +1,
                        pActiveMDI->hExeConv,
                        0L,
                        CF_TEXT,
                        XTYP_EXECUTE,
                        SHORT_SYNC_TIMEOUT,
                        NULL)
            )
            {
            TCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+3] = TEXT("\\\\");
            DWORD   CNLen = sizeof (ComputerName);


            // Need to delete the trust
            GetComputerName (ComputerName+2, &CNLen);
            #ifdef USETWOSHARESPERPAGE
                if (fSharePreference)
                    PageName[0] = SHR_CHAR;
                else
                    PageName[0] = UNSHR_CHAR;
            #else
                PageName[0] = SHR_CHAR;
            #endif
            NDdeSetTrustedShare (ComputerName, PageName, NDDE_TRUST_SHARE_DEL);



            if ( pActiveMDI->DisplayMode == DSP_PAGE )
                {
                PINFO(TEXT("forcing back to list mode\n\r"));
                SendMessage (hwndApp, WM_COMMAND,
                             pActiveMDI->OldDisplayMode == DSP_PREV ?
                               IDM_PREVIEWS : IDM_LISTVIEW,
                             0L );
                }

            UpdateListBox (hwndActiveChild, pActiveMDI->hExeConv);
            InitializeMenu (GetMenu(hwndApp));
            }
        else
            {
            XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONHAND);
            }
        }



    return ret;

}








/*
 *      OnIDMKeep
 *
 *
 *  Purpose: Create a Clipbook page.
 */

LRESULT OnIDMKeep (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL    bNewPage)
{
PMDIINFO        pMDI;
int             tmp;
DWORD           ret;
HANDLE          hData;
PNDDESHAREINFO  lpDdeInfo = NULL;
TCHAR           atchItem[256];
#ifdef NOOLEITEMSPERMIT
    unsigned    i;
#endif
LPTSTR          lpEnd; // Pointer to the end of the current data block
TCHAR           rgtchCName[MAX_COMPUTERNAME_LENGTH + 3];
DWORD           dwLen;
HCURSOR         hCursor = NULL;
BOOL            bShareSave = fSharePreference;
KEEPASDLG_PARAM KeepAs;






    if (!CountClipboardFormats())
        {
        PERROR (TEXT("Paste entered with no data on the clipboard!\r\n"));
        goto done;
        }



    if (!hwndLocal || !IsWindow(hwndLocal))
        {
        MessageBoxID (hInst, hwnd, IDS_NOCLPBOOK, IDS_APPNAME, MB_OK | MB_ICONSTOP);
        goto done;
        }



    if (!pActiveMDI)
        goto done;




    pMDI = GETMDIINFO(hwndLocal);







    if (bNewPage)
        {
        tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCOUNT, 0, 0L );

        if (tmp >= MAX_ALLOWED_PAGES)
            {
            MessageBoxID (hInst, hwnd, IDS_MAXPAGESERROR, IDS_PASTEDLGTITLE, MB_OK|MB_ICONEXCLAMATION);
            goto done;
            }


        // Do the dialog and get KeepAs request

        KeepAs.ShareName[0]   = TEXT('\0');
        KeepAs.bAlreadyExist  = FALSE;
        KeepAs.bAlreadyShared = FALSE;

        dwCurrentHelpId = 0;            //  F1 will be context sensitive


        ret = (DWORD)DialogBoxParam (hInst,
                                     MAKEINTRESOURCE(IDD_KEEPASDLG),
                                     hwnd,
                                     KeepAsDlgProc ,
                                     (LPARAM)&KeepAs);

        PINFO (TEXT("DialogBox returning %d\n\r"), ret );
        dwCurrentHelpId = 0L;


        // refresh main window
        UpdateWindow (hwndApp);

        if (!ret || !KeepAs.ShareName[0])
            goto done;

        bShareSave = fSharePreference;
        }



    if (!bNewPage || KeepAs.bAlreadyExist)
        {
        PLISTENTRY lpLE;

        if (!bNewPage)
            tmp = (int)SendMessage (pMDI->hWndListbox, LB_GETCURSEL, 0, 0);
        else
            tmp = (int)SendMessage (pMDI->hWndListbox,
                                    LB_FINDSTRING,
                                    (WPARAM)-1,
                                    (LPARAM)(LPCSTR)KeepAs.ShareName);


        if (LB_ERR == tmp)
            goto done;

        SendMessage (pMDI->hWndListbox,
                     LB_GETTEXT,
                     tmp,
                     (LPARAM)&lpLE);

        strcpy (KeepAs.ShareName, lpLE->name);

        KeepAs.bAlreadyShared = IsShared (lpLE);
        KeepAs.bAlreadyExist  = TRUE;

        fSharePreference = bNewPage? fSharePreference: KeepAs.bAlreadyShared;
        }









    // Set up NetDDE share for the page
    lpDdeInfo = GlobalAllocPtr (GHND, 2048 * sizeof(TCHAR));
    if (!lpDdeInfo)
       {
       MessageBoxID (hInst, hwnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK|MB_ICONSTOP);
       goto done;
       }



    hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));




    // Set up computer name with \\ in front

    rgtchCName[1] = rgtchCName[0] = TEXT('\\');
    dwLen = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (rgtchCName + 2, &dwLen);



    lpEnd = (LPTSTR)lpDdeInfo + sizeof(NDDESHAREINFO);



    // Set up the constant members of the struct

    if (KeepAs.bAlreadyExist && KeepAs.bAlreadyShared)
        {
        DWORD   dwAddItem = 0;
        DWORD   dwTotal;

        ret = NDdeShareGetInfo (rgtchCName,
                                KeepAs.ShareName,
                                2,
                                (PUCHAR)lpDdeInfo,
                                2048 * sizeof (TCHAR),
                                &dwTotal,
                                (PUSHORT)&dwAddItem);
        }
    else
        {
        lpDdeInfo->lRevision        = 1L;
        lpDdeInfo->fSharedFlag      = 0;
        lpDdeInfo->fService         = 1; //0;
        lpDdeInfo->fStartAppFlag    = 0;
        lpDdeInfo->qModifyId[0]     = 0;
        lpDdeInfo->qModifyId[1]     = 0;
        lpDdeInfo->nCmdShow         = SW_SHOWMINNOACTIVE;
        lpDdeInfo->lShareType       = SHARE_TYPE_STATIC;
        }



    // Enter the share name... must be == $<PAGENAME>.
    // (WFW used the dollar sign, we use the dollar sign. I
    //  hate backwards compatibility.)
    lpDdeInfo->lpszShareName = lpEnd;

    #ifdef USETWOSHARESPERPAGE
        if (fSharePreference || KeepAs.bAlreadyShared)
            {
            *lpEnd = SHR_CHAR;
            }
        else
            {
            *lpEnd = UNSHR_CHAR;
            }
    #else
        *lpEnd = SHR_CHAR;
    #endif


    lstrcpy(lpDdeInfo->lpszShareName + 1, KeepAs.ShareName + 1);
    lpEnd += lstrlen(lpDdeInfo->lpszShareName) + 1;


    // Start work on the app|topic list
    lpDdeInfo->lpszAppTopicList = lpEnd;

    // By default, there are no items.
    atchItem[0] = TEXT('\0');

    // Set up old-style and OLE name if cf_objectlink is
    // available, else set '\0'.
    if (OpenClipboard(hwnd))
        {
        unsigned cb;
        LPTSTR lpData;

        if ((hData = VGetClipboardData(NULL, cf_link)) &&
            (lpData = GlobalLock(hData)))
            {
            PINFO(TEXT("Link found\r\n"));
            lstrcpy(lpEnd, lpData);
            lpEnd += cb = lstrlen(lpEnd);
            *lpEnd++ = TEXT('|');
            lstrcpy(lpEnd, lpData + cb + 1);
            cb += lstrlen(lpEnd) + 2;
            lpEnd += lstrlen(lpEnd) + 1;
            lstrcpy(atchItem, lpData + cb);
            GlobalUnlock(lpData);
            lpDdeInfo->lShareType |= SHARE_TYPE_OLD;
            }
        else
            {
            *lpEnd++ = TEXT('\0');
            }

        if ((hData = VGetClipboardData(NULL, cf_objectlink)) &&
            (lpData = GlobalLock(hData)))
            {
            PINFO(TEXT("ObjectLink found\r\n"));
            lstrcpy(lpEnd, lpData);
            lpEnd += cb = lstrlen(lpEnd);
            *lpEnd++ = TEXT('|');
            lstrcpy(lpEnd, lpData + cb + 1);
            cb += lstrlen(lpEnd) + 2;
            lpEnd += lstrlen(lpEnd) + 1;
            lstrcpy(atchItem, lpData + cb);
            GlobalUnlock(lpData);
            lpDdeInfo->lShareType |= SHARE_TYPE_NEW;
            }
        else
            {
            *lpEnd++ = TEXT('\0');
            }

        CloseClipboard();
        }
    else // We couldn't open, we can't get objectlink.
       {
       *lpEnd++ = TEXT('\0');
       *lpEnd++ = TEXT('\0');
       }




    // Set up "CLIPSRV|*<pagename>" for a static app/topic
    // We use the *<pagename> form because when the page
    // is first created, it's ALWAYS unshared, and the server's
    // expecting us to be on the "unshared" topic name.
    // Unless the page already exists and is already shared.

    lstrcpy (lpEnd, SZ_SRV_NAME);
    lstrcat (lpEnd, TEXT(BAR_CHAR));
    lpEnd += lstrlen(lpEnd);

    if (KeepAs.bAlreadyShared)
        *lpEnd = SHR_CHAR;
    else
        *lpEnd = UNSHR_CHAR;



    lstrcpy(lpEnd + 1, KeepAs.ShareName + 1);
    lpEnd += lstrlen(lpEnd) + 1;
    // NetDDE requires a fourth NULL at the end of the app/topic
    // list - dumb, but easier to do this than fix that.
    *lpEnd++ = TEXT('\0');

    lpDdeInfo->lpszItemList = lpEnd;
    // If there's an item listed, we need to set the item.
    // Otherwise, set no items-- this is an OLE link to the entire
    // document. ANY item, but there's nothing but the static
    // share anyway.
    if (lstrlen(atchItem))
        {
        lstrcpy(lpEnd, atchItem);
        lpEnd += lstrlen(lpEnd) + 1;
        lpDdeInfo->cNumItems = 1;
        #ifdef NOOLEITEMSPERMIT
            for (i = 0; i < NOLEITEMS; i++)
                {
                lstrcpy(lpEnd, OleShareItems[i]);
                lpEnd += lstrlen(lpEnd) + 1;
                }
            lpDdeInfo->cNumItems = NOLEITEMS + 1;
        #endif
        }
    else
        {
        lpDdeInfo->cNumItems = 0;
        *lpEnd++ = TEXT('\0');
        }


    // Finish off item list with an extra null.
    *lpEnd++ = TEXT('\0');

    // Get an SD -- if this fails, we'll get a NULL pSD back,
    // and we'll end up creating the share with a default SD.
    // This is a tolerable condition.
    // pSD = CurrentUserOnlySD();




    // Create the share

    if (!KeepAs.bAlreadyExist)
        {
        DumpDdeInfo(lpDdeInfo, rgtchCName);
        ret = NDdeShareAdd (rgtchCName, 2, NULL, (LPBYTE)lpDdeInfo, sizeof(NDDESHAREINFO) );

        // We have to set security in a separate step, because
        // we set up a "default" DACL, and if we pass it in to
        // NDdeShareAdd(), it'll get overwritten by the "inherited"
        // DACL
        // The security people are scum. Use default
        // ([CreatorAll WorldRL]) share security.
        // if (pSD && NDDE_NO_ERROR == ret)
        //    {
        //    PrintSD(pSD);
        //
        //    ret = NDdeSetShareSecurity(rgtchCName,
        //                lpDdeInfo->lpszShareName,
        //                DACL_SECURITY_INFORMATION, pSD);
        //    }
        //
        PINFO(TEXT("NDdeShareAdd ret %ld\r\n"), ret);
        // if (pSD)
        //    {
        //    GlobalFree(pSD);
        //    }



        if (ret != NDDE_NO_ERROR && ret != NDDE_SHARE_ALREADY_EXIST)
            {
            if (NDDE_ACCESS_DENIED == ret)
                {
                MessageBoxID (hInst, hwnd, IDS_PRIVILEGEERROR, IDS_APPNAME, MB_OK|MB_ICONSTOP);
                }
            else
                {
                PERROR(TEXT("NDDE Error %d\r\n"), ret);
                NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);
                }
            goto done;
            }



        // Need to trust the share so that we can init through it!
        ret = NDdeSetTrustedShare (rgtchCName,
                                   lpDdeInfo->lpszShareName,
                                   NDDE_TRUST_SHARE_INIT);

        if (ret != NDDE_NO_ERROR)
            NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);

        }
    else
        {
        ret = NDdeShareSetInfo (rgtchCName,
                                lpDdeInfo->lpszShareName,
                                2,
                                (LPBYTE)lpDdeInfo,
                                sizeof(NDDESHAREINFO),
                                0);

        if (NDDE_NO_ERROR != ret)
            {
            NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);
            goto done;
            }
        }







    // Send DEExecute to tell clipsrv that we've created this page,
    // and will it please make an actual file for it?
    // NOTE must force all formats rendered to prevent deadlock
    // on the clipboard.
    ForceRenderAll (hwnd, NULL);

    lstrcat (lstrcpy (szBuf, SZCMD_PASTE), KeepAs.ShareName);


    AssertConnection (hwndLocal);



    if (!MySyncXact ((LPBYTE)szBuf,
                     lstrlen(szBuf) +1,
                     pMDI->hExeConv,
                     0L,
                     CF_TEXT,
                     XTYP_EXECUTE,
                     LONG_SYNC_TIMEOUT,
                     NULL))
        {
        XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK|MB_ICONSTOP);


        if (!KeepAs.bAlreadyExist)
            {
            // Problem creating the page so ask the server to delete it
            wsprintf (szBuf, TEXT("%s%s"), SZCMD_DELETE, KeepAs.ShareName);
            MySyncXact (szBuf,
                        lstrlen (szBuf) +1,
                        pMDI->hExeConv,
                        0L,
                        CF_TEXT,
                        XTYP_EXECUTE,
                        SHORT_SYNC_TIMEOUT,
                        NULL);


            // and we'll delete the rest.
            NDdeSetTrustedShare (rgtchCName,
                                 lpDdeInfo->lpszShareName,
                                 NDDE_TRUST_SHARE_DEL);

            NDdeShareDel (rgtchCName,
                          lpDdeInfo->lpszShareName,
                          0);
            goto done;
            }
        }






    // Turn off redraw and add the new page to list.  Adding the new item
    // to list is necessary because the Properties() call below.  Turning
    // off the redraw is necessary because we sometimes get into a re-entrancy
    // problem.  When the list box is update, it is redrawn and if we're in
    // the preview mode, we get into the async xaction in the middle of some
    // sync xact.

    SendMessage (pMDI->hWndListbox, WM_SETREDRAW, FALSE, 0);

    if (!KeepAs.bAlreadyExist)
        {
        PLISTENTRY lpLE;

        // below code is copied from InitListBox()
        if (lpLE = (PLISTENTRY)GlobalAllocPtr (GHND, sizeof(LISTENTRY)))
            {
            lpLE->fDelete = TRUE;
            lpLE->fTriedGettingPreview = FALSE;
            lstrcpy (lpLE->name, KeepAs.ShareName);
            SendMessage (pMDI->hWndListbox, LB_ADDSTRING, 0, (LPARAM)lpLE);
            }
        }




    if (fSharePreference != KeepAs.bAlreadyShared)
        {
        // get the item number
        tmp = (int)SendMessage (pMDI->hWndListbox,
                                LB_FINDSTRING,
                                (WPARAM)-1,
                                (LPARAM)(LPCSTR)KeepAs.ShareName);


        if (LB_ERR != tmp)
            {
            if (fSharePreference)
                {
                PLISTENTRY lpLE;

                SendMessage (pMDI->hWndListbox,
                             LB_GETTEXT,
                             tmp,
                             (LPARAM)&lpLE);
                Properties (hwnd, lpLE);
                }
            else
                OnIdmUnshare (tmp);
            }
        }




    // Now, turn on redraw.

    SendMessage (pMDI->hWndListbox, WM_SETREDRAW, TRUE, 0);



    // update the list box in all cases, the function
    // is smart enough to figure out which item has
    // changed and update only it.

    UpdateListBox (hwndLocal, pMDI->hExeConv);
    InvalidateRect (pMDI->hWndListbox, NULL, FALSE);




done:
    if (lpDdeInfo)
        GlobalFreePtr (lpDdeInfo);


    InitializeMenu (GetMenu (hwndApp));
    if (hCursor)
    {
        hCursor = SetCursor (hCursor);
    }


    fSharePreference = bShareSave;


    return 0L;

}








/*
 *      OnIDMCopy
 *
 *  Handles IDM_COPY to copy a page to clipbrd.
 */


LRESULT OnIDMCopy (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPLISTENTRY lpLE;
PMDIINFO    pMDIc;
PDATAREQ    pDataReq;
TCHAR       tchTmp;
INT         tmp;
BOOL        fLocked;




    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return 0L;



    fLocked = LockApp (TRUE, NULL);





    // make a copy to ensure that the global is not
    // changed from under us in case proc is reentered

    if (!(pMDIc = GETMDIINFO(hwndActiveChild)))
        goto done;

    tmp = (int)SendMessage ( pMDIc->hWndListbox, LB_GETCURSEL, 0, 0L );

    if (tmp == LB_ERR)
        goto done;




    if (SendMessage (pMDIc->hWndListbox, LB_GETTEXT, tmp, (LPARAM)(LPCSTR)&lpLE)
        == LB_ERR )
        {
        PERROR(TEXT("IDM_COPY: bad listbox index: %d\n\r"), tmp );
        goto done;
        }

    if (!(pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("error from CreateNewDataReq\n\r"));
        goto done;
        }



    if (pMDIc->hszClpTopic)
        {
        DdeFreeStringHandle (idInst, pMDIc->hszClpTopic);
        }



    tchTmp = lpLE->name[0];
    lpLE->name[0] = SHR_CHAR;
    pMDIc->hszClpTopic = DdeCreateStringHandle(idInst, lpLE->name, 0);


    // If we're local, trust the share so we can copy through it
    if (hwndActiveChild == hwndLocal)
       {
       DWORD adwTrust[3];

       NDdeGetTrustedShare(NULL, lpLE->name, adwTrust, adwTrust + 1,
            adwTrust + 2);
       adwTrust[0] |= NDDE_TRUST_SHARE_INIT;

       NDdeSetTrustedShare(NULL, lpLE->name, adwTrust[0]);
       }

    lpLE->name[0] = tchTmp;


    if ( !pMDIc->hszClpTopic )
       {
       MessageBoxID (hInst,
                     hwndActiveChild,
                     IDS_DATAUNAVAIL,
                     IDS_APPNAME,
                     MB_OK | MB_ICONEXCLAMATION );
       goto done;
       }



    if (pMDIc->hClpConv)
       {
       DdeDisconnect (pMDIc->hClpConv);
       pMDIc->hClpConv = NULL;
       }

    pMDIc->hClpConv = DdeConnect (idInst,
                                  pMDIc->hszConvPartner,
                                  pMDIc->hszClpTopic,
                                  NULL);



    if (!pMDIc->hClpConv)
       {
       PERROR(TEXT("DdeConnect to (%s) failed %d\n\r"),
              (LPSTR)(lpLE->name), DdeGetLastError(idInst) );
       MessageBoxID (hInst,
                     hwndActiveChild,
                     IDS_DATAUNAVAIL,
                     IDS_APPNAME,
                     MB_OK | MB_ICONEXCLAMATION);
       goto done;
       }


    pDataReq->rqType      = RQ_COPY;
    pDataReq->hwndList    = pMDIc->hWndListbox;
    pDataReq->iListbox    = tmp;
    pDataReq->hwndMDI     = hwndActiveChild;
    pDataReq->fDisconnect = FALSE;
    pDataReq->wFmt        = CF_TEXT;

    DdeSetUserHandle (pMDIc->hClpConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq);
    DdeKeepStringHandle (idInst, hszFormatList);



    if (!DdeClientTransaction (NULL,
                               0L,
                               pMDIc->hClpConv,
                               hszFormatList,
                               CF_TEXT,
                               XTYP_REQUEST,
                               (DWORD)TIMEOUT_ASYNC,
                               NULL))
        DdeMessageBox (hInst,
                       hwndApp,
                       DdeGetLastError(idInst),
                       IDS_APPNAME,
                       MB_OK|MB_ICONEXCLAMATION);



    // now a copy request packed will arrive at the call-back... or
    // not. report an error if no callback?



done:

    if (fLocked)
        LockApp (FALSE, NULL);


    SetEvent (hXacting);

    return 0L;

}










/*
 *      CreateClipboardWindow
 *
 *  Purpose: Create and activate a window showing the contents of the
 *  clipboard.
 */

static void CreateClipboardWindow (void)
{
WINDOWPLACEMENT wpl;
HMENU           hSysMenu;
PMDIINFO        pMDI;


    // create Clipboard Window
    hwndClpbrd = NewWindow();
    if (NULL == hwndClpbrd)
        {
        return;
        }


    pMDI              = GETMDIINFO(hwndClpbrd);
    pMDI->flags       = F_CLPBRD;
    pMDI->DisplayMode = DSP_PAGE;

    AdjustControlSizes ( hwndClpbrd );
    ShowHideControls ( hwndClpbrd );

    lstrcpy (pMDI->szBaseName, szSysClpBrd);
    lstrcpy (pMDI->szComputerName, TEXT(""));

    SetWindowText ( hwndClpbrd, szSysClpBrd );

    // Grey out close item on sys menu
    hSysMenu = GetSystemMenu ( hwndClpbrd, FALSE );
    EnableMenuItem (hSysMenu, SC_CLOSE, MF_GRAYED | MF_BYCOMMAND);

    // Tell MDI where the Window menu is -- must do this BEFORE placing
    // the clipboard window. (If the clipboard window's maximized, its
    // System menu is the first menu-- not the app's File menu.)
    hSysMenu = GetSubMenu(GetMenu(hwndApp), WINDOW_MENU_INDEX);
    SendMessage(hwndMDIClient, WM_MDISETMENU, 0, (LPARAM)hSysMenu);

    if ( ReadWindowPlacement ( szSysClpBrd, &wpl ))
        {
        wpl.length = sizeof(WINDOWPLACEMENT);
        wpl.flags = WPF_SETMINPOSITION;
        SetWindowPlacement ( hwndClpbrd, &wpl );
        PINFO(TEXT("sizing %s from .ini\n\r"), (LPSTR)szSysClpBrd);
        UpdateWindow ( hwndClpbrd );
        }
    else
        {
        PINFO(TEXT("showing %s in default size/posiiton\n\r"),
            (LPSTR)szSysClpBrd );
        ShowWindow ( hwndClpbrd, SW_MINIMIZE );
        }

    SendMessage ( hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndClpbrd, 0L );

}









/*
 *      CreateLocalWindow
 *
 *  Purpose: Create the "Local Clipbook" window.
 *
 *  Parameters: None.
 *
 *  Returns: Void.
 *
 */

static void CreateLocalWindow (void)
{
WINDOWPLACEMENT wpl;
HMENU           hSysMenu;
PMDIINFO        pMDI;



    hwndLocal = NewWindow();
    if (NULL == hwndLocal)
        {
        return;
        }


    pMDI = GETMDIINFO(hwndLocal);
    ShowHideControls (hwndLocal);

    pMDI->hszConvPartner   =
    pMDI->hszConvPartnerNP = hszDataSrv;
    pMDI->hExeConv         = InitSysConv (hwndLocal,
                                          pMDI->hszConvPartner,
                                          hszSystem,
                                          TRUE);

    if (!pMDI->hExeConv )
        goto error;



    pMDI->flags = F_LOCAL;

    if (!UpdateListBox ( hwndLocal, pMDI->hExeConv ))
        goto error;



    SetWindowText ( hwndLocal, szLocalClpBk );


    lstrcpy (pMDI->szBaseName, szLocalClpBk);
    lstrcpy (pMDI->szComputerName, TEXT(""));



    hSysMenu = GetSystemMenu ( hwndLocal, FALSE );
    EnableMenuItem ( hSysMenu, SC_CLOSE, MF_GRAYED );


    if ( ReadWindowPlacement ( szLocalClpBk, &wpl ))
        {
        wpl.length = sizeof(WINDOWPLACEMENT);
        wpl.flags = WPF_SETMINPOSITION;
        SetWindowPlacement ( hwndLocal, &wpl );
        PINFO(TEXT("sizing Local Clipbook from .ini\n\r"));
        UpdateWindow ( hwndLocal );
        }
    else
        {
        if ( !IsIconic(hwndApp))
            {
            RECT MDIrect;

            PINFO(TEXT("calculating size for Local Clipbook window\n\r"));
            GetClientRect ( hwndMDIClient, &MDIrect );
            MoveWindow ( hwndLocal,
                MDIrect.left, MDIrect.top, MDIrect.right - MDIrect.left,
                ( MDIrect.bottom - MDIrect.top )
                - GetSystemMetrics(SM_CYICONSPACING), FALSE );
            }
        else
            {
            fNeedToTileWindows = TRUE;
            }
        ShowWindow ( hwndLocal, SW_SHOWNORMAL );
        }

    SendMessage (hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndLocal, 0L);
    SendMessage (hwndMDIClient, WM_MDIREFRESHMENU, 0, 0L);

    if (NULL != hkeyRoot)
        {
        DWORD dwDefView = IDM_LISTVIEW;
        DWORD dwSize = sizeof(dwDefView);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyRoot,
              (LPTSTR)szDefView, NULL, NULL, (LPBYTE)&dwDefView, &dwSize));
            {
            PINFO(TEXT("Couldn't get DefView value\r\n"));
            }

        SendMessage ( hwndApp, WM_COMMAND, dwDefView, 0L );
        }


    return;


error:
    #if DEBUG
        MessageBox (hwndApp,
                    TEXT("No Local Server"),
                    TEXT("ClipBook Initialization"),
                    MB_OK | MB_ICONEXCLAMATION );
    #endif

    fShareEnabled = FALSE;

    //SendMessage ( hwndLocal, WM_CLOSE, 0, 0L );
    SendMessage (hwndLocal, WM_MDIDESTROY, 0, 0L);

    hwndLocal = NULL;

    return;

}











/*
 *      UnsharePage
 *
 *
 *  Purpose: Unshare the selected page in the active window.
 *
 *  Parameters: None.
 *
 *  Returns: Void. All error handling is provided within the function.
 *
 */

void UnsharePage (void)
{
DWORD           adwTrust[3];
int             tmp;
LPLISTENTRY     lpLE;
DWORD           ret;
WORD            wAddlItems;
PNDDESHAREINFO  lpDdeI;
DWORD           dwRet = 2048 * sizeof(TCHAR);



    assert(pActiveMDI);

    if (!pActiveMDI);
        return;



    tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);


    if ( tmp == LB_ERR )
        return;


    if (!(lpDdeI = LocalAlloc(LPTR, 2048 * sizeof(TCHAR))))
       {
       MessageBoxID (hInst, hwndApp, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
       return;
       }


   SendMessage (  pActiveMDI->hWndListbox, LB_GETTEXT, tmp,
       (LPARAM)(LPCSTR)&lpLE);

   AssertConnection(hwndActiveChild);

   PINFO(TEXT("for share [%s]"), lpLE->name);
   wAddlItems = 0;
   ret = NDdeShareGetInfo ( NULL, lpLE->name, 2,
       (LPBYTE)lpDdeI, 2048 * sizeof(TCHAR), &dwRet, &wAddlItems );


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        }
    else if (NDDE_NO_ERROR != ret)
        {
        PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
        NDdeMessageBox (hInst, hwndApp, ret,
                        IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
        }
    else
        {
        register LPTSTR lpOog;

        lpOog = lpDdeI->lpszAppTopicList;

        // Jump over the first two NULL chars you find-- these
        // are the old- and new-style app/topic pairs, we don't
        // mess with them. Then jump over the next BAR_CHAR you find.
        // The first character after that is the first char of the
        // static topic-- change that to a UNSHR_CHAR.

        while (*lpOog++) ;
        while (*lpOog++) ;


        // FEATURE: TEXT('|') should == BAR_CHAR. If not, this needs to
        // be adjusted.

        while (*lpOog++ != TEXT('|')) ;



        *lpOog = UNSHR_CHAR;
        lpDdeI->fSharedFlag = 0L;

        DumpDdeInfo(lpDdeI, NULL);

        // We want to get trusted info BEFORE we start changing
        // the share.
        NDdeGetTrustedShare(NULL, lpLE->name, adwTrust,
           adwTrust + 1, adwTrust + 2);

        ret = NDdeShareSetInfo ( NULL, lpLE->name, 2,
            (LPBYTE)lpDdeI, 2048 * sizeof(TCHAR), 0 );
        if (NDDE_NO_ERROR == ret)
            {
            #if 0
            PSECURITY_DESCRIPTOR pSD;
            DWORD dwSize;
            TCHAR atch[2048];
            BOOL  fDacl, fDefault;
            PACL  pacl;

            pSD = atch;
            if (NDDE_NO_ERROR == NDdeGetShareSecurity (NULL,
                                                       lpLE->name,
                                                       DACL_SECURITY_INFORMATION,
                                                       pSD,
                                                       2048 * sizeof(TCHAR),
                                                       &dwSize))
                {
                if (GetSecurityDescriptorDacl(pSD, &fDacl,
                      &pacl, &fDefault))
                    {
                    if (fDefault || !fDacl)
                        {
                        if (pSD = CurrentUserOnlySD())
                            {
                            NDdeSetShareSecurity (NULL,
                                                  lpLE->name,
                                                  DACL_SECURITY_INFORMATION,
                                                  pSD);
                            LocalFree(pSD);
                            }
                        }
                    }
                }
            #endif

            // We've finished mucking with the share, now set
            // trust info
            PINFO(TEXT("Setting trust info to 0x%lx\r\n"),
               adwTrust[0]);
            NDdeSetTrustedShare(NULL, lpLE->name,
               adwTrust[0]);

            ///////////////////////////////////////////////
            // do the execute to change the server state
            lstrcat(lstrcpy(szBuf,SZCMD_UNSHARE),lpLE->name);
            PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

            if (MySyncXact ((LPBYTE)szBuf,
                            lstrlen(szBuf) +1,
                            GETMDIINFO(hwndLocal)->hExeConv,
                            0L,
                            CF_TEXT,
                            XTYP_EXECUTE,
                            SHORT_SYNC_TIMEOUT,
                            NULL))
                {
                SetShared(lpLE, FALSE);
                InitializeMenu(GetMenu(hwndApp));
                }
            else
                {
                XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                }
            }
        }


}









/*
 *      OnIdmUnshare
 *
 *
 *  Purpose: Set the currently selected page in the active MDI window
 *      to 'unshared'.
 *
 *  dwItem is the item number to unshare.  If == LB_ERR then the current
 *      selected item will be unshared.
 *
 *  Parameters: None.
 *
 *  Returns: 0L always, function handles its own errors.
 *
 */

LRESULT OnIdmUnshare (DWORD dwItem)
{
PNDDESHAREINFO lpDdeI;
PLISTENTRY     lpLE;
DWORD          adwTrust[3];
WORD           wAddlItems;
DWORD          ret;
DWORD          dwRet = 2048 * sizeof(TCHAR);
LPTSTR         lpOog;

#if 0
    PSECURITY_DESCRIPTOR    pSD;
    DWORD                   dwSize;
    BOOL                    fDacl, fDefault;
    PACL                    pacl;
#endif




    if (!pActiveMDI)
        return 0L;


    if (LB_ERR == dwItem)
        dwItem = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L );

    if (LB_ERR == dwItem)
        {
        PERROR(TEXT("IDM_UNSHARE w/no page selected\r\n"));
        return 0L;
        }




    if (!(lpDdeI = LocalAlloc(LPTR, 2048 * sizeof(TCHAR))))
        {
        MessageBoxID (hInst, hwndApp, IDS_INTERNALERR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }



    SendMessage (pActiveMDI->hWndListbox,
                 LB_GETTEXT,
                 dwItem,
                 (LPARAM)(LPCSTR)&lpLE);


    AssertConnection(hwndActiveChild);





    PINFO(TEXT("for share [%s]"), lpLE->name);
    wAddlItems = 0;
    ret = NDdeShareGetInfo (NULL, lpLE->name,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            &dwRet,
                            &wAddlItems );


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }
    else if (ret != NDDE_NO_ERROR)
        {
        PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
        NDdeMessageBox (hInst, hwndApp, ret,
                        IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
        return 0L;
        }



    lpOog = lpDdeI->lpszAppTopicList;


    // Jump over the first two NULL chars you find-- these
    // are the old- and new-style app/topic pairs, we don't
    // mess with them. Then jump over the next BAR_CHAR you find.
    // The first character after that is the first char of the
    // static topic-- change that to a SHR_CHAR.

    while (*lpOog++) ;
    while (*lpOog++) ;


    // FEATURE: TEXT('|') should == BAR_CHAR. If not, this needs to
    // be adjusted.

    while (*lpOog++ != TEXT('|')) ;


    *lpOog = UNSHR_CHAR;
    lpDdeI->fSharedFlag = 1L;



    // Have to get trusted share settings before we modify
    // the share, 'cuz they'll be invalid.

    NDdeGetTrustedShare (NULL,
                         lpDdeI->lpszShareName,
                         adwTrust,
                         adwTrust + 1,
                         adwTrust + 2);


    DumpDdeInfo (lpDdeI, NULL);
    ret = NDdeShareSetInfo (NULL,
                            lpDdeI->lpszShareName,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            0);


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }
    else if (NDDE_NO_ERROR != ret)
        {
        NDdeMessageBox (hInst, hwndApp, ret, IDS_APPNAME,
                        MB_OK | MB_ICONHAND);
        PERROR(TEXT("Couldn't set share info\r\n"));
        return 0L;
        }




    #if 0
        pSD = LocalAlloc (LPTR, 30);
        ret = NDdeGetShareSecurity (NULL,
                                    lpDdeI->lpszShareName,
                                    DACL_SECURITY_INFORMATION,
                                    pSD,
                                    30,
                                    &dwSize);

        if (NDDE_BUF_TOO_SMALL == ret && dwSize < 65535L)
            {
            LocalFree(pSD);
            pSD = LocalAlloc(LPTR, dwSize);

            ret =  NDdeGetShareSecurity (NULL,
                                         lpDdeI->lpszShareName,
                                         DACL_SECURITY_INFORMATION,
                                         pSD,
                                         30,
                                         &dwSize);
            }


        if (NDDE_NO_ERROR == ret)
            {
            if (GetSecurityDescriptorDacl(pSD, &fDacl, &pacl, &fDefault))
                {
                LocalFree (pSD);

                if (fDefault || !fDacl)
                    {
                    if (pSD = CurrentUserOnlySD())
                        {
                        NDdeSetShareSecurity (NULL,
                                              lpDdeI->lpszShareName,
                                              DACL_SECURITY_INFORMATION,
                                              pSD);
                        }
                    else
                        {
                        PERROR(TEXT("Couldn't make CUOnlySD"));
                        }
                    }
                else
                    {
                    PINFO(TEXT("Non-default DACL"));
                    }
                }
            else
                {
                PINFO(TEXT("No DACL"));
                }
            }
        else
            {
            PERROR(TEXT("Couldn't get security for share"));
            }
        PERROR(TEXT("\r\n"));

        if (pSD)
            {
            LocalFree(pSD);
            }
    #endif



    // Setting trusted share info needs to be the last
    // operation we do on the share.
    if (NDDE_NO_ERROR != NDdeSetTrustedShare (NULL, lpDdeI->lpszShareName, adwTrust[0]))
        {
        PERROR(TEXT("Couldn't set trust status\r\n"));
        }

    ///////////////////////////////////////////////
    // do the execute to change the server state
    lstrcat(lstrcpy(szBuf,SZCMD_UNSHARE),lpLE->name);
    PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

    if (MySyncXact ((LPBYTE)szBuf,
                    lstrlen(szBuf) +1,
                    GETMDIINFO(hwndLocal)->hExeConv,
                    0L,
                    CF_TEXT,
                    XTYP_EXECUTE,
                    SHORT_SYNC_TIMEOUT,
                    NULL))
        {
        // 368989 : lpLE may be bogus (freed memory) after this call
        // SetShared(lpLE, FALSE);

        InitializeMenu(GetMenu(hwndApp));
        }
    else
        {
        XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP );
        }

    return(0L);

}









/*
 *      ClipBookCommand
 *
 * Purpose: Process menu commands for the Clipbook Viewer.
 *
 * Parameters: As wndproc.
 *
 * Returns: 0L, or DefWindowProc() if wParam isn't a WM_COMMAND id I
 *    know about.
 *
 */

LRESULT ClipBookCommand (
     HWND   hwnd,
     UINT   msg,
     WPARAM wParam,
     LPARAM lParam)
{
int             tmp;
UINT            wNewFormat;
UINT            wOldFormat;
LPLISTENTRY     lpLE;
BOOL            bRet;
DWORD           dwErr;


    switch (LOWORD(wParam))
        {
        case IDM_AUDITING:
            return(EditPermissions(TRUE));
            // return EditAuditing();
            break;

        case IDM_OWNER:
            return EditOwner();
            break;

        case IDM_PERMISSIONS:
            {
            PLISTENTRY pLE;
            RECT       Rect;
            INT        i;

            i = (INT)EditPermissions(FALSE);


            // Permissions may have changed.  Get old data, they need
            //  to be updated.

            SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT,     i, (LPARAM)&pLE);
            SendMessage (pActiveMDI->hWndListbox, LB_GETITEMRECT, i, (LPARAM)&Rect);


            // Delete the old bitmap.  If we are allowed to see it we'll
            //  get it when the list item is redrawn.

            DeleteObject (pLE->hbmp);
            pLE->fTriedGettingPreview = FALSE;
            pLE->hbmp = NULL;


            // Make it redraw.

            InvalidateRect (pActiveMDI->hWndListbox, &Rect, FALSE);
            }
            break;

        case IDC_TOOLBAR:
            MenuHelp( WM_COMMAND, wParam, lParam, GetMenu(hwnd), hInst,
                  hwndStatus, nIDs );
            break;

        case IDM_EXIT:
            SendMessage (hwnd, WM_CLOSE, 0, 0L);
            break;

        case IDM_TILEVERT:
        case IDM_TILEHORZ:
            SendMessage(hwndMDIClient, WM_MDITILE,
                wParam == IDM_TILEHORZ ? MDITILE_HORIZONTAL : MDITILE_VERTICAL,
                0L);
            break;

        case IDM_CASCADE:
            SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L);
            break;

        case IDM_ARRANGEICONS:
            SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            break;

        case IDM_COPY:
            szSaveFileName[0] = '\0';
            OnIDMCopy (hwnd, msg, wParam, lParam);
            break;

        case IDM_TOOLBAR:
            if ( fToolBar )
                {
                fToolBar = FALSE;
                ShowWindow ( hwndToolbar, SW_HIDE );
                AdjustMDIClientSize();
                }
            else
                {
                fToolBar = TRUE;
                AdjustMDIClientSize();
                ShowWindow ( hwndToolbar, SW_SHOW );
                }
            break;

        case IDM_STATUSBAR:

            if ( fStatus )
                {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                AdjustMDIClientSize();
                }
            else
                {
                fStatus = TRUE;
                AdjustMDIClientSize();
                ShowWindow ( hwndStatus, SW_SHOW );
                }
            break;

        case ID_PAGEUP:
        case ID_PAGEDOWN:
            {
            HWND hwndc;
            PMDIINFO pMDIc;
            UINT iLstbox, iLstboxOld;

            // copy to make sure this value doesn't change when we yield
            hwndc = hwndActiveChild;

            if (!(pMDIc = GETMDIINFO(hwndc)))
                break;

            SetFocus ( hwndc );

            // make sure this is not clipboard window...
            if ( pMDIc->flags & F_CLPBRD )
                break;

            // must be in page view
            if ( pMDIc->DisplayMode != DSP_PAGE )
                break;

            iLstbox = (int)SendMessage ( pMDIc->hWndListbox,
                LB_GETCURSEL, 0, 0L );
            if ( iLstbox == LB_ERR )
                break;

            // page up on first entry?
            if ( iLstbox == 0 && wParam == ID_PAGEUP )
                {
                MessageBeep(0);
                break;
                }

            // page down on last entry?
            if ( (int)iLstbox == (int)SendMessage(pMDIc->hWndListbox,
                LB_GETCOUNT,0,0L) - 1 && wParam == (WPARAM)ID_PAGEDOWN )
                {
                MessageBeep(0);
                break;
                }

            // move selection up/down as appropriate
            iLstboxOld;
            if ( wParam == ID_PAGEDOWN )
                iLstbox++;
            else
                iLstbox--;

            SetListboxEntryToPageWindow ( hwndc, pMDIc, iLstbox );
            }
            break;

        case IDM_LISTVIEW:
        case IDM_PREVIEWS:
            {
            HWND    hwndtmp;
            int     OldSel;
            int     OldDisplayMode;
            TCHAR   szBuf[80];

            SetFocus (hwndActiveChild);

            if (!pActiveMDI)
                break;


            // make sure this is not clipboard window...
            if (pActiveMDI->flags & F_CLPBRD)
                break;

            // NOP?
            if (pActiveMDI->DisplayMode == DSP_PREV && wParam == IDM_PREVIEWS ||
                pActiveMDI->DisplayMode == DSP_LIST && wParam == IDM_LISTVIEW)
                break;

            OldDisplayMode = pActiveMDI->DisplayMode;

            // nuke vclipboard if there is one
            if ( pActiveMDI->pVClpbrd )
                {
                DestroyVClipboard( pActiveMDI->pVClpbrd );
                pActiveMDI->pVClpbrd = NULL;
                }


            // Save selection... (extra code to avoid strange lb div-by-zero)
            OldSel = (int)SendMessage( pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);
            SendMessage (pActiveMDI->hWndListbox, LB_SETCURSEL, (WPARAM)-1, 0L);
            UpdateNofMStatus (hwndActiveChild);
            SendMessage (pActiveMDI->hWndListbox, WM_SETREDRAW, 0, 0L);


            // set new display mode so listbox will get created right
            pActiveMDI->DisplayMode = (wParam == IDM_PREVIEWS)? DSP_PREV :DSP_LIST;


            // save handle to old listbox
            hwndtmp =  pActiveMDI->hWndListbox;


            // hide the old listbox - will soon destroy
            ShowWindow ( hwndtmp, SW_HIDE );


            // make new listbox and save handle in extra window data
            pActiveMDI->hWndListbox = CreateNewListBox (hwndActiveChild,
                                                        (pActiveMDI->DisplayMode == DSP_PREV)?
                                                         LBS_PREVIEW:
                                                         LBS_LISTVIEW);

            // loop, extracting items from one box and into other
            while (SendMessage (hwndtmp, LB_GETTEXT, 0, (LPARAM)(LPCSTR)&lpLE ) != LB_ERR)
                {
                // mark this item not to be deleted in WM_DELETEITEM
                lpLE->fDelete = FALSE;

                // remove from listbox
                SendMessage (hwndtmp, LB_DELETESTRING, 0, 0L);

                // reset fDelete flag
                lpLE->fDelete = TRUE;

                // add to new listbox
                SendMessage (pActiveMDI->hWndListbox, LB_ADDSTRING, 0, (LPARAM)(LPCSTR)lpLE);
                }



            // kill old (empty) listbox
            DestroyWindow ( hwndtmp );


            if ( pActiveMDI->flags & F_LOCAL )
                {
                SetWindowText ( hwndLocal, szLocalClpBk );
                lstrcpy(szBuf, szDefView);
                }
            else
                {
                wsprintf(szBuf, szClipBookOnFmt,(LPSTR)(pActiveMDI->szBaseName));
                SetWindowText ( hwndActiveChild, szBuf );
                lstrcpy(szBuf, pActiveMDI->szBaseName);
                lstrcat(szBuf, szConn);
                }

            if (NULL != hkeyRoot)
                {
                DWORD dwValue;

                dwValue = pActiveMDI->DisplayMode == DSP_LIST ? IDM_LISTVIEW :
                          pActiveMDI->DisplayMode == DSP_PREV ? IDM_PREVIEWS :
                          IDM_PAGEVIEW;

                RegSetValueEx (hkeyRoot, (LPTSTR)szBuf, 0L, REG_DWORD,
                               (LPBYTE)&dwValue, sizeof(DWORD));
                }


            // adjust size and show
            AdjustControlSizes( hwndActiveChild );
            ShowHideControls ( hwndActiveChild );

            // restore selection
            SendMessage( pActiveMDI->hWndListbox, LB_SETCURSEL, OldSel, 0L );
            UpdateNofMStatus ( hwndActiveChild );

            InitializeMenu ( GetMenu(hwndApp) );
            SetFocus ( pActiveMDI->hWndListbox );
            break;
            }

        case IDM_UPDATE_PAGEVIEW:
        case IDM_PAGEVIEW:
            {
            HWND hwndc;
            PMDIINFO pMDIc;

            // copy to make sure this value doesn't change when we yield
            hwndc = hwndActiveChild;

            if (!(pMDIc = GETMDIINFO(hwndc)))
                break;

            SetFocus (hwndc);


            // make sure this is not clipboard window...

            if (pMDIc->flags & F_CLPBRD)
                break;


            // if switch to page view

            if (IDM_PAGEVIEW == LOWORD(wParam))
                {
                // already in page view?
                if (pMDIc->DisplayMode == DSP_PAGE)
                    break;
                }
            else
                {
                // make sure we're not in an sync xaction, if so
                //  post a message and try again later.
                if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
                    {
                    PostMessage (hwndApp, WM_COMMAND, IDM_UPDATE_PAGEVIEW, 0L);
                    break;
                    }

                // hXacting is now reset, set it so it can be used again
                SetEvent (hXacting);
                }


            tmp = (int)SendMessage (pMDIc->hWndListbox, LB_GETCURSEL, 0, 0L);
            if (tmp == LB_ERR)
                break;



            SetListboxEntryToPageWindow (hwndc, pMDIc, tmp);
            break;
            }

        case IDM_SHARE:
            if (!pActiveMDI)
                break;

            tmp = (int) SendMessage (pActiveMDI->hWndListbox,LB_GETCURSEL, 0, 0L);

            if ( tmp != LB_ERR )
                {
                SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT, tmp, (LPARAM)&lpLE);

                // We create the NetDDE share when we create the page, not when we
                // share it. Thus, we're always 'editing the properties' of an existing
                // share, even if the user thinks that he's sharing the page NOW.
                Properties(hwnd, lpLE);

                // Redraw the listbox.
                if (pActiveMDI->DisplayMode == DSP_PREV)
                    {
                    InvalidateRect(pActiveMDI->hWndListbox, NULL, FALSE);
                    }
                else
                    {
                    SendMessage(pActiveMDI->hWndListbox,LB_SETCURSEL, tmp, 0L);
                    UpdateNofMStatus(hwndActiveChild);
                    }
                }
            break;

        case IDM_CLPWND:
            CreateClipboardWindow();
            break;

        case IDM_LOCAL:
            if (fNetDDEActive)
                CreateLocalWindow();
            break;

        case IDM_UNSHARE:
            bRet = (BOOL)OnIdmUnshare(LB_ERR);
            UpdateListBox (hwndActiveChild, pActiveMDI->hExeConv);
            return bRet;
            break;

        case IDM_DELETE:
            bRet = (BOOL)OnIDMDelete(hwnd, msg, wParam, lParam);
            return bRet;
            break;


        case IDM_PASTE_PAGE:
        case IDM_KEEP:
            bRet = (BOOL)OnIDMKeep (hwnd,
                                    msg,
                                    wParam,
                                    lParam,
                                    IDM_KEEP == LOWORD(wParam) /* a new page? */);
            return bRet;
            break;

        case IDM_SAVEAS:
            {
            OPENFILENAME ofn;
            CHAR         szFile[MAX_FILENAME_LENGTH + 1];

            if (CountClipboardFormats())
                {
                szFile[0] = '\0';
                // Initialize the OPENFILENAME members
                ofn.lStructSize       = sizeof(OPENFILENAME);
                ofn.hwndOwner         = hwnd;
                ofn.lpstrFilter       = szFilter;
                ofn.lpstrCustomFilter = (LPTSTR) NULL;
                ofn.nMaxCustFilter    = 0L;
                ofn.nFilterIndex      = 1;
                ofn.lpstrFile         = (LPTSTR)szFile;
                ofn.nMaxFile          = sizeof(szFile);
                ofn.lpstrFileTitle    = NULL;
                ofn.nMaxFileTitle     = 0L;
                ofn.lpstrInitialDir   = szDirName;
                ofn.lpstrTitle        = (LPTSTR) NULL;
                ofn.lpstrDefExt       = "CLP";
                ofn.Flags             = OFN_HIDEREADONLY |
                                        OFN_NOREADONLYRETURN |
                                        OFN_OVERWRITEPROMPT;

                if (GetSaveFileName (&ofn) && szFile[0])
                    {
                    // NOTE must force all formats rendered!
                    ForceRenderAll (hwnd, NULL);

                    AssertConnection (hwndLocal);

                    // If user picked first filter ("NT Clipboard"), use save as..
                    // other filters would use save as old.
                    wsprintfA (szBuf, "%s%s",
                               (ofn.nFilterIndex == 1) ?
                                (LPSTR)SZCMD_SAVEAS :
                                (LPSTR)SZCMD_SAVEASOLD,
                               (LPSTR)szFile );



                    // these two lines replaces the follow if() else so we can save
                    // files directly without going to the server.

                    dwErr = SaveClipboardToFile (hwndApp, NULL, szFile, FALSE);
                    SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);


                    /****** replaced with above two lines, JohnFu
                    if (!(pMDIc = GETMDIINFO(hwndLocal)))
                        {
                        dwErr = SaveClipboardToFile (hwndApp, NULL, szFile, FALSE);
                        SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);
                        }
                    else
                        {
                        bRet = MySyncXact ((LPBYTE)szBuf,
                                            lstrlen(szBuf) +1,
                                            pMDIc->hExeConv,
                                            0L,
                                            CF_TEXT,
                                            XTYP_EXECUTE,
                                            LONG_SYNC_TIMEOUT,
                                            NULL);

                        if (!bRet)
                            XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK|MB_ICONHAND);
                        }
                    ******/
                    }
                }
            break;
            }
        case IDM_OPEN:
            {
            OPENFILENAME ofn;
            TCHAR        szFile[MAX_PATH+1] = TEXT("*.clp");

            // Initialize the OPENFILENAME members
            ofn.lStructSize       = sizeof(OPENFILENAME);
            ofn.hwndOwner         = hwnd;
            ofn.lpstrFilter       = szFilter;
            ofn.lpstrCustomFilter = (LPTSTR) NULL;
            ofn.nMaxCustFilter    = 0L;
            ofn.nFilterIndex      = 1;
            ofn.lpstrFile         = (LPTSTR)szFile;
            ofn.nMaxFile          = sizeof(szFile);
            ofn.lpstrFileTitle    = NULL;
            ofn.nMaxFileTitle     = 0L;
            ofn.lpstrInitialDir   = szDirName;
            ofn.lpstrTitle        = (LPTSTR) NULL;
            ofn.Flags             = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
            ofn.lpstrDefExt       = TEXT("CLP");

            if (GetOpenFileName (&ofn) && szFile[0])
                 {
                 // prompt for clearing clipboard
                 if (ClearClipboard(hwnd))
                    {
                    AssertConnection ( hwndLocal );

                    wsprintf(szBuf,TEXT("%s%s"), (LPTSTR)SZCMD_OPEN, (LPTSTR)szFile);

                    // these two lines replaces the follow if() else so we can open
                    // files directly without going to the server.

                    dwErr = OpenClipboardFile (hwndApp, szFile);
                    SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);


                    /****** replaced with above two lines, JohnFu
                    if (!(pMDIc = GETMDIINFO(hwndLocal)))
                        {
                        dwErr = OpenClipboardFile (hwndApp, szFile);
                        SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);
                        }
                    else
                        {
                        bRet = MySyncXact ((LPBYTE)szBuf,
                                           lstrlen(szBuf) +1,
                                           pMDIc->hExeConv,
                                           0L,
                                           CF_TEXT,
                                           XTYP_EXECUTE,
                                           SHORT_SYNC_TIMEOUT,
                                           NULL);

                        if (!bRet)
                            XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK | MB_ICONHAND);
                        }
                    ******/

                    InitializeMenu (GetMenu(hwnd));
                    }
                 }
            break;
            }

        case IDM_DISCONNECT:

            if (!pActiveMDI)
                break;

            // don't allow close of local or clipboard window
            if (pActiveMDI->flags & (F_LOCAL | F_CLPBRD))
                break;
            SendMessage ( hwndActiveChild, WM_CLOSE, 0, 0L );
            break;

        case IDM_CONNECT:
            {
            WCHAR rgwch[MAX_COMPUTERNAME_LENGTH + 3];
            BOOL  bOK = FALSE;
            BOOL  fFoundLMDlg = FALSE;
            HMODULE hMod;
            LPFNSYSFOCUS lpfn;
            #ifndef UNICODE
              WCHAR rgwchHelp[64];
            #endif

            *szConvPartner = '\0';
            rgwch[0] = L'\0';

            if (hMod = LoadLibraryW(L"NTLANMAN.DLL"))
               {
               if (lpfn = (LPFNSYSFOCUS)GetProcAddress(hMod, "I_SystemFocusDialog"))
                  {
                  #ifndef UNICODE
                    MultiByteToWideChar(CP_ACP, 0, szHelpFile, -1, rgwchHelp, 64);
                  #endif

                  fFoundLMDlg = TRUE;
                  (*lpfn)(hwnd,
                          FOCUSDLG_BROWSE_LOGON_DOMAIN |
                          FOCUSDLG_BROWSE_WKSTA_DOMAIN |
                          FOCUSDLG_BROWSE_OTHER_DOMAINS |
                          FOCUSDLG_BROWSE_TRUSTING_DOMAINS |
                          FOCUSDLG_BROWSE_WORKGROUP_DOMAINS |
                          FOCUSDLG_SERVERS_ONLY,
                          rgwch,
                          MAX_COMPUTERNAME_LENGTH + 3,
                          &bOK,
                          #ifndef UNICODE
                            rgwchHelp,
                          #else
                            szHelpFile,
                          #endif
                          IDH_SELECT_COMPUTER);

                  if (IDOK == bOK)
                     {
                     #ifndef UNICODE
                     WideCharToMultiByte(CP_ACP,
                         WC_COMPOSITECHECK | WC_DISCARDNS, rgwch,
                         -1, szConvPartner, MAX_COMPUTERNAME_LENGTH + 2, NULL, &bOK);
                     #else
                     lstrcpy(szConvPartner, rgwch);
                     #endif
                     }
                  else
                     {
                     szConvPartner[0] = TEXT('\0');
                     }
                  }
               else
                  {
                  PERROR(TEXT("Couldn't find connect proc!\r\n"));
                  }
               FreeLibrary(hMod);
               }
            else
               {
               PERROR(TEXT("Couldn't find NTLANMAN.DLL\r\n"));
               }

            // If we didn't find the fancy LanMan dialog, we still can get
            // by with our own cheesy version-- 'course, ours comes up faster, too.
            if (!fFoundLMDlg)
               {
               bOK = (BOOL)DialogBox(hInst, MAKEINTRESOURCE(IDD_CONNECT), hwnd,
                                     ConnectDlgProc);
               }

            if ( *szConvPartner )
               {
               CreateNewRemoteWindow ( szConvPartner, TRUE );
               }
            else
               {
                MessageBoxID (hInst,
                              hwnd,
                              IDS_NOCONNECTION,
                              IDS_APPNAME,
                              MB_OK | MB_ICONHAND);
               }
            UpdateWindow ( hwnd );
            break;
            }

        case IDM_REFRESH:

            if (!pActiveMDI)
                break;

            #if DEBUG
                {
                DWORD cbDBL = sizeof(DebugLevel);

                RegQueryValueEx(hkeyRoot, szDebug, NULL, NULL,
                    (LPBYTE)&DebugLevel, &cbDBL);
                }
            #endif
            if (pActiveMDI->flags & F_CLPBRD)
                break;

            AssertConnection ( hwndActiveChild );
            UpdateListBox ( hwndActiveChild, pActiveMDI->hExeConv );
            break;

        case IDM_CONTENTS:
            HtmlHelp(GetDesktopWindow(), szChmHelpFile, HH_DISPLAY_TOPIC, 0L);
            break;

        case IDM_ABOUT:
           {
           HMODULE hMod;
           LPFNSHELLABOUT lpfn;

           if (hMod = LoadLibrary(TEXT("SHELL32")))
              {
              if (lpfn = (LPFNSHELLABOUT)GetProcAddress(hMod,
                 #ifdef UNICODE
                   "ShellAboutW"
                 #else
                   "ShellAboutA"
                 #endif
                 ))
                 {
                 (*lpfn)(hwnd, szAppName, szNull,
                      LoadIcon(hInst, MAKEINTRESOURCE(IDFRAMEICON)));
                 }
              FreeLibrary(hMod);
              }
           else
              {
              PERROR(TEXT("Couldn't get SHELL32.DLL\r\n"));
              }
           }
           break;

        case CBM_AUTO:
        case CF_PALETTE:
        case CF_TEXT:
        case CF_BITMAP:
        case CF_METAFILEPICT:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_OEMTEXT:
        case CF_DIB:
        case CF_OWNERDISPLAY:
        case CF_DSPTEXT:
        case CF_DSPBITMAP:
        case CF_DSPMETAFILEPICT:
        case CF_PENDATA:
        case CF_RIFF:
        case CF_WAVE:
        case CF_ENHMETAFILE:
        case CF_UNICODETEXT:
        case CF_DSPENHMETAFILE:
        case CF_LOCALE:

            if (!pActiveMDI)
               break;

            if ( pActiveMDI->CurSelFormat != wParam)
                {
                CheckMenuItem (hDispMenu, pActiveMDI->CurSelFormat, MF_BYCOMMAND | MF_UNCHECKED);
                CheckMenuItem (hDispMenu, (UINT)wParam,                   MF_BYCOMMAND | MF_CHECKED);

                DrawMenuBar(hwnd);

                wOldFormat = GetBestFormat( hwndActiveChild, pActiveMDI->CurSelFormat);
                wNewFormat = GetBestFormat( hwndActiveChild, (UINT)wParam);

                if (wOldFormat == wNewFormat)
                    {
                    /* An equivalent format is selected; No change */
                    pActiveMDI->CurSelFormat = (UINT)wParam;
                    }
                else
                    {
                    /* A different format is selected; So, refresh... */

                    /* Change the character sizes based on new format. */
                    ChangeCharDimensions (hwndActiveChild, wOldFormat, wNewFormat);

                    pActiveMDI->fDisplayFormatChanged = TRUE;
                    pActiveMDI->CurSelFormat = (UINT)wParam;

                    // NOTE OwnerDisplay stuff applies only to the "real" clipboard!

                    if (wOldFormat == CF_OWNERDISPLAY)
                        {
                        /* Save the owner Display Scroll info */
                        SaveOwnerScrollInfo(hwndClpbrd);
                        ShowScrollBar ( hwndClpbrd, SB_BOTH, FALSE );
                        ShowHideControls(hwndClpbrd);
                        ResetScrollInfo( hwndActiveChild );
                        InvalidateRect ( hwndActiveChild, NULL, TRUE );
                        break;
                        }

                    if (wNewFormat == CF_OWNERDISPLAY)
                        {
                        /* Restore the owner display scroll info */
                        ShowHideControls(hwndClpbrd);
                        ShowWindow ( pActiveMDI->hwndSizeBox, SW_HIDE );
                        RestoreOwnerScrollInfo(hwndClpbrd);
                        InvalidateRect ( hwndActiveChild, NULL, TRUE );
                        break;
                        }

                    InvalidateRect  (hwndActiveChild, NULL, TRUE);
                    ResetScrollInfo (hwndActiveChild );
                    }
                }
            break;

        default:
            return DefFrameProc ( hwnd,hwndMDIClient,msg,wParam,lParam);
        }


    // return DefFrameProc ( hwnd,hwndMDIClient,msg,wParam,lParam);
    return 0;

}









/*
 *      SetListboxEntryToPageWindow
 */

BOOL SetListboxEntryToPageWindow(
    HWND        hwndc,
    PMDIINFO    pMDIc,
    int         lbindex)
{
HCONV       hConv;
LPLISTENTRY lpLE;
PVCLPBRD    pVClp;
PDATAREQ    pDataReq;
BOOL        fOK = FALSE;
TCHAR       tchTmp;
BOOL        fLocked;

// get listbox entry data



    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return fOK;



    fLocked = LockApp (TRUE, NULL);



    if (LB_ERR == SendMessage (pMDIc->hWndListbox, LB_GETTEXT, lbindex, (LPARAM)(LPCSTR)&lpLE)
        || !lpLE
        || !(pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("error from CreateNewDataReq\n\r"));
        goto done;
        }



    // make new clipboard
    if (!(pVClp = CreateVClipboard(hwndc)))
        {
        PERROR(TEXT("Failed to create Vclipboard\n\r"));
        goto done;
        }



    // nuke previous vclipboard if any
    if ( pMDIc->pVClpbrd )
        DestroyVClipboard( pMDIc->pVClpbrd );


    pMDIc->pVClpbrd = pVClp;


    // Set up $<page name> for topic
    if (pMDIc->hszClpTopic)
        DdeFreeStringHandle ( idInst, pMDIc->hszClpTopic );



    tchTmp = lpLE->name[0];
    lpLE->name[0] = SHR_CHAR;
    pMDIc->hszVClpTopic = DdeCreateStringHandle ( idInst, lpLE->name, 0 );
    lpLE->name[0] = tchTmp;

    if (!pMDIc->hszVClpTopic)
       {
       PERROR(TEXT("Couldn't make string handle for %s\r\n"), lpLE->name);
       goto done;
       }





    if (pMDIc->hVClpConv)
       {
       DdeDisconnect (pMDIc->hVClpConv);
       pMDIc->hVClpConv = NULL;
       }


    hConv = DdeConnect (idInst, pMDIc->hszConvPartner, pMDIc->hszVClpTopic, NULL);
    if (!hConv)
       {
       PERROR(TEXT("DdeConnect for Vclip failed: %x\n\r"), DdeGetLastError(idInst) );
       goto done;
       }


    pMDIc->hVClpConv = hConv;

    DdeKeepStringHandle (idInst, hszFormatList);

    pDataReq->rqType      = RQ_SETPAGE;
    pDataReq->hwndList    = pMDIc->hWndListbox;
    pDataReq->iListbox    = lbindex;
    pDataReq->hwndMDI     = hwndc;
    pDataReq->fDisconnect = FALSE;
    pDataReq->wFmt        = CF_TEXT;

    DdeSetUserHandle (hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq);

    if (!DdeClientTransaction (NULL,
                               0L,
                               hConv,
                               hszFormatList,
                               CF_TEXT,
                               XTYP_REQUEST,
                               (DWORD)TIMEOUT_ASYNC,
                               NULL ))
        DdeMessageBox (hInst,
                       pDataReq->hwndMDI,
                       DdeGetLastError (idInst),
                       IDS_APPNAME,
                       MB_OK|MB_ICONEXCLAMATION);

    fOK = TRUE;




done:

    if (!fOK)
        MessageBoxID ( hInst, hwndc, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONSTOP );

    if (fLocked)
        LockApp (FALSE, NULL);



    SetEvent (hXacting);

    return(fOK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvutil.h ===
/*****************************************************************************

                    C L I P B O O K   U T I L I T I E S

    Name:       cvutil.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for cvutil.c

*****************************************************************************/




extern  DWORD   gXERR_Type;
extern  DWORD   gXERR_Err;

extern  HSZ     hszErrorRequest;




VOID AdjustControlSizes(
    HWND    hwnd);


VOID ShowHideControls(
    HWND    hwnd);


BOOL AssertConnection(
    HWND    hwnd);


HCONV InitSysConv(
    HWND    hwnd,
    HSZ     hszApp,
    HSZ     hszTopic,
    BOOL    fLocal);


BOOL UpdateListBox(
    HWND    hwnd,
    HCONV   hConv);


BOOL GetPreviewBitmap(
    HWND    hwnd,
    LPTSTR  szName,
    UINT    index);


VOID SetBitmapToListboxEntry(
    HDDEDATA    hbmp,
    HWND        hwndList,
    UINT        index);


BOOL InitListBox(
    HWND        hwnd,
    HDDEDATA    hData);


UINT MyGetFormat(
    LPTSTR  szFmt,
    int     mode);


VOID HandleOwnerDraw(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


HWND CreateNewListBox(
    HWND    hwnd,
    DWORD   style);


BOOL SetClipboardFormatFromDDE(
    HWND     hwnd,
    UINT     uiFmt,
    HDDEDATA hDDE);


HWND  NewWindow(void);


VOID AdjustMDIClientSize(void);


HDDEDATA GetConvDataItem(
    HWND    hwnd,
    LPTSTR  szTopic,
    LPTSTR  szItem,
    UINT    uiFmt);


LRESULT  PASCAL MyMsgFilterProc(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam);


HDDEDATA MySyncXact(
    LPBYTE  lpbData,
    DWORD   cbDataLen,
    HCONV   hConv,
    HSZ     hszItem,
    UINT    wFmt,
    UINT    wType,
    DWORD   dwTimeout,
    LPDWORD lpdwResult);


void    RequestXactError(
    HCONV   hConv);


VOID ResetScrollInfo(
    HWND    hwnd);


BOOL IsShared(
    LPLISTENTRY lpLE);


BOOL SetShared(
    LPLISTENTRY lpLE,
    BOOL        fShared);


BOOL LockApp(
    BOOL    fLock,
    LPTSTR  lpszComment);


BOOL ForceRenderAll(
    HWND        hwnd,
    PVCLPBRD    pVclp);


BOOL UpdateNofMStatus(
    HWND    hwnd);


BOOL RestoreAllSavedConnections(void);


BOOL CreateNewRemoteWindow(
    LPTSTR  szMachineName,
    BOOL    fReconnect);


int MessageBoxID(
    HANDLE  hInstance,
    HWND    hwndParent,
    UINT    TextID,
    UINT    TitleID,
    UINT    fuStyle);


int NDdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle);


int SysMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    DWORD   dwErr,
    UINT    TitleID,
    UINT    fuStyle);


int XactMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    TitleID,
    UINT    fuStyle);


int DdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle);


void    ClearInput (HWND hWnd);


PDATAREQ CreateNewDataReq(void);


BOOL DeleteDataReq(
    PDATAREQ    pDataReq);


BOOL ProcessDataReq(
    HDDEDATA    hData,
    PDATAREQ    pDataReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\debug.c ===
//
// Purpose: This module contains functions that are being debugged or
//   are of interest during debugging. Generally, a function will be
//   placed in this file temporarily during debugging to make it easier
//   to find when running NTSD, 'cause the linker doesn't seem to include
//   symbols for functions that are only called from within their
//   own .c file.
//

// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <sedapi.h>
#include <commctrl.h>
#include <nddeapi.h>
#include <nddesec.h>

#include "clipbook.h"
#include "clipdsp.h"
#include "common.h"
#include "helpids.h"
#include "dialogs.h"
#include "debug.h"







// #define NOOLEITEMSPERMIT if netdde does not have
// support for allowing certain default OLE items in item-level
// conversations

#define NOOLEITEMSPERMIT

#ifdef NOOLEITEMSPERMIT
#define NOLEITEMS    5
static TCHAR *OleShareItems[NOLEITEMS] =
   {
   TEXT("StdDocumentName"),
   TEXT("EditEnvItems"),
   TEXT("StdHostNames"),
   TEXT("StdTargetDevice"),
   TEXT("StdDocDimensions")
   };
#endif // NOOLEITEMSPERMIT







// Typedef for dynamically loading the Edit Owner dialog.
typedef DWORD (WINAPI *LPFNOWNER)(
      HWND,
      HANDLE,
      LPWSTR,
      LPWSTR,
      LPWSTR,
      UINT,
      PSED_FUNC_APPLY_SEC_CALLBACK,
      ULONG,
      PSECURITY_DESCRIPTOR,
      BOOLEAN,
      BOOLEAN,
      LPDWORD,
      PSED_HELP_INFO,
      DWORD);







static  TCHAR   atchStatusBar[128];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\cvutil.c ===
/*****************************************************************************

                    C L I P B O O K   U T I L I T I E S

    Name:       cvutil.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        Utility functions for clipbook viewer.

    History:
        03-Feb-1994 John Fu     Add switch in ProcessDataReq's !hData path
                                to allow the lock to be displayed.
        19-Apr-1994 John Fu     Add DDE_DIB2BITMAP and veriouse fixes for
                                DIB to BITMAP conversion.
        30-Jun-1994 John Fu     Improved GetPreviewBitmap to allow multiple
                                connect tries and disable EDIT while waiting
                                to complete async transaction (there's still
                                holes).
        13-Mar-1995 John Fu     Add hXacting event to fix timing problems
                                Add Paste to Page stuff
                                Add UpdatePage
                                Fix MyMsgFilterProc

*****************************************************************************/





#define WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <assert.h>
#include <memory.h>
#include <stdio.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "cvinit.h"
#include "cvutil.h"
#include "dib.h"
#include "strtok.h"
#include "initmenu.h"
#include "debugout.h"



DWORD   gXERR_Type      = 0;
DWORD   gXERR_Err       = 0;
HSZ     hszErrorRequest = 0;





#if DEBUG
static void DumpDataReq (PDATAREQ pdr);


static void DumpDataReq(
    PDATAREQ    pdr)
{
    PINFO(TEXT("Datareq: type %d, to window %lx, \r\nat index %u, fDisc=%u, format=%u\r\n"),
               pdr->rqType,
               pdr->hwndMDI,
               pdr->iListbox,
               pdr->fDisconnect,
               pdr->wFmt);
}
#else
#define DumpDataReq(x)
#endif







// AdjustControlSizes //////////////////
//
// This function sizes the listbox windows associated
// with an MDI child window when its size changes

VOID AdjustControlSizes (
    HWND    hwnd)
{
RECT        rc1, rc2;
PMDIINFO    pMDI;
int         cx = GetSystemMetrics ( SM_CXVSCROLL );
int         cy = GetSystemMetrics ( SM_CYHSCROLL );



    if (!(pMDI = GETMDIINFO(hwnd)))
        return;


    GetClientRect ( hwnd, &rc1 );
    rc2 = rc1;
    rc2.right -= cx - 1;
    rc2.bottom -= cy - 1;

    switch ( pMDI->DisplayMode )
        {
        case DSP_LIST:
        case DSP_PREV:
            MoveWindow ( pMDI->hWndListbox, rc1.left - 1, rc1.top - 1,
               rc1.right - rc1.left + 2, ( rc1.bottom - rc1.top ) + 2, TRUE );
            break;

        case DSP_PAGE:
            MoveWindow (pMDI->hwndHscroll,
                        rc1.left - 1,
                        rc2.bottom,
                        (rc2.right - rc2.left) +2,
                        cy,
                        TRUE );

            if ( pMDI->flags & F_CLPBRD ) {
               MoveWindow ( pMDI->hwndVscroll, rc2.right, rc1.top - 1,
                  cx, ( rc2.bottom - rc2.top ) + 2, TRUE );
               }
            else
               {
               MoveWindow ( pMDI->hwndVscroll, rc2.right, rc1.top - 1,
                  cx, ( rc2.bottom - rc2.top ) + 2 - 2*cy, TRUE );
               }
            MoveWindow ( pMDI->hwndSizeBox,  rc2.right, rc2.bottom, cx, cy, TRUE );

            if ( ! ( pMDI->flags & F_CLPBRD ) )
               {
               MoveWindow ( pMDI->hwndPgUp, rc2.right,
                  rc2.bottom + 1 - 2*cy, cx, cy, TRUE );
               MoveWindow ( pMDI->hwndPgDown, rc2.right,
                  rc2.bottom + 1 - cy, cx, cy, TRUE );
               }

            // adjust display window
            pMDI->rcWindow = rc2;
            break;
        }

}






VOID ShowHideControls (
    HWND    hwnd)
{
PMDIINFO    pMDI;
int         nShowScroll;
int         nShowList;


    if (!(pMDI = GETMDIINFO(hwnd)))
        return;


    switch ( pMDI->DisplayMode )
        {
        case DSP_PREV:
        case DSP_LIST:
           nShowScroll = SW_HIDE;
           nShowList = SW_SHOW;
           break;

        case DSP_PAGE:
           if ( GetBestFormat( hwnd, pMDI->CurSelFormat) != CF_OWNERDISPLAY )
              nShowScroll = SW_SHOW;
           else
              {
              nShowScroll = SW_HIDE;
              ShowScrollBar ( hwnd, SB_BOTH, TRUE );
              }
           nShowList = SW_HIDE;
           break;
        }


   ShowWindow ( pMDI->hWndListbox, nShowList );
   ShowWindow ( pMDI->hwndVscroll, nShowScroll );
   ShowWindow ( pMDI->hwndHscroll, nShowScroll );
   ShowWindow ( pMDI->hwndSizeBox, nShowScroll );
   ShowWindow ( pMDI->hwndPgUp,    (pMDI->flags & F_CLPBRD)? SW_HIDE: nShowScroll );
   ShowWindow ( pMDI->hwndPgDown,  (pMDI->flags & F_CLPBRD)? SW_HIDE: nShowScroll );

}








// AssertConnection /////////////////

BOOL AssertConnection (
    HWND    hwnd)
{
PMDIINFO    pMDI;

    if (!(pMDI = GETMDIINFO(hwnd)))
        return FALSE;


    if (IsWindow(hwnd))
       {
       if (pMDI->hExeConv ||
           (pMDI->hExeConv = InitSysConv (hwnd,
                                          pMDI->hszConvPartner,
                                          hszClpBookShare,
                                          FALSE))
          )
          {
          return TRUE;
          }
       }
    return FALSE;
}










// InitSysConv ////////////////////////
//
// Purpose: Establishes a conversation with the given app and topic.
//
// Parameters:
//    hwnd      - MDI child window to own this conversation
//    hszApp    - App name to connect to
//    hszTopic  - Topic to connect to
//    fLocal    - Ignored.
//
// Returns: Handle to the conversation (0L if no conv. could be established).
//

HCONV InitSysConv (
    HWND    hwnd,
    HSZ     hszApp,
    HSZ     hszTopic,
    BOOL    fLocal )
{
HCONV       hConv = 0L;
PDATAREQ    pDataReq;
DWORD       dwErr;


#if DEBUG
TCHAR       atchApp[256];
TCHAR       atchTopic[256];

    if (DdeQueryString(idInst, hszApp, atchApp,
             sizeof(atchApp), CP_WINANSI) &&
        DdeQueryString(idInst, hszTopic, atchTopic,
             sizeof(atchTopic), CP_WINANSI))
       {
       PINFO(TEXT("InitSysConv: [%s | %s]\r\n"), atchApp, atchTopic);
       }
    else
       {
       PERROR(TEXT("I don't know my app/topic pair!\r\n"));
       }
#endif




    if (LockApp (TRUE, szEstablishingConn))
        {
        hConv = DdeConnect ( idInst, hszApp, hszTopic, NULL );
        if (!hConv)
            {
            dwErr = DdeGetLastError(idInst);
            PINFO(TEXT("Failed first try at CLIPSRV, #%x\r\n"), dwErr);

            if (GetSystemMetrics(SM_REMOTESESSION) )
                {
                MessageBoxID (hInst, hwnd, IDS_TSNOTSUPPORTED, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            else
                {
                MessageBoxID (hInst, hwnd, IDS_NOCLPBOOK, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            }
        else
            {
            PINFO(TEXT("Making datareq."));

            if ( pDataReq = CreateNewDataReq() )
                {
                pDataReq->rqType  = RQ_EXECONV;
                pDataReq->hwndMDI = hwnd;
                pDataReq->wFmt    = CF_TEXT;
                DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq );

                Sleep(3000);
                PINFO(TEXT("Entering AdvStart transaction "));

                if (!MySyncXact ( NULL, 0L, hConv, hszTopics,
                         CF_TEXT, XTYP_ADVSTART, LONG_SYNC_TIMEOUT, NULL ))
                    {
                    XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION);
                    }
                }
            else
                {
                PERROR(TEXT("InitSysConv:Could not create data req\r\n"));
                }
            }
        LockApp ( FALSE, szNull );
        }
    else
        {
        PERROR(TEXT("app locked in initsysconv\n\r"));
        }

    return hConv;

}







// UpdateListBox ////////////////////////////
//
// This function updates the contents of a listbox
// given the window handle of the MDI child window
// and the conversation over which the data is to be
// obtained

BOOL UpdateListBox(
    HWND    hwnd,
    HCONV   hConv)
{
HDDEDATA    hData;
BOOL        fOK = TRUE;



    if ( hConv == 0L || !IsWindow( hwnd ))
        {
        PERROR(TEXT("UpdateListBox called with garbage\n\r"));
        fOK = FALSE;
        }
    else
        {
        if (GETMDIINFO(hwnd) && GETMDIINFO(hwnd)->flags & F_LOCAL)
            {
            PINFO(TEXT("Getting all topics\r\n"));
            }
        else
            {
            PINFO(TEXT("Getting shared topics\r\n"));
            }



        // ask clipsrv to initialize shares

        MySyncXact (SZCMD_INITSHARE,
                    sizeof (SZCMD_INITSHARE),
                    hConv,
                    0L,
                    CF_TEXT,
                    XTYP_EXECUTE,
                    SHORT_SYNC_TIMEOUT,
                    NULL);



        //get the data

        hData = MySyncXact (NULL,
                            0L,
                            hConv,
                            hszTopics,
                            CF_TEXT,
                            XTYP_REQUEST,
                            SHORT_SYNC_TIMEOUT,
                            NULL );

        if ( !hData )
            {
            XactMessageBox (hInst,
                            hwnd,
                            IDS_APPNAME,
                            MB_OK | MB_ICONEXCLAMATION);
            fOK = FALSE;
            }
        else
            {
            fOK =  InitListBox ( hwnd, hData );
            }
        }

    return fOK;

}







// GetPreviewBitmap //////////////////////////////
// Informs CLIPSRV via DDE that we need a preview bitmap
// for the given page.
//
// Parameters:
//    hwnd -   Clipbook window which wants the bitmap
//    szName - Name of the clipbook page.
//    index  - Page's index within the listbox in hwnd
//
// Returns:
//    void.
//

BOOL GetPreviewBitmap (
    HWND    hwnd,
    LPTSTR  szName,
    UINT    index)
{
HSZ         hszTopic, hszItem = 0L;
HCONV       hConv;
HDDEDATA    hRet;
PDATAREQ    pDataReq;
BOOL        fLocked;
TCHAR       tchTmp;



    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return FALSE;



    fLocked = LockApp (TRUE, NULL);



    tchTmp = szName[0];
    szName[0] = SHR_CHAR;

    if (0 == (hszTopic = DdeCreateStringHandle (idInst, szName, 0)))
        {
        PERROR(TEXT("GetPreviewBitmap: no topic handle\n\r"));
        goto done;
        }


    if (0 == (hszItem = DdeCreateStringHandle (idInst, SZPREVNAME, 0)))
        {
        PERROR(TEXT("GetPreviewBitmap: no item handle\n\r"));
        goto done;
        }


    if (!GETMDIINFO(hwnd))
        {
        PERROR(TEXT("GETMDIINFO(hwnd) -> NULL\n\r"));
        goto done;
        }


    if (NULL == (pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("GetPreviewBitmap: no pdatareq\n\r"));
        goto done;
        }


    #if DEBUG
    {
    TCHAR atch[64];

    DdeQueryString(idInst, GETMDIINFO(hwnd)->hszConvPartnerNP,
          atch, 64, CP_WINANSI);
    PINFO(TEXT("GetPrevBmp: Connecting [%s | %s ! %s]\r\n"),
          atch, szName, SZPREVNAME);
    }
    #endif





    //
    // Let's try to connect up to ten times.  Sometimes when updating
    // the thumbnails if the user changes a page, the server will be
    // busy doing that and we can't connect here.  So, at least try
    // a few times.
    //
    {
    INT trycnt = 0;
    hConv = 0L;

    while (trycnt < 10 && !hConv)
        {
        hConv = DdeConnect (idInst, GETMDIINFO(hwnd)->hszConvPartnerNP, hszTopic, NULL);
        trycnt++;
        if (hConv) continue;

        PINFO (TEXT("GetPreviewBitmap: trying to connect again\r\n"));
        Sleep (200);
        }
    }



    if (hConv)
        {
        DWORD adwTrust[3];
        BOOL  fLocal = FALSE;

        if (GETMDIINFO(hwnd)->flags & F_LOCAL)
            {
            fLocal = TRUE;

            if (NDDE_NO_ERROR !=  NDdeGetTrustedShare(NULL, szName,
                  adwTrust, adwTrust + 1, adwTrust + 2))
                {
                adwTrust[0] = 0L;
                }

            NDdeSetTrustedShare (NULL,
                                 szName,
                                 adwTrust[0] | NDDE_TRUST_SHARE_INIT);
            }

        pDataReq->rqType      = RQ_PREVBITMAP;
        pDataReq->hwndList    = GETMDIINFO(hwnd)->hWndListbox;
        pDataReq->iListbox    = index;
        pDataReq->hwndMDI     = hwnd;
        pDataReq->fDisconnect = TRUE;
        pDataReq->wFmt        = (WORD)cf_preview;
        pDataReq->wRetryCnt   = 3;




        {
        /****   disable all edit function   ****/
        /**** will enable in after callback ****/

        // If the user does a paste or make some changes to the pages while
        // clipbrd is waiting for the xaction to complete, sometimes we get
        // a popup says there's a problem with connection (or something similar)
        // It seems there's some dirty code is causing this.  Below is a temp
        // fix which works well on fast machines.  On slower machines it may
        // still fail at times.  A better fix may be not to use async at all.
        // But there's not enough time to do this right now.
        //
        // NOTE: If there's multiple requests, one may complete while we're still
        // waitng for another.  This will cause the EDIT functions to be enabled
        // while we are still waiting.                          6/29/94 JyF.


        HANDLE hmenu;

        hmenu = GetMenu (hwndApp);

        EnableMenuItem (hmenu, IDM_COPY,       MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_KEEP,       MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_DELETE,     MF_GRAYED | MF_BYCOMMAND);

        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_COPY,   FALSE);
        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_KEEP,   FALSE);
        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_DELETE, FALSE);
        }


        hRet = DdeClientTransaction (NULL,
                                     0L,
                                     hConv,
                                     hszItem,
                                     cf_preview,
                                     XTYP_REQUEST,
                                     (DWORD)TIMEOUT_ASYNC,
                                     NULL);

        if ( !hRet )
            {
            unsigned uiErr;

            uiErr = DdeGetLastError (idInst);
            PERROR(TEXT("GetPreviewBitmap: Async Transaction for (%s) failed:%x\n\r"),
               szName, uiErr);
            }


        DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq );
        }
    #if DEBUG
    else
        {
        unsigned uiErr;

        uiErr = DdeGetLastError(idInst);
        DdeQueryString(idInst, GETMDIINFO(hwnd)->hszConvPartner,
           szBuf, 128, CP_WINANSI );
        PERROR(TEXT("GetPreviewBitmap: connect to %lx|%lx (%s|%s) failed: %d\n\r"),
           GETMDIINFO(hwnd)->hszConvPartner, hszTopic,
           (LPTSTR)szBuf, (LPTSTR)szName, uiErr);
        }
    #endif





done:

    if (!hszTopic)
        DdeFreeStringHandle (idInst, hszTopic);

    if (!hszItem)
        DdeFreeStringHandle ( idInst, hszItem );

    if (fLocked)
        LockApp (FALSE, NULL);

    szName[0] = tchTmp;



    SetEvent (hXacting);

    return TRUE;

}









VOID SetBitmapToListboxEntry (
    HDDEDATA    hbmp,
    HWND        hwndList,
    UINT        index)
{
LPLISTENTRY lpLE;
RECT        rc;
HBITMAP     hBitmap;
LPBYTE      lpBitData;
DWORD       cbDataLen;
unsigned    uiErr;


#if DEBUG
uiErr = DdeGetLastError(idInst);
if (uiErr)
    {
    PINFO(TEXT("SBmp2LBEntr: %d\r\n"), uiErr);
    }
#endif




    if (!IsWindow (hwndList)
        || SendMessage (hwndList, LB_GETTEXT,     index, (LPARAM)(LPCSTR)&lpLE) == LB_ERR
        || SendMessage (hwndList, LB_GETITEMRECT, index, (LPARAM)(LPRECT)&rc)   == LB_ERR)
        {
        DdeFreeDataHandle(hbmp);
        PERROR(TEXT("SetBitmapToListboxEntry: bad window: %x\n\r"), hwndList);
        }
    else
        {
        if (hbmp)
            {
            if ( lpBitData = DdeAccessData ( hbmp, &cbDataLen ))
                {
                // create the preview bitmap
                hBitmap  = CreateBitmap (PREVBMPSIZ,PREVBMPSIZ,1,1, lpBitData);
                DdeUnaccessData ( hbmp );
                }
            else
                {
                PERROR(TEXT("SB2LB: Couldn't access data!\r\n"));
                hBitmap = NULL;
                }

            DdeFreeDataHandle ( hbmp );
            lpLE->hbmp = hBitmap;

            PINFO(TEXT("Successfully set bmp.\r\n"));
            }

        PINFO(TEXT("Invalidating (%d,%d)-(%d,%d)\r\n"),rc.left, rc.top,
              rc.right, rc.bottom);
        InvalidateRect ( hwndList, &rc, TRUE );
        }


    uiErr = DdeGetLastError(idInst);
    if (uiErr)
        {
        PINFO (TEXT("SBmp2LBEntr: exit err %d\r\n"), uiErr);
        }

}








/*
 *      UpdatePage
 *
 *  When user paste into an existing page, the first item
 *  in szList is the share name of the page pasted. Since
 *  the name did not change, we need to do some special
 *  processing to update the display.
 *
 */

BOOL    UpdatePage (HWND hwnd, LPTSTR szList)
{
PMDIINFO    pMDI;
PLISTENTRY  pLE;
TCHAR       szPageBuf[MAX_NDDESHARENAME+1];
LPTSTR      szPage = szPageBuf;
RECT        Rect;
INT         i;



    *szPage = TEXT('\0');


    // does the first item in szList spcifies
    // an updated page?

    if (BOGUS_CHAR != *szList)
        return FALSE;



    // get the share name

    szList++;

    while (*szList && TEXT('\t') != *szList)
        *szPage++ = *szList++;

    *szPage = TEXT('\0');






    // Find the page, notice the name comparison below does not
    // compare the first char.  This is because the updated page's
    // share state may have changed so the first char won't match.

    pMDI = GETMDIINFO(hwnd);

    for (i=0;
         LB_ERR != SendMessage(pMDI->hWndListbox, LB_GETTEXT, i, (LPARAM)&pLE);
         i++)
        {
        if (pLE)
            if (!lstrcmpiA(pLE->name+1, szPageBuf+1))
                {
                goto update;
                }
        }


    return FALSE;




update:

    // invalidate the preview bitmap

    SendMessage (pMDI->hWndListbox, LB_GETITEMRECT, i, (LPARAM)&Rect);

    if (pLE->hbmp)
        DeleteObject (pLE->hbmp);

    pLE->fTriedGettingPreview = FALSE;
    pLE->hbmp = NULL;

    InvalidateRect (pMDI->hWndListbox, &Rect, FALSE);




    // if in page view and the page is the one currently
    // selected then update the page view

    if (DSP_PAGE == pMDI->DisplayMode)
        if (SendMessage (pMDI->hWndListbox, LB_GETCURSEL, 0, 0) == i)
            PostMessage (hwndApp, WM_COMMAND, IDM_UPDATE_PAGEVIEW, 0L);




    return TRUE;

}







// InitListBox //////////////////////////////////
//
// this function initializes the entries of a listbox
// given the handle of the MDI child window that owns
// the list box and a ddeml data handle that contains the
// tab-separated list of items that are to appear in the
// listbox
// BUGBUG: Right now, this deletes all entries in the list and
//    then recreates them. It would be more efficient to add or
//    delete only those items that have changed. This would save
//    CONSIDERABLE time in thumbnail mode-- now, we have to
//    establish a new DDE conversation with the server for each
//    page, just to get the thumbnail bitmap.


BOOL InitListBox (
    HWND        hwnd,
    HDDEDATA    hData )
{
PMDIINFO    pMDI;
PLISTENTRY  pLE;
LPTSTR      lpszList, q;
DWORD       cbDataLen;
HWND        hwndlist;
int         OldCount;
int         NewCount;
int         OldSel;
LPTSTR      OldSelString;
BOOL        OldStringDeleted;
int         i;
BOOL        fDel;




    if ( hData == 0L || !IsWindow ( hwnd ) )
       {
       PERROR(TEXT("InitListBox called with garbage\n\r"));
       return FALSE;
       }



    // Get a copy of the data in the handle
    lpszList = (LPTSTR)DdeAccessData ( hData, &cbDataLen );
    DdeUnaccessData(hData);
    lpszList = GlobalAllocPtr(GHND, cbDataLen);
    DdeGetData(hData, lpszList, cbDataLen, 0L);

    // Sometimes, the data will be longer than the string. This
    // would make the 'put tabs back' code below fail if we didn't
    // do this.
    cbDataLen = lstrlen(lpszList);

    PINFO(TEXT("InitLB: %s \r\n"), lpszList);

    if (!lpszList)
        {
        PERROR(TEXT("error accessing data in InitListBox\n\r"));
        return FALSE;
        }


    if (!(pMDI = GETMDIINFO(hwnd)))
        return FALSE;



    if (!(hwndlist = GETMDIINFO(hwnd)->hWndListbox))
        return FALSE;





    SendMessage ( hwndlist, WM_SETREDRAW, 0, 0L );





    // let's update the page that was pasted into
    // an existing page.

    UpdatePage (hwnd, lpszList);






    OldCount = (int)SendMessage ( hwndlist, LB_GETCOUNT, 0, 0L );
    OldSel = (int)SendMessage ( hwndlist, LB_GETCURSEL, 0, 0L );
    OldSelString = (LPTSTR)SendMessage (hwndlist, LB_GETITEMDATA, OldSel, 0);
    OldStringDeleted = FALSE;
    // SendMessage ( hwndlist, (UINT)LB_RESETCONTENT, 0, 0L );





    // Delete items in list that don't exist anymore
    for (i = 0; i < OldCount; i++)
        {
        SendMessage (hwndlist, LB_GETTEXT, i, (LPARAM)&pLE);
        fDel = TRUE;

        if (pLE)
            {
            for (q = strtokA(lpszList, "\t"); q; q = strtokA(NULL, "\t"))
                {
                PINFO(TEXT("<%hs>"), q);

                if (0 == lstrcmpA(pLE->name, q))
                   {
                   fDel = FALSE;
                   *q = BOGUS_CHAR;
                   break;
                   }
                }
            PINFO(TEXT("\r\n"));

            // Put back the tab chars that strtok ripped out
            for (q = lpszList;q < lpszList + cbDataLen;q++)
                {
                if ('\0' == *q)
                   {
                   *q = '\t';
                   }
                }
            *q = '\0';
            PINFO(TEXT("Restored %hs\r\n"), lpszList);

            if (fDel)
                {
                PINFO(TEXT("Deleting item %s at pos %d\r\n"), pLE->name, i);
                pLE->fDelete = TRUE;
                if (OldSelString == (LPTSTR)pLE)
                {
                   OldStringDeleted = TRUE;
                }
                SendMessage(hwndlist, LB_DELETESTRING, i, 0L);
                i--;
                if (OldCount)
                   {
                   OldCount--;
                   }
                }
            }
        else
            {
            PERROR(TEXT("Got NULL pLE!\r\n"));
            }
        }




    // Add new items to list
    for (q = strtokA(lpszList, "\t"); q; q = strtokA(NULL, "\t"))
       {
       // only add shared items if remote, never re-add existing items
       if (BOGUS_CHAR != *q &&
           (( GETMDIINFO(hwnd)->flags & F_LOCAL ) || *q == SHR_CHAR ))
          {
          // allocate a new list entry...
          if ( ( pLE = (PLISTENTRY)GlobalAllocPtr ( GHND,
                sizeof ( LISTENTRY ))) != NULL )
             {
             // mark this item to be deleted in WM_DELETEITEM
             pLE->fDelete = TRUE;
             pLE->fTriedGettingPreview = FALSE;

             lstrcpy(pLE->name, q);
             PINFO(TEXT("Adding item %s\r\n"), pLE->name);
             SendMessage(hwndlist, LB_ADDSTRING, 0, (LPARAM)(LPCSTR)pLE);
             }
          }
       }







    // Select the item at the same position we were at

    NewCount = (int)SendMessage (hwndlist, LB_GETCOUNT, 0, 0L);

    if (NewCount)
        if (OldCount == NewCount)
            {
            SendMessage (hwndlist,
                         LB_SETCURSEL,
                         OldSel,
                         0L);
            }
        else if ( (LB_ERR != (LRESULT)OldSelString) && (!OldStringDeleted) )
            {
            SendMessage (hwndlist,
                         LB_SELECTSTRING,
                         OldSel-1,  // we can do this 'cause listbox is sorted
                         (LPARAM)OldSelString);
            }




    SendMessage ( hwndlist, WM_SETREDRAW, 1, 0L );
    UpdateNofMStatus( hwnd );


    if (lpszList)
        GlobalFreePtr(lpszList);

    return TRUE;

}








// MyGetFormat ////////////////////////////
//
// this function returns the UINT ID of the
// format matchine the supplied string. This
// is the reverse of the "getclipboardformatname" function.
//
// Note that the formats &Bitmap, &Picture and Pal&ette exist
// both as predefined windows clipboard formats and as privately
// registered formats. The integer switch passed to this function
// determines whether the instrinsic format or the privately registered
// format ID is returned
//
// GETFORMAT_DONTLIE   return instrinsic format i.e. CF_BITMAP
// GETFORMAT_LIE      return registered format i.e. cf_bitmap

UINT MyGetFormat(
    LPTSTR  szFmt,
    int     mode)
{
TCHAR       szBuf[40];
unsigned    i;
UINT        uiPrivates[] = {CF_BITMAP,
                           CF_METAFILEPICT,
                           CF_PALETTE,
                           CF_ENHMETAFILE,
                           CF_DIB};



    PINFO("\nMyGetFormat [%s] %d:", szFmt, mode);

    for (i = 0;i <= CF_ENHMETAFILE ;i++)
        {
        LoadString(hInst, i, szBuf, 40);
        if (!lstrcmp( szFmt, szBuf))
            {
            if (GETFORMAT_DONTLIE == mode)
                {
                PINFO(TEXT("No-lie fmt %d\r\n"), i);
                }
            else
                {
                unsigned j;

                for (j = 0;j <sizeof(uiPrivates)/sizeof(uiPrivates[0]);j++)
                    {
                    if (i == uiPrivates[j])
                        {
                        i = RegisterClipboardFormat(szBuf);
                        break;
                        }
                    }
                }
            PINFO(TEXT("Format result %d\r\n"), i);
            return(i);
            }
        }

    for (i = CF_OWNERDISPLAY;i <= CF_DSPENHMETAFILE ;i++ )
        {
        LoadString(hInst, i, szBuf, 40);
        if (!lstrcmp( szFmt, szBuf))
            {
            if (GETFORMAT_DONTLIE != mode)
                {
                i = RegisterClipboardFormat(szBuf);
                }
            return(i);
            }
        }

    PINFO(TEXT("Registering format %s\n\r"), szFmt );

    return RegisterClipboardFormat ( szFmt );


}











// HandleOwnerDraw ////////////////////////////////
//
// This function handles drawing of owner draw buttons
// and listboxes in this app.

VOID HandleOwnerDraw(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPDRAWITEMSTRUCT    lpds;
RECT                tmprc;
COLORREF            OldTextColor;
COLORREF            OldBkColor;
COLORREF            BackColor;
COLORREF            TextColor;
HBRUSH              hBkBrush;
DWORD               cbData = 0L;
LPLISTENTRY         lpLE;
BOOL                fSel = FALSE;



   lpds = (LPDRAWITEMSTRUCT) lParam;

   // this section handles listbox drawing

    switch ( lpds->CtlID )
        {
        case ID_LISTBOX:
            if (!GETMDIINFO(hwnd))
                 break;

            if ( GETMDIINFO(hwnd)->DisplayMode == DSP_LIST )
                {
                if ( lpds->itemAction & (ODA_DRAWENTIRE|ODA_SELECT|ODA_FOCUS))
                    {
                    if ( SendMessage ( GETMDIINFO(hwnd)->hWndListbox, LB_GETTEXT,
                          lpds->itemID, (LPARAM)(LPCSTR)&lpLE ) == LB_ERR )
                        {
                        return;
                        }

                    hOldBitmap = SelectObject ( hBtnDC, hbmStatus );

                    tmprc = lpds->rcItem;

                    if ( lpds->itemState & ODS_SELECTED &&
                                lpds->itemState & ODS_FOCUS )
                        {
                        TextColor = GetSysColor ( COLOR_HIGHLIGHTTEXT );
                        BackColor = GetSysColor ( COLOR_HIGHLIGHT );
                        }
                    else
                        {
                        TextColor = GetSysColor ( COLOR_WINDOWTEXT );
                        BackColor = GetSysColor ( COLOR_WINDOW );
                        }

                    OldTextColor = SetTextColor ( lpds->hDC, TextColor );
                    OldBkColor = SetBkColor ( lpds->hDC, BackColor );

                    hBkBrush = CreateSolidBrush ( BackColor );
                    if ( hBkBrush )
                       FillRect ( lpds->hDC, &tmprc, hBkBrush );
                    DeleteObject ( hBkBrush );

                    hOldFont = SelectObject ( lpds->hDC, hFontPreview );



                    TextOut (lpds->hDC,
                             lpds->rcItem.left + 2 * LSTBTDX,
                             lpds->rcItem.top+1,
                             &(lpLE->name[1]),
                             lstrlen((lpLE->name)) - 1);

                    SelectObject ( lpds->hDC, hOldFont );

                    if ( IsShared( lpLE ) && fShareEnabled )
                        {
                        BitBlt ( lpds->hDC, lpds->rcItem.left + ( LSTBTDX / 2 ),
                           lpds->rcItem.top, LSTBTDX, LSTBTDY,
                           hBtnDC,
                           SHR_PICT_X,
                           SHR_PICT_Y +
                           (( lpds->itemState & ODS_SELECTED ) &&
                            ( lpds->itemState & ODS_FOCUS ) ? 0 : LSTBTDY ),
                           SRCCOPY );
                        }
                    else
                        {
                        BitBlt ( lpds->hDC, lpds->rcItem.left + ( LSTBTDX / 2 ),
                           lpds->rcItem.top, LSTBTDX, LSTBTDY,
                           hBtnDC,
                           SAV_PICT_X,
                           SAV_PICT_Y +
                           (( lpds->itemState & ODS_SELECTED ) &&
                            ( lpds->itemState & ODS_FOCUS ) ? 0 : LSTBTDY ),
                           SRCCOPY );
                        }

                    SelectObject ( hBtnDC, hOldBitmap );
                    SetTextColor ( lpds->hDC, OldTextColor );
                    SetBkColor ( lpds->hDC, OldBkColor );

                    if ( lpds->itemAction & ODA_FOCUS &&
                       lpds->itemState & ODS_FOCUS )
                        {
                        DrawFocusRect ( lpds->hDC, &(lpds->rcItem) );
                        }
                    }
                }
            else if ( GETMDIINFO(hwnd)->DisplayMode == DSP_PREV )
                {
                if ( lpds->itemAction & ODA_FOCUS )
                    {
                    DrawFocusRect ( lpds->hDC, &(lpds->rcItem) );
                    }

                if ( SendMessage ( GETMDIINFO(hwnd)->hWndListbox, LB_GETTEXT,
                      lpds->itemID, (LPARAM)(LPCSTR)&lpLE ) == LB_ERR )
                    {
                    //PERROR(TEXT("weird, WM_DRAWITEM for empty listbox\n\r");
                    // not weird, for empty focus rect
                    return;
                    }

                if ( lpds->itemAction & ODA_DRAWENTIRE )
                    {

                    // erase any bogus leftover focusrect
                    // due to what I consider ownerdraw bugs
                    if ( hBkBrush = CreateSolidBrush ( GetSysColor(COLOR_WINDOW)))
                        {
                        FillRect ( lpds->hDC, &(lpds->rcItem), hBkBrush );
                        DeleteObject ( hBkBrush );
                        }

                    tmprc.top    = lpds->rcItem.top + PREVBRD;
                    tmprc.bottom = lpds->rcItem.top + PREVBRD + PREVBMPSIZ;
                    tmprc.left   = lpds->rcItem.left + 5 * PREVBRD;
                    tmprc.right  = lpds->rcItem.right - 5 * PREVBRD;

                    Rectangle (lpds->hDC,
                               tmprc.left,
                               tmprc.top,
                               tmprc.right,
                               tmprc.bottom );

                    // draw preview bitmap if available
                    if (lpLE->hbmp == NULL)
                        {
                        if (!lpLE->fTriedGettingPreview)
                            {
                            if (!GetPreviewBitmap (hwnd,
                                                   lpLE->name,
                                                   lpds->itemID))
                                {
                                lpLE->fTriedGettingPreview = FALSE;

                                InvalidateRect (lpds->hwndItem,
                                                &(lpds->rcItem),
                                                FALSE);
                                break;
                                }
                            else
                                {
                                lpLE->fTriedGettingPreview = TRUE;
                                }
                            }
                        else
                            {
                            DrawIcon ( lpds->hDC,
                               // the magic '19' below is a function of the icon
                                  tmprc.left + PREVBMPSIZ - 19,
                                  tmprc.top,
                                  hicLock);
                            }
                        }
                    else
                        {
                        hOldBitmap = SelectObject ( hBtnDC, lpLE->hbmp );
                        BitBlt ( lpds->hDC, tmprc.left+1, tmprc.top+1,
                              ( tmprc.right - tmprc.left ) - 2,
                              ( tmprc.bottom - tmprc.top ) - 2,
                              hBtnDC, 0, 0, SRCCOPY );
                        SelectObject ( hBtnDC, hOldBitmap );
                        }

                    // draw share icon in corner...

                    if ( IsShared ( lpLE ) && fShareEnabled )
                        {
                        DrawIcon (lpds->hDC,
                                  tmprc.left - 10,
                                  tmprc.top + PREVBMPSIZ - 24,
                                  LoadIcon ( hInst, MAKEINTRESOURCE(IDSHAREICON)));
                       }
                    }

                if ( lpds->itemAction & ( ODA_SELECT | ODA_DRAWENTIRE | ODA_FOCUS ))
                    {
                    tmprc = lpds->rcItem;
                    tmprc.left += PREVBRD;
                    tmprc.right -= PREVBRD;
                    tmprc.top += PREVBMPSIZ + 2 * PREVBRD;
                    tmprc.bottom--;

                    if ((lpds->itemState & ODS_SELECTED) &&
                        (lpds->itemState & ODS_FOCUS))
                        {
                        TextColor = GetSysColor ( COLOR_HIGHLIGHTTEXT );
                        BackColor = GetSysColor ( COLOR_HIGHLIGHT );
                        }
                    else
                        {
                        TextColor = GetSysColor ( COLOR_WINDOWTEXT );
                        BackColor = GetSysColor ( COLOR_WINDOW );
                        }

                    OldTextColor = SetTextColor ( lpds->hDC, TextColor );
                    OldBkColor = SetBkColor ( lpds->hDC, BackColor );
                    hOldFont = SelectObject ( lpds->hDC, hFontPreview );

                    if ( hBkBrush = CreateSolidBrush ( BackColor ))
                        {
                        FillRect ( lpds->hDC, &tmprc, hBkBrush );
                        DeleteObject ( hBkBrush );
                        }


                    DrawText (lpds->hDC,
                              &(lpLE->name[1]),
                              lstrlen(lpLE->name) -1,
                              &tmprc,
                              DT_CENTER | DT_WORDBREAK | DT_NOPREFIX );

                    SetTextColor ( lpds->hDC, OldTextColor );
                    SetBkColor ( lpds->hDC, OldBkColor );
                    SelectObject ( lpds->hDC, hOldFont );
                    }
                }
            break;

        case ID_PAGEUP:
        case ID_PAGEDOWN:

            if (lpds->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))
                {
                if (lpds->itemState & ODS_SELECTED)
                    hOldBitmap = SelectObject (hBtnDC,
                                               (lpds->CtlID==ID_PAGEUP)? hPgUpDBmp: hPgDnDBmp);
                else
                    hOldBitmap = SelectObject (hBtnDC,
                                               (lpds->CtlID==ID_PAGEUP)? hPgUpBmp: hPgDnBmp);

                StretchBlt (lpds->hDC,
                            lpds->rcItem.top,
                            lpds->rcItem.left,
                            GetSystemMetrics (SM_CXVSCROLL),
                            GetSystemMetrics (SM_CYHSCROLL),
                            hBtnDC,
                            0,
                            0,
                            17,     // x and y of resource bitmaps
                            17,
                            SRCCOPY);

                SelectObject (hBtnDC, hOldBitmap);
                }
            break;

        default:
            PERROR(TEXT("spurious WM_DRAWITEM ctlID %x\n\r"), lpds->CtlID );
            break;
        }

}










// CreateNewListBox ///////////////////////////////
//
// this function creates a new ownerdraw listbox in one of
// two styles suitable for this app: multicolumn for the
// preview bitmap display, and single column for the description
// display preceeded by the little clipboard entry icons

HWND CreateNewListBox(
    HWND    hwnd,
    DWORD   style)
{
HWND hLB;


    hLB = CreateWindow (TEXT("listbox"),
                        szNull,
                        WS_CHILD | LBS_STANDARD | LBS_NOINTEGRALHEIGHT | style,
                        0,
                        0,
                        100,
                        100,
                        hwnd,
                        (HMENU)ID_LISTBOX,
                        hInst,
                        0L );

    if ( style & LBS_MULTICOLUMN )
       SendMessage ( hLB, LB_SETCOLUMNWIDTH, PREVBMPSIZ + 10*PREVBRD, 0L );

    return hLB;

}





// SetClipboardFormatFromDDE ///////////////////////////
//
// This function accepts a ddeml data handle and uses the
// data contained in it to set the clipboard data in the specified
// format to the virtual clipboard associated with the supplied MDI
// child window handle. This could be the real clipboard if the MDI
// child window handle refers to the clipboard child window.

BOOL SetClipboardFormatFromDDE(
    HWND     hwnd,
    UINT     uiFmt,
    HDDEDATA hDDE)
{
HANDLE         hBitmap;
HANDLE         hData;
LPBYTE         lpData;
LPBYTE         lpSrc;
BITMAP         bitmap;
HPALETTE       hPalette;
LPLOGPALETTE   lpLogPalette;
DWORD          cbData;
int            err;
BOOL           fOK = FALSE;


    PINFO("SetClpFmtDDE: format %d, handle %ld | ", uiFmt, hDDE);


    // Check for existing errors, clear the error flag
    err = DdeGetLastError(idInst);



    if (err != DMLERR_NO_ERROR)
        {
        PERROR(TEXT("Existing err %x\r\n"), err);
        }


    // get size of data
    if (NULL == (lpSrc = DdeAccessData ( hDDE, &cbData )))
        {
        #if DEBUG
        unsigned i;

        i = DdeGetLastError(idInst);
        PERROR(TEXT("DdeAccessData fail %d on handle %ld\r\n"), i, hDDE);
        #endif
        goto done;
        }




    PINFO(TEXT("%d bytes of data. "), cbData);

    if (!(hData = GlobalAlloc(GHND, cbData)))
        {
        PERROR(TEXT("GlobalAlloc failed\n\r"));
        goto done2;
        }



    if (!(lpData = GlobalLock(hData)))
       {
       PERROR(TEXT("GlobalLock failed\n\r"));
       goto done2;
       }



    memcpy(lpData, lpSrc, cbData);
    GlobalUnlock(hData);



    // As when we write these we have to special case a few of
    // these guys.  This code and the write code should match in terms
    // of the sizes and positions of data blocks being written out.
    switch ( uiFmt )
        {
        case CF_METAFILEPICT:
           {
           HANDLE      hMF;
           HANDLE      hMFP;
           HANDLE      hDataOut =  NULL;
           LPMETAFILEPICT   lpMFP;

           // Create the METAFILE with the bits we read in. */
           lpData = GlobalLock(hData);
           if (hMF = SetMetaFileBitsEx(cbData - sizeof(WIN31METAFILEPICT),
                    lpData + sizeof(WIN31METAFILEPICT)))
              {
              // Alloc a METAFILEPICT header.
              if (hMFP = GlobalAlloc(GHND, (DWORD)sizeof(METAFILEPICT)))
                 {
                 if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP)))
                    {
                    PERROR(TEXT("Set...FromDDE: GlobalLock failed\n\r"));
                    GlobalFree(hMFP);
                    }
                 else
                    {
                    // Have to set this struct memberwise because it's packed
                    // as a WIN31METAFILEPICT in the data we get via DDE
                    lpMFP->hMF = hMF;      /* Update the METAFILE handle  */
                    lpMFP->xExt =((WIN31METAFILEPICT *)lpData)->xExt;
                    lpMFP->yExt =((WIN31METAFILEPICT *)lpData)->yExt;
                    lpMFP->mm   =((WIN31METAFILEPICT *)lpData)->mm;

                    GlobalUnlock(hMFP);      /* Unlock the header      */
                    hDataOut = hMFP;       /* Stuff this in the clipboard */
                    fOK = TRUE;
                    }
                 }
              else
                 {
                 PERROR(TEXT("SCFDDE: GlobalAlloc fail in MFP, %ld\r\n"),
                       GetLastError());
                 }
              }
           else
              {
              PERROR(TEXT("SClipFDDE: SetMFBitsEx fail %ld\r\n"), GetLastError());
              }
           GlobalUnlock(hData);

           // GlobalFree(hData);

           hData = hDataOut;
           break;
           }

        case CF_ENHMETAFILE:
           // We get a block of memory containing enhmetafile bits in this case.
           if (lpData = GlobalLock(hData))
              {
              HENHMETAFILE henh;

              henh = SetEnhMetaFileBits(cbData, lpData);

              if (NULL == henh)
                 {
                 PERROR(TEXT("SetEnhMFBits fail %d\r\n"), GetLastError());
                 }
              else
                 {
                 fOK = TRUE;
                 }

              GlobalUnlock(hData);
              GlobalFree(hData);

              hData = henh;
              }
           else
              {
              GlobalFree(hData);
              hData = NULL;
              }
           break;

        case CF_BITMAP:
           if (!(lpData = GlobalLock(hData)))
              {
              GlobalFree(hData);
              }
           else
              {
              bitmap.bmType = ((WIN31BITMAP *)lpData)->bmType;
              bitmap.bmWidth = ((WIN31BITMAP *)lpData)->bmWidth;
              bitmap.bmHeight = ((WIN31BITMAP *)lpData)->bmHeight;
              bitmap.bmWidthBytes = ((WIN31BITMAP *)lpData)->bmWidthBytes;
              bitmap.bmPlanes = ((WIN31BITMAP *)lpData)->bmPlanes;
              bitmap.bmBitsPixel = ((WIN31BITMAP *)lpData)->bmBitsPixel;
              bitmap.bmBits = lpData + sizeof(WIN31BITMAP);

              // If this fails we should avoid doing the SetClipboardData()
              // below with the hData check.
              hBitmap = CreateBitmapIndirect(&bitmap);

              GlobalUnlock(hData);
              GlobalFree(hData);
              hData = hBitmap;      // Stuff this in the clipboard

              if (hBitmap)
                 {
                 fOK = TRUE;
                 }
              }
           break;

        case CF_PALETTE:
           if (!(lpLogPalette = (LPLOGPALETTE)GlobalLock(hData)))
              {
              GlobalFree(hData);
              DdeUnaccessData( hDDE );
              DdeFreeDataHandle ( hDDE );
              fOK = FALSE;
              }
           else
              {
              // Create a logical palette.
              if (!(hPalette = CreatePalette(lpLogPalette)))
                 {
                 GlobalUnlock(hData);
                 GlobalFree(hData);
                 }
              else
                 {
                 GlobalUnlock(hData);
                 GlobalFree(hData);

                 hData = hPalette;      // Stuff this into clipboard
                 fOK = TRUE;
                 }
              }
           break;


        case DDE_DIB2BITMAP:

            // convert dib to bitmap
            {
            HBITMAP hBmp;

            hBmp = BitmapFromDib (hData,
                                  VGetClipboardData (GETMDIINFO(hwnd)->pVClpbrd, CF_PALETTE));

            GlobalFree (hData);
            hData = hBmp;

            uiFmt = CF_BITMAP;

            fOK = TRUE;
            break;
            }


        default:
           fOK = TRUE;
        }



    if (!hData)
        {
        PERROR(TEXT("SetClipboardFormatFromDDE returning FALSE\n\r"));
        }


    if (GETMDIINFO(hwnd))
        if (fOK)
            {
            PINFO(TEXT("SCFFDDE: Setting VClpD\r\n"));
            VSetClipboardData( GETMDIINFO(hwnd)->pVClpbrd, uiFmt, hData);
            }
        else if (!(GETMDIINFO(hwnd)->flags & F_CLPBRD))
            {
                VSetClipboardData (GETMDIINFO(hwnd)->pVClpbrd, uiFmt,
                                   INVALID_HANDLE_VALUE);
            }


    // No GlobalFree() call here, 'cause we've put hData on the clp


done2:
    DdeUnaccessData(hDDE);

done:
    DdeFreeDataHandle(hDDE);

    return fOK;

}









// NewWindow /////////////////////////////////////////////
//
// this function creates a new MDI child window. special
// case code detects if the window created is the special case
// clipboard MDI child window or the special case local clipbook
// window, this information is used to size the initial 2 windows
// to be tiled side-by-side


HWND  NewWindow(VOID)
{
HWND hwnd;
MDICREATESTRUCT mcs;

    mcs.szTitle = TEXT("");
    mcs.szClass = szChild;
    mcs.hOwner   = hInst;

    /* Use the default size for the window */

    if ( !hwndClpbrd )
       {
       mcs.style = WS_MINIMIZE;
       }
    else
       {
       mcs.style = 0;
       }
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;

    /* Set the style DWORD of the window to default */

    // note not visible!
    mcs.style |= ( WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CAPTION |
       WS_THICKFRAME | WS_MAXIMIZEBOX | WS_MINIMIZEBOX |
       WS_SYSMENU );

    /* tell the MDI Client to create the child */
    hwnd = (HWND)SendMessage (hwndMDIClient,
               WM_MDICREATE,
               0,
               (LPARAM)(LPMDICREATESTRUCT)&mcs);

    return hwnd;
}








// AdjustMDIClientSize //////////////////////////////
//
// this function adjusts the size of the MDI client window
// when the application is resized according to whether the
// toolbar/status bar is visible, etc.

VOID AdjustMDIClientSize(VOID)
{
RECT rcApp;
RECT rcMDI;


    //   WINDOWPLACEMENT wpl;

    if (IsIconic(hwndApp))
        return;

    //wpl.length = sizeof(WINDOWPLACEMENT);
    //GetWindowPlacement ( hwndApp, &wpl );

    //if ( wpl.showCmd != SW_SHOWMAXIMIZED )
    //   rcApp = wpl.rcNormalPosition;
    //else
    //   GetClientRect ( hwndApp, &rcApp );


    GetClientRect (hwndApp, &rcApp);



    rcMDI.top    = 0;
    rcMDI.bottom = rcApp.bottom - rcApp.top;
    //      - ( GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU)))
    //      - ( 2 * GetSystemMetrics(SM_CYFRAME));

    rcMDI.left = 0;
    rcMDI.right = rcApp.right - rcApp.left;
    //      - ( 2 * GetSystemMetrics(SM_CXFRAME));

    MoveWindow (hwndMDIClient,
                rcMDI.left - 1,
                rcMDI.top + (fToolBar? (dyButtonBar +1): 0),
                (rcMDI.right - rcMDI.left) + 2,
                ((rcMDI.bottom - rcMDI.top) - (fStatus?dyStatus:0)) -(fToolBar?(dyButtonBar +1):0),
                TRUE);

    if (fNeedToTileWindows )
        {
        SendMessage (hwndMDIClient, WM_MDITILE, 0, 0);
        fNeedToTileWindows = FALSE;
        }
}









// GetConvDataItem ///////////////////////////////////
//
// this function retrieves the data item associated with the
// supplied topic and item from whatever local or remote host
// the MDI child window specified by the supplied handle is
// communicating with. It is used to get the preview bitmaps and
// to get individual format data.
//
// NOTE: caller should LockApp before calling this!

HDDEDATA GetConvDataItem(
    HWND    hwnd,
    LPTSTR  szTopic,
    LPTSTR  szItem,
    UINT    uiFmt)
{
HCONV       hConv;
HSZ         hszTopic;
HSZ         hszItem;
HDDEDATA    hRet = 0;
PMDIINFO    pMDI;



    // assert(fAppLockedState);

    PINFO(TEXT("GConvDI: %s ! %s, %x\r\n"), szTopic, szItem, uiFmt);

    if (!( hszTopic = DdeCreateStringHandle ( idInst, szTopic, 0 )))
        {
        PERROR(TEXT("GetConvDataItem: DdeCreateStringHandle failed\n\r"));
        return 0;
        }

    if (!(hszItem = DdeCreateStringHandle ( idInst, szItem, 0 )))
        {
        DdeFreeStringHandle ( idInst, hszTopic );
        PERROR(TEXT("GetConvDataItem: DdeCreateStringHandle failed\n\r"));
        return 0;
        }


    if (!(pMDI = GETMDIINFO(hwnd)))
        return 0;

    if ( hConv = DdeConnect (idInst,
                             (uiFmt == cf_preview && !(pMDI->flags & F_LOCAL))?
                              pMDI->hszConvPartnerNP:
                              pMDI->hszConvPartner,
                             hszTopic,NULL ))
        {
        hRet = MySyncXact (NULL, 0L, hConv,
                           hszItem, uiFmt, XTYP_REQUEST, SHORT_SYNC_TIMEOUT, NULL );
        if ( !hRet )
           {
           PERROR(TEXT("Transaction for (%s):(%s) failed: %x\n\r"),
              szTopic, szItem, DdeGetLastError(idInst));
           }
        }
    #if DEBUG
    else
        {
        DdeQueryString ( idInst, GETMDIINFO(hwnd)->hszConvPartner,
           szBuf, 128, CP_WINANSI );
        PERROR(TEXT("GetConvDataItem: connect to %s|%s failed: %d\n\r"),
                    (LPTSTR)szBuf,
                    (LPTSTR)szTopic, DdeGetLastError(idInst) );
        }
    #endif


    DdeDisconnect ( hConv );
    DdeFreeStringHandle ( idInst, hszTopic );


    return hRet;

}








//***************************************************************************
//  FUNCTION   : MyMsgFilterProc
//
//  PURPOSE   : This filter proc gets called for each message we handle.
//            This allows our application to properly dispatch messages
//            that we might not otherwise see because of DDEMLs modal
//            loop that is used while processing synchronous transactions.
//
//            Generally, applications that only do synchronous transactions
//            in response to user input (as this app does) does not need
//            to install such a filter proc because it would be very rare
//            that a user could command the app fast enough to cause
//            problems.  However, this is included as an example.

LRESULT  PASCAL MyMsgFilterProc(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam)
{



    if (( nCode == MSGF_DIALOGBOX || nCode == MSGF_MENU ) &&
          ((LPMSG)lParam)->message == WM_KEYDOWN &&
          ((LPMSG)lParam)->wParam == VK_F1 )
       {
       PostMessage ( hwndApp, WM_F1DOWN, nCode, 0L );
       }
    else if (nCode == MSGF_DDEMGR)
       {
       /* If a keyboard message is for the MDI , let the MDI client
        * take care of it.  Otherwise, check to see if it's a normal
        * accelerator key.  Otherwise, just handle the message as usual.
        */

       //if (!TranslateMDISysAccel (hwndMDIClient, (LPMSG)lParam) &&
       //    (hAccel? !TranslateAccelerator(hwndApp, hAccel, (LPMSG)lParam): 1))
       //   {
       //   TranslateMessage ((LPMSG)lParam );
       //   DispatchMessage ((LPMSG)lParam );
       //   }
       //return(1);
       }

    return(0);
}










// MySyncXact ///////////////////////////////
//
// this function is a wrapper to DdeClientTransaction which
// performs some checks related to the Locked state of the app

HDDEDATA MySyncXact(
    LPBYTE  lpbData,
    DWORD   cbDataLen,
    HCONV   hConv,
    HSZ     hszItem,
    UINT    wFmt,
    UINT    wType,
    DWORD   dwTimeout,
    LPDWORD lpdwResult)
{
HDDEDATA    hDDE;
BOOL        fAlreadyLocked;
UINT        uiErr;
UINT        DdeErr = 0;
DWORD       dwTmp  = 0;

#if DEBUG
if (dwTimeout != TIMEOUT_ASYNC)
    {
    dwTimeout +=10000;
    }
#endif





    // are we already in transaction?

    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        {
        Sleep (2000);
        ClearInput (hwndApp);
        return 0L;
        }



    fAlreadyLocked = !LockApp(TRUE, NULL);



    gXERR_Type = 0;
    gXERR_Err  = 0;





    hDDE = DdeClientTransaction (lpbData,
                                 cbDataLen,
                                 hConv,
                                 hszItem,
                                 wFmt,
                                 wType,
                                 dwTimeout,
                                 lpdwResult );


    if (!hDDE)
        {
        DWORD   size;
        LPBYTE  lpByte;


        DdeErr = DdeGetLastError(idInst);

        #if DEBUG
        PERROR("MySyncXact fail err %d.\r\n", uiErr);

        DdeQueryString (idInst, hszItem, lpbItem, 64, CP_WINANSI);
        PINFO(TEXT("Parameters: data at %lx (%s), len %ld, HCONV %lx\r\n"),
              lpbData, (CF_TEXT == wFmt && lpbData) ? lpbData : TEXT("Not text"),
              cbDataLen, hConv);

        PINFO(TEXT("item %lx (%s), fmt %d, type %d, timeout %ld\r\n"),
              hszItem, lpbItem, wFmt, wType, dwTimeout);
        #endif


        //
        // There was an error in the transaction, let's ask
        // the server what was it.
        //

        hDDE = DdeClientTransaction (NULL,
                                     0L,
                                     hConv,
                                     hszErrorRequest,
                                     CF_TEXT,
                                     XTYP_REQUEST,
                                     SHORT_SYNC_TIMEOUT,
                                     NULL);

        uiErr = DdeGetLastError (idInst);

        if (lpByte = DdeAccessData (hDDE, &size))
            sscanf (lpByte, XERR_FORMAT, &gXERR_Type, &gXERR_Err);

        DdeUnaccessData (hDDE);
        DdeFreeDataHandle (hDDE);

        hDDE = 0;
        }



    if (!gXERR_Type && DdeErr)
        {
        gXERR_Type = XERRT_DDE;
        gXERR_Err  = DdeErr;
        }



    if (!fAlreadyLocked)
        {
        LockApp(FALSE, NULL);
        }



    SetEvent (hXacting);


    return hDDE;


}









/*
 *      RequestXactError
 *
 *  Ask the server for error code.
 */

void    RequestXactError(
    HCONV   hConv)
{
HDDEDATA    hDDE;
BOOL        fAlreadyLocked;
UINT        uiErr;
UINT        DdeErr = 0;
DWORD       size;
LPBYTE      lpByte;



    // Are we already in transaction?

    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        {
        Sleep (2000);
        ClearInput (hwndApp);
        return;
        }



    fAlreadyLocked = !LockApp(TRUE, NULL);



    gXERR_Type = 0;
    gXERR_Err  = 0;



    DdeErr = DdeGetLastError(idInst);




    hDDE = DdeClientTransaction (NULL,
                                 0L,
                                 hConv,
                                 hszErrorRequest,
                                 CF_TEXT,
                                 XTYP_REQUEST,
                                 SHORT_SYNC_TIMEOUT,
                                 NULL);

    uiErr = DdeGetLastError (idInst);


    if (lpByte = DdeAccessData (hDDE, &size))
        sscanf (lpByte, XERR_FORMAT, &gXERR_Type, &gXERR_Err);

    DdeUnaccessData (hDDE);
    DdeFreeDataHandle (hDDE);




    if (!gXERR_Type && DdeErr)
        {
        gXERR_Type = XERRT_DDE;
        gXERR_Err  = DdeErr;
        }



    if (!fAlreadyLocked)
        {
        LockApp(FALSE, NULL);
        }


    SetEvent (hXacting);


}










// ResetScrollInfo ///////////////////////////
//
// this function resets the scroll information of the
// MDI child window designated by the supplied handle

VOID ResetScrollInfo(
    HWND    hwnd)
{
PMDIINFO pMDI = GETMDIINFO(hwnd);

    if (!pMDI)
        return;

    // Invalidate object info; reset scroll position to 0.
    // cyScrollLast = cxScrollLast = -1;
    pMDI->cyScrollLast = -1L;
    pMDI->cyScrollNow = 0L;
    pMDI->cxScrollLast = -1;
    pMDI->cxScrollNow = 0;

    // Range is set in case CF_OWNERDISPLAY owner changed it.
    PINFO(TEXT("SETSCROLLRANGE for window '%s'\n\r"),
          (LPTSTR)(pMDI->szBaseName) );

    SetScrollRange (pMDI->hwndVscroll, SB_CTL, 0, VPOSLAST, FALSE);
    SetScrollRange (pMDI->hwndHscroll, SB_CTL, 0, HPOSLAST, FALSE);
    SetScrollPos   (pMDI->hwndVscroll, SB_CTL, (int)(pMDI->cyScrollNow), TRUE);
    SetScrollPos   (pMDI->hwndHscroll, SB_CTL, pMDI->cxScrollNow,        TRUE);
}









// IsShared ///////////////////////////////////
//
// this function sets the shared state of the ownerdraw
// listbox entry denoted by the supplied pointer. Shared/nonshared
// status is expressed as a 1 character prefix to the description string
//
// return TRUE if shared, false otherwise

BOOL IsShared(
    LPLISTENTRY lpLE)
{
    if (!lpLE)
        return FALSE;

    if ( lpLE->name[0] == SHR_CHAR )
       return TRUE;

    #if DEBUG
        if ( lpLE->name[0] != UNSHR_CHAR )
            PERROR(TEXT("bad prefix char in share name: %s\n\r"),
                   (LPTSTR)lpLE->name );
    #endif

    return FALSE;
}








// SetShared //////////////////////////////////////////
//
// sets shared state to fShared, returns previous state

BOOL SetShared(
    LPLISTENTRY lpLE,
    BOOL        fShared)
{
BOOL fSave;

    fSave = lpLE->name[0] == SHR_CHAR ? TRUE : FALSE;
    lpLE->name[0] = ( fShared ? SHR_CHAR : UNSHR_CHAR );

    return fSave;
}









// LockApp ////////////////////////////////////////////
//
// this function effectively disables the windows UI during
// synchronous ddeml transactions to prevent the user from initiating
// another transaction or causing the window procedure of this app
// or another application to be re-entered in a way that could cause
// failures... A primary example is that sometimes we are forced to
// go into a ddeml transaction with the clipboard open...  this app
// and other apps must not be caused to access the clipboard during that
// time, so this mechanism emulates the hourglass...
//
// NOTE: do not call LockApp in a section of code where the
// cursor is already captured, such as in response to a scroll
// message, or the releasecapture during unlock will cause strange and
// bad things to happen.


BOOL LockApp(
    BOOL    fLock,
    LPTSTR  lpszComment)
{
static HCURSOR  hOldCursor;
BOOL            fOK = FALSE;


    if (lpszComment)
        {
        SetStatusBarText( lpszComment );
        }

    if ( fLock == TRUE )
        {
        if ( fAppLockedState )
            {
            PERROR(TEXT("LockApp(TRUE): already locked\n\r"));
            }
        else
            {
            hOldCursor = SetCursor ( LoadCursor ( NULL, IDC_WAIT ));

            SetCapture ( hwndDummy );
            EnableWindow ( hwndApp, FALSE );

            fOK = TRUE;
            fAppLockedState = TRUE;
            }
        }
    else
        {
        if ( !fAppLockedState )
            {
            PERROR(TEXT("LockApp(FALSE): not locked\n\r"));
            }
        else
            {

            ClearInput (hwndApp);

            EnableWindow ( hwndApp, TRUE );
            ReleaseCapture ();

            SetCursor ( hOldCursor );

            fOK = TRUE;

            // take care of any deferred clipboard update requests
            if ( fClipboardNeedsPainting )
                {
                PostMessage ( hwndApp, WM_DRAWCLIPBOARD, 0, 0L );
                }

            fAppLockedState = FALSE;
            }
        }

    return fOK;

}








// ForceRenderAll ///////////////////////////////////
//
// this function forces a complete rendering of any delayed
// render clipboard formats
BOOL ForceRenderAll(
    HWND        hwnd,
    PVCLPBRD    pVclp)
{
HANDLE  h;
UINT    uiFmt;

    if ( !VOpenClipboard ( pVclp, hwnd ))
        {
        PERROR(TEXT("Can't open clipboard in ForceRenderAll\n\r"));
        return FALSE;
        }


    for ( uiFmt = VEnumClipboardFormats( pVclp, 0); uiFmt;
          uiFmt = VEnumClipboardFormats( pVclp, uiFmt))
        {
        PINFO(TEXT("ForceRenderAll: force rendering %x\n\r"), uiFmt );
        h = VGetClipboardData ( pVclp, uiFmt );
        }

    VCloseClipboard ( pVclp );
    return TRUE;
}










BOOL UpdateNofMStatus(
    HWND    hwnd)
{
HWND    hwndlistbox;
int     total = 0;
int     sel = LB_ERR;



    if (hwnd == NULL)
        {
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)NULL );
        return TRUE;
        }


    if (!GETMDIINFO(hwnd))
        return FALSE;


    if (GETMDIINFO(hwnd)->flags & F_CLPBRD)
        {
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPTSTR) szSysClpBrd );
        return TRUE;
        }

    if ( IsWindow( hwndlistbox = GETMDIINFO(hwnd)->hWndListbox ) )
        {
        total = (int)SendMessage ( hwndlistbox, LB_GETCOUNT, (WPARAM)0, 0L );
        sel = (int)SendMessage ( hwndlistbox, LB_GETCURSEL, 0, 0L);
        }

    if ( sel == (int)LB_ERR )
        {
        if ( total == 1 )
            SendMessage (hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szPageFmt);
        else
            {
            wsprintf( szBuf, szPageFmtPl, total );
            SendMessage (hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szBuf );
            }
        }
    else
        {
        wsprintf(szBuf, szPageOfPageFmt, sel+1, total );
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szBuf );
        }


    return TRUE;

}








BOOL RestoreAllSavedConnections(void)
{
TCHAR       szName[80];
BOOL        ret = TRUE;
unsigned    i;

    i = lstrlen(szConn);

    if (NULL != hkeyRoot)
        {
        DWORD dwSize = 80;
        DWORD iSubkey = 0;

        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, iSubkey,
                    szName, &dwSize, NULL, NULL, NULL, NULL) )
            {
            if (0 == memcmp(szName, szConn, i))
                {
                PINFO(TEXT("Restoring connection to '%s'\n\r"), szName + i);

                if ( !CreateNewRemoteWindow ( szName + i, FALSE ) )
                    {
                    TCHAR szWindowName[80];

                    // remove re-connect entry
                    RegDeleteKey(hkeyRoot, szName);

                    lstrcat(lstrcpy(szWindowName, szWindows),
                          szName + i);
                    RegDeleteKey(hkeyRoot, szWindowName);
                    ret = 0;
                    }
                }

            dwSize = 80;
            iSubkey++;
            }
        }

    return ret;

}








BOOL CreateNewRemoteWindow(
    LPTSTR  szMachineName,
    BOOL    fReconnect)
{
WINDOWPLACEMENT wpl;
HWND            hwndc;
PMDIINFO        pMDIc;




    // make new window active
    hwndc = NewWindow();
    if (NULL == hwndc)
       {
       return FALSE;
       }


    if (!(pMDIc = GETMDIINFO(hwndc)))
        return FALSE;


    // save base name for window
    lstrcpy (pMDIc->szBaseName, szMachineName);
    lstrcpy (pMDIc->szComputerName, szMachineName);

    wsprintf ( szBuf, TEXT("%s\\%s"), (LPTSTR)szMachineName, (LPTSTR)szNDDEcode);

    pMDIc->hszConvPartner = DdeCreateStringHandle ( idInst, szBuf, 0 );

    PINFO(TEXT("Trying to talk to %s\r\n"),szBuf);

    wsprintf ( szBuf, TEXT("%s\\%s"), (LPTSTR)szMachineName, (LPTSTR)szNDDEcode1 );
    pMDIc->hszConvPartnerNP = DdeCreateStringHandle ( idInst, szBuf, 0 );

    PINFO(TEXT("NP = %s\r\n"),szBuf);

    #if DEBUG
    DdeQueryString(idInst, hszSystem, szBuf, 128, CP_WINANSI);
    PINFO(TEXT("Topic = %s\r\n"), szBuf);

    PINFO(TEXT("Existing err = %lx\r\n"), DdeGetLastError(idInst));
    #endif

    pMDIc->hExeConv = InitSysConv (hwndc, pMDIc->hszConvPartner, hszClpBookShare, FALSE);



    if ( pMDIc->hExeConv )
       {
       if ( UpdateListBox ( hwndc, pMDIc->hExeConv ))
          {
          wsprintf(szBuf, szClipBookOnFmt, (LPTSTR)(pMDIc->szBaseName) );
          SetWindowText ( hwndc, szBuf );

          if ( ReadWindowPlacement ( pMDIc->szBaseName, &wpl ))
             {
             wpl.length = sizeof(WINDOWPLACEMENT);
             wpl.flags = WPF_SETMINPOSITION;
             SetWindowPlacement ( hwndc, &wpl );
             UpdateWindow ( hwndc );
             }
          else
             {
             ShowWindow ( hwndc, SW_SHOWNORMAL );
             }

          ShowWindow ( pMDIc->hWndListbox, SW_SHOW );
          SendMessage ( hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndc, 0L );
          SendMessage ( hwndMDIClient, WM_MDISETMENU, (WPARAM) TRUE, 0L );

          hwndActiveChild = hwndc;
          pActiveMDI = GETMDIINFO(hwndc);

          if ( fReconnect )
             {
             TCHAR szName[80];
             DWORD dwData;

             lstrcat(lstrcpy(szName, szConn), szBuf);

             dwData = pMDIc->DisplayMode == DSP_LIST ? 1 : 2;

             RegSetValueEx(hkeyRoot, szName, 0L, REG_DWORD,
                   (LPBYTE)&dwData, sizeof(dwData));

             PINFO(TEXT("saving connection: '%s'\n\r"), (LPTSTR)szBuf );
             }
          else
             {
             TCHAR szName[80];
             DWORD dwData;
             DWORD dwDataSize = sizeof(dwData);

             lstrcat(lstrcpy(szName, szConn), pMDIc->szBaseName);

             RegQueryValueEx(hkeyRoot, szName, NULL, NULL,
                   (LPBYTE)&dwData, &dwDataSize);

             if (2 == dwData)
                {
                SendMessage ( hwndApp, WM_COMMAND, IDM_PREVIEWS, 0L );
                }
             }

          return TRUE;
          }
       else
          {
          PERROR(TEXT("UpdateListBox failed\n\r"));
          return FALSE;
          }
       }
    else
       {
       unsigned uiErr;

       #if DEBUG
       DdeQueryString(idInst, pMDIc->hszConvPartner, szBuf, 128, CP_WINANSI);
       #endif

       uiErr = DdeGetLastError(idInst);
       PERROR(TEXT("Can't find %s|System. Error #%x\n\r"),(LPTSTR)szBuf, uiErr );
       }


    return FALSE;
}







#define MB_SNDMASK (MB_ICONHAND|MB_ICONQUESTION|MB_ICONASTERISK|MB_ICONEXCLAMATION)

/*
 *      MessageBoxID
 *
 *  Display a message box with strings specified by
 *  TextID and TitleID.
 */

int MessageBoxID(
    HANDLE  hInstance,
    HWND    hwndParent,
    UINT    TextID,
    UINT    TitleID,
    UINT    fuStyle)
{
    LoadString (hInstance, TextID,  szBuf,  SZBUFSIZ);
    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwndParent, szBuf, szBuf2, fuStyle);
}






/*
 *      NDdeMessageBox
 *
 *  Display a message box with NDde error
 *  string specified by errCode and title
 *  string specified by TitleID.
 */

int NDdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle)
{
    if (!errCode)
        return IDOK;

    NDdeGetErrorString (errCode, szBuf, SZBUFSIZ);
    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwnd, szBuf, szBuf2, fuStyle);

}






/*
 *      SysMessageBox
 *
 *  Display a messag box for system message
 *  strings specified by dwErr and titl string
 *  specified by TitleID.
 */

int SysMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    DWORD   dwErr,
    UINT    TitleID,
    UINT    fuStyle)
{
DWORD   dwR;
LPTSTR  lpBuffer = NULL;
DWORD   dwSize = 20;

    if (dwErr == NO_ERROR)
        return IDOK;

    dwR = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER|
                         FORMAT_MESSAGE_FROM_SYSTEM,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)&lpBuffer, // dual use param. does not match prototype
                         dwSize,
                         NULL);
    if (0 < dwR)
    {
        LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

        MessageBeep (fuStyle & MB_SNDMASK);
        dwR = MessageBox (hwnd, lpBuffer, szBuf2, fuStyle);

        LocalFree (lpBuffer);
    }

    return dwR;
}






/*
 *      XactMessageBox
 *
 *  Display a message box for error
 *  occured in an transaction.  MySyncXact
 *  must be called to do the transaction
 *  before calling this function.
 */

int XactMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    TitleID,
    UINT    fuStyle)
{

    switch (gXERR_Type)
        {
        case XERRT_NDDE:
            return NDdeMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        case XERRT_DDE:
            return DdeMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        case XERRT_SYS:
            return SysMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        default:
            return IDOK;
        }
}






/*
 *      DdeNessageBox
 *
 *  Displays a message box for DDE
 *  error strings specified by errCode
 *  and title string spcified by TitleID.
 */

int DdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle)
{
TCHAR szErr[1024];


    switch (errCode)
        {
        case DMLERR_ADVACKTIMEOUT:
        case DMLERR_DATAACKTIMEOUT:
        case DMLERR_EXECACKTIMEOUT:
        case DMLERR_POKEACKTIMEOUT:
        case DMLERR_UNADVACKTIMEOUT:
        case DMLERR_NO_CONV_ESTABLISHED:
            if (hwnd == hwndLocal)
                LoadString (hInstance, IDS_NOCLPBOOK, szBuf, SZBUFSIZ);
            else
                LoadString (hInstance, IDS_DATAUNAVAIL, szBuf, SZBUFSIZ);
            break;

        case DMLERR_NOTPROCESSED:
        case DMLERR_BUSY:
        case DMLERR_DLL_NOT_INITIALIZED:
        case DMLERR_DLL_USAGE:
        case DMLERR_INVALIDPARAMETER:
        case DMLERR_LOW_MEMORY:
        case DMLERR_MEMORY_ERROR:
        case DMLERR_POSTMSG_FAILED:
        case DMLERR_REENTRANCY:
        case DMLERR_SERVER_DIED:
        case DMLERR_SYS_ERROR:
        case DMLERR_UNFOUND_QUEUE_ID:
            LoadString (hInstance, IDS_INTERNALERR, szBuf, SZBUFSIZ);
            break;
        default:
            return IDOK;
        }

    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    wsprintf (szErr, "%s (%#x)", szBuf, errCode);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwnd, szErr, szBuf2, fuStyle);

}







/*
 *      ClearInput
 *
 *  Removes all keyboard and mouse messages
 *  from message queue
 */

void    ClearInput (HWND    hWnd)
{
MSG Msg;

    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST,   WM_KEYLAST,   PM_REMOVE));
}






PDATAREQ CreateNewDataReq (void)
{
    return (PDATAREQ) GlobalAlloc (GPTR, sizeof(DATAREQ));
}






BOOL DeleteDataReq(
    PDATAREQ    pDataReq)
{
    return ((HGLOBAL)pDataReq == GlobalFree (pDataReq));
}






//
// Purpose: Handle data returned from CLIPSRV via DDE.
//
// Parameters:
//    hData - The data handle the XTYP_XACT_COMPLETE message gave us,
//            or 0L if we got XTYP_DISCONNECT instead.
//
//    pDataReq - Pointer to a DATAREQ struct containing info about what
//               we wanted the data for. This is gotten via DdeGetUserHandle.
//
// Returns:
//    TRUE on success, FALSE on failure.
//
//////////////////////////////////////////////////////////////////////////

BOOL ProcessDataReq(
    HDDEDATA    hData,
    PDATAREQ    pDataReq)
{
LPLISTENTRY lpLE;
LPSTR       lpwszList;
LPSTR       q;
HCURSOR     hSaveCursor;
DWORD       cbDataLen;
UINT        tmp;
PMDIINFO    pMDI;
UINT        uiErr;
BOOL        bRet = FALSE;



    hSaveCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));



    PINFO("PDR:");

    if ( !pDataReq || !IsWindow(pDataReq->hwndMDI) )
        {
        PERROR(TEXT("ProcessDataReq: bogus DATAREQ\n\r"));
        goto done;
        }


    if (!hData)
        {
        PERROR("ProcessDataReq: Woe, woe, we have gotten null data!\r\n");
        DumpDataReq(pDataReq);


        switch (pDataReq->rqType)
            {
            case RQ_COPY:
                MessageBoxID (hInst, hwndApp, IDS_DATAUNAVAIL, IDS_APPNAME,
                              MB_OK | MB_ICONHAND);
                break;
            case RQ_PREVBITMAP:
                // We still have to display the lock icon.
                SetBitmapToListboxEntry (hData, pDataReq->hwndList, pDataReq->iListbox);
                break;
            }

        goto done;;
        }




    if (!(pMDI = GETMDIINFO(pDataReq->hwndMDI)))
        goto done;






    switch ( pDataReq->rqType )
        {
        case RQ_PREVBITMAP:
           PINFO("Got bitmap for item %d in %x\r\n",pDataReq->iListbox,
                 pDataReq->hwndList);
           SetBitmapToListboxEntry( hData, pDataReq->hwndList, pDataReq->iListbox);
           InitializeMenu (GetMenu (hwndApp));
           bRet = TRUE;
           break;

        case RQ_EXECONV:
           // must be from disconnect
           GETMDIINFO(pDataReq->hwndMDI)->hExeConv = 0L;
           PINFO(TEXT("setting hExeConv NULL!\n\r"));
           break;

        case RQ_COPY:
           PINFO("RQ_COPY:");
           if ( hData == FALSE )
              {
              uiErr = DdeGetLastError (idInst);
              PERROR(TEXT("REQUEST for format list failed: %x\n\r"), uiErr);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           lpwszList = DdeAccessData ( hData, &cbDataLen );

           if ( !lpwszList )
              {
              uiErr = DdeGetLastError (idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           PINFO(TEXT("formatlist:>%ws<\n\r"), lpwszList );
           // this client now becomes the clipboard owner!!!

           if (SyncOpenClipboard (hwndApp) == TRUE)
              {
              BOOL  bHasBitmap = FALSE;
              BOOL  bLocked;

              // Need to lock app while we fill the clipboard with formats,
              // else hwndClpbrd will try to frantically try to redraw while
              // we're doing it. Since hwndClpbrd needs to openclipboard() to
              // do that, we don't want it to.
              bLocked = LockApp(TRUE, szNull);

              // reset clipboard view format to auto
              pMDI->CurSelFormat = CBM_AUTO;

              EmptyClipboard();

              hwndClpOwner = pDataReq->hwndMDI;
              PINFO(TEXT("Formats:"));

              if (pDataReq->wFmt != CF_TEXT)
                 {
                 PERROR(TEXT("Format %d, expected CF_TEXT!\r\n"), pDataReq->wFmt);
                 }


              for (q = strtokA(lpwszList, "\t");q;q = strtokA(NULL, "\t"))
                 {
                 PINFO(TEXT("[%s] "),q);
                 tmp = MyGetFormat(q, GETFORMAT_DONTLIE);
                 if (0 == tmp)
                    {
                    PERROR(TEXT("MyGetFormat failure!\r\n"));
                    }
                 else
                    {
                    switch (tmp)
                        {
                        case CF_DIB:
                            // DDBitmap can be converted from Dib.
                            SetClipboardData (CF_BITMAP, NULL);
                        default:
                            SetClipboardData (tmp, NULL);
                        }
                    }
                 }

              PINFO("\r\n");

              SyncCloseClipboard();

              if (bLocked)
                 LockApp (FALSE, szNull);


              // Redraw clipboard window.
              if (hwndClpbrd)
                 {
                 InvalidateRect(hwndClpbrd, NULL, TRUE);
                 }
              }
           else
              {
              PERROR(TEXT("ProcessDataReq: unable to open clipboard\n\r"));
              }

           DdeUnaccessData ( hData );
           DdeFreeDataHandle ( hData );
           bRet = TRUE;
           break;

        case RQ_SETPAGE:
           PINFO(TEXT("RQ_SETPAGE:"));

           if ( hData == FALSE )
              {
              uiErr = DdeGetLastError (idInst);
              PERROR(TEXT("vclip: REQUEST for format list failed: %x\n\r"), idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, idInst, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           if ( SendMessage ( pMDI->hWndListbox,
                 LB_GETTEXT, pDataReq->iListbox,
                 (LPARAM)(LPCSTR)&lpLE) == LB_ERR )
              {
              PERROR(TEXT("IDM_COPY: bad listbox index: %d\n\r"), pDataReq->iListbox );
              break;
              }

           lpwszList = DdeAccessData ( hData, &cbDataLen );

           if ( !lpwszList )
              {
              uiErr = DdeGetLastError (idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION );
              break;
              }

           if ( VOpenClipboard ( pMDI->pVClpbrd, pDataReq->hwndMDI ) == TRUE )
              {
              BOOL  bHasBitmap = FALSE;

              VEmptyClipboard( pMDI->pVClpbrd );

              for (q = strtokA(lpwszList, "\t");q;q = strtokA(NULL,"\t"))
                 {
                 tmp = MyGetFormat(q, GETFORMAT_DONTLIE);

                 switch (tmp)
                     {
                     case CF_DIB:
                         // DDBitmap can be converted from Dib.
                         VSetClipboardData (pMDI->pVClpbrd, CF_BITMAP, NULL);
                     default:
                         VSetClipboardData (pMDI->pVClpbrd, tmp, NULL);
                     }
                 }

              VCloseClipboard( pMDI->pVClpbrd );
              }
           else
              {
              PERROR(TEXT("ProcessDataReq: unable to open Vclipboard\n\r"));
              }

           DdeUnaccessData ( hData );
           DdeFreeDataHandle ( hData );

           // set proper window text
           if ( pMDI->flags & F_LOCAL )
              {
              wsprintf( szBuf, TEXT("%s - %s"), szLocalClpBk, &(lpLE->name[1]) );
              }
           else
              {
              wsprintf( szBuf, TEXT("%s - %s"),
                    (pMDI->szBaseName), &(lpLE->name[1]) );
              }
           SetWindowText ( pDataReq->hwndMDI, szBuf );

           SetFocus ( pDataReq->hwndMDI );
           pMDI->CurSelFormat = CBM_AUTO;
           pMDI->fDisplayFormatChanged = TRUE;
           ResetScrollInfo ( pDataReq->hwndMDI );

           // means data is for going into page mode
           if ( pMDI->DisplayMode != DSP_PAGE )
              {
              pMDI->OldDisplayMode = pMDI->DisplayMode;
              pMDI->DisplayMode = DSP_PAGE;
              AdjustControlSizes ( pDataReq->hwndMDI );
              ShowHideControls ( pDataReq->hwndMDI );
              InitializeMenu ( GetMenu(hwndApp) );
              }
           else // data is for scrolling up or down one page
              {
              SendMessage ( pMDI->hWndListbox, LB_SETCURSEL,
                 pDataReq->iListbox, 0L );
              }

           UpdateNofMStatus ( pDataReq->hwndMDI );
           InvalidateRect ( pDataReq->hwndMDI, NULL, TRUE );

           // refresh preview bitmap?
           if ( !lpLE->hbmp )
              {
              GetPreviewBitmap ( pDataReq->hwndMDI, lpLE->name,
                 pDataReq->iListbox );
              }

           // PINFO("\r\n");
           bRet = TRUE;
           break;

        default:
           PERROR (TEXT("unknown type %d in ProcessDataReq\n\r"),
                 pDataReq->rqType );
           break;
        }



done:

    SetCursor (hSaveCursor);

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\dde.c ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991,1992                    **/
/***************************************************************************/
// ts=4

// DDE.C - ClipBook viewer DDEML callback function
// 4-92 clausgi created


#include "windows.h"
#include "clipbook.h"
#include "common.h"

// internal forwards

static HWND GetConvHwnd ( HCONV hConv );

// ddeml callback routine

HDDEDATA EXPENTRY DdeCallback(
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
HDDEDATA hData,
DWORD lData1,
DWORD lData2)
{
HWND hwndTmp;
CONVINFO ConvInfo;
PDATAREQ pDataReq;

switch (wType)
   {
case XTYP_ADVDATA:
   if ( hwndTmp = GetConvHwnd ( hConv ) )
      {
      InitListBox ( hwndTmp, hData );
      }
   return FALSE;
   break;

case XTYP_DISCONNECT:
   ConvInfo.cb = sizeof(CONVINFO);
   if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
      {
      PERROR(TEXT("DdeQueryConvInfo for %lx failed: %x\n\r"),
         (DWORD)hConv, DdeGetLastError(idInst));
      break;
      }
   if ( pDataReq = (PDATAREQ)ConvInfo.hUser )
      {
      PINFO(TEXT("Freeing data req on %lx at disconnect time\n\r"), hConv );
      ProcessDataReq ( 0, pDataReq );
      DeleteDataReq ( pDataReq );
      DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, 0L );
      }
   else
      {
      PINFO(TEXT("Disconnect received on %lx - no datareq\n\r"), hConv );
      }
   break;

case XTYP_XACT_COMPLETE:
   ConvInfo.cb = sizeof(CONVINFO);
   if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
      {
      PERROR(TEXT("DdeQueryConvInfo for %lx failed: %x\n\r"),
         (DWORD)hConv, DdeGetLastError(idInst));
      break;
      }

   PINFO(TEXT("dde callback: got %lx data from conv handle %lx\n\r"),
      ConvInfo.hUser, (DWORD)hConv );

   pDataReq = (PDATAREQ)ConvInfo.hUser;

   ProcessDataReq ( hData,  pDataReq );
   DeleteDataReq ( pDataReq );
   if ( pDataReq->fDisconnect )
      {
      DdeDisconnect ( hConv );
      }
   DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, 0L );
   break;

case XTYP_REGISTER:
case XTYP_UNREGISTER:
case XTYP_ADVREQ:
case XTYP_REQUEST:
case XTYP_ADVSTART:
case XTYP_CONNECT_CONFIRM:
case XTYP_CONNECT:
default:
   break;
 }
return 0;
}

// this function retrieves the window handle associated with
// a conversation handle - the hande is put there by
// using DdeSetUserHandle at DdeConnect time

static HWND GetConvHwnd ( HCONV hConv )
{
   CONVINFO ConvInfo;
   PDATAREQ pDataReq;

   ConvInfo.cb = sizeof(CONVINFO);
   if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
      {
      PERROR(TEXT("DdeQueryConvInfo for %lx failed: %x\n\r"),
         (DWORD)hConv, DdeGetLastError(idInst));
      }

   pDataReq = (PDATAREQ)ConvInfo.hUser;

   PINFO(TEXT("GetConvHwnd: got %p as conv handle\r\n"), pDataReq);

   if ( !IsWindow ( pDataReq->hwndMDI ) )
      {
      PERROR(TEXT("Invalid window %lx in conv Uhandle: %lx!\n\r"),
         (DWORD)pDataReq->hwndMDI, (DWORD)hConv );
      return NULL;
      }
   return pDataReq->hwndMDI;
}

//
// Purpose: Get the version of Clipsrv connected to the given MDI
//    child.
//
// Parameters:
//    hwndChild - The child window.
//
// Returns:
//    A version number with the Clipsrv OS version in the hiword, and
//    the Clipsrv version in the loword.
//
//    Hiword values:
//       0 - Win 3.x
//       1 - NT 1.x
//
//    Loword values:
//       0 - WFW 1.0 Clipsrv
//       1 - NT  1.0 Clipsrv, adds [version] and [security] executes
//
/////////////////////////////////////////////////////////////////////
DWORD GetClipsrvVersion(
HWND hwndChild)
{
MDIINFO *pMDI;
HDDEDATA hdde;
DWORD    dwRet;
char    *lpszDDE;

dwRet = 0;
pMDI = GETMDIINFO(hwndChild);

if (pMDI && !(pMDI->flags & F_CLPBRD))
   {
   hdde = MySyncXact(SZCMD_VERSION, lstrlen(SZCMD_VERSION) + 1,
         pMDI->hExeConv, 0L, CF_TEXT, XTYP_EXECUTE,
         SHORT_SYNC_TIMEOUT, NULL);

   if (hdde)
      {
      lpszDDE = (char *)DdeAccessData(hdde, &dwRet);

      if (lpszDDE)
         {
         dwRet = MAKELONG(lpszDDE[0] - '0', lpszDDE[2] - '0');
         }
      else
         {
         dwRet = 0L;
         }

      DdeUnaccessData(hdde);
      DdeFreeDataHandle(hdde);
      }
   else
      {
      PINFO(TEXT("Clipsrv didn't like version execute\r\n"));
      }
   }
else
   {
   PERROR(TEXT("No Clipsrv for clipboard!\r\n"));
   }

return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\debug.h ===
/*****************************************************************************

                        D E B U G   H E A D E R

    Name:       debug.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for the debug.c

*****************************************************************************/




LRESULT EditPermissions(
    BOOL    fSacl);


DWORD CALLBACK SedCallback(
    HWND                 hwndParent,
    HANDLE               hInstance,
    ULONG                penvstr,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN              ApplyToSubContainers,
    BOOLEAN              ApplyToSubObjects,
    LPDWORD              StatusReturn);


LRESULT EditOwner(void);


LRESULT OnIDMKeep (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\dialogs.c ===
/*****************************************************************************

                                D I A L O G S

    Name:       dialogs.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        Dialog handling routines.

    History:
        13-Mar-1995 John Fu     allow KeepAsDlgProc to "Paste to Page"

        03-Nov-1997 Drewm       Added support for context sensitive help

*****************************************************************************/



#include <windows.h>
#include <nddeapi.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clpbkdlg.h"
#include "cvutil.h"
#include "dialogs.h"
#include "helpids.h"
#include "debugout.h"
#include "ismember.h"
#include "shares.h"



#define      PERM_READ  (NDDEACCESS_REQUEST|NDDEACCESS_ADVISE)
#define      PERM_WRITE (NDDEACCESS_REQUEST|NDDEACCESS_ADVISE|NDDEACCESS_POKE|NDDEACCESS_EXECUTE)





static BOOL    IsUniqueName (PKEEPASDLG_PARAM key);
static BOOL    StrHas2BkSlash (LPTSTR  str);




/*
 *      ConnectDlgProc
 */

INT_PTR CALLBACK ConnectDlgProc (
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{

    switch (message)
        {
        case WM_INITDIALOG:
            szConvPartner[0] = '\0';
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDOK:
                    GetDlgItemText (hwnd, IDC_CONNECTNAME, szConvPartner, 32);
                    EndDialog (hwnd, 1);
                    break;

                case IDCANCEL:
                    szConvPartner[0] = '\0';
                    EndDialog (hwnd, 0);
                    break;

                default:
                    return FALSE;
                }
            break;

        default:
            return FALSE;
        }

    return TRUE;

}






/*
 *      ShareDlgProc
 *
 *  Note: this routine expectes a PNDDESHAREINFO in lParam!
 */

INT_PTR CALLBACK ShareDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
static PNDDESHAREINFO   lpDdeS;
DWORD                   dwTrustOptions;
DWORD                   adwTrust[3];

BOOL                    bRet = TRUE;

// These vars are used for determining if I'm owner of the page
PSID                    psidPage;
BOOL                    fDump;
DWORD                   cbSD;
UINT                    uRet;
PSECURITY_DESCRIPTOR    pSD = NULL;

LPHELPINFO              lphi;
const DWORD aHelpIDs[] =
{
    IDC_STARTAPP, IDH_STARTAPP,
    IDC_MINIMIZED, IDH_MINIMIZED,
    IDC_PERMISSIONS, IDH_PERMISSIONS,
    0, 0
};
UINT    iCtrlId;



    switch (message)
        {
        case WM_INITDIALOG:

            lpDdeS = (PNDDESHAREINFO)lParam;

            // set share, always static
            SetDlgItemText (hwnd, IDC_STATICSHARENAME, lpDdeS->lpszShareName+1 );

            // If the current user doesn't own the page, we gray out the
            // "start app" and "run minimized" checkboxes.. basically, people
            // who aren't the owner don't get to trust the share.
            EnableWindow(GetDlgItem(hwnd, IDC_STARTAPP), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_MINIMIZED), FALSE);
            EnableWindow(GetDlgItem(hwnd, 207), FALSE);



            // Figure out who owns the page
            psidPage = NULL;
            if (!(pSD = LocalAlloc(LPTR, 50)))
                {
                PERROR(TEXT("Couldn't alloc 50 bytes\r\n"));
                break;
                }


            uRet = NDdeGetShareSecurity (NULL,
                                         lpDdeS->lpszShareName,
                                         OWNER_SECURITY_INFORMATION,
                                         pSD,
                                         50,
                                         &cbSD);

            if (uRet == NDDE_BUF_TOO_SMALL)
                {
                LocalFree (pSD);

                if (!(pSD = LocalAlloc(LPTR, cbSD)))
                   {
                   PERROR(TEXT("Couldn't alloc %ld bytes\r\n"), cbSD);
                   break;
                   }


                uRet = NDdeGetShareSecurity (NULL,
                                             lpDdeS->lpszShareName,
                                             OWNER_SECURITY_INFORMATION,
                                             pSD,
                                             cbSD,
                                             &cbSD);
                }


            if (NDDE_NO_ERROR != uRet)
                {
                PERROR(TEXT("GetSec fail %d"), uRet);
                break;
                }


            if (!GetSecurityDescriptorOwner(pSD, &psidPage, &fDump))
                {
                PERROR(TEXT("Couldn't get owner, even tho we asked\r\n"));
                break;
                }

            if (!psidPage || !IsUserMember(psidPage))
                {
                PINFO(TEXT("User isn't member of owner\r\n"));
                break;
                }



            EnableWindow (GetDlgItem (hwnd, IDC_STARTAPP), TRUE);

            // 207 is the group box around the checkboxes
            EnableWindow (GetDlgItem (hwnd, 207), TRUE);

            NDdeGetTrustedShare (NULL,
                                 lpDdeS->lpszShareName,
                                 adwTrust,
                                 adwTrust + 1,
                                 adwTrust + 2);

            if (!(adwTrust[0] & NDDE_TRUST_SHARE_START))
                {
                PINFO (TEXT("Buttons shouldn't check\r\n"));
                }
            else
                {
                CheckDlgButton(hwnd, IDC_STARTAPP, 1);

                EnableWindow (GetDlgItem (hwnd, IDC_MINIMIZED), TRUE);
                CheckDlgButton (hwnd,
                                IDC_MINIMIZED,
                                (SW_MINIMIZE == (adwTrust[0] & NDDE_CMD_SHOW_MASK)) ? 1 : 0);
               }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                   dwTrustOptions = NDDE_TRUST_SHARE_INIT;

                   if (IsDlgButtonChecked(hwnd, IDC_STARTAPP))
                      {
                      dwTrustOptions |= NDDE_TRUST_SHARE_START;

                      if (IsDlgButtonChecked(hwnd, IDC_MINIMIZED))
                         {
                         dwTrustOptions |= NDDE_TRUST_CMD_SHOW | SW_MINIMIZE;
                         }
                      }

                   // Update the share start flag.
                   if (dwTrustOptions & NDDE_TRUST_SHARE_START)
                       lpDdeS->fStartAppFlag = TRUE;
                   else
                       lpDdeS->fStartAppFlag = FALSE;

                   NDdeSetTrustedShare(NULL, lpDdeS->lpszShareName, dwTrustOptions);
                   EndDialog (hwnd, TRUE);
                   break;

                case IDCANCEL:
                   EndDialog (hwnd, FALSE);
                   break;

                case IDC_PERMISSIONS:
                   EditPermissions2 (hwnd, lpDdeS->lpszShareName, FALSE);
                   break;

                case  IDC_STARTAPP:
                   EnableWindow(GetDlgItem(hwnd, IDC_MINIMIZED),
                         IsDlgButtonChecked(hwnd, IDC_STARTAPP));
                   break;

                default:
                   bRet = FALSE;
                }
            break;

        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                if ((lphi->iCtrlId == IDC_STARTAPP) ||
                    (lphi->iCtrlId == IDC_MINIMIZED) ||
                    (lphi->iCtrlId == IDC_PERMISSIONS) ||
                    (lphi->iCtrlId == IDOK) ||
                    (lphi->iCtrlId == IDCANCEL) )
                {
                WinHelp ( lphi->hItemHandle,
                          szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR) (LPVOID) aHelpIDs);
                }
            }
            else
            {
                bRet = FALSE;
            }
            break;

        case WM_CONTEXTMENU:
            iCtrlId = GetDlgCtrlID( (HWND) wParam );
            if ((iCtrlId == IDC_STATICSHARENAME) ||
                (iCtrlId == IDC_STARTAPP) ||
                (iCtrlId == IDC_MINIMIZED) ||
                (iCtrlId == IDC_PERMISSIONS) ||
                (iCtrlId == IDOK) ||
                (iCtrlId == IDCANCEL) )
            {
                WinHelp( (HWND) wParam,
                         szHelpFile,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR) (LPVOID) aHelpIDs);
            }
            break;
        //

        default:
        bRet = FALSE;
        }



    if (pSD)
        LocalFree (pSD);

    return bRet;

}










/*
 *      IsUniqueName
 *
 *  Check to see if the name is unique
 */

static BOOL IsUniqueName (PKEEPASDLG_PARAM pParam)
{
PMDIINFO    pMDI;
LISTENTRY   ListEntry;
PLISTENTRY  pLE;
INT         i;


    if (!(pMDI = GETMDIINFO(hwndLocal)))
        return FALSE;


    lstrcpy (ListEntry.name, pParam->ShareName);

    i = (INT)SendMessage (pMDI->hWndListbox,
                          LB_FINDSTRING,
                          (WPARAM)-1,
                          (LPARAM)(LPCSTR) &ListEntry);


    if (LB_ERR != i)
        {
        SendMessage (pMDI->hWndListbox,
                     LB_GETTEXT,
                     i,
                     (LPARAM)&pLE);

        pParam->bAlreadyShared = IsShared (pLE);

        return FALSE;
        }

    return TRUE;

}







/*
 *      StrHas2BkSlash
 *
 *  Check to see if the string has
 *  double back slashes.  If double
 *  back slashes exists then return
 *  TRUE else return FALSE.
 */

static BOOL    StrHas2BkSlash (LPTSTR  str)
{
TCHAR   c;

    while (c = *str++)
        {
        if (c == TEXT('\\') && *str == TEXT('\\'))
            return TRUE;
        }

    return FALSE;

}






/*
 *      KeepAsDlgProc
 *
 *  Ask the user for a page name.
 */

INT_PTR CALLBACK KeepAsDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
static PKEEPASDLG_PARAM pParam;

LPHELPINFO              lphi;
const DWORD aHelpIDs[] =
{
    IDC_STATICPAGENAME, IDH_KEEPASEDIT,
    IDC_KEEPASEDIT, IDH_KEEPASEDIT,
    IDC_SHARECHECKBOX, IDH_SHARECHECKBOX,
    0, 0
};



    switch (msg)
        {
        case WM_INITDIALOG:
            pParam = (PKEEPASDLG_PARAM)lParam;

            pParam->bAlreadyExist  = FALSE;
            pParam->bAlreadyShared = FALSE;
            pParam->ShareName[0]   = '\0';

            SendDlgItemMessage (hwnd, IDC_KEEPASEDIT, EM_LIMITTEXT, MAX_NDDESHARENAME - 15, 0L);
            SendDlgItemMessage (hwnd, IDC_SHARECHECKBOX, BM_SETCHECK, fSharePreference, 0L);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDOK:
                    fSharePreference = (BOOL)SendDlgItemMessage (hwnd,
                                                                 IDC_SHARECHECKBOX,
                                                                 BM_GETCHECK,
                                                                 0,
                                                                 0L );

                    if (!GetDlgItemText(hwnd, IDC_KEEPASEDIT, pParam->ShareName+1, MAX_PAGENAME_LENGTH))
                        {
                        SetFocus (GetDlgItem (hwnd, IDC_KEEPASEDIT));
                        break;
                        }

                    pParam->ShareName[0] = SHR_CHAR;

                    if (!NDdeIsValidShareName(pParam->ShareName + 1))
                        //|| StrHas2BkSlash (pParam->ShareName)) // this was a temp fix for NDde bug
                        {
                        MessageBoxID (hInst,
                                      hwnd,
                                      IDS_PAGENAMESYNTAX,
                                      IDS_PASTEDLGTITLE,
                                      MB_OK|MB_ICONEXCLAMATION);
                        break;
                        }

                    pParam->ShareName[0] = UNSHR_CHAR;

                    // make sure name is unique
                    if ( !IsUniqueName (pParam))
                        {
                        if (IDOK != MessageBoxID (hInst,
                                                 hwnd,
                                                 IDS_NAMEEXISTS,
                                                 IDS_PASTEDLGTITLE,
                                                 MB_OKCANCEL|MB_ICONEXCLAMATION))
                             break;

                        pParam->bAlreadyExist = TRUE;

                        //MessageBoxID (hInst,
                        //              hwnd,
                        //              IDS_NAMEEXISTS,
                        //              IDS_PASTEDLGTITLE,
                        //              MB_OK|MB_ICONEXCLAMATION);
                        //break;
                        }

                    EndDialog( hwnd, TRUE );
                    break;

                case IDCANCEL:
                     EndDialog( hwnd, FALSE );
                     break;

                default:
                     return FALSE;
                }
            break;

        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( lphi->hItemHandle,
                          szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR) (LPVOID) aHelpIDs);
            }
            else
            {
                return FALSE;
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp( (HWND) wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR) (LPVOID) aHelpIDs);
            break;
        //


        default:
            return FALSE;
        }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\dialogs.h ===
/*****************************************************************************

                        D I A L O G S   H E A D E R

    Name:       dialogs.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for dialogs.c

*****************************************************************************/


INT_PTR CALLBACK ConnectDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


INT_PTR CALLBACK ShareDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


INT_PTR CALLBACK KeepAsDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\initmenu.c ===
/*****************************************************************************

                        I N I T M E N U

    Name:       initmenu.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the function to initialize the menus.

    History:
        21-Jan-1994     John Fu, reformat and cleanup.
        13-Mar-1995     John Fu, add Paste to Page

*****************************************************************************/



#define	WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <assert.h>
#include <memory.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "commctrl.h"
#include "cvinit.h"
#include "cvutil.h"
#include "initmenu.h"










/*
 *      InitializeMenu
 *
 *  this function controls the enabled/grayed state of
 *  the menu items and the state of the toolbar buttons.
 *  It is called when the selection within a listbox changes,
 *  or the focus changes from one MDI child window to another.
 */

VOID PASCAL InitializeMenu (
    HANDLE  hmenu)
{
LPLISTENTRY     lpLE = NULL;
int             index;
int             fMenu;
int             fButton;
DWORD           flags;



    assert(NULL != pActiveMDI);

    hmenu = GetMenu(hwndApp);

    flags = pActiveMDI->flags;


    if (flags & F_CLPBRD)
        {
        index = LB_ERR;
        }
    else if (pActiveMDI->hWndListbox)
        {
        index = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

        if ( index != LB_ERR )
            {
            SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT, index, (LPARAM)(LPCSTR)&lpLE);
            }
       }
    else
        index = LB_ERR;



    EnableMenuItem (hmenu,
                    IDM_OPEN,
                    (flags & F_CLPBRD ? MF_ENABLED : MF_GRAYED)| MF_BYCOMMAND);

    EnableMenuItem (hmenu,
                    IDM_SAVEAS,
                    (CountClipboardFormats() && flags & (F_CLPBRD|F_LOCAL)?
                     MF_ENABLED :
                     MF_GRAYED)
                    | MF_BYCOMMAND );


    if ( fShareEnabled )
        {
        // SHARE allowed?
        if ( (flags & F_LOCAL) && (index != LB_ERR) )
            {
            fMenu = MF_ENABLED;
            fButton = TRUE;
            }
        else
            {
            fMenu = MF_GRAYED;
            fButton = FALSE;
            }
        EnableMenuItem (hmenu, IDM_SHARE, fMenu | MF_BYCOMMAND );
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_SHARE, fButton );

        // UNSHARE allowed?
        if ( (flags & F_LOCAL) && (index != LB_ERR) &&  IsShared(lpLE) )
            {
            fMenu = MF_ENABLED;
            fButton = TRUE;
            }
        else
            {
            fMenu = MF_GRAYED;
            fButton = FALSE;
            }
        EnableMenuItem (hmenu, IDM_UNSHARE, fMenu | MF_BYCOMMAND);
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_UNSHARE, fButton );
        }





    if ( fNetDDEActive )
        {
        // DISCONNECT allowed?
        EnableMenuItem (hmenu, IDM_DISCONNECT,
           (flags & ( F_LOCAL | F_CLPBRD ) ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_DISCONNECT,
           flags & ( F_LOCAL | F_CLPBRD ) ? FALSE : TRUE );
        }
    else // If netdde isn't active, we can't connect
        {
        EnableMenuItem(hmenu, IDM_CONNECT, MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem(hmenu, IDM_DISCONNECT, MF_GRAYED | MF_BYCOMMAND);
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDM_CONNECT, FALSE);
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDM_DISCONNECT, FALSE);
        }



    // Delete allowed?
    if ( ( flags & F_LOCAL && index != LB_ERR ) ||
        flags & F_CLPBRD && CountClipboardFormats() )
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }

    EnableMenuItem (hmenu, IDM_DELETE, fMenu | MF_BYCOMMAND);
    SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_DELETE, fButton );



    // a page selected?
    if ( index != LB_ERR  )
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }

    EnableMenuItem (hmenu, IDM_COPY, fMenu | MF_BYCOMMAND);
    SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_COPY, fButton );



    // Paste Allowed?
    if (CountClipboardFormats() && hwndActiveChild == hwndLocal && !(flags & F_CLPBRD))
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }


    EnableMenuItem (hmenu, IDM_KEEP, fMenu | MF_BYCOMMAND);
    SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_KEEP, fButton );


    // if a page is selected
    if (LB_ERR != index)
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, fMenu|MF_BYCOMMAND);
    else
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, MF_GRAYED|MF_BYCOMMAND);








    // TOOLBAR, STATUS BAR
    CheckMenuItem ( hmenu, IDM_TOOLBAR, fToolBar ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem ( hmenu, IDM_STATUSBAR, fStatus ? MF_CHECKED:MF_UNCHECKED );




    // disable some view options if clipboard window

    EnableMenuItem (hmenu,
                    IDM_LISTVIEW,
                    (flags & F_CLPBRD ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );

    EnableMenuItem (hmenu,
                    IDM_PREVIEWS,
                    (flags & F_CLPBRD ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );
    EnableMenuItem (hmenu,
                    IDM_PAGEVIEW,
                    ((flags & F_CLPBRD) || index != LB_ERR ? MF_ENABLED : MF_GRAYED) | MF_BYCOMMAND);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_LISTVIEW,
                 flags & F_CLPBRD ? FALSE : TRUE);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_PREVIEWS,
                 flags & F_CLPBRD ? FALSE : TRUE);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_PAGEVIEW,
                 (( flags & F_CLPBRD ) || index != LB_ERR ) ? TRUE : FALSE );



    // Disable "Security" menu for other than Local Clipbook window
    // or if there's no item selected in the clipbook window
    fMenu = MF_GRAYED | MF_BYCOMMAND;
    if ((flags & F_LOCAL) && LB_ERR != index)
        {
        fMenu = MF_ENABLED | MF_BYCOMMAND;
        }

    EnableMenuItem (hmenu, IDM_PERMISSIONS, fMenu);
    EnableMenuItem (hmenu, IDM_OWNER, fMenu);
    EnableMenuItem (hmenu, IDM_AUDITING, fAuditEnabled ? fMenu : MF_GRAYED | MF_BYCOMMAND);



    // check selected view...

    CheckMenuItem (hmenu,
                   IDM_LISTVIEW,
                   pActiveMDI->DisplayMode == DSP_LIST ? MF_CHECKED : MF_UNCHECKED );

    CheckMenuItem (hmenu,
                   IDM_PREVIEWS,
                   pActiveMDI->DisplayMode == DSP_PREV ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem (hmenu,
                   IDM_PAGEVIEW,
                   pActiveMDI->DisplayMode == DSP_PAGE ? MF_CHECKED : MF_UNCHECKED );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_LISTVIEW,
                 pActiveMDI->DisplayMode == DSP_LIST ? TRUE : FALSE );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_PREVIEWS,
                 pActiveMDI->DisplayMode == DSP_PREV ? TRUE : FALSE );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_PAGEVIEW,
                 pActiveMDI->DisplayMode == DSP_PAGE ? TRUE : FALSE );




    DrawMenuBar(hwndApp);


    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\ismember.h ===
/*****************************************************************************

                        I S M E M B E R   H E A D E R

    Name:       ismember.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for ismember.c

*****************************************************************************/


BOOL IsUserMember(
    PSID    psidGroup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\dumpsd.c ===
#ifdef DEBUG


/*
 *      HexDumpBytes
 */

void HexDumpBytes(
    char        *pv,
    unsigned    cb)
{
char        achHex[]="0123456789ABCDEF";
char        achOut[80];
unsigned    iOut;



    iOut = 0;

    while (cb)
        {
        if (iOut >= 78)
            {
            PINFO(achOut);
            iOut = 0;
            }

        achOut[iOut++] = achHex[(*pv >> 4) & 0x0f];
        achOut[iOut++] = achHex[*pv++ & 0x0f];
        achOut[iOut]   = '\0';
        cb--;
        }


    if (iOut)
        {
        PINFO(achOut);
        }

}





/*
 *      PrintSid
 */

void PrintSid(
    PSID    sid)
{
DWORD   cSubAuth;
DWORD   i;

    PINFO(TEXT("\r\nSID: "));

    if (sid)
        {
        HexDumpBytes((char *)GetSidIdentifierAuthority(sid), sizeof(SID_IDENTIFIER_AUTHORITY));

        SetLastError(0);
        cSubAuth = *GetSidSubAuthorityCount(sid);
        if (GetLastError())
            {
            PINFO(TEXT("Invalid SID\r\n"));
            }
        else
            {
            for (i = 0;i < cSubAuth; i++)
                {
                PINFO(TEXT("-"));
                HexDumpBytes((char *)GetSidSubAuthority(sid, i), sizeof(DWORD));
                }
            PINFO(TEXT("\r\n"));
            }
        }
    else
        {
        PINFO(TEXT("NULL SID\r\n"));
        }

}






/*
 *      PrintAcl
 *
 *  Purpose: Print out the entries in an access-control list.
 */

void PrintAcl(
    PACL    pacl)
{
ACL_SIZE_INFORMATION    aclsi;
ACCESS_ALLOWED_ACE      *pace;
unsigned                i;


    if (pacl)
        {
        if (GetAclInformation (pacl, &aclsi, sizeof(aclsi), AclSizeInformation))
            {
            for (i = 0;i < aclsi.AceCount;i++)
                {
                GetAce(pacl, i, &pace);

                PINFO(TEXT("Type(%x) Flags(%x) Access(%lx)\r\nSID:"),
                      (int)pace->Header.AceType,
                      (int)pace->Header.AceFlags,
                      pace->Mask);
                PrintSid((PSID)&(pace->SidStart));
                }
            }
        }
    else
        {
        PINFO(TEXT("NULL PACL\r\n"));
        }

}






/*
 *      PrintSD
 */

void PrintSD(
    PSECURITY_DESCRIPTOR    pSD)
{
DWORD   dwRev;
WORD    wSDC;
BOOL    fDefault, fAcl;
PACL    pacl;
PSID    sid;



    if (NULL == pSD)
        {
        PINFO(TEXT("NULL sd\r\n"));
        return;
        }

    if (!IsValidSecurityDescriptor(pSD))
        {
        PINFO(TEXT("Bad SD %p"), pSD);
        return;
        }

    // Drop control info and revision
    if (GetSecurityDescriptorControl(pSD, &wSDC, &dwRev))
        {
        PINFO(TEXT("SD - Length: [%ld] Control: [%x] [%lx]\r\nGroup:"),
              GetSecurityDescriptorLength(pSD), wSDC, dwRev);
        }
    else
        {
        PINFO(TEXT("Couldn't get control\r\nGroup"));
        }

    // Show group and owner
    if (GetSecurityDescriptorGroup(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\nOwner:"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get group\r\n"));
        }

    if (GetSecurityDescriptorOwner(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\n"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get owner\r\n"));
        }

    // Print DACL and SACL
    if (GetSecurityDescriptorDacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("DACL: %s %s\r\n"), fAcl ? "Yes" : "No",
              fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid Acl %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get DACL\r\n"));
        }

    if (GetSecurityDescriptorSacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("SACL: %s %s\r\n"), fAcl ? "Yes" : "No", fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid ACL %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get SACL\r\n"));
        }

}


#else
#define PrintSid(x)
#define PrintSD(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\helpids.h ===
#define IDH_ABOUT           10020
#define IDH_EXIT            10021
#define IDH_COPY            10022
#define IDH_DELETE          10023
#define IDH_DLG_SHARE       10024
#define IDH_OPEN            10027
#define IDH_SAVEAS          10028
#define IDH_SELECT_COMPUTER 10029
#define IDH_CONNECT         10030
#define IDH_DISCONNECT      10031
#define IDH_CONTENTS        10032
#define IDH_HELPSEARCH      10033
#define IDH_HELPHELP        10034
#define IDH_DLG_PASTEDATA   10035
#define IDH_STOPSHARE       10036
#define IDH_TOOLBAR         10037
#define IDH_STATUS_BAR      10038
#define IDH_TILEVERT        10039
#define IDH_CASCADE         10040
#define IDH_ARRANGEICONS    10041
#define IDH_REFRESH         10044
#define IDH_TABLE           10045
#define IDH_THUMBNAILS      10046
#define IDH_FULLPAGE        10047
#define IDH_TILEHORIZ       10048
#define IDH_PERMISSIONS     10049
#define IDH_AUDITING        10050
#define IDH_OWNER           10051
#define IDH_PASTE_PAGE      10052

#define IDH_STARTAPP        10203
#define IDH_MINIMIZED       10215
#define IDH_KEEPASEDIT      10301
#define IDH_SHARECHECKBOX   10304

#define IDH_DEFAULT         11024
#define IDH_TEXT            10401 //IDH_FORMATS_BASE + CF_TEXT
#define IDH_BITMAP          10402 //IDH_FORMATS_BASE + CF_BITMAP
#define IDH_METAFILEPICT    10403 //IDH_FORMATS_BASE + CF_METAFILEPICT
#define IDH_SYLK            10404 //IDH_FORMATS_BASE + CF_SYLK
#define IDH_DIF             10405 //IDH_FORMATS_BASE + CF_DIF
#define IDH_TIFF            10406 //IDH_FORMATS_BASE + CF_TIFF
#define IDH_OEMTEXT         10407 //IDH_FORMATS_BASE + CF_OEMTEXT
#define IDH_DIB             10408 //IDH_FORMATS_BASE + CF_DIB
#define IDH_PALETTE         10409 //IDH_FORMATS_BASE + CF_PALETTE
#define IDH_PENDATA         10410 //IDH_FORMATS_BASE + CF_PENDATA
#define IDH_RIFF            10411 //IDH_FORMATS_BASE + CF_RIFF
#define IDH_WAVE            10412 //IDH_FORMATS_BASE + CF_WAVE
#define IDH_OWNERDISPLAY    10528 //IDH_FORMATS_BASE + CF_OWNERDISPLAY
#define IDH_DSPTEXT         10529 //IDH_FORMATS_BASE + CF_DSPTEXT
#define IDH_DSPBITMAP       10530 //IDH_FORMATS_BASE + CF_DSPBITMAP
#define IDH_DSPMETAFILEPICT 10531 //IDH_FORMATS_BASE + CF_DSPMETAFILEPICT
#define IDH_ENHMETAFILE     10414 //IDH_FORMATS_BASE + CF_ENHMETAFILE
#define IDH_DSPENHMETAFILE  10542 //IDH_FORMATS_BASE + CF_DSPENHMETAFILE
#define IDH_UNICODETEXT     10413 //IDH_FORMATS_BASE + CF_UNICODETEXT
#define IDH_HDROP           10415 //IDH_FORMATS_BASE + CF_HDROP
#define IDH_LOCALE          10416 //IDH_FORMATS_BASE + CF_LOCALE

#define IDH_NAMESWIND       10502
#define IDH_SYSMENU         10503

#define IDH_PERMSDLG        10102
#define IDH_AUDITDLG        10103
#define IDH_ADD_USER_DLG    10105
#define IDH_ADD_MEM_LG_DLG  10106
#define IDH_ADD_MEM_GG_DLG  10107
#define IDH_FIND_ACCT_DLG   10108

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\ndde.c ===
//========================================================================
//
//  NDDEAPI.H  include file for dde share apis
//
//  Revision History:
//  5-13-19     ClausGi created
//
//========================================================================
// tabstop = 4


#include "windows.h"
#include "nddeapi.h"


#define NDDE_NOT_RUNNING	 	      18

BOOL WINAPI
NDdeIsValidPassword (
    LPTSTR  password    // name to check for validity
)
{
    return TRUE;
}

BOOL WINAPI
NDdeIsValidTopic (
    LPTSTR  targetTopic // name to check for validity
)
{
    return TRUE;
}


HWND WINAPI NDdeGetWindow ( VOID )
{
    return (HWND)1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\initmenu.h ===
/*****************************************************************************

                        I N I T M E N U   H E A D E R

    Name:       initmenu.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for initmenu.c

*****************************************************************************/


VOID PASCAL InitializeMenu (
    HANDLE  hmenu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\ismember.c ===
/*****************************************************************************

                            I S M E M B E R

    Name:       ismember.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the function to check the user is a member
        of a given group.

    History:
        21-Jan-1994     John Fu, reformat and cleanup.

*****************************************************************************/


#include <windows.h>
#include "clipbook.h"
#include "ismember.h"
#include "security.h"
#include "debugout.h"




/*
 *      IsUserMember
 *
 *  Purpose: Determine if the current user is a member of the given group.
 *
 *  Parameters:
 *     psidGroup - Pointer to a SID describing the group.
 *
 *  Returns: TRUE if the user is a member of the group, FALSE
 *     otherwise
 */


BOOL IsUserMember(
    PSID    psidGroup)
{
TOKEN_GROUPS    *ptokgrp;
HANDLE          hToken;
BOOL            fRet = FALSE;
DWORD           dwInfoSize;
unsigned        i;



    PINFO(TEXT("IsMember of ? "));
    PrintSid(psidGroup);

    if (!GetTokenHandle(&hToken))
        {
        PERROR(TEXT("IsUserMember: Couldn't get token handle\r\n"));
        return FALSE;
        }


    GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwInfoSize);

    if (ptokgrp = LocalAlloc(LPTR, dwInfoSize))
        {
        if (GetTokenInformation(hToken, TokenGroups, ptokgrp,
                 dwInfoSize, &dwInfoSize))
            {
            for (i = 0;i < ptokgrp->GroupCount;i++)
                {
                PrintSid(ptokgrp->Groups[i].Sid);

                if (EqualSid(ptokgrp->Groups[i].Sid, psidGroup))
                    {
                    PINFO(TEXT("YES"));
                    fRet = TRUE;
                    break;
                    }
                }
            }
        LocalFree(ptokgrp);
        }


    if (!fRet)
        {
        TOKEN_USER *ptokusr;

        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwInfoSize);

        if (ptokusr = LocalAlloc(LPTR, dwInfoSize))
            {
            if (GetTokenInformation(hToken, TokenUser, ptokusr,
                  dwInfoSize, &dwInfoSize))
                {
                if (EqualSid(ptokusr->User.Sid, psidGroup))
                    {
                    PINFO(TEXT("YES"));
                    fRet = TRUE;
                    }
                }
            LocalFree(ptokusr);
            }
        }



    PINFO(TEXT("\r\n"));

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\shares.c ===
/*****************************************************************************

                                S H A R E S

    Name:       shares.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains functions for manipulating NetDDE shares.

    History:
        21-Jan-1994 John Fu     Reformat and cleanup.
        19-Apr-1994 John Fu     Fix shares dialog help topic.
        03-Nov-1997 DrewM       Revised dialogs to use context sensitive help
*****************************************************************************/


#define    NOAUTOUPDATE 1

#include <windows.h>
#include <windowsx.h>
#include <nddeapi.h>
#include <nddesec.h>
#include <sedapi.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "auditchk.h"
#include "clipdsp.h"
#include "dialogs.h"
#include "helpids.h"
#include "shares.h"
#include "clpbkdlg.h"
#include "cvutil.h"
#include "debugout.h"
#include "security.h"
#include "initmenu.h"





#define MAX_PERMNAMELEN     64



// Typedefs used to dynamically load and call the permission editors.

typedef DWORD (WINAPI *LPFNSACLEDIT)(HWND,
                                     HANDLE,
                                     LPWSTR,
                                     PSED_OBJECT_TYPE_DESCRIPTOR,
                                     PSED_APPLICATION_ACCESSES,
                                     LPWSTR,
                                     PSED_FUNC_APPLY_SEC_CALLBACK,
                                     ULONG_PTR,
                                     PSECURITY_DESCRIPTOR,
                                     BOOLEAN,
                                     LPDWORD,
                                     DWORD);

typedef DWORD (WINAPI *LPFNDACLEDIT)(HWND,
                                     HANDLE,
                                     LPWSTR,
                                     PSED_OBJECT_TYPE_DESCRIPTOR,
                                     PSED_APPLICATION_ACCESSES,
                                     LPWSTR,
                                     PSED_FUNC_APPLY_SEC_CALLBACK,
                                     ULONG_PTR,
                                     PSECURITY_DESCRIPTOR,
                                     BOOLEAN,
                                     BOOLEAN,
                                     LPDWORD,
                                     DWORD);


// Typedef for dynamically loading the Edit Owner dialog.
typedef DWORD (WINAPI *LPFNOWNER)(HWND,
                                  HANDLE,
                                  LPWSTR,
                                  LPWSTR,
                                  LPWSTR,
                                  UINT,
                                  PSED_FUNC_APPLY_SEC_CALLBACK,
                                  ULONG_PTR,
                                  PSECURITY_DESCRIPTOR,
                                  BOOLEAN,
                                  BOOLEAN,
                                  LPDWORD,
                                  PSED_HELP_INFO,
                                  DWORD);









static TCHAR    szDirName[256] = {'\0',};
static WCHAR    ShareObjectName[80];


static SED_APPLICATION_ACCESS KeyPerms[] =
   {
   SED_DESC_TYPE_RESOURCE,          0,                          0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_READ,              0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_READ_LINK,         0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_CHANGE,            0, NULL,
   SED_DESC_TYPE_RESOURCE,          GENERIC_ALL,                0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_READ,            0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_WRITE,           0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_INITIATE_STATIC, 0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_INITIATE_LINK,   0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_REQUEST,         0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_ADVISE,          0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_POKE,            0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_EXECUTE,         0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_ADD_ITEMS,       0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_LIST_ITEMS,      0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  DELETE,                     0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  READ_CONTROL,               0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  WRITE_DAC,                  0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  WRITE_OWNER,                0, NULL,
   };

static SED_APPLICATION_ACCESS KeyAudits[] =
   {
   SED_DESC_TYPE_AUDIT, NDDE_GUI_READ,   0, NULL,
   SED_DESC_TYPE_AUDIT, NDDE_GUI_CHANGE, 0, NULL,
   SED_DESC_TYPE_AUDIT, WRITE_DAC,       0, NULL,
   SED_DESC_TYPE_AUDIT, WRITE_OWNER,     0, NULL
   };







// Callback function gets called by the permission editor

DWORD CALLBACK SedCallback(HWND,
                  HANDLE,
                  ULONG_PTR,
                  PSECURITY_DESCRIPTOR,
                  PSECURITY_DESCRIPTOR,
                  BOOLEAN,
                  BOOLEAN,
                  LPDWORD);










#if DEBUG


/*
 *      DumpDdeInfo
 */

void DumpDdeInfo(
    PNDDESHAREINFO  pDdeI,
    LPTSTR          lpszServer)
{
LPTSTR      lpszT;
unsigned    i;



    PINFO(TEXT("Dde block:\r\n\r\n"));
    PINFO(TEXT("Server: <%s> Share: <%s>\r\n"),
          lpszServer ? lpszServer : "NULL",
          pDdeI->lpszShareName);

    lpszT = pDdeI->lpszAppTopicList;

    for (i = 0;i < 3;i++)
        {
        PINFO(TEXT("App|Topic %d: <%s>\r\n"),i, lpszT);
        lpszT += lstrlen(lpszT) + 1;
        }

    PINFO(TEXT("Rev: %ld Shared: %ld Service: %ld Start: %ld\r\n"),
          pDdeI->lRevision,
          pDdeI->fSharedFlag,
          pDdeI->fService,
          pDdeI->fStartAppFlag);

    PINFO(TEXT("Type: %ld Show: %ld Mod1: %lx Mod2: %lx\r\n"),
          pDdeI->lShareType,
          pDdeI->nCmdShow,
          pDdeI->qModifyId[0],
          pDdeI->qModifyId[1]);

    PINFO(TEXT("Items: %ld ItemList:"),
          pDdeI->cNumItems);


    lpszT = pDdeI->lpszItemList;

    if (lpszT)
        {
        for (i = 0;i < (unsigned)pDdeI->cNumItems;i++)
            {
            if ((i - 1)% 4 == 0)
                {
                PINFO(TEXT("\r\n"));
                }

            PINFO(TEXT("%s\t"),lpszT);
            lpszT += lstrlen(lpszT) + 1;
            }
        PINFO(TEXT("\r\n"));
        }
    else
        {
        PINFO(TEXT("NULL\r\n"));
        }

}


#endif // DEBUG











/*
 *      SedCallback
 *
 *  Purpose: Callback function called by ACLEDIT.DLL. See SEDAPI.H for
 *     details on its parameters and return value.
 *
 *  Notes: The CallbackContext of this callback should be a string in
 *     this format: Computername\0Sharename\0SECURITY_INFORMATION struct.
 */

DWORD CALLBACK SedCallback(
    HWND                 hwndParent,
    HANDLE               hInstance,
    ULONG_PTR            penvstr,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN              ApplyToSubContainers,
    BOOLEAN              ApplyToSubObjects,
    LPDWORD              StatusReturn)
{
PSECURITY_DESCRIPTOR    psdSet;
SEDCALLBACKCONTEXT      *pcbcontext;
DWORD                   ret = NDDE_NO_ERROR + 37;
DWORD                   dwMyRet = ERROR_INVALID_PARAMETER;
DWORD                   dwLen;
DWORD                   dwErr;


    pcbcontext = (SEDCALLBACKCONTEXT *)penvstr;

    PINFO(TEXT("SedCallback: machine  %ls share %ls SI %ld\r\n"),
          pcbcontext->awchCName, pcbcontext->awchSName, pcbcontext->si);


    // Need to give this capability to remote shares somehow!!!
    if (!IsValidSecurityDescriptor(SecDesc))
        {
        PERROR(TEXT("Bad security descriptor created, can't set security."));
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;
        dwMyRet = ERROR_INVALID_SECURITY_DESCR;
        }
    else
        {
        PINFO(TEXT("Setting security to "));
        PrintSD(SecDesc);

        SetLastError(0);
        dwLen = GetSecurityDescriptorLength (SecDesc);

        if (dwErr = GetLastError())
            {
            PERROR(TEXT("GetSecurityDescriptorLength -> %u\r\n"), dwErr);
            dwMyRet = ERROR_INVALID_SECURITY_DESCR;
            }
        else
            {
            // Try to make sure that the SD is self-relative, 'cause the
            // NetDDE functions vomit when given absolute SDs.

            if (psdSet = LocalAlloc (LPTR, dwLen))
                {
                if (FALSE == MakeSelfRelativeSD (SecDesc, psdSet, &dwLen))
                    {
                    LocalFree(psdSet);

                    if (psdSet = LocalAlloc (LPTR, dwLen))
                        {
                        if (FALSE == MakeSelfRelativeSD (SecDesc, psdSet, &dwLen))
                            {
                            LocalFree(psdSet);
                            psdSet = NULL;
                            dwMyRet = ERROR_INVALID_SECURITY_DESCR;
                            }
                        }
                    else
                        {
                        dwMyRet = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                if (psdSet)
                    {
                    DWORD dwTrust[3];

                    NDdeGetTrustedShareW (pcbcontext->awchCName,
                                          pcbcontext->awchSName,
                                          dwTrust,
                                          dwTrust + 1,
                                          dwTrust + 2);

                    ret = NDdeSetShareSecurityW (pcbcontext->awchCName,
                                                 pcbcontext->awchSName,
                                                 pcbcontext->si,
                                                 psdSet);

                    PINFO(TEXT("Set share info. %d\r\n"),ret);

                    if (ret != NDDE_NO_ERROR)
                        {
                        //MessageBoxID (hInst,
                        //              hwndParent,
                        //              IDS_INTERNALERR,
                        //              IDS_APPNAME,
                        //              MB_OK | MB_ICONSTOP);
                        NDdeMessageBox (hInst,
                                        hwndParent,
                                        ret,
                                        IDS_APPNAME,
                                        MB_OK|MB_ICONSTOP);

                        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;
                        dwMyRet =  ERROR_ACCESS_DENIED;
                        }
                    else
                        {
                        NDdeSetTrustedShareW (pcbcontext->awchCName,
                                              pcbcontext->awchSName,
                                              0);

                        NDdeSetTrustedShareW (pcbcontext->awchCName,
                                              pcbcontext->awchSName,
                                              dwTrust[0]);

                        *StatusReturn = SED_STATUS_MODIFIED;
                        dwMyRet =  ERROR_SUCCESS;
                        }
                    LocalFree(psdSet);
                    }
                }
            }
        }


    return(dwMyRet);


}








/*
 *      EditPermissions
 *
 *  Purpose: Call the Acl Editor for the selected page.
 *
 *  Parameters:
 *     fSacl - TRUE to call the SACL editor (auditing); FALSE to call
 *        the DACL editor (permissions).
 *
 *  Returns: current selected item in list box or LB_ERR.
 */

LRESULT EditPermissions (
    BOOL    fSacl)
{
LPLISTENTRY     lpLE;
TCHAR           rgtchCName[MAX_COMPUTERNAME_LENGTH + 3];
TCHAR           rgtchShareName[MAX_NDDESHARENAME + 1];
DWORD           dwBAvail;
WORD            wItems;
unsigned        iListIndex;
TCHAR           szBuf[MAX_PAGENAME_LENGTH + 32];




    iListIndex = (int)SendMessage(pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (iListIndex != LB_ERR)
       {
       // Set status bar text, and make the cursor an arrow.
       // LoadString(hInst, IDS_GETPERMS, atchStatusBar, sizeof(atchStatusBar));
       // LockApp(TRUE, atchStatusBar);

       if (SendMessage (pActiveMDI->hWndListbox,
                        LB_GETTEXT, iListIndex, (LPARAM)(LPCSTR)&lpLE)
           == LB_ERR)
          {
          PERROR(TEXT("PermsEdit No text: %d\n\r"), iListIndex );
          }
       else
          {
          // NDdeShareGetInfo wants a wItems containing 0. Fine.
          wItems = 0;

          // Get computer name containing share
          rgtchCName[0] = rgtchCName[1] = TEXT('\\');
          if (pActiveMDI->flags & F_LOCAL)
             {
             dwBAvail = MAX_COMPUTERNAME_LENGTH + 1;
             GetComputerName (rgtchCName + 2, &dwBAvail);
             }
          else
             {
             lstrcpy(rgtchCName + 2, pActiveMDI->szBaseName);
             }

          PINFO(TEXT("Getting page %s from server %s\r\n"),
               lpLE->name, rgtchCName);

          // Set up sharename string ("$<pagename>")
          lstrcpy(rgtchShareName, lpLE->name);
          rgtchShareName[0] = SHR_CHAR;



          // Edit the permissions
          PINFO(TEXT("Editing permissions for share %s\r\n"), rgtchShareName);
          EditPermissions2 (hwndApp, rgtchShareName, fSacl);



          ///////////////////////////////////////////////
          // do the execute to change the security on the file.
          lstrcat(lstrcpy(szBuf, IsShared(lpLE) ? SZCMD_SHARE : SZCMD_UNSHARE),
                      lpLE->name);
          PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

          MySyncXact ( (LPBYTE)szBuf,
              lstrlen(szBuf) +1, GETMDIINFO(hwndLocal)->hExeConv, 0L, CF_TEXT,
              XTYP_EXECUTE, SHORT_SYNC_TIMEOUT, NULL);
          }
       // LockApp(FALSE, szNull);
       }


    return iListIndex;

}












/*
 *      EditPermissions2
 *
 *  Purpose: Put up the standard "permission editor" dialog.
 *
 *  Parameters:
 *     hWnd - Parent window for the dialog.
 *     pShareName - Name of the DDE share.
 *     lpDdeI - Pointer to an NDDESHAREINFO describing the share.
 *     fSacl - TRUE if you're editing the SACL, FALSE to edit the DACL
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

BOOL WINAPI EditPermissions2 (
    HWND    hWnd,
    LPTSTR  pShareName,
    BOOL    fSacl)
{
SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
SED_APPLICATION_ACCESSES    ApplicationAccesses;

PSECURITY_DESCRIPTOR        pSD = NULL;
GENERIC_MAPPING             GmDdeShare;
SED_HELP_INFO               HelpInfo;
SEDCALLBACKCONTEXT          cbcontext;

DWORD       Status;
DWORD       dwRtn;
unsigned    i, iFirst;
BOOL        fRet = FALSE;
DWORD       dwSize;
BOOL        fCouldntRead;
HMODULE     hMod;
LPWSTR      szPermNames = NULL;

WCHAR	szSpecial[256];


    PINFO(TEXT("EditPermissions2: %s"), fSacl ? "SACL\r\n" : "DACL\r\n");

    if (fSacl && !AuditPrivilege (AUDIT_PRIVILEGE_ON))
        return fRet;




    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Set up the callback context for the SedCallback function.
    cbcontext.awchCName[0] = cbcontext.awchCName[1] = L'\\';
    if (pActiveMDI->flags & (F_LOCAL | F_CLPBRD))
        {
        dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerNameW(cbcontext.awchCName + 2, &dwSize);
        }
    else
        {
        #ifdef REMOTE_ADMIN_OK
            #ifdef UNICODE
                lstrcpy(awchEnvStr + 2, pActiveMDI->szBaseName);
            #else
                MultiByteToWideChar (CP_ACP,
                                     0,
                                     pActiveMDI->szBaseName, -1,
                                     cbcontext.awchCName + 2,
                                     MAX_COMPUTERNAME_LENGTH + 1);
            #endif
        #else
            PERROR(TEXT("EditPermissions2() on remote window!!!\r\n"));
            MessageBoxID (hInst,
                          hwndApp,
                          IDS_INTERNALERR,
                          IDS_APPNAME,
                          MB_OK | MB_ICONHAND);
        #endif
        }


    #ifdef UNICODE
        lstrcpyW(cbcontext.awchSName, pShareName);
    #else
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                            cbcontext.awchSName, MAX_NDDESHARENAME);
    #endif

    cbcontext.si = (fSacl? SACL_SECURITY_INFORMATION: DACL_SECURITY_INFORMATION);





    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, 30);
    if (!pSD)
        {
        PERROR(TEXT("LocalAlloc fail\r\n"));
        }
    else
        {
        // Get the security descriptor off of the share
        dwRtn = NDdeGetShareSecurityW (cbcontext.awchCName,
                                       cbcontext.awchSName,
                                       cbcontext.si |
                                       OWNER_SECURITY_INFORMATION,
                                       pSD,
                                       30,
                                       &dwSize);
        switch (dwRtn)
            {
            case NDDE_NO_ERROR:
                fCouldntRead = FALSE;
                PrintSD(pSD);
                break;

            case NDDE_BUF_TOO_SMALL:
                {
                PINFO(TEXT("GetShareSec sez SD is %ld bytes long, ret %ld\r\n"),
                      dwSize, dwRtn);

                LocalFree(pSD);
                pSD = NULL;

                if (dwSize < 65535 && (pSD = LocalAlloc(LPTR, dwSize)))
                    {
                    dwRtn = NDdeGetShareSecurityW (cbcontext.awchCName,
                                                   cbcontext.awchSName,
                                                   cbcontext.si |
                                                   OWNER_SECURITY_INFORMATION,
                                                   pSD,
                                                   dwSize,
                                                   &dwSize);

                    if (NDDE_NO_ERROR == dwRtn)
                        {
                        fCouldntRead = FALSE;
                        PINFO(TEXT("Got security!\r\n"));
                        PrintSD(pSD);
                        }
                    else
                        {
                        PERROR(TEXT("NDdeGetSecurity fail %ld!\r\n"), dwRtn);
                        fCouldntRead = TRUE;
                        LocalFree(pSD);
                        pSD = NULL;
                        break;
                        }
                    }
                else
                    {
                    PERROR(TEXT("LocalReAlloc fail (%ld bytes)\r\n"), dwSize);
                    }
                }
                break;

            case NDDE_ACCESS_DENIED:
            default:
                fCouldntRead = TRUE;
                LocalFree(pSD);
                pSD = NULL;
                break;
            }
        }



    if (!pSD && !fCouldntRead)
        {
        MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
        goto done;
        }




    LoadStringW(hInst, IDS_SHROBJNAME, ShareObjectName,
          ARRAYSIZE(ShareObjectName));

    // Set up help contexts for all of the dialogs, so the Help
    // buttons will work.
    HelpInfo.pszHelpFileName = L"clipbrd.hlp";
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = IDH_ADD_USER_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG]     = IDH_ADD_MEM_LG_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG]     = IDH_ADD_MEM_GG_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG]         = IDH_FIND_ACCT_DLG;
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = fSacl ?
                                                               IDH_AUDITDLG :
                                                               IDH_PERMSDLG;

    // Set up a GENERIC_MAPPING struct-- we don't use generic
    // rights, but the struct has to be there.
    GmDdeShare.GenericRead    = NDDE_GUI_READ;
    GmDdeShare.GenericWrite   = NDDE_GUI_CHANGE;
    GmDdeShare.GenericExecute = NDDE_GUI_READ_LINK;
    GmDdeShare.GenericAll     = NDDE_GUI_FULL_CONTROL;

    ObjectTypeDescriptor.Revision                        = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                     = FALSE;
    ObjectTypeDescriptor.AllowNewObjectPerms             = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric       = FALSE;
    ObjectTypeDescriptor.GenericMapping                  = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects        = &GmDdeShare;
    ObjectTypeDescriptor.ObjectTypeName                  = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                        = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle        = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;

    LoadStringW (hInst, IDS_SPECIAL, szSpecial, 256 );
    ObjectTypeDescriptor.SpecialObjectAccessTitle = szSpecial;

    ObjectTypeDescriptor.SpecialNewObjectAccessTitle     = NULL;

    if (fSacl)
        {
        PINFO(TEXT("Editing SACL..\r\n"));
        ApplicationAccesses.Count           = sizeof(KeyAudits)/sizeof(KeyAudits[0]);
        ApplicationAccesses.AccessGroup     = KeyAudits;
        }
    else
        {
        ApplicationAccesses.Count           = sizeof(KeyPerms)/sizeof(KeyPerms[0]);
        ApplicationAccesses.AccessGroup     = KeyPerms;
        // This corresponds to "Read and Link"
        ApplicationAccesses.DefaultPermName = KeyPerms[2].PermissionTitle;
        }


    // Load the permission names-- note ternary operator to give us
    // the AUDIT names if we're editing the SACL
    iFirst = fSacl ? IDS_AUDITNAMEFIRST : IDS_PERMNAMEFIRST;


    szPermNames = GlobalAlloc (LPTR,
                               ApplicationAccesses.Count
                               * MAX_PERMNAMELEN
                               * sizeof(WCHAR));

    if (!szPermNames)
        goto done;


    for (i=0; i<ApplicationAccesses.Count; i++)
        {
        ApplicationAccesses.AccessGroup[i].PermissionTitle
            = szPermNames + i * MAX_PERMNAMELEN;
        LoadStringW (hInst,
                     iFirst + i,
                     ApplicationAccesses.AccessGroup[i].PermissionTitle,
                     MAX_PERMNAMELEN - 1);
        }



    if (fSacl)
        {
        LPFNSACLEDIT lpfn;

        PINFO(TEXT("Finding SACL editor..\r\n"));

        if (hMod = LoadLibrary("ACLEDIT.DLL"))
            {
            if (lpfn = (LPFNSACLEDIT)GetProcAddress(hMod, "SedSystemAclEditor"))
                {
                SetCursor(LoadCursor(NULL, IDC_ARROW));

                PINFO(TEXT("Calling SACL editor..\r\n"));

                dwRtn = (*lpfn) (hWnd,                    // owner wnd
                                 hInst,                   // hinstance
                                 NULL,                    // Server (NULL means local)
                                 &ObjectTypeDescriptor,   // Object type
                                 &ApplicationAccesses,    // Access types.
                                 cbcontext.awchSName + 1, // Object name
                                 SedCallback,             // Apply security callback
                                 (ULONG_PTR)&cbcontext,   // Callback context
                                 pSD,                     // Points to current ACL
                                 (BOOLEAN)fCouldntRead,   // true if user can't read ACL list.
                                 &Status,                 // Status return code
                                 (DWORD)0);
                }
            else
                {
                MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            FreeLibrary(hMod);
            }
        else
            {
            MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
            }
        }
    else
        {
        LPFNDACLEDIT lpfn;

        PINFO(TEXT("Getting DACL edit \r\n"));

        if (hMod = LoadLibrary("ACLEDIT.DLL"))
            {
            if (lpfn = (LPFNDACLEDIT)GetProcAddress(hMod,
                  "SedDiscretionaryAclEditor"))
                {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
                dwRtn = (*lpfn) (hWnd,                    // owner wnd
                                 hInst,                   // hinstance
                                 NULL,                    // Server (NULL means local)
                                 &ObjectTypeDescriptor,   // Object type
                                 &ApplicationAccesses,    // Access types.
                                 cbcontext.awchSName + 1, // Object name
                                 SedCallback,             // Apply security callback
                                 (ULONG_PTR)&cbcontext,   // Callback context
                                 pSD,                     // Points to current ACL
                                 (BOOLEAN)fCouldntRead,   // true if user can't read ACL list.
                                 FALSE,                   // true if user can't write ACL list
                                 &Status,                 // Status return code
                                 0L);
                }
            FreeLibrary(hMod);
            }
        }



    PINFO(TEXT("ACL Editor returned status %ld, ret value %ld\r\n"), Status, dwRtn);

    fRet = TRUE;


    SendMessage (hWnd, WM_COMMAND, IDM_REFRESH, 0);






done:


    if (pSD)         LocalFree((HLOCAL)pSD);
    if (szPermNames) GlobalFree (szPermNames);


    SetCursor(LoadCursor(NULL, IDC_ARROW));

    AuditPrivilege(AUDIT_PRIVILEGE_OFF);


    return fRet;

}










/*
 *      EditOwner
 *
 *  Purpose: Edit ownership on the selected page.
 */

LRESULT EditOwner(void)
{
LPLISTENTRY             lpLE;
DWORD                   dwBAvail;
unsigned                iListIndex;
DWORD                   Status;
DWORD                   ret;
WCHAR                   ShareObjectName[100];
BOOL                    fCouldntRead;
BOOL                    fCouldntWrite;
DWORD                   dwSize;
HMODULE                 hMod;
SED_HELP_INFO           HelPINFO;
SEDCALLBACKCONTEXT      cbcontext;
PSECURITY_DESCRIPTOR    pSD = NULL;;




    iListIndex = (int)SendMessage(pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (iListIndex == LB_ERR)
        {
        PERROR(TEXT("Attempt to modify ownership with no item sel'ed\r\n"));
        goto done;
        }




    if (SendMessage ( pActiveMDI->hWndListbox, LB_GETTEXT, iListIndex, (LPARAM)(LPCSTR)&lpLE)
        == LB_ERR)
        {
        PERROR(TEXT("PermsEdit No text: %d\n\r"), iListIndex );
        goto done;
        }



    // Set up the callback context
    if (pActiveMDI->flags & F_LOCAL)
        {
        cbcontext.awchCName[0] = cbcontext.awchCName[1] = L'\\';
        dwBAvail = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerNameW(cbcontext.awchCName + 2, &dwBAvail);
        }
    else
        {
        #ifdef UNICODE
            lstrcpy (cbcontext.awchCName, pActiveMDI->szBaseName);
        #else
            MultiByteToWideChar (CP_ACP, 0, pActiveMDI->szBaseName, -1,
                                 cbcontext.awchCName, MAX_COMPUTERNAME_LENGTH + 1);
        #endif
        }



    // Get page name
    SendMessage(pActiveMDI->hWndListbox, LB_GETTEXT, iListIndex, (LPARAM)&lpLE);

    PINFO(TEXT("Getting page %s from server %ws\r\n"),
         lpLE->name, cbcontext.awchCName);

    #ifdef UNICODE
        lstrcpyW (cbcontext.awchSName, lpLE->name);
    #else
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpLE->name,
                             -1, cbcontext.awchSName, 100);
    #endif

    #ifndef USETWOSHARESPERPAGE
        cbcontext.awchSName[0] = L'$';
    #endif

    cbcontext.si = OWNER_SECURITY_INFORMATION;




    // Get object name

    LoadStringW(hInst, IDS_CB_PAGE, ShareObjectName, 99);



    // Get owner

    dwSize = 0L;

    PINFO(TEXT("Getting secinfo for %ls ! %ls\r\n"),
          cbcontext.awchCName,
          cbcontext.awchSName);

    NDdeGetShareSecurityW (cbcontext.awchCName,
                           cbcontext.awchSName,
                           OWNER_SECURITY_INFORMATION,
                           pSD,
                           0L,
                           &dwSize);


    if (!(pSD = LocalAlloc(LPTR, min(dwSize, 65535L))))
        {
        PERROR(TEXT("Couldn't get current owner (%ld bytes)!\r\n"), dwSize);
        }




    PINFO(TEXT("Getting owner on %ls ! %ls..\r\n"),
          cbcontext.awchCName, cbcontext.awchSName);

    ret = NDdeGetShareSecurityW(
          cbcontext.awchCName,
          cbcontext.awchSName,
          OWNER_SECURITY_INFORMATION,
          pSD,
          dwSize,
          &dwSize);

    if (NDDE_NO_ERROR == ret)
        {
        DWORD adwTrust[3];

        fCouldntRead = FALSE;

        NDdeGetTrustedShareW(
              cbcontext.awchCName,
              cbcontext.awchSName,
              adwTrust, adwTrust + 1, adwTrust + 2);

        ret = NDdeSetShareSecurityW(
              cbcontext.awchCName,
              cbcontext.awchSName,
              OWNER_SECURITY_INFORMATION,
              pSD);

        if (NDDE_NO_ERROR == ret)
            {
            NDdeSetTrustedShareW (cbcontext.awchCName,
                                  cbcontext.awchSName,
                                  adwTrust[0]);

            fCouldntWrite = FALSE;
            }
        }
    else
        {
        PERROR(TEXT("Couldn't get owner (err %d)!\r\n"), ret);
        fCouldntRead = TRUE;
        // We just set fCouldntWrite to FALSE if we couldn't read,
        // 'cause the only way to find out if we could would be
        // to overwrite the current ownership info (and we DON'T
        // KNOW WHAT IT IS!!)
        fCouldntWrite = FALSE;
        }

    HelPINFO.pszHelpFileName = L"CLIPBRD.HLP";
    HelPINFO.aulHelpContext[ HC_MAIN_DLG ] = IDH_OWNER;

    if (hMod = LoadLibrary("ACLEDIT.DLL"))
        {
        LPFNOWNER lpfn;

        if (lpfn = (LPFNOWNER)GetProcAddress(hMod, "SedTakeOwnership"))
            {
            ret = (*lpfn)(
               hwndApp,
               hInst,
               cbcontext.awchCName,
               ShareObjectName,
               cbcontext.awchSName + 1,
               1,
               SedCallback,
               (ULONG_PTR)&cbcontext,
               fCouldntRead ? NULL : pSD,
               (BOOLEAN)fCouldntRead,
               (BOOLEAN)fCouldntWrite,
               &Status,
               &HelPINFO,
               0L);
            }
        else
            {
            PERROR(TEXT("Couldn't get proc!\r\n"));
            }
        FreeLibrary(hMod);
        }
    else
        {
        PERROR(TEXT("Couldn't loadlib!\r\n"));
        }


    PINFO(TEXT("Ownership edited. Ret code %d, status %d\r\n"), ret, Status);

    LocalFree((HLOCAL)pSD);



done:

    return 0L;

}











/*
 *      Properties
 *
 *  Purpose: Change the properties of a share by displaying the Properties
 *     dialog and applying the changes the user makes to the share.
 *
 *  Parameters:
 *     hwnd - Parent window for the properties dialog
 *     lpLE - The entry we're messing with.
 *
 *  Returns:
 *     0L always. We don't return an error code because we handle informing
 *     the user of errors inside the routine.
 */

LRESULT Properties(
    HWND        hwnd,
    PLISTENTRY  lpLE)
{
PNDDESHAREINFO  lpDdeI;
LRESULT         ret;
WORD            wAddlItems;
DWORD           dwRet;
TCHAR           szBuf[MAX_PAGENAME_LENGTH + 32];
BOOL            fAlreadyShared;
DWORD           adwTrust[3];





    PINFO(TEXT("Props "));

    lpDdeI = GlobalAllocPtr(GHND, 2048 * sizeof(TCHAR));

    if (!lpDdeI)
        {
        PERROR(TEXT("GlobalAllocPtr failed\n\r"));
        return 0L;
        }




    // Use "shared" version of name, 'cause that's the way the DDE
    // share is named.
    fAlreadyShared = IsShared(lpLE);
    SetShared (lpLE, TRUE);

    PINFO(TEXT("for share [%s]"), lpLE->name);
    wAddlItems = 0;
    ret = NDdeShareGetInfo (NULL,
                            lpLE->name,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            &dwRet,
                            &wAddlItems );




    if (!fAlreadyShared)
        {
        SetShared(lpLE, FALSE);
        }




    PINFO(TEXT(" GetInfo ret %ld\r\n"), ret);

    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID(hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME, MB_OK | MB_ICONHAND);
        }
    else if (ret != NDDE_NO_ERROR)
        {
        PERROR(TEXT("Error from NDdeShareGetInfo %d\n\r"), ret );
        //MessageBoxID ( hInst, hwndApp, IDS_SHARINGERROR, IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK);
        NDdeMessageBox ( hInst,
                         hwndApp,
                         (UINT)ret,
                         IDS_SHAREDLGTITLE,
                         MB_ICONHAND | MB_OK);
        }
    else if (ret == NDDE_NO_ERROR)
        {
        PINFO(TEXT("Dialog "));

        // Put up the properties dialog
        dwCurrentHelpId = 0;            //  F1 will be context sensitive
        ret = DialogBoxParam (hInst,
                              fAlreadyShared?
                               MAKEINTRESOURCE(IDD_PROPERTYDLG):
                               MAKEINTRESOURCE(IDD_SHAREDLG),
                              hwnd,
                              ShareDlgProc,
                              (LPARAM)lpDdeI );

        dwCurrentHelpId = 0;



        // If the user hit OK, try to apply the changes asked for.
        if (ret)
            {
            PINFO(TEXT("OK "));

            // Change static app/topic to $<pagename> form
            if (!fAlreadyShared)
                {
                register LPTSTR lpOog;

                lpOog = lpDdeI->lpszAppTopicList;

                // Jump over the first two NULL chars you find-- these
                // are the old- and new-style app/topic pairs, we don't
                // mess with them. Then jump over the next BAR_CHAR you find.
                // The first character after that is the first char of the
                // static topic-- change that to a SHR_CHAR.

                while (*lpOog++) ;
                while (*lpOog++) ;


                // FEATURE: TEXT('|') should == BAR_CHAR. If not, this needs to
                // be adjusted.

                while (*lpOog++ != TEXT('|')) ;


                *lpOog = SHR_CHAR;
                }


            lpDdeI->fSharedFlag = 1L;

            // Get current trusted status
            if (NDDE_NO_ERROR != NDdeGetTrustedShare (NULL,
                                                      lpDdeI->lpszShareName,
                                                      adwTrust,
                                                      adwTrust + 1,
                                                      adwTrust + 2))
                {
                adwTrust[0] = 0;
                }



            DumpDdeInfo(lpDdeI, NULL);
            ret = NDdeShareSetInfo (NULL,
                                    lpDdeI->lpszShareName,
                                    2,
                                    (LPBYTE)lpDdeI,
                                    2048 * sizeof(TCHAR),
                                    0);


            if (NDDE_ACCESS_DENIED == ret)
                {
                MessageBoxID(hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
                }
            else if (NDDE_NO_ERROR != ret)
                {
                PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
                //MessageBoxID ( hInst, hwndApp, IDS_SHARINGERROR,
                //    IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
                NDdeMessageBox (hInst, hwndApp, (UINT)ret,
                                IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
                }
            else
                {
                NDdeSetTrustedShare(NULL, lpDdeI->lpszShareName, adwTrust[0]);

                #if 0
                // If the page wasn't already shared, and the user hasn't
                // changed the permissions, then we should update the permissions
                // from 'CreatorAll' to 'CreatorAll WorldRL'. (Of course,
                // if the user DID change permissions, we need to respect that
                // and NOT change them.)
                if (!fAlreadyShared)
                    {
                    PSECURITY_DESCRIPTOR pSD;
                    DWORD dwSize;
                    TCHAR atch[2048];
                    BOOL  fDacl, fDefault;
                    PACL  pacl;

                    SetShared(lpLE, TRUE);

                    pSD = atch;
                    if (NDDE_NO_ERROR == NDdeGetShareSecurity(NULL,
                          lpDdeI->lpszShareName,
                          DACL_SECURITY_INFORMATION, pSD, 2048 * sizeof(TCHAR),
                          &dwSize))
                        {
                        if (GetSecurityDescriptorDacl(pSD, &fDacl, &pacl, &fDefault))
                            {
                            if (fDefault || !fDacl)
                                {
                                if (InitializeShareSD(&pSD))
                                    {
                                    DWORD dwTrust[3];

                                    NDdeGetTrustedShare (NULL,
                                                         lpDdeI->lpszShareName,
                                                         dwTrust,
                                                         dwTrust + 1,
                                                         dwTrust + 2);

                                    NDdeSetShareSecurity (NULL,
                                                          lpDdeI->lpszShareName,
                                                          DACL_SECURITY_INFORMATION,
                                                          pSD);

                                    NDdeSetTrustedShare (NULL,
                                                         lpDdeI->lpszShareName,
                                                         dwTrust[0]);

                                    LocalFree(pSD);
                                    }
                                }
                            }
                        }
                    }
                #endif



                ///////////////////////////////////////////////
                // do the execute to change the server state
                lstrcat(lstrcpy(szBuf,SZCMD_SHARE), lpLE->name);
                PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

                if (MySyncXact ((LPBYTE)szBuf,
                                lstrlen(szBuf) +1,
                                GETMDIINFO(hwndLocal)->hExeConv,
                                0L,
                                CF_TEXT,
                                XTYP_EXECUTE,
                                SHORT_SYNC_TIMEOUT,
                                NULL))
                    {

                    // 368989 : lpLE may be bogus (freed memory) after this call.
                    // SetShared(lpLE, TRUE);

                    // if (pMDI->DisplayMode == DSP_PREV)
                    //    {
                    //    InvalidateRect(pMDI->hWndListbox, NULL, FALSE);
                    //    }
                    // else
                    //    {
                    //    SendMessage(pMDI->hWndListbox,LB_SETCURSEL, tmp, 0L);
                    //    UpdateNofMStatus ( hwndLocal );
                    //    }
                    InitializeMenu(GetMenu(hwndApp));
                    }
                else
                    {
                    XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                    }
                }
            }
        else if (!fAlreadyShared)  // User hit cancel on the dialog, restore the original shared state
            {
            SetShared(lpLE, FALSE);
            }
        }


    GlobalFreePtr(lpDdeI);



    return 0L;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\shares.h ===
/*****************************************************************************

                            S H A R E S   H E A D E R

    Name:       shares.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for shares.c

*****************************************************************************/


#if DEBUG

void DumpDdeInfo(
    PNDDESHAREINFO  pDdeI,
    LPTSTR          lpszServer);

#else
#define DumpDdeInfo(x,y)
#endif


LRESULT EditPermissions(
    BOOL    fSacl);


BOOL WINAPI EditPermissions2(
    HWND        hWnd,
    LPTSTR      pShareName,
    BOOL        fSacl);;


LRESULT EditOwner(void);


LRESULT Properties(
    HWND        hwnd,
    PLISTENTRY  lpLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\clipfile.c ===
/*****************************************************************************

                                C L I P F I L E

    Name:       clipfile.c
    Date:       19-Apr-1994
    Creator:    Unknown

    Description:
        Windows Clipboard File I/O Routines.

        NOTE:
          When saving the contents of the clipboard we SetClipboardData(fmt, NULL)
          to free up the memory associated with each clipboard format.  Then
          after we are done saving we take over as the clipboard owner.  This
          causes OWNERDRAW formats to be lost in the save process.

    History:
        19-Apr-1994 John Fu     Add code to make CF_BITMAP available when
                                there's CF_DIB.
                                Add CF_UNICODETEXT in GetClipboardName.
                                Fix AddNetInfoToClipboard not to dereference
                                GlobalLock(hData) when it's NULL.

        16-Jun-1994 John Fu     Fix SaveClipboardData() so when CF_DIB exists
                                in clipboard, CF_BITMAP will not be converted.

        08-Jul-1994 John Fu     Fix call to RenderFormatDibToBitmap to use
                                palette from file.

        13-Mar-1995 John Fu     Fix computer name buffer size.

        15-Mar-1995 John Fu     Add GetClipboardData to make sure CF_DIB
                                really exists.

*****************************************************************************/





#include <windows.h>
#include <windowsx.h>
#include <string.h>

#include "common.h"
#include "clipfile.h"
#include "clipfile.h"
#include "dib.h"
#include "debugout.h"
#include "render.h"
#include "security.h"




#define ARRAYSIZE(a)        (sizeof(a)/sizeof((a)[0]))



BOOL    fAnythingToRender;

TCHAR   szFileSpecifier[] = TEXT("*.CLP");
TCHAR   szFileName[MAX_PATH+1];
TCHAR   szSaveFileName[MAX_PATH+1];     // Saved filename for delayed render

BOOL    fNTReadFileFormat;
BOOL    fNTSaveFileFormat;

UINT    cf_link;
UINT    cf_objectlink;
UINT    cf_linkcopy;
UINT    cf_objectlinkcopy;





BOOL    AddDIBtoDDB(VOID);







/*******************

 File read routines

*******************/





/*
 *      ReadFileHeader
 *
 *  Purpose: Read the file header in the given .clp file, and get the number
 *     of formats. Also sets the fNTReadFileFormat flag appropriately.
 *
 *  Parameters:
 *     fh - Handle to the file.
 *
 *  Returns:
 *     The number of formats, or 0 if it isn't a valid .clp file.
 */

unsigned ReadFileHeader(
    HANDLE  fh)
{
FILEHEADER  FileHeader;
DWORD       dwBytesRead;


    // PINFO(TEXT("ClSrv\\RdFileHdr"));

    /* Read the File Header */
    SetFilePointer(fh, 0, NULL, FILE_BEGIN);
    ReadFile(fh, &FileHeader, sizeof(FileHeader), &dwBytesRead, NULL);

    if (dwBytesRead == sizeof(FILEHEADER))
        {
        // Make sure that this is a .CLP file
        if (FileHeader.magic == CLPBK_NT_ID ||
            FileHeader.magic == CLP_NT_ID)
            {
            fNTReadFileFormat = TRUE;
            }
        else if (FileHeader.magic == CLP_ID)
            {
            fNTReadFileFormat = FALSE;
            }
        else
            {
            PERROR(TEXT("Invalid magic member (not long enough?)\r\n"));
            FileHeader.FormatCount = 0;
            }

        // Check number of formats for additional reassurance.
        if (FileHeader.FormatCount > 100)
            {
            PERROR(TEXT("Too many formats!!!\r\n"));
            FileHeader.FormatCount = 0;
            }
        }
    else
        {
        PERROR("Read err\r\n");
        FileHeader.FormatCount = 0;
        }

    if (FileHeader.FormatCount)
        {
        // PINFO(TEXT("\r\n"));
        }


    return(FileHeader.FormatCount);

}







/*
 *      ReadFormatHeader
 */

BOOL ReadFormatHeader(
    HANDLE          fh,
    FORMATHEADER    *pfh,
    unsigned        iFormat)
{
DWORD           dwMrPibb;
OLDFORMATHEADER OldFormatHeader;



    // PINFO(TEXT("ClSrv\\RdFmtHdr"));

    if (NULL == pfh || NULL == fh)
        {
        PERROR("RdFmtHdr got NULL pointer\r\n");
        return FALSE;
        }

    SetFilePointer (fh,
                    sizeof(FILEHEADER) + iFormat *
                      (fNTReadFileFormat ? sizeof(FORMATHEADER) : sizeof(OLDFORMATHEADER)),
                    NULL,
                    FILE_BEGIN);

    if (fNTReadFileFormat)
        {
        ReadFile(fh, pfh, sizeof(FORMATHEADER), &dwMrPibb, NULL);

        if (dwMrPibb != sizeof(FORMATHEADER))
            {
            PERROR(TEXT("Bad new format rd\r\n"));
            return FALSE;
            }
        }
    else
        {
        ReadFile(fh, &OldFormatHeader, sizeof(OldFormatHeader), &dwMrPibb, NULL);

        if (dwMrPibb != sizeof(OLDFORMATHEADER))
            {
            PERROR(TEXT("Bad old format rd\r\n"));
            return FALSE;
            }

        pfh->FormatID   = OldFormatHeader.FormatID;
        pfh->DataLen    = OldFormatHeader.DataLen;
        pfh->DataOffset = OldFormatHeader.DataOffset;

        MultiByteToWideChar (CP_ACP,
                             MB_PRECOMPOSED,
                             OldFormatHeader.Name,
                             -1,
                             pfh->Name,
                             CCHFMTNAMEMAX);
        }

    // PINFO(TEXT("\r\n"));
    return TRUE;


}







/*
 *      ReadClipboardFromFile()
 *
 *  Read in a clipboard file and register all the formats in delayed mode.
 *  to render things for real reopen the file specified by ofStruct.
 *
 *  NOTE:
 *     This makes us the clipboard owner.
 *
 *  Bug 14564:  Changed return value to a short integer noting why the
 *  reading failed.
 *  Return Value:   READFILE_IMPROPERFORMAT
 *                  READFILE_OPENCLIPBRDFAIL
 *                  READFILE_SUCCESS
 */


short ReadClipboardFromFile(
    HWND    hwnd,
    HANDLE  fh)
{
register unsigned   i;
unsigned            cFormats;
FORMATHEADER        FormatHeader;



    PINFO(TEXT("Entering ReadClipboardFromFile\r\n"));

    if (!(cFormats = ReadFileHeader(fh)) )
        {
        return(READFILE_IMPROPERFORMAT);
        }


    /* We become the clipboard owner here! */
    if (!SyncOpenClipboard(hwnd))
        {
        PERROR(TEXT("Could not open clipboard!!!"));
        return(READFILE_OPENCLIPBRDFAIL);
        }

    EmptyClipboard();

    for (i=0; i < cFormats; i++)
        {
        ReadFormatHeader (fh, &FormatHeader, i);

        if (PRIVATE_FORMAT(FormatHeader.FormatID))
            {
            FormatHeader.FormatID = RegisterClipboardFormatW ((LPWSTR)FormatHeader.Name);
            }

        /*Delayed Render. */
        PINFO(TEXT("Set up delayed render for format %d .\r\n"), FormatHeader.FormatID);
        SetClipboardData (FormatHeader.FormatID, NULL);


        if (FormatHeader.FormatID == CF_DIB)
            SetClipboardData (CF_BITMAP, NULL);
        }




    /* Now, clipbrd viewer has something to render */
    if (cFormats > 0)
        {
        PINFO(TEXT("fAnythingToRender = TRUE\r\n"));
        fAnythingToRender = TRUE;
        }

    SyncCloseClipboard();

    return(READFILE_SUCCESS);

}







/*
 *      OpenClipboardFile
 */

DWORD OpenClipboardFile(
    HWND    hwnd,
    LPTSTR  szName)
{
HANDLE  fh;
DWORD   dwErr = NO_ERROR;


    PINFO(TEXT("OpenClipboardFile: %s \r\n"),szName);

    fh = CreateFile ((LPCTSTR)szName,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (fh != INVALID_HANDLE_VALUE)
        {
        // Store file name for delayed rendering stuff.
        lstrcpy(szSaveFileName, szName);

        // Read it.
        switch (ReadClipboardFromFile (hwnd, fh))
            {
            case READFILE_IMPROPERFORMAT:
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            case READFILE_OPENCLIPBRDFAIL:
                dwErr = ERROR_CLIPBOARD_NOT_OPEN;
                break;
            case READFILE_SUCCESS:
            default:
                dwErr = NO_ERROR;
                break;
            }
        CloseHandle (fh);
        }
    else
        {
        PERROR(TEXT("ClSrv\\OpClpFile: can't open file!"));
        dwErr = GetLastError ();
        }

    return dwErr;

}






/*
 *      RenderFormatFormFile
 *
 *  Purpose: Go get the given format from the given file.
 */

HANDLE RenderFormatFromFile(
    LPTSTR  szFile,
    WORD    wFormat)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData = NULL;
unsigned        cFormats;
unsigned        i;
BOOL            bHasDib = FALSE;


    PINFO(TEXT("ClSrv\\RndrFmtFromFile: Opening file %s.\r\n"),szSaveFileName);

    fh = CreateFile (szFile,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (INVALID_HANDLE_VALUE == fh)
        {
        PERROR(TEXT("Can't open file\r\n"));
        goto done;
        }


    cFormats = ReadFileHeader(fh);


    // If ReadFile didn't get the whole header, don't try to read anything
    // else.
    if (0 == cFormats)
        {
        PERROR(TEXT("Bad file header.\r\n"));
        goto done;
        }


    for (i=0; i < cFormats; i++)
        {
        ReadFormatHeader(fh, &FormatHeader, i);

        PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

        if (PRIVATE_FORMAT(FormatHeader.FormatID))
            {
            FormatHeader.FormatID = RegisterClipboardFormatW(FormatHeader.Name);
            }

        if (FormatHeader.FormatID == wFormat)
            {
            hData = RenderFormat(&FormatHeader, fh);
            }

        if (FormatHeader.FormatID == CF_DIB)
            bHasDib = TRUE;
        }



    // JYF make CF_BITMAP available when there's CF_DIB

    if (!hData && wFormat == CF_BITMAP && bHasDib)
        {
        if (SetFilePointer (fh, 0, 0, FILE_BEGIN) == 0xFFFFFFFF)
            {
            PERROR(TEXT("Cannot set file pointer to FILE_BEGIN\n"));
            goto done;
            }


        cFormats = ReadFileHeader (fh);

        for (i=0; i < cFormats; i++)
            {
            ReadFormatHeader (fh, &FormatHeader, i);

            PINFO (TEXT("Got format %ws\n"), FormatHeader.Name);

            if (FormatHeader.FormatID == CF_DIB)
                hData = RenderFormatDibToBitmap (&FormatHeader,
                                                 fh,
                                                 RenderFormatFromFile (szFile, CF_PALETTE));
            }
        }



done:

    if (fh != INVALID_HANDLE_VALUE)
        CloseHandle (fh);

    return(hData);

}





/*
 *      RenderAllFromFile
 *
 *  Purpose: Go get all formats from the given file.
 */

HANDLE RenderAllFromFile(
    LPTSTR  szFile)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData;
unsigned        cFormats;
unsigned        i;


    /* Check if the clipbrd viewer has done any File I/O before.
     * If it has not, then it has nothing to render!  Sankar
     */
    if (CountClipboardFormats() && fAnythingToRender)
        {
        /* Empty the clipboard */
        if (!SyncOpenClipboard(hwndApp))
            {
            PERROR("Couldn't open clipboard!\r\n");
            }
        else
            {
            EmptyClipboard();

            fh = CreateFile (szFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

            if (INVALID_HANDLE_VALUE != fh)
                {
                cFormats = ReadFileHeader(fh);

                // If ReadFile didn't get the whole header, don't try to read anything
                // else.
                if (0 == cFormats)
                    {
                    PERROR(TEXT("Bad file header.\r\n"));
                    }

                for (i=0; i < cFormats; i++)
                    {
                    ReadFormatHeader(fh, &FormatHeader, i);

                    PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

                    if (PRIVATE_FORMAT(FormatHeader.FormatID))
                        {
                        FormatHeader.FormatID =
                           RegisterClipboardFormatW(FormatHeader.Name);
                        }

                    // Render the format and set it into the clipboard
                    hData = RenderFormat(&FormatHeader, fh);
                    if ( hData != NULL )
                        {
                        if (!SetClipboardData(FormatHeader.FormatID, hData))
                            {
                            PERROR(TEXT("SetClipboardData fail\n\r"));
                            }
                        }
                    else
                        {
                        PERROR(TEXT("hData == NULL, bad\r\n"));
                        }
                    }
                CloseHandle(fh);
                }
            else
                {
                PERROR(TEXT("Can't open file\r\n"));
                }

            SyncCloseClipboard();
            }
        }

    return(0L);


}














/********************

 File write routines

********************/






/*
 *      IsWriteable()
 *
 *  Test if a clipboard format is writeable(i.e. if it makes sense to write it)
 *  OWNERDRAW and others can't be written because we (CLIPBRD) will become the
 *  owner when the files are reopened.
 */

BOOL IsWriteable(WORD Format)

{
    /* Are the PRIVATEFIRST and PRIVATELAST things right? */
    if ((Format >= CF_PRIVATEFIRST && Format <= CF_PRIVATELAST)
          || Format == CF_OWNERDISPLAY)
        {
        return FALSE;
        }

    // If we're not saving an NT clipboard, don't save NT-specific formats.
    if (!fNTSaveFileFormat &&
        (Format == CF_UNICODETEXT || Format == CF_ENHMETAFILE
         || Format == CF_DSPENHMETAFILE)
       )
        {
        return(FALSE);
        }

    return(TRUE);
}






/*
 *      Count16BitClipboardFormats
 *
 *  This function will return the number of clipboard formats compatible with
 *  the Windows 3.1 clipboard, this excludes CF_UNICODETEXT, CF_ENHMETAFILE and
 *  CF_DSPENHMETAFILE
 */

int Count16BitClipboardFormats(void)
{
int iCount;

    iCount = CountClipboardFormats();

    if (IsClipboardFormatAvailable(CF_UNICODETEXT))
        iCount--;

    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        iCount--;

    if (IsClipboardFormatAvailable(CF_DSPENHMETAFILE))
        iCount--;

    return iCount;

}







/*
 *      WriteFormatBlock
 *
 *  Purpose: Writes the format header for a single data format.
 *
 *  Parameters:
 *   fh - File handle to write to.
 *   offset - Position in the file to write the format block.
 *   DataOffset - Position in the file where the data for this format will be.
 *   DataLen    - Length of the data for this format.
 *   Format     - The format number.
 *   szName     - Name of the format.
 *
 *  Returns:
 *   The number of bytes written to the file.
 */

DWORD WriteFormatBlock(
    HANDLE  fh,
    DWORD   offset,
    DWORD   DataOffset,
    DWORD   DataLen,
    UINT    Format,
    LPWSTR  wszName)
{
DWORD   dwBytesWritten = 0;


    SetFilePointer(fh, offset, NULL, FILE_BEGIN);

    if (fNTSaveFileFormat)
        {
        FORMATHEADER    FormatHeader;

        memset (&FormatHeader, 0, sizeof(FormatHeader));

        FormatHeader.FormatID   = Format;
        FormatHeader.DataLen    = DataLen;
        FormatHeader.DataOffset = DataOffset;

        lstrcpyW(FormatHeader.Name, wszName);
        WriteFile (fh, &FormatHeader, sizeof(FormatHeader), &dwBytesWritten, NULL);
        }
    else
        {
        OLDFORMATHEADER OldFormatHeader;

        memset(&OldFormatHeader,0, sizeof(OldFormatHeader));

        OldFormatHeader.FormatID   = (WORD)Format;
        OldFormatHeader.DataLen    = DataLen;
        OldFormatHeader.DataOffset = DataOffset;

        WideCharToMultiByte(CP_ACP,
                            0,
                            wszName,
                            -1,
                            OldFormatHeader.Name,
                            CCHFMTNAMEMAX,
                            NULL,
                            NULL);
        WriteFile (fh,
                   &OldFormatHeader,
                   sizeof(OldFormatHeader),
                   &dwBytesWritten,
                   NULL);
        }

    return(dwBytesWritten);

}





/*
 *      WriteDataBlock() -
 *
 *  Returns:
 *     # of bytes written to the output file
 *
 *  NOTE: Write saves the name of a temp file in the clipboard for it's
 *  own internal clipboard format.  This file goes aways when Write
 *  (or windows?) shuts down.  Thus saving Write clipboards won't work
 *  (should we special case hack this?)
 *
 */

DWORD WriteDataBlock(
    register HANDLE hFile,
    DWORD           offset,
    WORD            Format)
{
WORD            wPalEntries;
LPSTR           lpData;
DWORD           dwSize = 0;
BITMAP          bitmap;
HANDLE          hMF;
HANDLE          hBitmap;
register HANDLE hData;
LPLOGPALETTE    lpLogPalette;
LPMETAFILEPICT  lpMFP;
DWORD           dwMFPSize;
BOOL            fOK = FALSE;


    if (!(hData = GetClipboardData(Format)) ||
        SetFilePointer (hFile, offset, NULL, FILE_BEGIN) != offset)
        {
        PERROR(TEXT("WriteDataBlock: couldn't get format data\n\r"));
        return 0;
        }



    /* We have to special case a few common formats but most things
     * get handled in the default case.
     */

    switch (Format)
        {
        case CF_ENHMETAFILE:
            dwSize = (DWORD) GetEnhMetaFileBits(hData, 0, NULL); /* Get data size */

            if (lpData = GlobalAllocPtr(GHND, dwSize))   /* allocate mem for EMF bits */
                {
                if (GetEnhMetaFileBits(hData, dwSize, (LPBYTE)lpData))
                    {
                    WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
                    fOK = TRUE;
                    }
                GlobalFreePtr(lpData);
                }

            if (!fOK)
                {
                PERROR(TEXT("WriteDataBlock: couldn't write CF_ENHMETAFILE\r\n"));
                dwSize = 0;
                }
            break;

        case CF_METAFILEPICT:
            if (lpMFP = (LPMETAFILEPICT)GlobalLock(hData)) /* get header */
                {
                // Write METAFILEPICT header -- if we're saving in Win31 format,
                // write the old-style header.
                if (fNTSaveFileFormat)
                    {
                    WriteFile(hFile, lpMFP, sizeof(METAFILEPICT),
                        &dwMFPSize, NULL);
                    }
                else
                    {
                    WIN31METAFILEPICT w31mfp;
                    /* If we save the metafile in the Windows 3.1 .CLP file format
                       we have to save the METAFILEPICT structure as a 16bit METAFILEPICT
                       structure. This may cause loss of information if the
                       high half of the METAFILEPICT structure's fields are used.
                       [pierrej 5/27/92]                                        */

                    w31mfp.mm   = (WORD)lpMFP->mm;
                    w31mfp.xExt = (WORD)lpMFP->xExt;
                    w31mfp.yExt = (WORD)lpMFP->yExt;
                    w31mfp.hMF  = (WORD)0;

                    WriteFile(hFile, &w31mfp, sizeof(WIN31METAFILEPICT), &dwMFPSize, NULL);
                    }

                hMF = lpMFP->hMF;

                GlobalUnlock(hData);            /* unlock the header */

                /* Figure out how big a block we need */
                dwSize = GetMetaFileBitsEx(hMF, 0, NULL);
                if (dwSize)
                    {
                    if (lpData = GlobalAllocPtr(GHND, dwSize))
                        {
                        if (dwSize == GetMetaFileBitsEx(hMF, dwSize, lpData))
                            {
                            WriteFile(hFile, lpData, dwSize, &dwSize, NULL);

                            dwSize += dwMFPSize;
                            }
                        else
                            {
                            dwSize = 0;
                            }

                        GlobalFreePtr(lpData);
                        }
                    else
                        {
                        dwSize = 0;
                        }
                    }
                }
            break;

        case CF_BITMAP:

            /* Writing DDBs to disk is bad. Therefore, we */
            /* write an intelligent CF_DIB block instead.    */
            /* A-MGATES 9/29/92                              */

            Format = CF_DIB;

            GetObject((HBITMAP)hData, sizeof(BITMAP), &bitmap);

            if (hBitmap = DibFromBitmap ((HBITMAP)hData,
                                         BI_RGB,
                                         (WORD) (bitmap.bmBitsPixel * bitmap.bmPlanes),
                                         IsClipboardFormatAvailable(CF_PALETTE) ?
                                           GetClipboardData(CF_PALETTE) : NULL))
               {
               if (lpData = GlobalLock(hBitmap))
                   {
                   // dwSize might be too big, but we can live with that.
                   dwSize = (DWORD)GlobalSize(lpData);

                   WriteFile(hFile, lpData, dwSize, &dwSize, NULL);

                   // Clean up
                   GlobalUnlock(hBitmap);
                   GlobalFree(hBitmap);
                   }
               }
            break;

        case CF_PALETTE:
            /* Get the number of palette entries */
            GetObject(hData, sizeof(WORD), (LPBYTE)&wPalEntries);

            /* Allocate enough place to build the LOGPALETTE struct */
            dwSize = (DWORD)(sizeof(LOGPALETTE) +
                 (LONG)wPalEntries * sizeof(PALETTEENTRY));
            if (lpLogPalette = (LPLOGPALETTE)GlobalAllocPtr(GHND, dwSize))
                {
                lpLogPalette->palVersion = 0x300;      /* Windows 3.00 */
                lpLogPalette->palNumEntries = wPalEntries;

                if (GetPaletteEntries(hData, 0, wPalEntries,
                   (LPPALETTEENTRY)(lpLogPalette->palPalEntry)) != 0)
                    {
                    /* Write the LOGPALETTE structure onto disk */
                    WriteFile(hFile, lpLogPalette, dwSize, &dwSize, NULL);
                    }
                else
                    {
                    dwSize = 0;
                    }

                GlobalFreePtr(lpLogPalette);
                }
            else
                {
                dwSize = 0L;
                }
            break;

        default:
            dwSize = (DWORD)GlobalSize(hData);

            // Just lock the data down and write it out.
            if (lpData = GlobalLock(hData))
                {
                WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
                GlobalUnlock(hData);
                }
            else
                {
                dwSize = 0;
                }

            break;
            }


    /* Return the number of bytes written. */
    return(dwSize);


}









/*
 *      GetClipboardNameW
 */

void GetClipboardNameW(
    register int    fmt,
    LPWSTR          wszName,
    register int    iSize)
{
LPWSTR  lprgch = NULL;
HANDLE  hrgch  = NULL;


    *wszName = '\0';


    /* Get global memory that everyone can get to */
    if (!(hrgch = GlobalAlloc(GMEM_MOVEABLE, (LONG)(iSize + 1)*sizeof(WCHAR))))
        {
        PERROR(TEXT("GetClipboardNameW: bad alloc\r\n"));
        goto done;
        }


    if (!(lprgch = (LPWSTR)GlobalLock(hrgch)))
       {
       PERROR(TEXT("GetClipboardNameW: bad lock\r\n"));
       goto done;
       }


    memset(lprgch, 0, (iSize+1)*sizeof(WCHAR));

    switch (fmt)
        {
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_TEXT:
        case CF_BITMAP:
        case CF_METAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_OEMTEXT:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPTEXT:
        case CF_DSPBITMAP:
        case CF_DSPMETAFILEPICT:
        case CF_DSPENHMETAFILE:
        case CF_UNICODETEXT:
            LoadStringW(hInst, fmt, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            // Note: This should NEVER happen because this function only gets
            // called when we're writing a given clipboard format. Clipbrd can't
            // get away with writing CF_OWNERDISPLAY because we become clipboard
            // owner when we re-read the file, and we won't know how to deal.

            PERROR(TEXT("GetClipboardName on OwnerDisplay format!\r\n"));

            // *lprgch = '\0';
            // SendOwnerMessageW(WM_ASKCBFORMATNAME, iSize, (LPARAM)lprgch);

            // if (!*lprgch)

            LoadStringW(hInst, fmt, lprgch, iSize);
            break;

        default:
            GetClipboardFormatNameW(fmt, lprgch, iSize);
            break;
        }

    lstrcpyW(wszName, lprgch);


done:

    if (lprgch) GlobalUnlock(hrgch);
    if (hrgch)  GlobalFree(hrgch);

}







/*
 *      SaveClipboardData() - Writes a clipboard file.
 *
 *  In:
 *     hwnd        handle of wnd that becomes the clipboard owner
 *     szFileName  file handle to read from
 *     fPage       TRUE if this is a clipbook page (which means we secure it)
 *
 *  NOTE:
 *     When done we call ReadClipboardFromFile(). this makes us the
 *     clipboard owner.
 *
 *  Returns:
 *      NO_ERROR if no error otherwise an error code.
 */

DWORD SaveClipboardData(
    HWND    hwnd,
    LPTSTR  szFileName,
    BOOL    fPage)
{
register HANDLE fh;
register WORD   Format;

SECURITY_ATTRIBUTES sa;

DWORD       HeaderPos;
DWORD       DataPos;
DWORD       datasize;
HCURSOR     hCursor;
FILEHEADER  FileHeader;
// Must be  WCHAR... it be format name!
WCHAR       wszName[CCHFMTNAMEMAX];
UINT        wHeaderSize;
UINT        uiSizeHeaderToWrite;
BOOL        fDIBUsed = FALSE;
DWORD       dwTemp;
DWORD       dwRet = NO_ERROR;



    /* First open the clipboard */
    if (!SyncOpenClipboard(hwndApp))
        return ERROR_CLIPBOARD_NOT_OPEN;


    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = (fPage ? CurrentUserOnlySD() : NULL);
    sa.bInheritHandle = FALSE;

    fh = CreateFile((LPCTSTR)szFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
               &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fh == INVALID_HANDLE_VALUE)
        {
        PERROR ("Error opening clipboard file!\r\n");
        dwRet = GetLastError ();
        goto done;
        }




    /* Fill out the file header structure */
    if (fNTSaveFileFormat)
        {
        FileHeader.magic = CLPBK_NT_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = sizeof(FORMATHEADER);
        }
    else
        {
        FileHeader.magic = CLP_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = sizeof(OLDFORMATHEADER);
        }


    FileHeader.FormatCount = 0;          /* dummy for now */

    /* Update HeaderPos and DataPos */
    HeaderPos = sizeof(FILEHEADER);

    /* This is the maximum number of formats that will be written.  Potentially
     * some may fail and some space will be wasted.
     */
    if (fNTSaveFileFormat)
        {
        DataPos = HeaderPos + (uiSizeHeaderToWrite * CountClipboardFormats());
        }
    else
        {
        DataPos = HeaderPos + (uiSizeHeaderToWrite * Count16BitClipboardFormats());
        }


   /* Now loop throught the data, one format at a time, and write out the data. */
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);


    /* Enumerate all formats */
    Format = 0;

    while ((Format = (WORD)EnumClipboardFormats(Format)))
        {
        if (IsWriteable(Format))
            {

            // DO NOT write CF_BITMAP to disk. Transform to CF_DIB
            // and write that instead.

            // If there's CF_DIB, then don't do CF_BITMAP

            if (CF_BITMAP == Format)
                if (IsClipboardFormatAvailable (CF_DIB)
                    && GetClipboardData (CF_DIB))
                    continue;   // We have DIB, don't worry about BITMAP.


            if (CF_BITMAP == Format || CF_DIB == Format)
                {
                if (!fDIBUsed)
                    fDIBUsed = TRUE;
                else
                    // Already done DIB, go on to the next format.
                    continue;
                }


            GetClipboardNameW (Format == CF_BITMAP ? CF_DIB : Format,
                               wszName,
                               ARRAYSIZE(wszName));


            PINFO(TEXT("SClipboardData: writing %ls (#)%d\r\n"), wszName,Format);

            if (datasize = WriteDataBlock(fh, DataPos, Format))
                {
                /* Create a Format header and write it to the file */
                wHeaderSize = (WORD)WriteFormatBlock (fh,
                                                      HeaderPos,
                                                      DataPos,
                                                      datasize,
                                                      Format == CF_BITMAP ? CF_DIB : Format,
                                                      wszName);
                if (wHeaderSize < uiSizeHeaderToWrite)
                    {
                    PERROR(TEXT("SaveClipboardData: error writing format block\n\r"));
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                    }
                HeaderPos += wHeaderSize;

                /* Update the data pos for the next block */
                DataPos += datasize;

                FileHeader.FormatCount++;   /* this format has been written */
                }
            else
                {
                //JYF PERROR(TEXT("SaveClipboardData: error writing data block\n\r"));
                //JYF dwRet = ERROR_NOT_ENOUGH_MEMORY;
                //JYF break;
                }
            }
        }


    ShowCursor(FALSE);
    SetCursor(hCursor);

    SyncCloseClipboard();      /* we are done looking at this */


    // Go back and write the file header at the front of the file
    SetFilePointer (fh, 0L, NULL, FILE_BEGIN);

    if (!WriteFile (fh, &FileHeader, sizeof(FileHeader), &dwTemp, NULL))
        dwRet = GetLastError ();


    /* Now we open the clipboard and become the owner.  this places
     * all the things we just saved in the clipboard (and throws out
     * those things we didn't save)
     */

    // Set us back to the beginning
    SetFilePointer(fh, 0L, NULL, FILE_BEGIN);

    /* Under NT, the save filename will be used to get the file back */
    lstrcpy(szSaveFileName, szFileName);

    PINFO(TEXT("sAVEcLIPBOARDdATA: Copied name %s to name %s\r\n"), szSaveFileName, szFileName);
    fNTReadFileFormat = fNTSaveFileFormat;

    if (dwRet == NO_ERROR) //bRet)
        {
        //bRet = !ReadClipboardFromFile(hwndApp, fh);
        switch (ReadClipboardFromFile (hwndApp, fh))
            {
            case READFILE_IMPROPERFORMAT:
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                break;
            case READFILE_OPENCLIPBRDFAIL:
                dwRet = ERROR_CLIPBOARD_NOT_OPEN;
                break;
            case READFILE_SUCCESS:
            default:
                dwRet = NO_ERROR;
                break;
            }
        }

    CloseHandle(fh);

    if (dwRet != NO_ERROR)
        {
        PERROR(TEXT("SCD: Trouble in ReadClipboardFromFile\r\n"));
        DeleteFile(szFileName);
        }




done:

    if (sa.lpSecurityDescriptor)
        {
        GlobalFree((HGLOBAL)sa.lpSecurityDescriptor);
        }


    SyncCloseClipboard();


    return dwRet;

}




/*
 *      SaveClipboardToFile() -
 *  Parameters:
 *     hwnd - Passed to SaveClipboardData
 *     szShareName - Clipbook page name
 *     szFileName  - Filename to save to
 *     fPage - TRUE if this is a clbook page, FALSE if a file saved
 *        by the user.
 *
 *  Returns: NO_ERROR if no error occured otherwise an error code.
 *
 */

DWORD SaveClipboardToFile(
    HWND    hwnd,
    TCHAR   *szShareName,
    TCHAR   *szFileName,
    BOOL    fPage)
{
DWORD   dwErr = NO_ERROR;

    PINFO(TEXT("\r\n Entering SaveClipboardToFile\r\n"));
    if (fPage)
        {
        AddNetInfoToClipboard( szShareName );
        AddPreviewFormat();
        }


    dwErr = SaveClipboardData(hwnd, szFileName, fPage);

    if (dwErr != NO_ERROR)
        {
        /* If Failure, Delete the incomplete file */
        PERROR(TEXT("SaveClipboardData failed!"));
        DeleteFile(szSaveFileName);
        }

    return dwErr;

}









/*
 *      AddPreviewFormat
 */

BOOL AddPreviewFormat (VOID)
{
LPMETAFILEPICT  lpMF;
HANDLE          hClpData;
HANDLE          hBmpData;
HBITMAP         hBitmap;
HBITMAP         hClpBmp;
HBITMAP         hOldDstBmp;
HBITMAP         hOldSrcBmp;
BITMAP          Bitmap;
HDC             hDC;
HDC             hDstDC;
HDC             hSrcDC;
LPBYTE          lpBmp;
int             ret = FALSE;
RECT            rc;
int             OldMode;



    if (!IsClipboardFormatAvailable(CF_TEXT)         &&
        !IsClipboardFormatAvailable(CF_BITMAP)       &&
        !IsClipboardFormatAvailable(CF_METAFILEPICT) &&
        !IsClipboardFormatAvailable(CF_ENHMETAFILE)  &&
        !IsClipboardFormatAvailable(CF_UNICODETEXT))
        return FALSE;


    if ( !SyncOpenClipboard(hwndApp))
        return FALSE;


    if ( !(hBmpData = GlobalAlloc ( GHND, 64 * 64 / 8 )) )
        {
        SyncCloseClipboard();
        return FALSE;
        }


    hDC = GetDC ( hwndApp );
    hDstDC = CreateCompatibleDC ( hDC );
    hSrcDC = CreateCompatibleDC ( hDC );
    ReleaseDC ( hwndApp, hDC );

    if ( !( hBitmap = CreateBitmap ( 64, 64, 1, 1, NULL )) )
        PERROR (TEXT("CreateBitmap failed\n\r"));


    hOldDstBmp = SelectObject ( hDstDC, hBitmap );

    rc.top = rc.left = 0;
    rc.bottom = rc.right = 64;


    PatBlt ( hDstDC, 0, 0, 64, 64, WHITENESS );



    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        {
        HENHMETAFILE hemf;
        ENHMETAHEADER enheader;

        if (hemf = (HENHMETAFILE)GetClipboardData(CF_ENHMETAFILE))
            {
            GetEnhMetaFileHeader(hemf, sizeof(enheader), &enheader);

            SaveDC(hDstDC);
            SetMapMode( hDstDC, MM_ISOTROPIC);
            SetViewportExtEx(hDstDC, 64, 64, NULL);
            SetWindowExtEx(hDstDC, enheader.rclBounds.right, enheader.rclBounds.bottom, NULL);
            PlayEnhMetaFile(hDstDC, hemf, (LPRECT)&enheader.rclBounds);
            RestoreDC(hDstDC, -1);
            }
        else
            {
            PERROR(TEXT("GetClipboardData fail on CF_ENHMETAFILE\r\n"));
            }
        }
    else if ( IsClipboardFormatAvailable ( CF_METAFILEPICT ))
        {
        if ( hClpData = GetClipboardData ( CF_METAFILEPICT ))
            {
            if ( lpMF = (LPMETAFILEPICT)GlobalLock ( hClpData ) )
                {
                SaveDC(hDstDC);
                SetMapMode( hDstDC, lpMF->mm);
                if ( lpMF->xExt >= lpMF->yExt )
                    {
                    SetViewportExtEx( hDstDC, 64,
                       (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt), NULL);
                    SetViewportOrgEx ( hDstDC, 0,
                       (64 - (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt))
                       / 2, NULL );
                    }
                else
                    {
                    SetViewportExtEx( hDstDC,
                       (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt),64, NULL);
                    SetViewportOrgEx( hDstDC,
                       ( 64 - (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt))
                       / 2, 0, NULL);
                    }
                if ( !PlayMetaFile ( hDstDC, lpMF->hMF ))
                    PERROR(TEXT("playmetafile failed\n\r"));
                GlobalUnlock ( hClpData );
                RestoreDC( hDstDC, -1 );
                }
            else
               PERROR(TEXT("couldn't LOCK it though...\n\r"));
            }
        else
           PERROR(TEXT("couldn't GET it though...\n\r"));
        }
    else if ( IsClipboardFormatAvailable ( CF_BITMAP ))
        {
        if ( hClpBmp = GetClipboardData ( CF_BITMAP ))
            {
            GetObject ( hClpBmp, sizeof(BITMAP), &Bitmap );
            hOldSrcBmp = SelectObject ( hSrcDC, hClpBmp );
            OldMode = SetStretchBltMode ( hDstDC, COLORONCOLOR);
            StretchBlt ( hDstDC, 0, 0, 64, 64,
                     hSrcDC, 0, 0, Bitmap.bmWidth, Bitmap.bmHeight,
                     SRCCOPY );
            SetStretchBltMode ( hDstDC, OldMode );
            SelectObject ( hSrcDC, hOldSrcBmp );
            }
        }
    else if ( IsClipboardFormatAvailable ( CF_TEXT ))
        {
        LPSTR lpText;
        HFONT hSmallFont, hOldFont;

        if ( hClpData = GetClipboardData ( CF_TEXT ))
            {
            lpText = (LPSTR)GlobalLock ( hClpData );
            FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
            hSmallFont = CreateFont( -6,
               0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
               CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
               VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
               );
            hOldFont = SelectObject ( hDstDC, hSmallFont );
            DrawTextA( hDstDC,lpText, lstrlenA(lpText),
               &rc, DT_LEFT);
            SelectObject ( hDstDC, hOldFont );
            DeleteObject ( hSmallFont );
            GlobalUnlock ( hClpData );
            }
        }
    else if ( IsClipboardFormatAvailable (CF_UNICODETEXT))
        {
        LPWSTR lpText;
        HFONT hSmallFont, hOldFont;

        if ( hClpData = GetClipboardData ( CF_UNICODETEXT ))
            {
            lpText = (LPWSTR)GlobalLock ( hClpData );
            FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
            hSmallFont = CreateFont( -6,
               0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
               CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
               VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
               );
            hOldFont = SelectObject ( hDstDC, hSmallFont );
            DrawTextW( hDstDC,lpText, lstrlenW(lpText),
               &rc, DT_LEFT);
            SelectObject ( hDstDC, hOldFont );
            DeleteObject ( hSmallFont );
            GlobalUnlock ( hClpData );
            }
        }

    SelectObject ( hDstDC, hOldDstBmp );
    DeleteDC ( hDstDC );
    DeleteDC ( hSrcDC );

    lpBmp = GlobalLock ( hBmpData );

    if ( GetBitmapBits ( hBitmap, 64 * 64 / 8, lpBmp ) != 64*64/8 )
//      if ( GetBitmapBits ( hBitmap, 64 * 64 / 2, lpBmp ) != 64*64/2 )
        PERROR(TEXT("GetBitmapBits failed\n\r"));

    GlobalUnlock ( hBmpData );

    SetClipboardData ( cf_preview, hBmpData );
    ret = TRUE;

    DeleteObject ( hBitmap );
    SyncCloseClipboard();


    return ret;

}









/*
 *      AddCopiedFormat
 */

BOOL AddCopiedFormat (
    UINT    ufmtOriginal,
    UINT    ufmtCopy)
{
LPBYTE  lpOriginal;
LPBYTE  lpCopy;
HANDLE  hOriginal;
HANDLE  hCopy = NULL;
BOOL    ret = FALSE;
int     i;


    if (IsClipboardFormatAvailable(ufmtOriginal) && SyncOpenClipboard(hwndApp))
        {
        if ( hOriginal = GetClipboardData(ufmtOriginal))
            {
            if ( hCopy = GlobalAlloc( GHND, GlobalSize(hOriginal)))
                {
                if ( lpOriginal = GlobalLock(hOriginal))
                    {
                    if ( lpCopy = GlobalLock (hCopy))
                        {

                        for ( i=(int)GlobalSize(hOriginal); i--; )
                            *lpCopy++ = *lpOriginal++;
                        GlobalUnlock(hCopy);

                        #ifdef DEBUG
                         lpCopy = GlobalLock(hCopy);
                         GlobalUnlock(hCopy);
                        #endif

                        ret = ( SetClipboardData ( ufmtCopy, hCopy ) != NULL );
                        }
                    GlobalUnlock(hOriginal);
                    }
                }
            }
        SyncCloseClipboard();
        }


    if ( !ret )
        {
        PERROR(TEXT("AddCopiedFormat returning FALSE!\n\r"));
        if ( hCopy )
            GlobalFree (hCopy);
        }

    return ret;


}







/*
 *      AddNetInfoToClipboard
 */

BOOL AddNetInfoToClipboard (
    TCHAR   *szShareName )
{
HANDLE  hData;
HANDLE  hNewData;
TCHAR   szServerName[MAX_COMPUTERNAME_LENGTH + 1];
DWORD   dwNameLen;
LPTSTR  src;
LPTSTR  dst;



    cf_link           = RegisterClipboardFormat (SZLINK);
    cf_linkcopy       = RegisterClipboardFormat (SZLINKCOPY);
    cf_objectlink     = RegisterClipboardFormat (SZOBJECTLINK);
    cf_objectlinkcopy = RegisterClipboardFormat (SZOBJECTLINKCOPY);



    // check to see if this info already added:
    if (IsClipboardFormatAvailable (cf_linkcopy))
        {
        PINFO(TEXT("AddNetInfo: Already added\n\r"));
        return FALSE;
        }




    if (IsClipboardFormatAvailable (cf_link))
        {
        AddCopiedFormat (cf_link, cf_linkcopy);

        if (!SyncOpenClipboard (hwndApp))
           return (FALSE);

        dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName (szServerName, &dwNameLen);

        PINFO(TEXT("link data found\n\r"));


        if (hData = GetClipboardData (cf_link))
            {
            if (src = GlobalLock (hData))
                {
                hNewData = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                        GlobalSize(hData)
                                        +lstrlen (szServerName)
                                        +lstrlen (szShareName)
                                        +3);

                dst = GlobalLock (hNewData);

                wsprintf (dst, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$"));
                dst += lstrlen(dst) + 1;

                lstrcpy ( dst, szShareName );
                *dst = SHR_CHAR;
                lstrcat ( dst, TEXT(".dde") );
                //lstrcat (dst, TEXT(".ole"));
                dst += lstrlen(dst) + 1;

                src += lstrlen(src) + 1;
                src += lstrlen(src) + 1;

                lstrcpy ( dst, src );

                GlobalUnlock (hData);
                GlobalUnlock (hNewData);

                SetClipboardData (cf_link, hNewData);
                }
            }

        SyncCloseClipboard ();
        }



    if (IsClipboardFormatAvailable (cf_objectlink))
        {
        AddCopiedFormat (cf_objectlink, cf_objectlinkcopy);

        if (!SyncOpenClipboard (hwndApp))
            return (FALSE);

        dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName (szServerName, &dwNameLen);

        PINFO(TEXT("objectlink data found\n\r"));

        if (hData = GetClipboardData (cf_objectlink))
            {
            if (src = GlobalLock (hData))
                {
                hNewData = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                        GlobalSize (hData)
                                        +lstrlen (szServerName)
                                        +lstrlen (szShareName)
                                        +3);

                dst = GlobalLock (hNewData);

                wsprintf(dst, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$"));
                dst += lstrlen(dst) + 1;

                lstrcpy (dst, szShareName);

                *dst = SHR_CHAR;
                lstrcat (dst, TEXT(".ole"));
                dst += lstrlen(dst) + 1;

                src += lstrlen(src) + 1;
                src += lstrlen(src) + 1;

                lstrcpy (dst, src);

                GlobalUnlock (hData);
                GlobalUnlock (hNewData);

                SetClipboardData (cf_objectlink, hNewData);
                }
            }

        SyncCloseClipboard ();
        }


    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\strtok.h ===
/*****************************************************************************

                            S T R T O K   H E A D E R

    Name:       strtok.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for strtok.c

*****************************************************************************/



BOOL IsInAlphaA(
    char    ch);


BOOL IsInAlphaW(
    WCHAR   ch);


LPSTR strtokA(
    LPSTR   lpchStart,
    LPCSTR  lpchDelimiters);


LPWSTR strtokW(
    LPWSTR  lpchStart,
    LPCWSTR lpchDelimiters);


TCHAR *ltoa(
    long        l,
    TCHAR       *ptch,
    unsigned    uRadix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\clipfile.h ===
/******************************************************************************

                    C L I P F I L E   H E A D E R

    Name:       clipfile.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for clipfile.c

******************************************************************************/




#define READFILE_SUCCESS         0
#define READFILE_IMPROPERFORMAT  1
#define READFILE_OPENCLIPBRDFAIL 2





extern  BOOL    fAnythingToRender;

extern  TCHAR   szFileSpecifier[];
extern  TCHAR   szFileName[MAX_PATH+1];
extern  TCHAR   szSaveFileName[MAX_PATH+1];     // Saved filename for delayed render

extern  BOOL    fNTReadFileFormat;
extern  BOOL    fNTSaveFileFormat;

extern  UINT    cf_link;
extern  UINT    cf_objectlink;
extern  UINT    cf_linkcopy;
extern  UINT    cf_objectlinkcopy;



extern TCHAR szCaptionName[];




extern  HANDLE RenderFormat(FORMATHEADER *, register HANDLE);


// winball additions

extern  BOOL AddNetInfoToClipboard (TCHAR *);
extern  BOOL AddPreviewFormat (VOID);
extern  BOOL AddCopiedFormat (UINT ufmtOriginal, UINT ufmtCopy);
extern  BOOL AddDIBtoDDB(VOID);

// end winball





// Functions


unsigned ReadFileHeader(
    HANDLE  fh);


BOOL ReadFormatHeader(
    HANDLE          fh,
    FORMATHEADER    *pfh,
    unsigned        iFormat);


short ReadClipboardFromFile(
    HWND    hwnd,
    HANDLE  fh);


DWORD OpenClipboardFile(
    HWND    hwnd,
    LPTSTR  szName);


HANDLE RenderFormatFromFile(
    LPTSTR  szFile,
    WORD    wFormat);


HANDLE RenderAllFromFile(
    LPTSTR  szFile);


BOOL IsWriteable(
    WORD Format);


int Count16BitClipboardFormats(void);


DWORD WriteFormatBlock(
    HANDLE  fh,
    DWORD   offset,
    DWORD   DataOffset,
    DWORD   DataLen,
    UINT    Format,
    LPWSTR  wszName);


DWORD WriteDataBlock(
    register HANDLE hFile,
    DWORD           offset,
    WORD            Format);


void GetClipboardNameW(
    register int    fmt,
    LPWSTR          wszName,
    register int    iSize);


DWORD SaveClipboardData(
    HWND    hwnd,
    LPTSTR  szFileName,
    BOOL    fPage);


DWORD SaveClipboardToFile(
    HWND    hwnd,
    TCHAR   *szShareName,
    TCHAR   *szFileName,
    BOOL    fPage);


BOOL AddPreviewFormat (VOID);


BOOL AddCopiedFormat (
    UINT    ufmtOriginal,
    UINT    ufmtCopy);


BOOL AddNetInfoToClipboard (
    TCHAR   *szShareName );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\strtok.c ===
/*****************************************************************************

                                S T R T O K

    Name:       strtok.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains functions for string manipulations.

    History:
        21-Jan-1994     John Fu, cleanup and reformat

*****************************************************************************/



#include <windows.h>
#include "clipbook.h"
#include "strtok.h"




static LPCSTR   lpchAlphaDelimiters;
static LPCWSTR  lpwchAlphaDelimiters;



/*
 *      IsInAlphaA
 */

BOOL IsInAlphaA(
    char    ch)
{
LPCSTR lpchDel = lpchAlphaDelimiters;

    if (ch)
        {
        while (*lpchDel)
            {
            if (ch == *lpchDel++)
                {
                return TRUE;
                }
            }
        }
    else
        {
        return TRUE;
        }

    return FALSE;

}





/*
 *      IsInAlphaW
 */

BOOL IsInAlphaW(
    WCHAR   ch)
{
LPCWSTR lpchDel = lpwchAlphaDelimiters;

    if (ch)
        {
        while (*lpchDel)
            {
            if (ch == *lpchDel++)
                {
                return TRUE;
                }
            }
        }
    else
        {
        return TRUE;
        }

    return FALSE;

}





/*
 *      strtokA
 */

LPSTR strtokA(
    LPSTR   lpchStart,
    LPCSTR  lpchDelimiters)
{
static LPSTR lpchEnd;



    // PINFO("sTRTOK\r\n");

    if (NULL == lpchStart)
        {
        if (lpchEnd)
            {
            lpchStart = lpchEnd + 1;
            }
        else
            {
            return NULL;
            }
        }


    // PINFO("sTRING: %s\r\n", lpchStart);

    lpchAlphaDelimiters = lpchDelimiters;

    if (*lpchStart)
        {
        while (IsInAlphaA(*lpchStart))
            {
            lpchStart++;
            }

        // PINFO("Token: %s\r\n", lpchStart);

        lpchEnd = lpchStart;
        while (*lpchEnd && !IsInAlphaA(*lpchEnd))
            {
            lpchEnd++;
            }

        if (*lpchEnd)
            {
            // PINFO("Found tab\r\n");
            *lpchEnd = '\0';
            }
        else
            {
            // PINFO("Found null\r\n");
            lpchEnd = NULL;
            }
        }
    else
        {
        lpchEnd = NULL;
        return NULL;
        }

    // PINFO("Returning %s\r\n", lpchStart);

    return lpchStart;

}








/*
 *      strtokW
 */

LPWSTR strtokW(
    LPWSTR  lpchStart,
    LPCWSTR lpchDelimiters)
{
static LPWSTR lpchEnd;

    if (NULL == lpchStart)
        {
        if (lpchEnd)
            {
            lpchStart = lpchEnd + 1;
            }
        else
            {
            return NULL;
            }
        }

    lpwchAlphaDelimiters = lpchDelimiters;

    if (*lpchStart)
        {
        while (IsInAlphaW(*lpchStart))
            {
            lpchStart++;
            }

        lpchEnd = lpchStart;
        while (*lpchEnd && !IsInAlphaW(*lpchEnd))
            {
            lpchEnd++;
            }

        if (*lpchEnd)
            {
            *lpchEnd = '\0';
            }
        else
            {
            lpchEnd = NULL;
            }
        }
    else
        {
        lpchEnd = NULL;
        return NULL;
        }

    return lpchStart;
}






/*
 *      ltoa
 *
 *  Purpose: Look, it's ltoa, OK? GO READ K&R.
 *
 *  Parameters: GO READ K&R, YOU SCUM!
 *
 *  Returns: READ K&R! READ K&R! READ K&R! Oh, okay... Returns ptch.
 */

TCHAR *_ltoa(
    long        l,
    TCHAR       *ptch,
    unsigned    uRadix)
{
TCHAR   rgtchDigits[]=TEXT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");



    if (uRadix < 37)
        {
        unsigned long ul;
        
        if (10 == uRadix && l < 0)
            {
            *ptch++ = TEXT('-');
            ul = (unsigned long)(l = -l); // l==0x8000000000000....
            }
        else
            {
            ul = (unsigned long)l;
            }

        // For non-decimal numbers, print all digits.
        if (10 != uRadix)
            {
            l = ((~0L)>>1);
            }

        while (l > 0)
            {
            l /= uRadix;
            ptch++;
            }
        *ptch-- = TEXT('\0');

        do
            {
            *ptch-- = rgtchDigits[ul % uRadix];
            ul /= uRadix;
            } while (ul > 0);

        }
    else
        {
        *ptch = TEXT('\0');
        }


    return(ptch);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\vclpbrd.h ===
/*****************************************************************************

                    V C L I P B O A R D   H E A D E R

    Name:       vclpbrd.H
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for vclpbrd.c

*****************************************************************************/




#ifndef	VCLPBRD_INCLUDED
#define VCLPBRD_INCLUDED

#define	CCHMAXCLPFORMAT	79

struct VClipBrdEntry {
   UINT   Fmt;
   HANDLE Data;
   struct VClipBrdEntry * Next;
   };


typedef struct VClipBrdEntry  VCLPENTRY;
typedef struct VClipBrdEntry * PVCLPENTRY;
typedef struct VClipBrdEntry far * LPVCLPENTRY;


struct VClipBrd {
   int        NumFormats;
   BOOL       fOpen;
   PVCLPENTRY Head;
   PVCLPENTRY Tail;
   HWND Hwnd;
   };


typedef struct VClipBrd VCLPBRD;
typedef struct VClipBrd * PVCLPBRD;
typedef struct VClipBrd far * LPVCLPBRD;





PVCLPBRD CreateVClipboard (
    HWND    hwnd);


BOOL DestroyVClipboard (
    PVCLPBRD    p);


int VCountClipboardFormats (
    PVCLPBRD    p);


BOOL VEmptyClipboard (
    PVCLPBRD    p);


UINT VEnumClipboardFormats(
    PVCLPBRD    p,
    UINT        Fmt);


HANDLE VGetClipboardData(
    PVCLPBRD    pvclp,
    UINT        Fmt);


BOOL VIsClipboardFormatAvailable(
    PVCLPBRD    p,
    UINT        Fmt);


HANDLE VSetClipboardData(
    PVCLPBRD    p,
    UINT        Fmt,
    HANDLE      Data);


BOOL VOpenClipboard(
    PVCLPBRD    p,
    HWND        hwnd);


BOOL VCloseClipboard(
    PVCLPBRD    p);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\clipview\vclpbrd.c ===
/*****************************************************************************

                        V I R T U A L   C L I P B O A R D

    Name:       vclpbrd.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the virtual clipboard routines.

    History:
        21-Jan-1994 John Fu     Reformat and cleanup
        19-Apr-1994 John Fu     Add code for DIB to BITMAP conversion.
        13-Mar-1995 John Fu     Fix code to delete clipboard formats.

*****************************************************************************/




#define   WIN31
#include <windows.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "vclpbrd.h"
#include "clipdsp.h"
#include "ddeml.h"
#include "debugout.h"
#include "cvutil.h"




/*
 *      CreateVClipboard
 */

PVCLPBRD CreateVClipboard (
    HWND    hwnd)
{
PVCLPBRD p;



    if ( !( p = (PVCLPBRD)GlobalAlloc ( GPTR, sizeof(VCLPBRD) )))
        {
        PERROR(TEXT("CreateVClipboard returning 0\n\r"));
        return NULL;
        }

    p->NumFormats = 0;
    p->Head       = (PVCLPENTRY)NULL;
    p->Tail       = (PVCLPENTRY)NULL;
    p->fOpen      = FALSE;
    p->Hwnd       = hwnd;


    // PINFO(TEXT("CreateVClipboard OK\n\r"));

    return p;

}







/*
 *      DestroyVClipboard
 */

BOOL DestroyVClipboard (
    PVCLPBRD    p)
{

    if (!p)
        {
        PERROR(TEXT("DestroyVClipboard on NULL Vclipboard\n\r"));
        return FALSE;
        }

    if (VEmptyClipboard ( p ) == FALSE)
        {
        PERROR(TEXT("DestroyVClipboard: couldn't empty Vclipboard\n\r"));
        return FALSE;
        }

    if (GlobalFree ( (HGLOBAL)p ))
        {
        PERROR(TEXT("DestroyVClipboard: GlobalFree failure\n\r"));
        return FALSE;
        }


    // PINFO(TEXT("DestroyVClipboard OK\n\r"));

    return TRUE;

}





/*
 *      VCountClipboardFormats
 */

int VCountClipboardFormats (
    PVCLPBRD    p)
{
    if ( !p )
        return CountClipboardFormats();

    return p->NumFormats;
}







/*
 *      VEmptyClipboard
 */

BOOL VEmptyClipboard (
    PVCLPBRD    p)
{
PVCLPENTRY q, tmp;

    if ( !p )
        return EmptyClipboard();

    for ( q = p->Head; q; )
        {
        tmp = q->Next;

        if ( q->Data )
            switch ( q->Fmt )
                {
                case CF_BITMAP:
                case CF_DIB:
                case CF_PALETTE:
                    DeleteObject ( q->Data );
                    break;

                case CF_METAFILEPICT:
                case CF_ENHMETAFILE:
                    DeleteEnhMetaFile (q->Data);
                    break;

                default:
                    GlobalFree ( q->Data );
                }

        GlobalFree ( (HGLOBAL)q );

        q = tmp;
        }

    p->NumFormats = 0;

    return TRUE;

}






/*
 *      VEnumClipboardFormats
 */

UINT VEnumClipboardFormats(
    PVCLPBRD    p,
    UINT        Fmt)
{
PVCLPENTRY q;

    if ( !p )
        return EnumClipboardFormats ( Fmt );

    if ( !p->fOpen )
        return 0;

    if ( Fmt == 0 )
        return (p->Head)->Fmt;

    for (q = p->Head; q; q = q->Next)
        if ( q->Fmt == Fmt )
            {
            if ( q->Next )
                return q->Next->Fmt;
            else
                return 0;
            }

    return 0;

}












/*
 *      VGetClipboardData
 */

HANDLE VGetClipboardData (
    PVCLPBRD    pvclp,
    UINT        Fmt )
{
PVCLPENTRY  pEntry;
HSZ         hszFmt;
TCHAR       szFmt[CCHMAXCLPFORMAT];
HDDEDATA    hFmtData;
HANDLE      hClipData;
DWORD       dwR;



    PINFO(TEXT("VGetClpData: %ld %d, "), pvclp, Fmt);

    if ( !pvclp )
        {
        if (IsClipboardFormatAvailable( Fmt ))
            {
            hClipData = GetClipboardData ( Fmt );
            if (!hClipData)
                dwR = GetLastError();
            return hClipData;
            }
        else
            {
            PINFO(TEXT("No data on clp\r\n"));
            return NULL;
            }
        }

    if ( !pvclp->fOpen )
        {
        PERROR(TEXT("!pvclp->fOpen\r\n"));
        return NULL;
        }

    for ( pEntry = pvclp->Head; pEntry; pEntry = pEntry->Next )
        {
        if ( pEntry->Fmt == Fmt )
            {
            if ( pEntry->Data )
                {
                // PINFO(TEXT("pEntry->Data\r\n"));
                }
            else
                {
                // if (LockApp(TRUE, szGettingData ))
                //    {
                // this is the biggie...
                GetClipboardName (Fmt, szFmt, sizeof (szFmt));

                PINFO(TEXT("Asking for %s.\r\n"),szFmt);
                if (hszFmt = DdeCreateStringHandle(idInst, szFmt, 0))
                    {
                    hFmtData = MySyncXact (NULL,
                                           0L,
                                           GETMDIINFO(pvclp->Hwnd)->hVClpConv,
                                           hszFmt,
                                           MyGetFormat (szFmt, GETFORMAT_LIE),
                                           XTYP_REQUEST,
                                           LONG_SYNC_TIMEOUT,
                                           NULL);

                    if ( hFmtData )
                        {
                        PINFO(TEXT("Got it\r\n"));
                        SetClipboardFormatFromDDE(pvclp->Hwnd, Fmt, hFmtData);
                        }
                    else
                        {
                        PERROR(TEXT("REQUEST for %s failed %x\n\r"),
                               szFmt, DdeGetLastError(idInst));

                        VSetClipboardData(pvclp, Fmt, INVALID_HANDLE_VALUE);
                        // LockApp ( FALSE, szNull );
                        // MessageBoxID ( hInst, hwndApp, IDS_DATAUNAVAIL,
                        //    IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION );
                        }




                    DdeFreeStringHandle(idInst, hszFmt);


                    // can't find bitmap, see if we can get it from dib

                    if (!hFmtData && Fmt == CF_BITMAP)
                        {
                        GetClipboardName (CF_DIB, szFmt, sizeof(szFmt));

                        if (hszFmt = DdeCreateStringHandle (idInst, szFmt, 0))
                             {
                             hFmtData = MySyncXact (NULL,
                                                    0L,
                                                    GETMDIINFO(pvclp->Hwnd)->hVClpConv,
                                                    hszFmt,
                                                    MyGetFormat (szFmt, GETFORMAT_LIE),
                                                    XTYP_REQUEST,
                                                    LONG_SYNC_TIMEOUT,
                                                    NULL);

                            if (hFmtData)
                                SetClipboardFormatFromDDE(pvclp->Hwnd, DDE_DIB2BITMAP, hFmtData);

                            DdeFreeStringHandle(idInst, hszFmt);
                            }
                        }



                //      }
                //  LockApp ( FALSE, szNull );
                    }
                else
                    {
                    PERROR(TEXT("app locked in vgetclipboarddata\n\r"));
                    }
                }
            break;
            }
        }



    return (pEntry ?
             (INVALID_HANDLE_VALUE == pEntry->Data? NULL: pEntry->Data):
             NULL);

}





/*
 *      VIsClipboardFormatAvailable
 */

BOOL VIsClipboardFormatAvailable (
    PVCLPBRD    p,
    UINT        Fmt )
{
PVCLPENTRY  q;


    if ( !p )
        {
        return IsClipboardFormatAvailable ( Fmt );
        }
    else
        {
        for ( q = p->Head; q; q = q->Next )
            {
            if ( q->Fmt == Fmt )
                {
                return TRUE;
                }
            }
        }

    return FALSE;

}







/*
 *      VSetClipboardData
 */

HANDLE VSetClipboardData(
    PVCLPBRD    p,
    UINT        Fmt,
    HANDLE      Data)
{
PVCLPENTRY  q;

    if ( !p )
        {
        PINFO(TEXT("Setting real clipboard data \r\n"));
        return SetClipboardData ( Fmt, Data );
        }

    if ( !p->fOpen )
        {
        PERROR(TEXT("VSetClipboardData on non-open Vclipboard\n\r"));
        return NULL;
        }

    // existing format?
    for ( q = p->Head; q; q = q->Next )
        {
        if (q->Fmt == Fmt)
            {
            if (q->Data)
                {
                switch (Fmt)
                    {
                    case CF_BITMAP:
                    case CF_DIB:
                    case CF_PALETTE:
                        DeleteObject ( q->Data );
                        break;

                    case CF_METAFILEPICT:
                    case CF_ENHMETAFILE:
                        DeleteEnhMetaFile (q->Data);
                        break;

                    default:
                        GlobalFree ( q->Data );
                    }
                }

            q->Data = Data;

            PINFO(TEXT("VSetClipboardData: set same as existing format\n\r"));
            return Data;
            }
        }



    if (!(q = (PVCLPENTRY)GlobalAlloc (GPTR, sizeof (VCLPENTRY))))
        {
        PERROR(TEXT("VSetClipboardData: GlobalAlloc failed\n\r"));
        return NULL;
        }



    q->Next = NULL;

    q->Data = Data;
    q->Fmt = Fmt;

    if ( p->Tail )
        {
        p->Tail->Next = q;
        }


    p->Tail = q;

    if ( !p->Head )
       p->Head = q;



    p->NumFormats++;
    PINFO(TEXT("VSetClipboardData: set new format w/%ldn\r"), Data);

    return Data;

}






/*
 *      VOpenClipboard
 */

BOOL VOpenClipboard(
    PVCLPBRD    p,
    HWND        hwnd)
{
    if ( !p )
       {
       return SyncOpenClipboard ( hwnd );
       }
    else if ( p->fOpen )
       {
       return FALSE;
       }
    else
       {
       p->fOpen = TRUE;
       p->Hwnd = hwnd;
       return TRUE;
       }
}







/*
 *      VCloseClipboard
 */

BOOL VCloseClipboard(
    PVCLPBRD    p)
{
    if ( !p )
        return SyncCloseClipboard();

    if ( !p->fOpen )
        return FALSE;

    p->fOpen = FALSE;
    p->Hwnd  = (HWND)0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\debugout.c ===
/******************************************************************************

                        D E B U G   O U P U T

    Name:       debugout.c
    Date:       1/19/94
    Creator:    John Fu

    Description:
        This file contains debug output functions.


******************************************************************************/




#include    <windows.h>
#include    "debugout.h"






INT     DebugLevel = 0;
BOOL    DebugFile  = FALSE;




#if DEBUG


/*
 *      PERROR
 */

VOID PERROR (LPTSTR format, ...)
{
static  TCHAR buf[256];
HANDLE  hf;
DWORD   dwWritten;
va_list vaMark;


    if (DebugLevel <= 0)
        return;


    va_start(vaMark, format);
    wvsprintf( buf, format, vaMark);
    va_end(vaMark);



    OutputDebugString(buf);


    if (!DebugFile)
        return;


    hf = CreateFile (TEXT("c:\\clipsrv.out"),
                     GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hf != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hf, 0, NULL, FILE_END);
        WriteFile(hf, buf, lstrlen(buf), &dwWritten, NULL);
        CloseHandle(hf);
        }


}
#else
VOID PERROR (LPTSTR format, ...)
{
}
#endif





#ifdef DEBUG

VOID PINFO (LPTSTR format, ...)
{
static  TCHAR buf[256];
HANDLE  hf;
DWORD   dwWritten;
va_list vaMark;



    if (DebugLevel <= 1)
        return;

    va_start(vaMark, format);
    wvsprintf( buf, format, vaMark);
    va_end(vaMark);

    OutputDebugString(buf);


    if (!DebugFile)
        return;



    hf = CreateFile (TEXT("c:\\clipsrv.out"),
                     GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hf != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hf, 0, NULL, FILE_END);
        WriteFile(hf, buf, lstrlen(buf), &dwWritten, NULL);
        CloseHandle(hf);
        }

}
#else
VOID PINFO (LPTSTR format, ...)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\common.h ===
/*****************************************************************************

                        C O M M O N   H E A D E R

    Name:       common.h
    Date:       19-Apr-1994
    Creator:    John Fu

    Description:
        This is the header common to clipview and datasrv.

*****************************************************************************/



#define   PREVBMPSIZ   64   // dim of preview bitmap ( x and y )

// non localized control strings common to Clipsrv.exe and clipview.exe
#define     SZ_SRV_NAME         "ClipSrv"
#define     SZ_FORMAT_LIST      TEXT("FormatList")

#define     SZCMD_INITSHARE     TEXT("[initshare]")
#define     SZCMD_EXIT          TEXT("[exit]")
#define     SZCMD_PASTESHARE    TEXT("[pasteshare]")
#define     SZCMD_DELETE        TEXT("[delete]")
#define     SZCMD_SHARE         TEXT("[markshared]")
#define     SZCMD_UNSHARE       TEXT("[markunshared]")
#define     SZCMD_PASTE         TEXT("[paste]")
#define     SZCMD_SAVEAS        TEXT("[saveas]")
#define     SZCMD_OPEN          TEXT("[open]")
#define     SZCMD_DEBUG         TEXT("[debug]")



#define     MAX_CMD_LEN         30
#define     MAX_DDE_EXEC        (MAX_PATH +MAX_CMD_LEN +1)






// These commands are new for NT clipbook.
///////////////////////////////////////////////////////////////////////

// Requesting for error code after an XTYP_EXECUTE xtransaction
#define     SZ_ERR_REQUEST      TEXT("ErrorRequest")

#define     XERRT_MASK          0xF0        // use to mask the XERR types
#define     XERRT_SYS           0x10        // XERR type, a GetLastError error code
#define     XERRT_NDDE          0x20        // XERR type, a NDde error code
#define     XERRT_DDE           0x30        // XERR type, a DDE error code
#define     XERR_FORMAT         "%x %x"     // XERR format string, "error_type error_code"


// Save clipbrd file in Win 3.1 format
#define     SZCMD_SAVEASOLD     TEXT("[saveasold]")


// Version request - NT product 1 clipsrv will return 0x3010
#define     SZCMD_VERSION       TEXT("[Version]")


// Security information
#define     SZCMD_SECURITY      TEXT("[Security]")

#define     SHR_CHAR            TEXT('$')
#define     UNSHR_CHAR          TEXT('*')
#define     BOGUS_CHAR          TEXT('?')

#define     SZPREVNAME          TEXT("Clipbook Preview")
#define     SZLINK              TEXT("Link")
#define     SZLINKCOPY          TEXT("LnkCpy")
#define     SZOBJECTLINK        TEXT("ObjectLink")
#define     SZOBJECTLINKCOPY    TEXT("ObjLnkCpy")
#define     LSZOBJECTLINK       L"ObjectLink"
#define     LSZLINK             L"Link"

// The viewer and the server use this mutex name to avoid opening
// the clipboard at the same time.
#define     SZMUTEXCLP          TEXT("ClipbrdMutex")



// The Common globals

extern      HINSTANCE           hInst;
extern      UINT                cf_preview;
extern      HWND                hwndApp;




// added for winball - clausgi
extern UINT cf_link;
extern UINT cf_objectlink;
extern UINT cf_linkcopy;
extern UINT cf_objectlinkcopy;

// end additions

#define PRIVATE_FORMAT(fmt) ((fmt) >= 0xC000)




/* Dialogbox resource id */
#define ABOUTBOX        1
#define CONFIRMBOX  2



/* Other constants */
#define CDEFFMTS        8       /* Count of predifined clipboard formats    */
#define VPOSLAST        100     /* Highest vert scroll bar value */
#define HPOSLAST        100     /* Highest horiz scroll bar value */
#define CCHFMTNAMEMAX   79      /* Longest clipboard data fmt name, including
                                   terminator */
#define cLineAlwaysShow 3       /* # of "standard text height" lines to show
                                   when maximally scrolled down */
#define BUFFERLEN       160      /* String buffer length */
#define SMALLBUFFERLEN  90
#define IDSABOUT        1

#define CBMENU      1   /* Number for the Clipboard main menu  */

#define FILTERMAX   100     /* max len. of File/Open filter string */
#define CAPTIONMAX  30      /* len of caption text for above dlg.  */
#define PATHMAX     128     /* max. len of DOS pathname        */




/*  Last parameter to SetDIBits() and GetDIBits() calls */

#define  DIB_RGB_COLORS   0
#define  DIB_PAL_COLORS   1

#define  IDCLEAR    IDOK




/* Structures for saving/loading clipboard data from disk */

#define      CLP_ID  0xC350
#define   CLP_NT_ID  0xC351
#define CLPBK_NT_ID  0xC352

typedef struct
   {
   WORD        magic;
   WORD        FormatCount;
   } FILEHEADER;


// Format header
typedef struct
   {
   DWORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   WCHAR  Name[CCHFMTNAMEMAX];
   } FORMATHEADER;

// Windows 3.1-type structures - Win31 packed on byte boundaries.
#pragma pack(1)
typedef struct
   {
   WORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   char Name[CCHFMTNAMEMAX];
   } OLDFORMATHEADER;

// Windows 3.1 BITMAP struct - used to save Win 3.1 .CLP files
typedef struct {
   WORD bmType;
   WORD bmWidth;
   WORD bmHeight;
   WORD bmWidthBytes;
   BYTE bmPlanes;
   BYTE bmBitsPixel;
   LPVOID bmBits;
   } WIN31BITMAP;

// Windows 3.1 METAFILEPICT struct
typedef struct {
   WORD mm;
   WORD xExt;
   WORD yExt;
   WORD hMF;
   } WIN31METAFILEPICT;

#pragma pack()





/*****************************  global data  *******************************/
// extern OFSTRUCT  ofStruct;
extern HWND  hwndMain;
extern TCHAR szAppName[];
extern TCHAR szFileSpecifier[];

/* variables for the new File Open,File SaveAs and Find Text dialogs */

extern TCHAR  szSaveFileName [];
extern TCHAR  szLastDir  [];
extern TCHAR  szFilterSpec [];    /* default filter spec. for above  */
extern int    wHlpMsg;            /* message used to invoke Help     */
extern TCHAR  szOpenCaption [];   /* File open dialog caption text   */
extern TCHAR  szSaveCaption [];   /* File Save as dialog caption text  */












//
//  Common function prototypes that are
//  not defined in common lib
//


BOOL SyncOpenClipboard(
    HWND    hwnd);

BOOL SyncCloseClipboard(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\render.h ===
/******************************************************************************

                        R E N D E R   H E A D E R

    Name:       render.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for render.c

******************************************************************************/



HANDLE RenderFormat(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh);


HANDLE RenderFormatDibToBitmap(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh,
    HPALETTE        hPalette);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\render.c ===
/*****************************************************************************

                                    R E N D E R

    Name:       render.c
    Date:       19-Apr-1994
    Creator:    Unknown

    Description:

    History:
        08-Jul-1994 John Fu     Fix RenderFormatDibToBitmap() to accept
                                palette as parameter and use it.

*****************************************************************************/



#include    <windows.h>
#include    "common.h"
#include    "clipfile.h"
#include    "render.h"
#include    "debugout.h"
#include    "dib.h"





/*
 *
 *      RenderFormat() -
 *
 *  Read the data from fh and SetClipboardData() with it.
 *  CLAUSGI - don't setClipboardData - just return the handle...
 */

HANDLE RenderFormat(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh)
{
HANDLE            hBitmap;
register HANDLE   hData;
LPSTR             lpData;
DWORD             MetaOffset;     /* special case hack for metafiles */
BITMAP            bitmap;
HPALETTE          hPalette;
LPLOGPALETTE      lpLogPalette;
DWORD             dwBytesRead;
DWORD             dwOffset;

    if (PRIVATE_FORMAT(pfmthdr->FormatID))
       pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);




    // Special case hack for metafiles to get hData referencing
    // the metafile bits, not the METAFILEPICT structure.


    switch (pfmthdr->FormatID)
        {
        case CF_METAFILEPICT:
            if (!fNTReadFileFormat)
               {
               MetaOffset = sizeof(WIN31METAFILEPICT);
               }
            else
               {
               MetaOffset = sizeof(METAFILEPICT);
               }
            break;
        case CF_BITMAP:
            if (!fNTReadFileFormat)
               {
               MetaOffset = sizeof(WIN31BITMAP);
               }
            else
               {
               MetaOffset = sizeof(BITMAP);
               }
            break;
        default:
            MetaOffset = 0;
            break;
        }



    if (!(hData = GlobalAlloc(GHND, pfmthdr->DataLen - MetaOffset)))
        {
        PERROR(TEXT("GlobalAlloc failure in RenderFormat\n\r"));
        return NULL;
        }


    if (!(lpData = GlobalLock(hData)))
        {
        PERROR(TEXT("GlobalLock failure in RenderFormat\n\r"));
        GlobalFree(hData);
        return NULL;
        }



    dwOffset = pfmthdr->DataOffset + MetaOffset;

    PINFO("Getting data for %ws at offset %ld\r\n",pfmthdr->Name, dwOffset);
    SetFilePointer(fh, dwOffset, NULL, FILE_BEGIN);

    ReadFile (fh, lpData, pfmthdr->DataLen - MetaOffset, &dwBytesRead, NULL);

    if(pfmthdr->DataLen - MetaOffset != dwBytesRead)
         {
         // Error in reading the file
         GlobalUnlock(hData);
         GlobalFree(hData);
         PERROR(TEXT("RenderFormat: Read err, expected %d bytes, got %d\r\n"),
               pfmthdr->DataLen - MetaOffset, dwBytesRead);
         return (NULL);
         }

    // As when we write these we have to special case a few of
    // these guys.  This code and the write code should match in terms
    // of the sizes and positions of data blocks being written out.
    // HEY, YOU! READ THIS: EVERY case in this switch should have a
    // GlobalUnlock(hData);
    // statement in it. We go in with the block locked, but should come
    // out with the block unlocked. Yeah, it's not structured, but most
    // of these formats require access to the data.. calling GlobalUnlock()
    // then GlobalLock() again looked even worse.
    switch (pfmthdr->FormatID)
        {
        case CF_ENHMETAFILE:
           {
           HENHMETAFILE hemf;

           hemf = SetEnhMetaFileBits(pfmthdr->DataLen, lpData);

           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = hemf;
           break;
           }

        case CF_METAFILEPICT:
           {
           HANDLE            hMF;
           HANDLE            hMFP;
           LPMETAFILEPICT    lpMFP;

           /* Create the METAFILE with the bits we read in. */
           hMF = SetMetaFileBitsEx(pfmthdr->DataLen, lpData);
           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = NULL;

           if (hMF)
              {
              /* Alloc a METAFILEPICT header. */

              if (hMFP = GlobalAlloc(GHND, (DWORD)sizeof(METAFILEPICT)))
                 {
                 if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP)))
                    {
                    GlobalFree(hMFP);
                    }
                 else
                    {
                    /* Reposition to the start of the METAFILEPICT header. */
                    SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN);

                    /* Read in the data */
                    if (fNTReadFileFormat)
                       {
                       ReadFile(fh, lpMFP, sizeof(METAFILEPICT),
                             &dwBytesRead, NULL);
                       }
                    else
                       {
                       WIN31METAFILEPICT w31mfp;

                       ReadFile(fh, &w31mfp, sizeof(w31mfp), &dwBytesRead, NULL);
                       if (sizeof(w31mfp) == dwBytesRead)
                          {
                          lpMFP->mm = w31mfp.mm;
                          lpMFP->xExt = w31mfp.xExt;
                          lpMFP->yExt = w31mfp.yExt;
                          }
                       }

                    lpMFP->hMF = hMF;         /* Update the METAFILE handle  */
                    GlobalUnlock(hMFP);       /* Unlock the header           */
                    hData = hMFP;             /* Stuff this in the clipboard */
                    }
                 }
              }
           break;
           }

        case CF_BITMAP:
           // Reposition to the start of the METAFILEPICT header.
           SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN);


           /* Read in the BITMAP struct */
           if (fNTReadFileFormat)
              {
              if (!ReadFile(fh, &bitmap, sizeof(BITMAP), &dwBytesRead, NULL))
                  memset(&bitmap, 0, sizeof(bitmap));
              }
           else
              {
              // Read in an old-style BITMAP struct, and set the fields
              // of the new-style BITMAP from that.
              WIN31BITMAP w31bm;
              if (ReadFile(fh, &w31bm, sizeof(w31bm), &dwBytesRead, NULL))
              {

                  bitmap.bmType       = w31bm.bmType;
                  bitmap.bmWidth      = w31bm.bmWidth;
                  bitmap.bmHeight     = w31bm.bmHeight;
                  bitmap.bmWidthBytes = w31bm.bmWidthBytes;
                  bitmap.bmPlanes     = w31bm.bmPlanes;
                  bitmap.bmBitsPixel  = w31bm.bmBitsPixel;
              }
              else
              {
                  memset(&bitmap, 0, sizeof(bitmap));
              }
              }

           // Set the bmBits member of the BITMAP to point to our existing
           // bits and make the bitmap.
           bitmap.bmBits = lpData;
           hBitmap = CreateBitmapIndirect(&bitmap);

           // Dump the original data (which was just the bitmap bits) and
           // make the bitmap handle our data handle.
           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = hBitmap;       // Stuff this in the clipboard
           break;

        case CF_PALETTE:
           lpLogPalette = (LPLOGPALETTE)lpData;

           hPalette = CreatePalette(lpLogPalette);

           GlobalUnlock(hData);
           GlobalFree(hData);

           hData = hPalette;
           break;

        default:
           GlobalUnlock(hData);
           break;
        }


    return(hData);

}








HANDLE RenderFormatDibToBitmap(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh,
    HPALETTE        hPalette)
{
HANDLE            hBitmap;
register HANDLE   hData;
LPSTR             lpData;
DWORD             dwBytesRead;
DWORD             dwOffset;



    if (PRIVATE_FORMAT(pfmthdr->FormatID))
        pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);




    if (!(hData = GlobalAlloc(GHND, pfmthdr->DataLen)))
        {
        PERROR(TEXT("GlobalAlloc failure in RenderFormat\n\r"));
        return NULL;
        }


    if (!(lpData = GlobalLock(hData)))
        {
        PERROR(TEXT("GlobalLock failure in RenderFormat\n\r"));
        GlobalFree(hData);
        return NULL;
        }



    dwOffset = pfmthdr->DataOffset;

    PINFO("Getting data for %ws at offset %ld\r\n",pfmthdr->Name, dwOffset);
    SetFilePointer(fh, dwOffset, NULL, FILE_BEGIN);

    ReadFile (fh, lpData, pfmthdr->DataLen, &dwBytesRead, NULL);

    if(pfmthdr->DataLen != dwBytesRead)
        {
        // Error in reading the file
        GlobalUnlock(hData);
        GlobalFree(hData);

        PERROR (TEXT("RenderFormat: Read err, expected %d bytes, got %d\r\n"),
                pfmthdr->DataLen, dwBytesRead);
        return (NULL);
        }


    GlobalUnlock(hData);

    hBitmap = BitmapFromDib (hData, hPalette);

    GlobalFree (hData);


    return (hBitmap);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\debugout.h ===
/******************************************************************************

                    D E B U G   O U T P U T   H E A D E R

    Name:       debugout.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for debugout.h

******************************************************************************/


extern  INT     DebugLevel;
extern  BOOL    DebugFile;



VOID PERROR (LPTSTR format, ...);


VOID PINFO (LPTSTR format, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\dib.h ===
/****************************************************************************
 *                                                                          *
 *  FILE        : SHOWDIB.H                                                 *
 *                                                                          *
 *  DESCRIPTION : Header/include file for ShowDIB example.                  *
 *                                                                          *
 ****************************************************************************/



// Macro to restrict a given value to an upper or lower boundary value
#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))


// Macro to swap two values
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))


// Macro to find the minimum of two values
#define MIN(x,y) (((x) <= (y)) : x ? y)


// Macros to display/remove hourglass cursor for lengthy operations
#define StartWait() hcurSave = SetCursor(LoadCursor(NULL,IDC_WAIT))
#define EndWait()   SetCursor(hcurSave)



#define MINBAND         50     // Minimum band size used by the program
#define BANDINCREMENT   20     // Decrement for band size while trying
                               // to determine optimum band size.


#define ISDIB(bft)      ((bft) == BFT_BITMAP)   // macro to determine if resource is a DIB


#define ALIGNULONG(i)   ((i+3)/4*4)     // Align to the closest DWORD (unsigned long )


#define WIDTHBYTES(i)   ((i+31)/32*4)   // Round off to the closest byte


#define PALVERSION      0x300
#define MAXPALETTE      256             // max. # supported palette entries

/***************** GLOBAL VARIABLES *************************/

extern  char        achFileName[128];   // File pathname
extern  DWORD       dwOffset;           // Current position if DIB file pointer
extern  RECT        rcClip;             // Current clip rectangle.
extern  BOOL        fPalColors;         // TRUE if the current DIB's color table
                                        // contains palette indexes not rgb values
extern  BOOL        bDIBToDevice;       // Use SetDIBitsToDevice() to BLT data.
extern  BOOL        bLegitDraw;         // We have a valid bitmap to draw
extern  WORD        wTransparent;       // Mode of DC
extern  HPALETTE    hpalCurrent;        // Handle to current palette
extern  HANDLE      hdibCurrent;        // Handle to current memory DIB
extern  HBITMAP     hbmCurrent;         // Handle to current memory BITMAP
extern  HANDLE      hbiCurrent;         // Handle to current bitmap info struct
extern  DWORD       dwStyle;            // Style bits of the App. window




/***********************************************************/
/* Declarations of functions used in dib.c module          */
/***********************************************************/

WORD            PaletteSize (VOID FAR * pv);
WORD            DibNumColors (VOID FAR * pv);
HANDLE          DibFromBitmap (HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal);
HBITMAP         BitmapFromDib (HANDLE hdib, HPALETTE hpal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\security.c ===
// Shares.C -- Functions for manipulating NetDDE shares


#define    NOAUTOUPDATE 1

#include <windows.h>
#include <windowsx.h>
#include "common.h"
#include "security.h"
#include "debugout.h"





/*
 *      GetTokenHandle
 */

BOOL GetTokenHandle(
    PHANDLE pTokenHandle )
{

    if (OpenThreadToken( GetCurrentThread(), TOKEN_READ, FALSE, pTokenHandle))
        return TRUE;



    if (GetLastError() != ERROR_NO_TOKEN)
        return FALSE;


    if (OpenProcessToken( GetCurrentProcess(), TOKEN_READ, pTokenHandle))
        return TRUE;


    return FALSE;

}







/*
 *      MakeLocalOnlySD
 *
 *  Purpose: Generate a self-relative SD whose ACL contains only an
 *     entry for LocalSystem/GENERIC_ALL access. This SD will be used
 *     in calls to CreateFile() for clipbook page files.
 *
 *  Parameters: None
 *
 *  Returns: Pointer to the security descriptor. This pointer may be freed.
 *     Returns NULL on failure.
 */

PSECURITY_DESCRIPTOR MakeLocalOnlySD (void)
{
PSECURITY_DESCRIPTOR        pSD;
PSECURITY_DESCRIPTOR        pSDSelfRel = NULL;
SID_IDENTIFIER_AUTHORITY    authNT     = SECURITY_NT_AUTHORITY;

PSID  sidLocal;
PACL  Acl;
DWORD dwAclSize;



    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
             0, 0, 0, 0, 0, 0, 0, &sidLocal))
        {
        if (InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))
            {
            // Allocate space for DACL with "System Full Control" access
            dwAclSize = sizeof(ACL)+ GetLengthSid(sidLocal) +
                  sizeof(ACCESS_ALLOWED_ACE) + 42; // 42==fudge factor
            if (Acl = (PACL)GlobalAlloc(GPTR, dwAclSize))
                {
                if (InitializeAcl(Acl, dwAclSize, ACL_REVISION))
                    {
                    // LocalSystem gets all access, nobody else gets any.
                    if (AddAccessAllowedAce(Acl, ACL_REVISION,
                          GENERIC_ALL, sidLocal))
                        {
                        if (SetSecurityDescriptorDacl(pSD, TRUE, Acl, TRUE))
                            {
                            DWORD dwSelfRelLen;

                            dwSelfRelLen = GetSecurityDescriptorLength(pSD);
                            pSDSelfRel = GlobalAlloc(GPTR, dwSelfRelLen);
                            if (pSDSelfRel)
                            {
                                if (!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSelfRelLen))
                                    {
                                    GlobalFree((HANDLE)pSDSelfRel);
                                    pSDSelfRel = NULL;
                                    }
                                }
                            }
                        }
                    }
                GlobalFree((HANDLE)Acl);
                }
            }
        FreeSid(sidLocal);
        }
    return(pSDSelfRel);
}

















/*
 *      CurrentUserOnlySD
 *
 *  Purpose: Create a security descriptor containing only a single
 *  DACL entry-- one to allow the user whose context we are running
 *  in GENERIC_ALL access.
 *
 *  Parameters: None.
 *
 *  Returns: A pointer to the security descriptor described above,
 *     or NULL on failure.
 */

PSECURITY_DESCRIPTOR CurrentUserOnlySD (void)
{
SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

SECURITY_DESCRIPTOR   aSD;
PSECURITY_DESCRIPTOR  pSD = NULL;
BOOL                  OK;
PACL                  TmpAcl;
PACCESS_ALLOWED_ACE   TmpAce;
DWORD                 lSD;
LONG                  DaclLength;
DWORD                 lTokenInfo;
HANDLE                hClientToken;
TOKEN_USER            *pUserTokenInfo;




    if (!InitializeSecurityDescriptor(&aSD, SECURITY_DESCRIPTOR_REVISION)
        || GetTokenHandle(&hClientToken))
        {
        PERROR(TEXT("Couldn't get token handle or InitSD bad \r\n"));
        return NULL;
        }



    // See if the token info fits in 50 bytes. If it does, fine.
    // If not, realloc to proper size and get the token info.
    pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, 50 );
    if (pUserTokenInfo && !GetTokenInformation( hClientToken, TokenUser,
                 (LPVOID) pUserTokenInfo, 50, &lTokenInfo ) )
       {
       LocalFree( pUserTokenInfo );
       pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, lTokenInfo );
       if (!GetTokenInformation( hClientToken, TokenUser,
               (LPVOID) pUserTokenInfo, lTokenInfo, &lTokenInfo ) )
          {
          LocalFree( pUserTokenInfo );
          pUserTokenInfo = NULL;
          }
       }


    if (!pUserTokenInfo)
        {
        PERROR(TEXT("Couldn't get usertokeninfo\r\n"));
        }
    else
        {
        // Figure out how big a Dacl we'll need for just me to be on it.
        DaclLength = (DWORD)sizeof(ACL) +
              GetLengthSid( pUserTokenInfo->User.Sid ) +
              (DWORD)sizeof( ACCESS_ALLOWED_ACE );

        if (!(TmpAcl = (PACL)LocalAlloc(LMEM_FIXED, DaclLength )))
            {
            PERROR(TEXT("LocalAllof for Acl fail\r\n"));
            }
        else
            {
            if (!InitializeAcl( TmpAcl, DaclLength, ACL_REVISION ))
                {
                PERROR(TEXT("InitializeAcl fail\r\n"));
                }
            else if (!AddAccessAllowedAce( TmpAcl, ACL_REVISION,
                   GENERIC_ALL, pUserTokenInfo->User.Sid ))
                {
                PERROR(TEXT("AddAccessAllowedAce fail\r\n"));
                }
            else if (!GetAce( TmpAcl, 0, (LPVOID *)&TmpAce))
                {
                PERROR("GetAce error %d", GetLastError());
                }
            else
                {
                TmpAce->Header.AceFlags = 0;
                OK   = SetSecurityDescriptorDacl(&aSD, TRUE, TmpAcl, FALSE);
                lSD  = GetSecurityDescriptorLength( &aSD);

                if (pSD  = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, lSD))
                    {
                    MakeSelfRelativeSD( &aSD, pSD, &lSD);

                    if( IsValidSecurityDescriptor( pSD ) )
                        {
                        LocalFree(pSD);
                        pSD = NULL;
                        }
                    else
                        {
                        PERROR(TEXT("Failed creating self-relative SD (%d)."),
                              GetLastError());
                        }
                    }
                else
                    {
                    PERROR(TEXT("LocalAlloc for pSD fail\r\n"));
                    }
                }


            LocalFree((HANDLE)TmpAcl);
            }

        LocalFree((HANDLE)pUserTokenInfo);
        }


    CloseHandle(hClientToken);



    return pSD;

}










#if 0



/*
 *      CurrentUserOnlySD
 *
 *  Purpose: Create an SD with a DACL saying "Current user- All". And
 *     nothing else. Note: This implementation is guaranteed to create
 *     a self-relative SD.
 *
 *  Returns: Pointer to the SD, or NULL on failure.
 */

PSECURITY_DESCRIPTOR CurrentUserOnlySD (void)
{
SECURITY_DESCRIPTOR     sd;
PSECURITY_DESCRIPTOR    pSD = NULL;
HANDLE                  htok;
PSID                    sid;
DWORD                   dwSidSize;
DWORD                   dwSDSize;
PACL                    pacl = NULL;
TOKEN_USER              *pusr = NULL;
PSID                    psidWorld;

SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;




    PINFO(TEXT("CUOnlySD "));

    AllocateAndInitializeSid (&WorldAuthority,
                              1,
                              SECURITY_WORLD_RID,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              &psidWorld);



    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
       {
       PERROR(TEXT("InitSD fail%ld\r\n"), GetLastError());
       goto done;
       }



    if (!GetTokenHandle(&htok))
       {
       PERROR(TEXT("GetTokenHandle fail%ld\r\n"), GetLastError());
       goto done;
       }



    // try 100 bytes, if not enough, alloc the required size.

    pusr = (TOKEN_USER *)GlobalAllocPtr(GHND, 100);

    if (!GetTokenInformation(htok, TokenUser, pusr, dwSidSize, &dwSidSize))
       {
       GlobalFree(pusr);
       pusr = (TOKEN_USER *)GlobalAlloc(GPTR, dwSidSize);
       }



    if (!pusr)
       {
       PERROR(TEXT("GlobalAllocPtr fail%ld\r\n"), GetLastError());
       goto done;
       }



    if (!GetTokenInformation (htok, TokenUser, pusr, dwSidSize, &dwSidSize))
       {
       PERROR(TEXT("GetTokinfo fail%ld\r\n"), GetLastError());
       goto done;
       }




    PrintSid (pusr->User.Sid);

    if (!SetSecurityDescriptorOwner(&sd, pusr->User.Sid, TRUE) ||
        !SetSecurityDescriptorGroup(&sd, pusr->User.Sid, TRUE))
       {
       PERROR(TEXT("Couldn't set owner/group %ld\r\n"), GetLastError());
       goto done;
       }



    pacl = (PACL) GlobalAllocPtr (GHND,
                                  sizeof(ACL)+
                                  (2 * sizeof (ACCESS_ALLOWED_ACE)) +
                                  GetLengthSid (pusr->User.Sid) +
                                  GetLengthSid (psidWorld));

    if (!pacl)
       {
       PERROR(TEXT("GlobalAllocPtr (PACL) fail%ld\r\n"), GetLastError());
       goto done;
       }



    if (!InitializeAcl(pacl,
                       sizeof(ACL) +
                       (2 * sizeof(ACCESS_ALLOWED_ACE)) +
                       GetLengthSid (pusr->User.Sid) +
                       GetLengthSid (psidWorld),
                       ACL_REVISION))
       {
       PERROR(TEXT("InitAcl fail%ld\r\n"), GetLastError());
       goto done;
       }




    if (!AddAccessAllowedAce (pacl,
                              ACL_REVISION,
                              NDDE_GUI_FULL_CONTROL,
                              pusr->User.Sid))
        // 6/25/93 - a-mgates Pages should have "userFC"
        //   access only when first created
        // &&
        //
        // AddAccessAllowedAce(pacl, ACL_REVISION,
        //    NDDE_GUI_READ,
        //    psidWorld))
       {
       PERROR(TEXT("AddAccAllAce fail %ld\r\n"), GetLastError());
       goto done;
       }



    if (!SetSecurityDescriptorDacl(&sd, TRUE, pacl, TRUE))
       {
       PERROR(TEXT("SetSDDacl fail%ld\r\n"), GetLastError());
       goto done;
       }



    dwSDSize = GetSecurityDescriptorLength(&sd);
    if (!(pSD = GlobalAllocPtr(GHND, dwSDSize)))
       {
       PERROR(TEXT("GAPtr for self-rel SD fail\r\n"));
       goto done;
       }




    if (MakeSelfRelativeSD(&sd, pSD, &dwSDSize))
       {
       PINFO(TEXT("CUOnlySD OK\r\n"));
       PrintSD(pSD);
       }
    else
       {
       PERROR(TEXT("MSelfRelSD fail %ld\r\n"),
             GetLastError());
       GlobalFreePtr(pSD);
       pSD = NULL;
       }





done:


    if (pacl) GlobalFreePtr(pacl);
    if (pusr) GlobalFreePtr(pusr);

    FreeSid (psidWorld);

    PERROR(TEXT("Returning %p\r\n"), pSD);


    return(pSD);

}

#endif // 0











#ifdef DEBUG


/*
 *      HexDumpBytes
 */

void HexDumpBytes(
    char        *pv,
    unsigned    cb)
{
char        achHex[]="0123456789ABCDEF";
char        achOut[80];
unsigned    iOut;



    iOut = 0;

    while (cb)
        {
        if (iOut >= 78)
            {
            PINFO(achOut);
            iOut = 0;
            }

        achOut[iOut++] = achHex[(*pv >> 4) & 0x0f];
        achOut[iOut++] = achHex[*pv++ & 0x0f];
        achOut[iOut]   = '\0';
        cb--;
        }


    if (iOut)
        {
        PINFO(achOut);
        }

}





/*
 *      PrintSid
 */

void PrintSid(
    PSID    sid)
{
DWORD   cSubAuth;
DWORD   i;

    PINFO(TEXT("\r\nSID: "));

    if (sid)
        {
        HexDumpBytes((char *)GetSidIdentifierAuthority(sid), sizeof(SID_IDENTIFIER_AUTHORITY));

        SetLastError(0);
        cSubAuth = *GetSidSubAuthorityCount(sid);
        if (GetLastError())
            {
            PINFO(TEXT("Invalid SID\r\n"));
            }
        else
            {
            for (i = 0;i < cSubAuth; i++)
                {
                PINFO(TEXT("-"));
                HexDumpBytes((char *)GetSidSubAuthority(sid, i), sizeof(DWORD));
                }
            PINFO(TEXT("\r\n"));
            }
        }
    else
        {
        PINFO(TEXT("NULL SID\r\n"));
        }

}






/*
 *      PrintAcl
 *
 *  Purpose: Print out the entries in an access-control list.
 */

void PrintAcl(
    PACL    pacl)
{
ACL_SIZE_INFORMATION    aclsi;
ACCESS_ALLOWED_ACE      *pace;
unsigned                i;


    if (pacl)
        {
        if (GetAclInformation (pacl, &aclsi, sizeof(aclsi), AclSizeInformation))
            {
            for (i = 0;i < aclsi.AceCount;i++)
                {
                GetAce(pacl, i, &pace);

                PINFO(TEXT("Type(%x) Flags(%x) Access(%lx)\r\nSID:"),
                      (int)pace->Header.AceType,
                      (int)pace->Header.AceFlags,
                      pace->Mask);
                PrintSid((PSID)&(pace->SidStart));
                }
            }
        }
    else
        {
        PINFO(TEXT("NULL PACL\r\n"));
        }

}






/*
 *      PrintSD
 */

void PrintSD(
    PSECURITY_DESCRIPTOR    pSD)
{
DWORD   dwRev;
WORD    wSDC;
BOOL    fDefault, fAcl;
PACL    pacl;
PSID    sid;



    if (NULL == pSD)
        {
        PINFO(TEXT("NULL sd\r\n"));
        return;
        }

    if (!IsValidSecurityDescriptor(pSD))
        {
        PINFO(TEXT("Bad SD %p"), pSD);
        return;
        }

    // Drop control info and revision
    if (GetSecurityDescriptorControl(pSD, &wSDC, &dwRev))
        {
        PINFO(TEXT("SD - Length: [%ld] Control: [%x] [%lx]\r\nGroup:"),
              GetSecurityDescriptorLength(pSD), wSDC, dwRev);
        }
    else
        {
        PINFO(TEXT("Couldn't get control\r\nGroup"));
        }

    // Show group and owner
    if (GetSecurityDescriptorGroup(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\nOwner:"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get group\r\n"));
        }

    if (GetSecurityDescriptorOwner(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\n"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get owner\r\n"));
        }

    // Print DACL and SACL
    if (GetSecurityDescriptorDacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("DACL: %s %s\r\n"), fAcl ? "Yes" : "No",
              fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid Acl %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get DACL\r\n"));
        }

    if (GetSecurityDescriptorSacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("SACL: %s %s\r\n"), fAcl ? "Yes" : "No", fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid ACL %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get SACL\r\n"));
        }

}


#else
#define PrintSid(x)
#define PrintSD(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\dib.c ===
/*****************************************************************************

                                    D I B

    Name:       dib.c
    Date:       19-Apr-1994
    Creator:    Unknown

    Description:
        Handles Device Independent Bitmap.

        PaletteSize()       - Calculates the palette size in bytes
                              of given DIB

        DibNumColors()      - Determines the number of colors in DIB

        BitmapFromDib()     - Creates a DDB given a global handle to
                              a block in CF_DIB format.

        DibFromBitmap()     - Creates a DIB repr. the DDB passed in.


    History:
        16-Jun-1994 John Fu     Fix DibFromBitmap() to use correct biBits.

        08-Jul-1994 John Fu     Fix DibFromBitmap() and BitmapFromDib() to
                                use palette when available.

        15-Mar-1995 John Fu     Changed to use DIB_RGB_COLORS only.

*****************************************************************************/




#include <windows.h>
#include "dib.h"


static   HCURSOR hcurSave;







/*
 *
 *  FUNCTION   :  PaletteSize(VOID FAR * pv)
 *
 *  PURPOSE    :  Calculates the palette size in bytes. If the info. block
 *                is of the BITMAPCOREHEADER type, the number of colors is
 *                multiplied by 3 to give the palette size, otherwise the
 *                number of colors is multiplied by 4.                                                         *
 *
 *  RETURNS    :  Palette size in number of bytes.
 *
 */

WORD PaletteSize (
    VOID FAR * pv)
{
LPBITMAPINFOHEADER  lpbi;
WORD                NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        return NumColors * sizeof(RGBTRIPLE);
    else
        return NumColors * sizeof(RGBQUAD);

}





/*
 *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)
 *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at
 *               the BitCount filed in the info block.
 *
 *  RETURNS    : The number of colors in the DIB.
 *
 */

WORD DibNumColors (
    VOID FAR * pv)
{
int                 bits;
LPBITMAPINFOHEADER  lpbi;
LPBITMAPCOREHEADER  lpbc;


    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);



    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
        {
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;
        bits = lpbi->biBitCount;
        }
    else
        bits = lpbc->bcBitCount;



    switch (bits)
        {
        case 1:
                return 2;
        case 4:
                return 16;
        case 8:
                return 256;
        default:
                /* A 24 bitcount DIB has no color table */
                return 0;
        }
}






/*
 *
 *  FUNCTION   : DibFromBitmap()
 *
 *  PURPOSE    : Will create a global memory block in DIB format that
 *               represents the Device-dependent bitmap (DDB) passed in.
 *
 *  RETURNS    : A handle to the DIB
 *
 */

HANDLE DibFromBitmap (
    HBITMAP     hbm,
    DWORD       biStyle,
    WORD        biBits,
    HPALETTE    hpal)
{
BITMAP               bm;
BITMAPINFOHEADER     bi;
BITMAPINFOHEADER FAR *lpbi;
DWORD                dwLen;
HANDLE               hdib;
HANDLE               h;
HDC                  hdc;



    if (!hbm)
        return NULL;


    if (hpal == NULL)
        {
        hpal = GetStockObject(DEFAULT_PALETTE);
        }


    if (!GetObject(hbm,sizeof(bm),(LPSTR)&bm))
        return NULL;


    if (biBits == 0)
        biBits = bm.bmPlanes * bm.bmBitsPixel;



    // make sure we have the right # of bits

    if (biBits <= 1)
        biBits = 1;
    else if (biBits <= 4)
        biBits = 4;
    else if (biBits <= 8)
        biBits = 8;
    else
        biBits = 24;



    bi.biSize           = sizeof(BITMAPINFOHEADER);
    bi.biWidth          = bm.bmWidth;
    bi.biHeight         = bm.bmHeight;
    bi.biPlanes         = 1;
    bi.biBitCount       = biBits;
    bi.biCompression    = biStyle;
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed        = 0;
    bi.biClrImportant   = 0;

    dwLen  = bi.biSize + PaletteSize (&bi);




    hdc = GetDC(NULL);

    hpal = SelectPalette (hdc, hpal, FALSE);
    RealizePalette (hdc);



    hdib = GlobalAlloc (GHND, dwLen);

    if (!hdib)
        {
        SelectPalette (hdc,hpal,FALSE);
        ReleaseDC (NULL,hdc);
        return NULL;
        }




    lpbi = (VOID FAR *)GlobalLock(hdib);
    *lpbi = bi;




    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */

    GetDIBits (hdc,
               hbm,
               0,
               (WORD)bi.biHeight,
               NULL,
               (LPBITMAPINFO)lpbi,
               DIB_RGB_COLORS);


    bi = *lpbi;
    GlobalUnlock(hdib);





    // If the driver did not fill in the biSizeImage field, make one up

    if (bi.biSizeImage == 0)
        {
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

        if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }




    // realloc the buffer big enough to hold all the bits

    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;

    if (h = GlobalReAlloc (hdib,dwLen,0))
        hdib = h;
    else
        {
        GlobalFree(hdib);
        hdib = NULL;

        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return hdib;
        }




    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */

    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (0 == GetDIBits (hdc,
                        hbm,
                        0,
                        (WORD)bi.biHeight,
                        (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
                        (LPBITMAPINFO)lpbi,
                        DIB_RGB_COLORS))
        {
        GlobalUnlock (hdib);
        hdib = NULL;
        SelectPalette (hdc, hpal, FALSE);
        ReleaseDC (NULL, hdc);
        return NULL;
        }


    bi = *lpbi;
    GlobalUnlock (hdib);


    SelectPalette (hdc, hpal, FALSE);

    ReleaseDC (NULL, hdc);

    return hdib;

}








/*
 *
 *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)
 *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global
 *               handle to a memory block in CF_DIB format
 *
 *  RETURNS    : A handle to the DDB.
 *
 */

HBITMAP BitmapFromDib (
    HANDLE      hdib,
    HPALETTE    hpal)
{
LPBITMAPINFOHEADER  lpbi;
HPALETTE            hpalT;
HDC                 hdc;
HBITMAP             hbm = NULL;



    StartWait();


    if (!hdib)
        goto done;


    lpbi = (VOID FAR *)GlobalLock (hdib);
    if (!lpbi)
        goto done;



    hdc = GetDC (NULL);

    if (hpal)
        {
        hpalT = SelectPalette (hdc, hpal, FALSE);
        RealizePalette (hdc);
        }

    hbm = CreateDIBitmap (hdc,
                          (LPBITMAPINFOHEADER)lpbi,
                          (LONG)CBM_INIT,
                          (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
                          (LPBITMAPINFO)lpbi,
                          DIB_RGB_COLORS);


    if (hpal)
        SelectPalette (hdc, hpalT, FALSE);


    ReleaseDC (NULL, hdc);
    GlobalUnlock (hdib);


done:

    EndWait();

    return hbm;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\security.h ===
/******************************************************************************

                        S E C U R I T Y   H E A D E R

    Name:       security.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for shares.c

******************************************************************************/




BOOL GetTokenHandle(
    PHANDLE pTokenHandle);


PSECURITY_DESCRIPTOR MakeLocalOnlySD (void);


PSECURITY_DESCRIPTOR CurrentUserOnlySD (void);




#ifdef DEBUG

void HexDumpBytes(
    char        *pv,
    unsigned    cb);


void PrintSid(
    PSID    sid);


void PrintAcl(
    PACL    pacl);


void PrintSD(
    PSECURITY_DESCRIPTOR    pSD);


#else

#define HexDumpBytes(x,y)
#define PrintSid(x)
#define PrintAcl(x)
#define PrintSD(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\common\version.h ===
#include <ntverp.h>
#if 0
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h>
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "3.1"
#define VER_PRODUCTVERSION_STR      "3.10\0"
#define VER_PRODUCTVERSION          3,10,2,102

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\callback.h ===
/******************************************************************************

                        D D E   C A L L B A C K   H E A D E R

    Name:       callback.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for callback.c

******************************************************************************/


extern  TCHAR   szInitShareCmd[];
extern  TCHAR   szExitCmd[];
extern  TCHAR   szPasteShareCmd[];
extern  TCHAR   szDelShareCmd[];
extern  TCHAR   szMarkSharedCmd[];
extern  TCHAR   szMarkUnSharedCmd[];
extern  TCHAR   szKeepCmd[];
extern  TCHAR   szSaveAsCmd[];
extern  TCHAR   szSaveAsOldCmd[];
extern  TCHAR   szOpenCmd[];
extern  TCHAR   szDebugCmd[];
extern  TCHAR   szVersionCmd[];
extern  TCHAR   szSecurityCmd[];
extern  TCHAR   szDebug[];
extern  TCHAR   szVer[];


extern  TCHAR   szSection[];
extern  TCHAR   szClipviewRoot[];
extern  TCHAR   szRegClass[];

extern  HSZ     hszSysTopic;
extern  HSZ     hszTopicList;
extern  HSZ     hszFormatList;




LONG MakeTheDamnKey(
    PHKEY   phkey,
    REGSAM  regsam);


int lstrncmp(
    LPTSTR  s1,
    LPTSTR  s2,
    WORD    count);


DWORD   GetConvErr(
    HCONV   hConv);


DWORD   GetXactErrType(
    HCONV   hConv);


VOID    SetXactErr(
    HCONV   hConv,
    DWORD   dwType,
    DWORD   dwErr);


HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2);


BOOL IsSupportedTopic(
    HSZ hszTopic);


BOOL CleanUpShares(void);


BOOL    CheckPageName(
    LPTSTR  ComputerName,
    LPTSTR  Name);


BOOL InitShares(void);


HDDEDATA GetFormat(
    HCONV   hConv,
    HSZ     hszTopic,
    HSZ     hszItem);


BOOL DelShare(
    HCONV   hConv,
    TCHAR   *pszName);


BOOL AddRecord(
    LPTSTR  lpszName,
    LPTSTR  lpszFileName,
    ULONG   siflags);


DWORD AddShare(
    LPTSTR  pszName,
    WORD    flags);



VOID DumpShares(void);


BOOL MarkShare(
    TCHAR   *pszName,
    WORD    flags);


void Hszize(void);


void UnHszize(void);


DWORD GetRandShareFileName(
    LPTSTR  buf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\clipbook\datasrv\clipfile.c ===
/*
 * CLIPFILE.C - Windows Clipboard File I/O Routines
 */

/* NOTE:
 *   When saving the contents of the clipboard we SetClipboardData(fmt, NULL)
 *   to free up the memory associated with each clipboard format.  Then
 *   after we are done saving we take over as the clipboard owner.  This
 *   causes OWNERDRAW formats to be lost in the save process.
 */

#include "clipshr.h"
#include "clipsrv.h"
#include <string.h>
#include <windowsx.h>
#include "..\common\dib.h"
#include "..\common\common.h"

BOOL fAnythingToRender;

TCHAR       szFileSpecifier[] = TEXT("*.CLP");
TCHAR       szFileName[MAX_PATH];
TCHAR       szSaveFileName[MAX_PATH]; // Saved filename for delayed render

BOOL        fNTReadFileFormat;
BOOL        fNTSaveFileFormat;

extern TCHAR szCaptionName[];

UINT cf_link;
UINT cf_objectlink;
UINT cf_linkcopy;
UINT cf_objectlinkcopy;

extern HANDLE RenderFormat(FORMATHEADER *, register HANDLE);

// winball additions
extern BOOL AddNetInfoToClipboard ( TCHAR * );
extern BOOL AddPreviewFormat ( VOID );
extern BOOL AddCopiedFormat ( UINT ufmtOriginal, UINT ufmtCopy );
BOOL AddDIBtoDDB(VOID);
// end winball

/*-----------------------------------------------------------------------
 * File read routines
 *-----------------------------------------------------------------------*/

//
// Purpose: Read the file header in the given .clp file, and get the number
//    of formats. Also sets the fNTReadFileFormat flag appropriately.
//
// Parameters:
//    fh - Handle to the file.
//
// Returns:
//    The number of formats, or 0 if it isn't a valid .clp file.
//
unsigned ReadFileHeader(
HANDLE fh)
{
FILEHEADER FileHeader;
DWORD dwBytesRead;

// PINFO(TEXT("ClSrv\\RdFileHdr"));

/* Read the File Header */
SetFilePointer(fh, 0, NULL, FILE_BEGIN);
ReadFile(fh, &FileHeader, sizeof(FileHeader), &dwBytesRead, NULL);

if (dwBytesRead == sizeof(FILEHEADER))
   {
   // Make sure that this is a .CLP file
   if (FileHeader.magic == CLPBK_NT_ID ||
       FileHeader.magic == CLP_NT_ID)
      {
      fNTReadFileFormat = TRUE;
      }
   else if (FileHeader.magic == CLP_ID)
      {
      fNTReadFileFormat = FALSE;
      }
   else
      {
      PERROR(TEXT("Invalid magic member (not long enough?)\r\n"));
      FileHeader.FormatCount = 0;
      }

   // Check number of formats for additional reassurance.
   if (FileHeader.FormatCount > 100)
      {
      PERROR(TEXT("Too many formats!!!\r\n"));
      FileHeader.FormatCount = 0;
      }
   }
else
   {
   PERROR("Read err\r\n");
   FileHeader.FormatCount = 0;
   }

if (FileHeader.FormatCount)
   {
   // PINFO(TEXT("\r\n"));
   }

return(FileHeader.FormatCount);
}

BOOL ReadFormatHeader(
HANDLE fh,
FORMATHEADER *pfh,
unsigned iFormat)
{
DWORD dwMrPibb;
OLDFORMATHEADER OldFormatHeader;

// PINFO(TEXT("ClSrv\\RdFmtHdr"));

if (NULL == pfh || NULL == fh)
   {
   PERROR("RdFmtHdr got NULL pointer\r\n");
   return FALSE;
   }

SetFilePointer(fh, sizeof(FILEHEADER) + iFormat *
      (fNTReadFileFormat ? sizeof(FORMATHEADER) : sizeof(OLDFORMATHEADER)),
      NULL, FILE_BEGIN);

if (fNTReadFileFormat)
   {
   ReadFile(fh, pfh, sizeof(FORMATHEADER), &dwMrPibb, NULL);

   if (dwMrPibb != sizeof(FORMATHEADER))
      {
      PERROR(TEXT("Bad new format rd\r\n"));
      return FALSE;
      }
   }
else
   {
   ReadFile(fh, &OldFormatHeader, sizeof(OldFormatHeader), &dwMrPibb, NULL);

   if (dwMrPibb != sizeof(OLDFORMATHEADER))
      {
      PERROR(TEXT("Bad old format rd\r\n"));
      return FALSE;
      }

   pfh->FormatID = OldFormatHeader.FormatID;
   pfh->DataLen = OldFormatHeader.DataLen;
   pfh->DataOffset = OldFormatHeader.DataOffset;
   MultiByteToWideChar(
         CP_ACP, MB_PRECOMPOSED, OldFormatHeader.Name, -1,
         pfh->Name, CCHFMTNAMEMAX);
   }

// PINFO(TEXT("\r\n"));
return TRUE;
}

/*
 *  ReadClipboardFromFile()
 *
 * Read in a clipboard file and register all the formats in delayed mode.
 * to render things for real reopen the file specified by ofStruct.
 *
 * NOTE:
 *    This makes us the clipboard owner.
 *
 * Bug 14564:  Changed return value to a short integer noting why the
 * reading failed.
 * Return Value:  0  Success
 *                1  Improper format
 *                2  SyncOpenClipboard failed
 */
#define READFILE_SUCCESS         0
#define READFILE_IMPROPERFORMAT  1
#define READFILE_OPENCLIPBRDFAIL 2

short ReadClipboardFromFile(
HWND hwnd,
HANDLE fh)
{
register unsigned i;
unsigned          cFormats;
FORMATHEADER      FormatHeader;
OLDFORMATHEADER   OldFormatHeader;
// DWORD             dwMrPibb; // Dummy var used for ReadFile

PINFO(TEXT("Entering ReadClipboardFromFile\r\n"));

if (!(cFormats = ReadFileHeader(fh)) )
   {
   return(READFILE_IMPROPERFORMAT);
   }


/* We become the clipboard owner here! */
if (!SyncOpenClipboard(hwnd))
   {
   PERROR(TEXT("Could not open clipboard!!!"));
   return(READFILE_OPENCLIPBRDFAIL);
   }

EmptyClipboard();

for (i=0; i < cFormats; i++)
   {
   ReadFormatHeader(fh, &FormatHeader, i);

   if (PRIVATE_FORMAT(FormatHeader.FormatID))
      {
      FormatHeader.FormatID = RegisterClipboardFormatW((LPWSTR)FormatHeader.Name);
      }

   /*Delayed Render. */
   PINFO(TEXT("Set up delayed render for format %d .\r\n"), FormatHeader.FormatID);
   SetClipboardData(FormatHeader.FormatID, NULL);
   }

/* Now, clipbrd viewer has something to render */
if (cFormats > 0)
   {
   PINFO(TEXT("fAnythingToRender = TRUE\r\n"));
   fAnythingToRender = TRUE;
   }

SyncCloseClipboard();
return(READFILE_SUCCESS);
}


BOOL OpenClipboardFile(
HWND hwnd,
LPTSTR szName)
{
HANDLE     fh;
BOOL nReadError = TRUE;

PINFO(TEXT("OpenClipboardFile: %s \r\n"),szName);

fh = CreateFile((LPCTSTR)szName, GENERIC_READ,
     FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

if (fh != INVALID_HANDLE_VALUE)
   {
   // Store file name for delayed rendering stuff.
   lstrcpy(szSaveFileName, szName);

   // Read it.
   nReadError = ReadClipboardFromFile(hwnd, fh);
   CloseHandle(fh);
   }
else
   {
   PERROR(TEXT("ClSrv\\OpClpFile: can't open file!"));
   }

return !nReadError;
}


//
// Purpose: Go get the given format from the given file.
//
/////////////////////////////////////////////////////////////////
HANDLE RenderFormatFromFile(
LPTSTR szFile,
WORD   wFormat)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData = NULL;
DWORD           dwBytesRead; // Dummy var for ReadFile
unsigned        cFormats;
unsigned        i;

PINFO(TEXT("ClSrv\\RndrFmtFromFile: Opening file %s.\r\n"),szSaveFileName);

fh = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

if (INVALID_HANDLE_VALUE != fh)
   {
   cFormats = ReadFileHeader(fh);

   // If ReadFile didn't get the whole header, don't try to read anything
   // else.
   if (0 == cFormats)
      {
      PERROR(TEXT("Bad file header.\r\n"));
      }

   for (i=0; i < cFormats; i++)
      {
      ReadFormatHeader(fh, &FormatHeader, i);

      PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

      if (PRIVATE_FORMAT(FormatHeader.FormatID))
         {
         FormatHeader.FormatID = RegisterClipboardFormatW(FormatHeader.Name);
         }
      if (FormatHeader.FormatID == wFormat)
         {
         hData = RenderFormat(&FormatHeader, fh);
         }
      }
   CloseHandle(fh);
   }
else
   {
   PERROR(TEXT("Can't open file\r\n"));
   }
return(hData);
}


//
// Purpose: Go get all formats from the given file.
//
/////////////////////////////////////////////////////////////////
HANDLE RenderAllFromFile(
LPTSTR szFile)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData;
DWORD           dwBytesRead; // Dummy var for ReadFile
unsigned        cFormats;
unsigned        i;

/* Check if the clipbrd viewer has done any File I/O before.
 * If it has not, then it has nothing to render!  Sankar
 */
if (CountClipboardFormats() && fAnythingToRender)
   {
   /* Empty the clipboard */
   if (!SyncOpenClipboard(hwndServer))
      {
      PERROR("Couldn't open clipboard!\r\n");
      }
   else
      {
      EmptyClipboard();

      fh = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != fh)
         {
         cFormats = ReadFileHeader(fh);

         // If ReadFile didn't get the whole header, don't try to read anything
         // else.
         if (0 == cFormats)
            {
            PERROR(TEXT("Bad file header.\r\n"));
            }

         for (i=0; i < cFormats; i++)
            {
            ReadFormatHeader(fh, &FormatHeader, i);

            PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

            if (PRIVATE_FORMAT(FormatHeader.FormatID))
               {
               FormatHeader.FormatID =
                  RegisterClipboardFormatW(FormatHeader.Name);
               }

            // Render the format and set it into the clipboard
            hData = RenderFormat(&FormatHeader, fh);
            if ( hData != NULL )
               {
               if (!SetClipboardData(FormatHeader.FormatID, hData))
                  {
                  PERROR(TEXT("SetClipboardData fail\n\r"));
                  }
               }
            else
               {
               PERROR(TEXT("hData == NULL, bad\r\n"));
               }
            }
         CloseHandle(fh);
         }
      else
         {
         PERROR(TEXT("Can't open file\r\n"));
         }
      SyncCloseClipboard();
      }
   }
return(0L);
}


/*-------------------------------------------------------------------------
 * File write routines
 *-------------------------------------------------------------------------*/
/*
 *  IsWriteable()
 *
 * Test if a clipboard format is writeable(i.e. if it makes sense to write it)
 * OWNERDRAW and others can't be written because we (CLIPBRD) will become the
 * owner when the files are reopened.
 */

BOOL IsWriteable(WORD Format)

{
/* Are the PRIVATEFIRST and PRIVATELAST things right? */
if ((Format >= CF_PRIVATEFIRST && Format <= CF_PRIVATELAST)
      || Format == CF_OWNERDISPLAY)
   {
   return FALSE;
   }

// If we're not saving an NT clipboard, don't save NT-specific formats.
if (!fNTSaveFileFormat &&
    (Format == CF_UNICODETEXT || Format == CF_ENHMETAFILE
     || Format == CF_DSPENHMETAFILE)
   )
   {
   return(FALSE);
   }

return(TRUE);
}


/* This function will return the number of clipboard formats compatible with
   the Windows 3.1 clipboard, this excludes CF_UNICODETEXT, CF_ENHMETAFILE and
   CF_DSPENHMETAFILE
*/
int Count16BitClipboardFormats(void)
{
    int iCount;

    iCount = CountClipboardFormats();
    if (IsClipboardFormatAvailable(CF_UNICODETEXT))
        iCount--;
    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        iCount--;
    if (IsClipboardFormatAvailable(CF_DSPENHMETAFILE))
        iCount--;

    return iCount;
}

/*
* Purpose: Writes the format header for a single data format.
*
* Parameters:
*  fh - File handle to write to.
*  offset - Position in the file to write the format block.
*  DataOffset - Position in the file where the data for this format will be.
*  DataLen    - Length of the data for this format.
*  Format     - The format number.
*  szName     - Name of the format.
*
* Returns:
*  The number of bytes written to the file.
*/
DWORD WriteFormatBlock(
HANDLE fh,
DWORD offset,
DWORD DataOffset,
DWORD DataLen,
UINT Format,
LPWSTR wszName)
{
DWORD           dwBytesWritten = 0;

SetFilePointer(fh, offset, NULL, FILE_BEGIN);

if (fNTSaveFileFormat)
   {
   FORMATHEADER    FormatHeader;

   memset(&FormatHeader,0, sizeof(FormatHeader));

   FormatHeader.FormatID = Format;
   FormatHeader.DataLen = DataLen;
   FormatHeader.DataOffset = DataOffset;
   lstrcpyW(FormatHeader.Name, wszName);
   WriteFile(fh, &FormatHeader, sizeof(FormatHeader), &dwBytesWritten, NULL);
   }
else
   {
   OLDFORMATHEADER OldFormatHeader;

   memset(&OldFormatHeader,0, sizeof(OldFormatHeader));

   OldFormatHeader.FormatID = Format;
   OldFormatHeader.DataLen = DataLen;
   OldFormatHeader.DataOffset = DataOffset;
   WideCharToMultiByte(CP_ACP, 0, wszName, -1,
         OldFormatHeader.Name, CCHFMTNAMEMAX, NULL, NULL);
   WriteFile(fh, &OldFormatHeader, sizeof(OldFormatHeader),
         &dwBytesWritten, NULL);
   }
return(dwBytesWritten);
}

/*
 *  Write