dowFile->Priority);

     movestr(pShadowFile->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pShadowFile->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pShadowFile->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pShadowFile->pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrinterName               %ws\n", Buffer);

     movestr(pShadowFile->pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDriverName                   %ws\n", Buffer);

    (*Print)("LPDEVMODE       pDevMode                      %p\n", pShadowFile->pDevMode);

     movestr(pShadowFile->pPrintProcName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrintProcName             %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    //SYSTEMTIME      Submitted;
    (*Print)("DWORD           StartTime                     %d\n", pShadowFile->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pShadowFile->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pShadowFile->Size);
    (*Print)("DWORD           cPages                        %d\n", pShadowFile->cPages);
    (*Print)("DWORD           cbSecurityDescriptor          %d\n", pShadowFile->cbSecurityDescriptor);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pShadowFile->pSecurityDescriptor);

    return TRUE;
}


BOOL
DbgDumpShadowFile2(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PSHADOWFILE_2 pShadowFile)
{
    WCHAR Buffer[MAX_PATH+1];

    (*Print)("ShadowFile2\n");
    (*Print)("DWORD           signature                     %x\n", pShadowFile->signature);
    (*Print)("DWORD           Status                        0x%.8x\n", pShadowFile->Status);
    (*Print)("DWORD           JobId                         %d\n", pShadowFile->JobId);
    (*Print)("DWORD           Priority                      %d\n", pShadowFile->Priority);

     movestr(pShadowFile->pNotify, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pNotify                       %ws\n", Buffer);

     movestr(pShadowFile->pUser, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pUser                         %ws\n", Buffer);

     movestr(pShadowFile->pDocument, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDocument                     %ws\n", Buffer);

     movestr(pShadowFile->pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrinterName               %ws\n", Buffer);

     movestr(pShadowFile->pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDriverName                   %ws\n", Buffer);

    (*Print)("LPDEVMODE       pDevMode                      %p\n", pShadowFile->pDevMode);

     movestr(pShadowFile->pPrintProcName, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pPrintProcName             %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pDatatype                     %ws\n", Buffer);

     movestr(pShadowFile->pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          pParameters                   %ws\n", Buffer);
    //SYSTEMTIME      Submitted;
    (*Print)("DWORD           StartTime                     %d\n", pShadowFile->StartTime);
    (*Print)("DWORD           UntilTime                     %d\n", pShadowFile->UntilTime);
    (*Print)("DWORD           Size                          %d\n", pShadowFile->Size);
    (*Print)("DWORD           cPages                        %d\n", pShadowFile->cPages);
    (*Print)("DWORD           cbSecurityDescriptor          %d\n", pShadowFile->cbSecurityDescriptor);
    (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pShadowFile->pSecurityDescriptor);
    (*Print)("DWORD           Version                       %d\n", pShadowFile->Version);
    (*Print)("DWORD           dwReboots                     %d\n", pShadowFile->dwReboots);

    return TRUE;
}


BOOL
DbgDumpPrintHandle(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PPRINTHANDLE pPrintHandle)
{
    NOTIFY Notify;

    (*Print)("PrintHandle\n");
    (*Print)("DWORD               signature  %d\n", pPrintHandle->signature);
    (*Print)("LPPROVIDOR          pProvidor  %p\n", pPrintHandle->pProvidor);
    (*Print)("HANDLE               hPrinter  0x%.8x\n", pPrintHandle->hPrinter);
    (*Print)("PCHANGE               pChange  %p\n", pPrintHandle->pChange);

    if (pPrintHandle->pChange) {
        DbgDumpChange(hCurrentProcess, Print, pPrintHandle->pChange);
    }

    (*Print)("PNOTIFY               pNotify  %p\n", pPrintHandle->pNotify);

    if (pPrintHandle->pNotify) {
        movestruct(pPrintHandle->pNotify, &Notify, NOTIFY);
        DbgDumpNotify(hCurrentProcess, Print, &Notify);
    }

    (*Print)("PPRINTHANDLE            pNext  %p\n", pPrintHandle->pNext);
    (*Print)("DWORD           fdwReplyTypes  0x%.8x\n", pPrintHandle->fdwReplyTypes);

    return TRUE;
}

BOOL
DbgDumpChange(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PCHANGE pChange)
{

    WCHAR Buffer[MAX_PATH+1];
    CHANGE Change;

    // if we've got no address, then quit now - nothing we can do

    if (!pChange) {
        return(0);
    }


    movestruct(pChange, &Change, CHANGE);

    if (Change.signature != CHANGEHANDLE_SIGNATURE) {
        (*Print)("Warning: Unknown Signature\n");
        return FALSE;
    }

    (*Print)("Change %p\n", pChange);
    (*Print)("                         Link  %p\n", Change.Link.pNext);
    (*Print)("                    signature  %d\n", Change.signature);
    (*Print)("                      eStatus  0x%x ", Change.eStatus);
    ExtractChangeStatus(Print, Change.eStatus);

    (*Print)("                      dwColor  %d\n", Change.dwColor);
    (*Print)("                         cRef  %d\n", Change.cRef);

    movestr(Change.pszLocalMachine, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("              pszLocalMachine  %ws\n", Buffer);

    DbgDumpChangeInfo(hCurrentProcess, Print, &Change.ChangeInfo);

    (*Print)("                      dwCount  0x%.8x\n", Change.dwCount);
    (*Print)("                       hEvent  0x%.8x\n", Change.hEvent);
    (*Print)("               fdwChangeFlags  0x%.8x\n", Change.fdwChangeFlags);
    (*Print)("              dwPrinterRemote  0x%.8x\n", Change.dwPrinterRemote);
    (*Print)("                hNotifyRemote  0x%.8x\n", Change.hNotifyRemote);

    return TRUE;
}

BOOL
DbgDumpNotify(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PNOTIFY pNotify)
{
    (*Print)("Notify\n");
    (*Print)("                  signature  %d\n", pNotify->signature);
    (*Print)("               pPrintHandle  %p\n", pNotify->pPrintHandle);

    return TRUE;
}

BOOL
DbgDumpChangeInfo(HANDLE hCurrentProcess, PNTSD_OUTPUT_ROUTINE Print, PCHANGEINFO pChangeInfo)
{
    (*Print)("  ChangeInfo %x\n", pChangeInfo);
    (*Print)("                    Link  %p\n", pChangeInfo->Link.pNext);
    (*Print)("            pPrintHandle  %p\n", pChangeInfo->pPrintHandle);
    (*Print)("              fdwOptions  0x%.8x\n", pChangeInfo->fdwOptions);
    (*Print)("          fdwFilterFlags  0x%.8x\n", pChangeInfo->fdwFilterFlags);
    (*Print)("                dwStatus  0x%.8x\n", pChangeInfo->fdwStatus);
    (*Print)("              dwPollTime  0x%.8x\n", pChangeInfo->dwPollTime);
    (*Print)("          dwPollTimeLeft  0x%.8x\n", pChangeInfo->dwPollTimeLeft);
    (*Print)("          bResetPollTime  0x%.8x\n", pChangeInfo->bResetPollTime);
    (*Print)("                fdwFlags  0x%.8x\n", pChangeInfo->fdwFlags);
    (*Print)("      pPrinterNotifyInfo  %p\n", pChangeInfo->pPrinterNotifyInfo);

    return TRUE;
}

BOOL
DbgDumpLL(
    HANDLE hCurrentProcess,
    PNTSD_OUTPUT_ROUTINE Print,
    UINT_PTR pAddress,
    BOOL  bCountOn,
    DWORD dwCount,
    PUINT_PTR  pNextAddress
    )
{

    INIDRIVER IniDriver;
    INIENVIRONMENT IniEnvironment;
    INIPRINTER IniPrinter;
    INIPRINTPROC IniPrintProc;
    ININETPRINT IniNetPrint;
    INIMONITOR IniMonitor;
    INIPORT IniPort;
    WINIPORT WIniPort;
    INIFORM IniForm;
    INIJOB  IniJob;
    INISPOOLER IniSpooler;
    SPOOL   Spool;
    WSPOOL  WSpool;
    SHADOWFILE  ShadowFile;
    SHADOWFILE_2  ShadowFile2;
    DWORD   Signature;
    UINT_PTR NextAddress;
    PRINTHANDLE PrintHandle;
    INIVERSION IniVersion;
    WCACHEINIPRINTEREXTRA WCacheIniPrinterExtra;
    BOOL    bRetval = TRUE;
    DWORD   i;

    if (!pAddress) {
        *pNextAddress = 0;
        return FALSE ;
    }

    if (bCountOn && (dwCount == 0)) {
        *pNextAddress = (UINT_PTR)pAddress;
        return FALSE ;
    }

    for (i=0; pAddress && (!bCountOn || i < dwCount); i++)
    {
        movestruct(pAddress,&Signature, DWORD);

        (*Print)("\n%p ",pAddress);

        switch (Signature) {

        case ISP_SIGNATURE: // dump INISPOOLER
            movestruct(pAddress, &IniSpooler, INISPOOLER);
            DbgDumpIniSpooler(hCurrentProcess, Print, (PINISPOOLER)&IniSpooler);
            NextAddress = (UINT_PTR)IniSpooler.pIniNextSpooler;
            break;

        case IPP_SIGNATURE: // dump INIPRINTPROC structure
            movestruct(pAddress, &IniPrintProc, INIPRINTPROC);
            DbgDumpIniPrintProc(hCurrentProcess, Print, (PINIPRINTPROC)&IniPrintProc);
            NextAddress = (UINT_PTR)IniPrintProc.pNext;
            break;

        case ID_SIGNATURE: //  dump INIDRIVER structure
            movestruct(pAddress, &IniDriver, INIDRIVER);
            DbgDumpIniDriver(hCurrentProcess, Print, (PINIDRIVER)&IniDriver);
            NextAddress = (UINT_PTR)IniDriver.pNext;
            break;

        case IE_SIGNATURE: //   dump INIENVIRONMENT structure
            movestruct(pAddress, &IniEnvironment, INIENVIRONMENT);
            DbgDumpIniEnvironment(hCurrentProcess, Print, (PINIENVIRONMENT)&IniEnvironment);
            NextAddress = (UINT_PTR)IniEnvironment.pNext;
            break;

        case IV_SIGNATURE: //   dump INIVERSION structure
            movestruct(pAddress, &IniVersion, INIVERSION);
            DbgDumpIniVersion(hCurrentProcess, Print, (PINIVERSION)&IniVersion);
            NextAddress = (UINT_PTR)IniVersion.pNext;
            break;

        case IP_SIGNATURE:
            movestruct(pAddress, &IniPrinter, INIPRINTER);
            DbgDumpIniPrinter(hCurrentProcess, Print, (PINIPRINTER)&IniPrinter);
            NextAddress = (UINT_PTR)IniPrinter.pNext;
            break;

        case WCIP_SIGNATURE:
            movestruct(pAddress, &WCacheIniPrinterExtra, WCACHEINIPRINTEREXTRA);
            DbgDumpWCacheIniPrinter(hCurrentProcess, Print, (PWCACHEINIPRINTEREXTRA)&WCacheIniPrinterExtra);
            NextAddress = 0;
            break;

        case IN_SIGNATURE:
            movestruct(pAddress, &IniNetPrint, ININETPRINT);
            DbgDumpIniNetPrint(hCurrentProcess, Print, (PININETPRINT)&IniNetPrint);
            NextAddress = (UINT_PTR)IniNetPrint.pNext;
            break;

        case IMO_SIGNATURE:
            movestruct(pAddress, &IniMonitor, INIMONITOR);
            DbgDumpIniMonitor(hCurrentProcess, Print, (PINIMONITOR)&IniMonitor);
            NextAddress = (UINT_PTR)IniMonitor.pNext;
            break;

        case IPO_SIGNATURE:
            movestruct(pAddress, &IniPort, INIPORT);
            DbgDumpIniPort(hCurrentProcess, Print, (PINIPORT)&IniPort);
            NextAddress = (UINT_PTR)IniPort.pNext;
            break;

        case WIPO_SIGNATURE:
            movestruct(pAddress, &WIniPort, WINIPORT);
            DbgDumpWIniPort(hCurrentProcess, Print, (PWINIPORT)&WIniPort);
            NextAddress = (UINT_PTR)WIniPort.pNext;
            break;

        case IFO_SIGNATURE:
            movestruct(pAddress, &IniForm, INIFORM);
            DbgDumpIniForm(hCurrentProcess, Print, (PINIFORM)&IniForm);
            NextAddress = (UINT_PTR)IniForm.pNext;
            break;

        case IJ_SIGNATURE:
            movestruct(pAddress, &IniJob, INIJOB);
            DbgDumpIniJob(hCurrentProcess, Print, (PINIJOB)&IniJob);
            NextAddress = (UINT_PTR)IniJob.pIniNextJob;
            break;

        case SJ_SIGNATURE:
            movestruct(pAddress, &Spool, SPOOL);
            DbgDumpSpool(hCurrentProcess, Print, (PSPOOL)&Spool);
            NextAddress = (UINT_PTR)Spool.pNext;
            break;

        case WSJ_SIGNATURE:
            movestruct(pAddress, &WSpool, WSPOOL);
            DbgDumpWSpool(hCurrentProcess, Print, (PWSPOOL)&WSpool);
            NextAddress = (UINT_PTR)WSpool.pNext;
            break;

        case PRINTHANDLE_SIGNATURE:
            movestruct(pAddress, &PrintHandle, PRINTHANDLE);
            DbgDumpPrintHandle(hCurrentProcess, Print, (PPRINTHANDLE)&PrintHandle);
            NextAddress = 0x00000000;
            break;

        case SF_SIGNATURE:
            movestruct(pAddress, &ShadowFile, SHADOWFILE);
            DbgDumpShadowFile(hCurrentProcess, Print, (PSHADOWFILE)&ShadowFile);
            NextAddress = 0x00000000;
            break;

        case SF_SIGNATURE_2:
            movestruct(pAddress, &ShadowFile2, SHADOWFILE_2);
            DbgDumpShadowFile2(hCurrentProcess, Print, (PSHADOWFILE_2)&ShadowFile2);
            NextAddress = 0x00000000;
            break;

        default:
            // Unknown signature -- no data to dump
            (*Print)("Warning: Unknown Signature\n");
            NextAddress = 0x00000000;
            bRetval = FALSE;
            break;
        }

        pAddress = NextAddress;
        *pNextAddress = NextAddress;
    }

    return bRetval ;
}

BOOL DumpDevMode(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress
        )
{
    DEVMODEW DevMode;
    DWORD   i;

    Print("DevMode\n");

    if (!lpAddress) {
        Print("\n Null DEVMODE Structure lpDevMode = NULL\n");
        return TRUE ;
    }
    movestruct(lpAddress, &DevMode, DEVMODEW);

    Print("TCHAR        dmDeviceName[32]    %ws\n", DevMode.dmDeviceName);
    Print("WORD         dmSpecVersion       %d\n", DevMode.dmSpecVersion);
    Print("WORD         dmDriverVersion     %d\n", DevMode.dmDriverVersion);
    Print("WORD         dmSize              %d\n", DevMode.dmSize);
    Print("WORD         dmDriverExtra       %d\n", DevMode.dmDriverExtra);
    Print("DWORD        dmFields            %d\n", DevMode.dmFields);

    for (i = 0; i < MAX_DEVMODE_FIELDS; i++ ) {
        if (DevMode.dmFields & DevModeFieldsTable[i].dmField) {
            Print("\t %s is ON\n", DevModeFieldsTable[i].String);
        } else {
            Print("\t %s is OFF\n", DevModeFieldsTable[i].String);
        }
    }

    Print("short        dmOrientation       %d\n", DevMode.dmOrientation);
    Print("short        dmPaperSize         %d\n", DevMode.dmPaperSize);

    if ((DevMode.dmPaperSize >= 1) && (DevMode.dmPaperSize <= MAX_DEVMODE_PAPERSIZES)) {
        Print("Paper size from dmPaperSize is %s\n", DevModePaperSizes[DevMode.dmPaperSize - 1]);
    } else {
        Print("Paper size from dmPaperSize is out of bounds!!\n");
    }

    Print("short        dmPaperLength       %d\n", DevMode.dmPaperLength);
    Print("short        dmPaperWidth        %d\n", DevMode.dmPaperWidth);

    Print("short        dmScale             %d\n", DevMode.dmScale);
    Print("short        dmCopies            %d\n", DevMode.dmCopies);
    Print("short        dmDefaultSource     %d\n", DevMode.dmDefaultSource);
    Print("short        dmPrintQuality      %d\n", DevMode.dmPrintQuality);
    Print("short        dmColor             %d\n", DevMode.dmColor);
    Print("short        dmDuplex            %d\n", DevMode.dmDuplex);
    Print("short        dmYResolution       %d\n", DevMode.dmYResolution);
    Print("short        dmTTOption          %d\n", DevMode.dmTTOption);
    Print("short        dmCollate           %d\n", DevMode.dmCollate);
    Print("TCHAR        dmFormName[32]      %ws\n", DevMode.dmFormName);
    Print("DWORD        dmLogPixels         %d\n", DevMode.dmLogPixels);
    Print("USHORT       dmBitsPerPel        %d\n", DevMode.dmBitsPerPel);
    Print("DWORD        dmPelsWidth         %d\n", DevMode.dmPelsWidth);
    Print("DWORD        dmPelsHeight        %d\n", DevMode.dmPelsHeight);
    Print("DWORD        dmDisplayFlags      %d\n", DevMode.dmDisplayFlags);
    Print("DWORD        dmDisplayFrequency  %d\n", DevMode.dmDisplayFrequency);

    return TRUE;
}

BOOL DbgDumpPI2(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_INFO_2  pi2;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_INFO_2 pPrinterInfo;

    for ( pPrinterInfo = (PPRINTER_INFO_2)lpAddress;
          pPrinterInfo != NULL && dwCount != 0;
          pPrinterInfo++, dwCount--  ) {


        movestruct( pPrinterInfo, &pi2, PRINTER_INFO_2);

        (*Print)("\nAddress %x\n", pPrinterInfo );

         movestr(pi2.pServerName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pServerName                     %ws\n", Buffer);

         movestr(pi2.pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrinterName                    %ws\n", Buffer);

         movestr(pi2.pShareName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pShareName                      %ws\n", Buffer);

         movestr(pi2.pPortName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPortName                       %ws\n", Buffer);

         movestr(pi2.pDriverName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pDriverName                     %ws\n", Buffer);

         movestr(pi2.pComment, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pComment                        %ws\n", Buffer);

         movestr(pi2.pLocation, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pLocation                       %ws\n", Buffer);

        (*Print)("LPDEVMODE     pDevMode                        %p\n", pi2.pDevMode);

         movestr(pi2.pSepFile, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pSepFile                        %ws\n", Buffer);

         movestr(pi2.pPrintProcessor, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrintProcessor                 %ws\n", Buffer);

         movestr(pi2.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pDatatype                       %ws\n", Buffer);

         movestr(pi2.pParameters, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pParameters                     %ws\n", Buffer);

        (*Print)("PSECURITY_DESCRIPTOR pSecurityDescriptor      %p\n", pi2.pSecurityDescriptor);

        (*Print)("DWORD         Attributes                      0x%.8x\n",pi2.Attributes);
        ExtractPrinterAttributes( Print, pi2.Attributes);

        (*Print)("DWORD         Priority                        %d\n", pi2.Priority);
        (*Print)("DWORD         DefaultPriority                 %d\n", pi2.DefaultPriority);
        (*Print)("DWORD         StartTime                       %d\n", pi2.StartTime);
        (*Print)("DWORD         UntilTime                       %d\n", pi2.UntilTime);

        (*Print)("DWORD         Status                          0x%.8x\n", pi2.Status);
        ExtractExternalPrinterStatus( Print, pi2.Status );

        (*Print)("DWORD         cJobs                           %d\n", pi2.cJobs);
        (*Print)("DWORD         AveragePPM                      %d\n", pi2.AveragePPM);

    }

    return TRUE;
}



BOOL DbgDumpPI0(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_INFO_STRESS  pi0;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_INFO_STRESS pPrinterInfo;

    for ( pPrinterInfo = (PPRINTER_INFO_STRESS)lpAddress;
          pPrinterInfo != NULL && dwCount != 0;
          pPrinterInfo++, dwCount--  ) {


        movestruct( pPrinterInfo, &pi0, PRINTER_INFO_STRESS);

        (*Print)("\nAddress %x\n", pPrinterInfo );

         movestr(pi0.pPrinterName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pPrinterName                    %ws\n", Buffer);

         movestr(pi0.pServerName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pServerName                     %ws\n", Buffer);

        (*Print)("DWORD         cJobs                           %d\n", pi0.cJobs);

        (*Print)("DWORD         cTotalJobs                      %d\n", pi0.cTotalJobs);

        (*Print)("DWORD         cTotalBytes (LOWER DWORD)       %d\n", pi0.cTotalBytes);

        (*Print)("SYSTEMTIME    stUpTime                        %d/%d/%d  %d  %d:%d:%d.%d\n",pi0.stUpTime.wYear,
                                                                pi0.stUpTime.wMonth,
                                                                pi0.stUpTime.wDay,
                                                                pi0.stUpTime.wDayOfWeek,
                                                                pi0.stUpTime.wHour,
                                                                pi0.stUpTime.wMinute,
                                                                pi0.stUpTime.wSecond,
                                                                pi0.stUpTime.wMilliseconds);

        (*Print)("DWORD         MaxcRef                         %d\n", pi0.MaxcRef);

        (*Print)("DWORD         cTotalPagesPrinted              %d\n", pi0.cTotalPagesPrinted);

        (*Print)("DWORD         dwGetVersion                    %d\n", pi0.dwGetVersion);

        (*Print)("DWORD         fFreeBuild                      %d\n", pi0.fFreeBuild);

        (*Print)("DWORD         cSpooling                       %d\n", pi0.cSpooling);

        (*Print)("DWORD         cMaxSpooling                    %d\n", pi0.cMaxSpooling);

        (*Print)("DWORD         cRef                            %d\n", pi0.cRef);

        (*Print)("DWORD         cErrorOutOfPaper                %d\n", pi0.cErrorOutOfPaper);

        (*Print)("DWORD         cErrorNotReady                  %d\n", pi0.cErrorNotReady);

        (*Print)("DWORD         cJobError                       %d\n", pi0.cJobError);

        (*Print)("DWORD         dwNumberOfProcessors            %d\n", pi0.dwNumberOfProcessors);

        (*Print)("DWORD         dwProcessorType                 %d\n", pi0.dwProcessorType);

        (*Print)("DWORD         dwHighPartTotalBytes            %d\n", pi0.dwHighPartTotalBytes);

        (*Print)("DWORD         cChangeID                       %d\n", pi0.cChangeID);

        (*Print)("DWORD         dwLastError                     %d\n", pi0.dwLastError);

        (*Print)("DWORD         Status                          0x%.8x\n", pi0.Status);
        ExtractExternalPrinterStatus( Print, pi0.Status );

        (*Print)("DWORD         cEnumerateNetworkPrinters       %d\n", pi0.cEnumerateNetworkPrinters);

        (*Print)("DWORD         cAddNetPrinters                 %d\n", pi0.cAddNetPrinters);

        (*Print)("WORD          wProcessorArchitecture          %d\n", pi0.wProcessorArchitecture);

        (*Print)("WORD          wProcessorLevel                 %d\n", pi0.wProcessorLevel);
    }

    return TRUE;
}

BOOL DbgDumpFI1(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    FORM_INFO_1  fi1;
    WCHAR Buffer[MAX_PATH+1];
    PFORM_INFO_1 pFORMInfo;

    for ( pFORMInfo = (PFORM_INFO_1)lpAddress;
          pFORMInfo != NULL && dwCount != 0;
          pFORMInfo++, dwCount--  ) {


        movestruct( pFORMInfo, &fi1, FORM_INFO_1);

        (*Print)("\nAddress %p\n", pFORMInfo );

        (*Print)("DWORD         Flags                           %x", fi1.Flags);

        if ( fi1.Flags & FORM_BUILTIN )
            (*Print)(" FORM_BUILTIN\n");
        else
            (*Print)(" FORM_USERDEFINED\n");

         movestr(fi1.pName, Buffer, sizeof(WCHAR)*MAX_PATH);
        (*Print)("LPWSTR        pName                           %ws\n", Buffer);

        (*Print)("SIZEL         Size                            cx %d cy %d\n", fi1.Size.cx, fi1.Size.cy);
        (*Print)("RECTL         ImageableArea                   left %d right %d top %d bottom %d\n",
                                                                 fi1.ImageableArea.left,
                                                                 fi1.ImageableArea.right,
                                                                 fi1.ImageableArea.top,
                                                                 fi1.ImageableArea.bottom);

    }

    return TRUE;
}

BOOL DbgDumpPDEF(
        HANDLE hCurrentProcess,
        PNTSD_OUTPUT_ROUTINE Print,
        UINT_PTR lpAddress,
        DWORD   dwCount
        )
{
    PRINTER_DEFAULTS PDef;
    WCHAR Buffer[MAX_PATH+1];
    PPRINTER_DEFAULTS pPDef;

    pPDef = ( PPRINTER_DEFAULTS )lpAddress;

    movestruct( pPDef, &PDef, PRINTER_DEFAULTS);

    (*Print)("\nAddress %x\n", pPDef );

    Buffer[0] = L'\0';
     movestr(PDef.pDatatype, Buffer, sizeof(WCHAR)*MAX_PATH);
    (*Print)("LPWSTR          PrinterDefaults.pDatatype     %p %ws\n", PDef.pDatatype, Buffer);
    (*Print)("LPDEVMODE       PrinterDefaults.pDevMode      %p\n", PDef.pDevMode);
    (*Print)("ACCESS_MASK     PrinterDefaults.DesiredAccess %p\n", PDef.DesiredAccess);
    ExtractPrinterAccess( Print, PDef.DesiredAccess );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\bitarray.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    bitarray.cxx

Abstract:

    Common utils.

Author:

    Steve Kiraly (SteveKi)  01-12-97

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

/********************************************************************

    Bit Array class

********************************************************************/

TBitArray::
TBitArray(
    IN UINT nBits,
    IN UINT uGrowSize
    ) : _nBits( nBits ),
        _pBits( NULL ),
        _uGrowSize( uGrowSize )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::ctor\n" ) );

    //
    // If the initial number of bits is not specified then
    // create a default bit array size.
    //
    if( !_nBits )
    {
        _nBits = kBitsInType;
    }

    //
    // This could fail, thus leaving the bit array
    // in an invalid state, Note _pBits being true is
    // the bValid check.
    //
    _pBits = new Type [ nBitsToType( _nBits ) ];

    if( _pBits )
    {
        //
        // The grow size should be at least the
        // number of bits in the type.
        //
        if( _uGrowSize < kBitsInType )
        {
            _uGrowSize = kBitsInType;
        }

        //
        // Clear all the bits.
        //
        memset( _pBits, 0, nBitsToType( _nBits ) * sizeof( Type ) );
    }
}

TBitArray::
TBitArray(
    const TBitArray &rhs
    ) : _nBits( kBitsInType ),
        _pBits( NULL )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::copy_ctor\n" ) );
    bClone( rhs );
}

const TBitArray &
TBitArray::
operator =(
    const TBitArray &rhs
    )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::operator =\n" ) );
    bClone( rhs );
    return *this;
}

TBitArray::
~TBitArray(
    VOID
    )
    {
    DBGMSG( DBG_TRACE, ( "TBitArray::dtor\n" ) );
    delete [] _pBits;
}

BOOL
TBitArray::
bValid(
    VOID
    ) const
{
    return _pBits != NULL;
}

BOOL
TBitArray::
bToString(
    IN TString &strBits
    ) const
{
    BOOL bStatus = bValid();

    if( bStatus )
    {
        TString strString;

        strBits.bUpdate( NULL );

        //
        // Get the upper bound bit.
        //
        UINT uIndex = _nBits - 1;

        //
        // Print the array in reverse order to make the bit array
        // appear as one large binary number.
        //
        for( UINT i = 0; i < _nBits; i++, uIndex-- )
        {
            strString.bFormat( TEXT( "%d" ), bRead( uIndex ) );
            strBits.bCat( strString );
        }

        bStatus = strBits.bValid();
    }

    return bStatus;
}

BOOL
TBitArray::
bRead(
    IN UINT Bit
    ) const
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        bStatus = _pBits[BitToIndex( Bit )] & BitToMask( Bit ) ? TRUE : FALSE;
    }

    return bStatus;
}

BOOL
TBitArray::
bSet(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] |= BitToMask( Bit );
    }

    return bStatus;
}

BOOL
TBitArray::
bReset(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] &= ~BitToMask( Bit );
    }

    return bStatus;
}

BOOL
TBitArray::
bToggle(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] ^= BitToMask( Bit );
    }

    return bStatus;
}

//
// Add one new bit to the end of the bit array.
// If multiple bits need to be added the user of the
// class should call this routine repeatedly.
//
BOOL
TBitArray::
bAdd(
    VOID
    )
{
    BOOL bStatus = FALSE;
    UINT Bit = _nBits + 1;

    //
    // Check if there is room in the array for one more bit.
    //
    if( Bit <= nBitsToType( _nBits ) * kBitsInType )
    {
        //
        // Update the current bit count and return true.
        //
        _nBits  = Bit;
        bStatus = TRUE;
    }
    else
    {
        //
        // Grow the bit array.
        //
        bStatus = bGrow( Bit );
    }

    return bStatus;
}

VOID
TBitArray::
vSetAll(
    VOID
    )
{
    for( UINT i = 0; i < _nBits; i++ )
    {
        bSet( i );
    }
}

VOID
TBitArray::
vResetAll(
    VOID
    )
{
    for( UINT i = 0; i < _nBits; i++ )
    {
        bReset( i );
    }
}

UINT
TBitArray::
uNumBits(
    VOID
    ) const
{
    return _nBits;
}


BOOL
TBitArray::
bFindNextResetBit(
    IN UINT *puNextFreeBit
    )
{
    BOOL bStatus = bValid();

    if( bStatus )
    {
        BOOL bFound = FALSE;

        //
        // Locate the first type that contains at least one cleared bit.
        //
        for( UINT i = 0; i < nBitsToType( _nBits ); i++ )
        {
            if( _pBits[i] != kBitsInTypeMask )
            {
                //
                // Search for the bit that is cleared.
                //
                for( UINT j = 0; j < kBitsInType; j++ )
                {
                    if( !( _pBits[i] & BitToMask( j ) ) )
                    {
                        *puNextFreeBit = i * kBitsInType + j;
                        bFound = TRUE;
                        break;
                    }
                }
            }

            //
            // Free bit found terminate the search.
            //
            if( bFound )
            {
                break;
            }
        }

        //
        // Free bit was not found then grow the bit array
        //
        if( !bFound )
        {
            //
            // Assume a new bit will be added.
            //
            *puNextFreeBit = uNumBits();

            //
            // Add a new bit.
            //
            bStatus = bAdd();
        }
    }
    return bStatus;
}


/********************************************************************

    Bit Array - private member functions.

********************************************************************/

BOOL
TBitArray::
bClone(
    const TBitArray &rhs
    )
{
    BOOL bStatus = FALSE;

    if( this == &rhs )
    {
        bStatus = TRUE;
    }
    else
    {
        Type *pTempBits = new Type [ nBitsToType( _nBits ) ];

        if( pTempBits )
        {
            memcpy( pTempBits, rhs._pBits, nBitsToType( _nBits ) * sizeof( Type ) );
            delete [] _pBits;
            _pBits = pTempBits;
            _nBits = rhs._nBits;
            bStatus = TRUE;
        }
    }
    return bStatus;
}

BOOL
TBitArray::
bGrow(
    IN UINT uBits
    )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::bGrow\n" ) );

    BOOL bStatus    = FALSE;
    UINT uNewBits   = uBits + _uGrowSize;

    DBGMSG( DBG_TRACE, ( "Grow to size %d Original size %d Buffer pointer %x\n", uNewBits, _nBits, _pBits ) );

    //
    // We do support reducing the size of the bit array.
    //
    SPLASSERT( uNewBits > _nBits );

    //
    // Allocate the enlarged bit array.
    //
    Type *pNewBits  = new Type [ nBitsToType( uNewBits ) ];

    if( pNewBits )
    {
        //
        // Clear the new bits.
        //
        memset( pNewBits, 0, nBitsToType( uNewBits ) * sizeof( Type ) );

        //
        // Copy the old bits to the new bit array.
        //
        memcpy( pNewBits, _pBits, nBitsToType( _nBits ) * sizeof( Type ) );

        //
        // Release the old bit array and save the new pointer and size.
        //
        delete [] _pBits;
        _pBits  = pNewBits;
        _nBits  = uBits;

        //
        // Success.
        //
        bStatus = TRUE;
    }

    DBGMSG( DBG_TRACE, ( "New size %d Buffer pointer %x\n", _nBits, _pBits ) );

    return bStatus;
}

UINT
TBitArray::
nBitsToType(
    IN UINT uBits
    ) const
{
    return ( uBits + kBitsInType - 1 ) / kBitsInType;
}

TBitArray::Type
TBitArray::
BitToMask(
    IN UINT uBit
    ) const
{
    return 1 << ( uBit % kBitsInType );
}

UINT
TBitArray::
BitToIndex(
    IN UINT uBit
    ) const
{
    return uBit / kBitsInType;
}

BOOL
TBitArray::
bIsValidBit(
    IN UINT uBit
    ) const
{
    BOOL bStatus = ( uBit < _nBits ) && bValid();

    if( !bStatus )
    {
        DBGMSG( DBG_TRACE, ( "Invalid bit value %d\n", uBit ) );
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\checkpoint.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    checkpoint.cxx

Abstract:

    This file implements a class (or for 'C' handle based) calls to set and 
    restore system breakpoints. 

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

--*/

#include "spllibp.hxx"
#include "checkpoint.hxx"

TSystemRestorePoint::
TSystemRestorePoint(
    VOID
    ) : m_hLibrary(NULL),
        m_pfnSetRestorePoint(NULL),
        m_bSystemRestoreSet(FALSE), 
        m_hr(E_FAIL)
{
    memset(&m_RestorePointInfo, 0, sizeof(m_RestorePointInfo));

    m_hr = Initialize();
}

TSystemRestorePoint::
~TSystemRestorePoint(
    VOID
    )
{
    if (m_hLibrary)
    {
        FreeLibrary(m_hLibrary);
    }
}

HRESULT
TSystemRestorePoint::
IsValid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Routine Name:

    StartSystemRestorePoint

Routine Description:

    This routine starts a system restore point in the AddPrinterDriver code.

Arguments:

    pszServer       -   The server name on which we are setting the restore point.
    pszDriverName   -   The driver name of which we are trying to install.
    hInst           -   The hInstance of the resource library.
    ResId           -   The resource id to use for the message string.

Return Value:

    An HRESULT.

--*/
HRESULT
TSystemRestorePoint::
StartSystemRestorePoint(
    IN      PCWSTR          pszServer,
    IN      PCWSTR          pszDriverName,
    IN      HINSTANCE       hInst,
    IN      UINT            ResId
    )
{
    HRESULT         hRetval     = E_FAIL;
    STATEMGRSTATUS  SMgrStatus;
    WCHAR           szDriverName[MAX_DESC];
    WCHAR           szMessage[MAX_DESC];

    hRetval = pszDriverName && hInst ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // We only set system restore points on the local machine for now.
    // 
    if (SUCCEEDED(hRetval) && !pszServer)
    {
        
        if (SUCCEEDED(hRetval))
        {
            if (LoadString(hInst, ResId, szMessage, COUNTOF(szMessage))) 
            {
                //
                // We have to check here if the length of the message 
                // is at least two (because of the string terminator and
                // at least one format specifier)
                //
                if (lstrlen(szMessage) > 2) 
                {
                    hRetval = S_OK;
                }
                else
                {
                    hRetval = HResultFromWin32(ERROR_RESOURCE_DATA_NOT_FOUND);
                }
            }
            else
            {
                hRetval = GetLastErrorAsHResult();
            }
        }

        if (SUCCEEDED(hRetval))
        {
            PWSTR       pszArray[1];

            //
            // Now we calculate how much of the driver name we can fit into the 
            // message (which is only 64 characters). This is 
            // MAX_DESC - (strlen(szMessage) - 2) - 1. 
            // 
            wcsncpy(szDriverName, pszDriverName, MAX_DESC - wcslen(szMessage) + 2);

            szDriverName[MAX_DESC - wcslen(szMessage) + 1] = L'\0';

            pszArray[0] = szDriverName;

            hRetval = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   szMessage, 
                                   0, 
                                   0, 
                                   m_RestorePointInfo.szDescription,
                                   COUNTOF(m_RestorePointInfo.szDescription),
                                   (va_list *)pszArray) ? S_OK : GetLastErrorAsHResult();        
        }

        //
        // Now that we have the system restore point, set it.
        //
        if (SUCCEEDED(hRetval))
        {
            m_RestorePointInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
            m_RestorePointInfo.dwRestorePtType = DEVICE_DRIVER_INSTALL;
            m_RestorePointInfo.llSequenceNumber = 0;

            hRetval = m_pfnSetRestorePoint(&m_RestorePointInfo, &SMgrStatus) ? S_OK : HRESULT_FROM_WIN32(SMgrStatus.nStatus);                            
        }

        if (SUCCEEDED(hRetval))
        {
            m_bSystemRestoreSet = TRUE;
        }
        else
        {
            //
            // Failing to set the system restore point should not stop us adding 
            // the printer driver.
            // 
            hRetval = S_OK;
        }
    }
    
    return hRetval;
}

/*++

Routine Name:

    EndSystemRestorePoint

Routine Description:

    This function either completes the system restore point or it cancels it if
    if whoever was doing the installiong tells us to.

Arguments:

    bCancel         -   If TRUE, the restore point should be cancelled.

Return Value:

    An HRESULT.

--*/
HRESULT
TSystemRestorePoint::
EndSystemRestorePoint(
    IN      BOOL            bCancel
    )
{
    HRESULT         hRetval = S_OK;
    STATEMGRSTATUS  SMgrStatus;

    if (m_bSystemRestoreSet)
    {
        m_RestorePointInfo.dwEventType     = END_NESTED_SYSTEM_CHANGE;
        m_RestorePointInfo.dwRestorePtType = bCancel ? CANCELLED_OPERATION : DEVICE_DRIVER_INSTALL;
        
        hRetval = m_pfnSetRestorePoint(&m_RestorePointInfo, &SMgrStatus) ? S_OK : HRESULT_FROM_WIN32(SMgrStatus.nStatus);                            
    }

    return hRetval;
}

/******************************************************************************

    Private Methods
    
******************************************************************************/    
/*++

Routine Name:

    Initialize

Routine Description:

    Load the system restore library and get the address of the system restore
    function.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
TSystemRestorePoint::
Initialize(
    VOID
    )
{    
    HRESULT hRetval = E_FAIL;
    
    m_hLibrary = LoadLibraryFromSystem32(L"srclient.dll");

    hRetval  = m_hLibrary ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        m_pfnSetRestorePoint = reinterpret_cast<PFnSRSetRestorePoint>(GetProcAddress(m_hLibrary, "SRSetRestorePointW"));

        hRetval  = m_pfnSetRestorePoint ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}


/*++

Routine Name:

    StartSystemRestorePoint

Routine Description:

    This form of the function is for C callers, it is handle based.

Arguments:

    pszServer       -   The server on which we are doing the restore point.
    pszDriverName   -   The driver name we are installing.
    hInst           -   The instance in which the resource which we want to load is.
    ResId           -   The Resource Id.

Return Value:

    An HRESULT

--*/
extern "C"
HANDLE
StartSystemRestorePoint(
    IN      PCWSTR          pszServer,
    IN      PCWSTR          pszDriverName,
    IN      HINSTANCE       hInst,
    IN      UINT            ResId
    )
{
    HRESULT hRetval         = E_FAIL;
    HANDLE  hRestorePoint   = NULL;

#ifdef _WIN64
    return NULL;
#endif

    TSystemRestorePoint *pSystemRestorePoint = new TSystemRestorePoint;

    hRetval = pSystemRestorePoint ? pSystemRestorePoint->IsValid() : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        hRetval = pSystemRestorePoint->StartSystemRestorePoint(pszServer, pszDriverName, hInst, ResId);
    }

    if (SUCCEEDED(hRetval))
    {
        hRestorePoint = pSystemRestorePoint;

        pSystemRestorePoint = NULL;
    }
    else
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    delete pSystemRestorePoint;

    return hRestorePoint;
}

/*++

Routine Name:

    EndSystemRestorePoint

Routine Description:

    This form of the function is for C callers, it is handle based.
    Note: This also closes the handle.

Arguments:

    hRestorePoint   -   The system restore point.
    bCancel         -   If TRUE, the system restore point should be cancelled 
                        and not completed.
    
Return Value:

    An HRESULT

--*/
extern "C"
BOOL
EndSystemRestorePoint(
    IN      HANDLE          hRestorePoint,
    IN      BOOL            bCancel
    )
{

    HRESULT             hRetval        = E_FAIL;
    TSystemRestorePoint *pRestorePoint = reinterpret_cast<TSystemRestorePoint *>(hRestorePoint);

#ifdef _WIN64
    return SUCCEEDED( E_FAIL );
#endif

    hRetval = pRestorePoint ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hRetval))
    {
        hRetval = pRestorePoint->EndSystemRestorePoint(bCancel);

        delete pRestorePoint;
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }
    
    return SUCCEEDED(hRetval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\clink.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    CLink.cxx

Abstract:

    C linkage support for DEBUG support only.

Author:

    Albert Ting (AlbertT)  10-Oct-95

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG

extern DBG_POINTERS gDbgPointers;

VBackTrace *pbtCS = NULL;

VOID
DbgEnterCriticalSection(
    PCRITICAL_SECTION pcs
    )
{
    if( !pbtCS ){
        pbtCS = new TBackTraceFile;
    }

    EnterCriticalSection( pcs );
    pbtCS->hCapture( (ULONG_PTR)pcs, 1 );
}

VOID
DbgLeaveCriticalSection(
    PCRITICAL_SECTION pcs
    )
{
    if( !pbtCS ){
        pbtCS = new TBackTraceFile;
    }

    pbtCS->hCapture( (ULONG_PTR)pcs, 0 );
    LeaveCriticalSection( pcs );
}


HANDLE
DbgAllocBackTrace(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceMem;
}

HANDLE
DbgAllocBackTraceMem(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceMem;
}

HANDLE
DbgAllocBackTraceFile(
    VOID
    )
{
    return (HANDLE)(VBackTrace*) new TBackTraceFile;
}

VOID
DbgFreeBackTrace(
    HANDLE hBackTrace
    )
{
    delete (VBackTrace*)hBackTrace;
}

VOID
DbgCaptureBackTrace(
    HANDLE hBackTrace,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3
    )
{
    VBackTrace* pBackTrace = (VBackTrace*)hBackTrace;
    if( pBackTrace ){
        pBackTrace->hCapture( Info1, Info2, Info3 );
    }
}

HANDLE
DbgAllocCritSec(
    VOID
    )
{
    return (HANDLE)new MCritSec;
}

VOID
DbgFreeCritSec(
    HANDLE hCritSec
    )
{
    delete (MCritSec*)hCritSec;
}

BOOL
DbgInsideCritSec(
    HANDLE hCritSec
    )
{
    return ((MCritSec*)hCritSec)->bInside();
}

BOOL
DbgOutsideCritSec(
    HANDLE hCritSec
    )
{
    return ((MCritSec*)hCritSec)->bOutside();
}

VOID
DbgEnterCritSec(
    HANDLE hCritSec
    )
{
    ((MCritSec*)hCritSec)->vEnter();
}

VOID
DbgLeaveCritSec(
    HANDLE hCritSec
    )
{
    ((MCritSec*)hCritSec)->vLeave();
}

VOID
DbgSetAllocFail(
    BOOL bEnable,
    LONG cAllocFail
    )
{
    gbAllocFail = bEnable;
    gcAllocFail = cAllocFail;
}

PVOID
DbgGetPointers(
    VOID
    )
{
    return &gDbgPointers;
}

#else

//
// Stub these out so that non-DBG builds can link w/ debug spoolss.dll.
//

PVOID
DbgGetPointers(
    VOID
    )
{
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\autoptr.inl ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    autoptr.hxx

Abstract:

    Auto pointer inline implmentation.
         
Author:

    Steve Kiraly (SteveKi)  5/15/96

Revision History:

--*/

// Constructor
template< class T >
_INLINE
auto_ptr<T>::
auto_ptr(           
        T *p
        ) : pointee(p) 
{
};

// Destructor
template< class T >
_INLINE
auto_ptr<T>::
~auto_ptr(          
    VOID
    ) 
{ 
    delete pointee; 
};

// Dereference 
template< class T >
_INLINE
T& 
auto_ptr<T>::
operator*(          
    VOID
    ) const
{
    return *pointee;
}

// Dereference
template< class T >
_INLINE
T* 
auto_ptr<T>::
operator->(         
    VOID
    ) const
{
    return pointee;
}

// Return value of current dumb pointer
template< class T >
_INLINE
T* 
auto_ptr<T>::
get(                
    VOID
    ) const
{
    return pointee;
}

// Relinquish ownership of current dumb pointer
template< class T >
_INLINE
T * 
auto_ptr<T>::
release(            
    VOID
    ) 
{
    T *oldPointee = pointee;
    pointee = 0;
    return oldPointee;
}

// Delete owned dumb pointer
template< class T >
_INLINE
VOID
auto_ptr<T>::
reset(              
    T *p
    ) 
{
    delete pointee;
    pointee = p;
}

// Copying an auto pointer
template< class T >
_INLINE
auto_ptr<T>::
auto_ptr(                   
    const auto_ptr<T>& rhs  
    ) : pointee( rhs.release() )
{
}

// Assign one auto pointer to another
template< class T >
_INLINE
const auto_ptr<T>&          
auto_ptr<T>::
operator=(                  
    const auto_ptr<T>& rhs  
    )
{
    if( this != &rhs )
    {
        reset( rhs.release() );
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\csem.cxx ===
/*****************************************************************************\
* Class  CriticalSection - Implementation
*
* Copyright (C) 1998 Microsoft Corporation
*
* History:
*   Jun 10, 1998, Weihai Chen (weihaic)
*
\*****************************************************************************/

#include "spllibp.hxx"

CCriticalSection::CCriticalSection (void):
    m_bValid (TRUE)
{
    __try {
        InitializeCriticalSection (&m_csec);
    }
    __except (1) {
        m_bValid = FALSE;
        SetLastError (ERROR_INVALID_HANDLE);
    }
}


CCriticalSection::~CCriticalSection (void)
{

    if (m_bValid) {
        DeleteCriticalSection (&m_csec);
    }
}

BOOL
CCriticalSection::Lock (void)
const
{
    BOOL bRet;
    
    if (m_bValid) {
    
        __try {
            EnterCriticalSection ((PCRITICAL_SECTION) &m_csec);
            bRet = TRUE;
        }
        __except (1) {
            SetLastError (ERROR_INVALID_HANDLE);
            bRet = FALSE;
        }
    }   
    else
        bRet = FALSE;
        
    return bRet;
}

BOOL
CCriticalSection::Unlock (void)
const
{   
    BOOL bRet;
    
    if (m_bValid) {
        LeaveCriticalSection ((PCRITICAL_SECTION) &m_csec);
        bRet = TRUE;
    }
    else
        bRet = FALSE;
        
    return TRUE;
}

    
TAutoCriticalSection::TAutoCriticalSection (
    CONST TCriticalSection & refCrit):
    m_pCritSec (refCrit)
    
{
    m_bValid = m_pCritSec.Lock ();
}

TAutoCriticalSection::~TAutoCriticalSection ()
{
    if (m_bValid) 
        m_pCritSec.Unlock ();
}

BOOL 
TAutoCriticalSection::bValid (VOID) 
{ 
    return m_bValid; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\cstmarsh.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    cstmars.cxx

Abstract:

    Code for custom marshalling spooler structures sent via RPC/LPC

Author:

    Adina Trufinescu (AdinaTru) 01/27/00

Revision History:

    
--*/

#include "spllibp.hxx"
#pragma hdrstop

/*++

Routine Name:   

    AlignUp

Routine Description: 

    Aligns up address to specified boundary

Arguments:  

    Addr   --  pointer to be aligned
    Boundary -- alignment boundary

Return Value:  

    Aligned pointer

Last Error: 

    Not set

--*/
inline
PBYTE
AlignIt(
    IN  PBYTE       Addr,
    IN  ULONG_PTR   Boundary
    ) 
{
    return (PBYTE)(((ULONG_PTR) (Addr) + (Boundary - 1))&~(Boundary - 1));
}

/*++

Routine Name:   

    BasicMarshallDownStructure

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{

    PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    BOOL    ReturnValue = FALSE;   
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;        
    }

    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        //
        // Pointer fields only: Convert pointers to offsets.
        //
        if (pFieldInfo[Index].Type == PTR_TYPE) 
        {
            Offset = pFieldInfo[Index].Offset;

            pOffset = (PBYTE *) (pStructure + Offset);

            if (*pOffset)
            {
                *pOffset -= (ULONG_PTR)pStructure;                
            }
         }
    }

    ReturnValue = TRUE;

End:
    return ReturnValue;

}

/*++

Routine Name:   

    BasicMarshallDownEntry

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    return BasicMarshallDownStructure(pStructure, pFieldInfo);
}

/*++

Routine Name:   

    MarshallUpStructure

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled up
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters.
--*/
BOOL
BasicMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    DWORD32 dwStrOffset = 0;
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }
    
    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        //
        // Pointer fields only: Convert offsets to pointers.
        //
        if(pFieldInfo[Index].Type == PTR_TYPE) 
        {
            Offset = pFieldInfo[Index].Offset;

            pOffset = (PBYTE *)(pStructure + Offset);

            if (*pOffset)
            {
                *pOffset += (ULONG_PTR) pStructure;                
            }
         }
    }

    ReturnValue = TRUE;
    
End:
    return ReturnValue;
}

/*++

Routine Name:   

    BasicMarshallUpEntry

Routine Description: 

    Performs the simplest marshalling where pointer are replaced by offsets.
    It is architecture/bitness independent.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
BasicMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    )
{
    return BasicMarshallUpStructure(pStructure, pFieldInfo);
}

/*++

Routine Name:   

    CustomMarshallDownEntry

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled down structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    
Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    PBYTE   *pOffset = NULL;
    PBYTE   pLast = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    ULONG_PTR Size = 0;
    ULONG_PTR Alignment = 0;
    BOOL    ReturnValue = FALSE;   

    //
    // pLast keeps track of the end of the shrinked part of the structure.
    //
    for (Index = 0, pLast = pStructure;
         Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff;
         ++Index)
     {
        //
        // ShiftIndex keeps track of how many bytes the structure shrinked because of 
        // shifting data.
        // pOffset points to the next field in the structure.
        // pOffset needs to be adjusted with ShiftIndex since structure changed.
        //
        pOffset = (PBYTE *)(pStructure + Offset);        

        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // Calculate the offset relatively to the new place where 
                // the structure will lay down on 32bit (pNewStructure).
                //
                if (*pOffset)
                {
                    *pOffset -= (ULONG_PTR) pNewStructure;
                }
                //
                // For pointers, enforce the size and alignment as they are on 32b
                //
                Size = sizeof(DWORD32);

                Alignment = sizeof(DWORD32);

                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;

                Alignment = pFieldInfo[Index].Alignment;

                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }

        //
        // pLast is the place where the fields should lay, as it is on 32b
        //
        pLast = AlignIt(pLast, Alignment);
        //
        // Enforce the alignment
        //
        MoveMemory((PBYTE)pLast, 
                   (PBYTE)pOffset, 
                   Size);
        //
        // Update pLast. After this, pLast points to the end of the shrinked part of the structure
        //
        pLast += Size;
    }
 
    //
    // Move up the shrinked structure in the 32bit structures to became array
    //
    MoveMemory(pNewStructure, 
               pStructure, 
               StructureSize);

    ReturnValue = TRUE;
End:
    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallDownStructure

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    BOOL    ReturnValue = FALSE;    

    ReturnValue = CustomMarshallDownEntry(pStructure, pStructure, pFieldInfo, StructureSize);

    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallUpEntry

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.
    It also handles 32-64 bit machine compatibility.

Arguments:  

    pStructure   --  pointer to the structure to be marshalled up
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled up structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the structure as it is to be when marshalled up
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
CustomMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize
    )
{
    PBYTE   *pOffset = NULL;
    PBYTE   pOffsetAlign = NULL;
    PBYTE   pLast = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    DWORD32 dwStrOffset = 0;
    DWORD32 ShiftIndex = 0;
    ULONG_PTR   Size = 0;
    ULONG_PTR   Alignment = 0;
    BOOL    ReturnValue = FALSE;
    //
    // The structure is part of the array of shrinked structures as for 32bit. 
    // Before expanding, we need to move the structure down in it's place in the 
    // array of 64bit structures to be.
    //
    MoveMemory(pNewStructure, 
               pStructure, 
               ShrinkedSize);
    //
    // pLast keeps track of the end of the expanded part of the structure.
    //
    for (Index = 0, ShiftIndex = 0, pLast = pNewStructure;
         Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff;
         ++Index)
     {
        pOffset = (PBYTE *)(pNewStructure + Offset);

        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // ShiftIndex keeps track of how many bytes the structure expanded.
                // pLast points to the field of the 32b structure that needs to be marshalled.
                // pLast - ShiftIndex points where the field was on 32b including the enforced padding.
                // Align (pLast - ShiftIndex) as it use to be on 32b and than add the shifting 
                // to determine the place of this field.
                // 
                Alignment = sizeof(DWORD32);

                pOffsetAlign = AlignIt(pLast - ShiftIndex, Alignment);

                pLast = pOffsetAlign + ShiftIndex;

                //
                // Move field on it's offset on 64b.
                //        
                MoveMemory((PBYTE)pOffset, 
                           (PBYTE)pLast, 
                           StructureSize - Offset);

                ShiftIndex += (DWORD32)((ULONG_PTR)pOffset - (ULONG_PTR)pLast);
                
                //
                // Expand 32bit pointer to 64bit.
                //
                MoveMemory((PBYTE) pOffset + sizeof(ULONG64),
                           (PBYTE) pOffset + sizeof(ULONG32),
                           StructureSize - (Offset + sizeof(ULONG32) + sizeof(ULONG32)));

                ShiftIndex += sizeof(DWORD32);

                dwStrOffset = *(LPDWORD)pOffset;            
                //
                // Update pointer field if offset different than zero.
                //
                if (dwStrOffset)
                {
                    *pOffset = pStructure + dwStrOffset;
                }
                else
                {
                    *pOffset = NULL;
                }

                Size = sizeof(DWORD64);

                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;

                Alignment = pFieldInfo[Index].Alignment;
                //
                // Align (pLast - ShiftIndex) as it use to be on 32b and than add the shifting 
                // to determine the place of this field.
                //
                pOffsetAlign = AlignIt(pLast - ShiftIndex, Alignment);

                pLast = pOffsetAlign + ShiftIndex;
                //
                // Move field on it's 64b place.
                //
                MoveMemory((PBYTE)pOffset, 
                           (PBYTE)pLast, 
                           StructureSize - Offset);

                ShiftIndex += (DWORD32)((ULONG_PTR)pOffset - (ULONG_PTR)pLast);
                
                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }
        //
        // Again, pLast keeps track of the end of the expanded part of the structure.
        //            
        pLast = (PBYTE)pOffset + Size;
     }
 
    ReturnValue =  TRUE;
End:
    return ReturnValue;
}


/*++

Routine Name:   

    CustomMarshallUpStructure

Routine Description: 

    Performs the custom down marshalling where a 64bit structure is shrinked so that 
    a 32bit process can basicly unmarshall it. 
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if NULL parameters

--*/
BOOL
CustomMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    )
{
    BOOL    ReturnValue = FALSE;

    ReturnValue = CustomMarshallUpEntry(pStructure, pStructure, pFieldInfo, StructureSize, StructureSize);
    
    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\cstmarsh.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    cstmars.h

Abstract:

    Declarations for custom marshalling spooler structures sent via RPC/LPC

Author:

    Adina Trufinescu (AdinaTru) 01/27/00

Revision History:

    
--*/

inline
PBYTE
AlignIt(
    IN  PBYTE       Addr,
    IN  ULONG_PTR   Boundary
    );


BOOL
BasicMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );


BOOL
BasicMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );

BOOL
BasicMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );


BOOL
BasicMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo
    );

BOOL
CustomMarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize
    );

BOOL
CustomMarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\common.cxx ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation
All rights reserved.

Module Name:

    common.cxx

Abstract:

    common functions across all spooler components

Author:

    Steve Kiraly (SteveKi)

Revision History:

    Felix Maxa (AMaxa) 19 Apr 2001
    Added StrCatSystemPath

--*/
#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"

extern "C"
DWORD
WINAPIV
StrCatAlloc(
    IN OUT  LPCTSTR      *ppszString,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    and returns a pointer to the new string.  It's the callers
    responsibility to release the returned string with a call
    to FreeSplMem();  The last argument must be a NULL
    to signify the end of the argument list.

Arguments:

    ppszString - pointer where to return pointer to newly created
                 string which is the concatenation of the passed
                 in strings.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

Usage

--*/
{
    UINT    uTotalLen   = 0;
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    LPTSTR  pszString   = NULL;
    LPCTSTR pszTemp     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (ppszString)
    {
        dwRetval = ERROR_SUCCESS;

        //
        // Keep the callers from getting random value on failure.
        //
        *ppszString = NULL;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, ppszString);

        //
        // Tally up all the strings.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, LPCTSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Sum all the string lengths.
            //
            uTotalLen = uTotalLen + _tcslen(pszTemp);
        }

        //
        // Need space for the null terminator.
        //
        uTotalLen = uTotalLen + 1;

        //
        // Allocate the space for the sum of all the strings.
        //
        pszString = (LPTSTR)AllocSplMem(uTotalLen * sizeof(TCHAR));

        if (pszString)
        {
            *pszString = L'\0';

            //
            // Reset the pointer to the argument frame.
            //
            va_start(pArgs, ppszString);

            //
            // Concatenate all the strings.
            //
            for ( ; ; )
            {
                pszTemp = va_arg(pArgs, LPCTSTR);

                if (!pszTemp)
                {
                    break;
                }

                _tcscat(pszString, pszTemp);
            }

            //
            // Copy back the string pointer to the caller.
            //
            *ppszString = pszString;
        }
        else
        {
            dwRetval = ERROR_NOT_ENOUGH_MEMORY;
        }

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;
}

extern "C"
DWORD
WINAPIV
StrNCatBuff(
    IN      LPTSTR      pszBuffer,
    IN      UINT        cchBuffer,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    into the provided buffer.  The last argument must be a NULL
    to signify the end of the argument list.

Arguments:

    pszBuffer  - pointer buffer where to place the concatenated
                 string.
    cchBuffer  - character count of the provided buffer including
                 the null terminator.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

--*/
{
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    LPCTSTR pszTemp     = NULL;
    LPTSTR  pszDest     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (pszBuffer && cchBuffer)
    {
        //
        // Assume success.
        //
        dwRetval = ERROR_SUCCESS;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, cchBuffer);

        //
        // Get temp destination pointer.
        //
        pszDest = pszBuffer;

        //
        // Insure we have space for the null terminator.
        //
        cchBuffer--;

        //
        // Collect all the arguments.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, LPCTSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Copy the data into the destination buffer.
            //
            for ( ; cchBuffer; cchBuffer-- )
            {
                if (!(*pszDest = *pszTemp))
                {
                    break;
                }

                pszDest++, pszTemp++;
            }

            //
            // If were unable to write all the strings to the buffer,
            // set the error code and nuke the incomplete copied strings.
            //
            if (!cchBuffer && pszTemp && *pszTemp)
            {
                dwRetval = ERROR_INVALID_PARAMETER;
                *pszBuffer = _T('\0');
                break;
            }
        }

        //
        // Terminate the buffer always.
        //
        *pszDest = _T('\0');

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;

}

extern "C"
LPTSTR
WINAPI
SubChar(
    IN LPCTSTR  pszIn,
    IN TCHAR    cIn,
    IN TCHAR    cOut
    )
/*++

Routine Description:

    Replaces all instances of cIn in pszIn with cOut.

Arguments:

    pszIn   - input string
    cIn     - character to replace with cOut
    cOut    - character that replaces cIn

Return Value:

    If successful, returns a pointer to an allocated buffer containing the
    output string.  If the return value is NULL, SubChar has fails and
    GetLastError() will return the error.

Notes:

    An output buffer is allocated (and contains NULL) even if pszOut is NULL.

--*/
{
    LPTSTR   pszReturn   = NULL;
    LPTSTR   pszOut      = NULL;

    if (cIn && pszIn)
    {
        if ((pszOut = pszReturn = (LPTSTR) AllocSplMem((_tcslen(pszIn) + 1)*sizeof(TCHAR))))
        {
            for (; *pszIn ; ++pszIn, ++pszOut)
            {
                *pszOut = (*pszIn == cIn) ? cOut : *pszIn;
            }
            *pszOut = *pszIn;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return pszReturn;
}

/*++

Routine Name:

    GetLastErrorAsHResult

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    None

Return Value:

    An HRESULT.

--*/
EXTERN_C
HRESULT
GetLastErrorAsHResult(
    VOID
    )
{
    return HResultFromWin32(GetLastError());
}

/*++

Routine Name:

    GetFileNamePart

Routine Description:

    Get the file name portion of a path.

Arguments:

    pszFullPath          - Full path to a file
    ppszFileName         - File name

Return Value:

    An HRESULT

--*/
EXTERN_C
HRESULT
GetFileNamePart(
    IN     PCWSTR      pszFullPath,
       OUT PCWSTR      *ppszFileName
    )
{
   HRESULT hRetval             = E_FAIL;
   WCHAR   szfname[_MAX_FNAME] = {0};

   hRetval = pszFullPath && ppszFileName ? S_OK : E_INVALIDARG;

   if (SUCCEEDED(hRetval))
   {
       _wsplitpath(pszFullPath, NULL, NULL, szfname, NULL);
       *ppszFileName = wcsstr(pszFullPath, szfname);
   }

   return hRetval;
}

/*++

Routine Name:

    GetLastErrorAsHResultAndFail

Routine Description:

    This routine gets the last error as HRESULT, and if there was no last error,
    returns E_UNEXPECTED.

Arguments:

    None

Return Value:

    An HRESULT

--*/
EXTERN_C
HRESULT
GetLastErrorAsHResultAndFail(
    void
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = GetLastErrorAsHResult();

    if (S_OK == hRetval)
    {
        hRetval = E_UNEXPECTED;
    }

    return hRetval;
}

/*++

Routine Name:

    HResultFromWin32

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    dwError   - Win32 error code

Return Value:

    An HRESULT

--*/
EXTERN_C
HRESULT
HResultFromWin32(
    IN DWORD dwError
    )
{
    return HRESULT_FROM_WIN32(dwError);
}

/*++

Description:

    This routine allocates a string which is the concatenation:
    Directory\pszFile. Directory is Windir, SystemRoot, CurrentDir,
    SystemWindowsDir, depending on the edir input argument.

Arguments:

    pszFile      - file name
    eDir         - enumeration, tells the function what directory to concatenate
    ppszFullPath - pointer where to return pointer to newly created string

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must use FreeSplMem to free the string returned by this function

--*/
EXTERN_C
DWORD
WINAPI
StrCatSystemPath(
    IN   LPCTSTR    pszFile,
    IN   EStrCatDir eDir,
    OUT  LPTSTR    *ppszFullPath
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    //
    // Validate arguments
    //
    if (pszFile && ppszFullPath)
    {
        DWORD cchNeeded;

        *ppszFullPath = NULL;

        //
        // Get the number of chars needed to hold the system directory. The returned
        // number accounts for the NULL terminator. GetCurrentDirectory is different than
        // the other function, because if takes the size of the buffer as the first
        // argument.
        //
        cchNeeded = eDir == kWindowsDir       ? GetWindowsDirectory(NULL, 0) :
                    eDir == kSystemWindowsDir ? GetSystemWindowsDirectory(NULL, 0) :
                    eDir == kSystemDir        ? GetSystemDirectory(NULL, 0) :
                                                GetCurrentDirectory(0, NULL);

        Error = cchNeeded ? ERROR_SUCCESS : GetLastError();

        if (Error == ERROR_SUCCESS)
        {
            //
            // Calculate the size of the buffer needed. Note that cchNeeded already
            // includes the NULL terminator.
            // length(directory) + whack + length(pszFile)
            //
            cchNeeded = cchNeeded + 1 + _tcslen(pszFile);

            *ppszFullPath = static_cast<LPTSTR>(AllocSplMem(cchNeeded * sizeof(TCHAR)));

            Error = *ppszFullPath ? ERROR_SUCCESS : GetLastError();

            if (Error == ERROR_SUCCESS)
            {
                DWORD cchTemp;

                cchTemp = eDir == kWindowsDir       ? GetWindowsDirectory(*ppszFullPath, cchNeeded) :
                          eDir == kSystemWindowsDir ? GetSystemWindowsDirectory(*ppszFullPath, cchNeeded) :
                          eDir == kSystemDir        ? GetSystemDirectory(*ppszFullPath, cchNeeded) :
                                                      GetCurrentDirectory(cchNeeded, *ppszFullPath);
                if (cchTemp)
                {
                    _tcscat(*ppszFullPath, _T("\\"));
                    _tcscat(*ppszFullPath, pszFile);
                }
                else
                {
                    Error = GetLastError();

                    FreeSplMem(*ppszFullPath);

                    *ppszFullPath = NULL;
                }
            }
        }
    }

    return Error;
}

/*++

Routine Name:

    StatusFromHResult

Description:

    This function returns a win32 error code from an HRESULT if possible and
    it failed, if it is not a win32 error code, it just returns the error code,
    otherwise it returns ERROR_SUCCESS.

Arguments:

    hr      -   The HRESULT.

Returns:

    The status equivalent of the hresult.

--*/
EXTERN_C
DWORD
StatusFromHResult(
    IN      HRESULT     hr
    )
{
    DWORD   Status = ERROR_SUCCESS;

    if (FAILED(hr))
    {
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            //
            // Kind of wacky, should we have a table here for reasonably translatable HResults?
            //
            Status = hr;
        }
    }

    return Status;
}

/*++

Routine Name:

    BoolFromHResult

Description:

    This function take an HRESULT input, if the HRESULT is a failure, it sets
    the last error and returns false, otherwise it returns TRUE.

Arguments:

    hr      -   The HRESULT.

Returns:

    A BOOLEAN, Sets the last error

--*/
EXTERN_C
BOOL
BoolFromHResult(
    IN      HRESULT     hr
    )
{
    DWORD   Status = StatusFromHResult(hr);

    if (Status != ERROR_SUCCESS)
    {
       SetLastError(Status);
    }

    return Status == ERROR_SUCCESS;
}

/*++

Routine Name:

    BoolFromStatus

Description:

    This function sets the last error to the given win32 error code if it is not
    error success. It returns the corresponding error result.

Arguments:

    Status      -   The Win32 error code.

Returns:

    A BOOLEAN, Sets the last error

--*/
EXTERN_C
BOOL
BoolFromStatus(
    IN      DWORD       Status
    )
{
    BOOL    bRet = TRUE;

    if (ERROR_SUCCESS != Status)
    {
        SetLastError(Status);

        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\dbglog.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.h

Abstract:

    New debug services for spooler.

Author:

    Albert Ting (AlbertT)  15-Jan-1995

Revision History:

--*/

#ifndef _DBGLOG_H
#define _DBGLOG_H

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD GENERROR, *PGENERROR;

/********************************************************************

DBGCHK

    Wraps any function that returns an unsigned 4 byte
    quantity with debug logging.

Arguments:

    expr - function/expression that needs to be tested

    uDbgLevel - print/break error level

    exprSuccess - expression that indicates function success
                  (GenError may be used as the expr return value)

    cgeFail - Count of items in pgeFails array

    pgeFails - Array of error return values (GenError) used
               when simulating failures (must be an array, not
               a pointer).

    pdwLastErrors - Array of error returned from GetLastError used
                    when simulating failures, zero terminated.

    argsPrint - Arguments to print/log in printf format.


Return Value:

    Result of the wrapped function or a simulated failure code.

Usage:

    lReturn = RegCreateKey( hKey,
                            L"SubKey",
                            &hKeyResult );

    should be re-written as:

    lReturn = DBGCHK( RegCreateKey( hKey,
                                    L"SubKey",
                                    &hKeyResult ),
                      DBG_ERROR,
                      GenError == ERROR_SUCCESS,
                      2, { ERROR_ACCESS_DENIED, ERROR_INVALID_PARAMETER },
                      NULL,
                      ( "CreateError 0x%x", hKey ));

    dwReturn = DBGCHK( GetProfileString( pszSection,
                                         pszKey,
                                         pszDefault,
                                         szReturnBuffer,
                                         COUNTOF( szReturnBuffer )),
                       DBG_WARN,
                       GenError != 0,
                       1, { 0 },
                       { ERROR_CODE_1, ERROR_CODE_2, 0 },
                       ( "GetProfileString: %s, %s, %s",
                          pszSection,
                          pszKey,
                          pszDefault ));

********************************************************************/

#define DBGCHK( expr,                                         \
                uDbgLevel,                                    \
                exprSuccess,                                  \
                cgeFail,                                      \
                pgeFails,                                     \
                pdwLastErrors,                                \
                argsPrint )                                   \
{                                                             \
    GENERROR GenError;                                        \
    LPSTR pszFileA = __FILE__;                                \
                                                              \
    if( !bDbgGenFail( pszFileA,                               \
                      __LINE__,                               \
                      cgeFail,                                \
                      pgeFails,                               \
                      pdwLastErrors,                          \
                      &GenError )){                           \
                                                              \
        GenError = (GENERROR)(expr);                          \
                                                              \
        if( !( exprSuccess )){                                \
                                                              \
            vDbgLogError( MODULE_DEBUG,                       \
                          uDbgLevel,                          \
                          __LINE__,                           \
                          pszFileA,                           \
                          MODULE,                             \
                          pszDbgAllocMsgA argsPrint );        \
        }                                                     \
    }                                                         \
    GenError;                                                 \
}

LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    );

BOOL
bDbgGenFail(
    LPCSTR    pszFileA,
    UINT      uLine,
    UINT      cgeFails,
    PGENERROR pgeFails,
    PDWORD    pdwLastErrors
    );

#ifdef __cplusplus
}
#endif

#endif // _DBGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\dnode.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dnode.inl

Abstract:

    Node template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/


template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(void):
    m_Data(NULL), 
    m_pPrev(NULL),
    m_Next(NULL)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(T item):
    m_Data(item), 
    m_pPrev(NULL),
    m_pNext(NULL)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::TDoubleNode(T item, TDoubleNode<T, KEYTYPE>* pPrev, TDoubleNode<T, KEYTYPE>* pNext):
    m_Data(item),
    m_pPrev(pPrev),
    m_pNext(pNext)
{
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE>::~TDoubleNode(void)
{
    if (m_Data) {
        delete (m_Data);
    }
}

template <class T, class KEYTYPE>
void 
TDoubleNode<T, KEYTYPE>::SetNext (TDoubleNode<T, KEYTYPE> *pNode)
{
    m_pNext = pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TDoubleNode<T, KEYTYPE>::GetNext (void )
{
    return m_pNext;
}

template <class T, class KEYTYPE>
void 
TDoubleNode<T, KEYTYPE>::SetPrev (
    TDoubleNode<T, KEYTYPE> *pNode)
{
    m_pPrev = pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * TDoubleNode<T, KEYTYPE>::GetPrev (void )
{
    return m_pPrev;
}

template <class T, class KEYTYPE>
T TDoubleNode<T, KEYTYPE>::GetData (void )
{
    return m_Data;  
}

template <class T, class KEYTYPE>
void TDoubleNode<T, KEYTYPE>::SetData (T pData)
{
    m_Data = pData;
}


template <class T, class KEYTYPE>
BOOL TDoubleNode<T, KEYTYPE>::IsSameItem (T &item)
{
    return m_Data->Compare (item) == 0;

}

template <class T, class KEYTYPE>
BOOL TDoubleNode<T, KEYTYPE>::IsSameKey (KEYTYPE &key)
{
    return m_Data->Compare (key) == 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\debug.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.cxx

Abstract:

    Debug support

Author:

    Albert Ting (AlbertT)  28-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "trace.hxx"

#define DEFAULT_TRACE_TYPE TBackTraceMem
//#define DEFAULT_TRACE_TYPE TBackTraceFile // For tracing to file.

#define DEFAULT_MEM_TRACE_TYPE TBackTraceMem

extern HANDLE ghMemHeap;
extern HANDLE ghDbgMemHeap;
extern pfCreateThread gpfSafeCreateThread;

#if DBG

UINT gLogFilter = (UINT)-1;
VBackTrace* gpbtErrLog;
VBackTrace* gpbtTraceLog;

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );
DBG_POINTERS gDbgPointers;
PDBG_POINTERS gpDbgPointers;

extern VBackTrace* gpbtAlloc;
extern VBackTrace* gpbtFree;

/********************************************************************

    Single thread checking.

    This is used to verify that a set of functions are called from
    only one thread.  This is for debugging purposes only.

********************************************************************/

VOID
vDbgSingleThread(
    PDWORD pdwThreadId
    )
{
    EnterCriticalSection( &gcsBackTrace );

    if (!*pdwThreadId) {
        *pdwThreadId = (DWORD)GetCurrentThreadId();
    }
    SPLASSERT( *pdwThreadId == (DWORD)GetCurrentThreadId() );

    LeaveCriticalSection( &gcsBackTrace );
}

VOID
vDbgSingleThreadReset(
    PDWORD pdwThreadId
    )
{
    *pdwThreadId = 0;
}

VOID
vDbgSingleThreadNot(
    PDWORD pdwThreadId
    )
{
    SPLASSERT( *pdwThreadId != (DWORD)GetCurrentThreadId() );
}


/********************************************************************

    TStatus automated error logging and codepath testing.

********************************************************************/

TStatusBase&
TStatusBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBase&)*this;
}



TStatusBase&
TStatusBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBase&)*this;
}


DWORD
TStatus::
dwGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _dwStatus;
}


DWORD
TStatusBase::
operator=(
    DWORD dwStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA &&
        dwStatus != ERROR_SUCCESS &&
        dwStatus != _dwStatusSafe1 &&
        dwStatus != _dwStatusSafe2 &&
        dwStatus != _dwStatusSafe3 ){

#ifdef DBGLOG
        //
        // An unexpected error occured.  Log an error and continue.
        //
        vDbgLogError( _uDbg,
                      _uDbgLevel,
                      _uLine,
                      _pszFileA,
                      _pszModuleA,
                      pszDbgAllocMsgA( "TStatus set to %d\nLine %d, %hs\n",
                                       dwStatus,
                                       _uLine,
                                       _pszFileA ));
#else
        DBGMSG( DBG_WARN,
                ( "TStatus set to %d\nLine %d, %hs\n",
                  dwStatus,
                  _uLine,
                  _pszFileA ));
#endif

    }

    return _dwStatus = dwStatus;
}

/********************************************************************

    Same, but for HRESULTs.

********************************************************************/

TStatusHBase&
TStatusHBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusH&)*this;
}

TStatusHBase&
TStatusHBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusH&)*this;
}

HRESULT
TStatusHBase::
operator=(
    HRESULT hrStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //


    if( _pszFileA &&
        FAILED(hrStatus)           &&
        hrStatus != _hrStatusSafe1 &&
        hrStatus != _hrStatusSafe2 &&
        hrStatus != _hrStatusSafe3 ){

#ifdef DBGLOG
        //
        // An unexpected error occured.  Log an error and continue.
        //
        vDbgLogError( _uDbg,
                      _uDbgLevel,
                      _uLine,
                      _pszFileA,
                      _pszModuleA,
                      pszDbgAllocMsgA( "TStatusH set to %x\nLine %d, %hs\n",
                                       hrStatus,
                                       _uLine,
                                       _pszFileA ));
#else
        DBGMSG( DBG_WARN,
                ( "TStatusH set to %x\nLine %d, %hs\n",
                  hrStatus,
                  _uLine,
                  _pszFileA ));
#endif

    }

    return _hrStatus = hrStatus;
}

HRESULT
TStatusH::
hrGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _hrStatus;
}
/********************************************************************

    Same, but for BOOLs.

********************************************************************/

TStatusBBase&
TStatusBBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBBase&)*this;
}

TStatusBBase&
TStatusBBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBBase&)*this;
}

BOOL
TStatusB::
bGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _bStatus;
}


BOOL
TStatusBBase::
operator=(
    BOOL bStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA && !bStatus ){

        DWORD dwLastError = GetLastError();

        if( dwLastError != _dwStatusSafe1 &&
            dwLastError != _dwStatusSafe2 &&
            dwLastError != _dwStatusSafe3 ){

#ifdef DBGLOG
            //
            // An unexpected error occured.  Log an error and continue.
            //
            vDbgLogError( _uDbg,
                          _uDbgLevel,
                          _uLine,
                          _pszFileA,
                          _pszModuleA,
                          pszDbgAllocMsgA( "TStatusB set to FALSE, LastError = %d\nLine %d, %hs\n",
                                           GetLastError(),
                                           _uLine,
                                           _pszFileA ));
#else
            DBGMSG( DBG_WARN,
                    ( "TStatusB set to FALSE, LastError = %d\nLine %d, %hs\n",
                      GetLastError(),
                      _uLine,
                      _pszFileA ));
#endif

        }
    }

    return _bStatus = bStatus;
}


VOID
vWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )

/*++

Routine Description:

    Warns that an object is invalid.

Arguments:

Return Value:

--*/

{
#if DBGLOG
    vDbgLogError( uDbg,
                  DBG_WARN,
                  uLine,
                  pszFileA,
                  pszModuleA,
                  pszDbgAllocMsgA( "Invalid Object %x LastError = %d\nLine %d, %hs\n",
                                   (ULONG_PTR)pvObject,
                                   GetLastError(),
                                   uLine,
                                   pszFileA ));
#else
    DBGMSG( DBG_WARN,
            ( "Invalid Object %x LastError = %d\nLine %d, %hs\n",
              (DWORD)pvObject,
              GetLastError(),
              uLine,
              pszFileA ));
#endif
}


/********************************************************************

    Generic Error logging package.

********************************************************************/

VOID
DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    )
{
    CHAR szMsgText[1024];
    va_list vargs;

    va_start( vargs, pszMsgFormat );
    wvsprintfA( szMsgText, pszMsgFormat, vargs );
    va_end( vargs );

#ifndef DBGLOG
    //
    // Prefix the string if the first character isn't a space:
    //
    if( szMsgText[0]  &&  szMsgText[0] != ' ' ){
        OutputDebugStringA( MODULE );
    }
#endif

    OutputDebugStringA( szMsgText );
}


#ifdef DBGLOG

LPSTR
pszDbgAllocMsgA(
    LPCSTR  pszMsgFormatA,
    ...
    )
{
    CHAR szMsgTextA[1024];
    UINT cbStr;
    LPSTR pszMsgA;

    va_list vargs;

    va_start(vargs, pszMsgFormatA);

    __try 
    {
        wvsprintfA( szMsgTextA, pszMsgFormatA, vargs );
    } __except(( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ||
                GetExceptionCode() == EXCEPTION_DATATYPE_MISALIGNMENT) ? 
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH ) 
    {

        OutputDebugStringA( "SPL: <Bad DbgMsg !!> " );
        OutputDebugStringA( pszMsgFormatA );
    }  

    va_end(vargs);

    cbStr = ( lstrlenA( szMsgTextA ) + 1 ) * sizeof( szMsgTextA[0] );
    
    pszMsgA = (LPSTR)DbgAllocMem( cbStr );
    
    if( pszMsgA ){
        CopyMemory( pszMsgA, szMsgTextA, cbStr );
    }
    
    return pszMsgA;
}


VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    )
{
    DWORD dwLastError = GetLastError();
    VBackTrace* pBackTrace = gpbtTraceLog;

    if(( uDbgLevel & DBG_PRINT_MASK & uDbg ) && pszMsgA ){

        if( !( uDbgLevel & DBG_NOHEAD )){

            OutputDebugStringA( pszModuleA );
        }
        OutputDebugStringA( pszMsgA );
    }

    if(( uDbgLevel << DBG_BREAK_SHIFT ) & uDbg ){

        DebugBreak();
    }

    if( gLogFilter & uDbgLevel  )
    {
        //
        // Log the failure.
        //

        //
        // Capture significant errors in separate error log.
        //
        if( uDbgLevel & DBG_ERRLOG_CAPTURE ){
            pBackTrace = gpbtErrLog;
        }

        if (pBackTrace) 
        {
            pBackTrace->hCapture( (ULONG_PTR)pszMsgA,
                                  uLine | ( uDbgLevel << DBG_BREAK_SHIFT ),
                                  (ULONG_PTR)pszFileA );
        }
        else
        {
            //
            // Backtracing is not enabled, free the message string that is
            // passed in.
            // 
            if(pszMsgA)
            {
                DbgFreeMem((PVOID)pszMsgA);
            }
        }
    }
    else
    {
        //
        // Just free up the memory if this line is not captured
        // actually this happens when uDbgLevel == DBG_NONE (0)
        //
        if( pszMsgA )
        {
            DbgFreeMem( (PVOID)pszMsgA );
        }
    }

    SetLastError( dwLastError );
}


#endif // def DBGLOG
#endif // DBG


/********************************************************************

    Initialization

********************************************************************/

#if DBG

BOOL
bSplLibInit(
    pfCreateThread pfSafeCreateThread
    )
{
    BOOL bValid;

    bValid = (ghMemHeap = HeapCreate( 0, 1024*4, 0 ))                       &&
             (ghDbgMemHeap = HeapCreate( 0, 1024*4, 0 ))                    &&
             (VBackTrace::bInit( ))                                         &&
#ifdef TRACE_ENABLED
             (gpbtAlloc = new DEFAULT_MEM_TRACE_TYPE)                       &&
             (gpbtFree = new DEFAULT_MEM_TRACE_TYPE)                        &&
             (gpbtErrLog = new DEFAULT_TRACE_TYPE( VBackTrace::kString ))   &&
             (gpbtTraceLog = new DEFAULT_TRACE_TYPE( VBackTrace::kString )) &&
#endif
             (MRefCom::gpcsCom = new MCritSec)                              &&
             MRefCom::gpcsCom->bValid();

    gpfSafeCreateThread = ( pfSafeCreateThread ) ? pfSafeCreateThread : CreateThread;

    if( bValid ){
        gDbgPointers.pfnAllocBackTrace = &DbgAllocBackTrace;
        gDbgPointers.pfnAllocBackTraceMem = &DbgAllocBackTraceMem;
        gDbgPointers.pfnAllocBackTraceFile = &DbgAllocBackTraceFile;
        gDbgPointers.pfnFreeBackTrace = &DbgFreeBackTrace;
        gDbgPointers.pfnCaptureBackTrace = &DbgCaptureBackTrace;
        gDbgPointers.pfnAllocCritSec = &DbgAllocCritSec;
        gDbgPointers.pfnFreeCritSec = &DbgFreeCritSec;
        gDbgPointers.pfnInsideCritSec = &DbgInsideCritSec;
        gDbgPointers.pfnOutsideCritSec = &DbgOutsideCritSec;
        gDbgPointers.pfnEnterCritSec = &DbgEnterCritSec;
        gDbgPointers.pfnLeaveCritSec = &DbgLeaveCritSec;
        gDbgPointers.pfnSetAllocFail = &DbgSetAllocFail;

        gDbgPointers.hMemHeap = ghMemHeap;
        gDbgPointers.hDbgMemHeap = ghDbgMemHeap;
        gDbgPointers.pbtAlloc = gpbtAlloc;
        gDbgPointers.pbtFree = gpbtFree;
        gDbgPointers.pbtErrLog = gpbtErrLog;
        gDbgPointers.pbtTraceLog = gpbtTraceLog;

        gpDbgPointers = &gDbgPointers;
    }
    return bValid;
}

VOID
vSplLibFree(
    VOID
    )
{
    SPLASSERT( MRefCom::gpcsCom->bOutside( ));
    delete MRefCom::gpcsCom;

    VBackTrace::vDone();

    if (ghMemHeap)
    {
        HeapDestroy( ghMemHeap );
        ghMemHeap = NULL;
    }

    if (ghDbgMemHeap)
    {
        HeapDestroy( ghDbgMemHeap );
        ghDbgMemHeap = NULL;
    }
}

#else

BOOL
bSplLibInit(
    pfCreateThread pfSafeCreateThread
    )
{
    gpfSafeCreateThread = ( pfSafeCreateThread ) ? pfSafeCreateThread : CreateThread;

    return ( ghMemHeap = HeapCreate( 0, 1024*4, 0 )) ?
               TRUE : FALSE;
}

VOID
vSplLibFree(
    VOID
    )
{
    if (ghMemHeap)
    {
        HeapDestroy( ghMemHeap );
        ghMemHeap = NULL;
    }
}

#endif

/********************************************************************

    Stub these out so non-debug builds will find them.

********************************************************************/

#if !DBG
#ifdef DBGLOG

LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    )
{
    return NULL;
}

VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    )
{
}

#else

VOID
vDbgMsg2(
    LPCTSTR pszMsgFormat,
    ...
    )
{
}

#endif // ndef DBGLOG
#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\dbgmsg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Debug.h

Abstract:

    New debug services for spooler.

Author:

    Albert Ting (AlbertT)  15-Jan-1995

Revision History:

--*/

#ifndef _DBGLOG_H
#define _DBGLOG_H

/********************************************************************

    Setting up the debug support:
    =============================

    Define a MODULE prefix string.  Since this will be printed as
    a prefix to all debug output, it should be concise and unique.

    In your global header file:

        #define MODULE "prtlib:"

    Define a MODULE_DEBUG variable.  This is the actual symbol
    that the library will use to indicate debugging level.
    This DWORD is broken into two bitfield WORDs: the low word
    indicates which levels to print to the debugger; the high word
    breaks into the debugger.  The library takes the DebugLevel from
    a debug message, then ANDs it with the debug level.  If the bit
    is on, the corresponding action (print or break) is taken.

    In your global header file:

        #define MODULE_DEBUG PrtlibDebug

    Finally, the actual debug variable must be defined and initialized
    to a default debug level.  This must be done in exactly one
    *.c translation unit:

    In one of your source files:

        MODULE_DEBUG_INIT ( {LevelsToPrint}, {LevelsToBreak} );

    Adding logging to source code:
    ==============================

    The general format for debug message is:

        DBGMSG( {DebugLevel}, ( {args to printf} ));

    The DebugLevel dictates whether the level should print, break
    into the debugger, or just log to memory (logging always done).

    The args to printf must be placed in an extra set of parens,
    and should assume everything is ANSI.  To print LPTSTRs, use
    the TSTR macro:

        DBGMSG( DBG_WARN,
                ( "LPTSTR "TSTR", LPSTR %s, LPWSTR %ws\n",
                  TEXT("hello"), "hello", L"hello" ));

    Viewing DBGMSGs:
    ================

    Messages will print to the debugger (usermode, or kernel debugger
    if no usermode debugger is available) for all printable levels.
    To change the level, you can edit the MODULE_DEBUG variable
    (PrtlibDebug in the above example).

    By default, DBG_ERROR and DBG_WARNING messages a logged to the
    error log (stored at gpbterrlog).  All others are stored in the
    trace log (gpbttracelog).  These currently log to memory in
    a circular buffer.  Use the splx.dll extension to dump these
    logs.

    At compile time, you can switch these logs to go to file rather
    than memory.  They will be stored as the PID + index number in
    the default directory of the process.

********************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

//
// These values are strictly debug, but must be defined in the free
// build because the TStatus error checking uses them as the first ctr
// parameter.  (During inlining they are discarded.)
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100

#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000

#if DBG

extern DWORD MODULE_DEBUG;

//
// This should be used exactly once in a C file.  It defines
// the Debug variable, and also the DbgMsg function.
//
// If we are statically linking with SplLib (SplLib is a library, not
// a Dll), then we will get the definition from SplLib, so don't define
// it here.
//
#ifdef LINK_SPLLIB
#define MODULE_DEBUG_INIT( print, break )                              \
    DWORD MODULE_DEBUG = (DBG_PRINT( print ) | DBG_BREAK( break ))
#else
#define MODULE_DEBUG_INIT( print, break )                              \
    VOID                                                               \
    DbgMsg(                                                            \
        LPCSTR pszMsgFormat,                                           \
        ...                                                            \
        )                                                              \
    {                                                                  \
        CHAR szMsgText[1024];                                          \
        va_list vargs;                                                 \
                                                                       \
        va_start( vargs, pszMsgFormat );                               \
        wvsprintfA( szMsgText, pszMsgFormat, vargs );                  \
        va_end( vargs );                                               \
                                                                       \
        if( szMsgText[0]  &&  szMsgText[0] != ' ' ){                   \
            OutputDebugStringA( MODULE );                              \
        }                                                              \
        OutputDebugStringA( szMsgText );                               \
    }                                                                  \
    DWORD MODULE_DEBUG = (DBG_PRINT( print ) | DBG_BREAK( break ))
#endif

#define DBGSTR( str ) \
    ((str) ? (str) : TEXT("(NULL)"))

#ifdef UNICODE
#define TSTR "%ws"
#else
#define TSTR "%s"
#endif

#define DBG_PRINT_MASK 0xffff
#define DBG_BREAK_SHIFT 16

#define DBG_PRINT(x) (x)
#define DBG_BREAK(x) (((x) << DBG_BREAK_SHIFT)|(x))

#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

VOID
vDbgSingleThreadReset(
    PDWORD pdwThreadId
    );

VOID
vDbgSingleThread(
    PDWORD pdwThreadId
    );

VOID
vDbgSingleThreadNot(
    PDWORD pdwThreadId
    );

VOID
DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    );           

#ifdef DBGLOG

#define DBGMSG( uDbgLevel, argsPrint )             \
        vDbgLogError( MODULE_DEBUG,                \
                      uDbgLevel,                   \
                      __LINE__,                    \
                      __FILE__,                    \
                      MODULE,                      \
                      pszDbgAllocMsgA argsPrint )  
                                                        
LPSTR
pszDbgAllocMsgA(
    LPCSTR pszMsgFormatA,
    ...
    );

VOID
vDbgLogError(
    UINT   uDbg,
    UINT   uDbgLevel,
    UINT   uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA,
    LPCSTR pszMsgA
    );
#else

VOID
DbgBreakPoint(
    VOID
    );

#define DBGMSG( Level, MsgAndArgs )                 \
{                                                   \
    if( ( (Level) & 0xFFFF ) & MODULE_DEBUG ){      \
        DbgMsg MsgAndArgs;                          \
    }                                               \
    if( ( (Level) << 16 ) & MODULE_DEBUG )          \
        DbgBreakPoint();                            \
}

#endif


#define SINGLETHREAD_VAR(var) \
    DWORD dwSingleThread_##var

#define SINGLETHREAD(var) \
    vDbgSingleThread(&dwSingleThread_##var)

#define SINGLETHREADNOT(var) \
    vDbgSingleThreadNot(&dwSingleThread_##var)

#define SINGLETHREADRESET(var) \
    vDbgSingleThreadReset(&dwSingleThread_##var)

#else
#define MODULE_DEBUG_INIT( print, break )
#define DBGMSG( uDbgLevel, argsPrint )
#define SPLASSERT(exp)
#define SINGLETHREAD_VAR(var)
#define SINGLETHREAD(var)
#define SINGLETHREADNOT(var)
#define SINGLETHREADRESET(var)
#endif


//
// Automatic checking if an object is valid.
//
#if DBG

VOID
vWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    );

#define VALID_PTR(x)                                                \
    ((( x ) && (( x )->bValid( ))) ?                                \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_OBJ(x)                                                \
    ((( x ).bValid( )) ?                                            \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)&(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_BASE(x)                                               \
    (( x::bValid( )) ?                                              \
        TRUE :                                                      \
        ( vWarnInvalid( (PVOID)this, MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#else
#define VALID_PTR(x) \
    (( x ) && (( x )->bValid()))
#define VALID_OBJ(x) \
    (( x ).bValid())
#define VALID_BASE(x) \
    ( x::bValid( ))
#endif

#ifdef __cplusplus
}
#endif

#endif // _DBGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\exec.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    exec.cxx

Abstract:

    Handles async commands.

    The client give TExec a worker object (MExecWork).  At some later
    time, the worker is given a thread (called via svExecute).

    If the Job is already on the list but is waiting, we just return.
    If it's not on the list but currently executing, we add it to the
    list when it's done executing.

    kExecActive    -> currently executing (so it's not on the list)
    kExecActiveReq -> kExecActive is on, and it needs to run again.

    If kExecExit is added, we call vExecExitComplete() (virtual function)
    when all jobs have been completed and assume the the client is cleaning
    up after itself.  In fact, the MExecWork object may be destroyed
    in vExecExitComplete().

Author:

    Albert Ting (AlbertT)  8-Nov-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

BOOL
TExec::
bJobAdd(
    MExecWork* pExecWork,
    STATEVAR StateVar
    )

/*++

Routine Description:

    Adds a job request to move to a given state.

Arguments:

    pExecWork - Work structure.

    StateVar - StateVar that we want to move toward.  If kExecExit
        is set, then we will complete the currently executing job
        then exit by calling vExecExitComplete().

        Note that kExecExit should be added by itself; if it is added
        with other commands, they will be ignored.

Return Value:

    TRUE  = Job added (or job already on wait list)
    FALSE = failed, GLE.

    Adding kExecExit is guarenteed to succeed here.

--*/

{
    BOOL bReturn = TRUE;
    BOOL bCallExecExitComplete = FALSE;

    {
        TCritSecLock CSL( *_pCritSec );

        DBGMSG( DBG_EXEC,
                ( "Exec.bJobAdd: %x StateVar = %x\n", pExecWork, StateVar ));

        //
        // Job bits must not have PRIVATE bits.
        //
        SPLASSERT( !( StateVar & kExecPrivate ));

        //
        // Don't allow adding a job after we are set to exit.
        //
        SPLASSERT( !( pExecWork->_State & kExecExit ));

        //
        // If it's active (currently executing in a thread), then it is
        // not on the wait list and we mark it as ACTIVE_REQ so that
        // when the job completes, it sees that more jobs have accumulated.
        //
        if( pExecWork->_State & kExecActive ){

            DBGMSG( DBG_EXEC,
                    ( "\n    ACTIVE, ++REQ _State %x _StatePending %x\n",
                      (STATEVAR)pExecWork->_State,
                      (STATEVAR)pExecWork->_StatePending ));

            //
            // Can't be an immediate request if executing already.
            //
            SPLASSERT( !( StateVar & kExecRunNow ));

            pExecWork->_StatePending |= StateVar;
            pExecWork->_State |= kExecActiveReq;

            bReturn = TRUE;

        } else {

            //
            // Store up the work requested since we aren't currently active.
            //
            pExecWork->_State |= StateVar;

            //
            // If we are not on the wait list, add it.
            //
            if( !pExecWork->Work_bLinked( )){

                if( StateVar & kExecExit ){

                    bCallExecExitComplete = TRUE;

                } else {

                    DBGMSG( DBG_EXEC, ( "not linked, added\n" ));
                    SPLASSERT( NULL == Work_pFind( pExecWork ));

                    bReturn = bJobAddWorker( pExecWork );
                }

            } else {

                DBGMSG( DBG_EXEC, ( "linked, NOP\n" ));
            }
        }
    }

    if( bCallExecExitComplete ){

        //
        // Special case exit: we should exit.  Once we call
        // vExecExitComplete, we can't refer to *this anymore,
        // since we may have deleted ourself.
        //
        pExecWork->vExecExitComplete();
        bReturn = TRUE;

    }

    return bReturn;
}


VOID
TExec::
vJobDone(
    MExecWork* pExecWork,
    STATEVAR StateVar
    )

/*++

Routine Description:

    A job has compeleted execution, clean up.

Arguments:

    pExecWork - Unit that just completed executing.

    StateVar - New state that the object is in (requests that
        successfully completed should be turned off--done by client).

Return Value:

--*/

{
    BOOL bCallExecExitComplete = FALSE;
    BOOL bCallExecFailedAddJob = FALSE;

    {
        TCritSecLock CSL( *_pCritSec );

        DBGMSG( DBG_EXEC,
                ( "Exec.vJobDone: %x completed -> %x +(new) %x = %x\n",
                  pExecWork, StateVar, (DWORD)pExecWork->_StatePending,
                  (DWORD)pExecWork->_State | pExecWork->_StatePending ));

        //
        // kExecRunNow can not be set when the object is working.
        //
        SPLASSERT( !( StateVar & kExecRunNow ));

        //
        // We have completed the work request, put in the new state.
        // Keep the private bits, and add in the new state variable,
        // plus any additional work that was pending.
        //
        // The ExecNow bit is not saved (it's not part of kExecPrivate)
        // since it's good for one shot only.
        //
        pExecWork->_State = ( pExecWork->_State & kExecPrivate ) |
                            ( StateVar & ~kExecPrivate ) |
                            pExecWork->_StatePending;

        pExecWork->_State &= ~kExecActive;

        //
        // If job is done, then quit.
        //
        if( pExecWork->_State & kExecExit ){

            DBGMSG( DBG_EXEC,
                    ( "Exec.vJobDone: _State %x, calling vExecExitComplete\n",
                      (STATEVAR)pExecWork->_State ));

            bCallExecExitComplete = TRUE;

        } else {

            //
            // If we have more work to do, add ourselves back
            // to the queue.
            //
            if( pExecWork->_State & kExecActiveReq &&
                !bJobAddWorker( pExecWork )){

                bCallExecFailedAddJob = TRUE;
            }
        }
    }

    if( bCallExecFailedAddJob ){

        //
        // Fail on delayed job add.
        //
        pExecWork->vExecFailedAddJob();
    }

    if( bCallExecExitComplete ){

        //
        // Once vExecExitComplete has been called, the current object
        // pExecWork may be destroyed.
        //
        // Don't refer to it again since vExecExitComplete may delete
        // this as part of cleanup.
        //
        pExecWork->vExecExitComplete();
    }
}


STATEVAR
TExec::
svClearPendingWork(
    MExecWork* pExecWork
    )

/*++

Routine Description:

    Queries what work is currently pending.

Arguments:

    pExecWork -- Work item.

Return Value:

--*/

{
    TCritSecLock CSL( *_pCritSec );

    //
    // Return pending work, minus the private and kExecRunNow
    // bits.
    //
    STATEVAR svPendingWork = pExecWork->_StatePending & ~kExecNoOutput;
    pExecWork->_StatePending = 0;

    return svPendingWork;
}

/********************************************************************

    Private

********************************************************************/

TExec::
TExec(
    MCritSec* pCritSec
    ) : TThreadM( 10, 2000, pCritSec ), _pCritSec( pCritSec )
{
}

BOOL
TExec::
bJobAddWorker(
    MExecWork* pExecWork
    )

/*++

Routine Description:

    Common code to add a job to our linked list.

    Must be called inside the _pCritSec.  It does leave it inside
    this function, however.

Arguments:


Return Value:

--*/

{
    SPLASSERT( _pCritSec->bInside( ));

    BOOL bRunNow = FALSE;

    //
    // Check if the client wants the job to run right now.
    //
    if( pExecWork->_State & kExecRunNow ){

        //
        // Add the job to the head of the queue.  Since we always pull
        // jobs from the beginning, we'll get to this job first.
        //
        // If a non-RunNow job is added to the list before we execute,
        // we'll still run, since the other job will be added to the
        // end of the list.
        //
        // If another RunNow job is added, we'll spawn separate threads
        // for each (unless an idle thread is available).
        //

        Work_vAdd( pExecWork );
        bRunNow = TRUE;

    } else {
        Work_vAppend( pExecWork );
    }

    if( !bJobAdded( bRunNow ) ){

        DBGMSG( DBG_INFO, ( "Exec.vJobProcess: unable to add job %x: %d\n",
                            pExecWork,
                            GetLastError( )));

        Work_vDelink( pExecWork );
        return FALSE;
    }

    return TRUE;
}

PJOB
TExec::
pThreadMJobNext(
    VOID
    )

/*++

Routine Description:

    Gets the next job from the queue.  This function is defined in
    TThreadM.

Arguments:

Return Value:

--*/

{
    TCritSecLock CSL( *_pCritSec );

    MExecWork* pExecWork = Work_pHead();

    if( !pExecWork ){
        return NULL;
    }

    Work_vDelink( pExecWork );

    //
    // Job should never be active here.
    //
    SPLASSERT( !(pExecWork->_State & kExecActive) );

    //
    // We will handle all requests now, so clear kExecActiveReq.
    // Also remove kExecRunNow, since it's one shot only, and mark us
    // as currently active (kExecActive).
    //
    pExecWork->_State &= ~( kExecActiveReq | kExecRunNow );
    pExecWork->_State |= kExecActive;

    return (PJOB)pExecWork;
}

VOID
TExec::
vThreadMJobProcess(
    PJOB pJob
    )

/*++

Routine Description:

    Process a job in the current thread.  We call the virtual function
    with the job object, then clear out the bits that it has completed.
    (This is a member of TThreadM.)

    If there is additional pending work (ACTIVE_REQ), then we re-add
    the job.

    If there is a failure in the re-add case, we must send an
    asynchronous fail message.

Arguments:

    pJob - MExecWork instance.

Return Value:

--*/

{
    SPLASSERT( _pCritSec->bOutside( ));

    STATEVAR StateVar;
    MExecWork* pExecWork = (MExecWork*)pJob;

    //
    // Do the work.
    //
    StateVar = pExecWork->svExecute( pExecWork->State() & ~kExecNoOutput );

    vJobDone( pExecWork, StateVar );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\dlist.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dlist.inl

Abstract:

    Double linked list template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

    Weihai Chen (WeihaiC) 03/08/00 Rename to T*
    
--*/

template <class T, class KEYTYPE>
TDoubleList<T, KEYTYPE>::TDoubleList<T, KEYTYPE>(void):
    m_pHead (NULL),
    m_pTail (NULL),
    m_dwNumNode (0),
    m_bValid (TRUE)
{
}

template <class T, class KEYTYPE>
TDoubleList<T, KEYTYPE>::~TDoubleList<T, KEYTYPE>(void)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;
    TDoubleNode<T, KEYTYPE> *pNext;

    while (pNode) {
        pNext = pNode->GetNext();
        delete pNode;
        pNode = pNext;
    }
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::InsertItem (T item)
{
    BOOL bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);

    if (pNewNode) {
        bRet = InsertNode (pNewNode);
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::AppendItem (T item)
{
    BOOL bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNewNode = new TDoubleNode<T, KEYTYPE> (item);

    if (pNewNode) {
        bRet = AppendNode (pNewNode);
    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::DeleteItem (T item)
{
    BOOL    bRet = FALSE;

    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;
    while (pNode) {
        if (pNode->IsSameItem (item)) {
            // Delete it
            DeleteNode (pNode);
            delete (item);
            bRet = TRUE;
            break;
        }
        pNode = pNode->GetNext();
    }


    return FALSE;
}

template <class T, class KEYTYPE>
T TDoubleList<T, KEYTYPE>::GetItemFromIndex (DWORD dwIndex)
{
    TDoubleNode<T, KEYTYPE> *pNode = GetNodeFromIndex (dwIndex);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}


template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleList<T, KEYTYPE>::GetNodeFromIndex (DWORD dwIndex)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    DWORD i = 0;

    while (pNode && i < dwIndex) {
        i++;
        pNode = pNode->GetNext();
    }

    return pNode;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::InsertNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;


    if (pNewNode) {
        if (m_pHead) {
            pNewNode->SetNext (m_pHead);
            pNewNode->SetPrev (NULL);
            
            m_pHead->SetPrev (pNewNode);
        }
        else {
            // This is the first node
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (NULL);
            m_pTail = pNewNode;
        }
        m_pHead = pNewNode;
        m_dwNumNode ++;
        bRet = TRUE;
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::AppendNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;


    if (pNewNode) {
        if (m_pTail) {
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (m_pTail);
            
            m_pTail->SetNext (pNewNode);
        }
        else {
            // This is the first node
            pNewNode->SetNext (NULL);
            pNewNode->SetPrev (NULL);
            m_pHead = pNewNode;
        }
        m_pTail = pNewNode;
        m_dwNumNode ++;
        bRet = TRUE;
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleList<T, KEYTYPE>::DeleteNode (TDoubleNode<T, KEYTYPE> *pNode)
{
    TDoubleNode<T, KEYTYPE> *pNextNode;
    TDoubleNode<T, KEYTYPE> *pPrevNode;
    BOOL    bRet = FALSE;

    if (pNode) {
        

        // It is not the first one, i.e. not the only one
        pNextNode = pNode->GetNext ();
        pPrevNode = pNode->GetPrev ();

        if (pNextNode) {
            pNextNode->SetPrev (pPrevNode);
        }
        else {
            m_pTail = pPrevNode;
        }
        
        if (pPrevNode) {
            pPrevNode->SetNext (pNextNode);
        }
        else {
            // It is the first one
            m_pHead = pNextNode;
        }

        m_dwNumNode --;
        bRet = TRUE;
    }
    return bRet;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleList<T, KEYTYPE>::GetHead (void)
{
    TDoubleNode<T, KEYTYPE> * pHead = NULL;

    pHead =  m_pHead;

    return pHead;
}

template <class T, class KEYTYPE>
BOOL  
TDoubleList<T, KEYTYPE>::GetTotalNode (PDWORD pdwCount)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {
        *pdwCount = m_dwNumNode;
        bRet = TRUE;
    }
    return bRet;
}

template <class T, class KEYTYPE>
T TSrchDoubleList<T, KEYTYPE>::FindItemFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> *pNode = FindNodeFromItem (item);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}

template <class T, class KEYTYPE>
T TSrchDoubleList<T, KEYTYPE>::FindItemFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> *pNode = FindNodeFromKey (key);

    if (pNode) {
        return pNode->GetData();
    }
    return NULL;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TSrchDoubleList<T, KEYTYPE>::FindNodeFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    while (pNode) {
        if (pNode->IsSameItem (item)) {
            return pNode;
        }
        pNode = pNode->GetNext();
    }


    return NULL;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TSrchDoubleList<T, KEYTYPE>::FindNodeFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> *pNode = m_pHead;

    while (pNode) {
        if (pNode->IsSameKey (key)) {
            return pNode;
        }
        pNode = pNode->GetNext();
    }


    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\loadlib.cxx ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation
All rights reserved.

Module Name:

    loadlib.cxx

Abstract:

    Library Loader helper class        
         
Author:

    Steve Kiraly (SteveKi) 10/17/95

Revision History:

--*/
#include "spllibp.hxx"
#pragma hdrstop

TLibrary::
TLibrary(
    LPCTSTR pszLibName
    ) 
{
    _hInst = LoadLibrary( pszLibName );

    if( !_hInst )
    {
        DBGMSG( DBG_WARN, ( "Library.ctr: unable to load "TSTR"\n", pszLibName ));
    }
}

TLibrary::
~TLibrary(
    )
{
    if( bValid() )
    {
        FreeLibrary( _hInst );
    }
}

BOOL
TLibrary::
bValid(
    VOID
    ) const
{
    return _hInst != NULL;
}

FARPROC
TLibrary::
pfnGetProc(
    IN LPCSTR pszProc
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, pszProc ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %s\n", pszProc ));
    }
    return fpProc;
}

FARPROC
TLibrary::
pfnGetProc(
    IN UINT uOrdinal
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, (LPCSTR)MAKELPARAM( uOrdinal, 0 ) ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %d\n", uOrdinal ));
    }
    return fpProc;
}

HINSTANCE
TLibrary::
hInst(
    VOID
    ) const
{
    return _hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\dlistlck.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    dlistlck.inl

Abstract:

    Double linked list with lock template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/

template <class T, class KEYTYPE>
TDoubleListLock<T, KEYTYPE>::TDoubleListLock<T, KEYTYPE>(void):
    m_bValid (FALSE)
{

    if (m_pList = new TDoubleList<T, KEYTYPE>) {
        if (m_pList->bValid ())
            m_bValid = TRUE;
    }

}

template <class T, class KEYTYPE>
TDoubleListLock<T, KEYTYPE>::~TDoubleListLock<T, KEYTYPE>(void)
{
    TAutoCriticalSection CritSec (m_CritSec);

    if (CritSec.bValid ())  {
    
        delete m_pList;
        m_pList = NULL;
    }
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::InsertItem (T item)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->InsertItem (item);
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::AppendItem (T item)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->AppendItem (item);
    }

    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::DeleteItem (T item)
{
    BOOL    bRet = FALSE;

    if (m_bValid) {
        Lock();

        bRet = m_pList->DeleteItem (item);
    
        Unlock();
    }

    return FALSE;
}


template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::InsertNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->InsertNode (pNewNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::AppendNode (TDoubleNode<T, KEYTYPE> *pNewNode)
{
    BOOL bRet = FALSE;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            bRet = m_pList->AppendNode (pNewNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
BOOL TDoubleListLock<T, KEYTYPE>::DeleteNode (TDoubleNode<T, KEYTYPE> *pNode)
{
    BOOL    bRet = FALSE;

    if (pNode && m_bValid) {
        
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
                         
            bRet = m_pList->DeleteNode (pNode);

    }
    return bRet;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> *
TDoubleListLock<T, KEYTYPE>::GetHead (void)
{
    TDoubleNode<T, KEYTYPE> * pHead = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pHead = m_pList->GetHead ();
    }

    return pHead;
}

template <class T, class KEYTYPE>
BOOL  
TDoubleListLock<T, KEYTYPE>::GetTotalNode (PDWORD pdwCount)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);
        
        if (CritSec.bValid ()) {
            bRet = m_pList->GetTotalNode (pdwCount);
        }
    }
    return bRet;
}

template <class T, class KEYTYPE>
T TSrchDoubleListLock<T, KEYTYPE>::FindItemFromKey (KEYTYPE key)
{
    T pItem = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pItem = m_pList->FindItemFromKey (key);
    }

    return pItem;
}
    
template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TSrchDoubleListLock<T, KEYTYPE>::FindNodeFromItem (T item)
{
    TDoubleNode<T, KEYTYPE> * pNode = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pNode = m_pList->FindNodeFromItem (item);
    
    }
    return pNode;
}

template <class T, class KEYTYPE>
TDoubleNode<T, KEYTYPE> * 
TSrchDoubleListLock<T, KEYTYPE>::FindNodeFromKey (KEYTYPE key)
{
    TDoubleNode<T, KEYTYPE> * pNode = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  
            pNode = m_pList->FindNodeFromKey (key);
    
    }
    return pNode;
}

template <class T, class KEYTYPE>
T TSrchDoubleListLock<T, KEYTYPE>::FindItemFromItem (T item)
{
    T pItem = NULL;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        if (CritSec.bValid ())  

            pItem = m_pList->FindItemFromItem (item);

    }
            
    return pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\mem.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    Mem.cxx

Abstract:

    Memory manipulations

Author:

    Albert Ting (AlbertT)  20-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

HANDLE ghMemHeap;

#if defined( CHECKMEM ) || DBG
LONG gcbMem = 0;
#endif

#if DBG

HANDLE ghDbgMemHeap;

VBackTrace* gpbtAlloc;
VBackTrace* gpbtFree;

/*++

    Memory fail test code

    This is test code (checked builds only) that fails memory allocations
    at regular intervals.  It helps detect cases where we are not checking
    memory return errors.

    Every gcAlloc allocations, it will try to fail.  However, if it detects
    that it has failed at that backtrace in the past, it will not fail
    and try to fail at the next allocation.

    Once it has failed, the counter is reset.

    To enable, set gbAllocFail to 1 (usually from the debugger).

    If you find an allocation and want to fail at it again, set the
    gAllocFailHash to the hash value of the failure, then also
    set gAllocFailHashAction to 1 (for fail) or 2 (for break and fail).


    gbAllocFail controls whether the alloc fail is enabled.
    gcAlloc is the current count of allocs.
    gcAllocFail indicates how often we fail (every gcAllocFail allocs).

--*/

BOOL gbAllocFail = FALSE;
LONG gcAlloc = 0;
LONG gcAllocFail = 0x20;
ULONG gAllocFailHash = 0;

enum EAllocFailHashAction {
    kIgnore = 0,
    kFail = 1,
    kBreakFail = 2
};

EAllocFailHashAction gAllocFailHashAction = kIgnore;

PVOID
DbgAllocMem(
    UINT cbSize
    )
{
    return HeapAlloc( ghDbgMemHeap, 0, cbSize );
}

VOID
DbgFreeMem(
    PVOID pMem
    )
{
    if( pMem ){
        HeapFree( ghDbgMemHeap, 0, pMem );
    }
}


#endif

PVOID
AllocMem(
    UINT cbSize
    )

/*++

Routine Description:

    Allocates memory.  If CHECKMEM is defined, adds tail guard.

Arguments:

Return Value:

--*/

{
#if defined( CHECKMEM ) || DBG
    PULONG_PTR pMem;
    UINT      cbNew;

    SPLASSERT( cbSize < 0x1000000 );
    cbNew = DWordAlign(cbSize+3*sizeof(*pMem));

    pMem = (PULONG_PTR)HeapAlloc( ghMemHeap, 0, cbNew );

    if (!pMem) {
        DBGMSG( DBG_WARN,
                ( "AllocMem failed: size %x, %d\n",
                  cbSize, GetLastError( )));

        return NULL;
    }

    FillMemory(pMem, cbNew, 0x83);

    pMem[0] = cbSize;

#if DBG
    HANDLE hData;
    ULONG Hash = 0;

    hData = gpbtAlloc ?
                gpbtAlloc->hCapture( (ULONG_PTR)&pMem[2], cbSize, 0, &Hash ) :
                NULL;

    pMem[1] = reinterpret_cast<ULONG_PTR>( hData );

    //
    // Test if what happens if out of memory failures
    // occur.
    //
    if( gbAllocFail && gpbtAlloc){

        BOOL bHashCase;

        bHashCase = ( Hash == gAllocFailHash ) &&
                    ( gAllocFailHashAction != kIgnore );

        if( bHashCase ||
            ( InterlockedCompareExchange( &gcAlloc, 0, 0 ) == 0 )){

            BOOL bBreak = bHashCase && ( gAllocFailHashAction == kBreakFail );

            PLONG plCount;

            plCount = gpbtAlloc->plGetCount( hData );

            //
            // Counter started at -1, so if it is 0 now, then fail
            // the allocation.
            //
            if( bBreak ||
                ( plCount && InterlockedIncrement( plCount ) == 0 )){

                gpbtAlloc->hCapture( 0, cbSize );
                HeapFree( ghMemHeap, 0, (PVOID)pMem );
                pMem = NULL;

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );

                //
                // Reset the counter to the negative number.
                //
                InterlockedExchangeAdd( &gcAlloc, -gcAllocFail );

                if( bBreak ){
                    OutputDebugStringA( "Reached AllocFail Hash.\n" );
                    DebugBreak();
                }

                return NULL;
            }
        } else {

            //
            // We didn't reach zero.  Increment the count.
            //
            InterlockedIncrement( &gcAlloc );
        }
    }

#endif

    InterlockedExchangeAdd( &gcbMem, cbNew );

    *(PDWORD)((PBYTE)pMem + cbNew - sizeof(ULONG_PTR)) = 0xdeadbeef;

    return (PVOID)(pMem+2);
#else
    return (PVOID)HeapAlloc( ghMemHeap, 0, cbSize );
#endif
}

VOID
FreeMem(
    PVOID pMem
    )
{
    if( !pMem ){
        return;
    }

#if defined( CHECKMEM ) || DBG
    DWORD   cbSize;
    PULONG_PTR pNewMem;

    pNewMem = (PULONG_PTR)pMem;
    pNewMem -= 2;

    cbSize = (DWORD)*pNewMem;
    InterlockedExchangeAdd( &gcbMem, -(LONG)cbSize );

    if (*(PDWORD)((PBYTE)pMem + DWordAlign(cbSize)) != 0xdeadbeef) {

        DBGMSG( DBG_ERROR,
                ( "Corrupt Memory: %x size = 0x%x\n",
                   pMem,
                   cbSize ));

    } else {

        FillMemory(pNewMem, cbSize, 0x65);
        HeapFree( ghMemHeap, 0, (PVOID)pNewMem );

#if DBG
        if( gpbtFree ){
            gpbtFree->hCapture( (ULONG_PTR)pMem, cbSize );
        }
#endif
    }
#else
    HeapFree( ghMemHeap, 0, (PVOID)pMem );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\loadwrap.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    loadwrap.cxx

Abstract:

    This implements a wrapper for all spooler calls to the loader to ensure that
    no exceptions are thrown from the loader and that on exit to every loader call,
    the owner of the loader lock is not the current thread. This is in response to
    a set of stress bugs where the loader lock is orphaned.

Author:

    Mark Lawrence   (mlawrenc)      -   28 Feb 2001

Environment:

    User Mode -Win32

Revision History:

--*/
#include "spllibp.hxx"
#include "loadwrap.hxx"

//
// Redefine all of the loader calls back to sanity.
// 
#undef LoadLibrary     
#undef GetProcAddress  
#undef FreeLibrary     
#undef LoadLibraryEx   
#undef LoadResource    
#undef LoadString      

#ifdef UNICODE

#define LoadLibrary     LoadLibraryW
#define LoadLibraryEx   LoadLibraryExW
#define LoadString      LoadStringW

#else

#define LoadLibrary     LoadLibraryA
#define LoadLibraryEx   LoadLibraryExA
#define LoadString      LoadStringA

#endif // !UNICODE

inline
VOID
EnterNtLoaderLockCheck(
        OUT BOOL            *pbInLock
    )
{
    *pbInLock = NtCurrentTeb()->ClientId.UniqueThread == 
            reinterpret_cast<PRTL_CRITICAL_SECTION>(NtCurrentPeb()->LoaderLock)->OwningThread;

    if (*pbInLock)
    {
        DbgPrintEx(DPFLTR_PRINTSPOOLER_ID, DPFLTR_INFO_LEVEL, "Loader Lock owned by thread on entry. Probably LoadLibrary in DllMain.\n");
    }
}

inline
VOID
CheckNotLoaderLockOwner(
    IN      BOOL            bInLock
    )
{
    if (!bInLock &&
        NtCurrentTeb()->ClientId.UniqueThread == 
            reinterpret_cast<PRTL_CRITICAL_SECTION>(NtCurrentPeb()->LoaderLock)->OwningThread)                                                                         
    {
        DbgPrint("Loader Lock owned by the current thread!\n");
        DebugBreak();
    }
}

inline
VOID
BreakAndAssert(
    IN      PCH             pszMessage
    )
{
    DbgPrint("Unexpected Exception thrown from loader code : ");
    DbgPrint(pszMessage); 
    DbgPrint(".\n");
    DebugBreak();
}


EXTERN_C
HMODULE
WrapLoadLibrary(
    IN      LPCTSTR     lpFileName
    )
{
    HMODULE     hModule = NULL;
    BOOL        bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try 
    {
        hModule = LoadLibrary(lpFileName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("LoadLibrary");
    }

    CheckNotLoaderLockOwner(bLock);

    return hModule;
}

EXTERN_C
FARPROC 
WrapGetProcAddress(
    IN      HMODULE     hModule,
    IN      LPCSTR      lpProcName
    )
{
    FARPROC     pfnProc = NULL;
    BOOL        bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try
    {
        pfnProc = GetProcAddress(hModule, lpProcName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("GetProcAddress");
    }

    CheckNotLoaderLockOwner(bLock);

    return pfnProc;
}

EXTERN_C
BOOL 
WrapFreeLibrary(
    IN      HMODULE     hModule
    )
{
    BOOL    bRet    = FALSE;
    BOOL    bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try
    {
        bRet = FreeLibrary(hModule);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("FreeLibrary");
    }

    CheckNotLoaderLockOwner(bLock);    
    
    return bRet;
}

EXTERN_C
HMODULE 
WrapLoadLibraryEx(
    IN      LPCTSTR     lpFileName,
    IN      HANDLE      hFile,
    IN      DWORD       dwFlags
    )
{
    HMODULE hModule = NULL;
    BOOL    bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try
    {
        hModule = LoadLibraryEx(lpFileName, hFile, dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("LoadLibraryEx");
    }

    CheckNotLoaderLockOwner(bLock);    
    
    return hModule;
}

EXTERN_C
HGLOBAL 
WrapLoadResource(
    IN      HMODULE     hModule, 
    IN      HRSRC       hResInfo 
    )
{
    HGLOBAL hGlobal = NULL;
    BOOL    bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try
    {
        hGlobal = LoadResource(hModule, hResInfo);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("LoadResource");
    }

    CheckNotLoaderLockOwner(bLock);    
    
    return hGlobal;
}

EXTERN_C
int 
WrapLoadString(
    IN      HINSTANCE   hInstance,
    IN      UINT        uID,             
    IN      LPTSTR      lpBuffer,
    IN      int         nBufferMax
    )
{
    int     iRet    = 0;
    BOOL    bLock   = FALSE;

    EnterNtLoaderLockCheck(&bLock);

    __try
    {
        iRet = LoadString(hInstance, uID, lpBuffer, nBufferMax);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        BreakAndAssert("LoadString");
    }

    CheckNotLoaderLockOwner(bLock);    

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\marshall.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    marshall.cxx

Abstract:

    Code for custom marshalling spooler structures sent via RPC/LPC.
    It handles 32-64 bit machine compatibility depending on the route the call is comming.
    It can come either from Kernel mode (NATIVE_CALL), an in-proc winspool.drv call (NATIVE_CALL),
    a 32 bit process (RPC_CALL) or a 64 bit process (RPC_CALL). 
    For native calls we perform basic marshalling. For RPC_CALLS we perform custom marshalling.
    Because there is no way to distinguish if a call came from a 64b or 32b proc, we always do
    custom marshalling across processes/wire.

Author:

    Ramanathan Venkatapathy (RamanV)   4/30/98

Revision History:

    Adina Trufinescu (AdinaTru) 12/09/99
    
--*/

#include "spllibp.hxx"
#pragma hdrstop
#include "cstmarsh.h"


/*++

Routine Name:   

    GetShrinkedSize

Routine Description: 

    Calculates the size of a 64bit structure as it is on 32bit.

Arguments: 

    pFieldInfo    -- structure containing information about fields inside the structure.           
    pShrinkedSize -- how much difference it between the structure'ssize on 32bit and 64bit

Return Value:  

    Size of the 32bit structure.

Last Error: 
    
    Not set.

--*/
EXTERN_C
BOOL
GetShrinkedSize(
    IN  FieldInfo   *pFieldInfo,
    OUT SIZE_T      *pShrinkedSize
    )
{

    DWORD     Index = 0;
    ULONG_PTR Size = 0; 
    ULONG_PTR Alignment = 0;
    BOOL      ReturnValue = FALSE;
    

    *pShrinkedSize = 0;

    //
    // For each field in the structure adds the length and enforce field's alignment.
    // For data fileds, the alignment is the same on both 32b and 64b.
    //
    for (Index = 0; pFieldInfo[Index].Offset != 0xffffffff; ++Index)
    {
        switch (pFieldInfo[Index].Type) 
        {
            case PTR_TYPE:
            {
                //
                // Treat pointers as they are on 32bit.
                //
                Size = sizeof(DWORD32);
                Alignment = sizeof(DWORD32);
                break;
            }
            case DATA_TYPE:
            {
                Size = pFieldInfo[Index].Size;
                Alignment = pFieldInfo[Index].Alignment;
                break;
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto End;
            }
        }
        //
        // Enforce alignment before adding the size of the next field.
        //
        *pShrinkedSize = (SIZE_T)(AlignIt((PBYTE)*pShrinkedSize, Alignment));
        //
        // Add field's size.
        //
        *pShrinkedSize += Size;
    }
    
    //
    // Almoust done. We need to align the 32b structure's size to 32bit since 
    // structures come as an array.
    //
    Alignment = sizeof(DWORD32);
    *pShrinkedSize = (SIZE_T)(AlignIt((PBYTE)*pShrinkedSize, Alignment));

    ReturnValue = TRUE;

End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallDownStructure

Routine Description: 

    Marshalls down structures to be sent via RPC/LPC.
    
Arguments:  
    pStructure   --  pointer to the structure to be marshalled down
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    RpcRoute    --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{

    BOOL    ReturnValue = FALSE;   
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;        
    }
    
    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // 32 bit server does not require special marshalling; 
            //
            ReturnValue = BasicMarshallDownStructure(pStructure, pFieldInfo);

            break;
        }
        case kSpl64Ptr :
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing
                    //
                    ReturnValue = BasicMarshallDownStructure(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallDownStructure(pStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }

End:
    return ReturnValue;

}

/*++

Routine Name:   

    MarshallDownEntry

Routine Description: 

    Custom marshalls down structures to be sent via RPC/LPC.

Arguments:  

    pStructure   --  pointer to the structure to be marshalled down
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled down structures ( pStructure == pNewStructure on 32b)
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the unmarshalled structure
    RpcRoute    --  indicates what type of marshalling we should do
    
Return Value:  

    TRUE if successful;

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
MarshallDownEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
  
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // 32 bit server does not require special marshalling
            //
            ReturnValue = BasicMarshallDownEntry(pStructure, pFieldInfo);

            break;
        }
        case kSpl64Ptr :
        {   
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallDownEntry(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallDownEntry(pStructure, pNewStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallUpStructure

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.

Arguments:  
    pStructure   --  pointer to the structure to be marshalled up
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize --  size of the structure as it is to be when marsahlled up
    Route        --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            ReturnValue = BasicMarshallUpStructure(pStructure, pFieldInfo);
            break;
        }
        case kSpl64Ptr:
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallUpStructure(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallUpStructure(pStructure, pFieldInfo, StructureSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            break;
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallUpEntry

Routine Description: 

    Custom marshalls up structures to be sent via RPC/LPC.

Arguments:  

    pStructure      --  pointer to the structure to be marshalled up
    pNewStructure   --  pointer to the new place where the structure will lay down
    in the array of marshalled up structures ( pStructure == pNewStructure on 32b)
    pFieldInfo      --  structure containing information about fileds inside the structure
    StructureSize   --  size of the structure as it is to be when marshalled up
    Route           -- determine what type of marshalling will be performed
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
BOOL
MarshallUpEntry(
    IN  OUT PBYTE   pStructure,
    IN  PBYTE       pNewStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  SIZE_T      ShrinkedSize,
    IN  CALL_ROUTE  Route
    )
{
    BOOL    ReturnValue = FALSE;
    
    if (!pStructure || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            ReturnValue = BasicMarshallUpEntry(pStructure, pFieldInfo);
            break;
        }
        case kSpl64Ptr :
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // The call came from Kernel Mode. In KM the structure is basic marshalled.
                    // We need to do the same thing here.
                    //
                    ReturnValue = BasicMarshallUpEntry(pStructure, pFieldInfo);
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // The call came through RPC.
                    // Do the custom marshalling regardless of caller's bitness.
                    //
                    ReturnValue = CustomMarshallUpEntry(pStructure, pNewStructure, pFieldInfo, 
                                                        StructureSize, ShrinkedSize);
                    break;    
                }   
                default:
                {
                    //
                    // Unknown route; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }
            break;    
        }
        default:
        {
            //
            // Unknown pointer size; should never happen
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }
    }
End:
    return ReturnValue;
}

/*++

Routine Name:   

    MarshallDownStructuresArray

Routine Description: 

    Custom marshalls down array of structures to be sent via RPC/LPC.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures and packed data
    cReturned   --  number of structures returned
    pFieldInfo   --  structure containing information about fields inside the structure
    StructureSize --  size of the 64bit structure 
    RpcRoute    --  indicates what type of marshalling we should do

Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallDownStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    DWORD   Index = 0;
    PBYTE   pStructure, pNewStructure;
    SIZE_T  ShrinkedSize = 0;
    BOOL    ReturnValue = FALSE;

    //
    // Check if there are any structures in the array.
    // This check must come before the one against pBufferArray and pFieldInfo.
    // If the Enum function didn't enumerate anything, we need to return success.
    //
    if (cReturned == 0) {
    
        ReturnValue = TRUE;
        goto End;
    }

    if (!pBufferArray || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // The size of the structure remains the same on 32b.
            //
            ShrinkedSize = StructureSize;

            break;
        }
        case kSpl64Ptr:
        {
            switch (Route) 
            {
                case NATIVE_CALL:
                {
                    //
                    // There is no need of special marshalling since the structures
                    // need to stay padding unaltered.
                    //
                    ShrinkedSize = StructureSize;
                    break;
                }
                case RPC_CALL:
                {
                    //
                    // Get the size of the 32b structure ; it takes care of both pointers and pointers/data alignments 
                    //
                    if (!GetShrinkedSize(pFieldInfo, &ShrinkedSize))
                    {
                        goto End;
                    }
                    break; 
                }   
                default:
                {
                    //
                    // Unknown route size; should never happen
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    break;
                }
            }   
            break;         
        }
        default: 
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto End;
        }
    }

    // 
    // pStructure is the pointer to the place where the 64b structure lays down in the array
    // pNewStructure is the pointer to the new place where the 32b structure will lay down in the array
    // MarshallDownEntry returns a pointer to the end of the just marshalled 32b structure which is  
    // the new place where the next 32b marshalled structure will lay down in the array
    //
    for( Index = 0, pNewStructure = pStructure = pBufferArray;
         Index < cReturned ; 
         Index++ , pStructure += StructureSize , pNewStructure += ShrinkedSize ) 
    {
        if (!MarshallDownEntry(pStructure, pNewStructure, pFieldInfo, StructureSize, Route))
        {
            goto End;
        }
    }

    ReturnValue = TRUE;

End:
    return ReturnValue;
    
}

/*++

Routine Name:   

    MarshallUpStructuresArray

Routine Description: 

    Custom marshalls up array of structures to be sent via RPC/LPC.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures and packed data
    cReturned    --  number of structures returned
    pFieldInfo   --  structure containing information about fileds inside the structure
    StructureSize -- size of the 64bit structure ( including the padding )
    Route         -- determine what type of marshalling will be performed
    
Return Value:  

    TRUE if successful.

Last Error: 

    Set to ERROR_INVALID_PARAMETER if unknown Field type or architecture other than 32bit or 64bit.

--*/
EXTERN_C
BOOL
MarshallUpStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    )
{
    INT32   Index = 0;
    PBYTE   pStructure, pNextStructure;
    SIZE_T  ShrinkedSize = 0;
    BOOL    ReturnValue = FALSE;
    
    //
    // Check if there are any structures in the array.
    // This check must come before the one against pBufferArray and pFieldInfo.
    // If the Enum function didn't enumerate anything, we need to return success.
    //
    if (cReturned == 0) {
    
        ReturnValue = TRUE;
        goto End;
    }

    if (!pBufferArray || !pFieldInfo) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
            //
            // The size of the structure remains the same on 32b.
            //
            ShrinkedSize = StructureSize;

            break;
        }
        case kSpl64Ptr:
        {
            //
            // Get the size of the 32b structure ; it takes care of both pointers and pointers/data alignments 
            //
            if (!GetShrinkedSize(pFieldInfo, &ShrinkedSize))
            {
                goto End;
            }            
            break;
        }
        default: 
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto End;
        }
    }
    
    //
    // pBufferArray is an array of 32b stuctures;
    // pStructure is the pointer to the place where the 32b structure lays down in the array
    // pNewStructure is the pointer to the new place where the 64b structure will lay down in the array
    //
    for (Index = cReturned - 1; Index >= 0 ; Index--) 
    {
        pStructure = pBufferArray + Index * ShrinkedSize;

        pNextStructure = pBufferArray + Index * StructureSize;

        if (!MarshallUpEntry(pStructure, pNextStructure, pFieldInfo, StructureSize, ShrinkedSize, Route))
        {
            goto End;
        }
    }

    ReturnValue = TRUE;
End:
    return ReturnValue;
}

/*++

Routine Name:   

    UpdateBufferSize

Routine Description: 

    UpdateBufferSize adjusts the number of bytes required for
    returning the structures based on 32 and 64 bit clients and servers.

Arguments:  

    pOffsets     - pointer to Offset struct
    cbStruct     - sizeof struct
    cbStructAlign - sizeof struct aligned on 32b
    pcNeeded     - pointer to number of bytes needed
    cbBuf        - sizeof input buffer
    dwError      - last error from RPC call
    pcReturned   - pointer to number of returned structures
                  (valid only if dwError == ERROR_SUCCESS)
    
Return Value:  

    Last Error; This function is called right after a RPC call.
    dwError is the return value of RPC call.
    The return value of this function is the result of applying of this code on the dwError.

Last Error: 

    Not set.

--*/
EXTERN_C
DWORD
UpdateBufferSize(
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      cbStruct,
    IN  OUT LPDWORD pcbNeeded,
    IN  DWORD       cbBuf,
    IN  DWORD       dwError,
    IN  LPDWORD     pcReturned
    )
{
    DWORD   cStructures = 0;
    SIZE_T  cbShrinkedStruct = 0;

    if (dwError != ERROR_SUCCESS &&
        dwError != ERROR_MORE_DATA &&
        dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // RpcCall failed, no need to update required size
        //
        goto End;
    }

    if (!cbStruct)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto End;
    }

    switch (kPointerSize) 
    {
        case kSpl32Ptr:
        {
           //
           // The pointers are not bigger on the server. Hence no adjustment is
           // required.
           //
           break;
        }
        case kSpl64Ptr:
        {            
            if (!GetShrinkedSize(pFieldInfo, &cbShrinkedStruct))
            {
                dwError = ERROR_INVALID_PARAMETER;
                goto End;
            }
        
            //
            // Increase the required size of buffer. This may be superfluous in the 64-64
            // connection but this solution is simpler than adjusting pcbNeeded on the server.
            // 
            // Count the number of structures to be returned
            // *pcbNeeded must be divided with the size of the structure on 32 bit.
            //
            cStructures = *pcbNeeded / (DWORD32)cbShrinkedStruct;        

            //
            // For each structure, pcbNeeded is increased with the number of bites the pointers shrink
            // and the number of bites needed fpr padding
            // cbStruct - cbStructAlign is the number of bytes the compiler padds
            //
            *pcbNeeded += (DWORD) (cStructures * (cbStruct - cbShrinkedStruct));

            if (cbBuf < *pcbNeeded && dwError == ERROR_SUCCESS)
            {
               dwError = ERROR_INSUFFICIENT_BUFFER;
            }            

            break;
        }
        default: 
        {
            //
            // Invalid pointer size; should not occur.
            //
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
    }

End:
    return dwError;
}


/*++

Routine Name:   

    AdjustPointers

Routine Description: 

    AdjustPointers adjusts pointer fields inside the structure.

Arguments:  

    pStructure   -- pointer to a structructure
    pFieldInfo   -- contains information about fields inside the structure
    cbAdjustment -- quantity to add to all pointer fields inside the structure
    
Return Value:  

    None.

Last Error: 

    Not set.

--*/
EXTERN_C
VOID
AdjustPointers
(   IN  PBYTE       pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  ULONG_PTR   cbAdjustment
    )    
{   PBYTE   *pOffset = NULL;
    DWORD   Index = 0;
    DWORD32 Offset = 0;
    
    for (Index = 0; Offset = pFieldInfo[Index].Offset, Offset != 0xffffffff; ++Index) 
    {
        if (pFieldInfo[Index].Type == PTR_TYPE) 
        {
            pOffset = (PBYTE *)(pStructure + Offset);

            if ( *pOffset )
            {
                *pOffset += (ULONG_PTR)cbAdjustment;
            }
        }
    }
}



/*++

Routine Name:   

    AdjustPointersInStructuresArray

Routine Description: 

    AdjustPointersInStructuresArray adjusts pointer fields 
    inside the each structure of an array.

Arguments:  

    pBufferArray --  pointer to the buffer containing the array of structures
    cReturned    --  number of structures in array
    pFieldInfo   -- contains information about fields inside the structure
    StructureSize -- size of structure 
    cbAdjustment -- quantity to add to all pointer fields inside the structure
    
Return Value:  

    None.

Last Error: 

    Not set.

--*/
EXTERN_C
VOID
AdjustPointersInStructuresArray(
    IN  PBYTE       pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  ULONG_PTR   cbAdjustment
    )    
{   
    INT32   Index = 0;
    PBYTE   pStructure;
    
    if (cReturned && cbAdjustment && pBufferArray && pFieldInfo) 
    {
        for (Index = cReturned - 1; Index >= 0 ; Index--) 
        {
            pStructure = pBufferArray + Index * StructureSize;

            //
            // Call AdjustPointers for each entry in the array
            //
            AdjustPointers(pStructure, pFieldInfo, cbAdjustment);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\memblock.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    memblock.cxx

Abstract:

    Memory allocater for chunks of read only memory.

Author:

    Albert Ting (AlbertT)  30-Aug-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

TMemBlock::
TMemBlock(
    UINT uGranularity,
    DWORD fdwFlags) :
    _uGranularity(uGranularity),
    _pIterBlock(NULL),
    _pIterData(NULL),
    _dwCount(0),
    _fdwFlags(fdwFlags)
{
    DWORD dwSize = dwBlockHeaderSize() + _uGranularity;

    if( _fdwFlags & kFlagGlobalNew ){

        _pLast = (PBLOCK) new BYTE[dwSize];

    } else {

        _pLast = (PBLOCK)AllocMem( dwSize );
    }

    _pFirst = _pLast;

    if (_pFirst) {
        _pFirst->pNext = NULL;
        _dwNextFree = dwBlockHeaderSize();
    }
}

TMemBlock::
~TMemBlock()
{
    PBLOCK pBlock;
    PBLOCK pBlockNext;

    for (pBlock = _pFirst; pBlock; pBlock = pBlockNext) {

        pBlockNext = pBlock;

        if( _fdwFlags & kFlagGlobalNew ){

            delete [] (PBYTE)pBlock;

        } else {

            //
            // Our Delete must mirror the New.
            //
            FreeMem(pBlock);
        }
    }
}

PVOID
TMemBlock::
pvAlloc(
    DWORD dwSize
    )
{
    PDATA pData;

    //
    // If out of memory, fail.
    //
    if (!_pFirst) {
        goto FailOOM;
    }

    dwSize = Align(dwSize + dwDataHeaderSize());

    SPLASSERT(dwSize <= _uGranularity);

    if (dwSize + _dwNextFree > _uGranularity) {

        DWORD dwSize = dwBlockHeaderSize() + _uGranularity;

        //
        // Must allocate a new block
        //
        if( _fdwFlags & kFlagGlobalNew ){

            _pLast->pNext = (PBLOCK) new BYTE[dwSize];

        } else {

            _pLast->pNext = (PBLOCK)AllocMem( dwSize );
        }

        if (!_pLast->pNext) {
            goto FailOOM;
        }

        _pLast = _pLast->pNext;
        _pLast->pNext = NULL;

        _dwNextFree = dwBlockHeaderSize();
   }

   //
   // We have enough space in this link now;
   // update everything.
   //

   pData = (PDATA)((PBYTE)_pLast + _dwNextFree);
   pData->dwSize = dwSize;

   _dwNextFree += dwSize;
   _pLast->pDataLast = pData;
   _dwCount++;

   return pvDataToUser(pData);

FailOOM:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return NULL;
}

PVOID
TMemBlock::
pvFirst(
    VOID
    )
{
    if (!_dwCount) {
        return NULL;
    }

    _pIterBlock = _pFirst;
    _pIterData = pBlockToData(_pIterBlock);
    _dwIterCount = 0;

    return pvDataToUser(_pIterData);
}

PVOID
TMemBlock::
pvIter(
    VOID
    )
{
    _dwIterCount++;

    if (_dwIterCount == _dwCount)
        return NULL;

    //
    // Go to next block.  If we're at the last pData, go to next block.
    //
    if (_pIterData == _pIterBlock->pDataLast) {

        _pIterBlock = _pIterBlock->pNext;
        _pIterData = pBlockToData(_pIterBlock);

    } else {

        _pIterData = pDataNext(_pIterData);
    }

    return pvDataToUser(_pIterData);
}


UINT
TMemBlock::
uSize(
    PVOID pvUser
    ) const
{
    return pvUserToData(pvUser)->dwSize;
}

#if 0

/********************************************************************

    TMemCircle:

    Implements a circular buffer.  Data is DWORD aligned.

    !! LATER !!

    Replace the array of TLines with this circular buffer.  This
    eliminates the alloc in the debug logging code, but requires
    a mechanism that passes both line/file information in addition
    to the debug wsprintf args.

    This code has not been thoroughly tested.

********************************************************************/

TMemCircle::
TMemCircle(
    COUNTB cbTotal
    ) : _cTail( 0 ), _cPrev( 0 )

/*++

Routine Description:

    Create a new circular buffer.

Arguments:

    cbTotal - Size in bytes of the entire buffer.

Return Value:

--*/

{
    _cTotal = cCountFromSize( cbTotal );
    _pdwData = (PDWORD)AllocMem( cbSizeFromCount( _cTotal ));

    ZeroMemory( _pdwData, cbSizeFromCount( _cTotal ));
}

TMemCircle::
~TMemCircle(
    VOID
    )

/*++

Routine Description:

    Destroys the circular buffer.

Arguments:

Return Value:

--*/

{
    FreeMem( (PVOID)_pdwData );
}

PVOID
TMemCircle::
pvAlloc(
    COUNTB cbSize
    )

/*++

Routine Description:

    Allocates a buffer of the requested size from the circular memory.

Arguments:

    cbSize - Size of requested block.

Return Value:

    Allocated buffer.

--*/

{
    //
    // Allocate size plus extra DWORD header for size.
    //
    COUNT cSize = cCountFromSize( cbSize ) + 1;

    //
    // Ensure this block fits.
    //
    SPLASSERT( cSize < _cTotal - 1 );

    //
    // Check we can't fit at the current location.
    //
    if( _cTail + cSize > _cTotal ){

        SPLASSERT( _cTail <= _cPrev );

        //
        // This block won't fit in the remaining space.
        // Expand the previous block so it consumes the rest of the
        // space, then reset the pointer to the beginning of the buffer.
        //
        PDWORD pdwHeader = &_pdwData[_cTail-_cPrev];

        _cPrev = _cTotal - _cTail;
        vSetCur( pdwHeader, _cPrev );

        //
        // We are now at the beginning.
        //
        _cTail = 0;
    }

    //
    // Add the block.
    //
    PDWORD pdwBlock = &_pdwData[_cTail];
    vSetHeader( pdwBlock, cSize, _cPrev );

    //
    // Update our state pointers.
    //
    _cTail += cSize;
    _cPrev = cSize;

    //
    // Return the space after the header.
    //
    return (PVOID)&pdwBlock[1];
}

PVOID
TMemCircle::
pvFirstPrev(
    VOID
    ) const
{
    //
    // If we've never set _cPrev, the we've never allocated anything.
    //
    if( !_cPrev ){
        return NULL;
    }

    PDWORD pdwPrev = pdwPrevHeader( &_pdwData[_cTotal], _cPrev );

    return &pdwPrev[1];
}

PVOID
TMemCircle::
pvPrev(
    PVOID pvCurrent
    ) const

/*++

Routine Description:

    Given a block, return the previous block, or NULL if the block
    doesn't exist or was overwritten.

Arguments:

    pvCurrent - Current block.

Return Value:

    PVOID - Previous block or NULL.

--*/

{
    //
    // Get to the header of this block.
    //
    PDWORD pdwHeader = (PDWORD)pvCurrent;
    --pdwHeader;

    PDWORD pdwPrev = pdwPrevHeader( pdwHeader, cGetPrev( *pdwHeader ));

    //
    // Check if the previous block was overwritten.
    //
    if( bOverwritten( pdwPrev, pdwHeader )){
        return NULL;
    }

    //
    // Return the previous block (adjust for header).
    //
    return (PVOID)&pdwPrev[1];
}

PVOID
TMemCircle::
pvNext(
    PVOID pvCurrent
    ) const
{
    //
    // Get to the header of this block.
    //
    PDWORD pdwHeader = (PDWORD)pvCurrent;
    --pdwHeader;

    PDWORD pdwNext = &pdwHeader[cGetCur(*pdwHeader)];

    //
    // If we're at the end of the block, then go to the beginning.
    // The alloc routine guarantees that the last block ends exactly
    // at the end of the entire buffer.
    //
    if( pdwNext == &_pdwData[_cTotal] ){

        //
        // Reset to the beginning of the buffer.
        //
        pdwNext = _pdwData;

    } else if( pdwNext == &_pdwData[_cTail] ){

        //
        // We're at the end.
        //
        return NULL;
    }

    //
    // Return the next block (adjust for header).
    //
    return (PVOID)&pdwNext[1];
}

/********************************************************************

    Private impementation.

********************************************************************/


BOOL
TMemCircle::
bOverwritten(
    PDWORD pdwCheck,
    PDWORD pdwNext
    ) const

/*++

Routine Description:

    Determine whether the block has been overwritten by
    looking at the pdwCheck and pdwNext pointers.

    Low                           High
    +--------------------------------------+
    | v  v  v    v  |   v      v    v   v  |
    +--------------------------------------+
      Nx C0 N0   C1 T   N1     C2   N2  Cx

    C0/N0: Valid; both behind Tail.
    C2/N2: Valid; both in front of Tail.
    C1/N1: Invalid: straddles Tail.

    If C1 == T, it's valid.

    If N1 == T, it's invalid.
    This block could be valid (it may have been the last block
    allocated), or invalid (it's really old and was just overwritten
    by the last block).  However, when searching backwards, we always
    get the most recent block without checking this routine since we
    know it's valid.

    Note: Cx/Nx is an illegal configuration: block must be contiguous.

Arguments:

    pdwCheck - Block to check.

    pdwNext - Pointer to the next block.
        We can't use pdwCheck's cCur size since it may have been
        overwritten already.

Return Value:

    TRUE - Overwritten; the data at pdwPrev doesn't exist anymore.
    FALSE - Data at pdwPrev is valid.

--*/

{
    PDWORD pdwTail = &_pdwData[_cTail];

    //
    // If the next pointer is equal to the prev, or the cTail stradles
    // the two, then it's been overwritten.
    //
    if( pdwTail == pdwNext ||
        ( pdwCheck < pdwTail && pdwNext > pdwTail )){

        return TRUE;
    }

    return FALSE;
}

PDWORD
TMemCircle::
pdwPrevHeader(
    PDWORD pdwHeader,
    COUNT cPrev
    ) const

/*++

Routine Description:

    Given a block, return the previous block, or NULL if the block
    doesn't exist or was overwritten.

Arguments:

    pvCurrent - Current block.

Return Value:

    PVOID - Previous block or NULL.

--*/

{
    PDWORD pdwBase = pdwHeader;

    //
    // Check if this is the first block.  If so, then the pPrev
    // isn't offset from the beginning, but from the end of _pdwData.
    //
    if( pdwHeader == _pdwData ){
        pdwBase = &_pdwData[_cTotal];
    }

    return pdwBase - cPrev;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\marshall.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    marshall.hxx

Abstract:

    Declarations for marshalling spooler structures sent via RPC/LPC

Author:

    Ramanathan Venkatapathy (RamanV)   4/30/98

Revision History:

--*/


//
// 32-64 bit marshalling constants
//

#include "mType.h"

typedef enum _EDataSize 
{
	kPointerSize = sizeof (ULONG_PTR),

} EDataSize;

typedef enum _EPtrSize 
{
	kSpl32Ptr = 4,
    kSpl64Ptr = 8,

} EPtrSize ;

EXTERN_C
BOOL
MarshallDownStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
BOOL
MarshallUpStructure(
    IN  OUT PBYTE   pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );


EXTERN_C
BOOL
MarshallUpStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
BOOL
MarshallDownStructuresArray(
    IN  OUT PBYTE   pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  CALL_ROUTE  Route
    );

EXTERN_C
DWORD
UpdateBufferSize(
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      cbStruct,
    IN  OUT LPDWORD pcbNeeded,
    IN  DWORD       cbBuf,
    IN  DWORD       dwError,
    IN  LPDWORD     pcReturned
    );

EXTERN_C
BOOL
GetShrinkedSize(
    IN  FieldInfo   *pFieldInfo,
    OUT SIZE_T      *pShrinkedSize      
    );

EXTERN_C
VOID
AdjustPointers(
    IN  PBYTE       pStructure,
    IN  FieldInfo   *pFieldInfo,
    IN  ULONG_PTR   cbAdjustment
    );    

EXTERN_C
VOID
AdjustPointersInStructuresArray(
    IN  PBYTE       pBufferArray,
    IN  DWORD       cReturned,
    IN  FieldInfo   *pFieldInfo,
    IN  SIZE_T      StructureSize,
    IN  ULONG_PTR   cbAdjustment
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\sitem.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    sitem.inl

Abstract:

    Item template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/


template <class T>
CSingleItem<T>::CSingleItem(void)
               : m_Data(NULL), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item)
               : m_Data(item), m_Next(NULL)
{
}

template <class T>
CSingleItem<T>::CSingleItem(T item, CSingleItem<T>* next)
               : m_Data(item), m_Next(next)
{
}

template <class T>
CSingleItem<T>::~CSingleItem(void)
{
    if (m_Data) {
        delete (m_Data);
    }
}

template <class T>
void CSingleItem<T>::SetNext (CSingleItem<T> *item)
{
    m_Next = item;
}

template <class T>
CSingleItem<T> * CSingleItem<T>::GetNext (void )
{
    return m_Next;
}

template <class T>
T CSingleItem<T>::GetData (void )
{
    return m_Data;
}


template <class T>
BOOL CSingleItem<T>::IsSame (T &item)
{
    return m_Data->Compare (item) == 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\sharedat.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    sharedat.cxx

Abstract:

    Shared data implementation.

Author:

    Albert Ting (AlbertT)  5-Oct-1997

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#include "sharedat.hxx"

LPCTSTR szSuffixFile = SZ_SUFFIX_FILE;


/********************************************************************

    TShareData::TBase

    Base functionality common to both TReadWrite and TRead.

********************************************************************/

TShareData::
TBase::
TBase(
    VOID
    ) : m_hMap( NULL ), m_pData( NULL )
{
}

VOID
TShareData::
TBase::
vCleanup(
    VOID
    )
{
    if( m_pData )
    {
        UnmapViewOfFile( m_pData );
        m_pData = NULL;
    }

    if( m_hMap )
    {
        CloseHandle( m_hMap );
        m_hMap = NULL;
    }
}

TShareData::
TBase::
~TBase(
    VOID
    )
{
    vCleanup();
}

BOOL
TShareData::
TBase::
bGetFullName(
    LPCTSTR pszName,
    LPTSTR pszFullName
    )
{
    UINT cchName;
    //
    // Validate input and determine the size of the name.
    //
    if( !pszName || !pszName[0] || ( cchName = lstrlen( pszName )) >= MAX_PATH )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    //
    // Create shared file object.
    //
    lstrcpy( pszFullName, pszName );
    lstrcpy( &pszFullName[cchName], szSuffixFile );

    return TRUE;
}

/********************************************************************

    TShareData::TReadWrite

    Class that allows user to read and write a shared data object.
    Since there is only one valid writer, the vWriteBegin and
    vWriteEnd functions are rolled up together here.

********************************************************************/

TShareData::
TReadWrite::
TReadWrite(
    IN LPCTSTR pszName,
    IN DWORD cbSize,
    IN PSECURITY_ATTRIBUTES pSA
    ) : TBase()

/*++

Routine Description:

    Create a shared data access object.

Arguments:

    pszName - Name of shared memory object.

    pSA - Security attributes.

Return Value:

--*/

{
    TCHAR szFullName[kNameBufferMax];

    if( bGetFullName( pszName, szFullName ))
    {
        m_hMap = CreateFileMapping( INVALID_HANDLE_VALUE,
                                    pSA,
                                    PAGE_READWRITE,
                                    0,
                                    sizeof( TData ) + cbSize,
                                    szFullName );

        if( m_hMap )
        {
            m_pData = (pTData)MapViewOfFile( m_hMap,
                                             FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0 );
            m_pData->cbSize = cbSize;

            //
            // Put ourselves in an inconsistent state so that clients won't
            // read bad data.  The callee must call vWriteFirst() after
            // the first initialization.
            //
            m_pData->lCount2 = m_pData->lCount1 + 1;
        }
    }

    //
    // m_pData is our valid check.  If this variable is NULL
    // then the object wasn't created correctly.
    //
}

VOID
TShareData::
TReadWrite::
vWriteFirst(
    VOID
    )
{
    m_pData->lCount1 = m_pData->lCount2 = 0;
}

VOID
TShareData::
TReadWrite::
vWriteBegin(
    VOID
    )
{
    InterlockedIncrement( &m_pData->lCount2 );
}

VOID
TShareData::
TReadWrite::
vWriteEnd(
    VOID
    )
{
    InterlockedIncrement( &m_pData->lCount1 );
}


/********************************************************************

    TShareData::TRead

    Read-only class.  Since there can be multiple readers, the
    reader instance is separated out into a TReadSync class.

********************************************************************/


TShareData::
TRead::
TRead(
    IN LPCTSTR pszName,
    IN DWORD cbSize
    ) : TBase()

/*++

Routine Description:

    Create a shared data access object.

Arguments:

    pszName - Name of shared memory object.

Return Value:

--*/

{
    TCHAR szFullName[kNameBufferMax];

    if( bGetFullName( pszName, szFullName ))
    {
        m_hMap = OpenFileMapping( FILE_MAP_READ,
                                  FALSE,
                                  szFullName );

        if( m_hMap )
        {
            m_pData = (pTData)MapViewOfFile( m_hMap,
                                             FILE_MAP_READ,
                                             0,
                                             0,
                                             0 );
            if( m_pData )
            {
                if( m_pData->cbSize < cbSize )
                {
                    vCleanup();
                    SetLastError( ERROR_INVALID_PARAMETER );
                }
            }
        }
    }

    //
    // m_pData is our valid check.  If this variable is NULL
    // then the object wasn't created correctly.
    //
}


/********************************************************************

    TShareData::TReadSync

    Synchronizes a read instance from a TShareData::Read object.
    There can be multiple TReadSyncs running concurrently for a
    given TShareData::Read object.

********************************************************************/

TShareData::
TReadSync::
TReadSync(
    TRead& Read
    ) : m_Read( Read )
{
}

VOID
TShareData::
TReadSync::
vReadBegin(
    VOID
    )
{
    m_lCount = m_Read.m_pData->lCount1;
}

BOOL
TShareData::
TReadSync::
bReadEnd(
    VOID
    )
{
    return m_Read.m_pData->lCount2 == m_lCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\sleepn.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    sleepn.cxx

Abstract:

    Handles delayed callbacks.  Delay must be < 49.7 days, and the
    callback must execute very quickly.

Author:

    Albert Ting (AlbertT)  19-Dec-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

TSleepNotify::
TSleepNotify(
    VOID
    )
/*++

Routine Description:

    Single thread that servers as a timer.

Arguments:

Return Value:

Notes:

    _hEvent is our validity variable.

--*/
{
    _hEvent = CreateEvent( NULL,
                           FALSE,
                           FALSE,
                           NULL );

    if( !_hEvent ){
        return;
    }
}

#if 0
TSleepNotify::
~TSleepNotify(
    VOID
    )

/*++

Routine Description:

    Destroys the SleepNotify.  This should never be called since we
    never should destruct the object.

Arguments:

Return Value:

--*/

{
    if( _hEvent ){
        CloseHandle( _hEvent );
    }
}
#endif


VOID
TSleepNotify::
vRun(
    VOID
    )

/*++

Routine Description:

    Main worker loop for callbacks.  We will wait on an object
    to pickup new notifications, and when we time out, do the callback.

Arguments:

    VOID

Return Value:

    VOID: never returns.

--*/

{
    DWORD dwTimeout;
    DWORD dwResult;
    VSleepWorker* pSleepWorker;

    TCritSecLock CSL( _CritSec );

    while( TRUE ){

        pSleepWorker = SleepWorker_pHead();

        dwTimeout = pSleepWorker ?
                        pSleepWorker->TickCountWake - GetTickCount() :
                        INFINITE;

        {
            TCritSecUnlock CSU( _CritSec );
            dwResult = WaitForSingleObject( _hEvent, dwTimeout );
        }

        if( dwResult == WAIT_TIMEOUT ){

            //
            // We added a new item, so go back to sleep with the
            // new timeout value.
            //
            continue;
        }

        //
        // Traverse linked list for all items that must be callbacked.
        //

        PDLINK pdlink;
        TICKCOUNT TickCountNow = GetTickCount();

        for( pdlink = SleepWorker_pdlHead();
             SleepWorker_bValid( pdlink ); ){

            pSleepWorker = SleepWorker_pConvert( pdlink );
            pdlink = SleepWorker_pdlNext( pdlink );

            if( pSleepWorker->TickCountWake - TickCountNow < kTickCountMargin ){

                //
                // We should wake up this guy now.
                // There is a 1 hr margin since these call backs to
                // take time to execute, and we may miss one of them.
                //
                pSleepWorker->vCallback();

                //
                // Remove current item from linked list.
                //
                pSleepWorker->SleepWorker_vDelinkSelf();

            } else {

                //
                // This item still needs to sleep a little longer.
                // Since they are ordered by sleep time, we can
                // stop now.
                //
                break;
            }
        }
    }
}


VOID
TSleepNotify::
vAdd(
    VSleepWorker& SleepWorkerAdd,
    TICKCOUNT TickCountWake
    )

/*++

Routine Description:

    Insert a SleepWorker into the list of items sleeping based on
    when it wants to wake.  The shortest sleepers are first on the list.

Arguments:

    SleepWorkerAdd -- Item that wants to sleep a while.

    TickCountWake -- Tick count that we want to wake at.

Return Value:

--*/

{
    TCritSecLock CSL( _CritSec );

    //
    // Traverse until we see someone that wants to sleep more than us.
    //
    PDLINK pdlink;
    VSleepWorker* pSleepWorker;
    TICKCOUNT TickCountNow = GetTickCount();
    TICKCOUNT TickCountSleep = TickCountWake - TickCountNow;

    for( pdlink = SleepWorker_pdlHead();
         SleepWorker_bValid( pdlink );
         pdlink = SleepWorker_pdlNext( pdlink ) ){

        pSleepWorker = SleepWorker_pConvert( pdlink );

        //
        // If the amount this item wants to sleep is greater than
        // the amount we want to sleep, then insert item here.
        //
        if( pSleepWorker->TickCountWake - TickCountNow > TickCountSleep ){

            SleepWorker_vInsertBefore( pdlink, &SleepWorkerAdd );
            return;
        }
    }

    //
    // No items or last item.
    // Add to end of list.
    //
    SleepWorker_vAppend( &SleepWorkerAdd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\slist.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved.

Module Name:

    slist.inl

Abstract:

    Single linked list template class.

Author:

    Weihai Chen  (WeihaiC) 06/29/98

Revision History:

--*/

template <class T>
CSingleList<T>::CSingleList<T>(void)
               :m_Dummy ()
{
}

template <class T>
CSingleList<T>::~CSingleList<T>(void)
{
    Lock ();

    CSingleItem<T> *pItem = m_Dummy.GetNext();
    CSingleItem<T> *pNext;

    while (pItem) {
        pNext = pItem->GetNext();
        delete pItem;
        pItem = pNext;
    }
    Unlock ();
}

template <class T>
BOOL CSingleList<T>::Insert (T item)
{
    BOOL bRet = FALSE;

    Lock();

    CSingleItem<T> *pNewItem = new CSingleItem<T> (item, m_Dummy.GetNext());

    if (pNewItem) {
        m_Dummy.SetNext (pNewItem);
        bRet = TRUE;
    }

    Unlock();
    return bRet;
}

template <class T>
BOOL CSingleList<T>::Delete (T item)
{
    CSingleItem<T> *pHead = &m_Dummy;
    CSingleItem<T> *pItem;
    BOOL    bRet = FALSE;

    Lock();

    while (pItem = pHead->GetNext()) {
        if (pItem->IsSame (item)) {
            // Delete it
            pHead->SetNext (pItem->GetNext ());
            delete (pItem);
            bRet = TRUE;
            break;
        }
        pHead = pHead->GetNext();
    }
    Unlock();

    return FALSE;
}

template <class T>
T CSingleList<T>::Find (T item)
{

    Lock();

    CSingleItem<T> *pItem = m_Dummy.GetNext();

    while (pItem) {
        if (pItem->IsSame (item)) {
            Unlock ();
            return pItem->GetData();
        }
        pItem = pItem->GetNext();
    }

    Unlock ();

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\threadm.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ThreadM.c

Abstract:

    Generic thread manager for spooler.

Author:

    Albert Ting (AlbertT) 13-Feb-1994

Environment:

    User Mode -Win32

Revision History:

    Albert Ting (AlbertT) 28-May-1994       C++ized

--*/

#include "spllibp.hxx"
#pragma hdrstop

pfCreateThread gpfSafeCreateThread;

/********************************************************************

    Public interfaces.

********************************************************************/

TThreadM::
TThreadM(
    UINT uMaxThreads,
    UINT uIdleLife,
    MCritSec* pCritSec OPTIONAL
    ) :

    _uMaxThreads(uMaxThreads), _uIdleLife(uIdleLife), _uActiveThreads(0),
    _uRunNowThreads(0), _iIdleThreads(0)

/*++

Routine Description:

    Construct a Thread Manager object.

Arguments:

    uMaxThreads - Upper limit of threads that will be created.

    uIdleLife - Maximum life once a thread goes idle (in ms).

    pCritSec - Use this crit sec for synchronization (if not specified,
        a private one will be created).

Return Value:

Notes:

    _hTrigger is our validity variable.  When this value is NULL,
    instantiation failed.  If it's non-NULL, the entire object is valid.

--*/

{
    _hTrigger = CreateEvent( NULL,
                             FALSE,
                             FALSE,
                             NULL );

    if( !_hTrigger ){
        return;
    }

    //
    // If no critical section, create our own.
    //
    if (!pCritSec) {

        _pCritSec = new MCritSec();

        if( !VALID_PTR( _pCritSec )){

            //
            // _hTrigger is our valid variable.  If we fail to create
            // the critical section, prepare to return failure.
            //
            CloseHandle( _hTrigger );
            _hTrigger = NULL;

            return;
        }
        _State |= kPrivateCritSec;

    } else {
        _pCritSec = pCritSec;
    }
}

VOID
TThreadM::
vDelete(
    VOID
    )

/*++

Routine Description:

    Indicates that the object is pending deletion.  Any object that
    inherits from vDelete should _not_ call the destructor directly,
    since there may be pending jobs.  Instead, they should call
    TThreadM::vDelete().

Arguments:

Return Value:

--*/

{
    BOOL bDestroy = FALSE;

    {
        TCritSecLock CSL( *_pCritSec );

        //
        // Mark as wanting to be destroyed.
        //
        _State |= kDestroyReq;

        if( !_iIdleThreads && !_uActiveThreads ){
            bDestroy = TRUE;
        }
    }

    if( bDestroy ){

        //
        // Delete the object.  Note that absolutely no object fields
        // can be accessed after this, since the object is returned
        // to free store.
        //
        delete this;
    }
}

BOOL
TThreadM::
bJobAdded(
    BOOL bRunNow
    )

/*++

Routine Description:

    Notify the thread manager that a new job has been added.  This job
    will be processed fifo.

Arguments:

    bRunNow - Ignore the thread limits and run the job now.

Return Value:

    TRUE - Job successfully added.
    FALSE - Job could not be added.

--*/

{
    DWORD dwThreadId;
    HANDLE hThread;
    BOOL rc = TRUE;

    TCritSecLock CSL( *_pCritSec );

    if( _State.bBit( kDestroyReq )){

        DBGMSG( DBG_THREADM | DBG_ERROR,
                ( "ThreadM.bJobAdded: add failed since DESTROY requested.\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );
        rc = FALSE;

    } else {

        //
        // We either: give it to an idle thread, create a new thread,
        // or leave it in the queue.
        //
        if( _iIdleThreads > 0 ){

            //
            // There are some idle threads--trigger the event and it
            // will be picked up.
            //
            --_iIdleThreads;

            DBGMSG( DBG_THREADM,
                    ( "ThreadM.bJobAdded: Trigger: --iIdle %d, uActive %d\n",
                      _iIdleThreads, _uActiveThreads ));

            //
            // If we set the event, then the worker thread that receives
            // this event should _not_ decrement _iIdleThreads, since
            // we already did this.
            //
            SetEvent( _hTrigger );

        } else if( _uActiveThreads < _uMaxThreads || bRunNow ){

            //
            // No idle threads, but we can create a new one since we
            // haven't reached the limit, or the bRunNow flag is set.
            //

            hThread = gpfSafeCreateThread( NULL,
                                           0,
                                           xdwThreadProc,
                                           this,
                                           0,
                                           &dwThreadId );
            if( hThread ){

                CloseHandle( hThread );

                //
                // We have successfully created a thread; up the
                // count.
                //
                ++_uActiveThreads;

                //
                // We have less active threads than the max; create a new one.
                //
                DBGMSG( DBG_THREADM,
                        ( "ThreadM.bJobAdded: ct: iIdle %d, ++uActive %d\n",
                          _iIdleThreads,
                          _uActiveThreads ));

            } else {

                rc = FALSE;

                DBGMSG( DBG_THREADM | DBG_WARN,
                        ( "ThreadM.bJobAdded: unable to ct %d\n",
                          GetLastError( )));
            }
        } else {

            //
            // No idle threads, and we are already at the max so we
            // can't create new threads.  Dec iIdleThreads anyway
            // (may go negative, but that's ok).
            //
            // iIdleThreads represents the number of threads that
            // are currently not processing jobs.  If the number is
            // negative, this indicates that even if a thread suddenly
            // completes a job and would go idle, there is a queued
            // job that would immediately grab it, so the thread really
            // didn't go into an idle state.
            //
            // The negative number indicates the number of outstanding
            // jobs that are queued (e.g., -5 indicate 5 jobs queued).
            //
            // There is always an increment of iIdleThreads when a
            // job is compeleted.
            //
            --_iIdleThreads;

            //
            // No threads idle, and at max threads.
            //
            DBGMSG( DBG_THREADM,
                    ( "ThreadM.bJobAdded: wait: --iIdle %d, uActive %d\n",
                      _iIdleThreads,
                      _uActiveThreads ));
        }

        //
        // If we succeeded and bRunNow is set, this indicates that
        // we were able to start a special thread, so we need to adjust
        // the maximum number of threads.  When a this special thread
        // job completes, we will decrement it.
        //
        if( bRunNow && rc ){

            ++_uMaxThreads;
            ++_uRunNowThreads;
        }
    }
    return rc;
}

/********************************************************************

    Private routines.

********************************************************************/

TThreadM::
~TThreadM(
    VOID
    )

/*++

Routine Description:

    Destroy the thread manager object.  This is private; to request
    that the thread manager quit, call vDelete().

Arguments:

Return Value:

--*/

{
    SPLASSERT( _State.bBit( kDestroyReq ));

    if( _State.bBit( kPrivateCritSec )){
        SPLASSERT( _pCritSec->bOutside( ));
        delete _pCritSec;
    }

    if( _hTrigger )
        CloseHandle( _hTrigger );

    vThreadMDeleteComplete();
}

VOID
TThreadM::
vThreadMDeleteComplete(
    VOID
    )

/*++

Routine Description:

    Stub routine for objects that don't need deletion
    complete notification.

Arguments:

Return Value:

--*/

{
}

DWORD
TThreadM::
xdwThreadProc(
    LPVOID pVoid
    )

/*++

Routine Description:

    Worker thread routine that calls the client to process the jobs.

Arguments:

    pVoid - pTMStateVar

Return Value:

    Ignored.

--*/

{
    TThreadM* pThreadM = (TThreadM*)pVoid;
    return pThreadM->dwThreadProc();
}

DWORD
TThreadM::
dwThreadProc(
    VOID
    )
{
    BOOL bDestroy = FALSE;

    {
        TCritSecLock CSL( *_pCritSec );

        DBGMSG( DBG_THREADM,
                ( "ThreadM.dwThreadProc: ct: iIdle %d, uActive %d\n",
                  _iIdleThreads,
                  _uActiveThreads));

        PJOB pJob = pThreadMJobNext();

        while( TRUE ){

            for( ; pJob; pJob=pThreadMJobNext( )){

                //
                // If bRunNow count is non-zero, this indicates that we just
                // picked up a RunNow job.  As soon as it completes, we
                // can decrement the count.
                //
                BOOL bRunNowCompleted = _uRunNowThreads > 0;

                {
                    TCritSecUnlock CSU( *_pCritSec );

                    //
                    // Call back to client to process the job.
                    //
                    DBGMSG( DBG_THREADM,
                            ( "ThreadM.dwThreadProc: %x processing\n",
                              (ULONG_PTR)pJob ));

                    //
                    // Call through virtual function to process the
                    // user's job.
                    //
                    vThreadMJobProcess( pJob );

                    DBGMSG( DBG_THREADM,
                            ( "ThreadM.dwThreadProc: %x processing done\n",
                              (ULONG_PTR)pJob ));
                }

                //
                // If a RunNow job has been completed, then decrement both
                // counts.  uMaxThreads was increased by one when the job was
                // accepted, so now it must be lowered.
                //
                if( bRunNowCompleted ){

                    --_uMaxThreads;
                    --_uRunNowThreads;
                }

                ++_iIdleThreads;

                DBGMSG( DBG_THREADM,
                        ( "ThreadM.dwThreadProc: ++iIdle %d, uActive %d\n",
                           _iIdleThreads,
                           _uActiveThreads ));
            }

            DBGMSG( DBG_THREADM,
                    ( "ThreadM.dwThreadProc: Sleep: iIdle %d, uActive %d\n",
                                    _iIdleThreads,
                                    _uActiveThreads ));

            {
                TCritSecUnlock CSU( *_pCritSec );

                //
                // Done, now relax and go idle for a bit.  We don't
                // care whether we timeout or get triggered; in either
                // case we check for another job.
                //
                WaitForSingleObject( _hTrigger, _uIdleLife );
            }

            //
            // We must check here instead of relying on the return value
            // of WaitForSingleObject since someone may see iIdleThreads!=0
            // and set the trigger, but we timeout before it gets set.
            //
            pJob = pThreadMJobNext();

            if( pJob ){

                DBGMSG( DBG_THREADM,
                        ( "ThreadM.dwThreadProc: Woke and found job: iIdle %d, uActive %d\n",
                          _iIdleThreads,
                          _uActiveThreads ));
            } else {

                //
                // No jobs found; break.  Be sure to reset the hTrigger, since
                // there are no waiting jobs, and the main thread might
                // have set it in the following case:
                //
                // MainThread:           WorkerThread:
                //                       Sleeping
                //                       Awoke, not yet in CS.
                // GotJob
                // SetEvent
                // --iIdleThreads
                //                       Enter CS, found job, process it.
                //
                // In this case, the event is set, but there is no thread
                // to pick it up.
                //
                ResetEvent( _hTrigger );
                break;
            }
        }

        //
        // Decrement ActiveThreads.  This was incremented when the thread
        // was successfully created, and should be decremented when the thread
        // is about to exit.
        //
        --_uActiveThreads;

        //
        // The thread enters an idle state right before it goes to sleep.
        //
        // When a job is added, the idle count is decremented by the main
        // thread, so the worker thread doesn't decrement it (avoids sync
        // problems).  If the worker thread timed out and there were no jobs,
        // then we need to decrement the matching initial increment here.
        //
        --_iIdleThreads;

        if( _State.bBit( kDestroyReq ) &&
            !_uActiveThreads           &&
            !_iIdleThreads ){

            //
            // Destroy requested.
            //
            bDestroy = TRUE;
        }

        DBGMSG( DBG_THREADM,
                ( "ThreadM.dwThreadProc: dt: --iIdle %d, --uActive %d\n",
                  _iIdleThreads,
                  _uActiveThreads));
    }

    if( bDestroy ){
        delete this;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\splutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    splutil.cxx

Abstract:

    Common utils.

Author:

    Albert Ting (AlbertT)  29-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG
VOID
LinkListDump(
    PDLINK pdlinkHead,
    DWORD offset,
    LPCSTR pcszType,
    LPCSTR pcszName
    )
{
    PDLINK pdlinkT;

    DbgMsg( " [Dump LL %s::%s (offset %d)]\n",
             pcszType,
             pcszName,
             offset);

    for( pdlinkT = pdlinkHead;
         pdlinkT != pdlinkHead;
         pdlinkT = pdlinkT->FLink ){

        DbgMsg( "   %x\n", (PBYTE)pdlinkT + offset );
    }
}
#endif

MEntry*
MEntry::
pFindEntry(
    PDLINK pdlink,
    LPCTSTR pszName
    )
{
    PDLINK pdlinkT;
    MEntry* pEntry;

    for( pdlinkT = pdlink->FLink;
         pdlinkT != pdlink;
         pdlinkT = pdlinkT->FLink ){

        pEntry = MEntry::Entry_pConvert( pdlinkT );
        if( pEntry->_strName == pszName ){

            return pEntry;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\stack.inl ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    stack.cxx

Abstract:

    Stack template class.

Author:

    Steve Kiraly (SteveKi)  11/06/96

Revision History:

--*/

/********************************************************************

    Stack template class.

********************************************************************/
//
// Note the _stackPtr points to the next available location.
// 

template<class T> 
_INLINE
TStack<T>::
TStack(
    UINT uSize
    ) : _uSize( uSize ),
        _pStack( NULL ),            
        _pStackPtr( NULL )
{
    _pStack = new T[_uSize+1];

    if( _pStack )
    {
        _pStackPtr = _pStack;
    }
}

template<class T> 
_INLINE
TStack<T>::
~TStack(
    VOID
    ) 
{
    delete [] _pStack;
}

template<class T> 
_INLINE
BOOL
TStack<T>::
bValid(
    VOID
    ) const
{
    return _pStack != NULL;
}

template<class T> 
_INLINE
BOOL
TStack<T>::
bPush(
    IN T Object
    )
{
    SPLASSERT( _pStack );

    BOOL bReturn = TRUE;

    if( _pStackPtr >= _pStack + _uSize )
    {
        bReturn = bGrow( _uSize );

        if( !bReturn )
        {
            DBGMSG( DBG_ERROR, ( "TStack::bPush - failed to grow\n" ) );
        }
    }

    if( bReturn )
    {
        *_pStackPtr++ = Object;
        bReturn = TRUE;
    }
    return bReturn;
}

template<class T> 
_INLINE
BOOL  
TStack<T>::
bPop(
    OUT T *pObject
    )
{
    SPLASSERT( _pStack );

    BOOL bReturn;

    if( _pStackPtr <= _pStack )
    {
        bReturn = FALSE;
    }
    else
    {
        *pObject = *--_pStackPtr;
        bReturn = TRUE;
    }
    return bReturn;
}

template<class T> 
_INLINE
UINT 
TStack<T>::
uSize(
    VOID
    ) const
{
    if( _pStackPtr < _pStack || _pStackPtr > _pStack + _uSize )
    {
        SPLASSERT( FALSE );
    }

    return _pStackPtr - _pStack;
}

template<class T> 
_INLINE
BOOL  
TStack<T>::
bEmpty(
    VOID
    ) const
{
    SPLASSERT( _pStack );

    return _pStackPtr <= _pStack;
}

template<class T> 
_INLINE
BOOL
TStack<T>::
bGrow( 
    IN UINT uSize
    )
{
    BOOL bReturn = FALSE;

    //
    // Calculate the new stack size.
    //
    UINT uNewSize = _uSize + uSize;

    //
    // Allocate a new stack.
    //
    T* pNewStack = new T[uNewSize];

    if( pNewStack )
    {
        //
        // Copy the old stack contents to the new stack;
        //
        for( UINT i = 0; i < _uSize; i++ )
        {
            pNewStack[i] = _pStack[i];
        }

        //
        // Set the stack pointer in the new stack
        //
        T *pNewStackPtr = _pStackPtr - _pStack + pNewStack;

        //
        // Release the old stack;
        //
        delete [] _pStack;

        //
        // Set the stack pointer.
        //
        _pStack     = pNewStack;
        _uSize      = uNewSize;
        _pStackPtr  = pNewStackPtr;

        //
        // Indicate the stack has grown.
        //
        bReturn     = TRUE;
    }
    else
    {   
        DBGMSG( DBG_TRACE, ( "TStack::bGrow failed.\n" ) );
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\trace.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    trace.cxx

Abstract:

    Holds logging routines.

Author:

    Albert Ting (AlbertT)  24-May-1996

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG

#include "trace.hxx"

/*
**  Turn off memory tracing. Turning this on keeps all the back traces in
** memory.
#if i386
#define BACKTRACE_ENABLED
#endif
*/

CRITICAL_SECTION gcsBackTrace;

#ifdef TRACE_ENABLED

TBackTraceDB* gpBackTraceDB;

/********************************************************************

    BackTrace DB

********************************************************************/

TBackTraceDB::
TBackTraceDB(
    VOID
    ) : _pTraceHead( NULL )

/*++

Routine Description:

    Initialize the trace database.

    Generally you will have just one database that holds all the
    traces.

Arguments:

Return Value:

--*/

{
    _pMemBlock = new TMemBlock( kBlockSize, TMemBlock::kFlagGlobalNew );
}

TBackTraceDB::
~TBackTraceDB(
    VOID
    )

/*++

Routine Description:

    Destroy the back trace database.

Arguments:

Return Value:

--*/

{
    delete _pMemBlock;
}

BOOL
TBackTraceDB::
bValid(
    VOID
    )
{
    return _pMemBlock && _pMemBlock->bValid();
}



HANDLE
TBackTraceDB::
hStore(
    IN ULONG ulHash,
    IN PVOID pvBackTrace
    )

/*++

Routine Description:

    Store a backtrace into the database.

Arguments:

    ulHash - Hash for this backtrace.

    pvBackTrace - Actual backtrace; must be NULL terminated.

Return Value:

    HANDLE - backtrace handle.

--*/

{
    TTrace *ptRet;
    TTrace **ppTrace;

    //
    // First see if we can find a backtrace.  If we can't, then
    // pTrace will hold the slot where it should be.
    //
    ptRet = ptFind( ulHash, pvBackTrace, &ppTrace );

    if( !ptRet ){

        //
        // Didn't find one; add it.
        //
        ptRet = TTrace::pNew( this, ulHash, pvBackTrace, ppTrace );
    }

    return ptRet;
}

PLONG
TBackTraceDB::
plGetCount(
    HANDLE hData
    )

/*++

Routine Description:

    Get data from a HANDLE retrieved from hStore.  There is one ULONG
    per stack backtrace.

Arguments:

    hData - Returned from hStore.

Return Value:

    PLONG.

--*/

{
    TTrace *ptTrace = static_cast<TTrace*>( hData );
    return &ptTrace->lCount();
}

TBackTraceDB::TTrace*
TBackTraceDB::
ptFind(
    IN     ULONG ulHash,
    IN     PVOID pvBackTrace,
       OUT TTrace ***pppTrace OPTIONAL
    )

/*++

Routine Description:

    Find a backtrace in the database.  If one does not exist,
    then return NULL and a pointer to where it would exist
    in the database.

Arguments:

    ulHash - Hash of the backtrace.

    pvBackTrace - Backtrace to find.

    pppTrace - If not found, this holds the address of where it should
        be stored in the database.  Adding the trace here is sufficient
        to add it.

Return Value:

    TTrace* the actual trace, NULL if not found.

--*/

{
    //
    // Traverse the binary tree until we find the end or the
    // right one.
    //
    TTrace **ppTrace = &_pTraceHead;

    while( *ppTrace ){

        //
        // Check if this one matches ours.
        //
        COMPARE Compare = (*ppTrace)->eCompareHash( ulHash );

        if( Compare == kEqual ){

            //
            // Now do slow compare in case the hash is a collision.
            //
            Compare = (*ppTrace)->eCompareBackTrace( pvBackTrace );

            if( Compare == kEqual ){

                //
                // Break out of while loop and quit.
                //
                break;
            }
        }

        ppTrace = ( Compare == kLess ) ?
            &(*ppTrace)->_pLeft :
            &(*ppTrace)->_pRight;
    }

    if( pppTrace ){
        *pppTrace = ppTrace;
    }
    return *ppTrace;
}


/********************************************************************

    TBackTraceDB::TTrace

********************************************************************/

COMPARE
TBackTraceDB::
TTrace::
eCompareHash(
    ULONG ulHash
    ) const

/*++

Routine Description:

    Quickly compare two trace hashes.

Arguments:

    ulHash - Input hash.

Return Value:

--*/

{
    if( _ulHash < ulHash ){
        return kLess;
    }

    if( _ulHash > ulHash ){
        return kGreater;
    }

    return kEqual;
}

COMPARE
TBackTraceDB::
TTrace::
eCompareBackTrace(
    PVOID pvBackTrace
    ) const

/*++

Routine Description:

    Compare backtrace to one stored in this.

Arguments:

    pvBackTrace - Must be NULL terminated.

Return Value:

    COMAARE: kLess, kEqual, kGreater.

--*/

{
    PVOID *pSrc;
    PVOID *pDest;

    for( pSrc = (PVOID*)this, pDest = (PVOID*)&pvBackTrace;
        *pSrc && *pDest;
        pSrc++, pDest++ ) {

        if ( *pSrc != *pDest ){
            return (ULONG_PTR)*pSrc < (ULONG_PTR)*pDest ?
                kLess :
                kGreater;
        }
    }
    return kEqual;
}

TBackTraceDB::TTrace*
TBackTraceDB::
TTrace::
pNew(
    IN     TBackTraceDB *pBackTraceDB,
    IN     ULONG ulHash,
    IN     PVOID pvBackTrace,
       OUT TTrace ** ppTrace
    )

/*++

Routine Description:

    Constructs a new TTrace and puts it in pBackTraceDB.

    Assumes the trace does _not_ exist already, and ppTrace points
    to the place where it should be stored to ensure the database
    is kept consistent.

Arguments:

    pBackTraceDB - Storage for the new trace.

    ulHash - Hash for the trace.

    pvBackTrace - The actual backtrace.

    ppTrace - Where the trace should be stored in the database.

Return Value:

    TTrace* - New trace, NULL if failed.

--*/

{
    COUNT cCalls;
    PVOID *ppvCalls;

    //
    // Calculate size of backtrace.  Start with cCalls = 1 so that
    // we include 1 extra for the NULL terminator.
    //
    for( ppvCalls = (PVOID*)pvBackTrace, cCalls = 1;
        *ppvCalls;
        ++ppvCalls, ++cCalls )

        ;

    ++cCalls;

    COUNTB cbSize = OFFSETOF( TTrace, apvBackTrace ) +
                    cCalls * sizeof( PVOID );

    TTrace* pTrace = (TTrace*)pBackTraceDB->_pMemBlock->pvAlloc( cbSize );

    if( pTrace ){

        pTrace->_pLeft = NULL;
        pTrace->_pRight = NULL;
        pTrace->_ulHash = ulHash;
        pTrace->_lCount = -1;

        CopyMemory( pTrace->apvBackTrace,
                    (PVOID*)pvBackTrace,
                    cCalls * sizeof( PVOID ));

        //
        // Add it in the right spot into the database.
        //
        *ppTrace = pTrace;
    }

    return pTrace;
}


/********************************************************************

    Back tracing: abstract base class.

********************************************************************/

BOOL VBackTrace::gbInitialized = FALSE;

#endif // TRACE_ENABLED

VBackTrace::
VBackTrace(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : _fOptions1( fOptions1 ), _fOptions2( fOptions2 )
{
}

VBackTrace::
~VBackTrace(
    VOID
    )
{
}

BOOL
VBackTrace::
bInit(
    VOID
    )
{

#ifdef TRACE_ENABLED

    InitializeCriticalSection(&gcsBackTrace);
    gpBackTraceDB = new TBackTraceDB();
    gbInitialized = TRUE;

    return gpBackTraceDB != NULL;

#else

    return TRUE;

#endif

}

VOID
VBackTrace::
vDone(
    VOID
    )
{

#ifdef TRACE_ENABLED

    if( gbInitialized )
    {
        DeleteCriticalSection(&gcsBackTrace);
    }

#endif

}

PLONG
VBackTrace::
plGetCount(
    HANDLE hData
    )
{

#ifdef TRACE_ENABLED

    return gpBackTraceDB->plGetCount( hData );

#else

    return NULL;

#endif

}

#ifndef TRACE_ENABLED


HANDLE
VBackTrace::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )

/*++

Routine Description:

    In the case that tracing is disabled, this function is coded
    to return NULL.

Arguments:

Return Value:

    NULL

--*/

{
    return NULL;
}

#endif // ndef TRACE_ENABLED


#ifdef TRACE_ENABLED

/********************************************************************

    Back tracing to memory.

********************************************************************/

TBackTraceMem::
TBackTraceMem(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : VBackTrace( fOptions1, fOptions2 ), _uNextFree( 0 )
{
    _pLines = new TLine[kMaxCall];
    if( _pLines ){
        ZeroMemory( _pLines, sizeof( TLine[kMaxCall] ));
    }
}

TBackTraceMem::
~TBackTraceMem(
    VOID
    )
{
    UINT i;
    TLine* pLine;

    if( _pLines ){
        for( i=0, pLine = _pLines; i< kMaxCall; i++, pLine++ ){

            if( _fOptions1 & kString ){
                DbgFreeMem( (PVOID)pLine->_Info1 );
            }

            if( _fOptions2 & kString ){
                DbgFreeMem( (PVOID)pLine->_Info2 );
            }
        }
        delete [] _pLines;
    }
}

VOID
TBackTraceMem::
vCaptureLine(
    IN OUT TLine* pLine,
    IN     ULONG_PTR Info1,
    IN     ULONG_PTR Info2,
    IN     ULONG_PTR Info3,
       OUT PVOID apvBackTrace[kMaxDepth+1], OPTIONAL
       OUT PULONG pulHash OPTIONAL
    )

/*++

Routine Description:

    Captures information into a TLine structure; freeing previous
    contents if necessary.

Arguments:

    pLine - Fully initialized pLine structure.  On output, everything
        _except_ _hTrace is filled in.

    ** Both apvBackTrace && pulHash must both be valid if either is valid **

    apvBackTrace - Buffer to receive backtrace.

    pulHash - Buffer to receive ulHash.

Return Value:

--*/

{
    //
    // Free memory if necessary.
    //
    if( _fOptions1 & kString ) {
        DbgFreeMem( (PVOID)pLine->_Info1 );
    }

    if( _fOptions2 & kString ) {
        DbgFreeMem( (PVOID)pLine->_Info2 );
    }

    pLine->_TickCount = GetTickCount();
    pLine->_Info1 = Info1;
    pLine->_Info2 = Info2;
    pLine->_Info3 = Info3;

    pLine->_ThreadId = GetCurrentThreadId();
    pLine->_hTrace = NULL;

#ifdef BACKTRACE_ENABLED

    if( apvBackTrace && pulHash ){

        ULONG ulHash;

        //
        // Capture a backtrace at this spot for debugging.
        //
        UINT uDepth = RtlCaptureStackBackTrace( 2,
                                                kMaxDepth,
                                                apvBackTrace,
                                                pulHash );

        //
        // NULL terminate.
        //
        apvBackTrace[uDepth] = NULL;
    }
#else
    apvBackTrace[0] = NULL;
    *pulHash = 0;
#endif

}

HANDLE
TBackTraceMem::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )
{
    UINT uDepth;
    TLine* pLine;
    ULONG ulHash;
    PVOID apvBackTrace[kMaxDepth+1];

    if( !_pLines ){
        return NULL;
    }

    EnterCriticalSection( &gcsBackTrace );

    pLine = &_pLines[_uNextFree];

    vCaptureLine( pLine, Info1, Info2, Info3, apvBackTrace, &ulHash );
    pLine->_hTrace = gpBackTraceDB->hStore( ulHash, apvBackTrace );

    _uNextFree++;

    if( _uNextFree == kMaxCall )
        _uNextFree = 0;

    LeaveCriticalSection( &gcsBackTrace );

    if( pHash )
    {
        *pHash = ulHash;
    }

    return (PVOID)pLine->_hTrace;
}

/********************************************************************

    Backtracing to File.

********************************************************************/

COUNT TBackTraceFile::gcInstances;

TBackTraceFile::
TBackTraceFile(
    ULONG_PTR fOptions1,
    ULONG_PTR fOptions2
    ) : VBackTrace( fOptions1, fOptions2 )
{
    TCHAR szFile[kMaxPath];

    EnterCriticalSection( &gcsBackTrace );

    wsprintf( szFile,
              TEXT( "spl_%d.%d.log" ),
              GetCurrentProcessId(),
              gcInstances );

    ++gcInstances;

    LeaveCriticalSection( &gcsBackTrace );

    _hFile = CreateFile( szFile,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_COMPRESSED,
                         NULL );

    if( _hFile == INVALID_HANDLE_VALUE ){

        OutputDebugStringA( "SPLLIB: Unable to open file " );
        OutputDebugString( szFile );
        OutputDebugStringA( "\n" );
        return;
    }
}

TBackTraceFile::
~TBackTraceFile(
    VOID
    )
{
    if( _hFile != INVALID_HANDLE_VALUE ){
        CloseHandle( _hFile );
    }
}

HANDLE
TBackTraceFile::
hCapture(
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    PULONG pHash
    )
{
    TLine Line;
    PVOID apvBackTrace[kMaxDepth+1];
    DWORD cbWritten;

    CHAR szLine[kMaxLineStr];
    szLine[0] = 0;

#ifdef BACKTRACE_ENABLED

    ULONG ulHash;

    //
    // Capture a backtrace at this spot for debugging.
    //
    UINT uDepth = RtlCaptureStackBackTrace( 2,
                                            kMaxDepth,
                                            apvBackTrace,
                                            &ulHash );
#endif

    EnterCriticalSection( &gcsBackTrace );

    //
    // Print out strings as appropriate.
    //

    if( _fOptions1 & kString )
    {
        WriteFile( _hFile,
                   (LPCVOID)Info1,
                   lstrlenA( (LPCSTR)Info1 ),
                   &cbWritten,
                   NULL );
    }

    if( _fOptions2 & kString )
    {
        WriteFile( _hFile,
                   (LPCVOID)Info2,
                   lstrlenA( (LPCSTR)Info2 ),
                   &cbWritten,
                   NULL );
    }

    //
    // Print out the hex info.
    //

    wsprintfA( szLine,
               "\n\t%08x: %08x %08x %08x threadid=%x tc=%x < %x >: ",
               this,
               Info1,
               Info2,
               Info3,
               GetCurrentThreadId(),
               GetTickCount(),
               Info1 + Info2 );

    if( _hFile )
    {
        WriteFile( _hFile, szLine, lstrlenA( szLine ), &cbWritten, NULL );
    }

#ifdef BACKTRACE_ENABLED

    //
    // Print out the backtrace.
    //

    UINT i;
    UINT uLineEnd = 1;
    szLine[0] = '\t';

    for( i=0; i < uDepth; ++i )
    {
        uLineEnd += wsprintfA( szLine + uLineEnd, "%08x ", apvBackTrace[i] );
    }

    if( _hFile && i )
    {
        szLine[uLineEnd++] = '\n';
        WriteFile( _hFile, szLine, uLineEnd, &cbWritten, NULL );
    }

#endif

    //
    // Add extra blank line.
    //
    szLine[0] = '\n';
    WriteFile( _hFile, szLine, 1, &cbWritten, NULL );

    LeaveCriticalSection( &gcsBackTrace );

    //
    // Free memory if necessary.
    //
    if( _fOptions1 & kString )
    {
        DbgFreeMem( (PVOID)Info1 );
    }

    if( _fOptions2 & kString )
    {
        DbgFreeMem( (PVOID)Info2 );
    }

#ifdef BACKTRACE_ENABLED

    if( pHash )
    {
        *pHash = ulHash;
    }

#endif

    return NULL;
}

#endif // TRACE_ENABLED

#endif // #ifdef DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\string.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    String.cxx

Abstract:

    Short strings

Author:

    Albert Ting (AlbertT)  9-June-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

//
// Class specific NULL state.
//
TCHAR TString::gszNullState[2] = {0,0};

//
// Default construction.
//
TString::
TString(
    VOID
    ) : _pszString( &TString::gszNullState[kValid] )
{
}

//
// Construction using an existing LPCTSTR string.
//
TString::
TString(
    IN LPCTSTR psz
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( psz );
}

//
// Destruction, ensure we don't free our NULL state.
//
TString::
~TString(
    VOID
    )
{
    vFree( _pszString );
}

//
// Copy constructor.
//
TString::
TString(
    const TString &String
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( String._pszString );
}

//
// Indicates if a string has any usable data.
//
BOOL
TString::
bEmpty(
    VOID
    ) const
{
    return _pszString[0] == 0;
}

//
// Indicates if a string object is valid.
//
BOOL
TString::
bValid(
    VOID
    ) const
{
    return _pszString != &TString::gszNullState[kInValid];
}

//
// Return the length of the string.
//
UINT
TString::
uLen(
    VOID
    ) const
{
    return lstrlen( _pszString );
}

BOOL
TString::
bCat(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe concatenation of the specified string to the string
    object. If the allocation fails, return FALSE and the
    original string is not modified.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    BOOL bStatus = FALSE;

    //
    // If a valid string was passed.
    //
    if( psz ){

        LPTSTR pszTmp = _pszString;

        //
        // Allocate the new buffer consisting of the size of the orginal
        // string plus the sizeof of the new string plus the null terminator.
        //
        _pszString = (LPTSTR)AllocMem(
                                ( lstrlen( pszTmp ) +
                                  lstrlen( psz ) +
                                  1 ) *
                                  sizeof ( pszTmp[0] ) );

        //
        // If memory was not available.
        //
        if( !_pszString ){

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Mark the string object as invalid.
            //
            _pszString = &TString::gszNullState[kInValid];

        } else {

            //
            // Copy the string and concatenate the passed string.
            //
            lstrcpy( _pszString, pszTmp );
            lstrcat( _pszString, psz );

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Indicate success.
            //
            bStatus = TRUE;

        }

    //
    // Skip null pointers, not an error.
    //
    } else {

        bStatus = TRUE;

    }

    return bStatus;
}

BOOL
TString::
bUpdate(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe updating of string.  If the allocation fails, return FALSE
    and leave the string as is.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    //
    // Check if the null pointer is passed.
    //
    if( !psz ){

        //
        // If not pointing to the gszNullState
        //
        vFree( _pszString );

        //
        // Mark the object as valid.
        //
       _pszString = &TString::gszNullState[kValid];

        return TRUE;
    }

    //
    // Create temp pointer and allocate the new string.
    //
    LPTSTR pszTmp = _pszString;
    _pszString = (LPTSTR) AllocMem(( lstrlen(psz)+1 ) * sizeof( psz[0] ));

    //
    // If memory was not available.
    //
    if( !_pszString ){

        //
        // Ensure we free any previous string.
        //
        vFree( pszTmp );

        //
        // Mark the string object as invalid.
        //
        _pszString = &TString::gszNullState[kInValid];

        return FALSE;
    }

    //
    // Copy the string and
    //
    lstrcpy( _pszString, psz );

    //
    // If the old string object was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    vFree( pszTmp );

    return TRUE;
}

BOOL
TString::
bLoadString(
    IN HINSTANCE hInst,
    IN UINT uID
    )

/*++

Routine Description:

    Safe load of a string from a resources file.

Arguments:

    hInst - Instance handle of resource file.
    uId - Resource id to load.

Return Value:

    TRUE = load successful
    FALSE = load failed

--*/

{
    LPTSTR  pszString   = NULL;
    BOOL    bStatus     = FALSE;
    INT     iSize;
    INT     iLen;

    //
    // Continue increasing the buffer until
    // the buffer is big enought to hold the entire string.
    //
    for( iSize = kStrMax; ; iSize += kStrMax ){

        //
        // Allocate string buffer.
        //
        pszString = (LPTSTR)AllocMem( iSize * sizeof( pszString[0] ) );

        if( pszString ){

            iLen = LoadString( hInst, uID, pszString, iSize );

            if( iLen == 0 ) {

                DBGMSG( DBG_ERROR, ( "String.vLoadString: failed to load IDS 0x%x, %d\n",  uID, GetLastError() ));
                FreeMem( pszString );
                break;

            //
            // Since LoadString does not indicate if the string was truncated or it
            // just happened to fit.  When we detect this ambiguous case we will
            // try one more time just to be sure.
            //
            } else if( iSize - iLen <= sizeof( pszString[0] ) ){

                FreeMem( pszString );

            //
            // LoadString was successful release original string buffer
            // and update new buffer pointer.
            //
            } else {

                vFree( _pszString );
                _pszString = pszString;
                bStatus = TRUE;
                break;
            }

        } else {
            DBGMSG( DBG_ERROR, ( "String.vLoadString: unable to allocate memory, %d\n", GetLastError() ));
            break;
        }
    }
    return bStatus;
}

VOID
TString::
vFree(
    IN LPTSTR pszString
    )
/*++

Routine Description:

    Safe free, frees the string memory.  Ensures
    we do not try an free our global memory block.

Arguments:

    pszString pointer to string meory to free.

Return Value:

    Nothing.

--*/

{
    //
    // If this memory was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    if( pszString != &TString::gszNullState[kValid] &&
        pszString != &TString::gszNullState[kInValid] ){

        FreeMem( pszString );
    }
}


BOOL
TString::
bFormat(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
/*++

Routine Description:

    Format the string opbject similar to sprintf.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/

    BOOL bStatus = TRUE;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    bStatus = bvFormat( pszFmt, pArgs );

    va_end( pArgs );

    return bStatus;

}

BOOL
TString::
bvFormat(
    IN LPCTSTR pszFmt,
    IN va_list avlist
    )
/*++

Routine Description:

    Format the string opbject similar to vsprintf.

Arguments:

    pszFmt pointer format string.
    pointer to variable number of arguments similar to vsprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/
{
    BOOL bStatus;

    //
    // Save previous string value.
    //
    LPTSTR pszTemp = _pszString;

    //
    // Format the string.
    //
    _pszString = vsntprintf( pszFmt, avlist );

    //
    // If format failed mark object as invalid and
    // set the return value.
    //
    if( !_pszString )
    {
        _pszString = &TString::gszNullState[kInValid];
        bStatus = FALSE;
    }
    else
    {
        bStatus = TRUE;
    }

    //
    // Release near the end because the format string or arguments
    // may be referencing this string object.
    //
    vFree( pszTemp );

    return bStatus;
}

LPTSTR
TString::
vsntprintf(
    IN LPCTSTR      szFmt,
    IN va_list      pArgs
    )
/*++

Routine Description:

    //
    // Formats a string and returns a heap allocated string with the
    // formated data.  This routine can be used to for extremely
    // long format strings.  Note:  If a valid pointer is returned
    // the callng functions must release the data with a call to delete.
    // Example:
    //
    //  LPCTSTR p = vsntprintf("Test %s", pString );
    //
    //  SetTitle( p );
    //
    //  delete [] p;
    //

Arguments:

    pszString pointer format string.
    pointer to a variable number of arguments.

Return Value:

    Pointer to format string.  NULL if error.

--*/

{
    LPTSTR  pszBuff = NULL;
    INT     iSize   = kStrIncrement;

    for( ; ; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = (LPTSTR)AllocMem( iSize * sizeof(TCHAR) );

        if( !pszBuff )
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        INT iReturn = _vsntprintf( pszBuff, iSize, szFmt, pArgs );

        //
        // If the return value positive and not equal to the buffer size
        // then the format succeeded.  _vsntprintf will not null terminate
        // the string if the resultant string is exactly the lenght of the
        // provided buffer.
        //
        if( iReturn > 0 && iReturn != iSize )
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        if( pszBuff )
        {
            FreeMem( pszBuff );
        }

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if( iSize > kStrMaxFormatSize )
        {
            DBGMSG( DBG_ERROR, ("TString::vsntprintf failed string too long.\n") );
            pszBuff = NULL;
            break;
        }

    }

    return pszBuff;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\state.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    State.cxx

Abstract:

    State abstraction and critical section

Author:

    Albert Ting (AlbertT)  28-May-1994

Revision History:

--*/

#include "spllibp.hxx"
#pragma hdrstop

#if DBG
MCritSec* MRefCom::gpcsCom;
#endif

/********************************************************************

    Ref counting

********************************************************************/

VOID
MRefQuick::
vIncRef(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld + 1 );
#endif

    ++_cRef;
}

LONG
MRefQuick::
cDecRef(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld - 1 );
#endif

    --_cRef;

    if( !_cRef ){

        vRefZeroed();
        return 0;
    }
    return _cRef;
}

VOID
MRefQuick::
vDecRefDelete(
    VOID
    )
{
#if DBG
    LONG cRefOld = _cRef;
    _BackTrace.hCapture( cRefOld, cRefOld );
#endif

    --_cRef;

    if( !_cRef ){
        vRefZeroed();
    }
}

/********************************************************************

    MRefCom: Reference counting using interlocked references.
    This avoids creating a common critical section.

    vDeleteDecRef is the same as vDecRef, but it logs differently.

********************************************************************/

VOID
MRefCom::
vIncRef(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld+1 );
#endif

    InterlockedIncrement( &_cRef );
}

LONG
MRefCom::
cDecRef(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld - 1 );
#endif

    LONG cRefReturn = InterlockedDecrement( &_cRef );

    if( !cRefReturn ){
        vRefZeroed();
    }
    return cRefReturn;
}


VOID
MRefCom::
vDecRefDelete(
    VOID
    )
{
#if DBG
    gpcsCom->vEnter();
    LONG cRefOld = _cRef;
    gpcsCom->vLeave();

    _BackTrace.hCapture( cRefOld, cRefOld );
#endif

    if( !InterlockedDecrement( &_cRef )){
        vRefZeroed();
    }
}

VOID
MRefCom::
vRefZeroed(
    VOID
    )
{
}

/********************************************************************

    State

********************************************************************/

#if DBG
TState::
TState(
    VOID
    ) : _StateVar(0)
{
}

TState::
TState(
    STATEVAR StateVar
    ) : _StateVar(StateVar)
{
}

TState::
~TState(
    VOID
    )
{
}

STATEVAR
TState::
operator|=(
    STATEVAR StateVarOn
    )
{
    SPLASSERT( bValidateSet( StateVarOn ));

    _BackTrace.hCapture( _StateVar, StateVarOn );

    _StateVar |= StateVarOn;
    return _StateVar;
}

STATEVAR
TState::
operator&=(
    STATEVAR StateVarMask
    )
{
    SPLASSERT( bValidateMask( StateVarMask ));

    _BackTrace.hCapture( _StateVar, StateVarMask );

    _StateVar &= StateVarMask;
    return _StateVar;
}
#endif


/********************************************************************

    Critical section implementation

    Logging:


    CS initialized: 00000000 00000000 00000000

    CS acquired:    1eeeeeee bbbbbbbb tttttttt
    e   New entry count.
    b   TickCount thread was blocked before acquiring CS.
    t   Total tickcount all threads have blocked before acquiring CS

    CS released:    0eeeeeee iiiiiiii tttttttt
    e   New entry count.
    i   Time spent inside the CS, from _first_ acquisition.
    t   Total tickcount all threads inside CS.

********************************************************************/


#if DBG

MCritSec::
MCritSec(
    VOID
    ) : _dwThreadOwner( 0 ), _dwEntryCount( 0 ),
        _dwTickCountBlockedTotal( 0 ), _dwTickCountInsideTotal( 0 ),
        _dwEntryCountTotal( 0 )
{
    InitializeCriticalSection( &_CritSec );
    _BackTrace.hCapture( 0, 0, 0 );
}

MCritSec::
~MCritSec(
    VOID
    )
{
    DeleteCriticalSection( &_CritSec );
}

VOID
MCritSec::
vEnter(
    VOID
    )
{
    DWORD dwTickCountBefore = GetTickCount();

    EnterCriticalSection( &_CritSec );

    ++_dwEntryCountTotal;

    DWORD dwTickCountBlocked = 0;

    //
    // Re-entrant case: only start the TickCountEntered counter
    // if this is the first time we've entered the cs.
    //
    if( _dwEntryCount == 0 ){

        //
        // Check how long it took us to enter the critical section.
        //
        _dwTickCountEntered = GetTickCount();
        dwTickCountBlocked = _dwTickCountEntered - dwTickCountBefore;

        //
        // Update the amount of time this thread blocked on this cs.
        //
        _dwTickCountBlockedTotal += dwTickCountBlocked;
    }

    //
    // We have entered the critical section; update the count
    // and the thread owner.
    //
    ++_dwEntryCount;
    _dwThreadOwner = GetCurrentThreadId();

    _BackTrace.hCapture( 0x10000000 | _dwEntryCount,
                          dwTickCountBlocked,
                          _dwTickCountBlockedTotal );

}

VOID
MCritSec::
vLeave(
    VOID
    )
{
    SPLASSERT( bInside( ));

    DWORD dwTickCountInside = GetTickCount() - _dwTickCountEntered;

    --_dwEntryCount;

    //
    // Verify that we don't leave a CritSecHardLock.
    //
    TIter Iter;
    TCritSecHardLock *pCritSecHardLock;

    for( CritSecHardLock_vIterInit( Iter ), Iter.vNext();
         Iter.bValid();
         Iter.vNext( )){

        pCritSecHardLock = CritSecHardLock_pConvert( Iter );

        //
        // If you hit this assert, then you have created a hard
        // lock, but someone is trying to leave it.  See header file
        // for more info (state.hxx).
        //
        if( _dwEntryCount < pCritSecHardLock->_dwEntryCountMarker ){
            DBGMSG( DBG_ERROR, ( "CritSec.vLeave: Leaving a hard lock.\n" ));
        }
    }

    //
    // If this leave frees the critical section, then capture
    // the total time the section was held (from the very first enter).
    //
    if( !_dwEntryCount ){
        _dwTickCountInsideTotal += dwTickCountInside;

        //
        // Since we are leaving the critical section for the last
        // time, the CS is now unowned.  We set the thread owner to 0.
        //
        _dwThreadOwner = 0;
    }

    //
    // Note: dwTickCountInsideTotal is based on _first_ entrance
    // of critical section, not the most recent.
    //
    _BackTrace.hCapture( ~0x10000000 & _dwEntryCount,
                          dwTickCountInside,
                          _dwTickCountInsideTotal );

    LeaveCriticalSection( &_CritSec );
}

BOOL
MCritSec::
bInside(
    VOID
    ) const
{
    if( !_dwEntryCount || GetCurrentThreadId() != _dwThreadOwner ){

        DBGMSG( DBG_ERROR, ( "CritSec: Not inside 0x%x!\n", this ));
        return FALSE;
    }
    return TRUE;
}


BOOL
MCritSec::
bOutside(
    VOID
    ) const
{
    //
    // We are outside if dwThreadOwner is not our thread id.
    //
    DWORD dwThreadOwner = (DWORD)InterlockedCompareExchange(
                                     (PLONG)&_dwThreadOwner,
                                     0,
                                     0 );

    if( dwThreadOwner == GetCurrentThreadId( )){

        DBGMSG( DBG_ERROR, ( "CritSec: Not outside 0x%x!\n",this ));
        return FALSE;
    }
    return TRUE;
}


/********************************************************************

    TCritSecHardLock

********************************************************************/

TCritSecHardLock::
TCritSecHardLock(
    MCritSec& CritSec
    ) : _CritSec( CritSec )
{
    _CritSec.vEnter();

    //
    // Add ourselves to the linked list and remember what the entry
    // count is.  Everytime we leave the critical section, we'll look
    // at all the items in the list and see if the current entry count
    // is < all hard locks.
    //
    _CritSec.CritSecHardLock_vAdd( this );
    _dwEntryCountMarker = _CritSec._dwEntryCount;
}


TCritSecHardLock::
~TCritSecHardLock(
    VOID
    )
{
    CritSecHardLock_vDelinkSelf();
    _CritSec.vLeave();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\webpnp.cxx ===
/*****************************************************************************\
* MODULE: webpnp.cxx
*
* This module contains routines which read/write printer-configuration
* data to a BIN-File.  The file format is depicted below.  The file begins
* with a header indicating the number of (pData) items.  THIS DOES NOT
* include the DEVMODEW in its item-count.  So, at a minimum, this code
* could result in the setting of a DEVMODE, or just setting the printer
* data, depending upon the header information.
*
*
*   DEVBIN_HEAD          DEVBIN_INFO         ...->      DEVBIN_INFO
*  --------------------------------------------------------------------------
* |            |           cbSize             |           cbSize             |
* |  bDevMode  |------------------------------|------------------------------|
* |  cItems    |      |     |      |  cbData  |      |     |      |  cbData  |
* |            | Type | Key | Name |----------| Type | Key | Name |----------|
* |            |      |     |      | DevModeW |      |     |      | pData 0  |
*  --------------------------------------------------------------------------
*
* The usage scenario is for webWritePrinterInfo() to query a printer and
* write out the DEVMODEW and Printer-Configuration data to this file-format.
* On a call to webReadPrinterInfo(), a particular printer is opened, and
* the BIN-File is read.  The printer is then reset to the information
* contained in the BIN-File.  This is accomplished by doing a GetPrinter(2)
* on the opened-printer, then re-configuring the PRINT_INFO_2 information
* and reseting the the printer through SetPrinter(2).
*
* Likewise, if there exists printer-data, the information is set to the
* opened printer through SetPrinterData() calls.
*
*
* NOTE: The DEVMODE is always the FIRST entry in this file following the
*       DEVBIN_HEAD.
*
* NOTE: The (cItems) only refers to the (Printer-Data) fields.  It does
*       not count the DEVMODEW.
*
* NOTE: The processing for ICM-Profile enumeration is performed in unicode
*       strings and only converted to TCHAR type strings on callbacks to
*       the caller of the enum API.  This is desirable to maintain a level
*       of consistency when dealing with text.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   25-Feb-1997 <chriswil> created.
*
\*****************************************************************************/

#include "spllibp.hxx"
#include <winspool.h>
#include <winsplp.h>
#include <icm.h>
#include <wininet.h>

/***************************************\
* Static Strings.
\***************************************/
static CONST WCHAR s_wszCopyFiles[] = L"CopyFiles";
static CONST WCHAR s_wszDir[]       = L"Directory";
static CONST WCHAR s_wszFil[]       = L"Files";
static CONST WCHAR s_wszMod[]       = L"Module";
static CONST CHAR  s_szGCFP[]       = "GenerateCopyFilePaths";


/*****************************************************************************\
* web_GAlloc (Local Routine)
*
* Allocates a block of memory.
*
\*****************************************************************************/
inline LPVOID web_GAlloc(
    DWORD cbSize)
{
    return new BYTE[cbSize];
}


/*****************************************************************************\
* web_GFree (Local Routine)
*
* Deletes the memory-block allocated via web_GAlloc().
*
\*****************************************************************************/
inline BOOL web_GFree(
    LPVOID lpMem)
{
    delete [] lpMem;

    return TRUE;
}


/*****************************************************************************\
* web_AlignSize (Local Routine)
*
* Returns size (bytes) of the memory-block.  This returns a 64 bit aligned
* value.
*
\*****************************************************************************/
inline DWORD web_AlignSize(
    DWORD cbSize)
{
    return ((cbSize & 7) ? cbSize + (8 - (cbSize & 7)) : cbSize);
}


/*****************************************************************************\
* web_StrSizeW (Local Routine)
*
* Returns size (bytes) of the string.  This includes the NULL terminator.
*
\*****************************************************************************/
inline DWORD web_StrSizeW(
    LPCWSTR lpszStr)
{
    return ((lstrlenW(lpszStr) + 1) * sizeof(WCHAR));
}


/*****************************************************************************\
* web_NextStrW (Local Routine)
*
* Returns pointer to the next-item in a string array.
*
\*****************************************************************************/
inline LPWSTR web_NextStrW(
    LPCWSTR lpszStr)
{
    return ((LPWSTR)lpszStr + (lstrlenW(lpszStr) + 1));
}


/*****************************************************************************\
* web_NextItem (Local Routine)
*
* Returns pointer to the next-item in the BIN-File.
*
\*****************************************************************************/
inline LPDEVBIN_INFO web_NextItem(
    LPDEVBIN_INFO lpInfo)
{
    return (LPDEVBIN_INFO)(((LPBYTE)lpInfo) + lpInfo->cbSize);
}


/*****************************************************************************\
* web_MBtoWC (Local Routine)
*
* Converts a MultiByte string to a Unicode string.
*
\*****************************************************************************/
inline DWORD web_MBtoWC(
    LPWSTR lpszWC,
    LPCSTR lpszMB,
    DWORD  cbSize)
{
    cbSize = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszMB,
                                        -1,
                                        lpszWC,
                                        (int)(cbSize / sizeof(WCHAR)));

    return (cbSize * sizeof(WCHAR));
}


/*****************************************************************************\
* web_WCtoTC (Local Routine)
*
* Converts a Unicode string to a string appropriate for the built library.
* The size must account for the NULL terminator when specifying size.
*
\*****************************************************************************/
inline LPTSTR web_WCtoTC(
    LPCWSTR lpwszWC,
    DWORD   cchWC)
{
    LPTSTR lpszTC;
    DWORD  cbSize;


    cbSize = cchWC * sizeof(TCHAR);

    if (lpszTC = (LPTSTR)web_GAlloc(cbSize)) {

#ifdef UNICODE

        // Use CopyMemory, not lstrcpyn.  This allows strings
        // with nulls in them...(e.g. MULTI_SZ regsitry values
        //
        CopyMemory(lpszTC, lpwszWC, cbSize);

#else

        WideCharToMultiByte(CP_ACP,
                            WC_DEFAULTCHAR,
                            lpwszWC,
                            cchWC,
                            lpszTC,
                            cchWC,
                            NULL,
                            NULL);
#endif

    }

    return lpszTC;
}


/*****************************************************************************\
* web_OpenDirectoryW (Local Routine)
*
* Open a handle to a directory.
*
\*****************************************************************************/
inline HANDLE web_OpenDirectoryW(
    LPCWSTR lpwszDir)
{
    return CreateFileW(lpwszDir,
                      0,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                      NULL);
}


/*****************************************************************************\
* web_OpenFileRead (Local Routine)
*
* Open a file for reading.
*
\*****************************************************************************/
inline HANDLE web_OpenFileRead(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/*****************************************************************************\
* web_OpenFileWrite (Local Routine)
*
* Open a file for writing.
*
\*****************************************************************************/
inline HANDLE web_OpenFileWrite(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/*****************************************************************************\
* web_LockMap (Local Routine)
*
* Locks the map-view.
*
\*****************************************************************************/
inline LPVOID web_LockMap(
    HANDLE hMap)
{
    LPWEB_FILEMAP lpMap;
    LPVOID        lpPtr = NULL;

    if (lpMap = (LPWEB_FILEMAP)hMap)
        lpPtr = MapViewOfFile(lpMap->hMap, FILE_MAP_READ, 0, 0, 0);

    return lpPtr;
}


/*****************************************************************************\
* web_UnlockMap (Local Routine)
*
* Unlocks the map-view.
*
\*****************************************************************************/
inline BOOL web_UnlockMap(
    LPVOID lpPtr)
{
    return UnmapViewOfFile(lpPtr);
}


/*****************************************************************************\
* web_OpenMap (Local Routine)
*
* Opens a file-mapping object.
*
\*****************************************************************************/
HANDLE web_OpenMap(
    LPCTSTR lpszFile)
{
    LPWEB_FILEMAP lpMap;
    DWORD         cbSize;


    if (lpMap = (LPWEB_FILEMAP)web_GAlloc(sizeof(WEB_FILEMAP))) {

        lpMap->hFile = web_OpenFileRead(lpszFile);

        if (lpMap->hFile && (lpMap->hFile != INVALID_HANDLE_VALUE)) {

            if (cbSize = GetFileSize(lpMap->hFile, NULL)) {

                lpMap->hMap = CreateFileMapping(lpMap->hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                cbSize,
                                                NULL);

                if (lpMap->hMap)
                    return (HANDLE)lpMap;
            }

            CloseHandle(lpMap->hFile);
        }

        web_GFree(lpMap);
    }

    return NULL;
}


/*****************************************************************************\
* web_CloseMap (Local Routine)
*
* Closes file-mapping object.
*
\*****************************************************************************/
BOOL web_CloseMap(
    HANDLE hMap)
{
    LPWEB_FILEMAP lpMap;
    BOOL          bRet = FALSE;


    if (lpMap = (LPWEB_FILEMAP)hMap) {

        CloseHandle(lpMap->hMap);
        CloseHandle(lpMap->hFile);

        bRet = web_GFree(lpMap);
    }

    return bRet;
}


/*****************************************************************************\
* web_GAllocStrW (Local Routine)
*
* Allocates a unicode string buffer.
*
\*****************************************************************************/
LPWSTR web_GAllocStrW(
    LPCWSTR lpszStr)
{
    LPWSTR lpszMem;
    DWORD  cbSize;


    if (lpszStr == NULL)
        return NULL;

    cbSize = web_StrSizeW(lpszStr);

    if (lpszMem = (LPWSTR)web_GAlloc(cbSize))
        CopyMemory(lpszMem, lpszStr, cbSize);

    return lpszMem;
}


/*****************************************************************************\
* web_LoadModuleW
*
* Loads the module by first looking in the path.  If this fails it attempts
* to load from the driver-directory.
*
\*****************************************************************************/
HMODULE web_LoadModuleW(
    LPCWSTR lpwszMod)
{
    HMODULE hLib;
    WCHAR   wszPath[MAX_PATH];

    if ((hLib = LoadLibraryW(lpwszMod)) == NULL) {

#ifdef NOT_IMPLEMENTED

// 22-Oct-1997 : ChrisWil WORK-ITEM
//
// Need to build a alternate path to the driver-directory if the item
// is not in the system32 dir.
//
//      hLib = LoadLibraryExW(wszPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

#endif

    }

    return hLib;
}


/*****************************************************************************\
* web_FindRCharW
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPWSTR web_FindRCharW(
    LPWSTR lpszStr,
    WCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlenW(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* web_GetDrvDirW
*
* Returns: LPWSTR - the printer driver dir, minus the architecture subdir.
* Example:  Returns something like "%WINDIR%\SYSTEM32\SPOOL\DRIVERS"
*
\*****************************************************************************/
LPWSTR web_GetDrvDirW(VOID)
{
    LPWSTR lpwszDrvDir;
    LPWSTR lpwszFind;
    DWORD  cbSize;


    // Call once to get size of buffer needed.
    //
    cbSize = 0;
    GetPrinterDriverDirectoryW(NULL, NULL, 1, NULL, 0, &cbSize);


    // Alloc a buffer.
    //
    if (cbSize && (lpwszDrvDir = (LPWSTR)web_GAlloc(cbSize)) ) {

        // Get the driver directory.
        //
        if (GetPrinterDriverDirectoryW(NULL,
                                       NULL,
                                       1,
                                       (LPBYTE)lpwszDrvDir,
                                       cbSize,
                                       &cbSize)) {


            // Find the parent-directory of the driver-path.
            //
            if (lpwszFind = web_FindRCharW(lpwszDrvDir, L'\\')) {

                *lpwszFind = L'\0';

                return lpwszDrvDir;
            }
        }

        // Free memory if we fail.
        //
        web_GFree(lpwszDrvDir);
    }

    return NULL;
}


/*****************************************************************************\
* web_BuildNameW
*
* Takes path, name, extension strings and builds a fully-qualified
* string representing the file.  This can also be used to build other
* names.
*
\*****************************************************************************/
LPWSTR web_BuildNameW(
    LPCWSTR lpwszPath,
    LPCWSTR lpwszName,
    LPCWSTR lpwszExt)
{
    DWORD  cch;
    LPWSTR lpwszFull;


    // Calculate the size necessary to hold the full-path filename.
    //
    cch  = lstrlenW(L"\\");
    cch += (lpwszPath ? lstrlenW(lpwszPath) : 0);
    cch += (lpwszName ? lstrlenW(lpwszName) : 0);
    cch += (lpwszExt  ? lstrlenW(lpwszExt)  : 0);


    if (lpwszFull = (LPWSTR)web_GAlloc(((cch + 1) * sizeof(WCHAR)))) {

        if (lpwszPath) {

            if (lpwszExt)
                cch = wsprintfW(lpwszFull, L"%s\\%s%s", lpwszPath, lpwszName, lpwszExt);
            else
                cch = wsprintfW(lpwszFull, L"%s\\%s", lpwszPath, lpwszName);

        } else {

            if (lpwszExt)
                cch = wsprintfW(lpwszFull, L"%s%s", lpwszName, lpwszExt);
            else
                cch = wsprintfW(lpwszFull, L"%s", lpwszName);
        }
    }

    return lpwszFull;
}


/*****************************************************************************\
* web_GetCurDirW
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPWSTR web_GetCurDirW(VOID)
{
    DWORD  cbSize;
    LPWSTR lpwszDir = NULL;


    cbSize = GetCurrentDirectoryW(0, NULL);

    if (cbSize && (lpwszDir = (LPWSTR)web_GAlloc((cbSize * sizeof(WCHAR)))))
        GetCurrentDirectoryW(cbSize, lpwszDir);

    return lpwszDir;
}


/*****************************************************************************\
* web_MakeFullKeyW (Local Routine)
*
* Creates a full registry-key from the key/sub-key strings.
*
\*****************************************************************************/
LPWSTR web_MakeFullKeyW(
    LPCWSTR lpszKey,
    LPCWSTR lpszSKey)
{
    DWORD  cbSize;
    LPWSTR lpszFKey = NULL;


    if (lpszKey && lpszSKey) {

        cbSize = web_StrSizeW(lpszKey) + web_StrSizeW(lpszSKey) + sizeof(WCHAR);

        if (lpszFKey = (LPWSTR)web_GAlloc(cbSize)) {

            if (*lpszKey)
                wsprintfW(lpszFKey, L"%ws\\%ws", lpszKey, lpszSKey);
            else
                wsprintfW(lpszFKey, L"%ws", lpszSKey);
        }
    }

    return lpszFKey;
}


/*****************************************************************************\
* web_KeyExistsW (Local Routine)
*
* Checks to see if the printer-key exists.
*
\*****************************************************************************/
BOOL web_KeyExistsW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    DWORD cbSize;
    DWORD dwRet;


    cbSize = 0;
    dwRet = EnumPrinterKeyW(hPrinter, lpszKey, NULL, 0, &cbSize);

    return (cbSize && (dwRet == ERROR_MORE_DATA));
}


/*****************************************************************************\
* web_EnumPrinterSubKeysW (Local Routine)
*
* Returns an array of printer-keys for the specified key.
*
\*****************************************************************************/
LPWSTR web_EnumPrinterSubKeysW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    DWORD  cbSize;
    DWORD  dwRet;
    LPWSTR aszSKeys;


    // Determine the size necessary for enumerating all the
    // sub-keys for this key.
    //
    cbSize = 0;
    dwRet  = EnumPrinterKeyW(hPrinter, lpszKey, NULL, 0, &cbSize);


    // If OK, then proceed to the enumeration.
    //
    if (cbSize && (dwRet == ERROR_MORE_DATA)) {

        // Allocate the space for retrieving the keys.
        //
        if (aszSKeys = (LPWSTR)web_GAlloc(cbSize)) {

            // Enumerate the sub-keys for this level in (lpszKey).
            //
            dwRet = EnumPrinterKeyW(hPrinter, lpszKey, aszSKeys, cbSize, &cbSize);

            if (dwRet == ERROR_SUCCESS)
                return aszSKeys;

            web_GFree(aszSKeys);
        }
    }

    return NULL;
}


/*****************************************************************************\
* web_EnumPrinterDataW (Local Routine)
*
* Returns an array of printer-data-values for the specified key.
*
\*****************************************************************************/
LPPRINTER_ENUM_VALUES web_EnumPrinterDataW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPDWORD lpcItems)
{
    DWORD                 cbSize;
    DWORD                 dwRet;
    LPPRINTER_ENUM_VALUES apevData;


    // Set the enumerated items to zero.
    //
    *lpcItems = 0;


    // Determine the size necessary to store the enumerated data.
    //
    cbSize = 0;
    dwRet  = EnumPrinterDataExW(hPrinter, lpszKey, NULL, 0, &cbSize, lpcItems);


    // If OK, then proceed to enumerate and write the values to the
    // BIN-File.
    //
    if (cbSize && (dwRet == ERROR_MORE_DATA)) {

        if (apevData = (LPPRINTER_ENUM_VALUES)web_GAlloc(cbSize)) {

            // Enumerate all values for the specified key.  This
            // returns an array of value-structs.
            //
            dwRet = EnumPrinterDataExW(hPrinter,
                                       lpszKey,
                                       (LPBYTE)apevData,
                                       cbSize,
                                       &cbSize,
                                       lpcItems);

            if (dwRet == ERROR_SUCCESS)
                return apevData;

            web_GFree(apevData);
        }
    }

    return NULL;
}


/*****************************************************************************\
* web_GetPrtNameW
*
* Returns a Wide-Char string representing the printer-name.
*
\*****************************************************************************/
LPWSTR web_GetPrtNameW(
    HANDLE hPrinter)
{
    DWORD             cbSize;
    DWORD             cbNeed;
    LPPRINTER_INFO_2W lppi;
    LPWSTR            lpszPrtName = NULL;


    // Get the necessary size for the printer-info-struct.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);


    // Allocate storage for holding the print-info structure.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize))) {

        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {

            lpszPrtName = web_GAllocStrW(lppi->pPrinterName);
        }

        web_GFree(lppi);
    }

    return lpszPrtName;
}


/*****************************************************************************\
* web_GetPrtDataW (Local Routine)
*
* Returns data for the specified key.
*
\*****************************************************************************/
LPBYTE web_GetPrtDataW(
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPCWSTR lpszVal)
{
    DWORD  dwType;
    DWORD  cbSize;
    DWORD  dwRet;
    LPBYTE lpData;


    cbSize = 0;
    GetPrinterDataExW(hPrinter, lpszKey, lpszVal, &dwType, NULL, 0, &cbSize);

    if (cbSize && (lpData = (LPBYTE)web_GAlloc(cbSize))) {

        dwRet = GetPrinterDataExW(hPrinter,
                                  lpszKey,
                                  lpszVal,
                                  &dwType,
                                  lpData,
                                  cbSize,
                                  &cbSize);

        if (dwRet == ERROR_SUCCESS)
            return lpData;

        web_GFree(lpData);
    }

    return NULL;
}


/*****************************************************************************\
* web_CreateDirW (Local Routine)
*
* Creates the specified directory, if it doesn't exist.
*
\*****************************************************************************/
BOOL web_CreateDirW(
    LPCWSTR lpwszDir)
{
    HANDLE hDir;
    BOOL   bRet = FALSE;


    hDir = web_OpenDirectoryW(lpwszDir);

    if (hDir && (hDir != INVALID_HANDLE_VALUE)) {

        CloseHandle(hDir);

        bRet = TRUE;

    } else {

        bRet = CreateDirectoryW(lpwszDir, NULL);
    }

    return bRet;
}


/*****************************************************************************\
* web_GetICMDirW (Local Routine)
*
* Loads the ICM-Module and returns the target color-directory.  If the
* module isn't loaded then return NULL indicating there is no color
* modules to load.
*
\*****************************************************************************/
LPWSTR web_GetICMDirW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    HMODULE                hLib;
    LPWSTR                 lpwszMod;
    WEBGENCOPYFILEPATHPROC pfn;
    SPLCLIENT_INFO_1       sci;
    LPWSTR                 lpwszSrc;
    LPWSTR                 lpwszDst;
    LPWSTR                 lpwszDrv;
    LPWSTR                 lpwszPrtName;
    DWORD                  cbSrc;
    DWORD                  cbDst;
    DWORD                  dwRet;
    LPWSTR                 lpwszRet = NULL;



    // Load associated module.  (e.g. color module)
    //
    if (lpwszMod = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszMod)) {

        if (hLib = web_LoadModuleW(lpwszMod)) {

            // Call into module to normalize the source/target
            // paths.
            //
            if (pfn = (WEBGENCOPYFILEPATHPROC)GetProcAddress(hLib, s_szGCFP)) {

                if (lpwszPrtName = web_GetPrtNameW(hPrinter)) {

                    if (lpwszDrv = web_GetDrvDirW()) {

                        cbSrc = (MAX_PATH + INTERNET_MAX_HOST_NAME_LENGTH + 1) * sizeof(WCHAR);
                        cbDst = (MAX_PATH + 1) * sizeof(WCHAR);

                        if (lpwszSrc = (LPWSTR)web_GAlloc(cbSrc)) {

                            if (lpwszDst = (LPWSTR)web_GAlloc(cbDst)) {

                                sci.dwSize         = sizeof(SPLCLIENT_INFO_1);
                                sci.pMachineName   = NULL;
                                sci.pUserName      = NULL;
                                sci.dwBuildNum     = 0;
                                sci.dwMajorVersion = webGetOSMajorVer(dwCliInfo);
                                sci.dwMinorVersion = webGetOSMinorVer(dwCliInfo);

                                wsprintfW(lpwszSrc, L"%s\\%s", lpwszDrv, lpwszDir);
                                lstrcpyW(lpwszDst, lpwszDir);

                                dwRet = (*pfn)(lpwszPrtName,
                                               lpwszDir,
                                               (LPBYTE)&sci,
                                               1,
                                               lpwszSrc,
                                               &cbSrc,
                                               lpwszDst,
                                               &cbDst,
                                               COPYFILE_FLAG_SERVER_SPOOLER);

                                if (dwRet == ERROR_SUCCESS) {

                                    lpwszRet = web_GAllocStrW(lpwszDst);
                                }

                                web_GFree(lpwszDst);
                            }

                            web_GFree(lpwszSrc);
                        }

                        web_GFree(lpwszDrv);
                    }

                    web_GFree(lpwszPrtName);
                }
            }

            FreeLibrary(hLib);
        }

        web_GFree(lpwszMod);
    }

    return lpwszRet;
}


/*****************************************************************************\
* web_BuildCopyDirW (Local Routine)
*
* This routine builds the src or dst directory for the CopyFiles. It does the
* following things:
*
* 1) loads optional module (if exists) and calls into it to adjust pathnames
* 2) builds fully-qualified CopyFiles directory
* 3) return the directory name
*
* Upon return this will represent the true path to the ICM profiles for the
* specified key.
*
\*****************************************************************************/
LPWSTR web_BuildCopyDirW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey)
{
    LPWSTR lpwszDir;
    LPWSTR lpwszDrvDir;
    LPWSTR lpwszICM;
    LPWSTR lpwszRet = NULL;


    // Return the directory-value for the specified ICM key.
    //
    if (lpwszDir = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszDir)) {

        // Return the printer-driver-directory-root.
        //
        if (lpwszDrvDir = web_GetDrvDirW()) {

            // If called from the server, then call into the color-module
            // to get the target-directory.  Otherwise, just return the
            // driver directory.
            //
            lpwszICM = web_GetICMDirW(hPrinter, dwCliInfo, lpwszDir, lpwszKey);


            // If the module loaded and return a valid target-directory, then
            // we can return this as our path to the ICM profiles.
            //
            if (lpwszICM != NULL) {
                lpwszRet = web_BuildNameW( lpwszDrvDir, lpwszICM, NULL);
                web_GFree(lpwszICM);  // Free up the memory allocated in web_GetICMDirW
            }


            web_GFree(lpwszDrvDir);
        }

        web_GFree(lpwszDir);
    }

    return lpwszRet;
}


/*****************************************************************************\
* web_CopyFilesW (Local Routine)
*
* This routine copies the point & print "CopyFiles" for the given key.
* It copies files from the web point & print setup-source to the directory
* specified by the "Directory" value under given key.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_CopyFilesW(
    HANDLE  hPrinter,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    LPWSTR awszFiles;
    LPWSTR lpwszFile;
    LPWSTR lpwszCurDir;
    LPWSTR lpwszSrcFile;
    LPWSTR lpwszDstFile;
    LPWSTR lpwszPrtName;
    BOOL   bRet = FALSE;


    // Get the files under the specified ICM key.
    //
    if (awszFiles = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszFil)) {

        // Get our current-directory.
        //
        if (lpwszCurDir = web_GetCurDirW()) {

            if (lpwszPrtName = web_GetPrtNameW(hPrinter)) {

                // For each file in the list, we will need to build our source
                // and destination directories to copy our ICM profiles.
                //
                for (bRet = TRUE, lpwszFile = awszFiles; bRet && *lpwszFile; ) {

                    bRet = FALSE;

                    if (lpwszSrcFile = web_BuildNameW(lpwszCurDir, lpwszFile, NULL)) {

                        if (lpwszDstFile = web_BuildNameW(lpwszDir, lpwszFile, NULL)) {

                            // Copy the ICM profile to the target directory.
                            //
                            bRet = CopyFileW(lpwszSrcFile, lpwszDstFile, FALSE);

#ifdef NOT_IMPLEMENTED

// 22-Oct-1997 : ChrisWil WORK-ITEM
//
// This probably isn't necessary since the addprinter-wizard involks
// print-setup.
//
//                          if (bRet) {
//
//                              bRet = AssociateColorProfileWithDeviceW(NULL,
//                                                                      lpwszDstFile,
//                                                                      lpwszPrtName);
//                          }

#endif

                            web_GFree(lpwszDstFile);
                        }

                        web_GFree(lpwszSrcFile);
                    }

                    lpwszFile = web_NextStrW(lpwszFile);
                }

                web_GFree(lpwszPrtName);
            }

            web_GFree(lpwszCurDir);
        }

        web_GFree(awszFiles);
    }

#ifdef NOT_IMPLEMENTED

// 05-May-1996 : ChrisWil INVESTIGATE-ITEM
//
// Notify with event here!!!
//

#endif

    return bRet;
}


/*****************************************************************************\
* web_TraverseCopyFilesW (Local Routine)
*
* This routine recursively traverses the printer-registry-settings for
* the CopyFiles keys.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_TraverseCopyFilesW(
    HANDLE  hPrinter,
    LPCWSTR lpwszDir,
    LPCWSTR lpwszKey)
{
    LPWSTR awszSKeys;
    LPWSTR lpwszSKey;
    LPWSTR lpwszFKey;
    LPWSTR lpwszFDir;
    DWORD  dwType;
    DWORD  dwCliInfo;
    BOOL   bRet = FALSE;


    // Get the array of keys under the specified key in the registry.
    //
    if (awszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpwszKey)) {

        // For each sub-key in the array, we need to build the path of
        // where we'll place the ICM files.
        //
        for (bRet = TRUE, lpwszSKey = awszSKeys; *lpwszSKey && bRet; ) {

            bRet = FALSE;

            // The enum-routine returns a relative path, so we must build
            // a fully-qualified registry-path.
            //
            if (lpwszFKey = web_MakeFullKeyW(lpwszKey, lpwszSKey)) {

                dwCliInfo = webCreateOSInfo();

                if (lpwszFDir = web_BuildCopyDirW(hPrinter, dwCliInfo, lpwszFKey)) {

                    // Create the ICM directory if it doesn't exist.  Proceed
                    // to traverse the ICM-keys for more sub-keys.
                    //
                    if (web_CreateDirW(lpwszFDir))
                        bRet = web_TraverseCopyFilesW(hPrinter, lpwszFDir, lpwszFKey);

                    web_GFree(lpwszFDir);
                }

                web_GFree(lpwszFKey);
            }

            lpwszSKey = web_NextStrW(lpwszSKey);
        }


        // Free up the array.
        //
        web_GFree(awszSKeys);


        // Process the ICM files for the specified key.  If this
        // is our top-level key (CopyFiles), then don't bother
        // with the initialization.  i.e. there should be no
        // (module, files, directory) keys at this level.
        //
        if (bRet && lstrcmpiW(lpwszKey, s_wszCopyFiles))
            bRet = web_CopyFilesW(hPrinter, lpwszDir, lpwszKey);
    }

    return bRet;
}


/*****************************************************************************\
* web_WriteHeader (Local Routine)
*
* Outputs the header for the BIN-file.  The parameters to this routine
* specify whether there is a DEVMODE contained in the file, as well as a
* count of all the device-data-items.
*
\*****************************************************************************/
BOOL web_WriteHeader(
    HANDLE hFile,
    DWORD  cItems,
    BOOL   bDevMode)
{
    DWORD       dwWr = 0;
    DEVBIN_HEAD dbh;
    BOOL        bRet;


    // Setup the header information.
    //
    dbh.cItems   = cItems;
    dbh.bDevMode = bDevMode;


    // Make sure our header is positioned at the beginning of the file.
    //
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);


    // Write out the header.  Check to make sure that all was written
    // succesfully.
    //
    bRet = WriteFile(hFile, &dbh, sizeof(DEVBIN_HEAD), &dwWr, NULL);

    return ((bRet && (dwWr != sizeof(DEVBIN_HEAD))) ? FALSE : bRet);
}


/*****************************************************************************\
* web_ReadDevMode (Local Routine)
*
* Reads the devmode-structure from the BIN-File and sets the printer with
* the information.  Since our data from the BIN-File is in the format
* of UNICODE, we must take care to only use (W) functions.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_ReadDevMode(
    LPDEVBIN_HEAD lpdbh,
    HANDLE        hPrinter,
    LPCTSTR       lpszPrtName)
{
    LPDEVBIN_INFO     lpdbi;
    LPPRINTER_INFO_2W lppi;
    LPDEVMODEW        lpdm;
    DWORD             cbSize;
    DWORD             cbNeed;
    BOOL              bRet = FALSE;


    // Set our pointer past the header.  The DEVMODE always occupies the
    // first entry in our item-list.
    //
    lpdbi = (LPDEVBIN_INFO)(lpdbh + 1);


    // First let's see how big our buffer will need to
    // be in order to hold the PRINTER_INFO_2W.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);


    // Allocate storage for holding the print-info structure as well
    // as the new devmode data we will be copying.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize + lpdbi->cbData))) {

        // Retrieve our current printer-settings.
        //
        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {

            // If our printer has a DEVMODE, then we can continue on
            // with initializing it with our BIN-File DEVMODE.  Otherwise,
            // there's no sense setting a devmode to a printer that
            // doesn't have one...return TRUE in this case.
            //
            if (lppi->pDevMode) {

                // Set the new devmode pointer.  We will be appending our
                // DEVMODE (from the file) to the PRINTER_INFO_2 structure
                // that we have just grabbed.  Reset the pointers to
                // reflect the new-position of the DEVMODE.
                //
                lppi->pDevMode = (LPDEVMODEW)(((LPBYTE)lppi) + cbSize);
                lpdm           = lppi->pDevMode;


                // Copy our new devmode to the printer-info struct.
                // This is appended on to the structure.
                //
                // Since this data was obtained by file, the pointer
                // is actually a byte offset.
                //
                CopyMemory(lpdm,
                           ((LPBYTE)lpdbi) + lpdbi->pData,
                           lpdbi->cbData);


                // Copy the new printer-name to the DEVMODE.  Since our
                // routines deal strictly with unicode, we need to do
                // the correct conversion in case this library was built
                // as ansi.
                //
#ifdef UNICODE

                lstrcpyn(lpdm->dmDeviceName, lpszPrtName, CCHDEVICENAME);
#else
                lpdm->dmDeviceName[CCHDEVICENAME - 1] = (WCHAR)0;

                web_MBtoWC(lpdm->dmDeviceName,
                           lpszPrtName,
                           sizeof(lpdm->dmDeviceName) - sizeof(WCHAR));
#endif

                // Write out our new printer-settings.
                //
                bRet = SetPrinterW(hPrinter, 2, (LPBYTE)lppi, 0);

            } else {

                bRet = TRUE;
            }
        }

        web_GFree(lppi);
    }

    return bRet;
}


/*****************************************************************************\
* web_ReadDevData (Local Routine)
*
* Reads the device-configuration-data from the BIN-File and sets the
* printer with the information.
*
* Use : Processed in the context of the print-client.
*
\*****************************************************************************/
BOOL web_ReadDevData(
    LPDEVBIN_HEAD lpdbh,
    HANDLE        hPrinter)
{
    LPDEVBIN_INFO lpdbi;
    LPWSTR        lpszKey;
    LPWSTR        lpszVal;
    LPBYTE        lpbData;
    DWORD         idx;
    DWORD         dwRet;
    BOOL          bRet;

    PWSTR         lpszNewKey = NULL;
    PWSTR         lpszNewVal = NULL;
    PBYTE         lpbNewData = NULL;


    // Set our pointer past the header.  The DEVMODE always occupies the
    // first entry (If a DEVMODE exists).
    //
    lpdbi = (LPDEVBIN_INFO)(lpdbh + 1);


    // If there's a DEVMODE, skip over it and point to the Printer-Data
    // entries.
    //
    if (lpdbh->bDevMode)
        lpdbi = web_NextItem(lpdbi);


    // Loop through our items and set the data to the registry.
    //
    for (idx = 0, bRet = TRUE; (idx < lpdbh->cItems) && bRet; idx++) {

        // Remarshall the byte-offsets into pointers.
        //
        lpszKey = (LPWSTR)(((LPBYTE)lpdbi) + lpdbi->pKey);
        lpszVal = (LPWSTR)(((LPBYTE)lpdbi) + lpdbi->pValue);
        lpbData = (LPBYTE)(((LPBYTE)lpdbi) + lpdbi->pData);

        //
        //  We have to copy the data into a new buffer to avoid 64 bit mis-alignment.
        //
        lpszNewKey = new WCHAR[(lpdbi->pValue - lpdbi->pKey) / sizeof (WCHAR)];
        lpszNewVal = new WCHAR[(lpdbi->pData - lpdbi->pValue) / sizeof (WCHAR)];
        lpbNewData = new BYTE[lpdbi->cbData];

        if (!lpszNewKey || !lpszVal || !lpbData)
        {
            bRet = FALSE;
        }
        else
        {
            CopyMemory (lpszNewKey, lpszKey, lpdbi->pValue - lpdbi->pKey);
            CopyMemory (lpszNewVal, lpszVal, lpdbi->pData - lpdbi->pValue);
            CopyMemory (lpbNewData, lpbData, lpdbi->cbData);

        }

        if (bRet)
        {

            // Set the printer-data.  Since our file-format
            // deals with UNICODE-strings, we will use the
            // Wide-API.
            //
            dwRet = SetPrinterDataExW(hPrinter,
                                      lpszNewKey,
                                      lpszNewVal,
                                      lpdbi->dwType,
                                      lpbNewData,
                                      lpdbi->cbData);

            // If the data is set-correctly, then continue on
            // to the next-item.  Otherwise, set us up to return
            // false.
            //
            if (dwRet == ERROR_SUCCESS) {

                lpdbi = web_NextItem(lpdbi);

            } else {

                bRet = FALSE;
            }
        }

        if (lpszNewKey)
        {
            delete [] lpszNewKey;
            lpszNewKey = NULL;
        }

        if (lpszNewVal)
        {
            delete [] lpszNewVal;
            lpszNewVal = NULL;
        }

        if (lpbNewData)
        {
            delete [] lpbNewData;
            lpbNewData = NULL;
        }

    }


    // Once the registry is initialized with the printer-data, we need
    // to parse the printer-data-registry for the ICM (CopyFiles), to
    // initialize ICM profiles.
    //
    if (bRet && web_KeyExistsW(hPrinter, s_wszCopyFiles))
        bRet = web_TraverseCopyFilesW(hPrinter, NULL, s_wszCopyFiles);

    return bRet;
}


/*****************************************************************************\
* web_WriteDevMode (Local Routine)
*
* Output the DEVMODEW struct to the BIN-File.  Since we are storing this
* to a file, we make sure that our format is consistent across various
* processes.  Our choice is to use UNICODE API as a means to query and store
* the DEVMODE information.
*
\*****************************************************************************/
BOOL web_WriteDevMode(
    HANDLE hFile,
    HANDLE hPrinter,
    LPBOOL lpbDevMode)
{
    DWORD             cbSize;
    DWORD             cbNeed;
    DWORD             cbDevMode;
    DWORD             dwWr;
    LPDEVBIN_INFO     lpdbi;
    LPPRINTER_INFO_2W lppi;
    BOOL              bRet = FALSE;


    // Set the default return for a devmode.
    //
    *lpbDevMode = FALSE;


    // Retrieve the size to store the printer-info-2 struct.
    //
    cbSize = 0;
    GetPrinterW(hPrinter, 2, NULL, 0, &cbSize);


    // Allocate the printer-info-2 struct and proceed
    // to pull out the devmode information.
    //
    if (cbSize && (lppi = (LPPRINTER_INFO_2W)web_GAlloc(cbSize))) {

        // Retreive the printer-info-2 and write out the
        // DEVMODEW part of this structure.
        //
        if (GetPrinterW(hPrinter, 2, (LPBYTE)lppi, cbSize, &cbNeed)) {

            // Allocate space for the devmode and our header information.
            // Align this on DWORD boundries.
            //
            if (lppi->pDevMode) {

                // The DEVMODE will need to include driver-specific
                // information if such is stored in this DEVMODE.
                //
                cbDevMode = lppi->pDevMode->dmSize +
                            lppi->pDevMode->dmDriverExtra;


                // Calculate the DWORD aligned size that we will need
                // to store our DEVMODE information to file.
                //
                cbSize = web_AlignSize(sizeof(DEVBIN_INFO) + cbDevMode);


                // Get the DEVMODE from the PRINTER_INFO_2 struct. and
                // write to file.  We want to take care to
                //
                if (lpdbi = (LPDEVBIN_INFO)web_GAlloc(cbSize)) {

                    // Setup our memory-block.  The DEVMODEW will
                    // occupy the first item in the array.  Since
                    // it's not associated with printer-data-information,
                    // we will not store any (NAME and TYPE).
                    //
                    // Since this structure will inevitably be written
                    // to file, we must marshall the pointers and store
                    // only byte-offsets.
                    //
                    lpdbi->cbSize  = cbSize;
                    lpdbi->dwType  = 0;
                    lpdbi->pKey    = 0;
                    lpdbi->pValue  = 0;
                    lpdbi->pData   = sizeof(DEVBIN_INFO);
                    lpdbi->cbData  = cbDevMode;

                    CopyMemory(((LPBYTE)lpdbi) + lpdbi->pData,
                               lppi->pDevMode,
                               cbDevMode);


                    // Write the information to file.  Check the return
                    // to verify bytes were written correctly.
                    //
                    bRet = WriteFile(hFile, lpdbi, cbSize, &dwWr, NULL);

                    if (bRet && (dwWr != cbSize))
                        bRet = FALSE;


                    // Indicate that a devmode was written.
                    //
                    *lpbDevMode = TRUE;


                    web_GFree(lpdbi);
                }

            } else {

                bRet        = TRUE;
                *lpbDevMode = FALSE;
            }
        }

        web_GFree(lppi);
    }

    return bRet;
}


/*****************************************************************************\
* web_WriteKeyItem (Local Routine)
*
* Writes one item to the file.
*
\*****************************************************************************/
BOOL web_WriteKeyItem(
    HANDLE                hFile,
    LPCWSTR               lpszKey,
    LPPRINTER_ENUM_VALUES lpPEV)
{
    DWORD         cbKeySize;
    DWORD         cbKey;
    DWORD         cbName;
    DWORD         cbSize;
    DWORD         dwWr;
    LPDEVBIN_INFO lpdbi;
    BOOL          bWrite = FALSE;


    // Calculate aligned sizes for the key-name and key-value strings.
    //
    cbKeySize = web_StrSizeW(lpszKey);
    cbKey     = web_AlignSize(cbKeySize);
    cbName    = web_AlignSize(lpPEV->cbValueName);


    // Calculate size necessary to hold our DEVBIN_INFO information
    // which is written to file.
    //
    cbSize = sizeof(DEVBIN_INFO) + cbKey + cbName + web_AlignSize (lpPEV->cbData);


    // Allocate space for the structure.
    //
    if (lpdbi = (LPDEVBIN_INFO)web_GAlloc(cbSize)) {

        // Initialize the structure elements.  Since this information
        // is written to file, we must take care to convert the
        // pointers to byte-offsets.
        //
        lpdbi->cbSize  = cbSize;
        lpdbi->dwType  = lpPEV->dwType;
        lpdbi->pKey    = sizeof(DEVBIN_INFO);
        lpdbi->pValue  = lpdbi->pKey + cbKey;
        lpdbi->pData   = lpdbi->pValue + cbName;
        lpdbi->cbData  = lpPEV->cbData;

        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pKey  , lpszKey          , cbKeySize);
        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pValue, lpPEV->pValueName, lpPEV->cbValueName);
        CopyMemory(((LPBYTE)lpdbi) + lpdbi->pData , lpPEV->pData     , lpPEV->cbData);

        bWrite = WriteFile(hFile, lpdbi, lpdbi->cbSize, &dwWr, NULL);

        if (bWrite && (dwWr != lpdbi->cbSize))
            bWrite = FALSE;

        web_GFree(lpdbi);
    }

    return bWrite;
}


/*****************************************************************************\
* web_WriteKeyData (Local Routine)
*
* Outputs the Printer-Configuration-Data to the BIN-File.  This writes
* all info for the specified key.
*
* returns: number of items written to file.
*          (-1) if an error occurs.
*
\*****************************************************************************/
int web_WriteKeyData(
    HANDLE  hFile,
    HANDLE  hPrinter,
    LPCWSTR lpszKey)
{
    LPPRINTER_ENUM_VALUES apevData;
    BOOL                  bWr;
    int                   idx;
    int                   nItems = -1;


    // Only write data if we are given a valid-key.
    //
    if ((lpszKey == NULL) || (*lpszKey == (WCHAR)0))
        return 0;


    // Enumerate all data for the specified key and write to the file.
    //
    if (apevData = web_EnumPrinterDataW(hPrinter, lpszKey, (LPDWORD)&nItems)) {

        // Write all the values for this key.
        //
        for (idx = 0, bWr = TRUE; (idx < nItems) && bWr; idx++)
            bWr = web_WriteKeyItem(hFile, lpszKey, apevData + idx);

        if (bWr == FALSE)
            nItems = -1;

        web_GFree(apevData);
    }

    return nItems;
}


/*****************************************************************************\
* web_WriteDevData (Local Routine)
*
* Recursively traverses the printer registry and writes out the settings
* to file.
*
\*****************************************************************************/
BOOL web_WriteDevData(
    HANDLE  hFile,
    HANDLE  hPrinter,
    LPCWSTR lpszKey,
    LPDWORD lpcItems)
{
    LPWSTR aszSKeys;
    LPWSTR lpszSKey;
    LPWSTR lpszFKey;
    DWORD  dwRet;
    INT    cItems;
    BOOL   bRet = FALSE;


    if (aszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpszKey)) {

        for (bRet = TRUE, lpszSKey = aszSKeys; *lpszSKey && bRet; ) {

            if (lpszFKey = web_MakeFullKeyW(lpszKey, lpszSKey)) {

                bRet = web_WriteDevData(hFile, hPrinter, lpszFKey, lpcItems);

                web_GFree(lpszFKey);
            }

            lpszSKey = web_NextStrW(lpszSKey);
        }


        // Free up the array.
        //
        web_GFree(aszSKeys);


        // Write the keys/values to the file.
        //
        if (bRet) {

            cItems = web_WriteKeyData(hFile, hPrinter, lpszKey);

            if (cItems >= 0)
                *lpcItems += cItems;
            else
                bRet = FALSE;
        }
    }

    return bRet;
}

/*****************************************************************************\
* web_ICMEnumCallBack (Local Routine)
*
* This routine takes the UNICODE (lpwszDir, lpwszFile) and converts it to
* the appropriate string prior to making the callback to the caller.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_ICMEnumCallBack(
    LPCWSTR lpwszDir,
    LPCWSTR lpwszFile,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPTSTR lpszDir;
    LPTSTR lpszFile;
    BOOL   bRet = FALSE;


    if (lpszDir = web_WCtoTC(lpwszDir, lstrlenW(lpwszDir) + 1)) {

        if (lpszFile = web_WCtoTC(lpwszFile, lstrlenW(lpwszFile) + 1)) {

            bRet = (*(WEBENUMICMPROC)fpEnum)(lpszDir, lpszFile, lpParm);

            web_GFree(lpszFile);
        }

        web_GFree(lpszDir);
    }

    return bRet;
}


/*****************************************************************************\
* web_EnumFilesW (Local Routine)
*
* This routine enums the point & print "files" under the "copyfiles" path
* for the printer.  This is called once we're at the end of a sub-key list
* in the registry.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_EnumFilesW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPWSTR awszFiles;
    LPWSTR lpwszFile;
    LPWSTR lpwszDir;
    BOOL   bRet = FALSE;


    // For this ICM key, we will grab the list of ICM profiles that are
    // necessary.
    //
    if (awszFiles = (LPWSTR)web_GetPrtDataW(hPrinter, lpwszKey, s_wszFil)) {

        // Get the src-directory for the ICM profiles under the given key.
        //
        if (lpwszDir = web_BuildCopyDirW(hPrinter, dwCliInfo, lpwszKey)) {

            for (bRet = TRUE, lpwszFile = awszFiles; *lpwszFile && bRet; ) {

                // Make the callback to the caller.  In order to do this,
                // we must make sure our strings are in the appropriate
                // format according to what the caller expects (ie. unicode
                // or ansi).
                //
                bRet = web_ICMEnumCallBack(lpwszDir, lpwszFile, fpEnum, lpParm);

                lpwszFile = web_NextStrW(lpwszFile);
            }

            web_GFree(lpwszDir);
        }

        web_GFree(awszFiles);
    }


#ifdef NOT_IMPLEMENTED

// 05-Mar-1997 : ChrisWil INVESTIGATE-ITEM
//
// Notify with event here!!!
//

#endif

    return bRet;
}


/*****************************************************************************\
* web_EnumCopyFilesW (similar to TraverseCopyFiles) (Local Routine)
*
* This routine recursively traverses the printer-registry-settings for
* the CopyFiles keys.  Since the API's used in this routine are only
* available in UNICODE, this should be a (W) type routine.
*
* Use : Processed in the context of the print-server.
*
\*****************************************************************************/
BOOL web_EnumCopyFilesW(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    LPCWSTR lpwszKey,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    LPWSTR awszSKeys;
    LPWSTR lpwszSKey;
    LPWSTR lpwszFKey;
    DWORD  dwType;
    BOOL   bRet = FALSE;


    // Returns an array of keys stored under the printer registry.
    //
    if (awszSKeys = web_EnumPrinterSubKeysW(hPrinter, lpwszKey)) {

        // For each key, look to see if it contains other sub-keys.  We
        // recursively traverse the registry until we hit a key with
        // no sub-keys.
        //
        for (bRet = TRUE, lpwszSKey = awszSKeys; *lpwszSKey && bRet; ) {

            bRet = FALSE;

            // Since the enum-routine only returns relative key-values,
            // we need to build the fully-qualified key-path.
            //
            if (lpwszFKey = web_MakeFullKeyW(lpwszKey, lpwszSKey)) {

                bRet = web_EnumCopyFilesW(hPrinter,
                                          dwCliInfo,
                                          lpwszFKey,
                                          fpEnum,
                                          lpParm);

                web_GFree(lpwszFKey);
            }


            // Next key in list.
            //
            lpwszSKey = web_NextStrW(lpwszSKey);
        }


        // Free up the array.
        //
        web_GFree(awszSKeys);


        // Process the files for the specified key.  If this
        // is our top-level key (CopyFiles), then don't bother
        // with the initialization.  i.e. there should be no
        // (module, files, directory) keys at this level.
        //
        if (bRet && lstrcmpiW(lpwszKey, s_wszCopyFiles))
            bRet = web_EnumFilesW(hPrinter, dwCliInfo, lpwszKey, fpEnum, lpParm);
    }

    return bRet;
}


/*****************************************************************************\
* webEnumPrinterInfo
*
* This routine enumerates the information stored in the registery.  Depending
* upon the (dwType) passed in, it can enumerate different types of information.
*
* Use : Called from the Printer-Server to enumerate the copyfiles sections
*       of the registry.  This also provides a callback to allow the caller
*       to trap the profiles so they may be added to the CAB list.
*
* Use : Called from the printer-server to enumerate ICM information.
*
\*****************************************************************************/
BOOL webEnumPrinterInfo(
    HANDLE  hPrinter,
    DWORD   dwCliInfo,
    DWORD   dwType,
    FARPROC fpEnum,
    LPVOID  lpParm)
{
    BOOL bEnum = TRUE;


    // Call enumeration functions for various enumeration types.
    //
    switch (dwType) {

    case WEB_ENUM_ICM:
        if (web_KeyExistsW(hPrinter, s_wszCopyFiles))
            bEnum = web_EnumCopyFilesW(hPrinter, dwCliInfo, s_wszCopyFiles, fpEnum, lpParm);
        break;

    default:
    case WEB_ENUM_KEY:  // NOT IMPLEMENTED
        bEnum = FALSE;
    }

    return bEnum;
}


/*****************************************************************************\
* webWritePrinterInfo
*
* This routine reads the DEVMODE and Configuration-Data from the specified
* printer, and writes this to a .BIN file.
*
* Use : Called from the printer-server to write the registry settings to file.
*
\*****************************************************************************/
BOOL webWritePrinterInfo(
    HANDLE  hPrinter,
    LPCTSTR lpszBinFile)
{
    HANDLE hFile;
    BOOL   bDevMode;
    DWORD  cItems;
    BOOL   bRet = FALSE;


    // Open the BIN file for writing.
    //
    hFile = web_OpenFileWrite(lpszBinFile);

    if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

        // Output the header.  This basically reserves
        // space at the beginning of the file to store
        // the item-count.
        //
        if (web_WriteHeader(hFile, 0, FALSE)) {

            // Write out the devmode-info.
            //
            if (web_WriteDevMode(hFile, hPrinter, &bDevMode)) {

                // Write out devdata-info.  The (cItems) indicates how
                // many driver-specific entries were written.
                //
                cItems = 0;
                if (web_WriteDevData(hFile, hPrinter, L"", &cItems))
                    bRet = web_WriteHeader(hFile, cItems, bDevMode);
            }
        }

        CloseHandle(hFile);
    }

    return bRet;
}


/*****************************************************************************\
* webReadPrinterInfo
*
* This routine reads the DEVMODE and Configuration-Data from the specified
* BIN-File, and sets the printer-handle with the attributes.
*
* Use : Called from the printer-client to initialize the registry.
*
\*****************************************************************************/
BOOL webReadPrinterInfo(
    HANDLE  hPrinter,
    LPCTSTR lpszPrtName,
    LPCTSTR lpszBinFile)
{
    HANDLE        hMap;
    LPDEVBIN_HEAD lpdbh;
    BOOL          bRet = FALSE;


    // Open the BIN file for writing.
    //
    if (hMap = web_OpenMap(lpszBinFile)) {

        if (lpdbh = (LPDEVBIN_HEAD)web_LockMap(hMap)) {

            // Only if we have a DevMode should we write out the information.
            //
            if (!lpdbh->bDevMode || web_ReadDevMode(lpdbh, hPrinter, lpszPrtName)) {

                // Only if we have printer-data items should we proceed
                // to write out the information.
                //
                if (!lpdbh->cItems || web_ReadDevData(lpdbh, hPrinter)) {

                    bRet = TRUE;
                }
            }

            web_UnlockMap((LPVOID)lpdbh);
        }

        web_CloseMap(hMap);
    }

    return bRet;
}


/*****************************************************************************\
* WebPnpEntry
*
* This routine is called by PrintWizard prior to installing the printer.
* Currently, we can find no value to this, but it is a nice balance to the
* WebPnpPostEntry() routine.
*
* Use : Called from the print-client prior to printer installation.
*
\*****************************************************************************/
BOOL WebPnpEntry(
    LPCTSTR lpszCmdLine)
{
    return TRUE;
}


BOOL
PrinterExists(
    HANDLE hPrinter)
{
    DWORD            cbNeeded;
    DWORD            Error;
    BOOL             rc = FALSE;
    LPPRINTER_INFO_2 pPrinter;
    DWORD            cbPrinter;

    cbPrinter = 0x400;
    pPrinter = (PPRINTER_INFO_2) web_GAlloc ( cbPrinter );

    if( !pPrinter )
        return FALSE;

    if( !GetPrinter( hPrinter, 2, (LPBYTE)pPrinter, cbPrinter, &cbNeeded ) )
    {
        Error = GetLastError( );

        if( Error == ERROR_INSUFFICIENT_BUFFER )
        {
            web_GFree (pPrinter);
            pPrinter = (PPRINTER_INFO_2)web_GAlloc ( cbNeeded );

            if( pPrinter )
            {
                cbPrinter = cbNeeded;

                if( GetPrinter( hPrinter, 2, (LPBYTE)pPrinter, cbPrinter, &cbNeeded ) )
                {
                    rc = TRUE;
                }
            }
        }

        else if( Error == ERROR_INVALID_HANDLE )
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }
    }

    else
    {
        rc = TRUE;
    }


    if( pPrinter )
    {
        web_GFree ( pPrinter );
    }

    return rc;
}


/*****************************************************************************\
* WebPnpPostEntry
*
* This routine is called via PrintWizard after a printer has been added.  This
* provides the oportunity for the web-pnp-installer to initialize the
* registry settings and files according to the information provided in the
* BIN-File.  The (fConnection) flag indicates whether the printer was
* installed via RPC or HTTP.  If it was RPC, then it's not necessary to do
* any printer-settings.
*
* Use : Called from the print-client after printer installation.
*
\*****************************************************************************/
BOOL WebPnpPostEntry(
    BOOL    fConnection,
    LPCTSTR lpszBinFile,
    LPCTSTR lpszPortName,
    LPCTSTR lpszPrtName)
{
    HANDLE           hPrinter;
    PRINTER_DEFAULTS pd;
    BOOL             bRet = TRUE;


    if (fConnection == FALSE) {

        // Setup the printer-defaults to
        // allow printer-changes.
        //
        pd.pDatatype     = NULL;
        pd.pDevMode      = NULL;
        pd.DesiredAccess = PRINTER_ALL_ACCESS;


        // Open the printer specified.
        //
        if (OpenPrinter((LPTSTR)lpszPrtName, &hPrinter, &pd)) {

            if (!PrinterExists(hPrinter) && GetLastError () == ERROR_ACCESS_DENIED) {
                ConfigurePort( NULL, GetDesktopWindow (), (LPTSTR) lpszPortName);
            }

            bRet = webReadPrinterInfo(hPrinter, lpszPrtName, lpszBinFile);

            ClosePrinter(hPrinter);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\data.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Data.c

Abstract:

    Driver Setup data

Author:

    Muhunthan Sivapragasam (MuhuntS) 28-Mar-1997

Revision History:

--*/

#include "precomp.h"

#define offsetof(type, identifier) (ULONG_PTR)(&(((type)0)->identifier))

ULONG_PTR   LocalDataOffsets[]={offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszInfName),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszModelName),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszDriverSection),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszHardwareID),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszManufacturer),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszOEMUrl),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszProvider),
                               offsetof(PPSETUP_LOCAL_DATA, DrvInfo.pszzPreviousNames),
                               (ULONG_PTR)-1};

ULONG_PTR   InfInfoOffsets[]={offsetof(PPARSEINF_INFO, pszInstallSection),
                             offsetof(PPARSEINF_INFO, pszzICMFiles),
                             offsetof(PPARSEINF_INFO, pszPrintProc),
                             offsetof(PPARSEINF_INFO, pszVendorSetup),
                             offsetof(PPARSEINF_INFO, pszVendorInstaller),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pName),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDriverPath),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pConfigFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDataFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pHelpFile),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDependentFiles),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pMonitorName),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pDefaultDataType),
                             (ULONG_PTR)-1};

//
// This array has the offsets of the elements that are shared in various structures
// 
ULONG_PTR   SharedInfInfoOffsets[] = {
                             offsetof(PPARSEINF_INFO, DriverInfo6.pszzPreviousNames),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pszMfgName),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pszOEMUrl),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pszHardwareID),
                             offsetof(PPARSEINF_INFO, DriverInfo6.pszProvider),
                             (ULONG_PTR)-1};

ULONG_PTR   PnPInfoOffsets[]={offsetof(PPNP_INFO, pszPortName),
                             offsetof(PPNP_INFO, pszDeviceInstanceId),
                             (ULONG_PTR)-1};


#if DBG
//
// The following are to catch any inconsistency in splsetup.h
// Which can break the printui/ntprint interface
//
pfPSetupCreatePrinterDeviceInfoList             _pfn1   = PSetupCreatePrinterDeviceInfoList;
pfPSetupDestroyPrinterDeviceInfoList            _pfn2   = PSetupDestroyPrinterDeviceInfoList;
pfPSetupSelectDriver                            _pfn3   = PSetupSelectDriver;
pfPSetupCreateDrvSetupPage                      _pfn4   = PSetupCreateDrvSetupPage;
pfPSetupGetSelectedDriverInfo                   _pfn5   = PSetupGetSelectedDriverInfo;
pfPSetupDestroySelectedDriverInfo               _pfn6   = PSetupDestroySelectedDriverInfo;
pfPSetupInstallPrinterDriver                    _pfn7   = PSetupInstallPrinterDriver;
pfPSetupIsDriverInstalled                       _pfn8   = PSetupIsDriverInstalled;
pfPSetupIsTheDriverFoundInInfInstalled          _pfn9   = PSetupIsTheDriverFoundInInfInstalled;
pfPSetupRefreshDriverList                       _pfn10  = PSetupRefreshDriverList;
pfPSetupThisPlatform                            _pfn11  = PSetupThisPlatform;
pfPSetupGetPathToSearch                         _pfn12  = PSetupGetPathToSearch;
pfPSetupDriverInfoFromName                      _pfn13  = PSetupDriverInfoFromName;
pfPSetupPreSelectDriver                         _pfn14  = PSetupPreSelectDriver;
pfPSetupCreateMonitorInfo                       _pfn15  = PSetupCreateMonitorInfo;
pfPSetupDestroyMonitorInfo                      _pfn16  = PSetupDestroyMonitorInfo;
pfPSetupEnumMonitor                             _pfn17  = PSetupEnumMonitor;
pfPSetupInstallMonitor                          _pfn18  = PSetupInstallMonitor;

//
// removed because unnecessary
//
// pfPSetupIsMonitorInstalled                      _pfn19  = PSetupIsMonitorInstalled;

pfPSetupProcessPrinterAdded                     _pfn20  = PSetupProcessPrinterAdded;
pfPSetupBuildDriversFromPath                    _pfn21  = PSetupBuildDriversFromPath;
pfPSetupSetSelectDevTitleAndInstructions        _pfn22  = PSetupSetSelectDevTitleAndInstructions;
pfPSetupInstallPrinterDriverFromTheWeb          _pfn23  = PSetupInstallPrinterDriverFromTheWeb;
pfPSetupIsOemDriver                             _pfn24  = PSetupIsOemDriver;
pfPSetupGetLocalDataField                       _pfn25  = PSetupGetLocalDataField;
pfPSetupFreeDrvField                            _pfn26  = PSetupFreeDrvField;
pfPSetupIsCompatibleDriver                      _pfn27  = PSetupIsCompatibleDriver;
pfPSetupAssociateICMProfiles                    _pfn28  = PSetupAssociateICMProfiles;
pfPSetupInstallICMProfiles                      _pfn29  = PSetupInstallICMProfiles;
pfPSetupFreeMem                                 _pfn30  = PSetupFreeMem;
pfPSetupFindMappedDriver                        _pfn31  = PSetupFindMappedDriver;
pfPSetupInstallInboxDriverSilently              _pfn32  = PSetupInstallInboxDriverSilently;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\webutil.cxx ===
/*****************************************************************************\
* MODULE: webutil.cxx
*
* PURPOSE:  functions to handle printer name encoding
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     02/26/98 weihaic     Added DecodePrinterName/EncodePrinterName
*                                GetWebpnpUrl
*     04/23/97 weihaic     Created based on spooler/inersrv/inetio.cxx
*
\*****************************************************************************/

#include "spllibp.hxx"
#pragma hdrstop

#include "splcom.h"

#ifdef DEBUG
DWORD g_cbIppMem = 0;
#endif

/*****************************************************************************\
* web_WCtoMB (Local Routine)
*
* Converts Wide-Char to Multi-Byte string.  This routine specifies a codepage
* for translation.
*
\*****************************************************************************/
LPSTR web_WCtoMB(
    UINT    uCP,
    LPCWSTR lpszWC,
    LPDWORD lpcbSize)
{
    DWORD cbSize;
    LPSTR lpszMB = NULL;


    // Get the size necessary to hold a multibyte string.
    //
    cbSize = WideCharToMultiByte(uCP, 0, lpszWC, -1, NULL, 0, NULL, NULL);

    if (cbSize) {

        if (lpszMB = (LPSTR)webAlloc(cbSize)) {

            WideCharToMultiByte(uCP, 0, lpszWC, -1, lpszMB, cbSize, NULL, NULL);

            // If a size-return is requested, then return
            // the bytes-occupied (no terminator).
            //
            if (lpcbSize)
                *lpcbSize = --cbSize;
        }
    }

    return lpszMB;
}


/*****************************************************************************\
* web_WCtoUtf8 (Local Routine)
* web_Utf8toWC (Local Routine)
*
* Converts Wide-Char to Multi-Byte string.  This routine is used for ansi
* 9X platforms since the CP_UTF8 codepage isn't supported.
*
\*****************************************************************************/

#define ASCII            0x007f                // ascii range.
#define UTF8_2_MAX       0x07ff                // max UTF8 2byte seq (32 * 64 = 2048)
#define UTF8_1ST_OF_2    0xc0                  // 110x xxxx
#define UTF8_1ST_OF_3    0xe0                  // 1110 xxxx
#define UTF8_TRAIL       0x80                  // 10xx xxxx
#define HIGER_6_BIT(u)   ((u) >> 12)           //
#define MIDDLE_6_BIT(u)  (((u) & 0x0fc0) >> 6) //
#define LOWER_6_BIT(u)   ((u) & 0x003f)        //
#define BIT7(a)          ((a) & 0x80)          //
#define BIT6(a)          ((a) & 0x40)          //
#define SIZEOF_UTF8      (sizeof(WCHAR) + sizeof(CHAR))

LPSTR web_WCtoUtf8(
    LPCWSTR lpszSrc,
    DWORD   cchSrc,
    LPDWORD lpcbSize)
{
    LPSTR   lpszU8;
    LPCWSTR lpszWC;
    LPSTR   lpszDst = NULL;
    DWORD   cchDst  = 0;


    // Allocate our buffer for the translation.
    //
    if (cchSrc && (lpszDst = (LPSTR)webAlloc(cchSrc * SIZEOF_UTF8))) {

        for (lpszU8 = lpszDst, lpszWC = lpszSrc; cchSrc; lpszWC++, cchSrc--) {

            if (*lpszWC <= ASCII) {

                *lpszU8++ = (CHAR)*lpszWC;

                cchDst++;

            } else if (*lpszWC <= UTF8_2_MAX) {

                //  Use upper 5 bits in first byte.
                //  Use lower 6 bits in second byte.
                //
                *lpszU8++ = (UTF8_1ST_OF_2 | (*lpszWC >> 6));
                *lpszU8++ = (UTF8_TRAIL    | LOWER_6_BIT(*lpszWC));

                cchDst+=2;
            } else {

                //  Use upper  4 bits in first byte.
                //  Use middle 6 bits in second byte.
                //  Use lower  6 bits in third byte.
                //
                *lpszU8++ = (UTF8_1ST_OF_3 | (*lpszWC >> 12));
                *lpszU8++ = (UTF8_TRAIL    | MIDDLE_6_BIT(*lpszWC));
                *lpszU8++ = (UTF8_TRAIL    | LOWER_6_BIT(*lpszWC));
                cchDst+=3;
            }
        }

    } else {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    // Return our buffer-size.
    //
    *lpcbSize = cchDst;

    return lpszDst;
}

LPWSTR web_Utf8toWC(
    LPCSTR lpszSrc,
    DWORD  cchSrc)
{
    LPCSTR lpszU8;
    LPWSTR lpszWC;
    int    nTB;
    CHAR   cU8;
    LPWSTR lpszDst = NULL;


    if (cchSrc && (lpszDst = (LPWSTR)webAlloc((cchSrc + 1) * sizeof(WCHAR)))) {

        for (lpszU8 = lpszSrc, lpszWC = lpszDst, nTB = 0; cchSrc ; cchSrc--) {

            if (BIT7(*lpszU8) == 0) {

                // Ascii.
                //
                *lpszWC++ = (WCHAR)*lpszU8;

            } else if (BIT6(*lpszU8) == 0) {

                if (nTB != 0) {

                    //
                    //  Decrement the trail byte counter.
                    //
                    nTB--;


                    // Make room for the trail byte and add the trail byte
                    // value.
                    //
                    *lpszWC <<= 6;
                    *lpszWC |= LOWER_6_BIT(*lpszU8);


                    if (nTB == 0)
                        lpszWC++;
                }

            } else {

                // Found a lead byte.
                //
                if (nTB > 0) {

                    // Error - previous sequence not finished.
                    //
                    nTB = 0;
                    lpszWC++;

                } else {

                    // Calculate the number of bytes to follow.
                    // Look for the first 0 from left to right.
                    //
                    for (cU8 = *lpszU8; BIT7(cU8) != 0; ) {

                        cU8 <<= 1;
                        nTB++;
                    }


                    // Store the value from the first byte and decrement
                    // the number of bytes to follow.
                    //
                    *lpszWC = (cU8 >> nTB--);
                }
            }

            lpszU8++;
        }
    }

    return lpszDst;
}


/*****************************************************************************\
* web_MBtoWC (Local Routine)
*
* Converts Multi-Byte to Wide-Char string.  This specifies a translation
* codepage.  The (cchMB) does not include the null-terminator, so we need
*
\*****************************************************************************/
LPWSTR web_MBtoWC(
    UINT   uCP,
    LPCSTR lpszMB,
    DWORD  cchMB)
{
    DWORD  cch;
    LPWSTR lpszWC = NULL;


    // Get the size necessary to hold a widechar string.
    //
    cch = MultiByteToWideChar(uCP, 0, lpszMB, cchMB, NULL, 0);

    if (cch) {

        cch = ((cchMB == (DWORD)-1) ? cch : cch + 1);

        if (lpszWC = (LPWSTR)webAlloc(cch * sizeof(WCHAR))) {

            MultiByteToWideChar(uCP, 0, lpszMB, cchMB, lpszWC, cch);
        }
    }

    return lpszWC;
}


/*****************************************************************************\
* webMBtoTC (Local Routine)
*
* Converts Multi-Byte to a TChar string.
*
\*****************************************************************************/
LPTSTR webMBtoTC(
    UINT  uCP,
    LPSTR lpszUT,
    DWORD cch)
{
    LPTSTR lpszTC = NULL;


#ifdef UNICODE
    if (lpszUT != NULL)
        lpszTC = web_MBtoWC(uCP, lpszUT, cch);

    return lpszTC;

#else
    LPWSTR lpszWC = NULL;

    // First convert the string to unicode so we can go through
    // the translation process.
    //

    if (lpszUT != NULL) {
        if (uCP == CP_UTF8) {
            DWORD cbSize = 0;

            lpszWC = web_Utf8toWC(lpszUT, cch);
            if (lpszWC) {
                lpszTC = web_WCtoMB(CP_ACP, lpszWC, &cbSize);
                webFree(lpszWC);
             }
         } else {
             if ( lpszTC = (LPSTR)webAlloc(cch+1) ) {
                memcpy( lpszTC, lpszUT, cch);
                lpszTC[cch] = '\0';
             }
        }
    }
    return lpszTC;
#endif

}


/*****************************************************************************\
* webTCtoMB (Local Routine)
*
* Converts a TChar to a Multi-Byte string.
*
\*****************************************************************************/
LPSTR webTCtoMB(
    UINT    uCP,
    LPCTSTR lpszTC,
    LPDWORD lpcbSize)
{
    LPWSTR lpszWC;
    LPSTR  lpszUT = NULL;


    *lpcbSize = 0;


    if (lpszTC != NULL) {

#ifdef UNICODE

        if (lpszWC = webAllocStr(lpszTC)) {

            lpszUT = web_WCtoMB(uCP, lpszWC, lpcbSize);
#else

        // Convert to unicode then back again so we can go
        // through the code-page translation.
        //
        if (lpszWC = web_MBtoWC(CP_ACP, lpszTC, (DWORD)-1)) {

            DWORD cch = webStrSize(lpszTC);

            if (uCP == CP_UTF8)
                lpszUT = web_WCtoUtf8(lpszWC, cch, lpcbSize);
            else
                lpszUT = web_WCtoMB(uCP, lpszWC, lpcbSize);
#endif

            webFree(lpszWC);
        }
    }

    return lpszUT;
}


/*****************************************************************************\
* webStrSize (Local Routine)
*
* Returns bytes occupied by string (including NULL terminator).
*
\*****************************************************************************/
DWORD webStrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*****************************************************************************\
* webAlloc (Local Routine)
*
* Allocates a block of memory.
*
\*****************************************************************************/
LPVOID webAlloc(
    DWORD cbSize)
{
    PDWORD_PTR lpdwPtr;

#ifdef DEBUG

    if (cbSize && (lpdwPtr = (LPDWORD)new BYTE[cbSize + sizeof(DWORD_PTR)])) {

        ZeroMemory(lpdwPtr, cbSize + sizeof(DWORD_PTR));

        *lpdwPtr = cbSize;

        g_cbIppMem += cbSize;

        return (LPVOID)(lpdwPtr + 1);
    }

#else

    if (cbSize && (lpdwPtr = (PDWORD_PTR) new BYTE[cbSize])) {

        ZeroMemory(lpdwPtr, cbSize);

        return (LPVOID)lpdwPtr;
    }

#endif

    return NULL;
}


/*****************************************************************************\
* webFree (Local Routine)
*
* Deletes the memory-block allocated via webAlloc().
*
\*****************************************************************************/
BOOL webFree(
    LPVOID lpMem)
{
    if (lpMem) {

#ifdef DEBUG

        DWORD cbSize;

        lpMem = ((LPDWORD)lpMem) - 1;

        cbSize = *((LPDWORD)lpMem);

        g_cbIppMem -= cbSize;

#endif

        delete [] lpMem;

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* webRealloc (Local Routine)
*
* Reallocates a block of memory.
*
\*****************************************************************************/
LPVOID webRealloc(
    LPVOID lpMem,
    DWORD  cbOldSize,
    DWORD  cbNewSize)
{
    LPVOID lpNew;

    if (lpNew = (LPVOID)webAlloc(cbNewSize)) {

        CopyMemory(lpNew, lpMem, cbOldSize);

        webFree(lpMem);
    }

    return lpNew;
}


/*****************************************************************************\
* webAllocStr (Local Routine)
*
* Allocates a string.
*
\*****************************************************************************/
LPTSTR webAllocStr(
    LPCTSTR lpszStr)
{
    LPTSTR lpszMem;
    DWORD  cbSize;


    if (lpszStr == NULL)
        return NULL;

    cbSize = webStrSize(lpszStr);

    if (lpszMem = (LPTSTR)webAlloc(cbSize))
        memcpy(lpszMem, lpszStr, cbSize);

    return lpszMem;
}


/*****************************************************************************\
* webFindRChar
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPTSTR webFindRChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlen(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* webAtoI
*
* Convert Ascii to Integer.
*
\*****************************************************************************/
DWORD webAtoI(
    LPTSTR pszInt)
{
	DWORD dwRet = 0;


    while ((*pszInt >= TEXT('0')) && (*pszInt <= TEXT('9')))
        dwRet = (dwRet * 10) + *pszInt++ - TEXT('0');

    return dwRet;
}


BOOL
IsWebServerInstalled(
    LPCTSTR     pszServer
    )
{
    HANDLE              hServer;
    DWORD               dwDontCare, dwW3SvcInstalled, dwLastError;
    PRINTER_DEFAULTS    Defaults    = {NULL, NULL, 0};

    if ( !OpenPrinter((LPTSTR)pszServer, &hServer, &Defaults) )
        return FALSE;

    dwLastError = GetPrinterData(hServer,
                                 SPLREG_W3SVCINSTALLED,
                                 &dwDontCare,
                                 (LPBYTE)&dwW3SvcInstalled,
                                 sizeof(dwW3SvcInstalled),
                                 &dwDontCare);

    ClosePrinter(hServer);

    return  dwLastError == ERROR_SUCCESS && dwW3SvcInstalled != 0;

}

/********************************************************************************

Name:
    EncodePrinterName

Description:

    Encode the printer name to avoid special characters, also encode any chars
    with ASC code between 0x80 and 0xffff. This is to avoid the conversion betwwen
    different codepages when the client  and the server have different language
    packages.

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL EncodePrinterName (LPCTSTR lpText, LPTSTR lpHTMLStr, LPDWORD lpdwSize)
{
#define MAXLEN_PER_CHAR 6
#define BIN2ASC(bCode,lpHTMLStr)   *lpHTMLStr++ = HexToAsc ((bCode) >> 4);\
                                   *lpHTMLStr++ = HexToAsc ((bCode) & 0xf)

    DWORD   dwLen;
    BYTE    bCode;

    if (!lpText || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = MAXLEN_PER_CHAR * lstrlen (lpText) + 1;

    if (!lpHTMLStr || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpText) {
        if ((DWORD) (*lpText) > 0xff ) {
            // Encode as ~0hhll hh is the high byte, ll is the low byte
            *lpHTMLStr++ = TEXT ('~');
            *lpHTMLStr++ = TEXT ('0');

            // Get the high byte
            bCode = (*lpText & 0xff00) >> 8;
            BIN2ASC(bCode,lpHTMLStr);

            // Get the low byte
            bCode = (*lpText & 0xff);
            BIN2ASC(bCode,lpHTMLStr);
        }
        else if ((DWORD) (*lpText) > 0x7f) {
            // Encode as ~xx
            *lpHTMLStr++ = TEXT ('~');
            bCode = *lpText & 0xff;
            BIN2ASC(bCode,lpHTMLStr);
        }
        else {
            if (! _istalnum( *lpText)) {
                *lpHTMLStr++ = TEXT ('~');
                BIN2ASC(*lpText,lpHTMLStr);
            }
            else {
                *lpHTMLStr++ = *lpText;
            }
        }
        lpText++;
    }
    *lpHTMLStr = NULL;
    return TRUE;
}

/********************************************************************************

Name:
    DncodePrinterName

Description:

    Dncode the printer name encoded in from EncodePrinterName

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL DecodePrinterName (LPCTSTR pPrinterName, LPTSTR pDecodedName, LPDWORD lpdwSize)
{
    LPTSTR  lpParsedStr     = pDecodedName;
    LPCTSTR lpUnparsedStr   = pPrinterName;
    TCHAR   chMark          = TEXT ('~');
    TCHAR   chZero          = TEXT ('0');
    BOOL    bRet            = TRUE;
    DWORD   dwLen;
    TCHAR   b1, b2, b3, b4;

    // Verify that we're getting non-Null input pointers
    if ((!pPrinterName) || (!lpdwSize)) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = lstrlen (pPrinterName) + 1;

    if (!pDecodedName || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpUnparsedStr) {

        if (*lpUnparsedStr == chMark) {
            if (! (b1 = *++lpUnparsedStr)) {
                SetLastError (ERROR_INVALID_DATA);
                bRet = FALSE;
                break;
            }

            if (b1 == chZero) {
                // Decode ~0hhll
                if ( !(b1 = *++lpUnparsedStr) ||
                     !(b2 = *++lpUnparsedStr) ||
                     !(b3 = *++lpUnparsedStr) ||
                     !(b4 = *++lpUnparsedStr)) {
                    SetLastError (ERROR_INVALID_DATA);
                    bRet = FALSE;
                    break;
                }

                lpUnparsedStr++;
                *lpParsedStr++ = (AscToHex (b1) << 12) |
                                 (AscToHex (b2) << 8) |
                                 (AscToHex (b3) << 4) |
                                 AscToHex (b4);
            }
            else {
                // To take care the case when the DecodeString ends with %
                if (! (b2 = *++lpUnparsedStr)) {
                    SetLastError (ERROR_INVALID_DATA);
                    bRet = FALSE;
                    break;
                }

                lpUnparsedStr++;
                *lpParsedStr++ = (AscToHex (b1) << 4) | AscToHex (b2);
            }
        }
        else {
            *lpParsedStr++ = *lpUnparsedStr++;
        }
    }
    *lpParsedStr = NULL;
    return bRet;
}

/********************************************************************************

Name:
    AscToHex

Description:

    Convert a hex character to the corresponding value (0-0xf);

Arguments:

    c:      The character

Return Value:

    0xff    if the character is not a hex digit
    the corresponding numberical value otherwise

********************************************************************************/
BYTE AscToHex (TCHAR c)
{
    UINT uValue = 0xff;

    if (_istxdigit (c))
    {
        if (_istdigit (c))
        {
            uValue = c - TEXT('0');
        }
        else
        {
            uValue = _totlower (c) - TEXT('a') + 10;
        }
    }
    return (BYTE)uValue;
}

/********************************************************************************

Name:
    HexToAsc

Description:

    Convert a hex character to the corresponding value (0-0xf);

Arguments:

    b:      The byte (0 to F)

Return Value:

    0  if the character is out of range
    the corresponding ASCII of the hex number

********************************************************************************/
TCHAR HexToAsc( INT b )
{
    UINT uValue = 0;

    if (0 <= b && b <= 0xf)
    {
        if (b < 0xa)
        {
            uValue = TEXT('0') + b;
        }
        else
        {
            uValue = TEXT('a') + b - 10;
        }
    }
    return (TCHAR)uValue;
}


/********************************************************************************

Name:
    EncodeString

Description:

    Convert the normal text string to HTML text string by replace special
    characters such as ", <, > with the corresponding HTML code

Arguments:

    lpText:     the normal text string
    bURL:       TRUE for encoding a URL string. FALSE otherwise.

Return Value:

    Pointer to the HTML string. The caller is responsible to call LocalFree to
    free the pointer. NULL is returned if no enougth memory
********************************************************************************/
LPTSTR EncodeString (LPCTSTR lpText, BOOL bURL)
{
    DWORD   dwLen;
    DWORD   dwMaxLen = bURL?3:6;    // The maximum length of the encoding characters.
                                    // if it is URL, we enocde it with %xx, so the max len is 3
                                    // otherwise the max len of HTML char is 5,
                                    // it happens when " is encoded (&quot;)
    LPTSTR  lpHTMLStr       = NULL;

    if (!lpText || !(dwLen = lstrlen (lpText))) return NULL;

    // To make life simpler, we allocate the necessary buffer at once instead of
    // calling realloc later. Since the encoded string is always freed after it is dumped
    // to the client, and the length of the string is limited to the nax length of the URL
    // so the modification does not pose extra burden on the system memroy.

    dwLen = dwMaxLen * dwLen + 1;
    if (! (lpHTMLStr = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))))
        return NULL;

    if (bURL) {
        LPTSTR lpDst = lpHTMLStr;

        while (*lpText) {
            switch (*lpText) {
            case TEXT ('<'):
            case TEXT ('>'):
            case TEXT ('"'):
            case TEXT ('&'):
            case TEXT (' '):
            case TEXT ('?'):
                *lpDst++ = TEXT ('%');
                *lpDst++ = HexToAsc ((*lpText & 0xf0) >> 4);
                *lpDst++ = HexToAsc (*lpText & 0x0f);
                break;
            default:
                *lpDst++ = *lpText;
                break;
            }
            lpText++;
        }
    }
    else {
        TCHAR   szDestChar[3]   = {0, 0};
        LPTSTR  lpChar;
        DWORD   dwIndex = 0;

        while (*lpText) {
            switch (*lpText) {
            case TEXT ('<'):    lpChar = TEXT ("&lt;");     break;
            case TEXT ('>'):    lpChar = TEXT ("&gt;");     break;
            case TEXT ('"'):    lpChar = TEXT ("&quot;");   break;
            case TEXT ('&'):    lpChar = TEXT ("&amp;");    break;
            //case TEXT (' '):    lpChar = TEXT ("&nbsp;");   break;
            default:
                szDestChar[0] = *lpText;
                szDestChar[1] = 0;
                lpChar = szDestChar;
            }
            lstrcpy (lpHTMLStr + dwIndex, lpChar);
            dwIndex += lstrlen (lpChar);
            lpText++;
        }
    }

    return lpHTMLStr;
}

/********************************************************************************

Name:
    GetWebpnpUrl

Description:

    Given the server name and the printer name, return the Url for webpnp
    Currently, the URL is
        http://servername/encoded printername/.printer[querystrings]

Arguments:

    pszServer:      The server name
    pszPrinterName: The printer name (unicode string)
    pszQueryString: The querystring (optional)
    pszURL:         The output URL buffer
    lpdwSize:       The size of the URL buffer (in Character)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL GetWebpnpUrl (LPCTSTR pszServer, LPCTSTR pszPrinterName, LPCTSTR pszQueryString,
                   BOOL bSecure, LPTSTR pszURL, LPDWORD lpdwSize)
{
    static TCHAR szHttp[]       = TEXT ("http://");
    static TCHAR szHttps[]      = TEXT ("https://");
    static TCHAR szSlash[]      = TEXT ("/printers/"); //Remove scripts in the URL . Previous value: TEXT ("/scripts/");
    static TCHAR szPrinter[]    = TEXT ("/.printer");
    LPTSTR pszEncodedName       = NULL;
    DWORD dwEncodedSize         = 0;
    DWORD dwSize                = 0;
    DWORD bRet                  = FALSE;

    if (!pszPrinterName || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // Calculate buffer size
    EncodePrinterName (pszPrinterName, NULL, &dwEncodedSize);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    dwSize = (DWORD)(2 + dwEncodedSize
             + COUNTOF (szHttps) + COUNTOF (szSlash) + COUNTOF (szPrinter)
             + ((pszServer)? lstrlen (pszServer):0)
             + ((pszQueryString)?lstrlen (pszQueryString):0));

    if (!pszURL || dwSize > *lpdwSize ) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwSize;
        return FALSE;
    }

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwEncodedSize)))
        goto Cleanup;

    if (!EncodePrinterName (pszPrinterName, pszEncodedName, &dwEncodedSize))
        goto Cleanup;

    if (pszServer) {
        if (bSecure)
            lstrcpy (pszURL, szHttps);
        else
            lstrcpy (pszURL, szHttp);
        lstrcat (pszURL, pszServer);
    }

    lstrcat (pszURL, szSlash);
    lstrcat (pszURL, pszEncodedName);
    lstrcat (pszURL, szPrinter);

    if (pszQueryString) {
        lstrcat (pszURL, TEXT ("?") );
        lstrcat (pszURL, pszQueryString);
    }

    bRet = TRUE;

Cleanup:
    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return bRet;

}

/********************************************************************************

Name:
    GetWebUIUrl

Description:

    Given the server name and the printer name, return the Url for webpnp
    Currently, the URL is
        http://servername/printers/ipp_0004.asp?epirnter=encoded printername

Arguments:

    pszServer:      The server name
    pszPrinterName: The printer name (unicode string)
    pszURL:         The output URL buffer
    lpdwSize:       The size of the URL buffer (in Character)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL GetWebUIUrl (LPCTSTR pszServer, LPCTSTR pszPrinterName, LPTSTR pszURL,
                  LPDWORD lpdwSize)
{
    static TCHAR szHttp[]       = TEXT ("http://");
    static TCHAR szPrinter[]    = TEXT ("/printers/ipp_0004.asp?eprinter=");
    LPTSTR pszEncodedName       = NULL;
    DWORD dwEncodedSize         = 0;
    DWORD dwSize                = 0;
    DWORD bRet                  = FALSE;

    if (!pszPrinterName || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // Calculate buffer size
    EncodePrinterName (pszPrinterName, NULL, &dwEncodedSize);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    dwSize = (DWORD)(2 + dwEncodedSize
             + COUNTOF (szHttp) + COUNTOF (szPrinter)
             + ((pszServer)? lstrlen (pszServer):0));


    if (!pszURL || dwSize > *lpdwSize ) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwSize;
        return FALSE;
    }

    if (! (pszEncodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwEncodedSize)))
        goto Cleanup;

    if (!EncodePrinterName (pszPrinterName, pszEncodedName, &dwEncodedSize))
        goto Cleanup;

    if (pszServer) {
        lstrcpy (pszURL, szHttp);
        lstrcat (pszURL, pszServer);
    }

    lstrcat (pszURL, szPrinter);
    lstrcat (pszURL, pszEncodedName);

    bRet = TRUE;

Cleanup:
    if (pszEncodedName) {
        LocalFree (pszEncodedName);
    }
    return bRet;

}

/********************************************************************************

Name:
    AssignString

Description:

    Perform an assign operation
     l = r

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.
********************************************************************************/
BOOL AssignString (
    LPTSTR &l,
    LPCTSTR r)
{

    if (l) {
        LocalFree (l);
        l = NULL;
    }

    if (!r) {
        return TRUE;
    }
    else if (l = (LPTSTR) LocalAlloc (LPTR, (1 + lstrlen (r)) * sizeof (TCHAR))) {
        lstrcpy( l, r );
        return TRUE;
    }

    return FALSE;
}


/****************************************************************** Method ***\
* CWebLst::CWebLst (Constructor)
*
*   Initializes the CWebLst object.
*
\*****************************************************************************/
CWebLst::CWebLst(VOID)
{
    m_cbMax  = WEBLST_BLKSIZE;
    m_cbLst  = 0;
    m_pbLst  = (PBYTE)webAlloc(m_cbMax);
    m_pbPtr  = m_pbLst;
    m_cItems = 0;
}


/****************************************************************** Method ***\
* CWebLst::~CWebLst (Destructor)
*
*   Free up the CWebLst object.
*
\*****************************************************************************/
CWebLst::~CWebLst(VOID)
{
    webFree(m_pbLst);
}


/****************************************************************** Method ***\
* CWebLst::Add
*
*   Add an item to our list.
*
\*****************************************************************************/
BOOL CWebLst::Add(
    PCTSTR lpszName)
{
    PBYTE pbNew;
    DWORD cbPtr;
    DWORD cbNew;
    DWORD cbStr;
    BOOL  bRet = FALSE;


    if (m_pbLst) {

        // Reallocate the buffer is a bigger size is necessary.
        //
        cbStr = webStrSize(lpszName);

        if ((m_cbLst + cbStr) > m_cbMax) {

            cbNew = m_cbMax + WEBLST_BLKSIZE;
            cbPtr = (DWORD)(m_pbPtr - m_pbLst);

            if (pbNew = (PBYTE)webRealloc(m_pbLst, m_cbMax, cbNew)) {

                m_cbMax = cbNew;
                m_pbLst = pbNew;
                m_pbPtr = m_pbLst + (DWORD_PTR)cbPtr;

            } else {

                goto AddEnd;
            }
        }


        // Copy the item.
        //
        memcpy(m_pbPtr, lpszName, cbStr);
        m_cbLst += cbStr;
        m_pbPtr += cbStr;

        m_cItems++;

        bRet = TRUE;
    }

AddEnd:

    return bRet;
}


/****************************************************************** Method ***\
* CWebLst::Count
*
*   Returns a count of items.
*
\*****************************************************************************/
DWORD CWebLst::Count(VOID)
{
    return m_cItems;
}


/****************************************************************** Method ***\
* CWebLst::Get
*
*   Retrieve current string.
*
\*****************************************************************************/
PCTSTR CWebLst::Get(VOID)
{
    return (m_cItems ? (PCTSTR)m_pbPtr : NULL);
}


/****************************************************************** Method ***\
* CWebLst::Next
*
*
\*****************************************************************************/
BOOL CWebLst::Next(VOID)
{
    m_pbPtr += webStrSize((PCTSTR)m_pbPtr);

    return (*m_pbPtr ? TRUE : FALSE);
}


/****************************************************************** Method ***\
* CWebLst::Reset
*
*
\*****************************************************************************/
VOID CWebLst::Reset(VOID)
{
    m_pbPtr = m_pbLst;
}

/*++

Routine Name:

    LoadLibraryFromSystem32

Routine Description:

    Load the dll from system32 directory

Arguments:

    lpLibFileName   - Library file name

Return Value:

    If the function succeeds, the return value is the handle;
    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

--*/
HINSTANCE
LoadLibraryFromSystem32(
    IN LPCTSTR lpLibFileName
    )
{
    HINSTANCE hLib = NULL;

    static const TCHAR cszBackSlash[] = TEXT("\\");
    static const TCHAR cszSystem32[] = TEXT("system32\\");

    TCHAR szWindowDir[MAX_PATH];
    LPTSTR pszPath = NULL;
    DWORD dwWinDirLen = 0;

    if (dwWinDirLen = GetSystemWindowsDirectory (szWindowDir, MAX_PATH))
    {
        pszPath = new TCHAR [dwWinDirLen + lstrlen (lpLibFileName) + COUNTOF (cszSystem32) + 2];

        if (pszPath)
        {
            lstrcpy (pszPath, szWindowDir);

            if (szWindowDir [dwWinDirLen - 1] != cszBackSlash[0])
            {
                lstrcat (pszPath, cszBackSlash);
            }

            lstrcat (pszPath, cszSystem32);
            lstrcat (pszPath, lpLibFileName);

            hLib = LoadLibrary(pszPath);
        }

        delete [] pszPath;
    }

    return hLib;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\webipp.h ===
/*****************************************************************************\
* MODULE: webipp.h
*
* This is the header module for webipp.c.  This contains the IPP 1.1 parser
* that encodes/decodes data for transfering across the HTTP wire.
*
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* history:
*   27-Oct-1997 <chriswil/v-chrisw> created.
*
\*****************************************************************************/
#ifndef _WEBIPP_H
#define _WEBIPP_H

#include <time.h>

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
extern "C" {        // when doing C++ stuff.
#endif

/***********************************************\
* Common Macros
*
\***********************************************/
#define offs(type, identifier) ((ULONG_PTR)&(((type)0)->identifier))


/***********************************************\
* Constant Values
*
\***********************************************/
#define IPP_BLOCK_SIZE  1024
#define IPP_VERSION     ((WORD)0x0100)
#define IPP_GETJOB_ALL  ((DWORD)0x7FFFFFFF)

#define IPPOBJ_MASK_SIZE     2


#define IPPTYPE_UNKNOWN 0
#define IPPTYPE_PRT     1
#define IPPTYPE_JOB     2
#define IPPTYPE_AUTH    3



#define IPP_ATR_ABSOLUTE     0
#define IPP_ATR_OFFSET      -1
#define IPP_ATR_OFFSETCONV  -2
#define IPP_ATR_TAG         -4


/***********************************************\
* IPP Element Sizes
*
*   These are used to identify the size of
*   IPP element values.
*
\***********************************************/
#define IPP_SIZEOFREQ   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFVER   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFLEN   sizeof(WORD)     // 2 bytes
#define IPP_SIZEOFTAG   sizeof(BYTE)     // 1 byte
#define IPP_SIZEOFINT   sizeof(DWORD)    // 4 bytes
#define IPP_SIZEOFBYTE  sizeof(BYTE)     // 1 bytes
#define IPP_SIZEOFHDR   (IPP_SIZEOFVER + IPP_SIZEOFREQ + IPP_SIZEOFINT)


/***********************************************\
* IPP Attribute Sizes
*
\***********************************************/
#define SIZE_TEXT           1023
#define SIZE_NAME            255
#define SIZE_KEYWORD         255
#define SIZE_KEYWORDNAME     255
#define SIZE_ENUM              4
#define SIZE_URI            1023
#define SIZE_URISCHEME        63
#define SIZE_CHARSET          63
#define SIZE_NATLANG          63
#define SIZE_MIMEMEDIA        63
#define SIZE_OCTSTRING      1023
#define SIZE_BOOLEAN           1
#define SIZE_INTEGER           4
#define SIZE_RANGEINTEGER      8
#define SIZE_DATETIME         11
#define SIZE_RESOLUTION        9


/***********************************************\
* IPP Job-State Codes
*
\***********************************************/
#define IPP_JOBSTATE_UNKNOWN            ((BYTE)0)
#define IPP_JOBSTATE_PENDING            ((BYTE)3)
#define IPP_JOBSTATE_PENDINGHELD        ((BYTE)4)
#define IPP_JOBSTATE_PROCESSING         ((BYTE)5)
#define IPP_JOBSTATE_PROCESSEDSTOPPED   ((BYTE)6)
#define IPP_JOBSTATE_CANCELLED          ((BYTE)7)
#define IPP_JOBSTATE_ABORTED            ((BYTE)8)
#define IPP_JOBSTATE_COMPLETED          ((BYTE)9)


/***********************************************\
* IPP Printer-State Codes
*
\***********************************************/
#define IPP_PRNSTATE_UNKNOWN            ((DWORD)0)
#define IPP_PRNSTATE_IDLE               ((DWORD)3)
#define IPP_PRNSTATE_PROCESSING         ((DWORD)4)
#define IPP_PRNSTATE_STOPPED            ((DWORD)5)


/***********************************************\
* IPP Request/Response Codes
*
\***********************************************/
#define IPP_REQ_GETOPERATION    ((WORD)0x0001)
#define IPP_REQ_PRINTJOB        ((WORD)0x0002)  // Implemented
#define IPP_REQ_PRINTURI        ((WORD)0x0003)
#define IPP_REQ_VALIDATEJOB     ((WORD)0x0004)  // Implemented
#define IPP_REQ_CREATEJOB       ((WORD)0x0005)
#define IPP_REQ_SENDDOC         ((WORD)0x0006)
#define IPP_REQ_SENDURI         ((WORD)0x0007)
#define IPP_REQ_CANCELJOB       ((WORD)0x0008)  // Implemented
#define IPP_REQ_GETJOB          ((WORD)0x0009)  // Implemented
#define IPP_REQ_ENUJOB          ((WORD)0x000A)  // Implemented
#define IPP_REQ_GETPRN          ((WORD)0x000B)  // Implemented
#define IPP_REQ_PAUSEJOB        ((WORD)0x000C)  // Implemented
#define IPP_REQ_RESUMEJOB       ((WORD)0x000D)  // Implemented
#define IPP_REQ_RESTARTJOB      ((WORD)0x000E)  // Implemented
#define IPP_REQ_REPROCESSJOB    ((WORD)0x000F)
#define IPP_REQ_PAUSEPRN        ((WORD)0x0010)  // Implemented
#define IPP_REQ_RESUMEPRN       ((WORD)0x0011)  // Implemented
#define IPP_REQ_CANCELPRN       ((WORD)0x0012)  // Implemented
#define IPP_REQ_FORCEAUTH       ((WORD)0x4000)

#define IPP_RESPONSE            ((WORD)0x1000)
#define IPP_RET_PRINTJOB        (IPP_RESPONSE | IPP_REQ_PRINTJOB)
#define IPP_RET_VALIDATEJOB     (IPP_RESPONSE | IPP_REQ_VALIDATEJOB)
#define IPP_RET_CANCELJOB       (IPP_RESPONSE | IPP_REQ_CANCELJOB)
#define IPP_RET_GETJOB          (IPP_RESPONSE | IPP_REQ_GETJOB)
#define IPP_RET_ENUJOB          (IPP_RESPONSE | IPP_REQ_ENUJOB)
#define IPP_RET_GETPRN          (IPP_RESPONSE | IPP_REQ_GETPRN)
#define IPP_RET_PAUSEJOB        (IPP_RESPONSE | IPP_REQ_PAUSEJOB)
#define IPP_RET_RESUMEJOB       (IPP_RESPONSE | IPP_REQ_RESUMEJOB)
#define IPP_RET_RESTARTJOB      (IPP_RESPONSE | IPP_REQ_RESTARTJOB)
#define IPP_RET_PAUSEPRN        (IPP_RESPONSE | IPP_REQ_PAUSEPRN)
#define IPP_RET_RESUMEPRN       (IPP_RESPONSE | IPP_REQ_RESUMEPRN)
#define IPP_RET_CANCELPRN       (IPP_RESPONSE | IPP_REQ_CANCELPRN)
#define IPP_RET_FORCEAUTH       (IPP_RESPONSE | IPP_REQ_FORCEAUTH)


/***********************************************\
* IPP Response Error Codes
*
\***********************************************/
#define IPPRSP_SUCCESS    ((WORD)0x0000)    // Standard
#define IPPRSP_SUCCESS1   ((WORD)0x0001)    // Standard
#define IPPRSP_SUCCESS2   ((WORD)0x0002)    // Standard

#define IPPRSP_ERROR_400  ((WORD)0x0400)    // Standard
#define IPPRSP_ERROR_401  ((WORD)0x0401)    // Standard
#define IPPRSP_ERROR_402  ((WORD)0x0402)    // Standard
#define IPPRSP_ERROR_403  ((WORD)0x0403)    // Standard
#define IPPRSP_ERROR_404  ((WORD)0x0404)    // Standard
#define IPPRSP_ERROR_405  ((WORD)0x0405)    // Standard
#define IPPRSP_ERROR_406  ((WORD)0x0406)    // Standard
#define IPPRSP_ERROR_407  ((WORD)0x0407)    // Standard
#define IPPRSP_ERROR_408  ((WORD)0x0408)    // Standard
#define IPPRSP_ERROR_409  ((WORD)0x0409)    // Standard
#define IPPRSP_ERROR_40A  ((WORD)0x040A)    // Standard
#define IPPRSP_ERROR_40B  ((WORD)0x040B)    // Standard
#define IPPRSP_ERROR_40C  ((WORD)0x040C)    // Standard
#define IPPRSP_ERROR_40D  ((WORD)0x040D)    // Standard
#define IPPRSP_ERROR_40E  ((WORD)0x040E)    // Standard
#define IPPRSP_ERROR_500  ((WORD)0x0500)    // Standard
#define IPPRSP_ERROR_501  ((WORD)0x0501)    // Standard
#define IPPRSP_ERROR_502  ((WORD)0x0502)    // Standard
#define IPPRSP_ERROR_503  ((WORD)0x0503)    // Standard
#define IPPRSP_ERROR_504  ((WORD)0x0504)    // Standard
#define IPPRSP_ERROR_505  ((WORD)0x0505)    // Standard
#define IPPRSP_ERROR_506  ((WORD)0x0506)    // Standard
#define IPPRSP_ERROR_540  ((WORD)0x0540)    // Extended

#define SUCCESS_RANGE(wRsp) ((BOOL)((wRsp >= 0x0000) && (wRsp <= 0x00FF)))

#define ERROR_RANGE(wReq)                                          \
    (((wReq >= IPPRSP_ERROR_400) && (wReq <= IPPRSP_ERROR_40E)) || \
     ((wReq >= IPPRSP_ERROR_500) && (wReq <= IPPRSP_ERROR_506)) || \
     ((wReq == IPPRSP_ERROR_540)))


#define REQID_RANGE(idReq) (((DWORD)idReq >= 1) && ((DWORD)idReq <= 0x7FFFFFFF))


/***********************************************\
* IPP Attribute Delimiter Tags
*
\***********************************************/
#define IPP_TAG_DEL_RESERVED    ((BYTE)0x00)    //
#define IPP_TAG_DEL_OPERATION   ((BYTE)0x01)    //
#define IPP_TAG_DEL_JOB         ((BYTE)0x02)    //
#define IPP_TAG_DEL_DATA        ((BYTE)0x03)    //
#define IPP_TAG_DEL_PRINTER     ((BYTE)0x04)    //
#define IPP_TAG_DEL_UNSUPPORTED ((BYTE)0x05)    //

#define IPP_TAG_OUT_UNSUPPORTED ((BYTE)0x10)    //
#define IPP_TAG_OUT_DEFAULT     ((BYTE)0x11)    //
#define IPP_TAG_OUT_NONE        ((BYTE)0x12)    //
#define IPP_TAG_OUT_COMPOUND    ((BYTE)0x13)    //

#define IPP_TAG_INT_INTEGER     ((BYTE)0x21)    // sizeof(DWORD)
#define IPP_TAG_INT_BOOLEAN     ((BYTE)0x22)    // sizeof(BYTE)
#define IPP_TAG_INT_ENUM        ((BYTE)0x23)    // sizeof(DWORD)

#define IPP_TAG_OCT_STRING      ((BYTE)0x30)    // UTF-8
#define IPP_TAG_OCT_DATETIME    ((BYTE)0x31)    // UTF-8
#define IPP_TAG_OCT_RESOLUTION  ((BYTE)0x32)    // UTF-8
#define IPP_TAG_OCT_RANGEOFINT  ((BYTE)0x33)    // UTF-8
#define IPP_TAG_OCT_DICTIONARY  ((BYTE)0x34)    // UTF-8
#define IPP_TAG_OCT_TXTWITHLANG ((BYTE)0x35)
#define IPP_TAG_OCT_NMEWITHLANG ((BYTE)0x36)

#define IPP_TAG_CHR_TEXT        ((BYTE)0x41)    // CharSet Dependent
#define IPP_TAG_CHR_NAME        ((BYTE)0x42)    // CharSet Dependent
#define IPP_TAG_CHR_KEYWORD     ((BYTE)0x44)    // US-ASCII
#define IPP_TAG_CHR_URI         ((BYTE)0x45)    // US-ASCII
#define IPP_TAG_CHR_URISCHEME   ((BYTE)0x46)    // US-ASCII
#define IPP_TAG_CHR_CHARSET     ((BYTE)0x47)    // US-ASCII
#define IPP_TAG_CHR_NATURAL     ((BYTE)0x48)    // US-ASCII
#define IPP_TAG_CHR_MEDIA       ((BYTE)0x49)    // US-ASCII


#define IPP_MANDITORY ((BYTE)0x00)
#define IPP_OPTIONAL  ((BYTE)0x10)
#define IPP_MULTIPLE  ((BYTE)0x20)
#define IPP_HIT       ((BYTE)0x80)

/***********************************************\
* IPP Tag-Value Ranges
*
\***********************************************/
#define IS_TAG_DELIMITER(bTag)   ((BOOL)((bTag >= 0x00) && (bTag <= 0x0F)))
#define IS_TAG_ATTRIBUTE(bTag)   ((BOOL)((bTag >= 0x10) && (bTag <= 0xFF)))
#define IS_TAG_OUTBOUND(bTag)    ((BOOL)((bTag >= 0x10) && (bTag <= 0x1F)))
#define IS_TAG_INTEGER(bTag)     ((BOOL)((bTag >= 0x20) && (bTag <= 0x2F)))
#define IS_TAG_OCTSTR(bTag)      ((BOOL)((bTag >= 0x30) && (bTag <= 0x3F)))
#define IS_TAG_CHRSTR(bTag)      ((BOOL)((bTag >= 0x40) && (bTag <= 0x5F)))
#define IS_TAG_CHARSETSTR(bTag)  ((BOOL)((bTag == 0x41) || (bTag == 0x42)))
#define IS_RANGE_DELIMITER(bTag) ((BOOL)((bTag >= 0x00) && (bTag <= 0x05)))

#define IS_TAG_COMPOUND(bTag)    ((BOOL)((bTag == 0x35) || (bTag == 0x36)))

/***********************************************\
* IPP Request Flags
*
\***********************************************/

#define RA_JOBURI                      0x00000001
#define RA_JOBID                       0x00000002
#define RA_JOBSTATE                    0x00000004
#define RA_JOBNAME                     0x00000008
#define RA_JOBSIZE                     0x00000010
#define RA_JOBUSER                     0x00000020
#define RA_JOBPRIORITY                 0x00000040
#define RA_JOBFORMAT                   0x00000080
#define RA_JOBSTATE_REASONS            0x00000100
#define RA_JOBSTATE_MESSAGE            0x00000200
#define RA_JOBCOUNT                    0x00000400
#define RA_SHEETSTOTAL                 0x00000800
#define RA_SHEETSCOMPLETED             0x00001000
#define RA_PRNURI                      0x00002000
#define RA_PRNSTATE                    0x00004000
#define RA_PRNNAME                     0x00008000
#define RA_PRNMAKE                     0x00010000
#define RA_URISUPPORTED                0x00020000
#define RA_URISECURITY                 0x00040000
#define RA_ACCEPTINGJOBS               0x00080000
#define RA_CHRSETCONFIGURED            0x00100000
#define RA_CHRSETSUPPORTED             0x00200000
#define RA_NATLNGCONFIGURED            0x00400000
#define RA_NATLNGSUPPORTED             0x00800000
#define RA_DOCDEFAULT                  0x01000000
#define RA_DOCSUPPORTED                0x02000000
#define RA_PDLOVERRIDE                 0x04000000
#define RA_UPTIME                      0x08000000
#define RA_OPSSUPPORTED                0x10000001
#define RA_JOBKSUPPORTED               0x10000002
#define RA_JOBSCOMPLETED               0x10000004
#define RA_JOBSUNCOMPLETED             0x10000008
#define RA_TIMEATCREATION              0x10000010



#define IPP_REQALL_IDX       8
#define IPP_REQENU_IDX       9
#define IPP_REQJDSC_IDX     10
#define IPP_REQJTMP_IDX     11
#define IPP_REQPDSC_IDX     12
#define IPP_REQPTMP_IDX     13
#define IPP_REQCLEAR_IDX    14

#define IPP_REQALL      ((DWORD)0x80000000)
#define IPP_REQENU      ((DWORD)0x90000000)
#define IPP_REQJDSC     ((DWORD)0xA0000000)
#define IPP_REQJTMP     ((DWORD)0xB0000000)
#define IPP_REQPDSC     ((DWORD)0xC0000000)
#define IPP_REQPTMP     ((DWORD)0xD0000000)
#define IPP_REQCLEAR    ((DWORD)0xE0000000)


/***********************************************\
* WebIppRcvData Return Codes
*
*   Receive API codes.  These are our internal
*   return-codes for the WebIpp routines.  They
*   have no connection to the IPP spec, but are
*   needed to let the caller know status of our
*   IPP handler-routines.
*
\***********************************************/
#define WEBIPP_OK              0
#define WEBIPP_FAIL            1
#define WEBIPP_MOREDATA        2
#define WEBIPP_BADHANDLE       3
#define WEBIPP_NOMEMORY        4


/***********************************************\
* IPP Job/Printer Structures
*
* These are meant to provide additional
* information to the standard W32 Spooler
* structures.
*
\***********************************************/
typedef struct _JOB_INFO_IPP {

     LPTSTR pPrnUri;
     LPTSTR pJobUri;
     DWORD  cJobs;

} JOB_INFO_IPP;
typedef JOB_INFO_IPP *PJOB_INFO_IPP;
typedef JOB_INFO_IPP *LPJOB_INFO_IPP;

typedef struct _IPPJI2 {

    JOB_INFO_2   ji2;
    JOB_INFO_IPP ipp;

} IPPJI2;
typedef IPPJI2 *PIPPJI2;
typedef IPPJI2 *LPIPPJI2;

typedef struct _PRINTER_INFO_IPP {

    LPTSTR pPrnUri;
    LPTSTR pUsrName;
    time_t dwPowerUpTime;   // This stores the T0 time of the printer in UCT, it is intentionally
                           // signed so that we can support Printers who's T0 is smaller than
                           // our T0 (1 Jan 1970) 
} PRINTER_INFO_IPP;

typedef PRINTER_INFO_IPP *PPRINTER_INFO_IPP;
typedef PRINTER_INFO_IPP *LPPRINTER_INFO_IPP;

typedef struct _IPPPI2 {

    PRINTER_INFO_2   pi2;
    PRINTER_INFO_IPP ipp;

} IPPPI2;
typedef IPPPI2 *PIPPPI2;
typedef IPPPI2 *LPIPPPI2;


/***********************************************\
* IPP Return Structures
*
*   IPPRET_JOB    - Job Information Response.
*   IPPRET_PRN    - Printer Information Response.
*   IPPRET_ENUJOB - Enum-Job.
*   IPPRET_AUTH   - Authentication.
*
\***********************************************/
typedef struct _IPPRET_ALL {

    DWORD cbSize;        // Size of entire structure.
    DWORD dwLastError;   // LastError.
    WORD  wRsp;          // Response Code.
    BOOL  bRet;          // Return Code.

} IPPRET_ALL;
typedef IPPRET_ALL *PIPPRET_ALL;
typedef IPPRET_ALL *LPIPPRET_ALL;

typedef IPPRET_ALL *PIPPRET_AUTH;
typedef IPPRET_ALL *LPIPPRET_AUTH;

typedef struct _IPPRET_JOB {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwLastError; // LastError for failed calls.
    WORD   wRsp;        // Response Code.
    BOOL   bRet;        // Return code for job calls.
    BOOL   bValidate;   // Is this only a validation request.
    IPPJI2 ji;          // Job-Information.

} IPPRET_JOB;
typedef IPPRET_JOB *PIPPRET_JOB;
typedef IPPRET_JOB *LPIPPRET_JOB;

typedef struct _IPPRET_PRN {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwLastError; // LastError for failed calls.
    WORD   wRsp;        // Response Code.
    BOOL   bRet;        // Return code for printer calls.
    IPPPI2 pi;          // Printer-Information.

} IPPRET_PRN;
typedef IPPRET_PRN *PIPPRET_PRN;
typedef IPPRET_PRN *LPIPPRET_PRN;

typedef struct _IPPRET_ENUJOB {

    DWORD    cbSize;       // Size of entire structure (including enum-data).
    DWORD    dwLastError;  // LastError for failed calls.
    WORD     wRsp;         // Response Code.
    BOOL     bRet;         // EnumJob/Get Return-Code.
    DWORD    cItems;       // Number of items in enum.
    DWORD    cbItems;      // Size of Enum Data.
    LPIPPJI2 pItems;       //

} IPPRET_ENUJOB;
typedef IPPRET_ENUJOB *PIPPRET_ENUJOB;
typedef IPPRET_ENUJOB *LPIPPRET_ENUJOB;


/***********************************************\
* IPP Request Structures
*
*   IPPREQ_PRTJOB - Print-Job/Validate-Job.
*   IPPREQ_ENUJOB - Enum-Job.
*   IPPREQ_GETJOB - Get-Job.
*   IPPREQ_SETJOB - Set-Job.
*   IPPREQ_GETPRN - Get-Printer.
*   IPPREQ_SETPRN - Set-Printer.
*   IPPREQ_AUTH   - Authentication.
*
\***********************************************/
typedef struct _IPPREQ_ALL {

    DWORD cbSize;        // Size of entire structure.

} IPPREQ_ALL;
typedef IPPREQ_ALL *PIPPREQ_ALL;
typedef IPPREQ_ALL *LPIPPREQ_ALL;

typedef IPPREQ_ALL IPPREQ_AUTH;
typedef IPPREQ_ALL *PIPPREQ_AUTH;
typedef IPPREQ_ALL *LPIPPREQ_AUTH;

typedef struct _IPPREQ_PRTJOB {

    DWORD  cbSize;      // Size of entire structure.
    BOOL   bValidate;   // Indicates whether this is only a validation.
    LPTSTR pDocument;   // Document name.
    LPTSTR pUserName;   // Requesting User name.
    LPTSTR pPrnUri;     // Printer Uri string.

} IPPREQ_PRTJOB;
typedef IPPREQ_PRTJOB *PIPPREQ_PRTJOB;
typedef IPPREQ_PRTJOB *LPIPPREQ_PRTJOB;

typedef struct _IPPREQ_SETJOB {

    DWORD  cbSize;      // Size of entire structure.
    DWORD  dwCmd;       // Job command.
    DWORD  idJob;       // Job ID.
    LPTSTR pPrnUri;     // Job Uri.

} IPPREQ_SETJOB;
typedef IPPREQ_SETJOB *PIPPREQ_SETJOB;
typedef IPPREQ_SETJOB *LPIPPREQ_SETJOB;

typedef struct _IPPREQ_ENUJOB {

    DWORD  cbSize;
    DWORD  cJobs;
    LPTSTR pPrnUri;

} IPPREQ_ENUJOB;
typedef IPPREQ_ENUJOB *PIPPREQ_ENUJOB;
typedef IPPREQ_ENUJOB *LPIPPREQ_ENUJOB;

typedef struct _IPPREQ_GETPRN {

    DWORD  cbSize;
    DWORD  dwAttr;
    LPTSTR pPrnUri;

} IPPREQ_GETPRN;
typedef IPPREQ_GETPRN *PIPPREQ_GETPRN;
typedef IPPREQ_GETPRN *LPIPPREQ_GETPRN;

typedef struct _IPPREQ_GETJOB {

    DWORD  cbSize;
    DWORD  idJob;
    LPTSTR pPrnUri;

} IPPREQ_GETJOB;
typedef IPPREQ_GETJOB *PIPPREQ_GETJOB;
typedef IPPREQ_GETJOB *LPIPPREQ_GETJOB;

typedef struct _IPPREQ_SETPRN {

    DWORD  cbSize;
    DWORD  dwCmd;
    LPTSTR pUserName;
    LPTSTR pPrnUri;

} IPPREQ_SETPRN;
typedef IPPREQ_SETPRN *PIPPREQ_SETPRN;
typedef IPPREQ_SETPRN *LPIPPREQ_SETPRN;


/***********************************************\
* IPP Attribute Structure.
*
\***********************************************/
typedef struct _IPPATTR {

    BYTE   bTag;
    WORD   cbName;
    LPTSTR lpszName;
    WORD   cbValue;
    LPVOID lpValue;

} IPPATTR;
typedef IPPATTR *PIPPATTR;
typedef IPPATTR *LPIPPATTR;


/***********************************************\
* IPP Error-Mappings
*
\***********************************************/
typedef struct _IPPERROR {

    WORD   wRsp;
    DWORD  dwLE;
    PCTSTR pszStr;

} IPPERROR;
typedef IPPERROR *PIPPERROR;
typedef IPPERROR *LPIPPERROR;


/***********************************************\
* IPP Default-Error-Mappings
*
\***********************************************/
typedef struct _IPPDEFERROR {

    DWORD dwLE;
    WORD  wRsp;

} IPPDEFERROR;
typedef IPPDEFERROR *PIPPDEFERROR;
typedef IPPDEFERROR *LPIPPDEFERROR;

#define IPPFLG_VALID        1
#define IPPFLG_CHARSET      2
#define IPPFLG_NATLANG      4
#define IPPFLG_USEFIDELITY  8

/***********************************************\
* IPP Object Structure.
*
\***********************************************/
typedef struct _IPPOBJ {

    WORD     wReq;        // Open Request being processed.
    WORD     wError;      // Used to store ipp errors during receive processing.
    DWORD    idReq;       // Request Id.
    UINT     uCPRcv;      // Codepage translation for receiving IPP Streams.
    DWORD    fState;      //
    DWORD    cbIppMax;    // Maximum size of hdr-Buffer.
    DWORD    cbIppHdr;    // Current size of hdr-buffer data.
    LPBYTE   lpIppHdr;    // Buffer to contain IPP-Stream-Header.
    LPBYTE   lpRawDta;    // Aligned (temporary) data buffer.
    LPWEBLST pwlUns;      // Unsupported attributes list.

    DWORD    fReq[IPPOBJ_MASK_SIZE];

} IPPOBJ;
typedef IPPOBJ *PIPPOBJ;
typedef IPPOBJ *LPIPPOBJ;


/***********************************************\
* Request Info
*
\***********************************************/
typedef struct _REQINFO {

    DWORD   idReq;
    UINT    cpReq;
    PWEBLST pwlUns;
    BOOL    bFidelity;
    DWORD   fReq[IPPOBJ_MASK_SIZE];

} REQINFO;
typedef REQINFO *PREQINFO;
typedef REQINFO *LPREQINFO;

/***********************************************\
* TypeDefs
*
\***********************************************/
typedef DWORD (*PFNRET)(LPIPPOBJ lpObj, LPBYTE* lplpRawHdr, LPDWORD lpcbRawHdr);


/***********************************************\
* IPP Attribute Structre (X)
*
\***********************************************/
typedef struct _IPPATTRX {

    BYTE    bTag;
    DWORD   fReq;
    int     nVal;
    LPCTSTR pszNam;
    LPVOID  pvVal;

} IPPATTRX;
typedef IPPATTRX *PIPPATTRX;
typedef IPPATTRX *LPIPPATTRX;


/***********************************************\
* IPP Attribute Structre (Y)
*
\***********************************************/
typedef struct _IPPATTRY {

    LPSTR pszNam;
    DWORD cbNam;
    LPSTR pszVal;
    DWORD cbVal;

} IPPATTRY;
typedef IPPATTRY *PIPPATTRY;
typedef IPPATTRY *LPIPPATTRY;

/***********************************************\
* IPP Conversion Structure
*
\***********************************************/
typedef struct _IPPSNDRCV {

    WORD       wReq;
    PBYTE      pbReqForm;
    PBYTE      pbRspForm;
    LPIPPATTRX paReq;
    DWORD      cbReq;
    LPIPPATTRX paRsp;
    DWORD      cbRsp;
    PFNRET     pfnRcvRet;

} IPPSNDRCV;
typedef IPPSNDRCV *PIPPSNDRCV;
typedef IPPSNDRCV *LPIPPSNDRCV;


/***********************************************\
* Flag/String Structure.
*
\***********************************************/
typedef struct _FLGSTR {

    DWORD   fFlag;
    LPCTSTR pszStr;

} FLGSTR;
typedef FLGSTR *PFLGSTR;
typedef FLGSTR *LPFLGSTR;


/************************************************
** Definition of Allocator (for outside functions)
************************************************/
typedef LPVOID (*ALLOCATORFN)(DWORD cb);
         
/***********************************************\
* WebIpp Object routines.
*
\***********************************************/
DWORD WebIppSndData(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpDta,
    DWORD     cbDta,
    LPBYTE*   lpOut,
    LPDWORD   lpcbOut);

HANDLE WebIppRcvOpen(
    WORD);

DWORD WebIppRcvData(
    HANDLE  hIpp,
    LPBYTE  lpData,
    DWORD   cbData,
    LPBYTE  *lplpHdr,
    LPDWORD lpdwHdr,
    LPBYTE  *lplpDta,
    LPDWORD lpdwDta);

BOOL WebIppRcvClose(
    HANDLE hIpp);

WORD WebIppGetError(
    HANDLE hIpp);

WORD WebIppLeToRsp(
    DWORD dwLastError);

DWORD WebIppRspToLe(
    WORD wRsp);

BOOL WebIppGetReqInfo(
    HANDLE    hIpp,
    LPREQINFO lpri);

BOOL WebIppFreeMem(
    LPVOID lpMem);

LPIPPJI2 WebIppCvtJI2toIPPJI2(
    IN     LPCTSTR      lpszJobBase,
    IN OUT LPDWORD      lpcbJobs,
    IN     DWORD        cJobs,
    IN     LPJOB_INFO_2 lpJI2Src);

LPJOB_INFO_2 WebIppPackJI2(
    IN  LPJOB_INFO_2 lpji2,
    OUT LPDWORD      lpcbSize,
    IN  ALLOCATORFN  pfnAlloc
);

/***********************************************\
* Request Creation Routines
*
\***********************************************/
PIPPREQ_PRTJOB WebIppCreatePrtJobReq(
    BOOL    bValidate,
    LPCTSTR lpszUser,
    LPCTSTR lpszDoc,
    LPCTSTR lpszPrnUri);

PIPPREQ_ENUJOB WebIppCreateEnuJobReq(
    DWORD   cJobs,
    LPCTSTR lpszPrnUri);

PIPPREQ_SETJOB WebIppCreateSetJobReq(
    DWORD   idJob,
    DWORD   dwCmd,
    LPCTSTR lpszPrnUri);

PIPPREQ_GETJOB WebIppCreateGetJobReq(
    DWORD   idJob,
    LPCTSTR lpszPrnUri);

PIPPREQ_GETPRN WebIppCreateGetPrnReq(
    DWORD   dwAttr,
    LPCTSTR lpszPrnUri);

PIPPREQ_SETPRN WebIppCreateSetPrnReq(
    DWORD   dwCmd,
    LPCTSTR lpszPrnName,
    LPCTSTR lpszPrnUri);

PIPPREQ_AUTH WebIppCreateAuthReq(VOID);


/***********************************************\
* Response Creation Routines
*
\***********************************************/
PIPPRET_JOB WebIppCreateJobRet(
    WORD           wRsp,
    BOOL           bRet,
    BOOL           bValidate,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp);

PIPPRET_PRN WebIppCreatePrnRet(
    WORD               wRsp,
    BOOL               bRet,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp);


PIPPRET_ENUJOB WebIppCreateEnuJobRet(
    WORD     wRsp,
    BOOL     bRet,
    DWORD    cbJobs,
    DWORD    cJobs,
    LPIPPJI2 lpbJobs);

PIPPRET_ALL WebIppCreateBadRet(
    WORD wRsp,
    BOOL bRet);

PIPPRET_AUTH WebIppCreateAuthRet(
    WORD wRsp,
    BOOL bRet);

BOOL WebIppConvertSystemTime(
    IN OUT LPSYSTEMTIME pSystemTime,
    IN     time_t       dwPrinterT0);


#ifdef UNICODE

    #define WEB_IPP_ASSERT(Expr) ASSERT(Expr)

#else

    #define WEB_IPP_ASSERT(Expr) // Need to figure out what to do here
    
#endif

#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif              //
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\clusupg.cxx ===
/*++

  Copyright (c) 2000 Microsoft Corporation
  All rights reserved.

  Module Name: 
      
      clusupg.cxx

  Purpose: 
  
      Upgrade printer drivers for clusters spoolers 

  Author: 
        

  Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/*++

Routine Name:

    PSetupUpgradeClusterDriversW

Routine Description:

    Upgrade function. Called by a cluster spooler to upgrade its drivers.
    This function is called the first time when the cluster spooler fails 
    over to a node that was upgraded. This function is called via rundll32.

Arguments:

    hwnd            - Window handle of stub window.
    hInstance,      - Rundll instance handle.
    pszCmdLine      - Pointer to command line.
    nCmdShow        - Show command value always TRUE.

Return Value:

    Returns the last error code.  This can be read by the spooler by getting the return code from the process.

--*/
DWORD
PSetupUpgradeClusterDriversW(
    IN HWND        hWnd,
    IN HINSTANCE   hInstance,
    IN LPCTSTR     pszCmdLine,
    IN UINT        nCmdShow
    )
{
    LPBYTE  pDriverEnum = NULL;
    DWORD   cbNeeded;
    DWORD   cStrucs;
    DWORD   dwError = ERROR_INVALID_PARAMETER;
    LPTSTR  pszServer = const_cast<LPTSTR>(pszCmdLine);
    
    if (pszServer)
    {
        //
        // Enumerate all the drivers on the server
        //
        dwError = EnumPrinterDrivers(pszServer,
                                     _T("all"),
                                     6,
                                     NULL,
                                     0,
                                     &cbNeeded,
                                     &cStrucs) ? ERROR_SUCCESS : GetLastError();
    
        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            if (pDriverEnum = static_cast<LPBYTE>(LocalAllocMem(cbNeeded)))
            {
                if (EnumPrinterDrivers(pszServer,
                                       _T("all"),
                                       6,
                                       pDriverEnum,
                                       cbNeeded,
                                       &cbNeeded,
                                       &cStrucs))
                {
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    LocalFreeMem(pDriverEnum);

                    pDriverEnum = NULL;
    
                    dwError = GetLastError();
                }
            }
            else
            {
                dwError = GetLastError();
            }
        }

        if (dwError==ERROR_SUCCESS && cStrucs) 
        {
             DRIVER_INFO_6 *pDrv     = NULL;
             UINT           uIndex   = 0;
             HINSTANCE      hLibrary = NULL;
             typedef (* PFNENTRY)(HWND, HINSTANCE, LPCTSTR, UINT);
             PFNENTRY       pfnEntry;

             //
             // Load printui and get the entry point
             //
             if ((hLibrary = LoadLibraryUsingFullPath(_T("printui.dll"))) &&
                 (pfnEntry = (PFNENTRY)GetProcAddress(hLibrary, "PrintUIEntryW"))
                )
             {
                 //
                 // Loop through drivers and try to upgrade them using the cab
                 //
                 for (uIndex = 0, pDrv=reinterpret_cast<LPDRIVER_INFO_6>(pDriverEnum); 
                      dwError == ERROR_SUCCESS && uIndex < cStrucs;
                      uIndex++, pDrv++
                     ) 
                 {
                     TString strCommand;
                     DWORD   cbNeeded   = 0;
                     LPCTSTR pszFormat  = _T("/q /Gw /ia /K /c \"%ws\" /m \"%ws\" /h \"%ws\" /v %u");
    
                     //
                     // Format the string that will be used as aparameter for printui
                     //
                     if (strCommand.bFormat(pszFormat, pszServer, pDrv->pName, pDrv->pEnvironment, pDrv->cVersion))
                     {
                         //
                         // This will try to upgrade the driver/ We don't care about the error. Even if a driver 
                         // couldn't be upgraded, we still want to loop and try to upgrade the other drivers
                         // 
                         dwError = (pfnEntry)(hWnd, hInstance, strCommand, 0);
                         
                         DBGMSG(DBG_WARN, ("Command %ws   dwError from printui %u\n", (LPCTSTR)strCommand, dwError));                      
                         
                         //
                         // The case statements reperesent errors where we cannot continue executing the
                         // printer driver update. This is when the spooler dies or the cluster group 
                         // becomes active on a different node
                         //
                         switch (dwError) 
                         {
                             case RPC_S_SERVER_UNAVAILABLE:
                             
                             //
                             // We can get access deined when the cluster group moves to a different node.
                             // Since this process executes in the local system acocunt, this account doesn't
                             // have permissins to install printer drivers on a remote machine
                             //    
                             case ERROR_ACCESS_DENIED:
                              
                             //
                             // The spooler returns this error when it cannot create temporary directories
                             // for driver upgrade
                             //
                             case ERROR_NO_SYSTEM_RESOURCES:

                             //
                             // printui returns this error when it cannot do OpenPrinter(\\server name).
                             // This means the cluster group is off line (inaccessible)
                             //
                             case ERROR_INVALID_PRINTER_NAME:    
                                 
                                 //
                                 // We will exit the loop since dwError is not error success
                                 //
                                 break;

                             default:

                                 //
                                 // We continue looping
                                 //
                                 dwError = ERROR_SUCCESS;
                         }
                     }                                  
                 }                 
             }
             else
             {
                 dwError = GetLastError();
             }

             if (hLibrary) 
             {
                 FreeLibrary(hLibrary);
             }
        }

        LocalFreeMem(pDriverEnum);        
    }
    
    DBGMSG(DBG_WARN, ("PSetupClusterDrivers Error %u \n", dwError));

    //
    // If an error occurs we call ExitProcess. Then the spooler picks up the 
    // error code using GetExitCodeProcess. If no error occurs, then we
    // terminate normally
    //
    if (dwError != ERROR_SUCCESS) 
    {
        ExitProcess(dwError);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\billbrd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Billbrd.c

Abstract:

    Code to put up a billboard saying printer drivers are getting upgraded.
    This lets the user know we are doing something and alive ..

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Apr-1995

Revision History:

--*/

#include "precomp.h"

BOOL
BillboardDlgProc(
    IN  HWND    hwnd,
    IN  UINT    uMsgId,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    return FALSE;
}


HWND
DisplayBillboard(
    IN  HWND    WindowToDisable
    )
{
    HWND    hwnd;

    return CreateDialog(ghInst, 
                        MAKEINTRESOURCE(IDD_BILLBOARD),
                        WindowToDisable,
                        BillboardDlgProc);
}

BOOL
KillBillboard(
    IN  HWND    hwnd
    )
{
    return DestroyWindow(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\webpnp.h ===
/*****************************************************************************\
* MODULE: webpnp.h
*
* This is the header module for webpnp.c.  This contains the routines
* necessary for processing .BIN files.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   25-Feb-1997 <chriswil> created.
*
\*****************************************************************************/
#ifndef _WEBPNP_H
#define _WEBPNP_H

#ifndef _WINSPOOL_
#include <winspool.h>
#endif


/*-----------------------------------*\
| webMakeOSInfo
|
|   Returns OSInfo from parameters.
|
\*-----------------------------------*/
_inline DWORD webMakeOSInfo(
    BYTE bArch,
    BYTE bPlatform,
    BYTE bMajVer,
    BYTE bMinVer)
{
    return (DWORD)MAKELONG(MAKEWORD(bArch, bPlatform), MAKEWORD(bMinVer, bMajVer));
}


/*-----------------------------------*\
| webCreateOSInfo
|
|   Builds an OS Info DWORD.
|
\*-----------------------------------*/
_inline DWORD webCreateOSInfo(VOID)
{
    SYSTEM_INFO   si;
    OSVERSIONINFO os;
    BYTE          bMaj;
    BYTE          bMin;
    BYTE          bArch;
    BYTE          bPlat;


    // Retrieve the OS version and architecture
    // information.
    //
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetSystemInfo(&si);
    GetVersionEx(&os);


    // Build our client-info return values.
    //
    bMaj  = (BYTE)(LOWORD(os.dwMajorVersion));
    bMin  = (BYTE)(LOWORD(os.dwMinorVersion));
    bPlat = (BYTE)(LOWORD(os.dwPlatformId));
    bArch = (BYTE)(LOBYTE(si.wProcessorArchitecture));

    return webMakeOSInfo(bArch, bPlat, bMaj, bMin);
}


/*-----------------------------------*\
| webGetOSArch
|
|   Returns architecture of os-info.
|
\*-----------------------------------*/
_inline WORD webGetOSArch(
    DWORD dwInfo)
{
    return (WORD)LOBYTE(LOWORD(dwInfo));
}


/*-----------------------------------*\
| webGetOSPlatform
|
|   Returns platform of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSPlatform(
    DWORD dwInfo)
{
    return (DWORD)HIBYTE(LOWORD(dwInfo));
}


/*-----------------------------------*\
| webGetOSMajorVer
|
|   Returns major version of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSMajorVer(
    DWORD dwInfo)
{
    return (DWORD)(HIBYTE(HIWORD(dwInfo)));
}


/*-----------------------------------*\
| webGetOSMinorVer
|
|   Returns minor version of os-info.
|
\*-----------------------------------*/
_inline DWORD webGetOSMinorVer(
    DWORD dwInfo)
{
    return (DWORD)(LOBYTE(HIWORD(dwInfo)));
}


#ifdef __cplusplus  // Place this here to prevent decorating of symbols
extern "C" {        // when doing C++ stuff.
#endif              //


// WEB_FILEMAP
//
typedef struct _WEB_FILEMAP {

    HANDLE hFile;
    HANDLE hMap;

} WEB_FILEMAP;
typedef WEB_FILEMAP      *PWEB_FILEMAP;
typedef WEB_FILEMAP NEAR *NPWEB_FILEMAP;
typedef WEB_FILEMAP FAR  *LPWEB_FILEMAP;


// Device-Bin Header Structure.
//
typedef struct _DEVBIN_HEAD {

    BOOL  bDevMode;
    DWORD cItems;

} DEVBIN_HEAD;
typedef DEVBIN_HEAD      *PDEVBIN_HEAD;
typedef DEVBIN_HEAD NEAR *NPDEVBIN_HEAD;
typedef DEVBIN_HEAD FAR  *LPDEVBIN_HEAD;


// Device-Bin Structure.
//
typedef struct _DEVBIN_INFO {

    DWORD cbSize;
    DWORD dwType;
    DWORD pKey;
    DWORD pValue;
    DWORD pData;
    DWORD cbData;

} DEVBIN_INFO;
typedef DEVBIN_INFO      *PDEVBIN_INFO;
typedef DEVBIN_INFO NEAR *NPDEVBIN_INFO;
typedef DEVBIN_INFO FAR  *LPDEVBIN_INFO;


// BIN-Routines.
//
#define WEB_ENUM_KEY  0
#define WEB_ENUM_ICM  1

typedef BOOL (CALLBACK* WEBENUMKEYPROC)(LPCTSTR, LPVOID);
typedef BOOL (CALLBACK* WEBENUMICMPROC)(LPCTSTR, LPCTSTR, LPVOID);
typedef BOOL (CALLBACK* WEBGENCOPYFILEPATHPROC)(LPCWSTR, LPCWSTR, LPBYTE, DWORD, LPWSTR, LPDWORD, LPWSTR, LPDWORD, DWORD);

BOOL webWritePrinterInfo(HANDLE, LPCTSTR);
BOOL webReadPrinterInfo(HANDLE, LPCTSTR, LPCTSTR);
BOOL webEnumPrinterInfo(HANDLE, DWORD, DWORD, FARPROC, LPVOID);


// SplLib Exports.
//
BOOL WebPnpEntry(LPCTSTR);
BOOL WebPnpPostEntry(BOOL, LPCTSTR, LPCTSTR, LPCTSTR);


#ifdef __cplusplus  // Place this here to prevent decorating of symbols
}                   // when doing C++ stuff.
#endif              //
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spllib\webipp.cxx ===
/*****************************************************************************\
* MODULE: webipp.cxx
*
* This module contains routines which handle the encoding/decoding of data
* sent across the HTTP wire to represent IPP packets.
*
* Public Interfaces
* -----------------
* WebIppRcvOpen    : returns a handle to an ipp-request stream
* WebIppRcvClose   : closes the handle to the ipp-request stream
* WebIppRcvData    : converts (Ipp -> W32)
* WebIppSndData    : converts (W32 -> Ipp)
* WebIppGetError   : returns ipp-error if WebIppSndData/WebIppRcvData fails
* WebIppLeToRsp    : returns an ipp-error mapping for a win32 error
* WebIppGetReqId   : returns the request-id for the ipp-stream
* WebIppGetUnsAttr : returns object with unsupported attribute strings
* WebIppGetReqFlag : returns a flag of requested-attributes from ipp-stream
* WebIppGetReqCp   : returns codepage that ipp-stream requests
* WebIppFreeMem    : used to free pointers returned from WebIpp* routines
*
* Definintions:
* ------------
* Ipp - Denotes Ipp-Formatted information according to the IPP protocol.
* W32 - Denotes win32 data that NT-Spooler understands.
*
* Copyright (C) 1996-1998 Microsoft Corporation
* Copyright (C) 1996-1998 Hewlett Packard
*
* history:
*   27-Oct-1997 <chriswil/v-chrisw> created.
*
\*****************************************************************************/

#include "spllibp.hxx"
#include <time.h>
#include <sys\timeb.h>
#include <wininet.h>
#include <winsock.h>

/*****************************************************************************\
* Static Strings
*
\*****************************************************************************/
static CONST TCHAR s_szJobLimit          [] = TEXT("limit");
static CONST TCHAR s_szJobName           [] = TEXT("job-name");
static CONST TCHAR s_szJobReqUser        [] = TEXT("requesting-user-name");
static CONST TCHAR s_szJobOrgUser        [] = TEXT("job-originating-user-name");
static CONST TCHAR s_szDocName           [] = TEXT("document-name");
static CONST TCHAR s_szJobId             [] = TEXT("job-id");
static CONST TCHAR s_szJobUri            [] = TEXT("job-uri");
static CONST TCHAR s_szJobState          [] = TEXT("job-state");
static CONST TCHAR s_szJobPri            [] = TEXT("job-priority");
static CONST TCHAR s_szJobKOctets        [] = TEXT("job-k-octets");
static CONST TCHAR s_szJobKOctetsProcess [] = TEXT("job-k-octets-processed");
static CONST TCHAR s_szJobSheets         [] = TEXT("job-media-sheets");
static CONST TCHAR s_szJobPrtUri         [] = TEXT("job-printer-uri");
static CONST TCHAR s_szTimeAtCreation    [] = TEXT("time-at-creation");
static CONST TCHAR s_szJobSheetsCompleted[] = TEXT("job-media-sheets-completed");
static CONST TCHAR s_szPrtUri            [] = TEXT("printer-uri");
static CONST TCHAR s_szPrtUriSupported   [] = TEXT("printer-uri-supported");
static CONST TCHAR s_szPrtUriSecurity    [] = TEXT("uri-security-supported");
static CONST TCHAR s_szPrtSecNone        [] = TEXT("none");
static CONST TCHAR s_szPrtOpsSupported   [] = TEXT("operations-supported");
static CONST TCHAR s_szPrtName           [] = TEXT("printer-name");
static CONST TCHAR s_szPrtState          [] = TEXT("printer-state");
static CONST TCHAR s_szPrtJobs           [] = TEXT("queued-job-count");
static CONST TCHAR s_szPrtMake           [] = TEXT("printer-make-and-model");
static CONST TCHAR s_szPrtAcceptingJobs  [] = TEXT("printer-is-accepting-jobs");
static CONST TCHAR s_szPrtUpTime         [] = TEXT("printer-up-time");
static CONST TCHAR s_szCharSetSupported  [] = TEXT("charset-supported");
static CONST TCHAR s_szCharSetConfigured [] = TEXT("charset-configured");
static CONST TCHAR s_szNatLangConfigured [] = TEXT("natural-language-configured");
static CONST TCHAR s_szNatLangSupported  [] = TEXT("generated-natural-language-supported");
static CONST TCHAR s_szUnknown           [] = TEXT("unknown");
static CONST TCHAR s_szWhichJobs         [] = TEXT("which-jobs");
static CONST TCHAR s_szCharSet           [] = TEXT("attributes-charset");
static CONST TCHAR s_szNaturalLanguage   [] = TEXT("attributes-natural-language");
static CONST TCHAR s_szReqAttr           [] = TEXT("requested-attributes");
static CONST TCHAR s_szUtf8              [] = TEXT("utf-8");
static CONST TCHAR s_szUsAscii           [] = TEXT("us-ascii");
static CONST TCHAR s_szEnUS              [] = TEXT("en-us");
static CONST TCHAR s_szDocFormatDefault  [] = TEXT("document-format-default");
static CONST TCHAR s_szDocFormatSupported[] = TEXT("document-format-supported");
static CONST TCHAR s_szStaMsg            [] = TEXT("status-message");
static CONST TCHAR s_szPdlOverride       [] = TEXT("pdl-override-supported");
static CONST TCHAR s_szNotAttempted      [] = TEXT("not-attempted");
static CONST TCHAR s_szDocFormat         [] = TEXT("document-format");
static CONST TCHAR s_szCompleted         [] = TEXT("completed");
static CONST TCHAR s_szNotCompleted      [] = TEXT("not-completed");
static CONST TCHAR s_szMimeTxtHtml       [] = TEXT("text/html");
static CONST TCHAR s_szMimeTxtPlain      [] = TEXT("text/plain");
static CONST TCHAR s_szMimePostScript    [] = TEXT("application/postscript");
static CONST TCHAR s_szMimePCL           [] = TEXT("application/vnd.hppcl");
static CONST TCHAR s_szMimeOctStream     [] = TEXT("application/octet-stream");
static CONST TCHAR s_szAll               [] = TEXT("all");
static CONST TCHAR s_szJobTemplate       [] = TEXT("job-template");
static CONST TCHAR s_szJobDescription    [] = TEXT("job-description");
static CONST TCHAR s_szPrtDescription    [] = TEXT("printer-description");
static CONST TCHAR s_szUnsupported       [] = TEXT("unsupported");
static CONST TCHAR s_szAtrFidelity       [] = TEXT("ipp-attribute-fidelity");
static CONST TCHAR s_szTrue              [] = TEXT("true");
static CONST TCHAR s_szFalse             [] = TEXT("false");

/*****************************************************************************\
* Ipp Error-Mapping
*
* These tables define the mappings for Win32 LastErrors and Ipp-http errors.
*
\*****************************************************************************/
static IPPERROR s_LEIpp[] = {

    IPPRSP_ERROR_400, ERROR_INVALID_DATA          , TEXT("Client: (400) BadRequest")                   ,
    IPPRSP_ERROR_401, ERROR_ACCESS_DENIED         , TEXT("Client: (401) Forbidden Access")             ,
    IPPRSP_ERROR_402, ERROR_ACCESS_DENIED         , TEXT("Client: (402) Not Authenticated")            ,
    IPPRSP_ERROR_403, ERROR_ACCESS_DENIED         , TEXT("Client: (403) Not Authorized")               ,
    IPPRSP_ERROR_404, ERROR_INVALID_DATA          , TEXT("Client: (404) Not Possible")                 ,
    IPPRSP_ERROR_405, ERROR_TIMEOUT               , TEXT("Client: (405) Time Out")                     ,
    IPPRSP_ERROR_406, ERROR_INVALID_DATA          , TEXT("Client: (406) Not Found")                    ,
    IPPRSP_ERROR_407, ERROR_INVALID_DATA          , TEXT("Client: (407) Gone")                         ,
    IPPRSP_ERROR_408, ERROR_INVALID_DATA          , TEXT("Client: (408) Entity Too Large")             ,
    IPPRSP_ERROR_409, ERROR_INVALID_DATA          , TEXT("Client: (409) Uri Too Long")                 ,
    IPPRSP_ERROR_40A, ERROR_INVALID_DATA          , TEXT("Client: (40A) Document Format Not Supported"),
    IPPRSP_ERROR_40B, ERROR_INVALID_DATA          , TEXT("Client: (40B) Attributes Not Supported")     ,
    IPPRSP_ERROR_40C, ERROR_INVALID_DATA          , TEXT("Client: (40C) Uri Scheme Not Supported")     ,
    IPPRSP_ERROR_40D, ERROR_INVALID_DATA          , TEXT("Client: (40D) Charset Not Supported")        ,
    IPPRSP_ERROR_40E, ERROR_INVALID_DATA          , TEXT("Client: (40E) Conflicting Attributes")       ,
    IPPRSP_ERROR_500, ERROR_INVALID_DATA          , TEXT("Server: (500) Internal Error")               ,
    IPPRSP_ERROR_501, ERROR_INVALID_DATA          , TEXT("Server: (501) Operation Not Supported")      ,
    IPPRSP_ERROR_502, ERROR_NOT_READY             , TEXT("Server: (502) Service Unavailable")          ,
    IPPRSP_ERROR_503, ERROR_INVALID_DATA          , TEXT("Server: (503) Version Not Supported")        ,
    IPPRSP_ERROR_504, ERROR_NOT_READY             , TEXT("Server: (504) Device Error")                 ,
    IPPRSP_ERROR_505, ERROR_OUTOFMEMORY           , TEXT("Server: (505) Temporary Error")              ,
    IPPRSP_ERROR_506, ERROR_INVALID_DATA          , TEXT("Server: (506) Not Accepting Jobs")           ,
    IPPRSP_ERROR_540, ERROR_LICENSE_QUOTA_EXCEEDED, TEXT("Server: (540) Too Many Users")
};

static IPPDEFERROR s_LEDef[] = {

    ERROR_INVALID_DATA          , IPPRSP_ERROR_400,
    ERROR_ACCESS_DENIED         , IPPRSP_ERROR_401,
    ERROR_INVALID_PARAMETER     , IPPRSP_ERROR_404,
    ERROR_TIMEOUT               , IPPRSP_ERROR_405,
    ERROR_NOT_READY             , IPPRSP_ERROR_504,
    ERROR_OUTOFMEMORY           , IPPRSP_ERROR_505,
    ERROR_LICENSE_QUOTA_EXCEEDED, IPPRSP_ERROR_540
};


/*****************************************************************************\
* Request/Response attributes that are written to the ipp-stream.
*
*
\*****************************************************************************/
static IPPATTRX s_PJQ[] = { // PrtJob, ValJob Request

    IPP_TAG_CHR_URI , RA_PRNURI , IPP_ATR_OFFSET  , s_szPrtUri    , (LPVOID)offs(PIPPREQ_PRTJOB, pPrnUri)  ,
    IPP_TAG_CHR_NAME, RA_JOBNAME, IPP_ATR_OFFSET  , s_szJobName   , (LPVOID)offs(PIPPREQ_PRTJOB, pDocument),
    IPP_TAG_CHR_NAME, RA_JOBUSER, IPP_ATR_OFFSET  , s_szJobReqUser, (LPVOID)offs(PIPPREQ_PRTJOB, pUserName),
    IPP_TAG_DEL_JOB , 0         , IPP_ATR_TAG     , NULL          , (LPVOID)NULL
};

static IPPATTRX s_EJQ[] = { // GetJobs Request

    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET  , s_szPrtUri  , (LPVOID)offs(PIPPREQ_ENUJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, RA_JOBCOUNT       , IPP_ATR_OFFSET  , s_szJobLimit, (LPVOID)offs(PIPPREQ_ENUJOB, cJobs)  ,
    IPP_TAG_CHR_KEYWORD, 0                 , IPP_ATR_ABSOLUTE, s_szReqAttr , (LPVOID)s_szAll
};

static IPPATTRX s_SJQ[] = { // PauJob, CanJob, RsmJob, RstJob Request

    IPP_TAG_CHR_URI    , 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_SETJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, 0, IPP_ATR_OFFSET, s_szJobId , (LPVOID)offs(PIPPREQ_SETJOB, idJob)
};


static IPPATTRX s_GJQ[] = { // GetJobAtr Request

    IPP_TAG_CHR_URI    , 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_GETJOB, pPrnUri),
    IPP_TAG_INT_INTEGER, 0, IPP_ATR_OFFSET, s_szJobId , (LPVOID)offs(PIPPREQ_GETJOB, idJob)
};

static IPPATTRX s_SPQ[] = { // PauPrn, CanPrn, RsmPrn, RstPrn Request

    IPP_TAG_CHR_URI , 0, IPP_ATR_OFFSET, s_szPrtUri    , (LPVOID)offs(PIPPREQ_SETPRN, pPrnUri) ,
    IPP_TAG_CHR_NAME, 0, IPP_ATR_OFFSET, s_szJobReqUser, (LPVOID)offs(PIPPREQ_SETPRN, pUserName)
};

static IPPATTRX s_GPQ[] = { // GetPrnAtr Request

    IPP_TAG_CHR_URI, 0, IPP_ATR_OFFSET, s_szPrtUri, (LPVOID)offs(PIPPREQ_GETPRN, pPrnUri)
};

static IPPATTRX s_PJR[] = { // PrintJob Response

    IPP_TAG_DEL_JOB    , 0                 , IPP_ATR_TAG       , NULL                  , (LPVOID)NULL                                  ,
    IPP_TAG_INT_INTEGER, RA_JOBID          , IPP_ATR_OFFSET    , s_szJobId             , (LPVOID)offs(PIPPRET_JOB, ji.ji2.JobId)       ,
    IPP_TAG_INT_ENUM   , RA_JOBSTATE       , IPP_ATR_OFFSETCONV, s_szJobState          , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBPRIORITY    , IPP_ATR_OFFSET    , s_szJobPri            , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Priority)    ,
    IPP_TAG_INT_INTEGER, RA_JOBSIZE        , IPP_ATR_OFFSETCONV, s_szJobKOctetsProcess , (LPVOID)offs(PIPPRET_JOB, ji.ji2.Size)        ,
    IPP_TAG_INT_INTEGER, RA_SHEETSTOTAL    , IPP_ATR_OFFSET    , s_szJobSheets         , (LPVOID)offs(PIPPRET_JOB, ji.ji2.TotalPages)  ,
    IPP_TAG_INT_INTEGER, RA_SHEETSCOMPLETED, IPP_ATR_OFFSET    , s_szJobSheetsCompleted, (LPVOID)offs(PIPPRET_JOB, ji.ji2.PagesPrinted),
    IPP_TAG_CHR_NAME   , RA_JOBNAME        , IPP_ATR_OFFSET    , s_szJobName           , (LPVOID)offs(PIPPRET_JOB, ji.ji2.pDocument)   ,
    IPP_TAG_CHR_NAME   , RA_JOBUSER        , IPP_ATR_OFFSET    , s_szJobOrgUser        , (LPVOID)offs(PIPPRET_JOB, ji.ji2.pUserName)   ,
    IPP_TAG_CHR_URI    , RA_JOBURI         , IPP_ATR_OFFSET    , s_szJobUri            , (LPVOID)offs(PIPPRET_JOB, ji.ipp.pJobUri)     ,
    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET    , s_szJobPrtUri         , (LPVOID)offs(PIPPRET_JOB, ji.ipp.pPrnUri)
};

static IPPATTRX s_EJR[] = { // GetJobs Response

    IPP_TAG_DEL_JOB    , 0                 , IPP_ATR_TAG   , NULL                  , (LPVOID)NULL                           ,
    IPP_TAG_INT_INTEGER, RA_JOBID          , IPP_ATR_OFFSET, s_szJobId             , (LPVOID)offs(PIPPJI2, ji2.JobId)       ,
    IPP_TAG_INT_ENUM   , RA_JOBSTATE       , IPP_ATR_OFFSET, s_szJobState          , (LPVOID)offs(PIPPJI2, ji2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBPRIORITY    , IPP_ATR_OFFSET, s_szJobPri            , (LPVOID)offs(PIPPJI2, ji2.Priority)    ,
    IPP_TAG_INT_INTEGER, RA_JOBSIZE        , IPP_ATR_OFFSET, s_szJobKOctetsProcess , (LPVOID)offs(PIPPJI2, ji2.Size)        ,
    IPP_TAG_INT_INTEGER, RA_SHEETSTOTAL    , IPP_ATR_OFFSET, s_szJobSheets         , (LPVOID)offs(PIPPJI2, ji2.TotalPages)  ,
    IPP_TAG_INT_INTEGER, RA_SHEETSCOMPLETED, IPP_ATR_OFFSET, s_szJobSheetsCompleted, (LPVOID)offs(PIPPJI2, ji2.PagesPrinted),
    IPP_TAG_INT_INTEGER, RA_TIMEATCREATION , IPP_ATR_OFFSET, s_szTimeAtCreation    , (LPVOID)offs(PIPPJI2, ji2.Submitted)   ,
    IPP_TAG_CHR_NAME   , RA_JOBNAME        , IPP_ATR_OFFSET, s_szJobName           , (LPVOID)offs(PIPPJI2, ji2.pDocument)   ,
    IPP_TAG_CHR_NAME   , RA_JOBUSER        , IPP_ATR_OFFSET, s_szJobOrgUser        , (LPVOID)offs(PIPPJI2, ji2.pUserName)   ,
    IPP_TAG_CHR_URI    , RA_JOBURI         , IPP_ATR_OFFSET, s_szJobUri            , (LPVOID)offs(PIPPJI2, ipp.pJobUri)     ,
    IPP_TAG_CHR_URI    , RA_PRNURI         , IPP_ATR_OFFSET, s_szJobPrtUri         , (LPVOID)offs(PIPPJI2, ipp.pPrnUri)
};

static IPPATTRX s_GPR[] = { // GetPrnAtr Response

    IPP_TAG_DEL_PRINTER, 0                  , IPP_ATR_TAG       , NULL                  , (LPVOID)NULL                                  ,
    IPP_TAG_INT_ENUM   , RA_PRNSTATE        , IPP_ATR_OFFSETCONV, s_szPrtState          , (LPVOID)offs(PIPPRET_PRN, pi.pi2.Status)      ,
    IPP_TAG_INT_INTEGER, RA_JOBCOUNT        , IPP_ATR_OFFSET    , s_szPrtJobs           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.cJobs)       ,
    IPP_TAG_CHR_URI    , RA_URISUPPORTED    , IPP_ATR_OFFSET    , s_szPrtUriSupported   , (LPVOID)offs(PIPPRET_PRN, pi.ipp.pPrnUri)     ,
    IPP_TAG_CHR_KEYWORD, RA_URISECURITY     , IPP_ATR_ABSOLUTE  , s_szPrtUriSecurity    , (LPVOID)s_szPrtSecNone                        ,
    IPP_TAG_CHR_NAME   , RA_PRNNAME         , IPP_ATR_OFFSET    , s_szPrtName           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.pPrinterName),
    IPP_TAG_CHR_TEXT   , RA_PRNMAKE         , IPP_ATR_OFFSET    , s_szPrtMake           , (LPVOID)offs(PIPPRET_PRN, pi.pi2.pDriverName) ,
    IPP_TAG_INT_BOOLEAN, RA_ACCEPTINGJOBS   , IPP_ATR_ABSOLUTE  , s_szPrtAcceptingJobs  , (LPVOID)TRUE                                  ,
    IPP_TAG_CHR_CHARSET, RA_CHRSETCONFIGURED, IPP_ATR_ABSOLUTE  , s_szCharSetConfigured , (LPVOID)s_szUtf8                              ,
    IPP_TAG_CHR_CHARSET, RA_CHRSETSUPPORTED , IPP_ATR_ABSOLUTE  , s_szCharSetSupported  , (LPVOID)s_szUtf8                              ,
    IPP_TAG_CHR_CHARSET, 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)s_szUsAscii                           ,
    IPP_TAG_CHR_NATURAL, RA_NATLNGCONFIGURED, IPP_ATR_ABSOLUTE  , s_szNatLangConfigured , (LPVOID)s_szEnUS                              ,
    IPP_TAG_CHR_NATURAL, RA_NATLNGSUPPORTED , IPP_ATR_ABSOLUTE  , s_szNatLangSupported  , (LPVOID)s_szEnUS                              ,
    IPP_TAG_CHR_MEDIA  , RA_DOCDEFAULT      , IPP_ATR_ABSOLUTE  , s_szDocFormatDefault  , (LPVOID)s_szMimeOctStream                     ,
    IPP_TAG_CHR_MEDIA  , RA_DOCSUPPORTED    , IPP_ATR_ABSOLUTE  , s_szDocFormatSupported, (LPVOID)s_szMimeOctStream                     ,
    IPP_TAG_CHR_KEYWORD, RA_PDLOVERRIDE     , IPP_ATR_ABSOLUTE  , s_szPdlOverride       , (LPVOID)s_szNotAttempted                      ,
    IPP_TAG_INT_INTEGER, RA_UPTIME          , IPP_ATR_ABSOLUTE  , s_szPrtUpTime         , (LPVOID)1                                     ,
    IPP_TAG_INT_ENUM   , RA_OPSSUPPORTED    , IPP_ATR_ABSOLUTE  , s_szPrtOpsSupported   , (LPVOID)IPP_REQ_PRINTJOB                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_VALIDATEJOB                   ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_CANCELJOB                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_GETJOB                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_ENUJOB                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_GETPRN                        ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_PAUSEJOB                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESUMEJOB                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESTARTJOB                    ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_PAUSEPRN                      ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_RESUMEPRN                     ,
    IPP_TAG_INT_ENUM   , 0                  , IPP_ATR_ABSOLUTE  , NULL                  , (LPVOID)IPP_REQ_CANCELPRN
};


/*****************************************************************************\
* Request/Response string-mappings.
*
*
\*****************************************************************************/
static FLGSTR s_ReqRspStr[] = {

    RA_JOBUSER, s_szJobReqUser,
    RA_JOBSIZE, s_szJobKOctets
};


/*****************************************************************************\
* Receive/Response group forms.
*
* These tables defines the order and layout of ipp group tags.
*
\*****************************************************************************/
static BYTE s_FormA[] = {

    IPP_TAG_DEL_OPERATION | IPP_MANDITORY,
    IPP_TAG_DEL_JOB       | IPP_OPTIONAL,
    IPP_TAG_DEL_DATA      | IPP_MANDITORY,
    0
};

static BYTE s_FormB[] = {

    IPP_TAG_DEL_OPERATION | IPP_MANDITORY,
    IPP_TAG_DEL_DATA      | IPP_MANDITORY,
    0
};

static BYTE s_FormC[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_JOB         | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormD[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_PRINTER     | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormE[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL ,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY,
    0
};

static BYTE s_FormF[] = {

    IPP_TAG_DEL_OPERATION   | IPP_MANDITORY              ,
    IPP_TAG_DEL_UNSUPPORTED | IPP_OPTIONAL               ,
    IPP_TAG_DEL_JOB         | IPP_OPTIONAL | IPP_MULTIPLE,
    IPP_TAG_DEL_DATA        | IPP_MANDITORY              ,
    0
};


/*****************************************************************************\
* Structure Offsets
*
*
\*****************************************************************************/
static DWORD s_IPPJI2Offs[] = {

    offs(LPIPPJI2, ji2.pPrinterName),
    offs(LPIPPJI2, ji2.pMachineName),
    offs(LPIPPJI2, ji2.pUserName),
    offs(LPIPPJI2, ji2.pDocument),
    offs(LPIPPJI2, ji2.pNotifyName),
    offs(LPIPPJI2, ji2.pDatatype),
    offs(LPIPPJI2, ji2.pPrintProcessor),
    offs(LPIPPJI2, ji2.pParameters),
    offs(LPIPPJI2, ji2.pDriverName),
    offs(LPIPPJI2, ji2.pDevMode),
    offs(LPIPPJI2, ji2.pStatus),
    offs(LPIPPJI2, ji2.pSecurityDescriptor),
    offs(LPIPPJI2, ipp.pPrnUri),
    offs(LPIPPJI2, ipp.pJobUri),
    0xFFFFFFFF
};

static DWORD s_IPPPI2Offs[] = {

    offs(LPIPPPI2, pi2.pServerName),
    offs(LPIPPPI2, pi2.pPrinterName),
    offs(LPIPPPI2, pi2.pShareName),
    offs(LPIPPPI2, pi2.pPortName),
    offs(LPIPPPI2, pi2.pDriverName),
    offs(LPIPPPI2, pi2.pComment),
    offs(LPIPPPI2, pi2.pLocation),
    offs(LPIPPPI2, pi2.pDevMode),
    offs(LPIPPPI2, pi2.pSepFile),
    offs(LPIPPPI2, pi2.pPrintProcessor),
    offs(LPIPPPI2, pi2.pDatatype),
    offs(LPIPPPI2, pi2.pParameters),
    offs(LPIPPPI2, pi2.pSecurityDescriptor),
    offs(LPIPPPI2, ipp.pPrnUri),
    offs(LPIPPPI2, ipp.pUsrName),
    0xFFFFFFFF
};

static DWORD s_JI2Off[] = {

    offs(LPJOB_INFO_2, pPrinterName),
    offs(LPJOB_INFO_2, pMachineName),
    offs(LPJOB_INFO_2, pUserName),
    offs(LPJOB_INFO_2, pDocument),
    offs(LPJOB_INFO_2, pNotifyName),
    offs(LPJOB_INFO_2, pDatatype),
    offs(LPJOB_INFO_2, pPrintProcessor),
    offs(LPJOB_INFO_2, pParameters),
    offs(LPJOB_INFO_2, pDriverName),
    // Do not include DEVMODE
    offs(LPJOB_INFO_2, pStatus),
    // Do not include SECURITY-DESCRIPTOR
    0xFFFFFFFF
};

static DWORD s_PI2Off[] = {

    offs(LPPRINTER_INFO_2, pServerName),
    offs(LPPRINTER_INFO_2, pPrinterName),
    offs(LPPRINTER_INFO_2, pShareName),
    offs(LPPRINTER_INFO_2, pPortName),
    offs(LPPRINTER_INFO_2, pDriverName),
    offs(LPPRINTER_INFO_2, pComment),
    offs(LPPRINTER_INFO_2, pLocation),
    // Do not include DEVMODE
    offs(LPPRINTER_INFO_2, pSepFile),
    offs(LPPRINTER_INFO_2, pPrintProcessor),
    offs(LPPRINTER_INFO_2, pDatatype),
    offs(LPPRINTER_INFO_2, pParameters),
    // Do not include SECURITY-DESCRIPTOR
    0xFFFFFFFF
};

static DWORD s_IPJOff[] = {

    offs(LPJOB_INFO_IPP, pPrnUri),
    offs(LPJOB_INFO_IPP, pJobUri),
    0xFFFFFFFF
};

static DWORD s_IPPOff[] = {

    offs(LPPRINTER_INFO_IPP, pPrnUri) ,
    offs(LPPRINTER_INFO_IPP, pUsrName),
    0xFFFFFFFF
};


/*****************************************************************************\
* ipp_SetReq (Local Routine)
*
* Sets a bit in the request flag.  If the index (upper 4 bits) is greater
* than 7, then we use this as a special enum flag.
*
\*****************************************************************************/
VOID x_SetReq(
    PDWORD pfReq,
    DWORD  fSet)
{
    DWORD  idz;
    PDWORD pFlg;
    DWORD  cFlg = 0;
    DWORD  idx  = ((fSet >> 28) & 0x0000000F);

    static DWORD s_fReqEnu[] = {

        RA_JOBID,
        RA_JOBURI
    };

    static DWORD s_fJobTmp[] = {

        RA_JOBPRIORITY     ,
        RA_SHEETSTOTAL     ,
        RA_SHEETSCOMPLETED
    };

    static DWORD s_fJobDsc[] = {

        RA_JOBURI          ,
        RA_JOBID           ,
        RA_JOBNAME         ,
        RA_JOBUSER         ,
        RA_JOBSTATE        ,
        RA_JOBSTATE_REASONS,
        RA_JOBSTATE_MESSAGE,
        RA_JOBSIZE
    };

    static DWORD s_fPrtDsc[] = {

        RA_URISUPPORTED    ,
        RA_URISECURITY     ,
        RA_PRNNAME         ,
        RA_PRNMAKE         ,
        RA_PRNSTATE        ,
        RA_OPSSUPPORTED    ,
        RA_CHRSETCONFIGURED,
        RA_CHRSETSUPPORTED ,
        RA_NATLNGCONFIGURED,
        RA_NATLNGSUPPORTED ,
        RA_DOCDEFAULT      ,
        RA_DOCSUPPORTED    ,
        RA_ACCEPTINGJOBS   ,
        RA_JOBCOUNT        ,
        RA_PDLOVERRIDE     ,
        RA_UPTIME
    };


    switch (idx) {

    case IPP_REQALL_IDX:
        pfReq[0] = 0x0FFFFFFF;
        pfReq[1] = 0x0FFFFFFF;
        break;

    case IPP_REQCLEAR_IDX:
        pfReq[0] = 0x00000000;
        pfReq[1] = 0x00000000;
        break;

    case IPP_REQENU_IDX:
        pFlg = s_fReqEnu;
        cFlg = sizeof(s_fReqEnu) / sizeof(s_fReqEnu[0]);
        break;

    case IPP_REQJDSC_IDX:
        pFlg = s_fJobDsc;
        cFlg = sizeof(s_fJobDsc) / sizeof(s_fJobDsc[0]);
        break;

    case IPP_REQJTMP_IDX:
        pFlg = s_fJobTmp;
        cFlg = sizeof(s_fJobTmp) / sizeof(s_fJobTmp[0]);
        break;

    case IPP_REQPDSC_IDX:
        pFlg = s_fPrtDsc;
        cFlg = sizeof(s_fPrtDsc) / sizeof(s_fPrtDsc[0]);
        break;
    }


    if (idx >= IPP_REQALL_IDX) {

        for (idz = 0; idz < cFlg; idz++) {

            idx = ((pFlg[idz] >> 28) & 0x0000000F);

            pfReq[idx] |= (pFlg[idz] & 0x0FFFFFFF);
        }

    } else {

        pfReq[idx] |= (fSet & 0x0FFFFFFF);
    }
}


/*****************************************************************************\
* ipp_ChkReq (Local Routine)
*
* Checks to se if bit-flag is set in the request flag.
*
\*****************************************************************************/
BOOL x_ChkReq(
    PDWORD pfReq,
    DWORD  fChk)
{
    DWORD idx = ((fChk >> 28) & 0x0000000F);

    return pfReq[idx] & (fChk & 0x0FFFFFFF);
}


/*****************************************************************************\
* ipp_CopyAligned (Local Routine)
*
* Copies memory to an aligned-buffer.
*
\*****************************************************************************/
inline LPBYTE ipp_CopyAligned(
    LPBYTE lpDta,
    DWORD            cbDta)
{
    LPBYTE lpAln;


    if (lpAln = (LPBYTE)webAlloc(cbDta))
        CopyMemory((LPVOID)lpAln, lpDta, cbDta);

    return lpAln;
}


/*****************************************************************************\
* ipp_WriteData (Local Routine)
*
* Sets the data in an IPP-Data-Stream.  This adjusts the pointer to the
* next byte-location in the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteData(
    LPBYTE* lplpPtr,
    LPVOID  lpData,
    DWORD   cbData)
{
    CopyMemory(*lplpPtr, lpData, cbData);

    *lplpPtr += cbData;
}


/*****************************************************************************\
* ipp_WriteByte (Local Routine)
*
* Write out a byte to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteByte(
    LPBYTE* lplpIppPtr,
    BYTE    bVal)
{
    ipp_WriteData(lplpIppPtr, (LPVOID)&bVal, IPP_SIZEOFTAG);
}


/*****************************************************************************\
* ipp_ReadByte (Local Routine)
*
* Read a byte from the stream.
*
\*****************************************************************************/
inline BYTE ipp_ReadByte(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    return (*(BYTE *)((LPBYTE)(lpbPtr) + cbIdx));
}


/*****************************************************************************\
* ipp_WriteWord (Local Routine)
*
* Write out a word to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteWord(
    LPBYTE* lplpIppPtr,
    WORD    wVal)
{
    WORD wNBW = htons (wVal);

    ipp_WriteData(lplpIppPtr, (LPVOID)&wNBW, IPP_SIZEOFLEN);
}


/*****************************************************************************\
* ipp_ReadWord (Local Routine)
*
* Read a word from the stream.
*
\*****************************************************************************/
inline WORD ipp_ReadWord(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    WORD wVal = (*(WORD UNALIGNED *)((LPBYTE)(lpbPtr) + cbIdx));

    return ntohs (wVal);
}


/*****************************************************************************\
* ipp_WriteDWord (Local Routine)
*
* Write out a dword to the stream.
*
\*****************************************************************************/
inline VOID ipp_WriteDWord(
    LPBYTE* lplpIppPtr,
    DWORD   dwVal)
{
    DWORD dwNBDW = htonl(dwVal);

    ipp_WriteData(lplpIppPtr, (LPVOID)&dwNBDW, IPP_SIZEOFINT);
}


/*****************************************************************************\
* ipp_ReadDWord (Local Routine)
*
* Read a dword from the stream.
*
\*****************************************************************************/
inline DWORD ipp_ReadDWord(
    LPBYTE lpbPtr,
    DWORD  cbIdx)
{
    DWORD dwVal = (*(DWORD UNALIGNED *)((LPBYTE)(lpbPtr) + cbIdx));

    return ntohl(dwVal);
}


/*****************************************************************************\
* ipp_MapReqToJobCmd (Local Routine)
*
* Returns a job-command from a request.
*
\*****************************************************************************/
inline DWORD ipp_MapReqToJobCmd(
    WORD wReq)
{
    if (wReq == IPP_REQ_CANCELJOB)
        return JOB_CONTROL_DELETE;

    if (wReq == IPP_REQ_PAUSEJOB)
        return JOB_CONTROL_PAUSE;

    if (wReq == IPP_REQ_RESUMEJOB)
        return JOB_CONTROL_RESUME;

    if (wReq == IPP_REQ_RESTARTJOB)
        return JOB_CONTROL_RESTART;

    return 0;
}


/*****************************************************************************\
* ipp_MapReqToPrnCmd (Local Routine)
*
* Returns a printer-command from a request.
*
\*****************************************************************************/
inline DWORD ipp_MapReqToPrnCmd(
    WORD wReq)
{
    if (wReq == IPP_REQ_RESUMEPRN)
        return PRINTER_CONTROL_RESUME;

    if (wReq == IPP_REQ_PAUSEPRN)
        return PRINTER_CONTROL_PAUSE;

    if (wReq == IPP_REQ_CANCELPRN)
        return PRINTER_CONTROL_PURGE;

    return 0;
}


/*****************************************************************************\
* ipp_W32ToIppJobPriority (Local Routine)
*
* Maps a JOB_INFO_2 priority to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobPriority(
    DWORD dwPriority)
{
    return dwPriority;
}


/*****************************************************************************\
* ipp_IppToW32JobPriority (Local Routine)
*
* Maps an IPP job priority to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobPriority(
    DWORD dwPriority)
{
    return dwPriority;
}

/*****************************************************************************\
* ipp_W32ToIppJobSize (Local Routine)
*
* Maps a JOB_INFO_2 size to an IPP size.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobSize(
    DWORD dwSize)
{
    return (1023 + dwSize) / 1024;
}


/*****************************************************************************\
* ipp_IppToW32JobSize (Local Routine)
*
* Maps an IPP job size to a JOB_INFO_2 size.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobSize(
    DWORD dwSize)
{
    return dwSize * 1024;
}


/*****************************************************************************\
* ipp_W32ToIppJobTotalPages (Local Routine)
*
* Maps a JOB_INFO_2 TotalPages to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobTotalPages(
    DWORD dwTotalPages)
{
    return dwTotalPages;
}


/*****************************************************************************\
* ipp_IppToW32JobTotalPages (Local Routine)
*
* Maps an IPP TotalPages to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobTotalPages(
    DWORD dwTotalPages)
{
    return dwTotalPages;
}


/*****************************************************************************\
* ipp_W32ToIppJobPagesPrinted (Local Routine)
*
* Maps a JOB_INFO_2 PagesPrinted to an IPP priority.
*
\*****************************************************************************/
inline DWORD ipp_W32ToIppJobPagesPrinted(
    DWORD dwPagesPrinted)
{
    return dwPagesPrinted;
}


/*****************************************************************************\
* ipp_IppToW32JobPagesPrinted (Local Routine)
*
* Maps an IPP PagesPrinted to a JOB_INFO_2 priority.
*
\*****************************************************************************/
inline DWORD ipp_IppToW32JobPagesPrinted(
    DWORD dwPagesPrinted)
{
    return dwPagesPrinted;
}


/*****************************************************************************\
* ipp_W32ToIppJobState (Local Routine)
*
* Maps a Job-Status flag to that of an IPP State flag.
*
\*****************************************************************************/
DWORD ipp_W32ToIppJobState(
    DWORD dwState)
{
    if (dwState & (JOB_STATUS_OFFLINE | JOB_STATUS_PAPEROUT | JOB_STATUS_ERROR | JOB_STATUS_USER_INTERVENTION | JOB_STATUS_BLOCKED_DEVQ))
        return IPP_JOBSTATE_PROCESSEDSTOPPED;

    if (dwState & JOB_STATUS_DELETED)
        return IPP_JOBSTATE_CANCELLED;

    if (dwState & JOB_STATUS_PAUSED)
        return IPP_JOBSTATE_PENDINGHELD;

    if (dwState & JOB_STATUS_PRINTED)
        return IPP_JOBSTATE_COMPLETED;

    if (dwState & (JOB_STATUS_PRINTING | JOB_STATUS_SPOOLING | JOB_STATUS_DELETING))
        return IPP_JOBSTATE_PROCESSING;

    if ((dwState == 0) || (dwState & JOB_STATUS_RESTART))
        return IPP_JOBSTATE_PENDING;

    return IPP_JOBSTATE_UNKNOWN;
}


/*****************************************************************************\
* ipp_IppToW32JobState (Local Routine)
*
* Maps a IPP State flag to that of a W32 Status flag.
*
\*****************************************************************************/
DWORD ipp_IppToW32JobState(
    DWORD dwState)
{
    switch (dwState) {

    case IPP_JOBSTATE_PENDINGHELD:
        return JOB_STATUS_PAUSED;

    case IPP_JOBSTATE_PROCESSEDSTOPPED:
        return JOB_STATUS_ERROR;

    case IPP_JOBSTATE_PROCESSING:
        return JOB_STATUS_PRINTING;

    case IPP_JOBSTATE_CANCELLED:
    case IPP_JOBSTATE_ABORTED:
        return JOB_STATUS_DELETING;

    case IPP_JOBSTATE_COMPLETED:
        return JOB_STATUS_PRINTED;

    default:
    case IPP_JOBSTATE_PENDING:
        return 0;
    }
}


/*****************************************************************************\
* ipp_W32ToIppPrnState (Local Routine)
*
* Maps a W32-Prn-State to Ipp-Prn-State.
*
\*****************************************************************************/
DWORD ipp_W32ToIppPrnState(
    DWORD dwState)
{
    if (dwState == 0)
        return IPP_PRNSTATE_IDLE;

    if (dwState & PRINTER_STATUS_PAUSED)
        return IPP_PRNSTATE_STOPPED;

    if (dwState & (PRINTER_STATUS_PROCESSING | PRINTER_STATUS_PRINTING))
        return IPP_PRNSTATE_PROCESSING;

    return IPP_PRNSTATE_UNKNOWN;
}


/*****************************************************************************\
* ipp_IppToW32PrnState (Local Routine)
*
* Maps a Ipp-Prn-State to W32-Prn-State.
*
\*****************************************************************************/
DWORD ipp_IppToW32PrnState(
    DWORD dwState)
{
    switch (dwState) {

    case IPP_PRNSTATE_STOPPED:
        return PRINTER_STATUS_PAUSED;

    case IPP_PRNSTATE_PROCESSING:
        return PRINTER_STATUS_PROCESSING;

    default:
    case IPP_PRNSTATE_IDLE:
        return 0;
    }
}

/*****************************************************************************\
* ipp_IppCurTime (Local Routine)
*
* Returns the base seconds printer has been alive.  This is used for the
* printer-up-time attribute.  Since our implementation can't determine the
* true printer up-time, we're going to use the relative seconds returned
* from the time() function.
*
\*****************************************************************************/
DWORD ipp_IppCurTime(VOID)
{
    time_t tTime;

    ZeroMemory(&tTime, sizeof(time_t));
    time(&tTime);

    return (DWORD) tTime;
}


/*****************************************************************************\
* ipp_IppToW32Time (Local Routine)
*
* Converts an IPP (DWORD) time to a win32 SYSTEMTIME. Note that we pass in the 
* printers' normalised start time as a straight overwrite of the first fields
* of the LPSYSTEMTIME structure. This is nasty but since the code has no concept
* of session, we have to pass it back to code that does.
*
\*****************************************************************************/
BOOL ipp_IppToW32Time(
    time_t        dwTime,
    LPSYSTEMTIME pst)
{

#if 1
    // All we do is brutally overwrite the structure with the time and send it back
    // 
    // *(time_t *)pst = dwTime;
    // Change to use CopyMemory to avoid 64bit alignment error
    //
    CopyMemory (pst, &dwTime, sizeof (time_t));

    return TRUE;

#else

    FILETIME ft;

    DosDateTimeToFileTime(HIWORD(dwTime), LOWORD(dwTime), &ft);

    return FileTimeToSystemTime(&ft, pst);


#endif

}

/*******************************************************************************
** ippConvertSystemTime 
** 
** This receives the system time (which has actually been packed with the time
** retrieved from the printers) and converts it to the Real System time based
** on the original T0 of the printer
**
******************************************************************************/
BOOL WebIppConvertSystemTime(
    IN OUT LPSYSTEMTIME pST,
    IN     time_t       dwPrinterT0) {

    // First we need to get the time stored in the LPSYSTEMTIME structure
    // time_t      dwSubmitTime = *(time_t *)pST;
    // Use CopyMemory to avoid alignment error in 64bit machine.
    time_t      dwSubmitTime;
     
    CopyMemory (&dwSubmitTime, pST, sizeof (time_t));


    SYSTEMTIME TmpST;

    // If the submitted time is zero, it means that either the job was submitted before
    // the printer was rebooted, or, the printer does not support the submitted time of the
    // job

    if (!dwSubmitTime) {
        ZeroMemory( &pST, sizeof(LPSYSTEMTIME));
    } else {
        // Next we have to normalise the time to that of the PrinterT0
        dwSubmitTime += dwPrinterT0;

        tm *ptm;


        // Convert the time into a struct and return the SYSTEMTIME
        // structure.
        //
        ptm = gmtime(&dwSubmitTime);

        if (ptm) {
    
            TmpST.wYear      = (WORD)(1900 + ptm->tm_year);
            TmpST.wMonth     = (WORD)(ptm->tm_mon + 1);
            TmpST.wDayOfWeek = (WORD)ptm->tm_wday;
            TmpST.wDay       = (WORD)ptm->tm_mday;
            TmpST.wHour      = (WORD)ptm->tm_hour;
            TmpST.wMinute    = (WORD)ptm->tm_min;
            TmpST.wSecond    = (WORD)ptm->tm_sec;
            TmpST.wMilliseconds = 0;
    
            CopyMemory (pST, &TmpST, sizeof (SYSTEMTIME));
        }
        else
            ZeroMemory( &pST, sizeof(LPSYSTEMTIME));


    }
    
    return TRUE;

}



/*****************************************************************************\
* ipp_W32ToIppTime (Local Routine)
*
* Converts a Win32 SYSTEMTIME to UCT. 
*
\*****************************************************************************/
DWORD ipp_W32ToIppTime(
    LPSYSTEMTIME pst)               // We pass in the T0 for the system in here
{

#if 1

    tm   tmCvt;
    struct _timeb tiTimeb;

    _ftime(&tiTimeb);               // We obtain the time zone difference from here,
                                    // mktime assumes local time in doing the conversion

    ZeroMemory(&tmCvt, sizeof(tm));
    tmCvt.tm_sec   = (int)(short)pst->wSecond;
    tmCvt.tm_min   = (int)(short)pst->wMinute;
    tmCvt.tm_hour  = (int)(short)pst->wHour;
    tmCvt.tm_mday  = (int)(short)pst->wDay;
    tmCvt.tm_mon   = (int)(short)(pst->wMonth - 1);
    tmCvt.tm_year  = ((int)(short)pst->wYear - 1900);
    tmCvt.tm_wday  = (int)(short)pst->wDayOfWeek;
                     
    INT iUCT = (INT)mktime(&tmCvt);

    iUCT -= tiTimeb.timezone * 60;      // Normalise for timezone difference

     return (DWORD)iUCT;

#else

    WORD     wDate;
    WORD     wTime;
    FILETIME ft;

    SystemTimeToFileTime(pst, &ft);

    FileTimeToDosDateTime(&ft, &wDate, &wTime);

    return (DWORD)MAKELONG(wTime, wDate);

#endif

}


/*****************************************************************************\
* ipp_JidFromUri
*
* Returns a job-id from a job-uri string.
*
\*****************************************************************************/
DWORD ipp_JidFromUri(
   LPTSTR lpszUri)
{
    LPTSTR lpszPtr;
    DWORD  jid = 0;

    if (lpszPtr = webFindRChar(lpszUri, TEXT('=')))
        jid = webAtoI(++lpszPtr);

    return jid;
}


/*****************************************************************************\
* ipp_PackStrings
*
* This routine packs strings to the end of a buffer.  This is used for
* building a JOB_INFO_2 list from IPP information.
*
\*****************************************************************************/
LPBYTE ipp_PackStrings(
   LPTSTR* ppszSrc,
   LPBYTE  pbDst,
   LPDWORD pdwDstOffsets,
   LPBYTE  pbEnd)
{
    DWORD cbStr;


    while (*pdwDstOffsets != (DWORD)-1) {
        // We fill in the strings from the end of the structure and fill in the 
        // structure forwards, if our string pointer is ever less than the address 
        // we are copying into, the initial block allocated was too small

        if (*ppszSrc) {

            cbStr  = webStrSize(*ppszSrc);
            pbEnd -= cbStr;

            CopyMemory(pbEnd, *ppszSrc, cbStr);

            LPTSTR *strWriteLoc = (LPTSTR *)(pbDst + *pdwDstOffsets);

            WEB_IPP_ASSERT( (LPBYTE)pbEnd >= (LPBYTE)strWriteLoc );
                        
            *strWriteLoc = (LPTSTR)pbEnd;

        } else {

            *(LPTSTR *)(pbDst + *pdwDstOffsets) = TEXT('\0');
        }

        ppszSrc++;
        pdwDstOffsets++;
    }

    return pbEnd;
}


/*****************************************************************************\
* ipp_NextVal (Local Routine)
*
* Returns next value-field in a tag-attribute.
*
* Parameters:
* ----------
* lpIppHdr - Pointer to the IPP-Stream.
* lpcbIdx  - Current Byte offset into the IPP-Stream.
* cbIppHdr - Size of the IPP-Stream.
*
\*****************************************************************************/
LPBYTE ipp_NextVal(
    LPBYTE  lpIppHdr,
    LPDWORD lpcbIdx,
    DWORD   cbIppHdr)
{
    DWORD cbIdx;
    DWORD cbSize;


    // The (cbIdx) is positioned at the location where a length
    // is to be read.
    //
    cbIdx = *lpcbIdx;


    // Make sure we have enough to read a WORD value.
    //
    if ((cbIdx + IPP_SIZEOFTAG) >= cbIppHdr)
        return NULL;


    // Get the name-length of the attribute.  Adjust our
    // offset by this amount and add size of length-field to
    // position to the next attribute-length.
    //
    cbSize  = (DWORD)ipp_ReadWord(lpIppHdr, cbIdx);
    cbIdx  += (cbSize + IPP_SIZEOFLEN);

    if (cbIdx >= cbIppHdr)
        return NULL;

    *lpcbIdx = cbIdx;

    return lpIppHdr + cbIdx;
}


/*****************************************************************************\
* ipp_NextTag (Local Routine)
*
* Returns a pointer to the next tag in the header.  If this routine returns
* NULL, then we do not have enough data to advance to the next-tag.
*
* Parameters:
* ----------
* lpTag   - Pointer to the current-tag postion.
* lpcbIdx - Bytes offset from the header.
* cbHdr   - Size of the header-stream we're working with.
*
\*****************************************************************************/
LPBYTE ipp_NextTag(
    LPBYTE  lpIppHdr,
    LPDWORD lpcbIdx,
    DWORD   cbIppHdr)
{
    BYTE  bTag;
    DWORD cbIdx;
    DWORD cbSize;


    // Out current byte-offset is at a tag.  Grab the tag, and advance
    // our index past it to proced to get past the possible attribute.
    //
    cbIdx  = *lpcbIdx;
    bTag   = ipp_ReadByte(lpIppHdr, cbIdx);
    cbIdx += IPP_SIZEOFTAG;


    // If our tag is a deliminator, then we need only advance to the
    // next byte where the next tag should be.
    //
    if (IS_TAG_DELIMITER(bTag)) {

        // Make sure we have enough bytes to return an offset
        // to the next tag.
        //
        if (cbIdx >= cbIppHdr)
            return NULL;

        *lpcbIdx = cbIdx;

        return lpIppHdr + cbIdx;
    }


    // Otherwise, we are currently at an attribute-tag.  We need to
    // calculate bytes offset to the next tag.
    //
    if (IS_TAG_ATTRIBUTE(bTag)) {

        // This logic calculates the byte-offsets to the
        // value-tags.  We need to do two value adjustments
        // since there is both a (name) and a (value) component
        // to an attribute.
        //
        if (ipp_NextVal(lpIppHdr, &cbIdx, cbIppHdr)) {

            // This last adjustment will return the position
            // of the next tag.
            //
            if (ipp_NextVal(lpIppHdr, &cbIdx, cbIppHdr)) {

                *lpcbIdx = cbIdx;

                return lpIppHdr + cbIdx;
            }
        }
    }

    return NULL;
}


/*****************************************************************************\
* ipp_RelAttr (Local Routine)
*
* Release (Free) the attribute block.
*
\*****************************************************************************/
BOOL ipp_RelAttr(
    LPIPPATTR lpAttr)
{
    if (lpAttr) {

        webFree(lpAttr->lpszName);
        webFree(lpAttr->lpValue);
        webFree(lpAttr);

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_GetAttr (Local Routine)
*
* Returns an attribute in a structured-from.
*
\*****************************************************************************/
LPIPPATTR ipp_GetAttr(
    LPBYTE   lpTag,
    DWORD    cbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr = NULL;
    WORD      wIdx;
    BYTE      bTag   = ipp_ReadByte(lpTag, 0);
    DWORD     cbSize;


    if (IS_TAG_ATTRIBUTE(bTag)) {

        if (lpAttr = (LPIPPATTR)webAlloc(sizeof(IPPATTR))) {

            __try {

                lpAttr->bTag    = bTag;
                lpTag          += IPP_SIZEOFTAG;

                lpAttr->cbName  = ipp_ReadWord(lpTag, 0);
                lpTag          += IPP_SIZEOFLEN;


                if (lpAttr->cbName) {

                    lpAttr->lpszName  = webMBtoTC(CP_UTF8, (LPSTR)lpTag, lpAttr->cbName);
                    lpTag            += lpAttr->cbName;
                }

#if 1
    // hack. This is added to support name-with-language attributes.  To
    // do this temporarily, this code will work but ignore the language
    // part of the attribute.  In the future, we can look at dealing with
    // the language appropriately.
    //
    // 15-Mar-1999 : ChrisWil (HP).
    //

                if (IS_TAG_COMPOUND(bTag)) {

                    if (ipp_ReadWord(lpTag, 0)) {

                        lpTag += IPP_SIZEOFLEN;
                        lpTag += ipp_ReadWord(lpTag, 0);
                        lpTag += IPP_SIZEOFLEN;
                    }
                }
#endif



                lpAttr->cbValue  = ipp_ReadWord(lpTag, 0);
                lpTag           += IPP_SIZEOFLEN;


                // If there's a value, then make sure that the size doesn't
                // exceed our IPP-Stream.
                //
                if (lpAttr->cbValue && (lpAttr->cbValue < (lpObj->cbIppHdr - cbIdx))) {

                    // Convert the value to the appropriate format.  This
                    // block currently makes the assumption that all strings
                    // are dealt with as Octet-Strings.  When this parser
                    // supports other character-sets, then the conversion
                    // for Character-Strings can utilize a different codepage.
                    //
                    if (IS_TAG_OCTSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(CP_UTF8, (LPSTR)lpTag, lpAttr->cbValue);

                    } else if (IS_TAG_CHARSETSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(lpObj->uCPRcv, (LPSTR)lpTag, lpAttr->cbValue);

                    } else if (IS_TAG_CHRSTR(lpAttr->bTag)) {

                        lpAttr->lpValue = (LPVOID)webMBtoTC(CP_ACP, (LPSTR)lpTag, lpAttr->cbValue);

                    } else {

                        if (lpAttr->cbValue <= sizeof(DWORD))
                            lpAttr->lpValue = (LPVOID)webAlloc(sizeof(DWORD));
                        else
                            lpAttr->lpValue = (LPVOID)webAlloc(lpAttr->cbValue);

                        if (lpAttr->lpValue) {

                            if (lpAttr->cbValue == sizeof(BYTE))
                                *(LPDWORD)(lpAttr->lpValue) = (DWORD)ipp_ReadByte(lpTag, 0);
                            else if (lpAttr->cbValue == sizeof(WORD))
                                *(LPDWORD)(lpAttr->lpValue) = (DWORD)ipp_ReadWord(lpTag, 0);
                            else if (lpAttr->cbValue == sizeof(DWORD))
                                *(LPDWORD)(lpAttr->lpValue) = ipp_ReadDWord(lpTag, 0);
                            else
                                CopyMemory((LPVOID)lpAttr->lpValue, (LPVOID)lpTag, lpAttr->cbValue);
                        }
                    }
                }

            } __except (1) {

                ipp_RelAttr(lpAttr);

                lpAttr = NULL;
            }
        }
    }

    return lpAttr;
}


/*****************************************************************************\
* ipp_WriteAttr (Local Routine)
*
* Write out the attribute.  If NULL is passed in as the (lplpIppPtr), then
* this routine returns the size necessary to write the info.
*
\*****************************************************************************/
DWORD ipp_WriteAttr(
    LPBYTE* lplpIppPtr,
    BYTE    bTag,
    DWORD   cbName,
    LPVOID  lpName,
    DWORD   cbValue,
    LPVOID  lpValue)
{
    DWORD cbSize;


    // Set the size that this attribute occupies.
    //
    cbSize = (cbName + cbValue + IPP_SIZEOFTAG + IPP_SIZEOFLEN + IPP_SIZEOFLEN);


    // Write out the attribute to the buffer (if available).
    //
    if (lplpIppPtr) {

        ipp_WriteByte(lplpIppPtr, bTag);

        if (cbName) {

            ipp_WriteWord(lplpIppPtr, (WORD)cbName);
            ipp_WriteData(lplpIppPtr, (LPVOID)lpName, cbName);

        } else {

            ipp_WriteWord(lplpIppPtr, (WORD)cbName);
        }

        ipp_WriteWord(lplpIppPtr, (WORD)cbValue);

        switch (bTag) {
        case IPP_TAG_INT_INTEGER:
        case IPP_TAG_INT_ENUM:
            ipp_WriteDWord(lplpIppPtr, * (DWORD*)lpValue);
            break;
        case IPP_TAG_INT_BOOLEAN:
            ipp_WriteByte(lplpIppPtr, * (BYTE*)lpValue);
            break;
        default:
            ipp_WriteData(lplpIppPtr, (LPVOID)lpValue , cbValue);
            break;
        }
    }

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeAttr (Local Routine)
*
* Return the size necessary to store the attribute.
*
\*****************************************************************************/
inline DWORD ipp_SizeAttr(
    DWORD cbName,
    DWORD cbValue)
{
    return ipp_WriteAttr(NULL, 0, cbName, NULL, cbValue, NULL);
}


/*****************************************************************************\
* ipp_WriteHead (Local Routine)
*
* Write out our "generic" type header.  This includes the character-set
* that we support.
*
\*****************************************************************************/
DWORD ipp_WriteHead(
    LPBYTE* lplpIppPtr,
    WORD    wReq,
    DWORD   idReq,
    UINT    cpReq)
{
    DWORD   cbNamCS;
    DWORD   cbValCS;
    DWORD   cbNamNL;
    DWORD   cbValNL;
    LPCTSTR lpszCS;
    LPSTR   lputfNamCS;
    LPSTR   lputfValCS;
    LPSTR   lputfNamNL;
    LPSTR   lputfValNL;
    DWORD   cbSize = 0;


    // Encode in the specified character-set.
    //
    lpszCS = ((cpReq == CP_ACP) ? s_szUsAscii : s_szUtf8);


    lputfNamCS = webTCtoMB(CP_ACP, s_szCharSet        , &cbNamCS);
    lputfValCS = webTCtoMB(CP_ACP, lpszCS             , &cbValCS);
    lputfNamNL = webTCtoMB(CP_ACP, s_szNaturalLanguage, &cbNamNL);
    lputfValNL = webTCtoMB(CP_ACP, s_szEnUS           , &cbValNL);


    if (lputfNamCS && lputfValCS && lputfNamNL && lputfValNL) {

        // Calculate the size necessary to hold the IPP-Header.
        //
        cbSize = IPP_SIZEOFHDR                   +   // Version-Request.
                 IPP_SIZEOFTAG                   +   // Operation Tag
                 ipp_SizeAttr(cbNamCS, cbValCS)  +   // CharSet Attribute.
                 ipp_SizeAttr(cbNamNL, cbValNL);     // NaturalLang Attribute.


        if (lplpIppPtr) {

            ipp_WriteWord(lplpIppPtr, IPP_VERSION);
            ipp_WriteWord(lplpIppPtr, wReq);
            ipp_WriteDWord(lplpIppPtr, idReq);
            ipp_WriteByte(lplpIppPtr, IPP_TAG_DEL_OPERATION);
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_CHR_CHARSET, cbNamCS, lputfNamCS, cbValCS, lputfValCS);
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_CHR_NATURAL, cbNamNL, lputfNamNL, cbValNL, lputfValNL);
        }
    }

    webFree(lputfValCS);
    webFree(lputfNamCS);
    webFree(lputfValNL);
    webFree(lputfNamNL);

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeHdr (Local Routine)
*
* Return the size necessary to store the header and operation tags.
*
\*****************************************************************************/
inline DWORD ipp_SizeHdr(
    UINT cpReq)
{
    return ipp_WriteHead(NULL, 0, 0, cpReq);
}


/*****************************************************************************\
* ipp_ValDocFormat (Local Routine)
*
* Validates the document-format.
*
\*****************************************************************************/
BOOL ipp_ValDocFormat(
    LPCTSTR lpszFmt)
{
    DWORD idx;
    DWORD cCnt;

    static PCTSTR s_szFmts[] = {

        s_szMimeTxtHtml   ,
        s_szMimeTxtPlain  ,
        s_szMimePostScript,
        s_szMimePCL       ,
        s_szMimeOctStream
    };

    cCnt = sizeof(s_szFmts) / sizeof(s_szFmts[0]);

    for (idx = 0; idx < cCnt; idx++) {

        if (lstrcmpi(lpszFmt, s_szFmts[idx]) == 0)
            return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_ValAtrFidelity (Local Routine)
*
* Validates the attribute-fidelity.
*
\*****************************************************************************/
BOOL ipp_ValAtrFidelity(
    DWORD  dwVal,
    LPBOOL lpbFidelity)
{
    if (dwVal == 1) {

        *lpbFidelity = TRUE;

    } else if (dwVal == 0) {

        *lpbFidelity = FALSE;

    } else {

        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_ValWhichJobs (Local Routine)
*
* Validates the which-jobs.
*
\*****************************************************************************/
BOOL ipp_ValWhichJobs(
    PDWORD  pfReq,
    LPCTSTR lpszWJ)
{
    DWORD idx;
    DWORD cCnt;

    static FLGSTR s_fsVal[] = {

        RA_JOBSCOMPLETED  , s_szCompleted   ,
        RA_JOBSUNCOMPLETED, s_szNotCompleted
    };

    cCnt = sizeof(s_fsVal) / sizeof(s_fsVal[0]);

    for (idx = 0; idx < cCnt; idx++) {

        if (lstrcmpi(lpszWJ, s_fsVal[idx].pszStr) == 0) {

            x_SetReq(pfReq, s_fsVal[idx].fFlag);

            return TRUE;
        }
    }

    return FALSE;
}


/*****************************************************************************\
* ipp_GetRspSta (Local Routine)
*
* Returns the response-code and any status messages if failure.
*
\*****************************************************************************/
WORD ipp_GetRspSta(
    WORD    wRsp,
    UINT    cpReq,
    LPSTR*  lplputfNamSta,
    LPDWORD lpcbNamSta,
    LPSTR*  lplputfValSta,
    LPDWORD lpcbValSta)
{
    DWORD idx;
    DWORD cErrors;


    *lplputfNamSta = NULL;
    *lplputfValSta = NULL;
    *lpcbNamSta    = 0;
    *lpcbValSta    = 0;


    if (SUCCESS_RANGE(wRsp) == FALSE) {

        // Get the status-name.
        //
        *lplputfNamSta = webTCtoMB(CP_ACP, s_szStaMsg, lpcbNamSta);


        // Get the string we will be using to encode the error.
        //
        cErrors = sizeof(s_LEIpp) / sizeof(s_LEIpp[0]);

        for (idx = 0; idx < cErrors; idx++) {

            if (wRsp == s_LEIpp[idx].wRsp) {

                *lplputfValSta = webTCtoMB(cpReq, s_LEIpp[idx].pszStr, lpcbValSta);

                break;
            }
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_CvtW32Val (Local Routine - Server)
*
* Converts a value to the appropriate ipp-value.
*
\*****************************************************************************/
VOID ipp_CvtW32Val(
    LPCTSTR lpszName,
    LPVOID  lpvVal)
{
    if (lstrcmpi(lpszName, s_szPrtState) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppPrnState(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobState) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobState(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobKOctets) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobSize(*(LPDWORD)lpvVal);

    } else if (lstrcmpi(lpszName, s_szJobKOctetsProcess) == 0) {

        *(LPDWORD)lpvVal = ipp_W32ToIppJobSize(*(LPDWORD)lpvVal);
    }
}


/*****************************************************************************\
* ipp_AllocUnsVals
*
* Allocates an array of ipp-values used to write to a stream.
*
\*****************************************************************************/
LPIPPATTRY ipp_AllocUnsVals(
    PWEBLST pwlUns,
    LPDWORD pcUns,
    LPDWORD lpcbAtrs)
{
    DWORD      idx;
    DWORD      cUns;
    DWORD      cbUns;
    PCTSTR     pszStr;
    LPIPPATTRY pUns = NULL;


    *pcUns = 0;

    if (pwlUns && (cUns = pwlUns->Count())) {

        if (pUns = (LPIPPATTRY)webAlloc(cUns * sizeof(IPPATTRY))) {

            *lpcbAtrs += IPP_SIZEOFTAG;
            *pcUns     = cUns;


            // Loop through each item and convert for addition to stream.
            //
            pwlUns->Reset();

            for (idx = 0; idx < cUns; idx++) {

                if (pszStr = pwlUns->Get()) {

                    pUns[idx].pszNam = webTCtoMB(CP_ACP, pszStr         , &pUns[idx].cbNam);


                    // Unsupported-values should be null.
                    //
                    pUns[idx].pszVal = NULL;
                    pUns[idx].cbVal  = 0;

                    *lpcbAtrs += ipp_SizeAttr(pUns[idx].cbNam, pUns[idx].cbVal);
                }

                pwlUns->Next();
            }
        }
    }

    return pUns;
}


/*****************************************************************************\
* ipp_AllocAtrVals
*
* Allocates an array of ipp-values used to write to a stream.
*
\*****************************************************************************/
LPIPPATTRY ipp_AllocAtrVals(
    WORD       wReq,
    PDWORD     pfReq,
    UINT       cpReq,
    LPBYTE     lpbData,
    LPIPPATTRX pRsp,
    DWORD      cAtr,
    LPDWORD    lpcbAtrs)
{
    BOOL       bRet = FALSE;
    BOOL       fWr;
    DWORD      idx;
    BOOL       bDel;
    LPVOID     lpvVal;
    LPIPPATTRY pAtr = NULL;


    if (cAtr && (pAtr = (LPIPPATTRY)webAlloc(cAtr * sizeof(IPPATTRY)))) {

        // Allocate the attribute-values.
        //
        for (idx = 0, fWr = TRUE; idx < cAtr; idx++) {

            bDel = FALSE;

            // Build the attribute-name.
            //
            if (pRsp[idx].pszNam) {

                pAtr[idx].pszNam = webTCtoMB(CP_ACP, pRsp[idx].pszNam, &pAtr[idx].cbNam);

                // If the value is absolute, then assign the
                // attribute directly.  Otherwise, it's an offset into
                // the return-structure, and as such, must be indirectly
                // built.
                //
                if (pRsp[idx].nVal == IPP_ATR_ABSOLUTE) {

                    // Special-case the printer-up-time to reflect the number
                    // of seconds it's been up and running.  Since we can't
                    // determine the time the printer's been up, use the time
                    // windows has been started.
                    //
                    if (lstrcmpi(pRsp[idx].pszNam, s_szPrtUpTime) == 0)
                        pRsp[idx].pvVal = (LPVOID)ULongToPtr (ipp_IppCurTime());
                    else
                        lpvVal = (LPVOID)&pRsp[idx].pvVal;

                } else {

                    lpvVal = (LPVOID)(lpbData + (DWORD_PTR)pRsp[idx].pvVal);
                }

                fWr = x_ChkReq(pfReq, pRsp[idx].fReq);
            }


            // Add it to the stream if it is a request or if
            // the response requires it.
            //
            if (fWr || !(wReq & IPP_RESPONSE)) {

                // If the value is absolute, then assign the
                // attribute directly.  Otherwise, it's an offset into
                // the return-structure, and as such, must be indirectly
                // built.
                //
                if (pRsp[idx].nVal == IPP_ATR_ABSOLUTE)
                    lpvVal = (LPVOID)&pRsp[idx].pvVal;
                else
                    lpvVal = (LPVOID)(lpbData + (DWORD_PTR)pRsp[idx].pvVal);


                // Build the attribute-value.
                //
                if (IS_TAG_DELIMITER(pRsp[idx].bTag)) {

                    bDel = TRUE;

                } else if (IS_TAG_OCTSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(CP_UTF8, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else if (IS_TAG_CHARSETSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(cpReq, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else if (IS_TAG_CHRSTR(pRsp[idx].bTag)) {

                    pAtr[idx].pszVal = webTCtoMB(CP_ACP, *(LPTSTR*)lpvVal, &pAtr[idx].cbVal);

                } else {

                    pAtr[idx].pszVal = (LPSTR)webAlloc(sizeof(DWORD));

                    if ( !pAtr[idx].pszVal )
                        goto Cleanup;

                    if (pRsp[idx].bTag == IPP_TAG_INT_BOOLEAN) {

                        pAtr[idx].cbVal = IPP_SIZEOFBYTE;

                    } else {

                        pAtr[idx].cbVal = IPP_SIZEOFINT;
                    }

                    CopyMemory(pAtr[idx].pszVal, lpvVal, pAtr[idx].cbVal);


                    // Do we need to convert the value.
                    //
                    if (pRsp[idx].nVal == IPP_ATR_OFFSETCONV)
                        ipp_CvtW32Val(pRsp[idx].pszNam, (LPVOID)pAtr[idx].pszVal);
                }


                // If this is a delimiter then it only occupies 1 byte.
                //
                if (bDel)
                    *lpcbAtrs += IPP_SIZEOFTAG;
                else
                    *lpcbAtrs += ipp_SizeAttr(pAtr[idx].cbNam, pAtr[idx].cbVal);
            }
        }
    }

    bRet = TRUE;

Cleanup:
    if ( !bRet && pAtr ) {

        for (idx = 0 ; idx < cAtr; ++idx)
            if ( pAtr[idx].pszVal )
                webFree(pAtr[idx].pszVal);

        webFree(pAtr);
        pAtr = NULL;
    }

    return pAtr;
}


/*****************************************************************************\
* ipp_WriteUnsVals
*
* Writes an array of ipp-values to an ipp-stream.
*
\*****************************************************************************/
BOOL ipp_WriteUnsVals(
    LPBYTE*    lplpIppPtr,
    LPIPPATTRY pUns,
    DWORD      cUns)
{
    DWORD idx;


    if (pUns && cUns) {

        ipp_WriteByte(lplpIppPtr, IPP_TAG_DEL_UNSUPPORTED);


        // Unsupported values should be null.
        //
        for (idx = 0; idx < cUns; idx++)
            ipp_WriteAttr(lplpIppPtr, IPP_TAG_OUT_UNSUPPORTED, pUns[idx].cbNam, pUns[idx].pszNam, 0, NULL);
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_WriteAtrVals
*
* Writes an array of ipp-values to an ipp-stream.
*
\*****************************************************************************/
BOOL ipp_WriteAtrVals(
    WORD       wReq,
    PDWORD     pfReq,
    LPBYTE*    lplpIppPtr,
    LPIPPATTRX pRsp,
    LPIPPATTRY pAtr,
    DWORD      cAtr)
{
    BOOL  fWr;
    DWORD idx;


    for (idx = 0, fWr = TRUE; idx < cAtr; idx++) {

        // If this item has a name-tag, then determine if the
        // originator wants it in the stream.
        //
        if (pRsp[idx].pszNam)
            fWr = x_ChkReq(pfReq, pRsp[idx].fReq);


        // Only write out the item if it is requested, or if
        // it is a request-operation.
        //
        if (fWr || !(wReq & IPP_RESPONSE)) {

            if (pRsp[idx].nVal == IPP_ATR_TAG)
                ipp_WriteByte(lplpIppPtr, pRsp[idx].bTag);
            else
                ipp_WriteAttr(lplpIppPtr, pRsp[idx].bTag, pAtr[idx].cbNam, pAtr[idx].pszNam, pAtr[idx].cbVal, pAtr[idx].pszVal);
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_FreeAtrVals
*
* Frees array of attribute values.
*
\*****************************************************************************/
VOID ipp_FreeAtrVals(
    LPIPPATTRY pAtr,
    DWORD      cAtr)
{
    DWORD idx;


    // Free up the attribute-values.
    //
    for (idx = 0; idx < cAtr; idx++) {

        webFree(pAtr[idx].pszNam);
        webFree(pAtr[idx].pszVal);
    }

    webFree(pAtr);
}


/*****************************************************************************\
* ipp_FreeIPPJI2 (Local Routine)
*
* Frees up the IPPJI2 memory.
*
\*****************************************************************************/
VOID ipp_FreeIPPJI2(
    LPIPPJI2 lpji)
{
    DWORD cCnt;
    DWORD idx;


    // Free JI2-Data.
    //
    cCnt = ((sizeof(s_JI2Off) / sizeof(s_JI2Off[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lpji->ji2) + s_JI2Off[idx]));


    // Free IPP-Data.
    //
    cCnt = ((sizeof(s_IPJOff) / sizeof(s_IPJOff[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lpji->ipp) + s_IPJOff[idx]));
}


/*****************************************************************************\
* ipp_FreeIPPPI2 (Local Routine)
*
* Frees up the IPPPI2 memory.
*
\*****************************************************************************/
VOID ipp_FreeIPPPI2(
    LPIPPPI2 lppi)
{
    DWORD cCnt;
    DWORD idx;


    // Free PI2-Data.
    //
    cCnt = ((sizeof(s_PI2Off) / sizeof(s_PI2Off[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lppi->pi2) + s_PI2Off[idx]));


    // Free IPP-Data.
    //
    cCnt = ((sizeof(s_IPPOff) / sizeof(s_IPPOff[0])) - 1);

    for (idx = 0; idx < cCnt; idx++)
        webFree(*(LPBYTE *)(((LPBYTE)&lppi->ipp) + s_IPPOff[idx]));

}


/*****************************************************************************\
* ipp_GetIPPJI2 (Local Routine)
*
* Returns the info for a complete job in the IPP stream.  We essentially
* loop through the attributes looking for the next IPP_TAG_DEL_JOB to
* signify another job-info-item.
*
\*****************************************************************************/
LPBYTE ipp_GetIPPJI2(
    LPBYTE   lpbTag,
    LPIPPJI2 lpji,
    LPDWORD  lpcbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    BYTE      bTag;
    DWORD     idx;
    DWORD     cAtr;
    BOOL      bReq;
    BOOL      bFound;
    DWORD     fAtr[IPPOBJ_MASK_SIZE];
    BOOL      bFid = FALSE;
    BOOL      bAtr = FALSE;
    BOOL      bEnu = FALSE;


    x_SetReq(fAtr, IPP_REQALL);

    bTag = ipp_ReadByte(lpbTag, 0);
    bReq = ((lpObj->wReq & IPP_RESPONSE) ? FALSE : TRUE);
    bEnu = (BOOL)(lpObj->wReq & IPP_REQ_ENUJOB);

    while ((!bEnu || (bTag != IPP_TAG_DEL_JOB)) && (bTag != IPP_TAG_DEL_DATA)) {

        if (lpAttr = ipp_GetAttr(lpbTag, *lpcbIdx, lpObj)) {

            if (lpAttr->lpszName && lpAttr->lpValue) {

                if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpAttr->cbValue > SIZE_CHARSET)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpAttr->cbValue > SIZE_NATLANG)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobId) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.JobId = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobLimit) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ipp.cJobs = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobState) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Status = ipp_IppToW32JobState(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobPri) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Priority = ipp_IppToW32JobPriority(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobKOctets) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Size = ipp_IppToW32JobSize(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobKOctetsProcess) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.Size = ipp_IppToW32JobSize(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobSheets) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.TotalPages = ipp_IppToW32JobTotalPages(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobSheetsCompleted) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lpji->ji2.PagesPrinted = ipp_IppToW32JobPagesPrinted(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pDocument);
                        lpji->ji2.pDocument = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pDocument);
                        lpji->ji2.pDocument = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobOrgUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pUserName);
                        lpji->ji2.pUserName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ji2.pUserName);
                        lpji->ji2.pUserName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pJobUri);
                        lpji->ipp.pJobUri = webAllocStr((LPTSTR)lpAttr->lpValue);

                        if (bReq && lpji->ipp.pJobUri)
                            lpji->ji2.JobId = ipp_JidFromUri(lpji->ipp.pJobUri);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pPrnUri);
                        lpji->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lpji->ipp.pPrnUri);
                        lpji->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocFormat) == 0) {

                    if (lpAttr->cbValue > SIZE_MIMEMEDIA) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValDocFormat((PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40A;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szAtrFidelity) == 0) {

                    if (lpAttr->cbValue != SIZE_BOOLEAN) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValAtrFidelity(*(LPDWORD)lpAttr->lpValue, &bFid) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_400;
                        else
                            lpObj->fState |= (bFid ? IPPFLG_USEFIDELITY : 0);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szWhichJobs) == 0) {

                    if (lpAttr->cbValue > SIZE_KEYWORD) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValWhichJobs(fAtr, (PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40B;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szTimeAtCreation) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        ipp_IppToW32Time(*(LPDWORD)lpAttr->lpValue, &lpji->ji2.Submitted);
                    }

                } else if (bReq && (lstrcmpi(lpAttr->lpszName, s_szReqAttr) == 0)) {

                    bAtr = TRUE;

                    x_SetReq(fAtr, IPP_REQCLEAR);

                    goto ProcessVal;

                } else {

                    lpObj->pwlUns->Add(lpAttr->lpszName);
                }

            } else if (bAtr && lpAttr->lpValue) {

ProcessVal:
                if (lpAttr->cbValue > SIZE_KEYWORD) {

                    lpObj->wError = IPPRSP_ERROR_409;

                } else {

                    if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szAll) == 0) {

                        x_SetReq(fAtr, IPP_REQALL);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobTemplate) == 0) {

                        x_SetReq(fAtr, IPP_REQJTMP);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobDescription) == 0) {

                        x_SetReq(fAtr, IPP_REQJDSC);

                    } else {

                        // Walk through the possible response attributes
                        // and look for those requested.
                        //
                        cAtr = sizeof(s_PJR) / sizeof(s_PJR[0]);

                        for (idx = 0, bFound = FALSE; idx < cAtr; idx++) {

                            if (s_PJR[idx].pszNam) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_PJR[idx].pszNam) == 0) {

                                    x_SetReq(fAtr, s_PJR[idx].fReq);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }


                        // Look through potential request/response mappings.  This
                        // is necessary for request that have a different name
                        // than that we give back in a response.  i.e. JobReqUser
                        // verses JobOrgUser.
                        //
                        if (bFound == FALSE) {

                            cAtr = sizeof(s_ReqRspStr) / sizeof(s_ReqRspStr[0]);

                            for (idx = 0; idx < cAtr; idx++) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_ReqRspStr[idx].pszStr) == 0) {

                                    x_SetReq(fAtr, s_ReqRspStr[idx].fFlag);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }

                        if (!bFound)
                            lpObj->pwlUns->Add((PCTSTR)lpAttr->lpValue);
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }

        if (ERROR_RANGE(lpObj->wError))
            break;


        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, lpcbIdx, lpObj->cbIppHdr))
            bTag = ipp_ReadByte(lpbTag, 0);
        else
            break;
    }


    // If the fidelity is desired, then we should have
    // no unsupported attributes.
    //
    if (bFid && (lpObj->pwlUns->Count()))
        lpObj->wError = IPPRSP_ERROR_40B;


    // Set the internal-state
    //
    if (bAtr)
        CopyMemory(lpObj->fReq, fAtr, IPPOBJ_MASK_SIZE * sizeof(DWORD));

    return lpbTag;
}


/*****************************************************************************\
* ipp_GetIPPPI2 (Local Routine)
*
* Returns the info for a complete job in the IPP stream.  We essentially
* loop through the attributes looking for the next IPP_TAG_DEL_JOB to
* signify another printer-info-item.
*
\*****************************************************************************/
LPBYTE ipp_GetIPPPI2(
    LPBYTE   lpbTag,
    LPIPPPI2 lppi,
    LPDWORD  lpcbIdx,
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    BYTE      bTag;
    DWORD     cAtr;
    DWORD     idx;
    BOOL      bReq;
    BOOL      bFound;
    DWORD     fAtr[IPPOBJ_MASK_SIZE];
    BOOL      bAtr = FALSE;


    x_SetReq(fAtr, IPP_REQALL);


    bTag = ipp_ReadByte(lpbTag, 0);
    bReq = ((lpObj->wReq & IPP_RESPONSE) ? FALSE : TRUE);


    while ((bTag != IPP_TAG_DEL_PRINTER) && (bTag != IPP_TAG_DEL_DATA)) {

        if (lpAttr = ipp_GetAttr(lpbTag, *lpcbIdx, lpObj)) {

            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName && lpAttr->lpValue) {

                if (lstrcmpi(lpAttr->lpszName, s_szPrtUpTime) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER) {
                        lpObj->wError = IPPRSP_ERROR_409;
                    } else {
                        // What we want to do is get the current time in seconds and then
                        // work out what the T0 of the printer must be in this renormalised
                        // time

                        // These will be positive, we assume [0..2^31-1]
                        DWORD dwCurTime = ipp_IppCurTime();  
                        DWORD  dwPrtTime = *(LPDWORD) lpAttr->lpValue;   

                        lppi->ipp.dwPowerUpTime = (time_t)dwCurTime - (time_t)dwPrtTime;
                   }

                } else if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpAttr->cbValue > SIZE_CHARSET)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpAttr->cbValue > SIZE_NATLANG)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtState) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lppi->pi2.Status = ipp_IppToW32PrnState(*(LPDWORD)lpAttr->lpValue);

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtJobs) == 0) {

                    if (lpAttr->cbValue != SIZE_INTEGER)
                        lpObj->wError = IPPRSP_ERROR_409;
                    else
                        lppi->pi2.cJobs = *(LPDWORD)lpAttr->lpValue;

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtName) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->pi2.pPrinterName);
                        lppi->pi2.pPrinterName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUri) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pPrnUri);
                        lppi->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pUsrName);
                        lppi->ipp.pUsrName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtUriSupported) == 0) {

                    if (lpAttr->cbValue > SIZE_URI) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->ipp.pPrnUri);
                        lppi->ipp.pPrnUri = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szPrtMake) == 0) {

                    if (lpAttr->cbValue > SIZE_TEXT) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        webFree(lppi->pi2.pDriverName);
                        lppi->pi2.pDriverName = webAllocStr((LPTSTR)lpAttr->lpValue);
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szDocFormat) == 0) {

                    if (lpAttr->cbValue > SIZE_MIMEMEDIA) {

                        lpObj->wError = IPPRSP_ERROR_409;

                    } else {

                        if (ipp_ValDocFormat((PCTSTR)lpAttr->lpValue) == FALSE)
                            lpObj->wError = IPPRSP_ERROR_40A;
                    }

                } else if (lstrcmpi(lpAttr->lpszName, s_szJobReqUser) == 0) {

                    if (lpAttr->cbValue > SIZE_NAME)
                        lpObj->wError = IPPRSP_ERROR_409;

                } else if (bReq && (lstrcmpi(lpAttr->lpszName, s_szReqAttr) == 0)) {

                    bAtr = TRUE;

                    x_SetReq(fAtr, IPP_REQCLEAR);

                    goto ProcessVal;

                } else {

                    lpObj->pwlUns->Add(lpAttr->lpszName);
                }

            } else if (bAtr && lpAttr->lpValue) {

ProcessVal:
                if (lpAttr->cbValue > SIZE_KEYWORD) {

                    lpObj->wError = IPPRSP_ERROR_409;

                } else {

                    if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szAll) == 0) {

                        x_SetReq(fAtr, IPP_REQALL);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szJobTemplate) == 0) {

                        x_SetReq(fAtr, IPP_REQPTMP);

                    } else if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_szPrtDescription) == 0) {

                        x_SetReq(fAtr, IPP_REQPDSC);

                    } else {

                        // Walk through the possible response attributes
                        // and look for those requested.
                        //
                        cAtr = sizeof(s_GPR) / sizeof(s_GPR[0]);

                        for (idx = 0, bFound = FALSE; idx < cAtr; idx++) {

                            if (s_GPR[idx].pszNam) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_GPR[idx].pszNam) == 0) {

                                    x_SetReq(fAtr, s_GPR[idx].fReq);

                                    bFound = TRUE;

                                    break;
                                }
                            }
                        }


                        // Look through potential request/response mappings.  This
                        // is necessary for request that have a different name
                        // than that we give back in a response.  i.e. JobReqUser
                        // verses JobOrgUser.
                        //
                        if (bFound == FALSE) {

                            cAtr = sizeof(s_ReqRspStr) / sizeof(s_ReqRspStr[0]);

                            for (idx = 0; idx < cAtr; idx++) {

                                if (lstrcmpi((PCTSTR)lpAttr->lpValue, s_ReqRspStr[idx].pszStr) == 0)
                                    x_SetReq(fAtr, s_ReqRspStr[idx].fFlag);
                            }
                        }

                        if (!bFound)
                            lpObj->pwlUns->Add((PCTSTR)lpAttr->lpValue);
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;


        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, lpcbIdx, lpObj->cbIppHdr))
            bTag = ipp_ReadByte(lpbTag, 0);
        else
            break;
    }


    // Set the internal-state
    //
    if (bAtr)
        CopyMemory(lpObj->fReq, fAtr, IPPOBJ_MASK_SIZE * sizeof(DWORD));

    return lpbTag;
}


/*****************************************************************************\
* ipp_CopyJI2toIPPJI2 (Local Routine)
*
* Copies a JOB_INFO_2 to IPPJI2.
*
\*****************************************************************************/
LPBYTE ipp_CopyJI2toIPPJI2(
    LPIPPJI2     lpjiDst,
    LPJOB_INFO_2 lpJI2,
    LPTSTR       lpszJobBase,
    LPBYTE       lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  lpszPtr;
    LPTSTR  lpszJobUri;
    LPTSTR  lpszPrnUri;
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];


    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc , sizeof(aszSrc));
    ZeroMemory(lpjiDst, sizeof(IPPJI2));


    // Copy fixed values.
    //
    lpjiDst->ji2.JobId        = lpJI2->JobId;
    lpjiDst->ji2.Status       = ipp_W32ToIppJobState(lpJI2->Status);
    lpjiDst->ji2.Priority     = ipp_W32ToIppJobPriority(lpJI2->Priority);
    lpjiDst->ji2.Size         = ipp_W32ToIppJobSize(lpJI2->Size);
    lpjiDst->ji2.TotalPages   = ipp_W32ToIppJobTotalPages(lpJI2->TotalPages);
    lpjiDst->ji2.PagesPrinted = ipp_W32ToIppJobPagesPrinted(lpJI2->PagesPrinted);

    *((LPDWORD)&lpjiDst->ji2.Submitted) = ipp_W32ToIppTime(&lpJI2->Submitted);


    // Build a job-uri.
    //
    if (lpszJobUri = (LPTSTR)webAlloc(webStrSize(lpszJobBase) + 80))
        wsprintf(lpszJobUri, TEXT("%s%d"), lpszJobBase, lpJI2->JobId);


    // Build a printer-uri.
    //
    lpszPrnUri = NULL;

    if (lpszJobBase && (lpszPtr = webFindRChar(lpszJobBase, TEXT('?')))) {

        *lpszPtr = TEXT('\0');
        lpszPrnUri = (LPTSTR)webAllocStr(lpszJobBase);
        *lpszPtr = TEXT('?');
    }


    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = lpJI2->pPrinterName;
    *lpszSrc++ = lpJI2->pMachineName;
    *lpszSrc++ = lpJI2->pUserName;
    *lpszSrc++ = lpJI2->pDocument;
    *lpszSrc++ = lpJI2->pNotifyName;
    *lpszSrc++ = lpJI2->pDatatype;
    *lpszSrc++ = lpJI2->pPrintProcessor;
    *lpszSrc++ = lpJI2->pParameters;
    *lpszSrc++ = lpJI2->pDriverName;
    *lpszSrc++ = NULL;
    *lpszSrc++ = lpJI2->pStatus;
    *lpszSrc++ = NULL;
    *lpszSrc++ = lpszPrnUri;
    *lpszSrc++ = lpszJobUri;

    lpbEnd = ipp_PackStrings(aszSrc, (LPBYTE)lpjiDst, s_IPPJI2Offs, lpbEnd);

    webFree(lpszJobUri);
    webFree(lpszPrnUri);

    return lpbEnd;
}


/*****************************************************************************\
* ipp_SizeofIPPPI2 (Local Routine)
*
* Returns the size necessary to store a IPPPI2 struct.  This excludes the
* DEVMODE and SECURITYDESCRIPTOR fields.
*
\*****************************************************************************/
DWORD ipp_SizeofIPPPI2(
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp)
{
    DWORD  cCnt;
    DWORD  idx;
    DWORD  cbSize;
    LPTSTR lpszStr;

    // Default Size.
    //
    cbSize = 0;


    // Get the size necessary for PRINTER_INFO_2 structure.
    //
    if (lppi2) {

        cCnt = ((sizeof(s_PI2Off) / sizeof(s_PI2Off[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lppi2) + s_PI2Off[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }


    // Get the size necessary for PRINTER_INFO_IPP structure.
    //
    if (lpipp) {

       cCnt = ((sizeof(s_IPPOff) / sizeof(s_IPPOff[0])) - 1);

       for (idx = 0; idx < cCnt; idx++) {

           lpszStr = *(LPTSTR*)(((LPBYTE)lpipp) + s_IPPOff[idx]);

           cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
       }
   }

    return cbSize;
}


/*****************************************************************************\
* ipp_SizeofIPPJI2 (Local Routine)
*
* Returns the size necessary to store a IPPJI2 struct.  This excludes the
* DEVMODE and SECURITYDESCRIPTOR fields.
*
\*****************************************************************************/
DWORD ipp_SizeofIPPJI2(
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp)
{
    DWORD  cCnt;
    DWORD  idx;
    DWORD  cbSize;
    LPTSTR lpszStr;

    // Default Size.
    //
    cbSize = 0;


    // Get the size necessary for JOB_INFO_2 structure.
    //
    if (lpji2) {

        cCnt = ((sizeof(s_JI2Off) / sizeof(s_JI2Off[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lpji2) + s_JI2Off[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }


    // Get the size necessary for JOB_INFO_IPP structure.
    //
    if (lpipp) {

        cCnt = ((sizeof(s_IPJOff) / sizeof(s_IPJOff[0])) - 1);

        for (idx = 0; idx < cCnt; idx++) {

            lpszStr = *(LPTSTR*)(((LPBYTE)lpipp) + s_IPJOff[idx]);

            cbSize += (lpszStr ? webStrSize(lpszStr) : 0);
        }
    }

    return cbSize;
}


/*****************************************************************************\
* ipp_BuildPI2 (Local Routine)
*
* Builds a IPPPI2 struct from PRINTER_INFO_2 and PRINTER_INFO_IPP.
*
\*****************************************************************************/
LPBYTE ipp_BuildPI2(
    LPIPPPI2           lppi,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp,
    LPBYTE             lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  aszSrc[(sizeof(IPPPI2) / sizeof(LPTSTR))];


    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc, sizeof(aszSrc));
    ZeroMemory(lppi  , sizeof(IPPPI2));


    // Copy fixed values.
    //
    if (lppi2) {

        lppi->pi2.Attributes      = lppi2->Attributes;
        lppi->pi2.Priority        = lppi2->Priority;
        lppi->pi2.DefaultPriority = lppi2->DefaultPriority;
        lppi->pi2.StartTime       = lppi2->StartTime;
        lppi->pi2.UntilTime       = lppi2->UntilTime;
        lppi->pi2.Status          = lppi2->Status;
        lppi->pi2.cJobs           = lppi2->cJobs;
        lppi->pi2.AveragePPM      = lppi2->AveragePPM;
     }


    lppi->ipp.dwPowerUpTime       = (lpipp ? lpipp->dwPowerUpTime : 0);
    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = (lppi2 ? lppi2->pServerName     : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPrinterName    : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pShareName      : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPortName       : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pDriverName     : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pComment        : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pLocation       : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lppi2 ? lppi2->pSepFile        : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pPrintProcessor : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pDatatype       : NULL);
    *lpszSrc++ = (lppi2 ? lppi2->pParameters     : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpipp ? lpipp->pPrnUri         : NULL);
    *lpszSrc++ = (lpipp ? lpipp->pUsrName        : NULL);

    return ipp_PackStrings(aszSrc, (LPBYTE)lppi, s_IPPPI2Offs, lpbEnd);
}


/*****************************************************************************\
* ipp_BuildJI2 (Local Routine)
*
* Builds a IPPJI2 struct from JOB_INFO_2 and JOB_INFO_IPP.
*
\*****************************************************************************/
LPBYTE ipp_BuildJI2(
    LPIPPJI2       lpji,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp,
    LPBYTE         lpbEnd)
{
    LPTSTR* lpszSrc;
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];

    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc, sizeof(aszSrc));
    ZeroMemory(lpji, sizeof(IPPJI2));


    // Copy fixed values.
    //
    if (lpji2) {

        lpji->ji2.JobId        = lpji2->JobId;
        lpji->ji2.Status       = lpji2->Status;
        lpji->ji2.Priority     = lpji2->Priority;
        lpji->ji2.Position     = lpji2->Position;
        lpji->ji2.StartTime    = lpji2->StartTime;
        lpji->ji2.UntilTime    = lpji2->UntilTime;
        lpji->ji2.TotalPages   = lpji2->TotalPages;
        lpji->ji2.Size         = lpji2->Size;
        lpji->ji2.Time         = lpji2->Time;
        lpji->ji2.PagesPrinted = lpji2->PagesPrinted;
        lpji->ji2.StartTime    = lpji2->StartTime;

        CopyMemory(&lpji->ji2.Submitted, &lpji2->Submitted, sizeof(SYSTEMTIME));
    }


    // Copy strings.  Make sure we place the strings in the appropriate
    // offset.
    //
    lpszSrc = aszSrc;

    *lpszSrc++ = (lpji2 ? lpji2->pPrinterName    : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pMachineName    : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pUserName       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDocument       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pNotifyName     : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDatatype       : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pPrintProcessor : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pParameters     : NULL);
    *lpszSrc++ = (lpji2 ? lpji2->pDriverName     : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpji2 ? lpji2->pStatus         : NULL);
    *lpszSrc++ = NULL;
    *lpszSrc++ = (lpipp ? lpipp->pPrnUri         : NULL);
    *lpszSrc++ = (lpipp ? lpipp->pJobUri         : NULL);

    return ipp_PackStrings(aszSrc, (LPBYTE)lpji, s_IPPJI2Offs, lpbEnd);
}


/*****************************************************************************\
* ipp_GetJobCount (Local Routine)
*
* Returns the total number of jobs in an enumerated GETJOB response.
*
\*****************************************************************************/
DWORD ipp_GetJobCount(
    LPBYTE lpbHdr,
    DWORD  cbHdr)
{
    DWORD  cbIdx;
    LPBYTE lpbTag;
    DWORD  cJobs = 0;


    // Position the tag at the start of the header.
    //
    lpbTag = lpbHdr + IPP_SIZEOFHDR;


    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {

        // If we hit a job-deliminator, then we have a job-info item.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB)
            cJobs++;


        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpbHdr, &cbIdx, cbHdr);
    }

    return cJobs;
}


/*****************************************************************************\
* ipp_IppToW32 (Local Routine - Client/Server)
*
* Converts an Ipp-Header to a W32-Structure.
*
\*****************************************************************************/
DWORD ipp_IppToW32(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    DWORD        cbIdx;
    DWORD        dwCmd;
    IPPJI2       ji;
    IPPPI2       pi;
    PIPPREQ_ALL  pr;
    UINT         uType = IPPTYPE_UNKNOWN;
    DWORD        dwRet = WEBIPP_FAIL;


    // Position the tag at the Tag/Attributes and fetch the information
    // for the request.
    //
    cbIdx = IPP_SIZEOFHDR;

    switch (lpObj->wReq) {

    case IPP_REQ_PRINTJOB:
    case IPP_REQ_VALIDATEJOB:
    case IPP_REQ_GETJOB:
    case IPP_REQ_CANCELJOB:
    case IPP_REQ_PAUSEJOB:
    case IPP_REQ_RESUMEJOB:
    case IPP_REQ_RESTARTJOB:
    case IPP_REQ_ENUJOB:
        ZeroMemory(&ji, sizeof(IPPJI2));
        ji.ipp.cJobs = IPP_GETJOB_ALL;

        ipp_GetIPPJI2(lpObj->lpIppHdr + IPP_SIZEOFHDR, &ji, &cbIdx, lpObj);

        uType = IPPTYPE_JOB;
        break;

    case IPP_REQ_GETPRN:
    case IPP_REQ_PAUSEPRN:
    case IPP_REQ_CANCELPRN:
    case IPP_REQ_RESUMEPRN:
        ZeroMemory(&pi, sizeof(IPPPI2));
        ipp_GetIPPPI2(lpObj->lpIppHdr + IPP_SIZEOFHDR, &pi, &cbIdx, lpObj);

        uType = IPPTYPE_PRT;
        break;

    case IPP_REQ_FORCEAUTH:
        uType = IPPTYPE_AUTH;
        break;
    }


    // If a failure occured, then there's no need to proceed.
    //
    if (ERROR_RANGE(lpObj->wError))
        goto EndCvt;


    // Initialize any default-values, that may have been overlooked
    // in the request-stream.
    //
    switch (uType) {

    case IPPTYPE_JOB:

        if (ji.ji2.pUserName == NULL)
            ji.ji2.pUserName = webAllocStr(s_szUnknown);

        if (ji.ji2.pDocument == NULL)
            ji.ji2.pDocument = webAllocStr(s_szUnknown);
        break;

    case IPPTYPE_PRT:

        if (pi.pi2.pPrinterName == NULL)
            pi.pi2.pPrinterName = webAllocStr(s_szUnknown);
        break;
    }


    // Build the request structure based upon the request command.
    //
    switch (lpObj->wReq) {

    case IPP_REQ_PRINTJOB:
        pr = (PIPPREQ_ALL)WebIppCreatePrtJobReq(FALSE, ji.ji2.pUserName, ji.ji2.pDocument, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_VALIDATEJOB:
        pr = (PIPPREQ_ALL)WebIppCreatePrtJobReq(TRUE, ji.ji2.pUserName, ji.ji2.pDocument, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_ENUJOB:
        pr = (PIPPREQ_ALL)WebIppCreateEnuJobReq(ji.ipp.cJobs, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_CANCELJOB:
    case IPP_REQ_PAUSEJOB:
    case IPP_REQ_RESUMEJOB:
    case IPP_REQ_RESTARTJOB:
        dwCmd = ipp_MapReqToJobCmd(lpObj->wReq);
        pr = (PIPPREQ_ALL)WebIppCreateSetJobReq(ji.ji2.JobId, dwCmd, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_GETJOB:
        pr = (PIPPREQ_ALL)WebIppCreateGetJobReq(ji.ji2.JobId, ji.ipp.pPrnUri);
        break;

    case IPP_REQ_GETPRN:
        pr = (PIPPREQ_ALL)WebIppCreateGetPrnReq(0, pi.ipp.pPrnUri);
        break;

    case IPP_REQ_PAUSEPRN:
    case IPP_REQ_CANCELPRN:
    case IPP_REQ_RESUMEPRN:
        dwCmd = ipp_MapReqToPrnCmd(lpObj->wReq);
        pr = (PIPPREQ_ALL)WebIppCreateSetPrnReq(dwCmd, pi.ipp.pUsrName, pi.ipp.pPrnUri);
        break;

    case IPP_REQ_FORCEAUTH:
        pr = (PIPPREQ_AUTH)WebIppCreateAuthReq();
        break;

    default:
        pr = NULL;
        break;
    }


    // Set the return values.
    //
    if (pr) {

        *lplpRawHdr = (LPBYTE)pr;
        *lpcbRawHdr = pr->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


EndCvt:

    // Cleanup.
    //
    switch (uType) {

    case IPPTYPE_JOB:
        ipp_FreeIPPJI2(&ji);
        break;

    case IPPTYPE_PRT:
        ipp_FreeIPPPI2(&pi);
        break;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_W32ToIpp (Local Routine - Client/Server)
*
* Converts a W32 information to an IPP Header (both request and responses).
*
\*****************************************************************************/
DWORD ipp_W32ToIpp(
    WORD       wReq,
    LPREQINFO  lpri,
    LPBYTE     lpbData,
    LPIPPATTRX pSnd,
    DWORD      cSnd,
    LPBYTE*    lplpIppHdr,
    LPDWORD    lpcbIppHdr)
{
    LPIPPRET_ENUJOB pej;
    LPBYTE          lpIppHdr;
    LPBYTE          lpIppPtr;
    DWORD           cbIppHdr;
    LPIPPJI2        lpji;
    DWORD           cUns;
    DWORD           idx;
    DWORD           cbSize;
    DWORD           dwRet;
    DWORD           dwState;
    DWORD           cbUns;
    WORD            wOut;
    LPIPPATTRY      pAtr = NULL;
    LPIPPATTRY      pUns = NULL;


    // Zero out our return pointer/count.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;


    // Is this a request or response.
    //
    if (wReq & IPP_RESPONSE) {

        if (((LPIPPRET_ALL)lpbData)->wRsp == IPPRSP_SUCCESS) {

            wOut = ((lpri->pwlUns && lpri->pwlUns->Count()) ? IPPRSP_SUCCESS1 : IPPRSP_SUCCESS);

        } else {

            wOut = ((LPIPPRET_ALL)lpbData)->wRsp;
        }

    } else {

        wOut = wReq;
    }


    // Minimum header size.
    //
    cbIppHdr = ipp_SizeHdr(lpri->cpReq) + IPP_SIZEOFTAG;


    // Treat the EnumJob response differently from the others, since this
    // returns a dynamic list of jobs.
    //
    if (wReq == IPP_RET_ENUJOB) {


        // Build the unsupported-attributes if there
        // are any.
        //
        cbUns = 0;
        pUns  = ipp_AllocUnsVals(lpri->pwlUns, &cUns, &cbUns);


        pej = (PIPPRET_ENUJOB)lpbData;

        cbSize = cbIppHdr +
                 cbUns    +
                 ((pej->cItems && pej->cbItems) ? (3 * pej->cbItems) : 0);

        if (lpIppHdr = (LPBYTE)webAlloc(cbSize)) {

            cbIppHdr += cbUns;
            lpIppPtr  = lpIppHdr;


            // Output the ipp-stream.
            //
            ipp_WriteHead(&lpIppPtr, wOut, lpri->idReq, lpri->cpReq);
            ipp_WriteUnsVals(&lpIppPtr, pUns, cUns);


            for (idx = 0, lpji = pej->pItems; idx < pej->cItems; idx++) {

                dwState = ipp_IppToW32JobState(lpji[idx].ji2.Status);

                // Check for any requested-attributes that include this job-entry.
                //
                if ((x_ChkReq(lpri->fReq, RA_JOBSCOMPLETED)   &&  (dwState & JOB_STATUS_PRINTED)) ||
                    (x_ChkReq(lpri->fReq, RA_JOBSUNCOMPLETED) && !(dwState & JOB_STATUS_PRINTED)) ||
                    (x_ChkReq(lpri->fReq, (RA_JOBSCOMPLETED | RA_JOBSUNCOMPLETED)) == FALSE)) {

                    if (pAtr = ipp_AllocAtrVals(wReq, lpri->fReq, lpri->cpReq, (LPBYTE)&lpji[idx], pSnd, cSnd, &cbIppHdr)) {

                        ipp_WriteAtrVals(wReq, lpri->fReq, &lpIppPtr, pSnd, pAtr, cSnd);

                        ipp_FreeAtrVals(pAtr, cSnd);
                    }
                }
            }

            ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);


            // Set the return values for the IPP-Stream-Header
            // as well as the size.
            //
            dwRet = WEBIPP_OK;

            *lplpIppHdr = lpIppHdr;
            *lpcbIppHdr = cbIppHdr;

        } else {

            dwRet = WEBIPP_NOMEMORY;
        }

        ipp_FreeAtrVals(pUns, cUns);

    } else {

        if ((cSnd == 0) ||
            (pAtr = ipp_AllocAtrVals(wReq, lpri->fReq, lpri->cpReq, lpbData, pSnd, cSnd, &cbIppHdr))) {


            // Build the unsupported-attributes if there
            // are any.
            //
            pUns = ipp_AllocUnsVals(lpri->pwlUns, &cUns, &cbIppHdr);


            // Write the IPP-Stream.
            //
            if (lpIppHdr = (LPBYTE)webAlloc(cbIppHdr)) {

                lpIppPtr = lpIppHdr;

                ipp_WriteHead(&lpIppPtr, wOut, lpri->idReq, lpri->cpReq);
                ipp_WriteUnsVals(&lpIppPtr, pUns, cUns);
                ipp_WriteAtrVals(wReq, lpri->fReq, &lpIppPtr, pSnd, pAtr, cSnd);
                ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);


                // Set the return values for the IPP-Stream-Header
                // as well as the size.
                //
                dwRet = WEBIPP_OK;

                *lplpIppHdr = lpIppHdr;
                *lpcbIppHdr = cbIppHdr;

            } else {

                dwRet = WEBIPP_NOMEMORY;
            }

            if (pUns)
            {
                ipp_FreeAtrVals(pUns, cUns);
            }

            if (pAtr)
            {
                ipp_FreeAtrVals(pAtr, cSnd);
            }


        } else {

            dwRet = WEBIPP_NOMEMORY;
        }
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToFailure (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_ALL  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToFailure(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_ALL pbr;
    WORD        wRsp;
    BOOL        bRet;
    DWORD       dwRet;


    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);
    bRet = SUCCESS_RANGE(wRsp);


    // Build the response structure.
    //
    if (pbr = WebIppCreateBadRet(wRsp, bRet)) {

        *lplpRawHdr = (LPBYTE)pbr;
        *lpcbRawHdr = pbr->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToJobRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_JOB.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToJobRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    LPBYTE       lpbTag;
    PIPPRET_JOB  pj;
    WORD         wRsp;
    IPPJI2       ji;
    DWORD        cbIdx;
    BOOL         bRet;
    DWORD        dwRet;
    BOOL         bValidate = FALSE;


    // Set our default-settings necessary for our PIPPRET_JOB.
    //
    ZeroMemory(&ji, sizeof(IPPJI2));


    // Position the tag at the Tag/Attributes.
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;


    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);


    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);


    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {

        // Look for a IPP_TAG_DEL_JOB to indicate we have a job-info
        // item.  Otherwise, skip to the next attribute.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB) {

            // Since were currently at a deliminator, we need to get to
            // the next for the start of the job.
            //
            if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr)) {

                lpbTag = ipp_GetIPPJI2(lpbTag, &ji, &cbIdx, lpObj);
            }

        } else {

            lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
        }
    }


    // Determine the correct return-code based upon the request response.
    //
    switch (lpObj->wReq) {

    case IPP_RET_PRINTJOB:
        bRet = (SUCCESS_RANGE(wRsp) ? (BOOL)ji.ji2.JobId : FALSE);
        break;

    case IPP_RET_VALIDATEJOB:
        bValidate = TRUE;

        // Fall Through.
        //

    default:
        bRet = SUCCESS_RANGE(wRsp);
        break;
    }


    // Build the response structure.
    //
    if (pj = WebIppCreateJobRet(wRsp, bRet, bValidate, &ji.ji2, &ji.ipp)) {

        *lplpRawHdr = (LPBYTE)pj;
        *lpcbRawHdr = pj->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


    // Cleanup.
    //
    ipp_FreeIPPJI2(&ji);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToPrnRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_PRN.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToPrnRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_PRN pp;
    IPPPI2      pi;
    WORD        wRsp;
    LPBYTE      lpbTag;
    LPBYTE      lpbEnd;
    DWORD       cbIdx;
    DWORD       idx;
    DWORD       dwRet;


    // Set our default-settings necessary for our PIPPRET_PRN.
    //
    ZeroMemory(&pi, sizeof(IPPPI2));


    // Position the tag at the Tag/Attributes.
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;


    // Pull out response code.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);


    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);


    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag && (ipp_ReadByte(lpbTag, 0) != IPP_TAG_DEL_DATA); ) {

        // Look for a IPP_TAG_DEL_PRINTER to indicate we have a printer-info
        // item.  Otherwise, skip to the next attribute.
        //
        if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_PRINTER) {

            // Since were currently at a deliminator, we need to get to
            // the next for the start of the job.
            //
            if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr))
                lpbTag = ipp_GetIPPPI2(lpbTag, &pi, &cbIdx, lpObj);

        } else {

            lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
        }
    }


    // If none is specified for the pertinent information, then
    // use a default-str.
    //
    if (pi.ipp.pPrnUri == NULL)
        pi.ipp.pPrnUri = webAllocStr(s_szUnknown);

    if (pi.ipp.pUsrName == NULL)
        pi.ipp.pUsrName = webAllocStr(s_szUnknown);

    if (pi.pi2.pPrinterName == NULL)
        pi.pi2.pPrinterName = webAllocStr(s_szUnknown);

    if (pi.pi2.pDriverName == NULL)
        pi.pi2.pDriverName = webAllocStr(s_szUnknown);


    // Build the response structure.
    //
    pp = WebIppCreatePrnRet(wRsp, SUCCESS_RANGE(wRsp), &pi.pi2, &pi.ipp);

    if (pp != NULL) {

        *lplpRawHdr = (LPBYTE)pp;
        *lpcbRawHdr = pp->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


    // Cleanup.
    //
    ipp_FreeIPPPI2(&pi);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToEnuRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_ENUJOB.
*
\*****************************************************************************/
DWORD ipp_IppToEnuRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_ENUJOB pgj;
    LPIPPJI2       lpjiSrc;
    LPIPPJI2       lpjiDst;
    WORD           wRsp;
    DWORD          cJobs;
    DWORD          cbJobs;
    LPBYTE         lpbTag;
    LPBYTE         lpbEnd;
    DWORD          cbIdx;
    DWORD          idx;
    DWORD          dwRet;


    // Set our default-settings necessary for our PIPPRET_ENUJOB.
    //
    cJobs   = 0;
    cbJobs  = 0;
    lpjiDst = NULL;


    // Get the response-code.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);


    // If this is a failure-response then call the routine to
    // generate a failure-structure.
    //
    if (SUCCESS_RANGE(wRsp) == FALSE)
        return ipp_IppToFailure(lpObj, lplpRawHdr, lpcbRawHdr);


    // See if we have jobs to enumerate.
    //
    if (cJobs = ipp_GetJobCount(lpObj->lpIppHdr, lpObj->cbIppHdr)) {

        if (lpjiSrc = (LPIPPJI2)webAlloc(cJobs * sizeof(IPPJI2))) {

            // Get the job-info.
            //
            lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;

            for (idx = 0, cbIdx = IPP_SIZEOFHDR; lpbTag && (idx < cJobs); ) {

                // Look for a IPP_TAG_DEL_JOB to indicate we have a job-info
                // item.  Otherwise, skipp to the next attribute.
                //
                if (ipp_ReadByte(lpbTag, 0) == IPP_TAG_DEL_JOB) {

                    // Since were currently at a deliminator, we need to get to
                    // the next for the start of the job.
                    //
                    if (lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr))
                        lpbTag = ipp_GetIPPJI2(lpbTag, &lpjiSrc[idx++], &cbIdx, lpObj);

                } else {

                    lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
                }
            }


            // Get storage necessary for packed IPPJI2 structures.
            //
            cbJobs = (cJobs * sizeof(IPPJI2));

            for (idx = 0; idx < cJobs; idx++)
                cbJobs += ipp_SizeofIPPJI2(&lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp);


            // Allocate an array of JI2 structs to contain our
            // enumeration.
            //
            if (lpjiDst = (LPIPPJI2)webAlloc(cbJobs)) {

                // For each job-item, initialize.
                //
                lpbEnd = ((LPBYTE)lpjiDst) + cbJobs;

                for (idx = 0; idx < cJobs; idx++)
                    lpbEnd = ipp_BuildJI2(&lpjiDst[idx], &lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp, lpbEnd);
            }


            // Free the memory allocated for the job-item.
            //
            for (idx = 0; idx < cJobs; idx++)
                ipp_FreeIPPJI2(&lpjiSrc[idx]);

            webFree(lpjiSrc);
        }
    }


    // Build the response structure.
    //
    pgj = WebIppCreateEnuJobRet(wRsp, SUCCESS_RANGE(wRsp), cbJobs, cJobs, lpjiDst);

    if (pgj != NULL) {

        *lplpRawHdr = (LPBYTE)pgj;
        *lpcbRawHdr = pgj->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


    // Cleanup.
    //
    webFree(lpjiDst);

    return dwRet;
}


/*****************************************************************************\
* ipp_IppToAthRet (Local Routine - Client)
*
* Converts an Ipp-Header to a IPPRET_AUTH.  From the stream we need
* to pull out the following information:
*
\*****************************************************************************/
DWORD ipp_IppToAthRet(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    PIPPRET_AUTH pfa;
    WORD         wRsp;
    BOOL         bRet;
    DWORD        dwRet;


    // Pull out the response.
    //
    wRsp = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);
    bRet = SUCCESS_RANGE(wRsp);


    // Build the response structure.
    //
    if (pfa = WebIppCreateAuthRet(wRsp, bRet)) {

        *lplpRawHdr = (LPBYTE)pfa;
        *lpcbRawHdr = pfa->cbSize;

        dwRet = WEBIPP_OK;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_FailureToIpp (Local Routine - Server)
*
* Converts a IPPRET_ALL to an IPP Header.  This is used for responding to
* clients that an operation is not supported, or returning a failure.
*
\*****************************************************************************/
DWORD ipp_FailureToIpp(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpbData,
    LPBYTE*   lplpIppHdr,
    LPDWORD   lpcbIppHdr)
{
    LPBYTE      lpIppHdr;
    LPBYTE      lpIppPtr;
    DWORD       cbIppHdr;
    DWORD       dwRet;
    DWORD       cbNamSta;
    DWORD       cbValSta;
    LPSTR       lputfNamSta;
    LPSTR       lputfValSta;
    PIPPRET_ALL pbr = (PIPPRET_ALL)lpbData;


    // Zero out our return pointer/count.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;


    ipp_GetRspSta(pbr->wRsp, lpri->cpReq, &lputfNamSta, &cbNamSta, &lputfValSta, &cbValSta);


    // Calculate the space necessary to generate our
    // IPP-Header-Stream.
    //
    cbIppHdr = ipp_SizeHdr(lpri->cpReq)                                                  +
               (lputfNamSta && lputfValSta ? ipp_SizeAttr(cbNamSta, cbValSta) : 0) +
               IPP_SIZEOFTAG;


    // Allocate the header for the IPP-Stream.
    //
    if (lpIppHdr = (LPBYTE)webAlloc(cbIppHdr)) {

        // Initialize the pointer which will keep track
        // of where we are in writing the IPP-Stream-Header.
        //
        lpIppPtr = lpIppHdr;


        // Write out the IPP-Header-Stream.
        //
        ipp_WriteHead(&lpIppPtr, pbr->wRsp, lpri->idReq, lpri->cpReq);

        if (lputfNamSta && lputfValSta)
            ipp_WriteAttr(&lpIppPtr, IPP_TAG_CHR_TEXT, cbNamSta, lputfNamSta, cbValSta, lputfValSta);

        ipp_WriteByte(&lpIppPtr, IPP_TAG_DEL_DATA);


        // Set the return values for the IPP-Stream-Header
        // as well as the size.
        //
        dwRet = WEBIPP_OK;

        *lplpIppHdr = lpIppHdr;
        *lpcbIppHdr = cbIppHdr;

    } else {

        dwRet = WEBIPP_NOMEMORY;
    }


    // Cleanup
    //
    webFree(lputfNamSta);
    webFree(lputfValSta);

    return dwRet;
}


/*****************************************************************************\
* Ipp Send/Receive Table
*
*
*
\*****************************************************************************/
static IPPSNDRCV s_pfnIpp[] = {

    // Operation         Req Form Rsp Form Req X  Req X Size     Rsp X  Rsp X Size     Rsp (cli)
    // ----------------- -------- -------- ------ -------------- ------ -------------- ----------------
    //
    IPP_REQ_PRINTJOB   , s_FormA, s_FormC, s_PJQ, sizeof(s_PJQ), s_PJR, sizeof(s_PJR), ipp_IppToJobRet,
    IPP_REQ_VALIDATEJOB, s_FormA, s_FormE, s_PJQ, sizeof(s_PJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_CANCELJOB  , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_GETJOB     , s_FormB, s_FormC, s_GJQ, sizeof(s_GJQ), s_PJR, sizeof(s_PJR), ipp_IppToJobRet,
    IPP_REQ_ENUJOB     , s_FormB, s_FormF, s_EJQ, sizeof(s_EJQ), s_EJR, sizeof(s_EJR), ipp_IppToEnuRet,
    IPP_REQ_GETPRN     , s_FormB, s_FormD, s_GPQ, sizeof(s_GPQ), s_GPR, sizeof(s_GPR), ipp_IppToPrnRet,
    IPP_REQ_PAUSEJOB   , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_RESUMEJOB  , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_RESTARTJOB , s_FormB, s_FormE, s_SJQ, sizeof(s_SJQ), NULL , 0            , ipp_IppToJobRet,
    IPP_REQ_PAUSEPRN   , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_RESUMEPRN  , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_CANCELPRN  , s_FormB, s_FormE, s_SPQ, sizeof(s_SPQ), NULL , 0            , ipp_IppToPrnRet,
    IPP_REQ_FORCEAUTH  , s_FormB, s_FormB, NULL , 0            , NULL , 0            , ipp_IppToAthRet
};


/*****************************************************************************\
* ipp_ValidateRcvReq (Local Routine)
*
* Returns whether the header is a supported request.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvReq(
    LPIPPOBJ lpObj)
{
    DWORD idx;
    DWORD cCnt;
    DWORD dwId = ipp_ReadDWord(lpObj->lpIppHdr, IPP_SIZEOFINT);
    WORD  wVer = ipp_ReadWord(lpObj->lpIppHdr, 0);
    WORD  wReq = ipp_ReadWord(lpObj->lpIppHdr, IPP_SIZEOFVER);


    // First check that we are the correct-version, then proceed
    // to validate the request.
    //
    if (wVer == IPP_VERSION) {

        if (REQID_RANGE(dwId)) {

            // See if we're in the range of response codes.
            //
            if (SUCCESS_RANGE(wReq) || ERROR_RANGE(wReq))
                return WEBIPP_OK;


            // Validate supported operations.
            //
            cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

            for (idx = 0; idx < cCnt; idx++) {

                if (wReq == s_pfnIpp[idx].wReq)
                    return WEBIPP_OK;
            }

            lpObj->wError = IPPRSP_ERROR_400;

        } else {

            lpObj->wError = IPPRSP_ERROR_400;
        }

    } else {

        lpObj->wError = IPPRSP_ERROR_503;
    }

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* ipp_ValForm (Local Routine)
*
* Checks the tag-order for delimiters.
*
\*****************************************************************************/
BOOL ipp_ValForm(
    BYTE  bTag,
    PBYTE pbVal)
{
    DWORD idx;


    // Look to see if the tag is one of our supported groups for
    // this request.
    //
    for (idx = 0; pbVal[idx] != (BYTE)0; idx++) {

        // Is this a tag we're interested in.
        //
        if ((pbVal[idx] & 0x0F) == bTag) {

            // If we're already encountered this tag, then we
            // have an error (duplication of groups).
            //
            if ((pbVal[idx] & IPP_HIT) && !(pbVal[idx] & IPP_MULTIPLE))
                return FALSE;


            // Otherwise, mark this group as hit.
            //
            pbVal[idx] |= IPP_HIT;

            return TRUE;

        } else {

            // If this is not our tag, then we need to check
            // that this has at least been hit, or is an
            // optional group (verifies order).
            //
            if (IS_RANGE_DELIMITER(bTag))
                if (!(pbVal[idx] & (IPP_HIT | IPP_OPTIONAL)))
                    return FALSE;
        }
    }

    return TRUE;
}


/*****************************************************************************\
* ipp_AllocVal (Local Routine)
*
* Allocates a byte-array of tags that specify order.
*
\*****************************************************************************/
PBYTE ipp_AllocVal(
    WORD wReq)
{
    DWORD cCnt;
    DWORD idx;
    PBYTE pbGrp;
    PBYTE pbVal = NULL;


    // Build the byte-array for validation of form.
    //
    cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

    for (idx = 0, pbGrp = NULL; idx < cCnt; idx++) {

        if (wReq == s_pfnIpp[idx].wReq) {

            pbGrp = s_pfnIpp[idx].pbReqForm;
            break;

        } else if (wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq)) {

            pbGrp = s_pfnIpp[idx].pbRspForm;
            break;
        }
    }


    if (pbGrp) {

        for (idx = 0; pbGrp[idx++] != (BYTE)0; );

        if (idx && (pbVal = (PBYTE)webAlloc(idx)))
            CopyMemory(pbVal, pbGrp, idx);
    }

    return pbVal;
}


/*****************************************************************************\
* ipp_ValidateRcvForm (Local Routine)
*
* Returns whether the header is well-formed.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvForm(
    LPIPPOBJ lpObj,
    LPDWORD  lpcbSize)
{
    LPBYTE lpbTag;
    BYTE   bTag;
    DWORD  cbIdx;
    PBYTE  pbVal;
    DWORD  dwRet = WEBIPP_MOREDATA;


    // Zero out the return buffer.
    //
    *lpcbSize = 0;


    // Allocate our array of tags that represent order.
    //
    if (pbVal = ipp_AllocVal(lpObj->wReq)) {

        // Advance our pointer to the start of our attributes
        // in the byte-stream (i.e. skip version/request).
        //
        lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;


        // Hack!  Check to be sure that our headers always start
        // off with an operations-attribute-tag.
        //
        if (IS_TAG_DELIMITER(ipp_ReadByte(lpbTag, 0))) {

            // Traverse through the header, advancing through the attributes,
            // until the IPP_TAG_DEL_DATA is encountered.  This will verify
            // that we have a well-formed header.
            //
            for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {

                // Get the tag.
                //
                bTag = ipp_ReadByte(lpbTag, 0);


                // Only check our delimiter tags for this
                // validation.
                //
                if (IS_TAG_DELIMITER(bTag)) {

                    if (bTag == IPP_TAG_DEL_DATA) {

                        if (ipp_ValForm(bTag, pbVal)) {

                            *lpcbSize = (cbIdx + 1);

                            dwRet = WEBIPP_OK;

                            goto EndVal;

                        } else {

                            goto BadFrm;
                        }

                    } else {

                        if (ipp_ValForm(bTag, pbVal) == FALSE)
                            goto BadFrm;
                    }
                }


                // Advance to next Tag.  This routine also increments
                // the (cbIdx) count.  If we run out of bytes in the
                // header before we can get to the next-tag, then this
                // will return NULL.
                //
                lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
            }

        } else {

BadFrm:
            lpObj->wError = IPPRSP_ERROR_400;

            dwRet = WEBIPP_FAIL;
        }

EndVal:
        webFree(pbVal);

    } else {

        lpObj->wError = IPPRSP_ERROR_505;

        dwRet = WEBIPP_NOMEMORY;
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvCharSet (Local Routine)
*
* Returns whether we support the character-set.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvCharSet(
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    LPBYTE    lpbTag;
    BYTE      bTag;
    DWORD     cbIdx;
    DWORD     dwRet = WEBIPP_FAIL;


    // Advance our pointer to the start of our attributes
    // in the byte-stream (i.e. skip version/request).
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;


    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.  This will verify
    // that we have a well-formed header.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {

        bTag = ipp_ReadByte(lpbTag, 0);


        // If we walked through the end of our stream, then
        // the stream does not contain character-set information.
        //
        if (IS_TAG_DELIMITER(bTag) && (bTag != IPP_TAG_DEL_OPERATION))
            break;


        // If we are pointing at an attribute, then retrieve
        // it in a format we understand.
        //
        if (lpAttr = ipp_GetAttr(lpbTag, cbIdx, lpObj)) {

            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName) {

                if (lstrcmpi(lpAttr->lpszName, s_szCharSet) == 0) {

                    if (lpObj->fState & IPPFLG_CHARSET) {

                        lpObj->wError = IPPRSP_ERROR_400;
                        dwRet         = WEBIPP_FAIL;

                    } else {

                        lpObj->fState |= IPPFLG_CHARSET;

                        if (lpAttr->cbValue > SIZE_CHARSET) {

                            lpObj->wError = IPPRSP_ERROR_409;

                        } else {

                            if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szUtf8) == 0) {

                                lpObj->uCPRcv = CP_UTF8;

                                dwRet = WEBIPP_OK;

                            } else if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szUsAscii) == 0) {

                                lpObj->uCPRcv = CP_ACP;

                                dwRet = WEBIPP_OK;

                            } else {

                                lpObj->wError = IPPRSP_ERROR_40D;
                            }
                        }
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;


        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
    }

    if ((dwRet != WEBIPP_OK) && (lpObj->wError == IPPRSP_SUCCESS))
        lpObj->wError = IPPRSP_ERROR_400;

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvLang (Local Routine)
*
* Returns whether we support the natural-language.
*
\*****************************************************************************/
DWORD ipp_ValidateRcvLang(
    LPIPPOBJ lpObj)
{
    LPIPPATTR lpAttr;
    LPBYTE    lpbTag;
    BYTE      bTag;
    DWORD     cbIdx;
    DWORD     dwRet = WEBIPP_FAIL;


    // Advance our pointer to the start of our attributes
    // in the byte-stream (i.e. skip version/request).
    //
    lpbTag = lpObj->lpIppHdr + IPP_SIZEOFHDR;


    // Traverse through the header, advancing through the attributes,
    // until the IPP_TAG_DEL_DATA is encountered.  This will verify
    // that we have a well-formed header.
    //
    for (cbIdx = IPP_SIZEOFHDR; lpbTag; ) {

        bTag = ipp_ReadByte(lpbTag, 0);

        // If we walked through the end of our stream, then
        // the stream does not contain natural-language information.
        //
        if (IS_TAG_DELIMITER(bTag) && (bTag != IPP_TAG_DEL_OPERATION))
            break;


        // If we are pointing at an attribute, then retrieve
        // it in a format we understand.
        //
        if (lpAttr = ipp_GetAttr(lpbTag, cbIdx, lpObj)) {

            // Check the name-type to see how to handle the value.
            //
            if (lpAttr->lpszName) {

                if (lstrcmpi(lpAttr->lpszName, s_szNaturalLanguage) == 0) {

                    if (lpObj->fState & IPPFLG_NATLANG) {

                        lpObj->wError = IPPRSP_ERROR_400;
                        dwRet         = WEBIPP_FAIL;

                    } else {

                        lpObj->fState |= IPPFLG_NATLANG;

                        if (lpAttr->cbValue > SIZE_NATLANG) {

                            lpObj->wError = IPPRSP_ERROR_409;

                        } else {

                            if (lstrcmpi((LPTSTR)lpAttr->lpValue, s_szEnUS) == 0) {

                                dwRet = WEBIPP_OK;

                            } else {

                                dwRet = WEBIPP_OK;
                            }
                        }
                    }
                }
            }

            ipp_RelAttr(lpAttr);
        }


        if (ERROR_RANGE(lpObj->wError))
            break;


        // Advance to next Tag.  This routine also increments
        // the (cbIdx) count.  If we run out of bytes in the
        // header before we can get to the next-tag, then this
        // will return NULL.
        //
        lpbTag = ipp_NextTag(lpObj->lpIppHdr, &cbIdx, lpObj->cbIppHdr);
    }

    if ((dwRet != WEBIPP_OK) && (lpObj->wError == IPPRSP_SUCCESS))
        lpObj->wError = IPPRSP_ERROR_400;

    return dwRet;
}


/*****************************************************************************\
* ipp_ValidateRcvHdr (Local Routine)
*
* Parses through the (lpbHdr) and returns whether it's a full (complete)
* header.  Essentially, this need only look through the byte-stream until
* it finds the IPP_TAG_DEL_DATA attribute.
*
* Returns the size of the header (in bytes).
*
\*****************************************************************************/
DWORD ipp_ValidateRcvHdr(
    LPIPPOBJ lpObj,
    LPDWORD  lpcbSize)
{
    LPBYTE lpbTag;
    DWORD  cbIdx;
    DWORD  cbSize;
    DWORD  dwRet;


    // Initialize our return-size so that we are reporting
    // clean data.
    //
    *lpcbSize = 0;


    // Make sure we have enough in our header to handle
    // the basic verification.
    //
    if (lpObj->cbIppHdr <= (IPP_SIZEOFHDR + IPP_SIZEOFTAG))
        return WEBIPP_MOREDATA;


    // Set the request-type for the header.  This will help
    // us determine the appropriate conversion to the data-
    // structure.
    //
    lpObj->idReq = ipp_ReadDWord(lpObj->lpIppHdr, IPP_SIZEOFINT);


    // Validate the fixed header values, then proceed with
    // other validation of the operational-attributes.
    //
    if ((dwRet = ipp_ValidateRcvReq(lpObj)) == WEBIPP_OK) {

        if ((dwRet = ipp_ValidateRcvForm(lpObj, &cbSize)) == WEBIPP_OK) {

            if ((dwRet = ipp_ValidateRcvCharSet(lpObj)) == WEBIPP_OK) {

                if ((dwRet = ipp_ValidateRcvLang(lpObj)) == WEBIPP_OK) {

                    *lpcbSize = cbSize;
                }
            }
        }
    }

    return dwRet;
}


/*****************************************************************************\
* ipp_ConvertIppToW32 (Local Routine)
*
* This routine takes in an IPP stream-buffer and generates the appropriate
* structure in which NT-Spooler-API's can process.
*
* Returns the pointer to the converted-header as well as the bytes that
* this converted header occupies.
*
\*****************************************************************************/
DWORD ipp_ConvertIppToW32(
    LPIPPOBJ lpObj,
    LPBYTE*  lplpRawHdr,
    LPDWORD  lpcbRawHdr)
{
    DWORD cCnt;
    DWORD idx;


    // Perform the request.  If the request has NULL function-pointers, then
    // the request/response is not supported.
    //
    cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

    for (idx = 0; idx < cCnt; idx++) {

        // Check for request
        //
        if (lpObj->wReq == s_pfnIpp[idx].wReq)
            return ipp_IppToW32(lpObj, lplpRawHdr, lpcbRawHdr);


        // Check for response
        //
        if (lpObj->wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq))
            return s_pfnIpp[idx].pfnRcvRet(lpObj, lplpRawHdr, lpcbRawHdr);

    }

    lpObj->wError = IPPRSP_ERROR_501;

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* WebIppSndData
*
* This routine takes the (lpRawHdr) and packages it up in IPP 1.1 protocol
* and returns the pointer to the Ipp-Header.
*
* Parameters:
* ----------
* dwReq      - Describes the type of IPP-Header to package.
* lpRawHdr   - Input pointer to raw (spooler) data-structure.
* cbRawHdr   - Input byte-count of (lpRawHdr).
* lplpIppHdr - Output pointer to IPP-Header stream.
* lpcbIppHdr - Output to byte-count of Ipp-Header stream (lplpIppHdr).
*
\*****************************************************************************/
DWORD WebIppSndData(
    WORD      wReq,
    LPREQINFO lpri,
    LPBYTE    lpRawHdr,
    DWORD     cbRawHdr,
    LPBYTE*   lplpIppHdr,
    LPDWORD   lpcbIppHdr)
{
    DWORD      cCnt;
    DWORD      idx;
    LPIPPATTRX pSnd;
    DWORD      cSnd;


    // Zero out the return pointers/sizes.
    //
    *lplpIppHdr = NULL;
    *lpcbIppHdr = 0;


    // Make sure the code-pages are something we can support.
    //
    if ((lpri->cpReq == CP_ACP) || (lpri->cpReq == CP_UTF8)) {

        // Perform the request.  If the request has NULL function-pointers,
        // then the request/response is not supported.
        //
        cCnt = sizeof(s_pfnIpp) / sizeof(s_pfnIpp[0]);

        for (idx = 0; idx < cCnt; idx++) {

            // Check for request.
            //
            if (wReq == s_pfnIpp[idx].wReq) {

                pSnd = s_pfnIpp[idx].paReq;
                cSnd = s_pfnIpp[idx].cbReq / sizeof(IPPATTRX);

                return ipp_W32ToIpp(wReq, lpri, lpRawHdr, pSnd, cSnd, lplpIppHdr, lpcbIppHdr);
            }


            // Check for response.
            //
            if (wReq == (IPP_RESPONSE | s_pfnIpp[idx].wReq)) {

                // Check response for any fail-cases.
                //
                if (SUCCESS_RANGE(((LPIPPRET_ALL)lpRawHdr)->wRsp)) {

                    pSnd = s_pfnIpp[idx].paRsp;
                    cSnd = s_pfnIpp[idx].cbRsp / sizeof(IPPATTRX);

                    return ipp_W32ToIpp(wReq, lpri, lpRawHdr, pSnd, cSnd, lplpIppHdr, lpcbIppHdr);
                }

                break;
            }
        }


        // If this was sent by our server, then we want to reply to the client
        // with an ipp-stream.
        //
        return ipp_FailureToIpp(wReq, lpri, lpRawHdr, lplpIppHdr, lpcbIppHdr);
    }

    return WEBIPP_FAIL;
}


/*****************************************************************************\
* WebIppRcvOpen
*
* This routine creates an IPP-state-object which parses IPP stream-data.  The
* parameter (dwReq) specifies which request we expect the stream to provide.
*
* We allocate a default-size buffer to contain the header.  If more memory
* is necessary, then it is reallocated to append the data.
*
\*****************************************************************************/
HANDLE WebIppRcvOpen(
    WORD wReq)
{
    LPIPPOBJ lpObj;


    if (lpObj = (LPIPPOBJ)webAlloc(sizeof(IPPOBJ))) {

        if (lpObj->pwlUns = (PWEBLST)new CWebLst()) {

            lpObj->wReq     = wReq;
            lpObj->wError   = IPPRSP_SUCCESS;
            lpObj->idReq    = 0;
            lpObj->uCPRcv   = CP_UTF8;
            lpObj->fState   = 0;
            lpObj->cbIppHdr = 0;
            lpObj->cbIppMax = IPP_BLOCK_SIZE;
            lpObj->lpRawDta = NULL;

            x_SetReq(lpObj->fReq, (wReq == IPP_REQ_ENUJOB ? IPP_REQENU : IPP_REQALL));


            // Allocate a default buffer-size to hold the IPP
            // header.  This may not be large enough to hold
            // the complete header so we reserve the right to
            // reallocate it until it contains the entire header.
            //
            if (lpObj->lpIppHdr = (LPBYTE)webAlloc(lpObj->cbIppMax)) {

                return (HANDLE)lpObj;
            }

            delete lpObj->pwlUns;
        }

        webFree(lpObj);
    }

    return NULL;
}


/*****************************************************************************\
* WebIppRcvData
*
* This routine takes in IPP stream-data and builds a complete IPP-Header.  It
* is possible that the header-information is not provided in one chunk of
* stream-data.  Therefore, we will not return the converted header information
* until our header is complete.
*
* Once the header is complete, it's returned in the output-buffer in the
* format that the caller can utilized in spooler-related calls.
*
* Not only does this handle the header, but it is also used to process raw
* stream-data which is returned unmodified to the caller.  In the case that
* we encounter data during the processing of the IPP-Header, we need to
* return an allocated buffer pointing to DWORD-Aligned bits.
*
* Parameters:
* ----------
* hObj       - Handle to the Ipp-Parse-Object.
* lpIppDta   - Input pointer to ipp-stream-data.  This is header and/or data.
* cbIppDta   - Input byte-count contained in the (lpIppData).
* lplpRawHdr - Output pointer to spooler-define (raw) structure.
* lpcbRawHdr - Output pointer to byte-count in (lplpRawHdr).
* lplpRawDta - Output pointer to data-stream.
* lpcbRawDta - Output pointer to byte-count in (lplpRawDta).
*
* Returns:
* -------
* WEBIPP_OK           - Information in lplpHdr or lplpData is valid.
* WEBIPP_FAIL         - Failed in validation.  Use WebIppGetError.
* WEBIPP_MOREDATA     - Needs more data to complete header.
* WEBIPP_BADHANDLE    - Ipp-Object-Handle is invalid.
* WEBIPP_NOMEMORY     - Failed allocation request (out-of-memory).
*
\*****************************************************************************/
DWORD WebIppRcvData(
    HANDLE  hObj,
    LPBYTE  lpIppDta,
    DWORD   cbIppDta,
    LPBYTE* lplpRawHdr,
    LPDWORD lpcbRawHdr,
    LPBYTE* lplpRawDta,
    LPDWORD lpcbRawDta)
{
    LPIPPOBJ lpObj;
    LPBYTE   lpNew;
    DWORD    cbSize;
    DWORD    cbData;
    DWORD    cBlks;
    DWORD    dwRet;


    // Initialize the output pointers to NULL.  We return two distinct
    // references since it is possible that the buffer passed in contains
    // both header and data.
    //
    *lplpRawHdr = NULL;
    *lpcbRawHdr = 0;
    *lplpRawDta = NULL;
    *lpcbRawDta = 0;


    // Process the stream-data.
    //
    if (lpObj = (LPIPPOBJ)hObj) {

        // If our header is complete, then the stream is raw-data meant
        // to be return directly.  In this case we only need to return the
        // data-stream passed in.
        //
        // Otherwise, the default-case is that we are building our header
        // from the stream-data.
        //
        if (lpObj->fState & IPPFLG_VALID) {

            // Free up the memory occupied by our header (only done on
            // the first hit of this block).  Since we aren't using
            // this anymore during the processing of the stream, we
            // shouldn't occupy any more memory than necessary.
            //
            if (lpObj->lpIppHdr) {

                webFree(lpObj->lpIppHdr);
                lpObj->lpIppHdr = NULL;
                lpObj->cbIppHdr = 0;


                // Likewise, if we had need of a temporary data-buffer
                // to hold aligned-bits, then we need to free this up
                // as well.
                //
                webFree(lpObj->lpRawDta);
                lpObj->lpRawDta = NULL;
            }


            // Return the data-stream passed in.
            //
            dwRet       = WEBIPP_OK;
            *lplpRawDta = lpIppDta;
            *lpcbRawDta = cbIppDta;

        } else {

            // Check to see if our buffer can accomodate the
            // size of the buffer being passed in.  If not, realloc
            // a new buffer to accomodate the new chunk.
            //
            if ((lpObj->cbIppHdr + cbIppDta) >= lpObj->cbIppMax) {

                // Determine the number of memory-blocks that we
                // need to hold the (cbData) coming in.
                //
                cBlks = (cbIppDta / IPP_BLOCK_SIZE) + 1;

                cbSize = lpObj->cbIppMax + (IPP_BLOCK_SIZE * cBlks);

                lpNew = (LPBYTE)webRealloc(lpObj->lpIppHdr,
                                           lpObj->cbIppMax,
                                           cbSize);

                if (lpNew != NULL) {

                    lpObj->lpIppHdr = lpNew;
                    lpObj->cbIppMax = cbSize;

                } else {

                    return WEBIPP_NOMEMORY;
                }
            }


            // Copy/Append the stream-data to our header-buffer.
            //
            memcpy(lpObj->lpIppHdr + lpObj->cbIppHdr, lpIppDta, cbIppDta);
            lpObj->cbIppHdr += cbIppDta;


            // Validate the header.  If this is successful, then we have
            // a well-formed-header.  Otherwise, we need to request
            // more data from the caller.  This returns the actual size
            // of the header in (cbSize).
            //
            if ((dwRet = ipp_ValidateRcvHdr(lpObj, &cbSize)) == WEBIPP_OK) {

                // Convert the IPP-Heade to a structure (stream)
                // that the caller understands (depends on dwReq).
                //
                dwRet = ipp_ConvertIppToW32(lpObj, lplpRawHdr, lpcbRawHdr);

                if (dwRet == WEBIPP_OK) {

                    // The validation returns the actual-size occupied by
                    // the header.  Therefore, if our (cbHdr) is larger, then
                    // the remaining information is pointing at data.
                    //
                    if (cbSize < lpObj->cbIppHdr) {

                        cbData = (lpObj->cbIppHdr - cbSize);

                        lpObj->lpRawDta = ipp_CopyAligned(lpObj->lpIppHdr + cbSize, cbData);

                        *lplpRawDta = lpObj->lpRawDta;
                        *lpcbRawDta = cbData;
                    }


                    // Set the flag indicating we have a full-header.  This
                    // assures that subsequent calls to this routine returns
                    // only the lpData.
                    //
                    lpObj->fState |= IPPFLG_VALID;
                }
            }
        }

    } else {

        dwRet = WEBIPP_BADHANDLE;
    }

    return dwRet;
}


/*****************************************************************************\
* WebIppRcvClose
*
* This routine Frees up our IPP object.  This is called once the caller wishes
* to end the parsing/handling of ipp-stream-data.
*
\*****************************************************************************/
BOOL WebIppRcvClose(
    HANDLE hObj)
{
    LPIPPOBJ lpObj;


    if (lpObj = (LPIPPOBJ)hObj) {

        webFree(lpObj->lpIppHdr);
        webFree(lpObj->lpRawDta);

        delete lpObj->pwlUns;

        webFree(lpObj);

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* WebIppGetError
*
* This routine returns the specific error in the ipp-object.  This is called
* on a failure during the receive.
*
\*****************************************************************************/
WORD WebIppGetError(
    HANDLE hIpp)
{
    LPIPPOBJ lpObj;

    if (lpObj = (LPIPPOBJ)hIpp)
        return lpObj->wError;

    return IPPRSP_ERROR_500;
}


/*****************************************************************************\
* WebIppGetReqInfo
*
* This routine returns the request-info.
*
\*****************************************************************************/
BOOL WebIppGetReqInfo(
    HANDLE    hIpp,
    LPREQINFO lpri)
{
    LPIPPOBJ lpObj;


    if ((lpObj = (LPIPPOBJ)hIpp) && lpri) {

        lpri->idReq     = lpObj->idReq;
        lpri->cpReq     = lpObj->uCPRcv;
        lpri->pwlUns    = lpObj->pwlUns;
        lpri->bFidelity = (lpObj->fState & IPPFLG_USEFIDELITY);

        CopyMemory(lpri->fReq, lpObj->fReq, IPPOBJ_MASK_SIZE * sizeof(DWORD));

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* WebIppLeToRsp
*
* This routine returns an IPP-Response-Code from a Win32-LastError.
*
\*****************************************************************************/
WORD WebIppLeToRsp(
    DWORD dwLastError)
{
    DWORD idx;
    DWORD cErrors;

    if (dwLastError == ERROR_SUCCESS)
        return IPPRSP_SUCCESS;


    // Lookup lasterror.
    //
    cErrors = sizeof(s_LEDef) / sizeof(s_LEDef[0]);

    for (idx = 0; idx < cErrors; idx++) {

        if (dwLastError == s_LEDef[idx].dwLE)
            return s_LEDef[idx].wRsp;
    }

    return IPPRSP_ERROR_500;
}


/*****************************************************************************\
* WebIppRspToLe
*
* This routine returns a Win32 LastError from an IPP-Response-Code.
*
\*****************************************************************************/
DWORD WebIppRspToLe(
    WORD wRsp)
{
    DWORD idx;
    DWORD cErrors;

    if (SUCCESS_RANGE(wRsp))
        return ERROR_SUCCESS;


    // Lookup lasterror.
    //
    cErrors = sizeof(s_LEIpp) / sizeof(s_LEIpp[0]);

    for (idx = 0; idx < cErrors; idx++) {

        if (wRsp == s_LEIpp[idx].wRsp)
            return s_LEIpp[idx].dwLE;
    }

    return ERROR_INVALID_DATA;
}


/*****************************************************************************\
* WebIppCreatePrtJobReq
*
* Creates a IPPREQ_PRTJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_PRTJOB WebIppCreatePrtJobReq(
    BOOL    bValidate,
    LPCTSTR lpszUser,
    LPCTSTR lpszDoc,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_PRTJOB ppj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_PRTJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_PRTJOB, pDocument),
        offs(LPIPPREQ_PRTJOB, pUserName),
        offs(LPIPPREQ_PRTJOB, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_PRTJOB information.
    //
    cbSize = sizeof(IPPREQ_PRTJOB)    +
             webStrSize(lpszUser)     +
             webStrSize(lpszDoc)      +
             webStrSize(lpszPrnUri);


    // Allocate the print-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (ppj = (PIPPREQ_PRTJOB)webAlloc(cbSize)) {

        ppj->cbSize    = cbSize;
        ppj->bValidate = bValidate;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszDoc;
        *lpszSrc++ = (LPTSTR)lpszUser;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)ppj, s_Offs, ((LPBYTE)ppj) + cbSize);
    }

    return ppj;
}


/*****************************************************************************\
* WebIppCreateGetJobReq
*
* Creates a IPPREQ_GETJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_GETJOB WebIppCreateGetJobReq(
    DWORD   idJob,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_GETJOB pgj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_GETJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_GETJOB, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_GETJOB information.
    //
    cbSize = sizeof(IPPREQ_GETJOB) + webStrSize(lpszPrnUri);


    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgj = (PIPPREQ_GETJOB)webAlloc(cbSize)) {

        pgj->cbSize = cbSize;
        pgj->idJob  = idJob;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgj, s_Offs, ((LPBYTE)pgj) + cbSize);
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateSetJobReq
*
* Creates a IPPREQ_SETJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_SETJOB WebIppCreateSetJobReq(
    DWORD   idJob,
    DWORD   dwCmd,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_SETJOB psj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_SETJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_SETJOB, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_SETJOB information.
    //
    cbSize = sizeof(IPPREQ_SETJOB) + webStrSize(lpszPrnUri);


    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (psj = (PIPPREQ_SETJOB)webAlloc(cbSize)) {

        psj->cbSize = cbSize;
        psj->idJob  = idJob;
        psj->dwCmd  = dwCmd;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)psj, s_Offs, ((LPBYTE)psj) + cbSize);
    }

    return psj;
}


/*****************************************************************************\
* WebIppCreateEnuJobReq
*
* Creates a IPPREQ_ENUJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_ENUJOB WebIppCreateEnuJobReq(
    DWORD   cJobs,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_ENUJOB pgj;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_ENUJOB) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_ENUJOB, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_ENUJOB information.
    //
    cbSize = sizeof(IPPREQ_ENUJOB) + webStrSize(lpszPrnUri);


    // Allocate the cancel-job-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgj = (PIPPREQ_ENUJOB)webAlloc(cbSize)) {

        pgj->cbSize = cbSize;
        pgj->cJobs  = cJobs;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgj, s_Offs, ((LPBYTE)pgj) + cbSize);
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateSetPrnReq
*
* Creates a IPPREQ_SETPRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_SETPRN WebIppCreateSetPrnReq(
    DWORD   dwCmd,
    LPCTSTR lpszUsrName,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_SETPRN psp;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_SETPRN) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_SETPRN, pUserName),
        offs(LPIPPREQ_SETPRN, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_SETPRN information.
    //
    cbSize = sizeof(IPPREQ_SETPRN)    +
             webStrSize(lpszUsrName)  +
             webStrSize(lpszPrnUri);


    // Allocate the set-prn-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (psp = (PIPPREQ_SETPRN)webAlloc(cbSize)) {

        psp->cbSize = cbSize;
        psp->dwCmd  = dwCmd;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszUsrName;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)psp, s_Offs, ((LPBYTE)psp) + cbSize);
    }

    return psp;
}


/*****************************************************************************\
* WebIppCreateGetPrnReq
*
* Creates a IPPREQ_GETPRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_GETPRN WebIppCreateGetPrnReq(
    DWORD   dwAttr,
    LPCTSTR lpszPrnUri)
{
    PIPPREQ_GETPRN pgp;
    DWORD          cbSize;
    LPTSTR*        lpszSrc;
    LPTSTR         aszSrc[(sizeof(IPPREQ_GETPRN) / sizeof(LPTSTR))];

    static DWORD s_Offs[] = {

        offs(LPIPPREQ_GETPRN, pPrnUri),
        0xFFFFFFFF
    };


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_GETPRN information.
    //
    cbSize = sizeof(IPPREQ_GETPRN) + webStrSize(lpszPrnUri);


    // Allocate the get-prt-attribute-request structure.  The string
    // values are appended at the end of the structure.
    //
    if (pgp = (PIPPREQ_GETPRN)webAlloc(cbSize)) {

        pgp->cbSize = cbSize;
        pgp->dwAttr = dwAttr;

        lpszSrc    = aszSrc;
        *lpszSrc++ = (LPTSTR)lpszPrnUri;

        ipp_PackStrings(aszSrc, (LPBYTE)pgp, s_Offs, ((LPBYTE)pgp) + cbSize);
    }

    return pgp;
}


/*****************************************************************************\
* WebIppCreateAuthReq
*
* Creates a IPPREQ_AUTH structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPREQ_AUTH WebIppCreateAuthReq(VOID)
{
    PIPPREQ_AUTH pfa;
    DWORD        cbSize;


    // Calculate the size in bytes that are necesary for
    // holding the IPPREQ_AUTH information.
    //
    cbSize = sizeof(IPPREQ_AUTH);


    // Allocate the request structure.
    //
    if (pfa = (PIPPREQ_AUTH)webAlloc(cbSize)) {

        pfa->cbSize = cbSize;
    }

    return pfa;
}


/*****************************************************************************\
* WebIppCreateJobRet
*
* Creates a IPPRET_JOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_JOB WebIppCreateJobRet(
    WORD           wRsp,
    BOOL           bRet,
    BOOL           bValidate,
    LPJOB_INFO_2   lpji2,
    LPJOB_INFO_IPP lpipp)
{
    PIPPRET_JOB pjr;
    DWORD       cbSize;


    // Calculate our structure size.
    //
    cbSize = sizeof(IPPRET_JOB) + ipp_SizeofIPPJI2(lpji2, lpipp);


    // Build our response.
    //
    if (pjr = (PIPPRET_JOB)webAlloc(cbSize)) {

        pjr->cbSize      = cbSize;
        pjr->dwLastError = WebIppRspToLe(wRsp);
        pjr->wRsp        = wRsp;
        pjr->bRet        = bRet;
        pjr->bValidate   = bValidate;

        ipp_BuildJI2(&pjr->ji, lpji2, lpipp, ((LPBYTE)pjr) + cbSize);
    }

    return pjr;
}


/*****************************************************************************\
* WebIppCreatePrnRet
*
* Creates a IPPRET_PRN structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_PRN WebIppCreatePrnRet(
    WORD               wRsp,
    BOOL               bRet,
    LPPRINTER_INFO_2   lppi2,
    LPPRINTER_INFO_IPP lpipp)
{
    PIPPRET_PRN ppr;
    DWORD       cbSize;


    // Calculate our structure size.
    //
    cbSize = sizeof(IPPRET_PRN) + ipp_SizeofIPPPI2(lppi2, lpipp);


    // Build our response.
    //
    if (ppr = (PIPPRET_PRN)webAlloc(cbSize)) {

        ppr->cbSize      = cbSize;
        ppr->dwLastError = WebIppRspToLe(wRsp);
        ppr->wRsp        = wRsp;
        ppr->bRet        = bRet;

        ipp_BuildPI2(&ppr->pi, lppi2, lpipp, ((LPBYTE)ppr) + cbSize);
    }

    return ppr;
}


/*****************************************************************************\
* WebIppCreateEnuJobRet
*
* Creates a IPPRET_ENUJOB structure.  This is the structure necessary
* for calling WebIpp* API's.
*  
\*****************************************************************************/
PIPPRET_ENUJOB WebIppCreateEnuJobRet(
    WORD     wRsp,
    BOOL     bRet,
    DWORD    cbJobs,
    DWORD    cJobs,
    LPIPPJI2 lpjiSrc)
{
    PIPPRET_ENUJOB pgj;
    LPIPPJI2       lpjiDst;
    LPBYTE         lpbEnd;
    DWORD          idx;
    DWORD          cbSize;

    cbSize = sizeof(IPPRET_ENUJOB) + ((cJobs && cbJobs && lpjiSrc) ? cbJobs : 0);

    if (pgj = (PIPPRET_ENUJOB)webAlloc(cbSize)) {

        pgj->cbSize      = cbSize;
        pgj->dwLastError = WebIppRspToLe(wRsp);
        pgj->wRsp        = wRsp;
        pgj->bRet        = bRet;
        pgj->cItems      = 0;
        pgj->cbItems     = 0;
        pgj->pItems      = NULL;


        if (cJobs && cbJobs && lpjiSrc) {

            // Initialize defaults.
            //
            pgj->cItems  = cJobs;
            pgj->cbItems = cbJobs;
            pgj->pItems  = (LPIPPJI2)(((LPBYTE)pgj) + sizeof(IPPRET_ENUJOB));


            lpjiDst = pgj->pItems;
            lpbEnd  = ((LPBYTE)lpjiDst) + cbJobs;

            for (idx = 0; idx < cJobs; idx++) {

                lpbEnd = ipp_BuildJI2(&lpjiDst[idx], &lpjiSrc[idx].ji2, &lpjiSrc[idx].ipp, lpbEnd);
            }
        }
    }

    return pgj;
}


/*****************************************************************************\
* WebIppCreateBadRet
*
* Creates a IPPRET_ALL structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_ALL WebIppCreateBadRet(
    WORD wRsp,
    BOOL bRet)
{
    PIPPRET_ALL pra;
    DWORD       cbSize;

    cbSize = sizeof(IPPRET_ALL);

    if (pra = (PIPPRET_ALL)webAlloc(cbSize)) {

        pra->cbSize      = cbSize;
        pra->dwLastError = WebIppRspToLe(wRsp);
        pra->wRsp        = wRsp;
        pra->bRet        = bRet;
    }

    return pra;
}


/*****************************************************************************\
* WebIppCreateAuthRet
*
* Creates a IPPRET_AUTH structure.  This is the structure necessary
* for calling WebIpp* API's.
*
\*****************************************************************************/
PIPPRET_AUTH WebIppCreateAuthRet(
    WORD wRsp,
    BOOL bRet)
{
    return (PIPPRET_AUTH)WebIppCreateBadRet(wRsp, bRet);
}


/*****************************************************************************\
* WebIppFreeMem
*
* Free memory allocated through the WebIpp routines.
*
\*****************************************************************************/
BOOL WebIppFreeMem(
    LPVOID lpMem)
{
    return webFree(lpMem);
}


/*****************************************************************************\
* WebIppCvtJI2toIPPJI2
*
* Converts an array of JOB_INFO_2 structures to an array of IPPJI2 structures.
*
* This code is only called from inetsrv/spool.cxx. It was better to change the
* the buffer calculation here than in the calling function since IPPJI2 is a 
* web printing only call. This will return the new required Job size in the 
* cbJobs Parameter that is passed in.
*
\*****************************************************************************/
LPIPPJI2 WebIppCvtJI2toIPPJI2(
    LPCTSTR      lpszJobBase,
    LPDWORD      lpcbJobs,
    DWORD        cJobs,
    LPJOB_INFO_2 lpjiSrc)
{
    LPBYTE   lpbEnd;
    DWORD    idx;
    DWORD    cbSize;
    DWORD    cbUri;
    LPIPPJI2 lpjiDst = NULL;

    WEB_IPP_ASSERT(lpcbJobs);

    if (*lpcbJobs && cJobs && lpjiSrc) {

        // For each job, we need to add enough to hold the extra
        // information.
        //
        cbUri  = 2*(webStrSize(lpszJobBase) + sizeof(DWORD)) * cJobs;
        // There can be two of these strings allocated, one for the JobUri and the 
        // other for the Printer Uri
        cbSize = (sizeof(IPPJI2) - sizeof(JOB_INFO_2)) * cJobs + *lpcbJobs + cbUri;
        // cbJobs already contains the correct size for the JOB_INFO_2 structure and its
        // strings we need the space for the JOB_INFO_IPP part of the structure plus the 
        // extra strings that will be added.

        *lpcbJobs = cbSize;  // Pass the required size back


        if (lpjiDst = (LPIPPJI2)webAlloc(cbSize)) {

            // Position string end at the end of our buffer.
            //
            lpbEnd = ((LPBYTE)lpjiDst) + cbSize;


            // For each job, copy.
            //
            for (idx = 0; idx < cJobs; idx++) {

                lpbEnd = ipp_CopyJI2toIPPJI2(&lpjiDst[idx],
                                             &lpjiSrc[idx],
                                             (LPTSTR)lpszJobBase,
                                             lpbEnd);
            }
        }
    }

    return lpjiDst;
}

/*****************************************************************************\
* WebIppPackJI2
*
* This takes in a JOB_INFO_2 structure whose members are note packed correctly
* and returns a correctly filled out and allocated JOB_INFO_2. It does not 
* copy the DEVMODE and SECURITY-DESCRIPTOR fields.
*
\*****************************************************************************/
LPJOB_INFO_2 WebIppPackJI2(
    IN  LPJOB_INFO_2  lpji2,
    OUT LPDWORD       lpcbSize,
    IN  ALLOCATORFN   pfnAlloc
    )  {

    WEB_IPP_ASSERT(lpji2);
    WEB_IPP_ASSERT(pfnAlloc);
    WEB_IPP_ASSERT(lpcbSize);

    *lpcbSize = 0;

    // This is used to perform the ipp_PackStrings operation
    LPTSTR  aszSrc[(sizeof(IPPJI2) / sizeof(LPTSTR))];
    
    // First get the required allocation size
    DWORD dwSize = ipp_SizeofIPPJI2( lpji2, NULL ) + sizeof(JOB_INFO_2);
    
    // Allocate the memory required to store the data

    LPJOB_INFO_2 pji2out = (LPJOB_INFO_2)pfnAlloc( dwSize );
    
    if (pji2out) {
        // First, do a straight copy of the memory from the incoming JI2 to the outgoing
        // ji2

        LPTSTR* lpszSrc = aszSrc;
        LPBYTE  lpbEnd  = (LPBYTE)pji2out + dwSize;

        *lpcbSize = dwSize;     

        CopyMemory( pji2out, lpji2, sizeof(JOB_INFO_2) );

        pji2out->pDevMode            = NULL; // These two pointers cannot be set
        pji2out->pSecurityDescriptor = NULL;

        *lpszSrc++ = lpji2->pPrinterName;
        *lpszSrc++ = lpji2->pMachineName;
        *lpszSrc++ = lpji2->pUserName;
        *lpszSrc++ = lpji2->pDocument;
        *lpszSrc++ = lpji2->pNotifyName;
        *lpszSrc++ = lpji2->pDatatype;
        *lpszSrc++ = lpji2->pPrintProcessor;
        *lpszSrc++ = lpji2->pParameters;
        *lpszSrc++ = lpji2->pDriverName;
        *lpszSrc++ = lpji2->pStatus;

        ipp_PackStrings(aszSrc, (LPBYTE)pji2out, s_JI2Off, lpbEnd);
    }

    return pji2out;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\precomp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam (MuhuntS)  17-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <objbase.h>
#define USE_SP_ALTPLATFORM_INFO_V1 0
#include <setupapi.h>
#include <shellapi.h>
#include <cfgmgr32.h>
#include <winspool.h>
#include <winsprlp.h>
#include <Winver.h>
#include "splsetup.h"
#include <wincrypt.h>
#include <mscat.h>
#include <icm.h>
#include <stdio.h>
#include "tchar.h"
#include "cdm.h"
#include "web.h"
#include "local.h"
#include "ntprint.h"
#include "spllib.hxx"
#include "printui.h"

//
// We need to include wow64t.h to ensure that 
// WOW64_SYSTEM_DIRECTORY and WOW64_SYSTEM_DIRECTORY_U
// are defined and for 64bit file redirection in WOW64
//
#include <wow64t.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\ntprint.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    ntprint.h

Abstract:

    Definitions used by the printer class installer

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-96

Revision History:

--*/

#define FIRST_PRIVATE           0x00010000

#define DIF_DRIVERINFO          0x00010001

typedef struct _PRINTER_CLASSINSTALL_INFO {

    DWORD       cbSize;
    DWORD       dwLevel;
    LPBYTE      pBuf;
    DWORD       cbBufSize;
    LPDWORD     pcbNeeded;
} PRINTER_CLASSINSTALL_INFO, *PPRINTER_CLASSINSTALL_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\monitor.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Monitor.c

Abstract:

    Routines for installing monitors

Author:

    Muhunthan Sivapragasam (MuhuntS) 30-Nov-1995

Revision History:

--*/

#include "precomp.h"


//
// Keys to search INF files
//
TCHAR   cszOptions[]                = TEXT("Options");
TCHAR   cszPortMonitorSection[]     = TEXT("PortMonitors");
TCHAR   cszPortMonitorDllKey []     = TEXT("PortMonitorDll");
TCHAR   cszMonitorInf[]             = TEXT("*.inf");


typedef struct _MON_INFO {
    LPTSTR  pszName;
    LPTSTR  pszDllName;
    BOOL    bInstalled;
} MON_INFO, *PMON_INFO;

typedef struct _MONITOR_SETUP_INFO {
    PMON_INFO  *ppMonInfo;
    DWORD       dwCount;
    LPTSTR      pszInfFile;         // Valid only for OEM disk INF
    LPTSTR      pszServerName;
} MONITOR_SETUP_INFO, *PMONITOR_SETUP_INFO;


VOID
FreeMonInfo(
    PMON_INFO   pMonInfo
    )
/*++

Routine Description:
    Free memory for a MON_INFO structure and the strings in it

Arguments:
    pMonInfo    : MON_INFO structure pointer

Return Value:
    Nothing

--*/
{
    if ( pMonInfo ) {

        LocalFreeMem(pMonInfo->pszName);
        LocalFreeMem(pMonInfo->pszDllName);

        LocalFreeMem(pMonInfo);
    }
}


PMON_INFO
AllocMonInfo(
    IN  LPTSTR  pszName,
    IN  LPTSTR  pszDllName,     OPTIONAL
    IN  BOOL    bInstalled,
    IN  BOOL    bAllocStrings
    )
/*++

Routine Description:
    Allocate memory for a MON_INFO structure and create strings

Arguments:
    pszName         : Monitor name
    pszDllName      : Monitor DLL name
    bAllocStrings   : TRUE if routine should allocated memory and create string
                      copies, else just assign the pointers

Return Value:
    Pointer to the created MON_INFO structure. NULL on error.

--*/
{
    PMON_INFO   pMonInfo;

    pMonInfo    = (PMON_INFO) LocalAllocMem(sizeof(*pMonInfo));

    if ( !pMonInfo )
        return NULL;

    if ( bAllocStrings ) {

        pMonInfo->pszName    = AllocStr(pszName);
        pMonInfo->pszDllName = AllocStr(pszDllName);

        if ( !pMonInfo->pszName ||
             (pszDllName && !pMonInfo->pszDllName) ) {

            FreeMonInfo(pMonInfo);
            return NULL;

        }
    } else {

        pMonInfo->pszName       = pszName;
        pMonInfo->pszDllName    = pszDllName;
    }

    pMonInfo->bInstalled = bInstalled;

    return pMonInfo;
}


VOID
PSetupDestroyMonitorInfo(
    IN OUT HANDLE h
    )
/*++

Routine Description:
    Free memory allocated to a MONITOR_SETUP_INFO structure and its contents

Arguments:
    h   : A handle got by call to PSetupCreateMonitorInfo

Return Value:
    Nothing

--*/
{
    PMONITOR_SETUP_INFO pMonitorSetupInfo = (PMONITOR_SETUP_INFO) h;
    DWORD   Index;

    if ( pMonitorSetupInfo ) {

        if ( pMonitorSetupInfo->ppMonInfo ) {

            for ( Index = 0 ; Index < pMonitorSetupInfo->dwCount ; ++Index )
                FreeMonInfo(pMonitorSetupInfo->ppMonInfo[Index]);

            LocalFreeMem(pMonitorSetupInfo->ppMonInfo);
        }

        LocalFreeMem(pMonitorSetupInfo->pszInfFile);
        LocalFreeMem(pMonitorSetupInfo->pszServerName);
        LocalFreeMem(pMonitorSetupInfo);
    }
}


BOOL
IsMonitorFound(
    IN  LPVOID  pBuf,
    IN  DWORD   dwReturned,
    IN  LPTSTR  pszName
    )
/*++

Routine Description:
    Find out if the given monitor name is found in the buffer returned from
    an EnumMonitors call to spooler

Arguments:
    pBuf        : Buffer used on a succesful EnumMonitor call to spooler
    dwReturned  : Count returned by spooler on EnumMonitor
    pszMonName  : Monitor name we are searching for

Return Value:
    TRUE if monitor is found, FALSE else

--*/
{
    PMONITOR_INFO_2     pMonitor2;
    DWORD               Index;

    for ( Index = 0, pMonitor2 = (PMONITOR_INFO_2) pBuf ;
          Index < dwReturned ;
          ++Index, (LPBYTE)pMonitor2 += sizeof(MONITOR_INFO_2) ) {

        if ( !lstrcmpi(pszName, pMonitor2->pName) )
            return TRUE;
    }

    return FALSE;

}


PMONITOR_SETUP_INFO
CreateMonitorInfo(
    LPCTSTR     pszServerName
    )
/*++

Routine Description:
    Finds all installed and installable monitors.

Arguments:
    pSelectedDrvInfo    : Pointer to the selected driver info (optional)

Return Value:
    A pointer to MONITOR_SETUP_INFO on success,
    NULL on error

--*/
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = NULL;
    PMON_INFO               *ppMonInfo;
    PMONITOR_INFO_2         pMonitor2;
    LONG                    Index, Count = 0;
    BOOL                    bFail = TRUE;
    DWORD                   dwNeeded, dwReturned;
    LPBYTE                  pBuf = NULL;
    LPTSTR                  pszMonName;

    //
    // First query spooler for installed monitors. If we fail let's quit
    //
    if ( !EnumMonitors((LPTSTR)pszServerName, 2, NULL,
                       0, &dwNeeded, &dwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
             !(pBuf = LocalAllocMem(dwNeeded)) ||
             !EnumMonitors((LPTSTR)pszServerName,
                           2,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           &dwReturned) ) {

            goto Cleanup;
        }
    }

    //
    // We know how many monitors we have to display now
    //
    pMonitorSetupInfo = (PMONITOR_SETUP_INFO) LocalAllocMem(sizeof(*pMonitorSetupInfo));

    if ( !pMonitorSetupInfo )
        goto Cleanup;

    ZeroMemory(pMonitorSetupInfo, sizeof(*pMonitorSetupInfo));

    //
    // pMonitorSetupInfo->dwCount could be adjusted later not to list duplicate
    // entries. We are allocating max required buffer here
    //
    pMonitorSetupInfo->dwCount = dwReturned;

    pMonitorSetupInfo->ppMonInfo = (PMON_INFO *)
                        LocalAllocMem(pMonitorSetupInfo->dwCount*sizeof(PMON_INFO));

    ppMonInfo = pMonitorSetupInfo->ppMonInfo;

    if ( !ppMonInfo )
        goto Cleanup;

    for ( Index = 0, pMonitor2 = (PMONITOR_INFO_2) pBuf ;
          Index < (LONG) dwReturned ;
          ++Index, (LPBYTE)pMonitor2 += sizeof(MONITOR_INFO_2) ) {

        *ppMonInfo++ = AllocMonInfo(pMonitor2->pName,
                                    pMonitor2->pDLLName,
                                    TRUE,
                                    TRUE);
    }

    bFail = FALSE;

Cleanup:
    if ( pBuf )
        LocalFreeMem(pBuf);

    if ( bFail ) {

        PSetupDestroyMonitorInfo(pMonitorSetupInfo);
        pMonitorSetupInfo = NULL;
    }

    return pMonitorSetupInfo;
}


BOOL
AddPrintMonitor(
    IN  LPCTSTR     pszName,
    IN  LPCTSTR     pszDllName
    )
/*++

Routine Description:
    Add a print monitor by calling AddMonitor to spooler

Arguments:
    pszName     : Name of the monitor
    pszDllName  : Monitor dll name

Return Value:
    TRUE if monitor was succesfully added or it is already installed,
    FALSE on failure

--*/
{
    MONITOR_INFO_2  MonitorInfo2;

    MonitorInfo2.pName          = (LPTSTR) pszName;
    MonitorInfo2.pEnvironment   = NULL;
    MonitorInfo2.pDLLName       = (LPTSTR) pszDllName;

    //
    // Call is succesful if add returned TRUE, or monitor is already installed
    //
    if ( AddMonitor(NULL, 2, (LPBYTE) &MonitorInfo2) ||
         GetLastError() == ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) {

        return TRUE;
    } else {

        return FALSE;
    }
}


PMON_INFO
MonInfoFromName(
    IN PMONITOR_SETUP_INFO  pMonitorSetupInfo,
    IN LPCTSTR              pszMonitorName
    )
{
    PMON_INFO   pMonInfo;
    DWORD       dwIndex;

    if ( !pMonitorSetupInfo ) {

        return NULL;
    }

    for ( dwIndex = 0 ; dwIndex < pMonitorSetupInfo->dwCount ; ++dwIndex ) {

        pMonInfo = pMonitorSetupInfo->ppMonInfo[dwIndex];
        if ( !lstrcmp(pszMonitorName, pMonInfo->pszName) ) {

            return pMonInfo;
        }
    }

    return NULL;
}

BOOL
InstallOnePortMonitor(HWND hwnd, 
                      HINF hInf, 
                      LPTSTR pMonitorName, 
                      LPTSTR pSectionName, 
                      LPTSTR pSourcePath)
/*++

Routine Description:
    Install one port monitor by copying files and calling spooler to add it

Arguments:
    hwnd                : Window handle of current top-level window
    hInf                : handle to the INF file
    pMonitorName        : port monitor display name
    pSectionName        : install section within the INF for the port monitor 

Return Value:
    TRUE if a port monitor was successfully installed
    FALSE if not

--*/

{
    DWORD  NameLen;
    BOOL   bSuccess = FALSE;
    HSPFILEQ InstallQueue = {0};
    PVOID  pQueueContext = NULL;
    LPTSTR  pMonitorDllName;

    NameLen = MAX_PATH;
    if ((pMonitorDllName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL)
    {
        goto Cleanup;
    }
    
    //
    // Find the port monitor DLL name
    //
    if (!SetupGetLineText(NULL, hInf, pSectionName, cszPortMonitorDllKey, pMonitorDllName, NameLen, NULL))
    {
        goto Cleanup;
    }

    //
    // perform the installation
    //
    
    if ((InstallQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    if (!SetupInstallFilesFromInfSection(hInf, NULL, InstallQueue, pSectionName, pSourcePath, 
                                         SP_COPY_IN_USE_NEEDS_REBOOT | SP_COPY_NOSKIP))
    {
        goto Cleanup;
    }

    //
    // Commit the file queue. This gets all files copied over.
    //
    pQueueContext = SetupInitDefaultQueueCallback(hwnd);
    if ( !pQueueContext ) 
    {
        goto Cleanup;
    }

    bSuccess = SetupCommitFileQueue(hwnd,
                                  InstallQueue,
                                  SetupDefaultQueueCallback,
                                  pQueueContext);


    if ( !bSuccess )
        goto Cleanup;

    bSuccess = AddPrintMonitor(pMonitorName, pMonitorDllName);

Cleanup:
    if (pQueueContext)
    {
        SetupTermDefaultQueueCallback(pQueueContext);
    }

    if (pMonitorDllName)
    {
        LocalFreeMem(pMonitorDllName);
    }
    
    SetupCloseFileQueue(InstallQueue);

    if (!bSuccess)
    {
        LPTSTR pszFormat = NULL, pszPrompt = NULL, pszTitle = NULL;

        pszFormat   = GetStringFromRcFile(IDS_ERROR_INST_PORT_MONITOR);
        pszTitle    = GetStringFromRcFile(IDS_INSTALLING_PORT_MONITOR);

        if ( pszFormat && pszTitle)
        {
            pszPrompt = LocalAllocMem((lstrlen(pszFormat) + lstrlen(pMonitorName) + 2)
                                                * sizeof(TCHAR));

            if ( pszPrompt )
            {
                wsprintf(pszPrompt, pszFormat, pMonitorName);

                MessageBox(hwnd, pszPrompt, pszTitle, MB_OK);

                LocalFreeMem(pszPrompt);
            }

        }
        LocalFreeMem(pszFormat);
        LocalFreeMem(pszTitle);
    
    }

    return bSuccess;
}

BOOL
InstallAllPortMonitorsFromInf(HWND hwnd, 
                              HINF hInfFile, 
                              LPTSTR pSourcePath)
/*++

Routine Description:
    Install all port monitors listed in one INF

Arguments:
    hwnd                : Window handle of current top-level window
    hInfFile            : handle of the INF file
    pSourcePath         : path to the INF file (without the name of the INF)

Return Value:
    TRUE if at least one port monitor was successfully installed
    FALSE if not

--*/

{
    LPTSTR pMonitorName = NULL, pSectionName= NULL;
    DWORD  NameLen;
    BOOL   bSuccess = FALSE;
    INFCONTEXT Context = {0};

    NameLen = MAX_PATH;
    if (((pMonitorName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL) ||
        ((pSectionName = LocalAllocMem(NameLen * sizeof(TCHAR))) == NULL))
    {
        goto Cleanup;
    }

    //
    // Go through the list of port monitors
    //
    if (!SetupFindFirstLine(hInfFile, cszPortMonitorSection, NULL, &Context))
    {
        goto Cleanup;
    }

    do 
    {
        //
        // get the key name
        //
        if (!SetupGetStringField(&Context, 0, pMonitorName, NameLen, NULL))
        {
            goto Cleanup;
        }
        //
        // get the section name
        //
        if (!SetupGetStringField(&Context, 1, pSectionName, NameLen, NULL))
        {
            goto Cleanup;
        }
        
        bSuccess = InstallOnePortMonitor(hwnd, hInfFile, pMonitorName, pSectionName, pSourcePath) ||
                   bSuccess;

    } while (SetupFindNextLine(&Context, &Context));

Cleanup:
    if (pMonitorName)
    {
        LocalFreeMem(pMonitorName);
    }
    if (pSectionName)
    {
        LocalFreeMem(pSectionName);
    }

    return bSuccess;
}

BOOL
PSetupInstallMonitor(
    IN  HWND                hwnd
    )
/*++

Routine Description:
    Install a print monitor by copying files, and calling spooler to add it

Arguments:
    hwnd                : Window handle of current top-level window

Return Value:
    TRUE if at least one port monitor was successfully installed
    FALSE if not

--*/
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = NULL;
    PMON_INFO              *ppMonInfo, pMonInfo;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              InfContext;
    TCHAR                   szInfPath[MAX_PATH];
    LPTSTR                  pszTitle, pszPrintMonitorPrompt;
    WIN32_FIND_DATA         FindData ={0};
    HANDLE                  hFind;
    size_t                  PathLen;
    BOOL                    bRet = FALSE;
    

    pszTitle              = GetStringFromRcFile(IDS_INSTALLING_PORT_MONITOR);
    pszPrintMonitorPrompt = GetStringFromRcFile(IDS_PROMPT_PORT_MONITOR);

    if (!pszTitle || ! pszPrintMonitorPrompt) 
    {
        goto Cleanup;
    }

    //
    // Ask the user where the inf file with the port monitor info resides
    //
    GetCDRomDrive(szInfPath);

    if ( !PSetupGetPathToSearch(hwnd,
                                pszTitle,
                                pszPrintMonitorPrompt,
                                cszMonitorInf,
                                TRUE,
                                szInfPath) ) {

        goto Cleanup;
    }

    //
    // find the INF(s) in the path. There must be one else SetupPromptForPath would've complained
    //
    PathLen = _tcslen(szInfPath);
    if (PathLen > MAX_PATH - _tcslen(cszMonitorInf) - 2) // -2 for terminating zero and backslash
    {
        DBGMSG(DBG_WARN, ("PSetupInstallMonitor: Path too long\n"));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        goto Cleanup;
    }

    ASSERT(PathLen);

    if (szInfPath[PathLen-1] != _T('\\'))
    {
        szInfPath[PathLen++] = _T('\\');
        szInfPath[PathLen] = 0;
    }

    _tcscat(szInfPath, cszMonitorInf);

    hFind = FindFirstFile(szInfPath, &FindData);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        HANDLE hInfFile;

        do
        {
            if (PathLen + _tcslen(FindData.cFileName) >= MAX_PATH)
            {
                DBGMSG(DBG_WARN, ("PSetupInstallMonitor: Path for %s%s too long - file skipped\n", szInfPath, FindData.cFileName));
                SetLastError(ERROR_BUFFER_OVERFLOW);
                continue;
            }

            _tcscpy(&(szInfPath[PathLen]), FindData.cFileName);

            hInfFile = SetupOpenInfFile(szInfPath, _T("Printer"), INF_STYLE_WIN4, NULL);

            if (hInfFile != INVALID_HANDLE_VALUE)
            {
                //
                // if the file has a section on port monitors, install it
                //
                if ( SetupGetLineCount(hInfFile, cszPortMonitorSection) > 0 )
                {
                    //
                    // cut off the INF name from the path
                    //
                    szInfPath[PathLen -1] = 0;

                    //
                    // bRet should be TRUE if there was at least one print monitor successfully installed
                    //
                    bRet = InstallAllPortMonitorsFromInf(hwnd, hInfFile, szInfPath) || bRet;                    
                    
                    //
                    // Put the trailing backslash back on
                    //
                    szInfPath[PathLen -1] = _T('\\');
                
                }

                SetupCloseInfFile(hInfFile);
            }
        } while ( FindNextFile(hFind, &FindData) );

        FindClose(hFind);
    }

Cleanup:
    if (pszTitle)
    {
        LocalFreeMem(pszTitle);
    }
    if (pszPrintMonitorPrompt)
    {
        LocalFreeMem(pszPrintMonitorPrompt);
    }

    return bRet;
}


HANDLE
PSetupCreateMonitorInfo(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszServerName
    )
{
    return (HANDLE) CreateMonitorInfo(pszServerName);
}


BOOL
PSetupEnumMonitor(
    IN     HANDLE   h,
    IN     DWORD    dwIndex,
    OUT    LPTSTR   pMonitorName,
    IN OUT LPDWORD  pdwSize
    )
{
    PMONITOR_SETUP_INFO     pMonitorSetupInfo = (PMONITOR_SETUP_INFO) h;
    PMON_INFO               pMonInfo;
    DWORD                   dwNeeded;

    if ( dwIndex >= pMonitorSetupInfo->dwCount ) {

        SetLastError(ERROR_NO_MORE_ITEMS);
        return FALSE;
    }

    pMonInfo = pMonitorSetupInfo->ppMonInfo[dwIndex];

    dwNeeded = lstrlen(pMonInfo->pszName) + 1;
    if ( dwNeeded > *pdwSize ) {

        *pdwSize = dwNeeded;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    lstrcpy(pMonitorName, pMonInfo->pszName);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\printupg.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    printupg.cxx
    
Abstract:

    Code to implement printupg. Please refer to printupg.hxx for an overview 
    of printupg feature set.
    
Author:

    Larry Zhu (LZhu) 20-Feb-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "printupg.hxx"

/*++

Routine Name

    PSetupIsCompatibleDriver
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver is blocked 
    or warned, return the blocking status and the replacement driver, if any.
    
Arguments:
    
    pszServer             - The server that needs to check for bad driver. If
                            pszServer is NULL, that means the local machine
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path 
                            or the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    dwVersion             - The major version of the driver
    pFileTimeDriver       - The FileTime of the driver
    puBlockingStatus      - Points to status of blocking
    ppszReplacementDriver - Points to the NULL terminating name of the replacement 
                            driver. A *NULL* string (instead of an empty string) 
                            means there is no replacement driver

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code. Pass a NULL to ppszReplacementDriver 
                           will not receive the name of replacement driver otherwise
                           Call PSetupFreeMem to free the received string pointed by
                           ppszReplacementDriver

--*/
BOOL
PSetupIsCompatibleDriver(
    IN     LPCTSTR          pszServer,                OPTIONAL
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     DWORD            dwVersion,
    IN     FILETIME         *pFileTimeDriver,        
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    )
{
    HRESULT hRetval         = E_FAIL;
    UINT    uBlockingStatus = 0;
    TString strReplacementDriver;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pFileTimeDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = 0;
        if (ppszReplacementDriver)
        {
            *ppszReplacementDriver = NULL;
        }
        
        hRetval = IsLocalMachineServer();
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = InternalCompatibleDriverCheck(pszDriverModel,
                                                pszDriverPath,
                                                pszEnvironment,
                                                pFileTimeDriver,
                                                cszUpgradeInf,
                                                dwVersion,
                                                S_OK == hRetval ? TRUE : FALSE,  // bIsServer
                                                &uBlockingStatus,
                                                &strReplacementDriver);
    }
                                         
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = uBlockingStatus;
        if ((BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) && ppszReplacementDriver && !strReplacementDriver.bEmpty())
        {
            *ppszReplacementDriver = AllocStr(strReplacementDriver);
            hRetval = ppszReplacementDriver ? S_OK : E_OUTOFMEMORY;
            
            if (SUCCEEDED(hRetval))
            {
                *pdwBlockingStatus |= BSP_INBOX_DRIVER_AVAILABLE;
            }
        }
    } 
          
    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));   
    return SUCCEEDED(hRetval);                                     
}

/*++

Routine Name:

    AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry

Routine Description:

    This routine tries to add the printer driver and it is blocked or
    warned, it popups a message box either indicates the driver is blocked 
    and installation will abort or at the case of warned driver, whether 
    to preceed the driver installation.

Arguments:

    pszServer                     - The server that needs to check for bad driver. If
                                    pszServer is NULL, that means the local machine
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    dwAddDrvFlags                 - Flags used in AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOfferReplacement             - Whether to offer replacement
    bPopupUI                      - Whether to popup UI
    ppszReplacementDriver         - Points to the replacement driver
    pdwBlockingStatus             - Points to blocking status of the driver    
    
Return Value:

    An BOOL                      - GetLastError() on failure                 

--*/  
BOOL
AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    )
{  
    HRESULT   hRetval         = E_FAIL;
    DWORD     dwLevel         = 6;
    FILETIME  DriverFileTime;

    hRetval = pDriverInfo6 && ppszReplacementDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
    
    //
    // Set APD_NO_UI flag and call AddPrinterDriver.
    //
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = BSP_PRINTER_DRIVER_OK;
        *ppszReplacementDriver = NULL;
        dwAddDrvFlags |= APD_NO_UI;
        hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                     dwLevel,
                                     reinterpret_cast<BYTE*>(pDriverInfo6),
                                     dwAddDrvFlags) ? ERROR_SUCCESS : GetLastErrorAsHResult();
    }

    for ( dwLevel = 4; (FAILED(hRetval) && (ERROR_INVALID_LEVEL == HRESULT_CODE(hRetval))) && (dwLevel > 1) ; --dwLevel ) {
        
        //
        // Since DRIVER_INFO_2, 3, 4 are subsets of DRIVER_INFO_6 and all fields
        // are at the beginning these calls can be made with same buffer
        //
        hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                     dwLevel,
                                     reinterpret_cast<BYTE*>(pDriverInfo6),
                                     dwAddDrvFlags) ? S_OK : GetLastErrorAsHResult();
    }
   
    //
    // Set the blocking status information (either blocked or warned) from the 
    // server.
    //
    // Show printupg ui and get the replacement driver from printupg.inf on 
    // client and get user's response and retry AddPrinterDriver with level
    // dwLevel.
    //
    if (FAILED(hRetval) && bPopupUI && ((ERROR_PRINTER_DRIVER_BLOCKED == HRESULT_CODE(hRetval)) || (ERROR_PRINTER_DRIVER_WARNED == HRESULT_CODE(hRetval))))
    {       
        *pdwBlockingStatus = (ERROR_PRINTER_DRIVER_BLOCKED == HRESULT_CODE(hRetval)) ? BSP_PRINTER_DRIVER_BLOCKED : BSP_PRINTER_DRIVER_WARNED;
    
        hRetval = PrintUpgRetry(pszServer,                               
                                dwLevel,
                                pDriverInfo6,
                                dwAddDrvFlags,
                                bIsDriverPathFullPath,
                                bOfferReplacement,
                                pdwBlockingStatus,
                                ppszReplacementDriver);
    }   

    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));
    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    BlockedDriverPrintUpgUI
   
Routine Description:

    This routine checks the printupg.inf and see if the driver is there. If the
    driver is there, consider it blocked even if it is warned. Then it popups a
    message box either indicates the driver is blocked and ask whether the user
    wants to proceed to install a replacement driver it has one.

Arguments:

    pszServer                     - The server that needs to check for bad driver. If
                                    pszServer is NULL, that means the local machine
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOfferReplacement             - Whether to offer replacement
    bPopupUI                      - Whether to popup UI
    ppszReplacementDriver         - Points to the replacement driver
    pdwBlockingStatus             - Points to blocking status of the driver    
    
Return Value:

    An BOOL                      - GetLastError() on failure                 

--*/  
BOOL
BlockedDriverPrintUpgUI(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    )
{  
    HRESULT hRetval                  = E_FAIL;
    DWORD   dwBlockingStatusOnClient = BSP_PRINTER_DRIVER_OK;

    hRetval = pDriverInfo6 && ppszReplacementDriver && pdwBlockingStatus ? S_OK : E_INVALIDARG;
             
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = BSP_PRINTER_DRIVER_OK;
        *ppszReplacementDriver = NULL;
        hRetval = IsDriverBadLocally(pszServer,
                                     pDriverInfo6,
                                     bIsDriverPathFullPath,
                                     &dwBlockingStatusOnClient,
                                     ppszReplacementDriver); 

        //
        // Get the replacement driver information
        //
        if (SUCCEEDED(hRetval) && (BSP_PRINTER_DRIVER_OK != (dwBlockingStatusOnClient & BSP_BLOCKING_LEVEL_MASK)))
        {
            *pdwBlockingStatus |= (dwBlockingStatusOnClient & ~BSP_BLOCKING_LEVEL_MASK) | BSP_PRINTER_DRIVER_BLOCKED; 
        }
    }

    if (SUCCEEDED(hRetval) && bPopupUI && (BSP_PRINTER_DRIVER_BLOCKED & *pdwBlockingStatus))
    {
        hRetval = PrintUpgRetry(pszServer,                               
                                6, // dwLevel, do not care in the case of blocked driver
                                pDriverInfo6,
                                0, // dwAddDrvFlags, do not care in the case of blocked driver
                                bIsDriverPathFullPath,
                                bOfferReplacement,
                                pdwBlockingStatus,
                                ppszReplacementDriver);
    }

    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));
    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    PrintUpgRetry

Routine Description:

    This routine popups up a message box either indicates the driver is blocked
    or warned and asks the user how to preceed. In the case of warned driver, 
    whether to preceed the driver installation and retry AddPrinterDriver if 
    the user wants to proceed with a warned driver.

Arguments:

    pszServer                     - Remote machine that has the driver files
    dwLevel                       - Driver info level, since DRIVER_INFO_6
                                    is a super set of level 4, 3, and 2,
                                    the driver info structure is shared
    pDriverInfo6                  - Points to DRIVER_INFO_6 structure
    dwAddDrvFlags                 - Flags used to AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOffereReplacement            - Whether to offer a replacement driver
    pdwBlockingStatus             - Points to blocking status on server
    ppszReplacementDriver         - Points to the replacement driver

Return Value:

    An HRESULT                                 

--*/
HRESULT
PrintUpgRetry(
    IN     LPCTSTR          pszServer,              OPTIONAL
    IN     DWORD            dwLevel,    
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver && ((6 == dwLevel) || (dwLevel >= 2) && (dwLevel <= 4)) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppszReplacementDriver = NULL;
        hRetval = PrintUpgUI(pszServer,
                             pDriverInfo6,
                             bIsDriverPathFullPath,
                             bOfferReplacement,
                             pdwBlockingStatus,
                             ppszReplacementDriver);
        
        //
        //  There are 4 cases here:
        //  1. For warned driver and the user instructs to install it, try 
        //     AddPrinterDriverEx again with APD_INSTALL_WARNED_DRIVER.
        //  2. If the user wants to cancel, set the last error correctly and 
        //     abort.
        //  3. If the user wants to install the replacement driver, we will 
        //     set the error code correctly and do not install the replacement
        //     driver at this moment since we shall clean ourself up first.
        //  4. If other errors occur, we will just return the correct error 
        //     code.
        //
        //  For case 1, 2, 4, we do not return the replacement driver because
        //  I can not see any reason to do so.
        //
        if (FAILED(hRetval) || !(*pdwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))         // except case 3 
        {
            LocalFreeMem(*ppszReplacementDriver);
            *ppszReplacementDriver = NULL;
        }
        
        if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_PROCEEDED))      // case 1
        {
             dwAddDrvFlags |= APD_INSTALL_WARNED_DRIVER;

             hRetval = AddPrinterDriverEx(const_cast<LPTSTR>(pszServer),
                                          dwLevel,
                                          reinterpret_cast<BYTE*>(pDriverInfo6),
                                          dwAddDrvFlags) ? ERROR_SUCCESS : GetLastErrorAsHResult();
        } 
        else if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_CANCELLED)) // case 2
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else if (SUCCEEDED(hRetval) && (*pdwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))  // case 3
        {
            hRetval = HResultFromWin32((*pdwBlockingStatus & BSP_PRINTER_DRIVER_BLOCKED) ? ERROR_PRINTER_DRIVER_BLOCKED : ERROR_PRINTER_DRIVER_WARNED);
        }
    }

    return hRetval;
}

/*++

Routine Name:

    PrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    pszServer                     - Remote machine that has the driver files
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    bOffereReplacement            - Whether to offer a replacement driver
    pdwBlockingStatus             - Points to blocking status on server
    ppszReplacementDriver         - Points to the replacement driver

Return Value:

    An HRESULT                                

--*/  
HRESULT
PrintUpgUI(
    IN     LPCTSTR          pszServer,              OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT  hRetval                  = E_FAIL;     
    DWORD    dwBlockingStatusOnClient = BSP_PRINTER_DRIVER_OK;
    
    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver ? S_OK : E_INVALIDARG;

    //
    // Take the replacement driver information from local client.
    //    
    if (SUCCEEDED(hRetval) && bOfferReplacement)
    {
        *ppszReplacementDriver = NULL;
        hRetval = IsDriverBadLocally(pszServer,
                                     pDriverInfo6,
                                     bIsDriverPathFullPath,
                                     &dwBlockingStatusOnClient,
                                     ppszReplacementDriver); 

        //
        // Get the replacement driver information
        //
        if (SUCCEEDED(hRetval))
        {
            *pdwBlockingStatus |= (dwBlockingStatusOnClient & ~BSP_BLOCKING_LEVEL_MASK); 
        }
   }
   
   //
   // Get the user's response
   //  
   if (SUCCEEDED(hRetval))
   {   
       *pdwBlockingStatus &= ~BSP_USER_RESPONSE_MASK;
       hRetval = InternalPrintUpgUI(pDriverInfo6->pName,
                                    pDriverInfo6->pDriverPath,        // main rendering driver dll
                                    pDriverInfo6->pEnvironment,
                                    pDriverInfo6->cVersion,  
                                    pdwBlockingStatus);
   }
           
   return hRetval;
}

/*++

Routine Name

    InfIsCompatibleDriver
        
Routine Description:

    Check whether the driver is blocked or warned and if the driver is blocked 
    or warned, return the blocking status and the replacement driver, if any.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path 
                            or the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    hInf                  - Handle to printupg inf
    puBlockingStatus      - Points to status of blocking
    ppszReplacementDriver - Points to the NULL terminating name of the replacement 
                            driver. A *NULL* string (instead of an empty string) 
                            means there is no replacement driver

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code. Pass a NULL to ppszReplacementDriver 
                           will not receive the name of replacement driver otherwise
                           Call PSetupFreeMem to free the received string pointed by
                           ppszReplacementDriver

--*/
BOOL
InfIsCompatibleDriver(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     HINF             hInf,       
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    )
{
    HRESULT  hRetval         = E_FAIL;
    UINT     uBlockingStatus = 0;      
    DWORD    dwMajorVersion  = 0;
    BOOL     bIsServer       = FALSE;
    TString  strReplacementDriver;
    FILETIME DriverFileTime;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && (hInf != INVALID_HANDLE_VALUE) && pdwBlockingStatus ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = 0;
        if (ppszReplacementDriver)
        {
            *ppszReplacementDriver = NULL;
        }

        hRetval = GetPrinterDriverVersion(pszDriverPath, &dwMajorVersion, NULL);
    }
        
    if (SUCCEEDED(hRetval))
    {
       hRetval = IsLocalMachineServer();
    }
    
    if (SUCCEEDED(hRetval))
    {   
        bIsServer = S_OK == hRetval ? TRUE : FALSE;

        hRetval = GetFileTimeByName(pszDriverPath, &DriverFileTime);
    }
            
    if (S_OK == hRetval)
    {
        hRetval = InternalCompatibleInfDriverCheck(pszDriverModel,
                                                   pszDriverPath,
                                                   pszEnvironment,
                                                   &DriverFileTime,
                                                   hInf,
                                                   dwMajorVersion,
                                                   bIsServer,
                                                   &uBlockingStatus,
                                                   &strReplacementDriver);

    }
                                             
    if (SUCCEEDED(hRetval))
    {
        *pdwBlockingStatus = uBlockingStatus;
        if ((BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) && ppszReplacementDriver && !strReplacementDriver.bEmpty())
        {
            *ppszReplacementDriver = AllocStr(strReplacementDriver);
            hRetval = ppszReplacementDriver ? S_OK : E_OUTOFMEMORY;
            
            if (SUCCEEDED(hRetval))
            {
                *pdwBlockingStatus |= BSP_INBOX_DRIVER_AVAILABLE;
            }
        }
    } 
          
    SetLastError(SUCCEEDED(hRetval) ? ERROR_SUCCESS : HRESULT_CODE(hRetval));   
    return SUCCEEDED(hRetval);                                     
}

/*++

Routine Name:

    GetPrinterDriverVersion

Routine Description:

    Gets version information about an executable file. If the file is not an
    executable, it will return 0 for both major and minor version.

Arguments:

    pszFileName                 -   file name, this is either a full path for
                                    the file is under the path in  the search 
                                    sequence specified used the LoadLibrary 
                                    function. 
    pdwFileMajorVersion         -   pointer to major version
    pdwFileMinorVersion         -   pointer to minor version
    
Return Value:

    An HRESULT

--*/
HRESULT
GetPrinterDriverVersion(
    IN     LPCTSTR           pszFileName,               
       OUT DWORD             *pdwFileMajorVersion,           OPTIONAL
       OUT DWORD             *pdwFileMinorVersion            OPTIONAL
     )
{
    HRESULT           hRetval             = E_FAIL;
    DWORD             dwSize              = 0;
    UINT              uLen                = 0;
    BYTE              *pbBlock            = NULL;     
    VS_FIXEDFILEINFO  *pFileVersion       = NULL;   

    hRetval = pszFileName && *pszFileName ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        dwSize = GetFileVersionInfoSize(const_cast<LPTSTR>(pszFileName), 0);

        if (dwSize == 0)
        {
            hRetval = GetLastErrorAsHResult();
        }      
    }
   
    if (SUCCEEDED(hRetval))
    {
        pbBlock = new BYTE[dwSize];
        hRetval = pbBlock ? S_OK : E_OUTOFMEMORY;
    }
   
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileVersionInfo(const_cast<LPTSTR>(pszFileName), 0, dwSize, pbBlock) ? S_OK : GetLastErrorAsHResult();
    }
 
    //
    // VerQueryValue does not set last error.
    // 
    if (SUCCEEDED(hRetval))
    {
        hRetval = VerQueryValue(pbBlock, _T("\\"), reinterpret_cast<VOID **> (&pFileVersion), &uLen) && pFileVersion && uLen ? S_OK : E_INVALIDARG; 
    }
  
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetDriverVersionFromFileVersion(pFileVersion, pdwFileMajorVersion, pdwFileMinorVersion);
    }
     
    delete [] pbBlock;
    return hRetval;
} 

/*++

Routine Name:

    GetDriverVersionFromFileVersion

Routine Description:

    Gets driver info from a FileVersion structure.
    
Arguments:

    pFileVersion                -   Points to a file info structure 
    pdwFileMajorVersion         -   pointer to major version
    pdwFileMinorVersion         -   pointer to minor version
    
Return Value:

    An HRESULT

--*/ 
HRESULT    
GetDriverVersionFromFileVersion(
    IN     VS_FIXEDFILEINFO  *pFileVersion,
       OUT DWORD             *pdwFileMajorVersion,      OPTIONAL
       OUT DWORD             *pdwFileMinorVersion       OPTIONAL
    )
{
    HRESULT  hRetval = E_FAIL;
    
    hRetval = pFileVersion ? S_OK : E_INVALIDARG;
    
    //
    //  Return versions for drivers designed for Windows NT/Windows 2000,
    //  and marked as printer drivers.
    //  Hold for all dlls Pre-Daytona.
    //  After Daytona, printer driver writers must support
    //  version control or we'll dump them as Version 0 drivers.
    //            
    if (SUCCEEDED(hRetval))
    {
        if (pdwFileMajorVersion) 
        {
            *pdwFileMajorVersion = 0;
        }
    
        if (pdwFileMinorVersion) 
        {
            *pdwFileMinorVersion = 0;
        }

        if (VOS_NT_WINDOWS32 == pFileVersion->dwFileOS)
        {
            if ((VFT_DRV == pFileVersion->dwFileType) && (VFT2_DRV_VERSIONED_PRINTER == pFileVersion->dwFileSubtype))
            {
                if (pdwFileMajorVersion)
                {
                    *pdwFileMajorVersion = pFileVersion->dwFileVersionMS;       
                }            
                if (pdwFileMinorVersion)
                {
                    *pdwFileMinorVersion = pFileVersion->dwFileVersionLS;       
                }
            } 
            else if (pdwFileMajorVersion)
            {
                if (pFileVersion->dwProductVersionMS == pFileVersion->dwFileVersionMS) 
                {
                     *pdwFileMajorVersion = 0;
                }
                else
                {
                    *pdwFileMajorVersion = pFileVersion->dwFileVersionMS;
                }
            }
        }
    }
     
    return hRetval;
}

/*++

Routine Name:

    IsDriverBadLocally

Routine Description:

    This routine loads the file and gets the FILETIME of the driver and check 
    whether the driver is blokced or warned according the printupg.inf on the 
    local machine.
    
Arguments:

    pszServer                     - The server that has the driver files
    pDriverInfo6                  - Points to DRINVER_INFO_6 structor
    dwAddDrvFlags                 - Flags used in AddPrinterDriver
    bIsDriverPathFullPath         - Whether the driverpath is a full path
    pdwBlockingStatus             - Points to blocking status of the driver     
    ppszReplacementDriver         - Points to the replacement driver   
    
Return Value:

    An HRESULT                

--*/
HRESULT
IsDriverBadLocally(
    IN     LPCTSTR          pszServer,            OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver
    )
{
    HRESULT  hRetval            = E_FAIL;
    DWORD    dwMajorVersion     = 0;
    FILETIME DriverFileTime;
    TString  strDriverFullPath;
    
    hRetval = pDriverInfo6 && pdwBlockingStatus && ppszReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {            
        hRetval = GetPrinterDriverPath(pszServer,
                                       pDriverInfo6->pDriverPath,
                                       pDriverInfo6->pEnvironment,
                                       bIsDriverPathFullPath,
                                       &strDriverFullPath);
    }
    
    if (SUCCEEDED(hRetval))
    {           
        hRetval = GetFileTimeByName(strDriverFullPath, &DriverFileTime);
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetPrinterDriverVersion(strDriverFullPath, &dwMajorVersion, NULL);
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = PSetupIsCompatibleDriver(NULL, 
                                           pDriverInfo6->pName, 
                                           pDriverInfo6->pDriverPath, 
                                           pDriverInfo6->pEnvironment, 
                                           dwMajorVersion, 
                                           &DriverFileTime, 
                                           pdwBlockingStatus,
                                           ppszReplacementDriver) ? S_OK : GetLastErrorAsHResult();
    }                                          
    
    if (FAILED(hRetval) && ppszReplacementDriver && *ppszReplacementDriver)
    {
        LocalFreeMem(*ppszReplacementDriver);
        *ppszReplacementDriver = NULL;
    }
    
    return hRetval;
}

/*++

Routine Name:

    InternalPrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    pszDriverModel                - The name of the driver to check
    pszDriverPath                 - The path of the driver, this can be a full path 
                                    or the filename
    pszEnvironment                - The environment of the server, such as 
                                    "Windows NT x86"
    dwVersion                     - The major version of the driver
    pdwBlockingStatus             - Points to blocking status on the client
    ppszReplacementDriver         - Points to the name of replacement driver
    
Return Value:

    An HRESULT                    - When this function is successful, user choose 
                                    either proceed to install warned driver or install 
                                    replacement driver. 

--*/
HRESULT
InternalPrintUpgUI(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     DWORD            dwVersion,   
    IN OUT DWORD            *pdwBlockingStatus         
    )
{
    DWORD            hRetval              = E_FAIL;
    HWND             hWndParent           = NULL;
    DWORD            dwStatusResponsed    = BSP_PRINTER_DRIVER_OK;
    
    hRetval  = pszDriverModel && pszDriverPath && pszEnvironment && pdwBlockingStatus ? S_OK : E_INVALIDARG;
        
    if (SUCCEEDED(hRetval) && (BSP_PRINTER_DRIVER_OK != (*pdwBlockingStatus & BSP_BLOCKING_LEVEL_MASK)))
    {      
        *pdwBlockingStatus &= ~BSP_USER_RESPONSE_MASK; 
        hWndParent = SUCCEEDED(GetCurrentThreadLastPopup(&hWndParent)) ? hWndParent : NULL;

        //
        // Ask the user what they want to do. If they don't want to proceed, 
        // then the error is what the would get from the localspl call.
        // 
        // PSetupShowBlockedDriverUI can not fail!
        //
        *pdwBlockingStatus |= (PSetupShowBlockedDriverUI(hWndParent, *pdwBlockingStatus) & BSP_USER_RESPONSE_MASK); 
    } 
        
    return hRetval;
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT
GetCurrentThreadLastPopup(
        OUT HWND    *phwnd
    )
{
    HWND hwndOwner, hwndParent;
    HRESULT hr = E_INVALIDARG;
    GUITHREADINFO ti = {0};

    if( phwnd )
    {
        hr = E_FAIL;
        *phwnd = NULL;

        ti.cbSize = sizeof(ti);
        if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
        {
            *phwnd = ti.hwndActive;
            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}

/*++

Routine Name

    GetPrinterDriverPath
    
Routine Description:

    Get the file full path of the driver.
    
Arguments:
    
    pszServer             - The server that needs to check for bad driver. If
                            pszServer is NULL, that means the local machine
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    bIsDriverpathFullPath - Whether pszDriverPath is the full path or just the
                            the file name of the driver
    pstrFull              - The full path of the driver

Return Value:

    An HRESULT

--*/
HRESULT
GetPrinterDriverPath(
    IN     LPCTSTR          pszServer,                OPTIONAL
    IN     LPCTSTR          pszDriverPath,
    IN     LPCTSTR          pszEnvironment,
    IN     BOOL             bIsDriverPathFullPath,
       OUT TString          *pstrFullPath
    )
{
    HRESULT hRetval         = E_FAIL;
    TCHAR   szDir[MAX_PATH] = {0};
    DWORD   dwNeeded        = 0;
    
    hRetval = pszEnvironment && *pszEnvironment && pszDriverPath && *pszDriverPath && pstrFullPath ? S_OK : E_INVALIDARG;
     
    if (SUCCEEDED(hRetval) && !bIsDriverPathFullPath)
    {      
        hRetval = GetPrinterDriverDirectory(const_cast<LPTSTR>(pszServer), // This API is designed wrongly.
                                            const_cast<LPTSTR>(pszEnvironment),
                                            1,                             // This value must be 1
                                            (LPBYTE)szDir,
                                            sizeof(szDir),
                                            &dwNeeded) ? S_OK : GetLastErrorAsHResult();
    }

    if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval)))
    {
        hRetval = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }
    
    //
    // Add 1 '\\' between driverpath and filename. Note if the path is too
    // long StrNCatBuff will truncate it and StrNCatBuff always NULL terminates
    // the buffer.
    //  
    if (SUCCEEDED(hRetval))
    {
        hRetval = HResultFromWin32(StrNCatBuff(szDir, COUNTOF(szDir), szDir, *szDir ? _T("\\") : _T(""), pszDriverPath, NULL));
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = pstrFullPath->bUpdate(szDir) ? S_OK : E_OUTOFMEMORY;
    }
    
    return hRetval;
}

/*++

Routine Name

    GetFileTimeByName
    
Routine Description:

    Get the file time of the file given a full path.
    
Arguments:
    
    pszPath               - Full path of the driver
    pFileTime             - Points to the file time
    
Return Value:

    An HRESULT

--*/
HRESULT
GetFileTimeByName(
    IN      LPCTSTR         pszPath,
       OUT  FILETIME        *pFileTime
    )
{
    HRESULT     hRetval     = E_FAIL;
    HANDLE      hFile       = INVALID_HANDLE_VALUE;

    hRetval = pszPath && *pszPath && pFileTime ? S_OK : E_INVALIDARG;
             
    if (SUCCEEDED(hRetval))
    {
        hFile = CreateFile(pszPath, 
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        hRetval = (INVALID_HANDLE_VALUE == hFile) ? S_OK : GetLastErrorAsHResult();
    }
    
    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileTime(hFile, NULL, NULL, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }   
    
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }           
    
    return hRetval;
}

/*++

Routine Name

    InternalCompatibleDriverCheck
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver
    is blocked or warned, return the replacement driver.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    pFileTimeDriver       - The FileTime of the driver
    pszPrintUpgInf        - The PrintUpg Inf filename
    uVersion              - The major version of the driver
    bIsServer             - Where the printing services runs on an NT Server SKU
    puBlockingStatus      - Points to status of blocking
    pstrReplacementDriver - The replacement driver.

Return Value:

    An HRESULT

--*/
HRESULT
InternalCompatibleDriverCheck(
    IN     LPCTSTR        pszDriverModel,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     FILETIME       *pFileTimeDriver,
    IN     LPCTSTR        pszPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus,
       OUT TString        *pstrReplacementDriver
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the InternalCompatibleDriverCheck routine\n")));

    HRESULT hRetval = E_FAIL;    
    HINF    hInf    = INVALID_HANDLE_VALUE;
    
    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pFileTimeDriver &&  pszPrintUpgInf && puBlockingStatus && pstrReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval))
    {
        *puBlockingStatus = 0;

        hInf  = SetupOpenInfFile(pszPrintUpgInf, NULL, INF_STYLE_WIN4, NULL);
        hRetval = (INVALID_HANDLE_VALUE == hInf) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = InternalCompatibleInfDriverCheck(pszDriverModel,
                                                   pszDriverPath,
                                                   pszEnvironment,
                                                   pFileTimeDriver,
                                                   hInf,
                                                   uVersion,
                                                   bIsServer,
                                                   puBlockingStatus,
                                                   pstrReplacementDriver);
    }
    
    if (INVALID_HANDLE_VALUE != hInf)
    {
        SetupCloseInfFile(hInf);
    }
    
    return hRetval;
}

/*++

Routine Name

    InternalCompatibleInfDriverCheck
    
Routine Description:

    Check whether the driver is blocked or warned and if the driver
    is blocked or warned, return the replacement driver.
    
Arguments:
    
    pszDriverModel        - The name of the driver to check
    pszDriverPath         - The path of the driver, this can be a full path or 
                            the filename
    pszEnvironment        - The environment of the server, such as 
                            "Windows NT x86"
    pFileTimeDriver       - The FileTime of the driver
    hPrintUpgInf          - The handle to the PrintUpg Inf file
    uVersion              - The major version of the driver
    bIsServer             - Where the printing services runs on an NT Server SKU
    puBlockingStatus      - Points to status of blocking
    pstrReplacementDriver - The replacement driver.

Return Value:

    An HRESULT

--*/
HRESULT
InternalCompatibleInfDriverCheck(
    IN     LPCTSTR        pszModelName,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     FILETIME       *pFileTimeDriver,
    IN     HINF           hPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus,
       OUT TString        *pstrReplacementDriver       OPTIONAL
    )
{
    HRESULT  hRetval           = E_FAIL;    
    HINF     hInf              = INVALID_HANDLE_VALUE;
    UINT     uWarnLevelSrv     = 0;
    UINT     uWarnLevelWks     = 0;
    UINT     uWarnLevel        = 0;
    FILETIME FileTimeOfDriverInInf;

    hRetval = pszModelName && pszDriverPath && pszEnvironment && pFileTimeDriver && (INVALID_HANDLE_VALUE != hPrintUpgInf) && puBlockingStatus && pstrReplacementDriver? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = IsDriverDllInExcludedSection(pszDriverPath, hPrintUpgInf);
    }
    
    if (S_FALSE == hRetval)
    {
        hRetval = IsDriverInMappingSection(pszModelName,
                                           pszEnvironment,
                                           uVersion,
                                           hPrintUpgInf, 
                                           pFileTimeDriver,                                       
                                           &uWarnLevelSrv,
                                           &uWarnLevelWks,
                                           pstrReplacementDriver);

        if (S_OK == hRetval) 
        {
            hRetval = GetBlockingStatusByWksType(uWarnLevelSrv, uWarnLevelWks, bIsServer, puBlockingStatus);
        }
    }

    if (SUCCEEDED(hRetval)) 
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" Driverpath \"%s\" Environment \"%s\" Version %d WarnLevel Server %d WarnLevel Wks %d bIsServer %d *Blocking Status* 0X%X *Replacement Driver* \"%s\"\n"), pszModelName, pszDriverPath, pszEnvironment,uVersion, uWarnLevelSrv, uWarnLevelSrv, bIsServer, *puBlockingStatus, static_cast<LPCTSTR>(*pstrReplacementDriver)));
        hRetval = (BSP_PRINTER_DRIVER_OK == (*puBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) ? S_OK : S_FALSE;
    }

    return hRetval;
}

/*++

Routine Name

    IsDriverInMappingSection
    
Routine Description:

    Check whether the driver is mapped, aka a bad driver.
    
Arguments:
    
    pszDriverModel         - The name of the driver to check
    pszEnvironment         - The environment of the server, such as 
    uVersion               - The major version of the driver
    hPrintUpgInf           - The handle to the PrintUpg Inf file
    pFileTimeDriver        - Points to the file time of the driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver

Return Value:

    An HRESULT            - S_OK means the driver is a bad driver and is mapped to
                            some inbox driver, S_FALSE means the driver is not.

--*/
HRESULT
IsDriverInMappingSection(
    IN     LPCTSTR        pszModelName,
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
    IN     HINF           hPrintUpgInf,
    IN     FILETIME       *pFileTimeDriver,
       OUT UINT           *puWarnLevelSrv,
       OUT UINT           *puWarnLevelWks,
       OUT TString        *pstrReplacementDriver   
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the IsDriverInMappingSection routine\n")));

    HRESULT       hRetval        = E_FAIL;    
    UINT          uWarnLevelSrv  = 0;
    UINT          uWarnLevelWks  = 0;
    INFCONTEXT    InfContext;
    TString       strMappingSection;
    TString       strReplacementDriver;
    
    hRetval = pszModelName && pszEnvironment && (INVALID_HANDLE_VALUE != hPrintUpgInf) && pFileTimeDriver && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *puWarnLevelSrv = 0;
        *puWarnLevelWks = 0;
        hRetval = GetSectionName(pszEnvironment, uVersion, &strMappingSection); 
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf, strMappingSection, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();        
    }
       
    //
    // This code assumes that:
    //  
    //  There can be multiple lines for the same printer driver, but they
    //  are sorted in non-descreasing order by date, the last field of the 
    //  line. The fist line that has the date no older than the driver's
    //  date is used.
    //
    //  An interesting case would be like (since date is optional)
    //
    // "HP LaserJet 4"         = "HP LaserJet 4",       1, 2, "11/28/1999"
    // "HP LaserJet 4"         = "HP LaserJet 4",       2, 1
    //
    //  If a date is empty then the driver of all dates are blocked, hence
    //  an empty date means close to a very late date in the future.
    //
    for (;S_FALSE == hRetval;)
    {
        hRetval = IsDateInLineNoOlderThanDriverDate(&InfContext, pFileTimeDriver, &uWarnLevelSrv, &uWarnLevelWks, &strReplacementDriver);

        if (S_FALSE == hRetval)
        {
            hRetval = SetupFindNextMatchLine(&InfContext, pszModelName, &InfContext) ? S_FALSE : GetLastErrorAsHResult();
        }
    }
    
    //
    // ERROR_LINE_NOT_FOUND is an HRESULT!
    // 
    if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" is not mapped\n"), pszModelName));
        hRetval = S_FALSE;
    }
     
    if (S_OK == hRetval)
    {
        DBG_MSG(DBG_TRACE, (_T("Driver \"%s\" is mapped\n"), pszModelName));
        *puWarnLevelSrv = uWarnLevelSrv;
        *puWarnLevelWks = uWarnLevelWks;
        hRetval = pstrReplacementDriver->bUpdate(strReplacementDriver) ? S_OK : E_OUTOFMEMORY;
    }
    
    return hRetval;
}

/*++

Routine Name

    IsDateInLineNoOlderThanDriverDate
    
Routine Description:

    This routines process the current line of inf and determinate whether the 
    date in the line is not older than that of driver. 
    
Arguments:
    
    pInfContext            - Points to the current context of an INF
    pDriverFileTime        - File time of the actual driver
    pdwWarnLevelSrv        - Points to the warning level for server SKU
    pdwWarnLevelWks        - Points to the warning level for wks SKU
    pstrReplacementDriver  - The replacement driver.
   
Return Value:

    An HRESULT            - S_OK means the date in the current line is no older
                            than that of the driver
--*/
HRESULT
IsDateInLineNoOlderThanDriverDate(
    IN     INFCONTEXT       *pInfContext,
    IN     FILETIME         *pDriverFileTime,
       OUT UINT             *puWarnLevelSrv,
       OUT UINT             *puWarnLevelWks,
       OUT TString          *pstrReplacementDriver
    )
{
    HRESULT  hRetval     = E_FAIL;
    INT      iWarnLevel = 0;
    FILETIME FileTimeInInf;
    
    hRetval = pInfContext && pDriverFileTime && puWarnLevelSrv && puWarnLevelWks && pstrReplacementDriver ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupGetIntField(pInfContext, kWarnLevelSrv, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval)) 
        {
            *puWarnLevelSrv = iWarnLevel;
            hRetval = SetupGetIntField(pInfContext, kWarnLevelWks, &iWarnLevel) ? S_OK: GetLastErrorAsHResult();
        }
        
        if (SUCCEEDED(hRetval)) 
        {
            *puWarnLevelWks = iWarnLevel;
            hRetval = InfGetString(pInfContext, kReplacementDriver, pstrReplacementDriver);
        }

        if (SUCCEEDED(hRetval)) 
        {
            hRetval = InfGetStringAsFileTime(pInfContext, kFileTime, &FileTimeInInf);
        
            //
            //  Date field is optional.
            //
            if (FAILED(hRetval) && (ERROR_INVALID_PARAMETER == HRESULT_CODE(hRetval)))
            {
                DBG_MSG(DBG_TRACE, (_T("Date in inf is empty, drivers of all dates are blocked.\n")));
                hRetval = S_OK;
            } 
            else if (SUCCEEDED(hRetval))
            {
                hRetval = CompareFileTime(pDriverFileTime, &FileTimeInInf) <= 0 ? S_OK : S_FALSE ;
            }
        }
    }
    
    return hRetval;
}

/*++

Routine Name

    GetSectionName
    
Routine Description:

    Get the Section name in terms of environment and driver version.
    
Arguments:
    
    pszEnvironment         - The environment of the server, such as 
    uVersion               - The major version of the driver
    pstrSection            - Points the name of section of driver mapping

Return Value:

    An HRESULT            

--*/
HRESULT
GetSectionName(
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion,
       OUT TString        *pstrSection
    )
{
    HRESULT hRetval = E_FAIL;
    
    hRetval = pszEnvironment && pstrSection ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = pstrSection->bFormat(_T("%s_%s_%s %d"), cszPrintDriverMapping, pszEnvironment, cszVersion, uVersion); 
    }

    return hRetval;
}
 
/*++

Routine Name

    InfGetString
    
Routine Description:

    This routine is a wrapper to SetupGetStringField using TString.
    
Arguments:
    
    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pstrField              - Points to the string field as TString

Return Value:

    An HRESULT            

--*/
HRESULT
InfGetString(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT TString        *pstrField
    )
{
    HRESULT hRetval           = E_FAIL;
    TCHAR   szField[MAX_PATH] = {0};
    DWORD   dwNeeded          = 0;
    TCHAR   *pszField         = NULL;
    
    hRetval = pInfContext && pstrField ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SetupGetStringField(pInfContext,
                                      uFieldIndex,
                                      szField,
                                      COUNTOF(szField),
                                      &dwNeeded) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval)) 
        {
            hRetval = pstrField->bUpdate(szField) ? S_OK : E_OUTOFMEMORY;
        } 
        else if (FAILED(hRetval) && (ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval))) 
        {
            pszField = new TCHAR[dwNeeded];
            hRetval = pszField ? S_OK : E_OUTOFMEMORY;
            
            DBG_MSG(DBG_TRACE, (_T("Long string encountered\n")));

            if (SUCCEEDED(hRetval)) 
            {
                hRetval = SetupGetStringField(pInfContext,
                                              uFieldIndex,
                                              pszField,
                                              dwNeeded,
                                              &dwNeeded) ? S_OK : GetLastErrorAsHResult();
            }
        
            if (SUCCEEDED(hRetval)) 
            {
                hRetval = pstrField->bUpdate(pszField) ? S_OK : E_OUTOFMEMORY;
            }
        }
    }
    
    delete [] pszField;
    return hRetval;
}

/*++

Routine Name

    InfGetStringAsFileTime
    
Routine Description:

    This routine get the time of driver in printupg and converts it to FILETIME.
    
Arguments:
    
    pInfContext            - The context of the inf
    uFieldIndex            - The field index of the string to retrieve
    pFielTime              - Points to the FILETIME structure

Return Value:

    An HRESULT            

--*/
HRESULT
InfGetStringAsFileTime(
    IN     INFCONTEXT     *pInfContext,
    IN     UINT           uFieldIndex,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT hRetval = E_FAIL;
    TString strDate;

    hRetval = pInfContext && pFileTime ? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = InfGetString(pInfContext, uFieldIndex, &strDate);
    }

    if (SUCCEEDED(hRetval)) 
    {
        DBG_MSG(DBG_TRACE, (_T("FileTime in INF as string \"%s\"\n"), static_cast<LPCTSTR>(strDate)));
        hRetval = StringTimeToFileTime(strDate, pFileTime);
    }
  
    return hRetval;
}

/*++

Routine Name

    StringTimeToFileTime
    
Routine Description:

    Converts a string of time in the form of "11/27/1999" to FILETIME.
    
Arguments:
 
    pszFileTime            - The file time as string such as "11/27/1999"
    pFileTime              - Points to the converted FILETIME

Return Value:

    An HRESULT            

--*/
HRESULT
StringTimeToFileTime(
    IN     LPCTSTR        pszFileTime,
       OUT FILETIME       *pFileTime
    )
{
    HRESULT    hRetval = E_FAIL;
    SYSTEMTIME SystemTime;

    hRetval = pszFileTime && pFileTime ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        //
        // StringToDate should take pszFileTime as const.
        //
        hRetval = StringToDate(const_cast<LPTSTR>(pszFileTime), &SystemTime) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SystemTimeToFileTime(&SystemTime, pFileTime) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}

/*++

Routine Name

    GetBlockingStatusByWksType
    
Routine Description:

    Fill out the status of blocking according to the type of SKU that runs the
    service.
    
Arguments:
 
    uWarnLevelSrv          - The warn level for server SKU
    uWarnLevelSrv          - The warn level for wks SKU
    bIsServer              - Whether the SKU running printing service is server
    puBlockingStatus       - Points to the result as status of blocking

Return Value:

    An HRESULT            

--*/
HRESULT
GetBlockingStatusByWksType(
    IN     UINT           uWarnLevelSrv,
    IN     UINT           uWarnLevelWks,
    IN     BOOL           bIsServer,
       OUT UINT           *puBlockingStatus
    ) 
{
    HRESULT hRetval    = E_FAIL;
    UINT    uWarnLevel = 0;

    hRetval = puBlockingStatus ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *puBlockingStatus &= ~BSP_BLOCKING_LEVEL_MASK;
        *puBlockingStatus |= BSP_PRINTER_DRIVER_OK;

        uWarnLevel = bIsServer ? uWarnLevelSrv : uWarnLevelWks;

        switch (uWarnLevel)
        {
        case kBlocked:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_BLOCKED;
            break;
        case kWarned:
            *puBlockingStatus |= BSP_PRINTER_DRIVER_WARNED;
            break;
            
        default: 
            hRetval = E_FAIL;
            break;
        }
    }

    return hRetval;
}

/*++

Routine Name

    IsDriverDllInExcludedSection
    
Routine Description:

    Determine Whether the driver dll name is in the excluded section of printupg.
    
Arguments:

     pszDriverPath       - The path of the driver and this can be a full path or
                           the file name
     hPrintUpgInf        - The handle to printupg INF file

Return Value:

    An HRESULT           - S_OK means the driver dll is in the excluded section,
                           S_FALSE means it is not. 

--*/
HRESULT
IsDriverDllInExcludedSection(
    IN     LPCTSTR        pszDriverPath,
    IN     HINF           hPrintUpgInf
    )
{
    DBG_MSG(DBG_TRACE, (_T("In the IsDriverDllInExcludedSection routine\n")));

    HRESULT    hRetval = E_FAIL;
    TString    strDriverFileName;
    INFCONTEXT InfContext;

    hRetval = pszDriverPath && (INVALID_HANDLE_VALUE != hPrintUpgInf) ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = strDriverFileName.bUpdate(FileNamePart(pszDriverPath)) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval) && !strDriverFileName.bEmpty()) 
    {
        hRetval = SetupFindFirstLine(hPrintUpgInf, 
                                     cszExcludeSection, 
                                     strDriverFileName,
                                     &InfContext) ? S_OK : GetLastErrorAsHResult();

        //
        // ERROR_LINE_NOT_FOUND is an HRESULT!
        // 
        if (FAILED(hRetval) && (HRESULT_CODE(ERROR_LINE_NOT_FOUND) == HRESULT_CODE(hRetval)))
        {
            hRetval = S_FALSE;
        }

        DBG_MSG(DBG_TRACE, (_T("Driver Path %s driver dll %s excluded section \"%s\" Is not excluded? %d\n"), pszDriverPath, static_cast<LPCTSTR>(strDriverFileName), cszExcludeSection, hRetval));
    }
    
    return hRetval;
}

/*++

Routine Name

    IsEnvironmentAndVersionNeededToCheck
    
Routine Description:

    This routine looks up a table of environment and version to see whether it
    is necessary to check for blocked/warned driver.
    
Arguments:

     pszEnvironment      - The environment where the driver runs
     uVersion            - The major version of the driver.

Return Value:

    An HRESULT           

--*/
HRESULT
IsEnvironmentAndVersionNeededToCheck(
    IN     LPCTSTR        pszEnvironment,
    IN     UINT           uVersion
    )
{
    HRESULT hRetval = E_FAIL;

    static struct TPrintUPGCheckListItem 
    {
        LPCTSTR pszEnvironment;
        UINT    uVersion;
    } aPrintUpgCheckList[] = {
        {X86_ENVIRONMENT,  2},
        {X86_ENVIRONMENT,  3},
        {IA64_ENVIRONMENT, 3},
    };

    hRetval = pszEnvironment ? S_FALSE : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        for (UINT i = 0; i < COUNTOF(aPrintUpgCheckList); i++)
        {
            if (!lstrcmpi(aPrintUpgCheckList[i].pszEnvironment, pszEnvironment) && (aPrintUpgCheckList[i].uVersion == uVersion))
            {
                hRetval = S_OK;
                break;
            }
        }
    }

    return hRetval;
}

/*++

Routine Name

    IsLocalMachineServer
    
Routine Description:

    This routine determines whether the local machine is a server SKU.
    
Arguments:

     None

Return Value:

    An HRESULT            - S_OK if it is a server, S_FALSE otherwise.          

--*/
HRESULT
IsLocalMachineServer(
    VOID
    )
{
    HRESULT         hRetval          = E_FAIL;
    DWORDLONG       dwlConditionMask = 0;
    OSVERSIONINFOEX OsVerEx;
    
    (VOID)ZeroMemory(&OsVerEx, sizeof(OSVERSIONINFOEX));
    OsVerEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    
    OsVerEx.wProductType = VER_NT_SERVER;
    VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );

    hRetval = VerifyVersionInfo(&OsVerEx, VER_PRODUCT_TYPE, dwlConditionMask) ? S_OK : GetLastErrorAsHResult();
   
    if (FAILED(hRetval) && (ERROR_OLD_WIN_VERSION == HRESULT_CODE(hRetval)))
    {
       hRetval = S_FALSE;
    }
    
    return hRetval;
}

#if DBG_PRINTUPG

LPTSTR
ReadDigit(
    LPTSTR  ptr,
    LPWORD  pW
    )
{
    TCHAR   c;
    //
    // Skip spaces
    //
    while ( !iswdigit(c = *ptr) && c != TEXT('\0') )
        ++ptr;

    if ( c == TEXT('\0') )
        return NULL;

    //
    // Read field
    //
    for ( *pW = 0 ; iswdigit(c = *ptr) ; ++ptr )
        *pW = *pW * 10 + c - TEXT('0');

    return ptr;
}

BOOL
StringToDate(
    LPTSTR          pszDate,
    SYSTEMTIME     *pInfTime
    )
{
    BOOL    bRet = FALSE;

    ZeroMemory(pInfTime, sizeof(*pInfTime));

    bRet = (pszDate = ReadDigit(pszDate, &(pInfTime->wMonth)))      &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wDay)))        &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wYear)));

    //
    // Y2K compatible check
    //
    if ( bRet && pInfTime->wYear < 100 ) {

        if ( pInfTime->wYear < 10 )
            pInfTime->wYear += 2000;
        else
            pInfTime->wYear += 1900;
    }

    return bRet;
}


LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    )
{
    LPTSTR pszSlash, pszTemp;

    if ( !pszFullName )
        return NULL;

    //
    // First find the : for the drive
    //
    if ( pszTemp = lstrchr(pszFullName, TEXT(':')) )
        pszFullName = pszFullName + 1;

    for ( pszTemp = (LPTSTR)pszFullName ;
          pszSlash = lstrchr(pszTemp, TEXT('\\')) ;
          pszTemp = pszSlash + 1 )
    ;

    return *pszTemp ? pszTemp : NULL;

}

PVOID
LocalAllocMem(
    IN UINT cbSize
    )
{
    return LocalAlloc( LPTR, cbSize );
}

VOID
LocalFreeMem(
    IN PVOID p
    )
{
    LocalFree(p);
}

/*++

Routine Description:
    Allocate memory and make a copy of a string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
LPTSTR
AllocStr(
    IN LPCTSTR              pszStr
    )
{
    LPTSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = reinterpret_cast<LPTSTR>(LocalAllocMem((lstrlen(pszStr) + 1) * sizeof(*pszRet)));
        if ( pszRet )
            lstrcpy(pszRet, pszStr);
    }

    return pszRet;
}

//
// For some reason these are needed by spllib when you use StrNCatBuf.
// This doesn't make any sense, but just implement them.
//
extern "C"
LPVOID
DllAllocSplMem(
    DWORD cbSize
)
{
    return LocalAllocMem(cbSize);
}

HRESULT
TestPrintUpgOne(
    IN     LPCTSTR        pszDriverModel,
    IN     LPCTSTR        pszDriverPath,
    IN     LPCTSTR        pszEnvironment,
    IN     LPCTSTR        pszDriverTime,
    IN     LPCTSTR        pszPrintUpgInf,
    IN     UINT           uVersion,
    IN     BOOL           bIsServer,
    IN     UINT           uBlockingStatusInput,
    IN     LPCTSTR        pszReplacementDriver,
    IN     BOOL           bSuccess
    )
{
    HRESULT  hRetval         = E_FAIL;
    UINT     uBlockingStatus = 0;
    TString  strReplacementDriver;
    FILETIME FileTimeDriver;

    hRetval = pszDriverModel && pszDriverPath && pszEnvironment && pszDriverTime && pszPrintUpgInf &&  pszReplacementDriver ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = StringTimeToFileTime(pszDriverTime, &FileTimeDriver);
    }

    //if (SUCCEEDED(hRetval)) 
    //{
    //    hRetval = IsEnvironmentAndVersionNeededToCheck(pszEnvironment, uVersion);
    //}

    //if (S_OK == hRetval) 
    if (SUCCEEDED(hRetval))
    {
        DBG_MSG(DBG_TRACE, (_T("TEST case: Driver of time %s Expected status %d Expected Replacement \"%s\"\n"), pszDriverTime, uBlockingStatusInput, pszReplacementDriver));

        hRetval = InternalCompatibleDriverCheck(pszDriverModel,
                                                pszDriverPath,
                                                pszEnvironment,
                                                &FileTimeDriver,
                                                pszPrintUpgInf,
                                                uVersion,
                                                bIsServer,
                                                &uBlockingStatus,
                                                &strReplacementDriver);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = ((uBlockingStatusInput & BSP_BLOCKING_LEVEL_MASK) == (uBlockingStatus & BSP_BLOCKING_LEVEL_MASK)) ? S_OK : S_FALSE;
    }

    if ((S_OK == hRetval) && (BSP_PRINTER_DRIVER_OK != (uBlockingStatus & BSP_BLOCKING_LEVEL_MASK))) 
    {
        hRetval = !lstrcmp(pszReplacementDriver, strReplacementDriver) ? S_OK : S_FALSE;
        
        //
        //  we can not test whether BSP_INBOX_DRIVER_AVAILABLE is set
        //
        //if((S_OK == hRetval) && pszReplacemtDriver && *ppszReplacementDriver)
        //{
        //    hRetval = (BSP_INBOX_DRIVER_AVAILABLE & uBlockingStatus) ? S_OK : S_FALSE; 
        //}
    }

    if (SUCCEEDED(hRetval))
    {   
        hRetval = (((S_FALSE == hRetval) && !bSuccess) || (S_OK == hRetval) && bSuccess) ? S_OK : E_FAIL;
    }
 
    return hRetval;
}

TCHAR szModel1[] = _T("HP LaserJet 4");
TCHAR szModel2[] = _T("HP LaserJet 4P");
TCHAR szModel3[] = _T("");
TCHAR szModel4[] = _T("HP LaserJet 4M Plus");
TCHAR szModel5[] = _T("HP LaserJet 4Si");
TCHAR szModel6[] = _T("HP LaserJet 4PPP");
TCHAR szModel7[] = _T("Lexmark Optra T612");
TCHAR szModel8[] = _T("HP LaserJet 4V");
TCHAR szModel9[] = _T("Apple LaserJet 400PS");
TCHAR szModel0[] = _T("HP Laserjet 4Si mx");

TCHAR szDriverPath1[] = _T("H:\\WINDOWS\\system32\\spool\\drivers\\w32x86\\3\\ps5ui.dll");
TCHAR szDriverPath2[] = _T("pscript5.dll");
TCHAR szDriverPath3[] = _T("H:\\WINDOWS\\system32\\spool\\drivers\\w32x86\\3\\ps5ui.dll");
TCHAR szDriverPath4[] = _T("psCrIpt5.dll");
TCHAR szDriverPath5[] = _T("ps5ui.dll");

TCHAR szEnvironment1[] = _T("Windows NT x86");
TCHAR szEnvironment2[] = _T("Windows 4.0");
TCHAR szEnvironment3[] = _T("Windows IA64");
TCHAR szEnvironment4[] = _T("Windows XP");

TCHAR szDriverTime1[] = _T("11/27/1999");
TCHAR szDriverTime2[] = _T("11/27/2999");
TCHAR szDriverTime3[] = _T("11/27/2001");
TCHAR szDriverTime4[] = _T("10/27/1999");
TCHAR szDriverTime5[] = _T("11/28/1998");
TCHAR szDriverTime6[] = _T("11/28/1999");
TCHAR szDriverTime7[] = _T("10/28/1999");

DWORD dwStatus1 = BSP_PRINTER_DRIVER_OK;
DWORD dwStatus2 = BSP_PRINTER_DRIVER_WARNED;
DWORD dwStatus3 = BSP_PRINTER_DRIVER_BLOCKED;

TCHAR cszUpgradeInf[] = _T("printupg.inf");
TCHAR cszPrintDriverMapping[] = _T("Printer Driver Mapping");
TCHAR cszVersion[] = _T("Version");
TCHAR cszExcludeSection[] = _T("Excluded Driver Files");
TCHAR cszPrintUpgInf[] = _T("\\\\lzhu0\\zdrive\\sdroot\\printscan\\print\\spooler\\test\\printupg\\printupg.inf");

HRESULT
TestPrintUpgAll(
    VOID
    )
{
    HRESULT hRetval = S_OK;

    const struct PrintUpgTest aPrintUpgTests [] =
    {
        //
        // model    driverPath     environment   drivertime    ver isServer status   replacement isSuccess
        //
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime4, 2, TRUE,  dwStatus2, szModel1, TRUE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel1, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel1, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus1, szModel1, TRUE},

        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel6, TRUE}, 
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel6, TRUE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel6, TRUE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel1, TRUE},

        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel1, FALSE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel1, FALSE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel1, FALSE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus3, szModel1, FALSE},

        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel1, FALSE}, 
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel6, FALSE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus1, szModel6, FALSE},
        {szModel2, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel1, FALSE},

        //
        // case 16 is next
        //
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel3, TRUE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus1, szModel3, TRUE},

        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel3, TRUE}, 
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel3, TRUE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus1, szModel3, TRUE},

        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus3, szModel7, FALSE}, 
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel7, FALSE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus2, szModel7, FALSE},
        {szModel7, szDriverPath1, szEnvironment1, szDriverTime2, 2, TRUE,  dwStatus3, szModel7, FALSE},

        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel7, FALSE}, 
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime2, 2, FALSE, dwStatus3, szModel8, FALSE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus1, szModel8, FALSE},
        {szModel8, szDriverPath1, szEnvironment1, szDriverTime1, 2, FALSE, dwStatus2, szModel7, FALSE},

        //
        // case 32 is next
        // 
        {szModel4, szDriverPath2, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel4, FALSE},
        {szModel4, szDriverPath5, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus3, szModel4, FALSE},
        {szModel4, szDriverPath5, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath4, szEnvironment1, szDriverTime1, 2, TRUE,  dwStatus1, szModel7, TRUE},

        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus3, szModel4, TRUE}, 
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus2, szModel4, TRUE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel4, TRUE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus1, szModel4, TRUE},

        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus3, szModel4, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus2, szModel4, FALSE},
        {szModel4, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus3, szModel4, FALSE},

        {szModel0, szDriverPath1, szEnvironment1, szDriverTime1, 3, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime1, 3, FALSE, dwStatus2, szModel3, TRUE},
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel0, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus1, szModel3, TRUE},

        //
        // case 48 is next
        //
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus2, szModel8, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel2, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus1, szModel8, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus1, szModel8, TRUE},

        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel8, FALSE}, 
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus3, szModel8, FALSE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus2, szModel8, FALSE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus3, szModel8, FALSE},

        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 3, TRUE,  dwStatus3, szModel3, TRUE}, 
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel3, TRUE},
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus1, szModel3, TRUE},

        {szModel5, szDriverPath1, szEnvironment2, szDriverTime1, 3, TRUE,  dwStatus1, szModel3, TRUE}, 
        {szModel5, szDriverPath1, szEnvironment3, szDriverTime1, 1, FALSE, dwStatus2, szModel3, FALSE},
        {szModel9, szDriverPath1, szEnvironment1, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        {szModel9, szDriverPath1, szEnvironment1, szDriverTime2, 3, TRUE,  dwStatus2, szModel3, FALSE},

        //
        // case 64 is next
        //
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 2, TRUE,  dwStatus3, szModel8, TRUE},
        {szModel4, szDriverPath1, szEnvironment3, szDriverTime1, 3, FALSE, dwStatus2, szModel2, TRUE},
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime5, 2, TRUE,  dwStatus3, szModel1, TRUE}, 
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime6, 2, TRUE,  dwStatus2, szModel1, TRUE}, 
        
        {szModel1, szDriverPath1, szEnvironment1, szDriverTime7, 2, TRUE,  dwStatus2, szModel1, TRUE},
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 3, TRUE,  dwStatus2, szModel3, TRUE},  
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 3, FALSE, dwStatus3, szModel3, TRUE}, 
        {szModel2, szDriverPath1, szEnvironment4, szDriverTime2, 3, FALSE, dwStatus1, szModel3, TRUE},
        
        {szModel2, szDriverPath1, szEnvironment3, szDriverTime2, 4, FALSE, dwStatus1, szModel3, TRUE},
    };

    DBG_MSG(DBG_TRACE, (L"tests started\n"));

    for (int i = 0; SUCCEEDED(hRetval) && i < COUNTOF(aPrintUpgTests); i++)
    {
        DBG_MSG(DBG_TRACE, (_T("************************ %d **********************\n"), i));
        hRetval = TestPrintUpgOne(aPrintUpgTests[i].pszDriverModel,
                                  aPrintUpgTests[i].pszDriverPath,
                                  aPrintUpgTests[i].pszEnvironment,
                                  aPrintUpgTests[i].pszDriverTime,
                                  cszPrintUpgInf,
                                  aPrintUpgTests[i].uVersion,
                                  aPrintUpgTests[i].bIsServer,
                                  aPrintUpgTests[i].uBlockingStatus,
                                  aPrintUpgTests[i].pszReplacementDriver,
                                  aPrintUpgTests[i].bSuccess);
    }

    DBG_MSG(DBG_TRACE, (L"tests ended\n"));

    return hRetval;
}

#endif // DBG_PRINTUPG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\ntprint.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Ntprint.c

Abstract:

    Ntprint.dll main functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"
#include "splcom.h"
#include "regstr.h"

HINSTANCE   ghInst;
DWORD       dwThisMajorVersion  =   3;

PCODEDOWNLOADINFO   gpCodeDownLoadInfo = NULL;

HANDLE      hPrintui = NULL;
DWORD       (*dwfnPnPInterface)(
                IN EPnPFunctionCode Function,
                IN TParameterBlock  *pParameterBlock
                )   = NULL;

TCHAR   cszMicrosoft[]                  = TEXT("Microsoft");
TCHAR   cszPrinter[]                    = TEXT("Printer");
TCHAR   cszPortName[]                   = TEXT("PortName");
TCHAR   cszPnPKey[]                     = TEXT("PnPData");
TCHAR   cszDeviceInstanceId[]           = TEXT("DeviceInstanceId");
TCHAR   cszHardwareID[]                 = TEXT("HardwareID");
TCHAR   cszManufacturer[]               = TEXT("Manufacturer");
TCHAR   cszOEMUrl[]                     = TEXT("OEM URL");
TCHAR   cszProcessAlways[]              = TEXT(".ProcessPerPnpInstance");
TCHAR   cszRunDll32[]                   = TEXT("rundll32.exe");
TCHAR   cszBestDriverInbox[]            = TEXT("InstallInboxDriver");

const   DWORD dwFourMinutes             = 240000;

OSVERSIONINFO       OsVersionInfo;
LCID                lcid;

#define MAX_PRINTER_NAME    MAX_PATH

MODULE_DEBUG_INIT(DBG_WARN|DBG_ERROR, DBG_ERROR);

BOOL 
DllMain(
    IN HINSTANCE  hInst,
    IN DWORD      dwReason,
    IN LPVOID     lpRes   
    )
/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:

            ghInst              = hInst;

            if( !bSplLibInit(NULL))
            {
                DBGMSG( DBG_WARN,
                      ( "DllEntryPoint: Failed to init SplLib %d\n", GetLastError( )));

                return FALSE;
            }

            DisableThreadLibraryCalls(hInst);
            OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

            if ( !GetVersionEx(&OsVersionInfo) )
                return FALSE;
            lcid = GetUserDefaultLCID();

            InitializeCriticalSection(&CDMCritSect);
            InitializeCriticalSection(&SkipCritSect);

            if(IsInWow64())
            {
                //
                // 32-bit code running on Win64 -> set platform appropriately
                //
                MyPlatform = PlatformIA64;
            }

            break;

        case DLL_PROCESS_DETACH:
            if ( hPrintui )
                FreeLibrary(hPrintui);

            DeleteCriticalSection(&CDMCritSect);
            // Cleanup and CDM Context  created by windows update.
            DestroyCodedownload( gpCodeDownLoadInfo );
            gpCodeDownLoadInfo = NULL;

            CleanupSkipDir();
            vSplLibFree();
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL
LoadAndInitializePrintui(
    VOID
    )
/*++

Routine Description:
    Check the refcount on printui, load it on 0 and increment the refcount.

Arguments:
    None

Return Value:
    TRUE on success, FALSE on error

--*/
{
    LPTSTR   szDll =
#ifdef  UNICODE
        TEXT("printui.dll");
#else
        TEXT("printuia.dll");
#endif

    if ( hPrintui ) {

        return TRUE;
    }

    if ( hPrintui = LoadLibraryUsingFullPath(szDll) ) {

        if ( (FARPROC)dwfnPnPInterface = GetProcAddress(hPrintui,
                                                        "PnPInterface") ) {

            return TRUE;
        } else {

            FreeLibrary(hPrintui);
            hPrintui = NULL;
        }
    }

    return FALSE;
}

BOOL
PSetupAssociateICMProfiles(
    IN  LPCTSTR     pszzICMFiles,
    IN  LPCTSTR     pszPrinterName
    )
/*++

Routine Description:
    Install ICM color profiles for a printer driver and associate it with
    the printer name given

Arguments:
    pszzICMFiles    : Multi-sz field giving ICM profile names
    pszPrinterName  : Printer name

Return Value:
    None

--*/
{
    TCHAR   szDir[MAX_PATH], *p;
    DWORD   dwSize, dwNeeded;

    dwSize      = SIZECHARS(szDir);
    dwNeeded    = sizeof(szDir);

    if ( !GetColorDirectory(NULL, szDir, &dwNeeded) )
        return FALSE;

    dwNeeded           /= sizeof(TCHAR);
    szDir[dwNeeded-1]   = TEXT('\\');

    //
    // Install and assoicate each profiles from the multi-sz field
    //
    for ( p = (LPTSTR)pszzICMFiles; *p ; p += lstrlen(p) + 1 ) {

        if ( dwNeeded + lstrlen(p) + 1 > dwSize ) {

            ASSERT(dwNeeded + lstrlen(p) + 1 <= dwSize);
            continue;
        }

        lstrcpy(szDir + dwNeeded, p);
        //
        // We do not need the right server name here since ICM should send it
        // to the right server
        //
        if ( !AssociateColorProfileWithDevice(NULL, szDir, pszPrinterName) )
            return FALSE;
    }

    return TRUE;
}


DWORD
GetPlugAndPlayInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
/*++

Routine Description:
    Get necessary PnP info LPT enumerator would have setup in the config
    manager registry

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer
    pLocalData      : Gives installation data

Return Value:
    TRUE on success, FALSE else.

--*/
{
    HKEY        hKey = NULL;
    TCHAR       buf[MAX_PATH];
    DWORD       dwType, dwSize, dwReturn;
    PNP_INFO    PnPInfo;

    ASSERT( !(pLocalData->Flags & VALID_PNP_INFO) );

    ZeroMemory(&PnPInfo, sizeof(PnPInfo));

    //
    // Look in the devnode for the printer created to get the port name and
    // the device instance id
    //
    if ( dwReturn = CM_Open_DevNode_Key(pDevInfoData->DevInst, KEY_READ, 0,
                                        RegDisposition_OpenExisting, &hKey,
                                        CM_REGISTRY_HARDWARE) )
        goto Cleanup;

    dwSize = sizeof(buf);

    if ( dwReturn = RegQueryValueEx(hKey, cszPortName, NULL, &dwType,
                                    (LPBYTE)&buf, &dwSize) ) {

        if ( dwReturn == ERROR_FILE_NOT_FOUND )
            dwReturn = ERROR_UNKNOWN_PORT;
        goto Cleanup;
    }

    if ( !(PnPInfo.pszPortName = AllocStr(buf)) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

    //
    // This can't be bigger than MAX_DEVICE_ID_LEN so it is ok
    //
    if ( !SetupDiGetDeviceInstanceId(hDevInfo,
                                     pDevInfoData,
                                     buf,
                                     SIZECHARS(buf),
                                     NULL) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

    if ( !(PnPInfo.pszDeviceInstanceId =  AllocStr(buf)) ) {

        dwReturn = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if ( dwReturn == ERROR_SUCCESS ) {

        CopyMemory(&pLocalData->PnPInfo, &PnPInfo, sizeof(PnPInfo));
        pLocalData->Flags   |= VALID_PNP_INFO;
    } else {

        FreeStructurePointers((LPBYTE)&PnPInfo, PnPInfoOffsets, FALSE);
    }

    if ( hKey )
        RegCloseKey(hKey);

    return dwReturn;
}


BOOL
PrinterGoingToPort(
    IN  LPPRINTER_INFO_2    pPrinterInfo2,
    IN  LPCTSTR             pszPortName
    )
/*++

Routine Description:
    Find out if a printer is going to a port (it may go to other ports also)

Arguments:
    pPrinterInfo2   : Gives the PRINTER_INFO_2 for the print queue
    pszPortName     : The port name

Return Value:
    If the print queue is going to the port TRUE, else FALSE

--*/
{
    LPTSTR  pszStr1 = pPrinterInfo2->pPortName, pszStr2;

    //
    // Port names are returned comma separated by spooler; and there are blanks
    //
    while ( pszStr2 = lstrchr(pszStr1, sComma) ) {

        *pszStr2 = sZero;
        ++pszStr2;

        if ( !lstrcmpi(pszPortName, pszStr1) )
            return TRUE;
        pszStr1 = pszStr2;

        //
        // Skip spaces
        //
        while ( *pszStr1 == TEXT(' ') )
            ++pszStr1;
    }

    if ( !lstrcmpi(pszPortName, pszStr1) )
        return TRUE;

    return FALSE;
}


BOOL
SetPnPInfoForPrinter(
    IN  HANDLE      hPrinter,
    IN  LPCTSTR     pszDeviceInstanceId,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszOEMUrl
    )
/*++

Routine Description:
    Set registry values in the PnPInfo subkey

Arguments:
    hPrinter            : Printer handle
    pszDeviceInstanceId : DeviceInstance Id
    pszHardwareID       : Device PnP or Compat Id
    pszManufacturer     : Manufacturer (from the inf)
    pszOEMUrl           : Manufacturer URL (from the inf)

Return Value:
    TRUE on success, FALSE else.

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;

    if ( pszDeviceInstanceId && *pszDeviceInstanceId)
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszDeviceInstanceId,
                                       REG_SZ,
                                       (LPBYTE)pszDeviceInstanceId,
                                       (lstrlen(pszDeviceInstanceId) + 1)
                                                * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszHardwareID && *pszHardwareID )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszHardwareID,
                                       REG_SZ,
                                       (LPBYTE)pszHardwareID,
                                       (lstrlen(pszHardwareID) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszManufacturer && *pszManufacturer )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszManufacturer,
                                       REG_SZ,
                                       (LPBYTE)pszManufacturer,
                                       (lstrlen(pszManufacturer) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError == ERROR_SUCCESS && pszOEMUrl && *pszOEMUrl )
        dwLastError = SetPrinterDataEx(hPrinter,
                                       cszPnPKey,
                                       cszOEMUrl,
                                       REG_SZ,
                                       (LPBYTE)pszOEMUrl,
                                       (lstrlen(pszOEMUrl) + 1)
                                            * sizeof(TCHAR));

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


BOOL
PrinterInfo2s(
    OUT LPPRINTER_INFO_2   *ppPI2,
    OUT LPDWORD             pdwReturned
    )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_2s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPI2       : Points to PRINTER_INFO_2s on return
    pdwReturned : Tells how many PRINTER_INFO_2s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL    bRet = FALSE;
    DWORD   dwNeeded = 0x1000;
    LPBYTE  pBuf;

    if ( !(pBuf = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       pdwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            goto Cleanup;

        LocalFreeMem(pBuf);
        if ( !(pBuf = LocalAllocMem(dwNeeded))   ||
             !EnumPrinters(PRINTER_ENUM_LOCAL,
                           NULL,
                           2,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           pdwReturned) ) {

            goto Cleanup;
        }
   }

   bRet = TRUE;

Cleanup:

    if ( bRet ) {

        *ppPI2 = (LPPRINTER_INFO_2)pBuf;
    } else {

        if ( pBuf )
            LocalFreeMem(pBuf);

        *ppPI2 = NULL;
        *pdwReturned = 0;
        }

    return bRet;
}


BOOL
DuplicateDevice(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
/*++

Routine Description:
    Find out if a PnP reported printer is already installed

Arguments:
    pLocalData  : Gives installation data

Return Value:
    If the printer is already install TRUE, else FALSE

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    LPPRINTER_INFO_2    p = NULL, pPrinterInfo2;
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded;
    HANDLE              hPrinter;
    LPTSTR              pszDriverName = pLocalData->DrvInfo.pszModelName,
                        pszPortName = pLocalData->PnPInfo.pszPortName;

    ASSERT( (pLocalData->Flags & VALID_PNP_INFO)    &&
            (pLocalData->Flags & VALID_INF_INFO) );

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Cleanup;

    //
    // If there is a local printer using the same driver and going to the
    // same port then it is a duplicate
    //
    for ( dwNeeded = 0, pPrinterInfo2 = p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, pPrinterInfo2++ ) {

        if ( !lstrcmpi(pszDriverName, pPrinterInfo2->pDriverName) &&
             PrinterGoingToPort(pPrinterInfo2, pszPortName) )
            break; // for loop
    }

    if ( dwNeeded == dwReturned )
        goto Cleanup;

    bReturn = TRUE;

    if ( bReturn ) {

        if ( OpenPrinter(pPrinterInfo2->pPrinterName,
                         &hPrinter,
                         &PrinterDefault) ) {

            //
            // If it fails can't help
            //
            (VOID)SetPnPInfoForPrinter(hPrinter,
                                       pLocalData->PnPInfo.pszDeviceInstanceId,
                                       pLocalData->DrvInfo.pszHardwareID,
                                       pLocalData->DrvInfo.pszManufacturer,
                                       pLocalData->DrvInfo.pszOEMUrl);

            ClosePrinter(hPrinter);
        }
    }

Cleanup:
    LocalFreeMem(p);

    return bReturn;
}


BOOL
PrinterPnPDataSame(
    IN LPTSTR pszDeviceInstanceId,
    IN LPTSTR pszPrinterName
)
/*

Routine Description:
    Find out if a PnP printer has been installed with different driver name.
    We need to associate the queue previously used with this new driver as
    pnp says it's the new best driver for the device.

Arguments:
    pszDeviceInstanceId  : Gives the device ID instance string of the pnped device.
    pszPrinterName       : The name of the printer to compare the device instance ID to.

Return Value:
    If printer's pnp data holds the same device instance ID as the passed ID returns TRUE, else FALSE.

*/
{
    BOOL              bRet           = FALSE;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    HANDLE            hPrinter;
    DWORD             dwNeeded;
    TCHAR             szPrnId[MAX_DEVICE_ID_LEN];

    if( pszPrinterName && pszDeviceInstanceId ) {

        if ( OpenPrinter(pszPrinterName,
                         &hPrinter,
                         &PrinterDefault) ) {

            if ( ERROR_SUCCESS == GetPrinterDataEx(hPrinter,
                                                   cszPnPKey,
                                                   cszDeviceInstanceId,
                                                   &dwNeeded,
                                                   (LPBYTE)szPrnId,
                                                   sizeof(szPrnId),
                                                   &dwNeeded)           &&
                 !lstrcmp(szPrnId, pszDeviceInstanceId) ) {

                bRet = TRUE;
            }

            ClosePrinter(hPrinter);
        }
    }

    return bRet;
}


BOOL
NewDriverForInstalledDevice(
    IN     PPSETUP_LOCAL_DATA  pLocalData,
    OUT    LPTSTR              pszPrinterName
    )
/*++

Routine Description:
    Find out if a PnP printer has been installed with different driver name.
    We need to associate the queue previously used with this new driver as
    pnp says it's the new best driver for the device.

Arguments:
    pLocalData     : Gives installation data
    pszPrinterName : Gives the printer name to return and use.

Return Value:
    If a printer is already installed which uses another driver TRUE, else FALSE

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    LPPRINTER_INFO_2    p = NULL, pPrinterInfo2;
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded;
    HANDLE              hPrinter;
    LPTSTR              pszPortName = pLocalData->PnPInfo.pszPortName;
    LPTSTR              pszDeviceInstanceId = pLocalData->PnPInfo.pszDeviceInstanceId;

    ASSERT( (pLocalData->Flags & VALID_PNP_INFO)    &&
            (pLocalData->Flags & VALID_INF_INFO) );

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Cleanup;

    //
    // If there is a printer going to that same port and with the same pnp
    // info, then it has been reinstalled with a newer driver.
    //
    for ( dwNeeded = 0, pPrinterInfo2 = p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, pPrinterInfo2++ ) {

        if ( PrinterGoingToPort(pPrinterInfo2, pszPortName) &&
            PrinterPnPDataSame(pszDeviceInstanceId, pPrinterInfo2->pPrinterName) ) {

            break; // for loop
        }
    }

    if ( dwNeeded == dwReturned ) {
        //
        // We didn't find anything...
        //
        goto Cleanup;
    }

    if ( OpenPrinter(pPrinterInfo2->pPrinterName,
                     &hPrinter,
                     &PrinterDefault) ) {

        pPrinterInfo2->pDriverName = pLocalData->DrvInfo.pszModelName;

        if( SetPrinter( hPrinter, 2, (LPBYTE)pPrinterInfo2, 0 ) ) {

            lstrcpyn( pszPrinterName, pPrinterInfo2->pPrinterName, MAX_PRINTER_NAME );
            bReturn = TRUE;
        }

        ClosePrinter(hPrinter);
    }

Cleanup:
    if( p ) {

        LocalFreeMem(p);
    }

    return bReturn;
}


VOID
CallVendorDll(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    )
/*++

Routine Description:
    A VendorSetup was specified in the INF. Call the dll with the name of the
    printer just created

Arguments:
    pLocalData      : Gives installation data
    pszPrinterName  : Name of the printer which got installed
    hwnd            : Window handle for any UI

Return Value:
    If the printer is already install TRUE, else FALSE

--*/
{
    TCHAR               szCmd[MAX_PATH];
    SHELLEXECUTEINFO    ShellExecInfo;
    TCHAR               *pszExecutable  = NULL;
    TCHAR               *pszParams      = NULL;
    LPTSTR              pszVendorSetup  = pLocalData->InfInfo.pszVendorSetup;
    INT                 cParamsLength   = 0;
    INT                 cLength         = 0;

    
    if (IsSystemSetupInProgress())
    {
        goto Cleanup;
    }

    ASSERT(pLocalData->Flags & VALID_INF_INFO);

    cParamsLength = lstrlen(pszVendorSetup) + lstrlen(pszPrinterName) + 4;
    pszParams     = LocalAllocMem(cParamsLength * sizeof(TCHAR));
    if (!pszParams) 
    {
        goto Cleanup;
    }

    wsprintf(pszParams, TEXT("%s \"%s\""), pszVendorSetup, pszPrinterName);

    GetSystemDirectory( szCmd, SIZECHARS(szCmd) );
    cLength = lstrlen( szCmd ) + lstrlen( cszRunDll32 ) + 2;
    pszExecutable = LocalAllocMem( cLength * sizeof(TCHAR) );
    if (!pszExecutable) 
    {
        goto Cleanup;
    }
    lstrcpy(pszExecutable, szCmd);
    cLength = lstrlen( pszExecutable );
    if (*(pszExecutable + (cLength - 1)) != TEXT('\\'))
    {
        lstrcat( pszExecutable, TEXT("\\"));
    }
    lstrcat(pszExecutable, cszRunDll32 );

    ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
    ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
    ShellExecInfo.hwnd          = hwnd;
    ShellExecInfo.lpFile        = pszExecutable;
    ShellExecInfo.nShow         = SW_SHOWNORMAL;
    ShellExecInfo.fMask         = SEE_MASK_NOCLOSEPROCESS;
    ShellExecInfo.lpParameters  = pszParams;

    //
    // Call run32dll and wait for the vendor dll to return before proceeding
    //
    if ( ShellExecuteEx(&ShellExecInfo) && ShellExecInfo.hProcess ) {

        WaitForSingleObject(ShellExecInfo.hProcess, dwFourMinutes );
        CloseHandle(ShellExecInfo.hProcess);
    }

Cleanup:

    LocalFreeMem(pszExecutable);
    LocalFreeMem(pszParams);
    return;
}


BOOL
SetPackageName (
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
{
   SP_WINDOWSUPDATE_PARAMS     WinUpParams;

   //
   // Get current SelectDevice parameters, and then set the fields
   // we wanted changed from default
   //
   WinUpParams.ClassInstallHeader.cbSize = sizeof(WinUpParams.ClassInstallHeader);
   WinUpParams.ClassInstallHeader.InstallFunction = DIF_GETWINDOWSUPDATEINFO;
   if ( !SetupDiGetClassInstallParams( hDevInfo,
                                       pDevInfoData,
                                       &WinUpParams.ClassInstallHeader,
                                       sizeof(WinUpParams),
                                       NULL) )
   {
       return FALSE;
   }

   lstrcpy( WinUpParams.PackageId,  cszWebNTPrintPkg );
   WinUpParams.CDMContext = gpCodeDownLoadInfo->hConnection;

   if ( !SetupDiSetClassInstallParams( hDevInfo,
                                       pDevInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &WinUpParams,
                                       sizeof(WinUpParams) ) )
   {
       return FALSE;
   }

   return TRUE;
}

DWORD
ProcessPerInstanceAddRegSections(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  PPSETUP_LOCAL_DATA  pLocalData
)
/*++

Routine Description:
    Processes the AddReg section for this printer that is marked as to process per instance of this
    device

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pLocalData          : Pointer to the print setup local data

Return Value:
    Win 32 error code

--*/
{
    DWORD dwReturn;
    HINF hPrinterInf;
    TCHAR *pszSection = NULL;

    dwReturn = StrCatAlloc(&pszSection, pLocalData->InfInfo.pszInstallSection, cszProcessAlways, NULL);

    if (dwReturn != ERROR_SUCCESS)
    {
        goto Done;
    }
    
    hPrinterInf = SetupOpenInfFile(pLocalData->DrvInfo.pszInfName, 
                                   NULL, 
                                   INF_STYLE_WIN4,
                                   NULL);

    if (hPrinterInf != INVALID_HANDLE_VALUE)
    {
        //
        // Ignore return value - it doesn't make much sense to fail the install here
        //
        if (!SetupInstallFromInfSection(NULL,
                                        hPrinterInf,
                                        pszSection,
                                        SPINST_REGISTRY,
                                        NULL,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL,
                                        hDevInfo,
                                        pDevInfoData))
        {
            DBGMSG( DBG_ERROR,("ProcessPerInstanceAddRegSections: SetupInstallFromInfSection failed: %d\n", GetLastError( )));
        }
        
        SetupCloseInfFile(hPrinterInf);
    }
    else
    {
        DBGMSG( DBG_ERROR,("ProcessPerInstanceAddRegSections: SetupOpenInfFile %s failed: %d\n", pLocalData->DrvInfo.pszInfName, GetLastError( )));
    }

Done:
    FreeSplMem(pszSection);

    return dwReturn;
}

DWORD
ClassInstall_SelectDevice(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_SELECTDEVICE

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer

Return Value:
    Win 32 error code

--*/
{

    return SetSelectDevParams(hDevInfo, pDevInfoData, FALSE, NULL)  &&
           SetDevInstallParams(hDevInfo, pDevInfoData, NULL)
                ? ERROR_DI_DO_DEFAULT
                : GetLastError();
}


DWORD
ClassInstall_InstallDevice(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLDEVICE

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    TPrinterInstall     TPrnInstData;
    TParameterBlock     TParm;
    TCHAR               szPrinterName[MAX_PRINTER_NAME];
    HANDLE              hPrinter = NULL;
    DWORD               dwReturn;
    SP_DRVINFO_DATA     DrvInfoData = {0};


    if ( !pDevInfoData ) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // check whether this is the NULL driver - we get that request if we fail DIF_ALLOW_INSTALL.
    // If the DI_FLAGSEX_SETFAILEDINSTALL we must succeed. In this case call the default class installer
    // to do it's thing, then set the REINSTALL flag on the devnode so on first boot 
    // they will try to reinstall the device
    //
    DrvInfoData.cbSize = sizeof(DrvInfoData);
    
    if ( 
         !SetupDiGetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData) &&
         (ERROR_NO_DRIVER_SELECTED == GetLastError()) &&
         IsSystemSetupInProgress() &&
         (pDevInstallParams->FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)
       )
    {
        DWORD dwConfigFlags = 0, cbRequiredSize =0, dwDataType = REG_DWORD;

        //
        // run the default class installer
        //
        if (SetupDiInstallDevice(hDevInfo, pDevInfoData))
        {
            //
            // now set the appropriate config flags
            //
            dwReturn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                        pDevInfoData,
                                                        SPDRP_CONFIGFLAGS,
                                                        &dwDataType,
                                                        (PBYTE) &dwConfigFlags,
                                                        sizeof(dwConfigFlags),
                                                        &cbRequiredSize) ? 
                                                            (REG_DWORD == dwDataType ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER) 
                                                            : GetLastError();                   

            if (ERROR_SUCCESS == dwReturn) 
            {
                dwConfigFlags |= CONFIGFLAG_REINSTALL;      // to make setupapi reinstall this on first boot
                dwConfigFlags &= ~CONFIGFLAG_FAILEDINSTALL; // per LonnyM's request in order not to screw up anything setupapi-internal

                dwReturn = SetupDiSetDeviceRegistryProperty(hDevInfo,
                                                            pDevInfoData,
                                                            SPDRP_CONFIGFLAGS,
                                                            (PBYTE) &dwConfigFlags,
                                                            sizeof(dwConfigFlags)) ? 
                                                                ERROR_SUCCESS : GetLastError();
            }
        }
        else
        {
            dwReturn = GetLastError();
        }
       
        //
        // don't go through the normal cleanup path that would munge the error code to 
        // DI_DO_DEFAULT - we have already called the default class installer and it would
        // clean out the flags we've set.
        //

        return dwReturn;
    }

    //
    //
    // Parse the inf and also get PnP info from config manger registry
    //
    if ( !(pLocalData = BuildInternalData(hDevInfo, pDevInfoData))  ||
         !ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0) ) {

        dwReturn = GetLastError();
        goto Done;
    }
    
    if ( dwReturn = ProcessPerInstanceAddRegSections(hDevInfo, pDevInfoData, pLocalData)) {
        goto Done;
    }

    if ( dwReturn = GetPlugAndPlayInfo(hDevInfo, pDevInfoData, pLocalData) ) {
        goto Done;
    }

    //
    // Install printer driver if FORCECOPY is set or if the driver is not
    // available and it is ok to put up ui
    //
    if ( (pDevInstallParams->Flags & DI_FORCECOPY)  ||
         DRIVER_MODEL_INSTALLED_AND_IDENTICAL !=
                PSetupIsTheDriverFoundInInfInstalled(NULL,
                                                     pLocalData,
                                                     MyPlatform,
                                                     KERNEL_MODE_DRIVER_VERSION) ) {

        if ( pDevInstallParams->Flags & DI_NOFILECOPY ) {

            dwReturn = ERROR_UNKNOWN_PRINTER_DRIVER;
            goto Done;
        }

        dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                               pLocalData,
                                               pDevInstallParams->hwndParent,
                                               MyPlatform,
                                               dwThisMajorVersion,
                                               NULL,
                                               pDevInstallParams->FileQueue,
                                               pDevInstallParams->InstallMsgHandlerContext,
                                               pDevInstallParams->InstallMsgHandler,
                                               pDevInstallParams->Flags,
                                               NULL,
                                               DRVINST_NO_WARNING_PROMPT,
                                               APD_COPY_NEW_FILES, 
                                               NULL,
                                               NULL,
                                               NULL);

        if ( dwReturn != ERROR_SUCCESS )
            goto Done;
    }

    //
    // If the printer is already installed nothing to do
    //
    if ( DuplicateDevice(pLocalData) ) {

        dwReturn = ERROR_SUCCESS;
        goto Done;
    }

    if( !NewDriverForInstalledDevice(pLocalData, (LPTSTR)&szPrinterName) ) {

        if ( !LoadAndInitializePrintui() ) {

            dwReturn = GetLastError();
            goto Done;
        }

        TPrnInstData.cbSize                 = sizeof(TPrinterInstall);
        TPrnInstData.pszServerName          = NULL;
        TPrnInstData.pszDriverName          = pLocalData->DrvInfo.pszModelName;
        TPrnInstData.pszPortName            = pLocalData->PnPInfo.pszPortName;
        TPrnInstData.pszPrinterNameBuffer   = szPrinterName;
        TPrnInstData.cchPrinterName         = SIZECHARS(szPrinterName);

        TParm.pPrinterInstall   = &TPrnInstData;

        if ( dwReturn = dwfnPnPInterface(kPrinterInstall, &TParm) )
            goto Done;
    } else {

        dwReturn = ERROR_SUCCESS;
    }

    //
    // Set the device instance id with spooler
    //
    if ( OpenPrinter(szPrinterName, &hPrinter, &PrinterDefault) ) {

        (VOID)SetPnPInfoForPrinter(hPrinter,
                                   pLocalData->PnPInfo.pszDeviceInstanceId,
                                   pLocalData->DrvInfo.pszHardwareID,
                                   pLocalData->DrvInfo.pszManufacturer,
                                   pLocalData->DrvInfo.pszOEMUrl);
    }

    //
    // If a vendor dll is given we need to call into it
    //
    if ( pLocalData->InfInfo.pszVendorSetup )
        CallVendorDll(pLocalData, szPrinterName, pDevInstallParams->hwndParent);

    //
    // If ICM files need to installed and associated do it
    //
    if ( pLocalData->InfInfo.pszzICMFiles )
        (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                         szPrinterName);

Done:
    if ( hPrinter )
        ClosePrinter(hPrinter);

    DestroyLocalData(pLocalData);

    //
    // On everything going smoothly we want setup to whatever it needs to do
    // to make PnP system happy so that the devnode is marked as configured
    // But we do not want them to copy files again
    //
    if ( dwReturn == ERROR_SUCCESS ) {

        pDevInstallParams->Flags |= DI_NOFILECOPY;

        SetupDiSetDeviceInstallParams(hDevInfo,
                                      pDevInfoData,
                                      pDevInstallParams);

        dwReturn = ERROR_DI_DO_DEFAULT;
    }

    return dwReturn;
}


DWORD
ClassInstall_DestroyWizardData(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_DESTROYWIZARDDATA
Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    SP_INSTALLWIZARD_DATA   InstallWizData;
    TDestroyWizard          TDestroyWsd;
    TParameterBlock         TParams;
    DWORD                   dwReturn;

    ASSERT(hPrintui && dwfnPnPInterface);

    InstallWizData.ClassInstallHeader.cbSize
                = sizeof(InstallWizData.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData),
                                       NULL)    ||
         InstallWizData.ClassInstallHeader.InstallFunction != DIF_DESTROYWIZARDDATA ) {

        return ERROR_DI_DO_DEFAULT;
    }

    TDestroyWsd.cbSize          = sizeof(TDestroyWsd);
    TDestroyWsd.pszServerName   = NULL;
    TDestroyWsd.pData           = &InstallWizData;
    TDestroyWsd.pReferenceData  = (PVOID)pDevInstallParams->ClassInstallReserved;

    TParams.pDestroyWizard      = &TDestroyWsd;

    dwReturn = dwfnPnPInterface(kDestroyWizardData, &TParams);

    return dwReturn;
}


DWORD
ClassInstall_InstallWizard(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLWIZARD

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/

{
    SP_INSTALLWIZARD_DATA   InstallWizData;
    TInstallWizard          TInstWzd;
    TParameterBlock         TParams;
    DWORD                   dwReturn;

    InstallWizData.ClassInstallHeader.cbSize
                = sizeof(InstallWizData.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData),
                                       NULL)    ||
         InstallWizData.ClassInstallHeader.InstallFunction != DIF_INSTALLWIZARD ) {

        return ERROR_DI_DO_DEFAULT;
    }

    if ( !LoadAndInitializePrintui() )
        return GetLastError();

    TInstWzd.cbSize         = sizeof(TInstWzd);
    TInstWzd.pszServerName  = NULL;
    TInstWzd.pData          = &InstallWizData;
    TInstWzd.pReferenceData = (PVOID)pDevInstallParams->ClassInstallReserved;

    TParams.pInstallWizard  = &TInstWzd;

    if ( dwReturn = dwfnPnPInterface(kInstallWizard, &TParams) )
        goto Cleanup;

    if ( !SetupDiSetClassInstallParams(hDevInfo,
                                       pDevInfoData,
                                       &InstallWizData.ClassInstallHeader,
                                       sizeof(InstallWizData)) ) {

        dwReturn = GetLastError();
    }

    pDevInstallParams->ClassInstallReserved = (LPARAM)TInstWzd.pReferenceData;
    if ( !SetupDiSetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        pDevInstallParams) ) {

        dwReturn = GetLastError();
    }

Cleanup:
    if ( dwReturn != ERROR_SUCCESS ) {

        ClassInstall_DestroyWizardData(hDevInfo,
                                       pDevInfoData,
                                       pDevInstallParams);
    }

    return dwReturn;
}

            

DWORD
ClassInstall_InstallDeviceFiles(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_INSTALLDEVICEFILES

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    PPSETUP_LOCAL_DATA      pLocalData;
    DWORD                   dwReturn;

    if ( pLocalData = BuildInternalData(hDevInfo, pDevInfoData) ) 
    {
        dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                               pLocalData,
                                               pDevInstallParams->hwndParent,
                                               MyPlatform,
                                               dwThisMajorVersion,
                                               NULL,
                                               pDevInstallParams->FileQueue,
                                               pDevInstallParams->InstallMsgHandlerContext,
                                               pDevInstallParams->InstallMsgHandler,
                                               pDevInstallParams->Flags,
                                               NULL,
                                               DRVINST_NO_WARNING_PROMPT,
                                               APD_COPY_NEW_FILES,
                                               NULL,
                                               NULL,
                                               NULL);
        
        DestroyLocalData(pLocalData);
    } 
    else 
    {
        dwReturn = GetLastError();
    }

    return dwReturn;
}


DWORD
ClassInstall_RemoveDevice(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_REMOVEDEVICE

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    DWORD               dwRet = ERROR_SUCCESS, dwIndex, dwCount, dwNeeded;
    HANDLE              hPrinter;
    LPPRINTER_INFO_2    pPrinterInfo2, pBuf = NULL;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    TCHAR               szDevId[MAX_DEVICE_ID_LEN], szPrnId[MAX_DEVICE_ID_LEN];

    if ( !SetupDiGetDeviceInstanceId(hDevInfo,
                                     pDevInfoData,
                                     szDevId,
                                     SIZECHARS(szDevId),
                                     NULL)                  ||
         !PrinterInfo2s(&pBuf, &dwCount) )
        return GetLastError();

    for ( dwIndex = 0, pPrinterInfo2 = pBuf ;
          dwIndex < dwCount ;
          ++dwIndex, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName,
                          &hPrinter,
                          &PrinterDefault) )
            continue;

        if ( ERROR_SUCCESS == GetPrinterDataEx(hPrinter,
                                               cszPnPKey,
                                               cszDeviceInstanceId,
                                               &dwNeeded,
                                               (LPBYTE)szPrnId,
                                               sizeof(szPrnId),
                                               &dwNeeded)           &&
             !lstrcmp(szPrnId, szDevId) ) {

            dwRet = DeletePrinter(hPrinter) ? ERROR_SUCCESS : GetLastError();
            ClosePrinter(hPrinter);
            goto Done;
        }

        ClosePrinter(hPrinter);
    }

    //
    // If we did not find the printer with spooler let setup do whatever they
    // want to. Note even if a printer failed to install they can call us to
    // remove it when Uninstall is selected from DevMan
    //
    dwRet = ERROR_DI_DO_DEFAULT;

Done:
    LocalFreeMem(pBuf);

    return dwRet;
}


DWORD
ClassInstall_DriverInfo(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for DIF_DRIVERINFO
    This is a class installer entry point specific to printer class installer.

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    PPRINTER_CLASSINSTALL_INFO  pClassInstallInfo;
    PPSETUP_LOCAL_DATA          pLocalData;
    DWORD                       dwReturn;

    //
    // PRINTER_CLASSINSTALL_INFO could expand in the future
    //
    pClassInstallInfo = (PPRINTER_CLASSINSTALL_INFO)
                                    pDevInstallParams->ClassInstallReserved;

    if ( !pClassInstallInfo ||
         pClassInstallInfo->cbSize < sizeof(PRINTER_CLASSINSTALL_INFO) ) {

        return ERROR_INVALID_PARAMETER;
    }

    if ( pClassInstallInfo->dwLevel != 2    &&
         pClassInstallInfo->dwLevel != 3    &&
         pClassInstallInfo->dwLevel != 4 )
        return ERROR_INVALID_LEVEL;

    if ( !(pLocalData = BuildInternalData(hDevInfo, pDevInfoData))      ||
         !ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0) ) {

        dwReturn = GetLastError();
        goto Done;
    }

    *pClassInstallInfo->pcbNeeded = pLocalData->InfInfo.cbDriverInfo6;
    if ( pClassInstallInfo->cbBufSize < *pClassInstallInfo->pcbNeeded ) {

        dwReturn = ERROR_INSUFFICIENT_BUFFER;
        goto Done;
    }

    PackDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                    (LPDRIVER_INFO_6)pClassInstallInfo->pBuf,
                    pLocalData->InfInfo.cbDriverInfo6);
    dwReturn = ERROR_SUCCESS;

Done:
    DestroyLocalData(pLocalData);
    return dwReturn;
}

BOOL
FindDriver(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    OUT PSP_DRVINFO_DATA        pDrvInfoData
    )
/*++

Routine Description:
    Gets the DeviceInstanceId for the pnp device and searches through all installed printer's pnp data to see if
    this device has already been installed.  This will only be called if no device has been selected and we're
    being asked to install a NULL driver.

    If there is a printer installed for this instance, get it's driver info and put the driver, mfg and provider names
    into the pDrvInfoData structure to return.

Arguments:
    hDevInfo     - passed in from pnp.
    pDevInfoData - passed in from pnp.
    pDrvInfoData - will return with the relevant driver information to search for to install.

--*/
{
    TCHAR               szDeviceInstanceId[MAX_DEVICE_ID_LEN];
    HANDLE              hPrinter       = INVALID_HANDLE_VALUE;
    BOOL                bRet           = FALSE;
    DWORD               dwReturned,
                        dwIndex,
                        dwNeeded       = 0;
    LPPRINTER_INFO_2    p              = NULL,
                        pPrinterInfo2;
    LPDRIVER_INFO_6     lpDriverInfo6  = NULL;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

    if( !pDrvInfoData || pDrvInfoData->cbSize != sizeof(SP_DRVINFO_DATA) ) {

        goto Cleanup;
    }

    if ( !SetupDiGetDeviceInstanceId(hDevInfo,
                                     pDevInfoData,
                                     szDeviceInstanceId,
                                     SIZECHARS(szDeviceInstanceId),
                                     NULL) ) {

        goto Cleanup;
    }

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Cleanup;

    //
    // If there is a printer going to that same port and with the same pnp
    // info, then it has been reinstalled with a newer driver.
    //
    for ( dwIndex = 0, pPrinterInfo2 = p ;
          dwIndex < dwReturned ;
          ++dwIndex, pPrinterInfo2++ ) {

        if ( PrinterPnPDataSame(szDeviceInstanceId, pPrinterInfo2->pPrinterName) )
        {
            //
            // Get a DRIVER_INFO_6 for the installed driver.
            //
            if( OpenPrinter(pPrinterInfo2->pPrinterName, &hPrinter, &PrinterDefault) ) {

                if( !GetPrinterDriver( hPrinter,
                                       PlatformEnv[MyPlatform].pszName,
                                       6,
                                       (LPBYTE)lpDriverInfo6,
                                       dwNeeded,
                                       &dwNeeded) ) {

                    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER           ||
                        NULL == ( lpDriverInfo6 = LocalAllocMem( dwNeeded ) ) ||
                        !GetPrinterDriver( hPrinter,
                                           PlatformEnv[MyPlatform].pszName,
                                           6,
                                           (LPBYTE)lpDriverInfo6,
                                           dwNeeded,
                                           &dwNeeded) ) {

                        ClosePrinter( hPrinter );
                        goto Cleanup;
                    }
                }

                //
                // We have some info, so clear the pDrvInfoData and set it up.
                //
                ZeroMemory( pDrvInfoData, sizeof(SP_DRVINFO_DATA) );

                pDrvInfoData->cbSize = sizeof(SP_DRVINFO_DATA);

                pDrvInfoData->DriverType = SPDIT_CLASSDRIVER;

                //
                // We have the DRIVER_INFO_6 - now get the Driver, Mfg and Provider names from the struct
                // to use as the install info.
                //
                lstrcpyn( pDrvInfoData->Description, lpDriverInfo6->pName, LINE_LEN );
                lstrcpyn( pDrvInfoData->MfgName, lpDriverInfo6->pszMfgName, LINE_LEN );
                lstrcpyn( pDrvInfoData->ProviderName, lpDriverInfo6->pszProvider, LINE_LEN );

                ClosePrinter( hPrinter );
                bRet = TRUE;

                goto Cleanup;
            }
        }
    }

Cleanup:

    if( p ) {

        LocalFreeMem( p );
    }

    if( lpDriverInfo6 ) {

        LocalFreeMem( lpDriverInfo6 );
    }

    return bRet;
}


DWORD
ClassInstall_SelectBestCompatDrv(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for
    DIF_SELECTBESTCOMPATDRV.

    We try to handle the broken OEM models which return same PnP id for
    multiple devices. For that we do the following:
        1. If only one compatible driver has been found by setup we got
           nothing to do. We ask setup to do the default since this is a good
           devive.
        2. If multiple drivers are found we do the following:
            2.1 What is the port this printer is attached to
            2.2 Find list of printers installed currently
            2.3 If we have a printer going to the port the PnP printer is
                attached to AND the driver for that printer is one of the
                compatible drivers then we got nothing to do. User has already
                manually installed it.

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    BOOL                    bFound = FALSE, Rank0IHVMatchFound = FALSE;
    HKEY                    hKey = NULL;
    DWORD                   dwReturn = ERROR_DI_DO_DEFAULT, dwRank0Matches;
    DWORD                   dwSize, dwType, dwIndex1, dwIndex2, dwReturned;
    SP_DRVINFO_DATA         DrvInfoData;
    TCHAR                   szPortName[MAX_PATH];
    LPPRINTER_INFO_2        p = NULL, pPrinterInfo2;
    SP_DRVINSTALL_PARAMS    DrvInstData;
    LPTSTR                  pszModelName = NULL;
    PSP_DRVINFO_DETAIL_DATA pDetailData;
    DWORD                   dwDetailDataSize = sizeof(SP_DRVINFO_DETAIL_DATA); 

    //
    // Allocate pDetailData on the heap, it's quite chunky
    //
    pDetailData = LocalAllocMem(dwDetailDataSize);
    if ( !pDetailData )
    {
        goto Done;
    }

    //
    // If we do not have more than 1 compatible driver do default
    //   Note: API uses 0 based index.
    //
    for ( dwIndex1 = dwRank0Matches = 0 ; ; ++dwIndex1 ) {

        DrvInfoData.cbSize = sizeof(DrvInfoData);
        if ( !SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER,
                                    dwIndex1, &DrvInfoData) )
            break;

        DrvInstData.cbSize = sizeof(DrvInstData);
        if ( SetupDiGetDriverInstallParams(hDevInfo,
                                           pDevInfoData,
                                           &DrvInfoData,
                                           &DrvInstData))
        {
            if (DrvInstData.Rank < 0x1000 ) 
            {
               if (!pszModelName)
               {
                  pszModelName = AllocStr( DrvInfoData.Description );
                  ++dwRank0Matches;
               }
               else if ( lstrcmpi( pszModelName, DrvInfoData.Description ) )
               {
                  ++dwRank0Matches;
               }
            }
            
            //
            // Check for whether this match is in ntprint.inf. If so, set flag to prefer other drivers
            //
            ZeroMemory(pDetailData, dwDetailDataSize);
            pDetailData->cbSize = dwDetailDataSize;

            //
            // check whether it's ntprint.inf
            // function may return insufficient buffer if it couldn't stuff all the
            // hardware IDs at the end of the structure.
            //
            if ((SetupDiGetDriverInfoDetail(hDevInfo, 
                                            pDevInfoData, 
                                            &DrvInfoData,
                                            pDetailData,
                                            dwDetailDataSize,
                                            NULL))              || 
                (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
            {
                SetLastError(ERROR_SUCCESS);
                if (IsSystemNTPrintInf( pDetailData->InfFileName ) )
                {
                    DrvInstData.Flags |= DNF_BASIC_DRIVER;
                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDevInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstData);

                }
                else if (DrvInstData.Rank < 0x1000 ) 
                {
                    Rank0IHVMatchFound = TRUE;
                }
            }

        }
    }

    //
    // Free the memory if allocated
    //
    LocalFreeMem( pszModelName );
    LocalFreeMem( pDetailData );

    if ( dwRank0Matches <= 1 )
        goto Done;

    //
    // Look in the devnode of the printer for the port name
    //
    dwSize = sizeof(szPortName);
    if ( ERROR_SUCCESS != CM_Open_DevNode_Key(pDevInfoData->DevInst, KEY_READ,
                                              0, RegDisposition_OpenExisting,
                                              &hKey, CM_REGISTRY_HARDWARE)  ||
         ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortName, NULL, &dwType,
                                          (LPBYTE)&szPortName, &dwSize) )
        goto Done;

    if ( !PrinterInfo2s(&p, &dwReturned) )
        goto Done;


    //
    // If there is a local printer using a driver with rank-0 match and
    // going to the same port then it is a duplicate
    //
    for ( dwIndex1 = 0, pPrinterInfo2 = p ;
          dwIndex1 < dwReturned ;
          ++dwIndex1, pPrinterInfo2++ ) {

        if ( !PrinterGoingToPort(pPrinterInfo2, szPortName) )
            continue;

        dwIndex2 = 0;
        DrvInfoData.cbSize = sizeof(DrvInfoData);
        while ( SetupDiEnumDriverInfo(hDevInfo, pDevInfoData,
                                      SPDIT_COMPATDRIVER, dwIndex2,
                                      &DrvInfoData) ) {

            DrvInstData.cbSize = sizeof(DrvInstData);
            if ( SetupDiGetDriverInstallParams(hDevInfo,
                                               pDevInfoData,
                                               &DrvInfoData,
                                               &DrvInstData)            &&
                 DrvInstData.Rank < 0x1000                              &&
                 !lstrcmpi(DrvInfoData.Description,
                           pPrinterInfo2->pDriverName) ) {

                bFound = TRUE;
                break;
            }

            ++dwIndex2;
            DrvInfoData.cbSize = sizeof(DrvInfoData);
        }

        if ( bFound )
            break;
    }

    //
    // If we found a manually installed printer which matches one of the
    // compatible drivers that is what we want to install
    //
    if ( bFound ) {

        //
        // This means newdev will choose this as the driver to install
        //
        if ( SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData) )
            dwReturn = ERROR_SUCCESS;
    } 
    else if (!Rank0IHVMatchFound)
    {
        //
        // We did not find a printer. So bump up the rank of all drivers
        // to force newdev to ask the user to select a driver
        //
        dwIndex2 = 0;
        DrvInfoData.cbSize = sizeof(DrvInfoData);
        while ( SetupDiEnumDriverInfo(hDevInfo, pDevInfoData,
                                      SPDIT_COMPATDRIVER, dwIndex2,
                                      &DrvInfoData) ) {

            DrvInstData.cbSize = sizeof(DrvInstData);
            if ( SetupDiGetDriverInstallParams(hDevInfo,
                                               pDevInfoData,
                                               &DrvInfoData,
                                               &DrvInstData)            &&
                 DrvInstData.Rank < 0x1000 ) {

                DrvInstData.Rank += 0x1000;
                SetupDiSetDriverInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &DrvInfoData,
                                              &DrvInstData);
            }

            ++dwIndex2;
            DrvInfoData.cbSize = sizeof(DrvInfoData);

        }
    }

Done:
    LocalFreeMem(p);

    if ( hKey )
        RegCloseKey(hKey);

    return dwReturn;
}

DWORD
StoreDriverTypeInDevnode(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    SP_DRVINFO_DATA DrvInfoData = {0};
    DWORD dwRet = ERROR_SUCCESS;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if (SetupDiGetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData))
    {
        DWORD  dwDetailDataSize = sizeof(SP_DRVINFO_DETAIL_DATA); 
        SP_DRVINSTALL_PARAMS DrvInstData = {0};

        DrvInstData.cbSize = sizeof(DrvInstData);

        if ( SetupDiGetDriverInstallParams(hDevInfo,
                                           pDevInfoData,
                                           &DrvInfoData,
                                           &DrvInstData))
        {
            HKEY    hKey;
            DWORD   InstallInboxDriver;

            InstallInboxDriver = (DrvInstData.Flags & DNF_BASIC_DRIVER) ? 1 : 0;
            
            hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_WRITE);
            if (hKey != INVALID_HANDLE_VALUE)
            {
                dwRet = RegSetValueEx(hKey, cszBestDriverInbox, 0, REG_DWORD, (LPBYTE) &InstallInboxDriver, sizeof(InstallInboxDriver));

                RegCloseKey(hKey);
            }
            else
            {
                dwRet = GetLastError();
            }
        }
        else 
        {
            dwRet = GetLastError();
        }
    }
    else 
    {
        dwRet = GetLastError();
    }
    
    return dwRet;
}



DWORD
ClassInstall_AllowInstall(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevInfoData,
    IN  PSP_DEVINSTALL_PARAMS   pDevInstallParams
    )
/*++

Routine Description:
    This function handles the class installer entry point for
    DIF_ALLOW_INSTALL.

    Do not allow PnP installs during GUI setup portion of system upgrade
    Do not allow install of INFs using VendorSetup if QUIETINSTALL bit is set

Arguments:
    hDevInfo            : Handle to the printer class device information list
    pDevInfoData        : Pointer to the device info element for the printer
    pDevInstallParam    : Pointer to the device install structure

Return Value:
    Win 32 error code

--*/
{
    DWORD               dwReturn = ERROR_DI_DO_DEFAULT;
    PPSETUP_LOCAL_DATA  pLocalData;

    if ( pDevInstallParams->Flags & DI_QUIETINSTALL ) {

        //
        // During system setup no PnP install of printers because there ain't no spooler
        // check that the spooler is running - failing this will punt to client-side installation
        // which should happen at a point in time where the spooler actually is running - we don't 
        // want to stall system startup until the spooler is up (think USB mouse...) 
        //
        if (IsSystemSetupInProgress() ||
            !IsSpoolerRunning()) {
            //
            // store the type (inbox or not) in the devnode. This fails if this is a clean install
            // but it doesn't matter because we only need it for drivers that have been installed
            // before upgrade.
            // We use it to determine later on whether to clear the CONFIGFLAG_REINSTALL
            // or not. We don't want to clear it if the best driver is inbox so we'll install it
            // on first boot.
            //
            StoreDriverTypeInDevnode(hDevInfo, pDevInfoData);

            dwReturn = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            goto Done;
        }

        if ( (pLocalData = BuildInternalData(hDevInfo, pDevInfoData))   &&
             ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0) ) {

            if ( pLocalData->InfInfo.pszVendorSetup &&
                 *pLocalData->InfInfo.pszVendorSetup )
                dwReturn = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
         } else {

            if ( (dwReturn = GetLastError()) == ERROR_SUCCESS )
                dwReturn = ERROR_INVALID_PARAMETER;
        }

    }

Done:
    return dwReturn;
}


DWORD
ClassInstall32(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:
    This is the printer class installer entry point for SetupDiCallClassInstaller calls

Arguments:
    InstallFunction : The function being called
    hDevInfo        : Handle to the printer class device information list
    pDevInfoData    : Pointer to the device info element for the printer

Return Value:
    Win 32 error code

--*/
{
    SP_DEVINSTALL_PARAMS        DevInstallParams;
    DWORD                       dwReturn = ERROR_DI_DO_DEFAULT;

    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        dwReturn = GetLastError();
        goto Done;
    }

    switch (InstallFunction) {

        case DIF_SELECTDEVICE:
            dwReturn = ClassInstall_SelectDevice(hDevInfo, pDevInfoData);
            break;

        case DIF_INSTALLDEVICE:
            dwReturn = ClassInstall_InstallDevice(hDevInfo,
                                                  pDevInfoData,
                                                  &DevInstallParams);
            break;

        case  DIF_DRIVERINFO:
            dwReturn = ClassInstall_DriverInfo(hDevInfo,
                                               pDevInfoData,
                                               &DevInstallParams);
            break;

        case DIF_INSTALLWIZARD:
            dwReturn = ClassInstall_InstallWizard(hDevInfo,
                                                  pDevInfoData,
                                                  &DevInstallParams);
            break;

        case DIF_DESTROYWIZARDDATA:
            dwReturn = ClassInstall_DestroyWizardData(hDevInfo,
                                                      pDevInfoData,
                                                      &DevInstallParams);
            break;

        case DIF_INSTALLDEVICEFILES:
            dwReturn = ClassInstall_InstallDeviceFiles(hDevInfo,
                                                       pDevInfoData,
                                                       &DevInstallParams);
            break;

        case DIF_REMOVE:
            dwReturn = ClassInstall_RemoveDevice(hDevInfo,
                                                 pDevInfoData,
                                                 &DevInstallParams);
            break;

        case DIF_GETWINDOWSUPDATEINFO:


            if ( !InitCodedownload(HWND_DESKTOP) )
                dwReturn = GetLastError();
            else
            {
                if ( SetPackageName(hDevInfo, pDevInfoData) )
                   dwReturn = NO_ERROR;
                else
                   dwReturn = GetLastError();
            }
            break;
        case DIF_SELECTBESTCOMPATDRV:
            dwReturn = ClassInstall_SelectBestCompatDrv(hDevInfo,
                                                        pDevInfoData,
                                                        &DevInstallParams);
            break;

        case DIF_ALLOW_INSTALL:
            dwReturn = ClassInstall_AllowInstall(hDevInfo,
                                                 pDevInfoData,
                                                 &DevInstallParams);
            break;

        case DIF_DESTROYPRIVATEDATA:
        case DIF_MOVEDEVICE:

        default:
            break;
    }

Done:
    return dwReturn;
}


BOOL
PSetupProcessPrinterAdded(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    )
{
    BOOL                bRet = FALSE;
    HANDLE              hPrinter = NULL;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

    bRet = OpenPrinter((LPTSTR)pszPrinterName, &hPrinter, &PrinterDefault)  &&
           SetPnPInfoForPrinter(hPrinter,
                                pLocalData->PnPInfo.pszDeviceInstanceId,
                                pLocalData->DrvInfo.pszHardwareID,
                                pLocalData->DrvInfo.pszManufacturer,
                                pLocalData->DrvInfo.pszOEMUrl);

    //
    // If a vendor dll is given we need to call into it
    //
    if ( pLocalData->InfInfo.pszVendorSetup )
        CallVendorDll(pLocalData, pszPrinterName, hwnd);

    if ( pLocalData->InfInfo.pszzICMFiles )
        (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                         pszPrinterName);

    if ( hPrinter )
        ClosePrinter(hPrinter);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\local.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Holds spooler install headers.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#if defined(__cplusplus)
extern "C"
{
#endif


#define     MAX_SETUP_LEN                        250
#define     MAX_SETUP_ALLOC_STRING_LEN          4000 // in characters, used in GetLongStringFromRcFile
#define     MAX_SECT_NAME_LEN                    256
#define     MAX_DWORD                     0xFFFFFFFF

#define     IDS_PRINTERWIZARD                   1001
#define     IDS_WINNTDEV_INSTRUCT               1002
#define     IDS_WIN95DEV_INSTRUCT               1003
#define     IDS_SELECTDEV_LABEL                 1004
#define     IDS_DRIVERS_FOR_PLATFORM            1005
#define     IDS_INSTALLING_PORT_MONITOR         1006
#define     IDS_WRONG_ARCHITECTURE              1007
#define     IDS_INVALID_DRIVER                  1008
#define     IDS_PROMPT_PORT_MONITOR             1009
#define     IDS_ERROR_INST_PORT_MONITOR         1010

#define     IDS_WIN95_FLATSHARE                 1021
#define     IDS_WINNT_40_CD                     1022
#define     IDS_WINNT_SERVER_CD                 1023
#define     IDS_WINNT_X86_SERVER_CD             1024
#define     IDS_WINNT_ALPHA_SERVER_CD           1025
#define     IDS_WINNT_IA64_SERVER_CD            1026
#define     IDS_PROMPT_ALT_PLATFORM_DRIVER      1027
#define     IDS_WARN_NO_ALT_PLATFORM_DRIVER     1028
#define     IDS_WARN_NO_DRIVER_FOUND            1029

#define     IDS_DRIVERS_FOR_WIN95               1031
#define     IDS_DRIVERS_FOR_NT4_X86             1032
#define     IDS_DRIVERS_FOR_NT4_ALPHA           1033
#define     IDS_DRIVERS_FOR_NT4_MIPS            1034
#define     IDS_DRIVERS_FOR_NT4_PPC             1035
#define     IDS_DRIVERS_FOR_X86                 1036
#define     IDS_DRIVERS_FOR_IA64                1037

//
// Setuplog entried used during upgrade
//
#define     IDS_UPGRADE_FAILED                  1051
#define     IDS_DRIVER_UPGRADE_FAILED           1052
#define     IDS_PRINTER_UPGRADE_FAILED          1053
#define     IDS_PRINTER_DELETED                 1054
#define     IDS_DRIVER_CHANGED                  1055
#define     IDS_CONNECTION_DELETED              1056

//
// entries for printupg warnings
//
#define     IDS_TITLE_BSP_WARN                  1060
#define     IDS_TITLE_BSP_ERROR                 1061
#define     IDS_BSP_WARN_NO_INBOX               1062
#define     IDS_BSP_WARN_WITH_INBOX             1063
#define     IDS_BSP_BLOCK_NO_INBOX              1064
#define     IDS_BSP_BLOCK_WITH_INBOX            1065
#define     IDS_BSP_WARN_UNSIGNED_DRIVER        1066

#define     IDT_STATIC                           100
#define     IDD_BILLBOARD                        101
#define     IDI_SETUP                            102
#define     SETUP_ICON                           103

//
// Printer driver directory set in ntprint.inf
//
#define     PRINTER_DRIVER_DIRECTORY_ID                         66000
#define     PRINT_PROC_DIRECTORY_ID                             66001
#define     SYSTEM_DIRECTORY_ID_ONLY_FOR_NATIVE_ARCHITECTURE    66002
#define     ICM_PROFILE_DIRECTORY_ID                            66003
#define     WEBPAGE_DIRECTORY_ID                                66004

#define     PSETUP_SIGNATURE                   0x9585

// Defines for the columns in the Architecture Platform Table for Driver Signing & CDM

#define  OS_PLATFORM    0
#define  PROCESSOR_ARCH 1


#ifdef UNICODE
#define lstrchr     wcschr
#define lstrncmp    wcsncmp
#define lstrncmpi   _wcsnicmp
#else
#define lstrchr     strchr
#define lstrtok     strtok
#define lstrncmp    strncmp
#define lstrncmpi   _strnicmp
#endif



#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

//
// Type definitions
//
typedef struct _SPLPLATFORMINFO {

    LPTSTR pszName;
} SPLPLATFORMINFO, *PSPLPLATFORMINFO;

typedef struct _SELECTED_DRV_INFO {

    LPTSTR              pszInfName;
    LPTSTR              pszModelName;
    LPTSTR              pszDriverSection;
    PSP_DEVINFO_DATA    pDevInfoData;
    LPTSTR              pszHardwareID;
    LPTSTR              pszManufacturer;
    LPTSTR              pszOEMUrl;
    LPTSTR              pszProvider;
    FILETIME            ftDriverDate;
    DWORDLONG           dwlDriverVersion;
    DWORD               Flags;
    LPTSTR              pszzPreviousNames;
} SELECTED_DRV_INFO, *PSELECTED_DRV_INFO;

#define             SDFLAG_PREVNAME_SECTION_FOUND     0x00000001
#define             SDFLAG_CDM_DRIVER                 0x00000002

typedef struct  _PARSEINF_INFO {

    PLATFORM            platform;
    LPTSTR              pszInstallSection;  // Can be platform dependent
    LPTSTR              pszzICMFiles;
    LPTSTR              pszPrintProc;
    LPTSTR              pszVendorSetup;
    LPTSTR              pszVendorInstaller;
    DWORD               cbDriverInfo6;
    DRIVER_INFO_6       DriverInfo6;
} PARSEINF_INFO, *PPARSEINF_INFO;

typedef struct _PNP_INFO {

    LPTSTR              pszPortName;
    LPTSTR              pszDeviceInstanceId;
} PNP_INFO, *PPNP_INFO;

#define             VALID_INF_INFO      0x00000001
#define             VALID_PNP_INFO      0x00000002
//
// Set if the installation files are copied into a directory whose name is derived from
// the pnp ID. Since the spooler copies files around, setupapi can't find the files anymore
// when the device is re-pnp'd and prompts the user for them. We copy the files into this directory
// and don't delete it, that way setupapi can find them.
//
#define LOCALDATAFLAG_PNP_DIR_INSTALL   0x00000004


typedef struct  _PSETUP_LOCAL_DATA {

    SELECTED_DRV_INFO   DrvInfo;
    DWORD               signature;
    DWORD               Flags;
    PARSEINF_INFO       InfInfo;
    PNP_INFO            PnPInfo;
} PSETUP_LOCAL_DATA;

//
// Global data
//
extern OSVERSIONINFO        OsVersionInfo;
extern LCID                 lcid;
extern DWORD                dwThisMajorVersion;
extern TCHAR                sComma;
extern TCHAR                sZero;
extern const GUID           GUID_DEVCLASS_PRINTER;
extern PLATFORM             MyPlatform;
extern HINSTANCE            ghInst;
extern SPLPLATFORMINFO      PlatformEnv[], PlatformOverride[];
extern DWORD                PlatformArch[][2];
extern TCHAR                cszNtprintInf[];
extern TCHAR                cszDataSection[];
extern TCHAR                cszComma[];
extern ULONG_PTR            DriverInfo6Offsets[];
extern ULONG_PTR            LocalDataOffsets[];
extern ULONG_PTR            InfInfoOffsets[];
extern ULONG_PTR            SharedInfInfoOffsets[];
extern ULONG_PTR            PnPInfoOffsets[];
extern TCHAR                cszWebNTPrintPkg[];
extern PCODEDOWNLOADINFO    gpCodeDownLoadInfo;
extern TCHAR                cszCatExt[];
extern TCHAR                cszInfExt[];
extern CRITICAL_SECTION     CDMCritSect;

extern CRITICAL_SECTION     SkipCritSect;
extern LPTSTR               gpszSkipDir;

extern TCHAR                cszHardwareID[];
extern TCHAR                cszBestDriverInbox[];
extern TCHAR                cszPnPKey[];
extern TCHAR                cszDeviceInstanceId[];

extern TCHAR                cszMonitorKey[];


//
// Function prototypes
//
VOID
GetDriverPath(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDriverPath[MAX_PATH]
    );

DWORD
InvokeSetup(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszOption,
    IN  LPCTSTR     pszInfFile,
    IN  LPCTSTR     pszSourcePath,
    IN  LPCTSTR     pszServerName       OPTIONAL
    );

PVOID
LocalAllocMem(
        IN UINT cbSize
        );

VOID
LocalFreeMem(
    IN PVOID pMem
    );

LPTSTR
AllocStr(
    IN LPCTSTR  pszStr
    );

DWORD
InstallWin95Driver(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModel,
    IN      LPCTSTR     pszzPreviousNames,
    IN      BOOL        bPreviousNamesSection,
    IN      LPCTSTR     pszServerName,
    IN  OUT LPTSTR      pszInfPath,
    IN      LPCTSTR     pszDiskName,
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags
    );

VOID
InfGetString(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    );

LPTSTR
GetStringFromRcFile(
    UINT    uId
    );

LPTSTR
GetLongStringFromRcFile(
    UINT    uId
    );

BOOL
SetSelectDevParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  BOOL                bWin95,
    IN  LPCTSTR             pszModel    OPTIONAL
    );

BOOL
SetDevInstallParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  LPCTSTR             pszDriverPath   OPTIONAL
    );

HDEVINFO
CreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    );

LPDRIVER_INFO_6
Win95DriverInfo6FromName(
    IN  HDEVINFO    hDevInfo,
    IN  PPSETUP_LOCAL_DATA*  ppLocalData,
    IN  LPCTSTR     pszModel,
    IN  LPCTSTR     pszzPreviousNames
    );

BOOL
CopyPrinterDriverFiles(
    IN  LPDRIVER_INFO_6     pDriverInfo6,
    IN  LPCTSTR             pszInfName,
    IN  LPCTSTR             pszSourcePath,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszTargetPath,
    IN  HWND                hwnd,
    IN  DWORD               dwInstallFlags,
    IN  BOOL                bForgetSource
    );

BOOL
ParseInf(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags
    );

BOOL
BuildClassDriverList(
    IN HDEVINFO    hDevInfo
    );

DWORD
InstallDriverFromCurrentInf(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  HWND                hwnd,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HSPFILEQ            CopyQueue,
    IN  PVOID               QueueContext,
    IN  PSP_FILE_CALLBACK   InstallMsgHandler,
    IN  DWORD               Flags,
    IN  LPCTSTR             pszSource,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    IN  LPCTSTR             pszFileSrcPath, // can be different from INF source in case we had to decompress NT4 CD-ROM inf
    OUT LPTSTR             *ppszNewModelName,
    OUT PDWORD              pBlockingInfo
    );

HRESULT
IsProductType(
    IN  BYTE  ProductType,
    IN  BYTE  Comparison
);

#if         0
BOOL
CopyOEMInfFileAndGiveUniqueName(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  LPTSTR              pszInfFile
    );
#endif

BOOL
AddPrintMonitor(
    IN  LPCTSTR     pszName,
    IN  LPCTSTR     pszDllName
    );

BOOL
FindPathOnSource(
    IN      LPCTSTR     pszFileName,
    IN      HINF        MasterInf,
    IN OUT  LPTSTR      pszPathOnSource,
    IN      DWORD       dwLen,
    OUT     LPTSTR     *ppszMediaDescription,       OPTIONAL
    OUT     LPTSTR     *ppszTagFile                 OPTIONAL
    );

VOID
DestroyLocalData(
    IN  PPSETUP_LOCAL_DATA   pLocalData
    );

LPDRIVER_INFO_6
CloneDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  DWORD           cbDriverInfo6
    );

PPSETUP_LOCAL_DATA
BuildInternalData(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pSpDevInfoData
    );

VOID
PackDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  LPDRIVER_INFO_6 pTargetDriverInfo6,
    IN  DWORD           cbDriverInfo6
    );

BOOL
InfGetDependentFilesAndICMFiles(
    IN      HDEVINFO            hDevInfo,
    IN      HINF                hInf,
    IN      BOOL                bWin95,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      LPCTSTR             pszSectionNameWithExt,
    IN OUT  LPDWORD             pcchSize
    );

BOOL
IdenticalDriverInfo6(
    IN  LPDRIVER_INFO_6 p1,
    IN  LPDRIVER_INFO_6 p2
    );

BOOL
DeleteAllFilesInDirectory(
    LPCTSTR     pszDir,
    BOOL        bDeleteDir
    );

LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    );

HDEVINFO
GetInfAndBuildDrivers(
    IN  HWND                hwnd,
    IN  DWORD               dwTitleId,
    IN  DWORD               dwDiskId,
    IN  TCHAR               szInfPath[MAX_PATH],
    IN  DWORD               dwInstallFlags,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszDriverName,              OPTIONAL
    OUT PPSETUP_LOCAL_DATA *ppLocalData,                OPTIONAL
    OUT LPTSTR             *ppFileSrcPath               OPTIONAL
    );

BOOL
MyName(
    IN  LPCTSTR     pszServerName
    );

BOOL
CreateDevNodeForPrinter(
    IN  HDEVINFO                hDevInfo,
    IN  PPSETUP_LOCAL_DATA      pLocalData,
    IN  LPCTSTR                 pszPrinterName,
    IN  HANDLE                  hPrinter
    );

VOID
FreeStructurePointers(
    LPBYTE      pStruct,
    PULONG_PTR  pOffSets,
    BOOL        bFreeStruct
    );

BOOL
AddPrinterDriverUsingCorrectLevel(
    IN  LPCTSTR             pszServerName,
    IN  DRIVER_INFO_6       *pDriverInfo6,
    IN  DWORD               dwAddDrvFlags
    );

BOOL
AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(
    IN     LPCTSTR          pszServerName,            OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     DWORD            dwAddDrvFlags,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    );

BOOL
BlockedDriverPrintUpgUI(
    IN     LPCTSTR          pszServer,                 OPTIONAL
    IN     DRIVER_INFO_6    *pDriverInfo6,
    IN     BOOL             bIsDriverPathFullPath,
    IN     BOOL             bOfferReplacement,
    IN     BOOL             bPopupUI,
       OUT LPTSTR           *ppszReplacementDriver,
       OUT DWORD            *pdwBlockingStatus
    );

BOOL
InfIsCompatibleDriver(
    IN     LPCTSTR          pszDriverModel,
    IN     LPCTSTR          pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR          pszEnvironment,
    IN     HINF             hInf,       
       OUT DWORD            *pdwBlockingStatus,
       OUT LPTSTR           *ppszReplacementDriver    OPTIONAL // caller must free it.
    );
    
BOOL
FileExists(
    IN  LPCTSTR  pszFileName
    );

BOOL
SetPnPInfoForPrinter(
    IN  HANDLE      hPrinter,
    IN  LPCTSTR     pszDeviceInstanceId,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszOEMUrl
    );

BOOL
IsRunningNtServer(
    VOID
    );

BOOL
InstallAllInfSections(
   IN  PPSETUP_LOCAL_DATA  pLocalData,
   IN  PLATFORM            platform,
   IN  LPCTSTR             pszServerName,
   IN  HSPFILEQ            CopyQueue,
   IN  LPCTSTR             pszSource,
   IN  DWORD               dwInstallFlags,
   IN  HINF                hInf,
   IN  LPCTSTR             pszInstallSection
   );

LPTSTR
CheckForCatalogFile(
   IN  HINF     hInf,
   IN  BOOL     bOnlyFromINF,
   IN  LPCTSTR  pszSource
);

BOOL
SetTargetDirectories(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  HINF                hInf,
    IN  DWORD               dwInstallFlags
    );

BOOL
IsMonitorFound(
    IN  LPVOID  pBuf,
    IN  DWORD   dwReturned,
    IN  LPTSTR  pszName
    );

BOOL
IsMonitorInstalled(
   IN LPTSTR pszMonitorName
   );

BOOL
IsLanguageMonitorInstalled(
   IN PCTSTR pszMonitorName
   );

BOOL
CleanupUniqueScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    );

BOOL
CleanupScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    );

BOOL
InitCodedownload(
    HWND    hwnd
    );

VOID
DestroyCodedownload(
    PCODEDOWNLOADINFO   pCodeDownLoadInfo
    );

BOOL
DestroyOnlyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    );

LPTSTR
GetSystemInstallPath(
    VOID
    );

PPSETUP_LOCAL_DATA
RebuildDeviceInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszSource
    );

BOOL
SetupSkipDir(
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName
    );

void
CleanupSkipDir(
    VOID
    );

LPTSTR
AllocAndCatStr(
    IN  LPCTSTR  pszStr1,
    IN  LPCTSTR  pszStr2
    );

LPTSTR
AllocAndCatStr2(
    IN LPCTSTR  pszStr1,
    IN LPCTSTR  pszStr2,
    IN LPCTSTR  pszStr3
    );

LPTSTR
AllocStrWCtoTC(
    IN LPWSTR lpStr
    );

VOID
PSetupKillBadUserConnections(
    VOID
    );

DWORD
PSetupInstallInboxDriverSilently(
    IN      LPCTSTR     pszDriverName
    );

BOOL
PruneInvalidFilesIfNotAdmin(
    IN     HWND      hWnd,
    IN OUT HSPFILEQ  CopyQueue
    );

BOOL
AddDirectoryTag(
        IN LPTSTR pszDir,
        IN DWORD  dwSize
        );

BOOL
AddPnpDirTag(
        IN LPTSTR     pszHardwareId,
        IN OUT LPTSTR pszDir,
        IN DWORD      dwSize 
        );

BOOL
AddDirToDriverInfo(
        IN LPTSTR          pszDir,
        IN LPDRIVER_INFO_6 pDriverInfo6
        );

VOID
GetCDRomDrive(
    TCHAR   szDrive[5]
    );

BOOL
IsSystemUpgradeInProgress(
    VOID
    );

BOOL
IsSystemSetupInProgress(
        VOID
        );

BOOL
IsSpoolerRunning(
    VOID
    );

LPTSTR
GetMyTempDir(
    VOID
    );

BOOL
IsNTPrintInf(
    IN LPCTSTR pszInfName
    );

BOOL
IsSystemNTPrintInf(
    IN LPCTSTR pszInfName
    );

PVOID
SetupDriverSigning(
    IN HDEVINFO hDevInfo,
    IN LPCTSTR   pszServerName,
    IN LPTSTR    pszInfName,
    IN LPCTSTR   pszSource,
    IN PLATFORM  platform,
    IN DWORD     dwVersion,
    IN HSPFILEQ  CopyQueue,
    IN BOOL      bWeb
    );

BOOL
IsLocalAdmin(
    OUT BOOL    *pbAdmin
    );

BOOL
GetCatalogFile(
    IN  HANDLE   hDriverSigning,
    OUT PCWSTR   *ppszCat
    );

BOOL
DrvSigningIsLocalAdmin(
    IN  HANDLE   hDriverSigning,
    OUT BOOL     *pbIsLocalAdmin
    );

BOOL
AddDriverCatalogIfNotAdmin(
    IN PCWSTR   pszServer,
    IN HANDLE   hDriverSigningInfo,
    IN PCWSTR   pszInfPath,
    IN PCWSTR   pszSrcLoc,
    IN DWORD    dwMediaType,
    IN DWORD    dwCopyStyle
    );

BOOL
CleanupDriverSigning(
    IN PVOID pDSInfo
    );

BOOL
CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
    );

BOOL
IsCatInInf(
    IN PVOID pDSInfo
    );

BOOL
GetOSVersion(
    IN     LPCTSTR        pszServerName,
    OUT    POSVERSIONINFO pOSVer
    );

BOOL
GetOSVersionEx(
    IN     LPCTSTR          pszServerName,
    OUT    POSVERSIONINFOEX pOSVerEx
    );

BOOL
GetArchitecture(
    IN     LPCTSTR   pszServerName,
    OUT    LPTSTR    pszArch,
    IN OUT LPDWORD   pcArchSize
    );

DWORD
InstallDriverSilently(
    IN      LPCTSTR     pszInfFile,
    IN      LPCTSTR     pszDriverName,
    IN      LPCTSTR     pszSource
    );

BOOL 
IsInWow64(
    );
BOOL
IsWhistlerOrAbove(
    IN LPCTSTR pszServerName
    );

DWORD
InstallReplacementDriver(
    IN HWND       hwnd, 
    IN LPCTSTR    pszServerName, 
    IN LPCTSTR    pszModelName, 
    IN PLATFORM   platform,
    IN DWORD      version,
    IN DWORD      dwInstallFlags,
    IN DWORD      dwAddDrvFlags
    );

HMODULE LoadLibraryUsingFullPath(
    LPCTSTR lpFileName
    );

BOOL
CheckAndKeepPreviousNames(
    IN  LPCTSTR          pszServer,
    IN  PDRIVER_INFO_6   pDriverInfo6,
    IN  PLATFORM         platform
);

BOOL
IsTheSamePlatform(
    IN  LPCTSTR          pszServer,
    IN PLATFORM          platform
);

LPTSTR 
GetArchitectureName(
    IN     LPCTSTR   pszServerName
);

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\install.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Install.c

Abstract:

    File queue functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 18-Nov-96

Revision History:

--*/

#include "precomp.h"
#include <winsprlp.h>

const TCHAR       szWebDirPrefix[]        = TEXT("\\web\\printers\\");
const TCHAR       szNtPrintInf[]          = TEXT("inf\\ntprint.inf");

//
//  File queue flags, and structure
//
#define     CALLBACK_MEDIA_CHECKED          0x01
#define     CALLBACK_SOURCE_SET             0x02
#define     CALLBACK_PATH_MODIFIED          0x04

typedef struct _FILE_QUEUE_CONTEXT {

    HWND        hwnd;
    PVOID       QueueContext;
    LPCTSTR     pszSource;
    BOOL        dwCallbackFlags;
    DWORD       dwInstallFlags;
    LPCTSTR     pszFileSrcPath;
    TCHAR       szInfPath[MAX_PATH];
    PLATFORM    platform;
    DWORD       dwVersion;

} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;


/*
BOOL
SystemCab(
    LPCTSTR  pszPath
    )
{
    BOOL    bRet = FALSE;
    HKEY    hKey;
    DWORD   dwSize, dwType;
    TCHAR   szCabLocation[MAX_PATH],
            szReg[] = TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup");

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       szReg,
                                       0,
                                       KEY_READ,
                                       &hKey ) ) {
        dwSize = sizeof(szCabLocation);
        if ( ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              TEXT("DriverCachePath"),
                                              NULL,
                                              &dwType,
                                              (LPBYTE)szCabLocation,
                                              &dwSize)                  &&
             dwType == REG_EXPAND_SZ ) {

            bRet = lstrncmpi(szCabLocation, pszPath, lstrlen(pszPath)) == 0;
        }
        RegCloseKey(hKey);
    }

    return bRet;
}
*/


BOOL
FileExistsOnMedia(
    PSOURCE_MEDIA   pSourceMedia
    )
{
    BOOL    bRes                   = FALSE;
    TCHAR   *pszFile               = NULL;
    INT     cbLength               = 0;
    INT     cbAdditionalSymbolsLen = 0;
    DWORD   dwLen1                 = 0;
    DWORD   dwLen2                 = 0;
    LPTSTR  p                      = NULL;
    LPTSTR  q                      = NULL; 


    if ( !pSourceMedia->SourcePath || !*pSourceMedia->SourcePath ||
         !pSourceMedia->SourceFile || !*pSourceMedia->SourceFile )
    {
        goto Cleanup;   
    }

    cbAdditionalSymbolsLen = lstrlen(TEXT("\\")) + lstrlen(TEXT("_")) + 1;
    cbLength = lstrlen(pSourceMedia->SourcePath) + lstrlen(pSourceMedia->SourceFile) + 
               cbAdditionalSymbolsLen;
    if (cbLength == cbAdditionalSymbolsLen) 
    {
        goto Cleanup;
    }

    //
    // First check if file is there on source path
    //
    pszFile = LocalAllocMem(cbLength * sizeof(TCHAR));
    if (!pszFile) 
    {
        goto Cleanup;
    }
    lstrcpy(pszFile, pSourceMedia->SourcePath);
    dwLen1 = lstrlen(pszFile);
    if  ( *(pszFile + (dwLen1-1)) != TEXT('\\') ) 
    {
        *(pszFile + dwLen1) = TEXT('\\');
        ++dwLen1;
    }

    lstrcpy(pszFile + dwLen1, pSourceMedia->SourceFile);
    dwLen2 = dwLen1 + lstrlen(pSourceMedia->SourceFile);

    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    p = lstrchr(pszFile, TEXT('.'));
    q = lstrchr(pszFile, TEXT('\\'));

    //
    // A dot present in filename?
    //
    if ( q < p ) 
    {
        //
        // For files with 0, 1, 2 characters after the dot append underscore
        //
        if ( lstrlen(p) < 4 ) 
        {

            *(pszFile + dwLen2) = TEXT('_');
            ++dwLen2;
            *(pszFile + dwLen2) = TEXT('\0');
        } 
        else 
        {
            //
            // If 3+ characters after dot then replace last character with _
            // to get the compressed file name
            //
            *(pszFile + (dwLen2-1)) = TEXT('_');
        }
    } 
    else 
    {
        //
        // If no dot then replace last character with _ for compressed name
        //
        *(pszFile + (dwLen2-1)) = TEXT('_');
    }

    //
    // Does the compressed file exist on source path?
    //
    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    //
    // Check for the file in compressed form with $ as the character
    //
    *(pszFile + (dwLen2-1)) = TEXT('$');
    bRes = FileExists(pszFile);
    if (bRes)
    {
        goto Cleanup;
    }

    if ( !pSourceMedia->Tagfile || !*pSourceMedia->Tagfile )
    {
        goto Cleanup;
    }

    //
    // Look for tag file
    //
    lstrcpy(pszFile + dwLen1, pSourceMedia->Tagfile);
    bRes = FileExists(pszFile);

Cleanup:

    LocalFreeMem(pszFile);
    return bRes;
}


UINT
MyQueueCallback(
    IN  PVOID     QueueContext,
    IN  UINT      Notification,
    IN  UINT_PTR  Param1,
    IN  UINT_PTR  Param2
    )
{
    PFILE_QUEUE_CONTEXT     pFileQContext=(PFILE_QUEUE_CONTEXT)QueueContext;
    PSOURCE_MEDIA           pSourceMedia;
    LPTSTR                  pszPathOut;
    PFILEPATHS              pFilePaths;


    switch (Notification) {

        case SPFILENOTIFY_NEEDMEDIA:

            pSourceMedia    = (PSOURCE_MEDIA)Param1;
            pszPathOut      = (LPTSTR)Param2;

            //
            // If pszSource is specified then we have a flat share where
            // all the files are available. Setup is looking for the file
            // in the sub-directory (ex. ..\i386) based on the layout info.
            // We need to tell setup to look in the root directory
            //
            if ( !(pFileQContext->dwCallbackFlags & CALLBACK_SOURCE_SET)    &&
                 pFileQContext->pszSource                                   &&
                 lstrcmpi(pFileQContext->pszSource,
                          pSourceMedia->SourcePath) ) {

                    lstrcpy(pszPathOut, pFileQContext->pszSource);
                    pFileQContext->dwCallbackFlags |= CALLBACK_SOURCE_SET;
                    return FILEOP_NEWPATH;
            }

/*
            } else if ( (pFileQContext->dwInstallFlags & DRVINST_CABONLY)  &&
                        !SystemCab(pSourceMedia->SourcePath) ) {

                return FILEOP_ABORT;
            }

            if ( pFileQContext->dwInstallFlags & DRVINST_WEBPNP ) {

                if ( !pFileQContext->bMediaChecked ) {

                    pFileQContext->bMediaChecked = TRUE;
                    return FILEOP_DOIT;
                } else
                    return FILEOP_ABORT;
            }
*/

            //
            // If DRVINST_PROMPTLESS is set then we can't allow prompt
            //
            if ( pFileQContext->dwInstallFlags & DRVINST_PROMPTLESS ) {

                if ( !(pFileQContext->dwCallbackFlags & CALLBACK_MEDIA_CHECKED) ) {

                    pFileQContext->dwCallbackFlags |= CALLBACK_MEDIA_CHECKED;
                    if ( FileExistsOnMedia(pSourceMedia) )
                        return FILEOP_DOIT;
                }

                return FILEOP_ABORT;
            }

            //
            // If we do a non-native platform install and the user points
            // to a server CD, the inf will specify a subdir \i386 which is
            // correct on an installed machine but not on a CD. Remove that dir
            // and try again.
            //
            if ( (pFileQContext->dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL) &&
                !(pFileQContext->dwCallbackFlags & CALLBACK_PATH_MODIFIED))
            {
                LPSTR pCur;
                size_t  Pos, Len, OverrideLen;

                //
                // for NT4 installations we have possibly expanded the INF
                // from a server CD. Point there if that's the case
                //
                if ((pFileQContext->dwVersion == 2) &&
                    (pFileQContext->pszFileSrcPath))
                {
                    Len = _tcslen(pFileQContext->szInfPath);

                    if (_tcsnicmp(pSourceMedia->SourcePath,
                                  pFileQContext->szInfPath, Len) == 0)
                    {
                        _tcscpy(pszPathOut, pFileQContext->pszFileSrcPath);

                        pFileQContext->dwCallbackFlags |= CALLBACK_PATH_MODIFIED;

                        return FILEOP_NEWPATH;
                    }
                }

                //
                // Find the spot where the platform ID begins
                //
                Pos = Len = _tcslen(pFileQContext->szInfPath);

                //
                // sanity check
                //
                if (_tcslen(pSourceMedia->SourcePath) <= Len)
                    goto Default;

                if (pSourceMedia->SourcePath[Len] == _T('\\'))
                {
                    Pos++;
                }

                OverrideLen = _tcslen(PlatformOverride[pFileQContext->platform].pszName);

                if (_tcsnicmp(pSourceMedia->SourcePath,
                              pFileQContext->szInfPath, Len) == 0 &&
                    _tcsnicmp(&(pSourceMedia->SourcePath[Pos]),
                              PlatformOverride[pFileQContext->platform].pszName,
                              OverrideLen) == 0)
                {
                    _tcscpy(pszPathOut, pFileQContext->szInfPath);

                    pFileQContext->dwCallbackFlags |= CALLBACK_PATH_MODIFIED;

                    return FILEOP_NEWPATH;
                }


            }
            goto Default;

        case SPFILENOTIFY_STARTCOPY:
            pFilePaths = (PFILEPATHS)Param1;
            if ( gpszSkipDir &&
                 !lstrncmpi(gpszSkipDir, pFilePaths->Target, lstrlen(gpszSkipDir)) )
                return FILEOP_SKIP;

            goto Default;

        case SPFILENOTIFY_ENDCOPY:
            // Here we set the bMediaChecked flag to FALSE, this is because some OEM drivers
            // have more than one media, so we assume NEEDMEDIA,STARTCOPY,ENDCOPY,NEEDMEDIA
            // So if we reset the NEEDMEDIA flag after the ENDCOPY, we are OK

            //
            // Clear the per file flags
            //
            pFileQContext->dwCallbackFlags  &= ~(CALLBACK_MEDIA_CHECKED |
                                                 CALLBACK_SOURCE_SET |
                                                 CALLBACK_PATH_MODIFIED);
            goto Default;

        case SPFILENOTIFY_COPYERROR:

            pFilePaths = (PFILEPATHS)Param1;
            // If there is a copy error happens in webpnp, we force it retry
            // the orginal flat directory
            if ( pFileQContext->dwInstallFlags & DRVINST_WEBPNP) {

                 pszPathOut = (LPTSTR)Param2;

                 // We need to make sure the path used in the copy operation is not as same as we're going
                 // to replace, otherwise, it will go to indefinite loop.
                 //
                 if (lstrncmpi(pFileQContext->pszSource, pFilePaths->Source, lstrlen(pFileQContext->pszSource)) ||
                     lstrchr (pFilePaths->Source + lstrlen(pFileQContext->pszSource) + 1, TEXT ('\\'))) {

                    lstrcpy(pszPathOut, pFileQContext->pszSource);
                    return FILEOP_NEWPATH;
                 }
            }
            goto Default;

    }

Default:
    return SetupDefaultQueueCallback(pFileQContext->QueueContext,
                                     Notification,
                                     Param1,
                                     Param2);
}

VOID
CheckAndEnqueueOneFile(
    IN      LPCTSTR     pszFileName,
    IN      LPCTSTR     pszzDependentFiles, OPTIONAL
    IN      HSPFILEQ    CopyQueue,
    IN      LPCTSTR     pszSourcePath,
    IN      LPCTSTR     pszTargetPath,
    IN      LPCTSTR     pszDiskName,        OPTIONAL
    IN OUT  LPBOOL      lpFail
)
/*++

Routine Description:
    Ensure that a file is enqueue only once for copying. To do so we check
    if the given file name also appears in the list of dependent files and
    enqueue it only if it does not.

Arguments:
    pszFileName         : File name to be checked and enqueued
    pszzDependentFiles  : Dependent files (multi-sz) list
    pszSourcePath       : Source directory to look for the files
    pszTargetPath       : Target directory to copy the files to
    pszDiskName         : Title of the disk where files are
    lpBool              : Will be set to TRUE on error

Return Value:
    Nothing

--*/
{
    LPCTSTR  psz;

    if ( *lpFail )
        return;

    //
    // If the file also appears as a dependent file do not enqueue it
    //
    if ( pszzDependentFiles ) {

        for ( psz = pszzDependentFiles ; *psz ; psz += lstrlen(psz) + 1 )
            if ( !lstrcmpi(pszFileName, psz) )
                return;
    }

    *lpFail = !SetupQueueCopy(
                    CopyQueue,
                    pszSourcePath,
                    NULL,           // Path relative to source
                    pszFileName,
                    pszDiskName,
                    NULL,           // Source Tag file
                    pszTargetPath,
                    NULL,           // Target file name
                    0);             // Copy style flags
}


BOOL
CopyPrinterDriverFiles(
    IN  LPDRIVER_INFO_6     pDriverInfo6,
    IN  LPCTSTR             pszInfName,
    IN  LPCTSTR             pszSourcePath,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszTargetPath,
    IN  HWND                hwnd,
    IN  DWORD               dwInstallFlags,
    IN  BOOL                bForgetSource
    )
/*++

Routine Description:
    Copy printer driver files to a specified directory using SetupQueue APIs

Arguments:
    pDriverInfo6    : Points to a valid SELECTED_DRV_INFO
    szTargetPath    : Target directory to copy to
    szSourcePath    : Source directory to look for the files, if none is
                      specified will use the one from prev. operation
    pszDiskName     : Title of the disk where files are
    hwnd            : Windows handle of current top-level window
    bForgetSource   : TRUE if the path where driver files were copied from
                      should not be remembered for future use

Return Value:
    TRUE    on succes
    FALSE   else, use GetLastError() to get the error code

--*/
{
    HSPFILEQ            CopyQueue;
    BOOL                bFail = FALSE;
    DWORD               dwOldCount, dwNewCount, dwIndex;
    LPTSTR              psz, *List = NULL;
    FILE_QUEUE_CONTEXT  FileQContext;

    //
    // Valid DriverInfo6
    //
    if ( !pDriverInfo6                  ||
         !pDriverInfo6->pDriverPath     ||
         !pDriverInfo6->pDataFile       ||
         !pDriverInfo6->pConfigFile )
        return FALSE;

    //
    // If no additions should be made to the source list findout the count
    //
    if ( bForgetSource ) {

        dwOldCount = 0;
        if ( !SetupQuerySourceList(SRCLIST_USER | SRCLIST_SYSTEM,
                                   &List, &dwOldCount) ) {

            return FALSE;
        }

        SetupFreeSourceList(&List, dwOldCount);
    }

    //
    // Create a setup file copy queue and initialize setup queue callback
    //
    ZeroMemory(&FileQContext, sizeof(FileQContext));
    FileQContext.hwnd           = hwnd;
    FileQContext.pszSource      = NULL;
    FileQContext.dwInstallFlags = dwInstallFlags;

    if ( dwInstallFlags & DRVINST_PROGRESSLESS ) {

        FileQContext.QueueContext   = SetupInitDefaultQueueCallbackEx(
                                            hwnd,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);
    } else {

        FileQContext.QueueContext   = SetupInitDefaultQueueCallback(hwnd);
    }

    CopyQueue                   = SetupOpenFileQueue();

    if ( CopyQueue == INVALID_HANDLE_VALUE || !FileQContext.QueueContext )
        goto Cleanup;

    CheckAndEnqueueOneFile(pDriverInfo6->pDriverPath,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    CheckAndEnqueueOneFile(pDriverInfo6->pDataFile,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    CheckAndEnqueueOneFile(pDriverInfo6->pConfigFile,
                           pDriverInfo6->pDependentFiles,
                           CopyQueue,
                           pszSourcePath,
                           pszTargetPath,
                           pszDiskName,
                           &bFail);

    if ( pDriverInfo6->pHelpFile && *pDriverInfo6->pHelpFile )
        CheckAndEnqueueOneFile(pDriverInfo6->pHelpFile,
                               pDriverInfo6->pDependentFiles,
                               CopyQueue,
                               pszSourcePath,
                               pszTargetPath,
                               pszDiskName,
                               &bFail);

    //
    // Add each file in the dependent files field to the setup queue
    //
    if ( pDriverInfo6->pDependentFiles ) {

        for ( psz = pDriverInfo6->pDependentFiles ;
              *psz ;
              psz += lstrlen(psz) + 1 )

            CheckAndEnqueueOneFile(psz,
                                   NULL,
                                   CopyQueue,
                                   pszSourcePath,
                                   pszTargetPath,
                                   pszDiskName,
                                   &bFail);

    }

    if ( bFail )
        goto Cleanup;

    {
       // Before adding files to the File Queue set the correct Platform/Version
       //  info for Driver Signing
       // Setup the structure for SETUPAPI
       SP_ALTPLATFORM_INFO AltPlat_Info;
       HINF                hInf;
       TCHAR               CatalogName[ MAX_PATH ];
       LPTSTR              pszCatalogFile = NULL;

       AltPlat_Info.cbSize                     = sizeof(SP_ALTPLATFORM_INFO);
       AltPlat_Info.Platform                   =  VER_PLATFORM_WIN32_WINDOWS;
       AltPlat_Info.MajorVersion               = 4;
       AltPlat_Info.MinorVersion               = 0;
       AltPlat_Info.ProcessorArchitecture      = PROCESSOR_ARCHITECTURE_INTEL;
       AltPlat_Info.Reserved                   = 0;
       AltPlat_Info.FirstValidatedMajorVersion = AltPlat_Info.MajorVersion;
       AltPlat_Info.FirstValidatedMinorVersion = AltPlat_Info.MinorVersion;

       if ( CheckForCatalogFileInInf(pszInfName, &pszCatalogFile) && pszCatalogFile )
       {
           if ( (lstrlen(pszSourcePath)+lstrlen(pszCatalogFile)+2) < MAX_PATH )
           {
               lstrcpy( CatalogName, pszSourcePath );
               lstrcat( CatalogName, TEXT("\\") );
               lstrcat( CatalogName, pszCatalogFile );
           }
           else
           {
               bFail = TRUE;
           }

           LocalFreeMem( pszCatalogFile );
           pszCatalogFile = CatalogName;
       }

       if (bFail)
          goto Cleanup;


       // Now call the Setup API to change the parms on the FileQueue
       bFail = !SetupSetFileQueueAlternatePlatform( CopyQueue, &AltPlat_Info, pszCatalogFile );

    }

    if ( bFail )
        goto Cleanup;

    bFail = !SetupCommitFileQueue(hwnd,
                                  CopyQueue,
                                  MyQueueCallback,
                                  &FileQContext);

    //
    // If bForegetSource is set fix source list
    //
    if ( bForgetSource &&
         SetupQuerySourceList(SRCLIST_USER | SRCLIST_SYSTEM,
                              &List, &dwNewCount) ) {

         dwOldCount = dwNewCount - dwOldCount;
         if ( dwOldCount < dwNewCount )
         for ( dwIndex = 0 ; dwIndex < dwOldCount ; ++dwIndex ) {

            SetupRemoveFromSourceList(SRCLIST_SYSIFADMIN,
                                      List[dwIndex]);
         }

        SetupFreeSourceList(&List, dwNewCount);
    }
Cleanup:

    if ( CopyQueue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue(CopyQueue);

    if ( FileQContext.QueueContext )
        SetupTermDefaultQueueCallback(FileQContext.QueueContext);

    return !bFail;
}


BOOL
AddPrinterDriverUsingCorrectLevel(
    IN  LPCTSTR         pszServerName,
    IN  LPDRIVER_INFO_6 pDriverInfo6,
    IN  DWORD           dwAddDrvFlags
    )
{
    BOOL    bReturn;
    DWORD   dwLevel;

    bReturn = AddPrinterDriverEx((LPTSTR)pszServerName,
                                 6,
                                 (LPBYTE)pDriverInfo6,
                                 dwAddDrvFlags );

    for ( dwLevel = 4 ;
          !bReturn && GetLastError() == ERROR_INVALID_LEVEL && dwLevel > 1 ;
          --dwLevel ) {

        //
        // Since DRIVER_INFO_2, 3, 4 are subsets of DRIVER_INFO_6 and all fields
        // are at the beginning these calls can be made with same buffer
        //
        bReturn = AddPrinterDriverEx((LPTSTR)pszServerName,
                                   dwLevel,
                                   (LPBYTE)pDriverInfo6,
                                   dwAddDrvFlags);
    }

    return bReturn;
}


typedef struct _MONITOR_SCAN_INFO {

    LPTSTR  pszMonitorDll;
    LPTSTR  pszTargetDir;
    BOOL    bFound;
} MONITOR_SCAN_INFO, *PMONITOR_SCAN_INFO;


UINT
MonitorCheckCallback(
    IN  PVOID    pContext,
    IN  UINT     Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:
    This callback routine is to check language monitor dll is getting copied
    to system32 directory.

Arguments:
    pContext        : Gives the MONITOR_SCAN_INFO structure
    Notification    : Ignored
    Param1          : Gives the target file name
    Param2          : Ignored

Return Value:
    Win32 error code

--*/
{
    size_t              dwLen;
    LPTSTR              pszTarget = (LPTSTR)Param1, pszFileName;
    PMONITOR_SCAN_INFO  pScanInfo = (PMONITOR_SCAN_INFO)pContext;

    if ( !pScanInfo->bFound ) {

        if ( !(pszFileName = FileNamePart(pszTarget)) )
            return ERROR_INVALID_PARAMETER;

        if ( !lstrcmpi(pScanInfo->pszMonitorDll, pszFileName) ) {

            //
            // Length excludes \ (i.e. D:\winnt\system32)
            //
            dwLen = (size_t)(pszFileName - pszTarget - 1);
            if ( !lstrncmpi(pScanInfo->pszTargetDir, pszTarget, dwLen)  &&
                 dwLen == (DWORD) lstrlen(pScanInfo->pszTargetDir) )
                pScanInfo->bFound = TRUE;
        }
    }

    return NO_ERROR;
}


BOOL
CheckAndEnqueueMonitorDll(
    IN  LPCTSTR     pszMonitorDll,
    IN  LPCTSTR     pszSource,
    IN  HSPFILEQ    CopyQueue,
    IN  HINF        hInf
    )
/*++

Routine Description:
    This routine is to check language monitor dll is getting copied to system32
    directory. On NT 4.0 we did not list LM as a file to be copied. ntprint.dll
    automatically did it. Now we use a DRID for it. But for backward
    compatibility this routine is there to get NT 4.0 INFs to work.

Arguments:
    pszMonitorDll   : Monitor dll to enqueue
    pszSource       : Source directory to look for files
    CopyQueue       : File queue
    hInf            : Printer driver INF file handle

Return Value:
    TRUE    on success, FALSE else

--*/
{
    BOOL                bRet = FALSE;
    DWORD               dwNeeded;
    LPTSTR              pszPathOnSource = NULL, pszDescription = NULL,
                        pszTagFile = NULL;
    TCHAR               szDir[MAX_PATH];
    MONITOR_SCAN_INFO   ScanInfo;
    SP_FILE_COPY_PARAMS FileCopyParams = {0};

    if ( !GetSystemDirectory(szDir, SIZECHARS(szDir)) )
        goto Cleanup;

    ScanInfo.pszMonitorDll  = (LPTSTR)pszMonitorDll;
    ScanInfo.pszTargetDir   = szDir;
    ScanInfo.bFound         = FALSE;

    if ( !SetupScanFileQueue(CopyQueue,
                             SPQ_SCAN_USE_CALLBACK,
                             0,
                             MonitorCheckCallback,
                             &ScanInfo,
                             &dwNeeded) )
        goto Cleanup;

    if ( !ScanInfo.bFound ) {

        pszPathOnSource = (LPTSTR) LocalAllocMem(MAX_PATH * sizeof(TCHAR));
        if ( !pszPathOnSource )
            goto Cleanup;

        //
        // This gives which subdirectory to look for. By default in same dir
        //
        if ( !FindPathOnSource(pszMonitorDll, hInf,
                               pszPathOnSource, MAX_PATH,
                               &pszDescription, &pszTagFile) ) {

            LocalFreeMem(pszPathOnSource);
            pszPathOnSource = NULL;
        }

        FileCopyParams.cbSize             = sizeof( SP_FILE_COPY_PARAMS );
        FileCopyParams.QueueHandle        = CopyQueue;
        FileCopyParams.SourceRootPath     = pszSource;
        FileCopyParams.SourcePath         = pszPathOnSource;
        FileCopyParams.SourceFilename     = pszMonitorDll;
        FileCopyParams.SourceDescription  = pszDescription;
        FileCopyParams.SourceTagfile      = pszTagFile;
        FileCopyParams.TargetDirectory    = szDir;
        FileCopyParams.TargetFilename     = NULL;
        FileCopyParams.CopyStyle          = SP_COPY_NEWER;
        FileCopyParams.LayoutInf          = hInf;
        FileCopyParams.SecurityDescriptor = NULL;

        if ( !SetupQueueCopyIndirect(&FileCopyParams) )
        {
            goto Cleanup;
        }
    }

    bRet = TRUE;

Cleanup:
    LocalFreeMem(pszPathOnSource);
    LocalFreeMem(pszDescription);
    LocalFreeMem(pszTagFile);

    return bRet;
}


BOOL
GetWebPageDir(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDir[MAX_PATH]
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLen;

    if ( !GetSystemWindowsDirectory(szDir, MAX_PATH) )
        goto Done;

    dwLen = lstrlen(szDir) + lstrlen(szWebDirPrefix)
                           + lstrlen(pLocalData->DrvInfo.pszManufacturer)
                           + lstrlen(pLocalData->DrvInfo.pszModelName)
                           + 2;

    if ( dwLen >= MAX_PATH ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Done;
    }

    lstrcat(szDir, szWebDirPrefix);
    lstrcat(szDir, pLocalData->DrvInfo.pszManufacturer);
    lstrcat(szDir, TEXT("\\"));
    lstrcat(szDir, pLocalData->DrvInfo.pszModelName);
    bRet = TRUE;

Done:
    return bRet;
}

BOOL
SetTargetDirectories(
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  HINF                hInf,
    IN  DWORD               dwInstallFlags
    )
/*++

Routine Description:
    Set all the target directories listed in the INF file for file copy
    operations. Also gets the source directory where we should look for
    driver files

Arguments:
    hDevInfo        : Handle to printer device info list
    pLocalData      : INF parsing information
    platform        : Gives the platform
    pszSource       : Source directory to look for files
    CopyQueue       : File queue
    hInf            : Printer driver INF file handle
    dwInstallFlags  : Driver installation flags

Return Value:
    TRUE    on success, FALSE else

--*/
{
    BOOL                bRet=FALSE;
    DWORD               dwNeeded, dwIndex, dwIndex2, dwCount, dwCount2;
    INT                 DRID;
    TCHAR               szDir[MAX_PATH];
    INFCONTEXT          InfContext;

    if ( (dwCount = SetupGetLineCount(hInf, TEXT("DestinationDirs"))) == -1 )
        goto Cleanup;

    // Setup the Skip Dir
    if ( !SetupSkipDir( platform, pszServerName ) )
        goto Cleanup;

    //
    // Process every line in the DestinationDirs section
    //
    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        if ( !SetupGetLineByIndex(hInf, TEXT("DestinationDirs"),
                                  dwIndex, &InfContext) )
            goto Cleanup;

        //
        // A file could be copied to multiple destination directories
        //
        if ( (dwCount2 = SetupGetFieldCount(&InfContext)) == -1 )
            continue;

        for ( dwIndex2 = 1 ; dwIndex2 <= dwCount2 ; ++dwIndex2 ) {

            //
            // Not all directories are specified with a DRID
            // for ex. %ProgramFiles%\%OLD_ICWDIR% could be used
            // If DRID is smaller than DIRID_USER setup has predefined
            // meaning to it
            //
            if ( !SetupGetIntField(&InfContext, dwIndex2, &DRID)    ||
                 DRID < DIRID_USER )
                continue;

            if ( DRID < DIRID_USER )
                continue;

            dwNeeded = SIZECHARS(szDir);

            switch (DRID) {

                case PRINTER_DRIVER_DIRECTORY_ID:
                    if ( !GetPrinterDriverDirectory(
                                (LPTSTR)pszServerName,
                                PlatformEnv[platform].pszName,
                                1,
                                (LPBYTE)szDir,
                                sizeof(szDir),
                                &dwNeeded) )
                    {
                        goto Cleanup;
                    }
                    if ( dwInstallFlags & DRVINST_PRIVATE_DIRECTORY ) 
                    {                        
                        //
                        // if we have a pnp-ID, and it's an installation of a native driver
                        // and it's not an inbox driver, make the files stick around for 
                        // pnp-reinstallations, else the user gets prompted over and over again
                        //
                        if ((lstrlen(pLocalData->DrvInfo.pszHardwareID) != 0)   &&
                            !(dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL)    &&
                            !IsSystemNTPrintInf(pLocalData->DrvInfo.pszInfName))
                        {
                            //
                            // add the pnp-ID to szDir and set flag to not clean up this directory
                            // this is to get around users getting prompted for pnp-reinstallation
                            //
                            AddPnpDirTag( pLocalData->DrvInfo.pszHardwareID, szDir, sizeof(szDir)/sizeof(TCHAR));

                            pLocalData->Flags |= LOCALDATAFLAG_PNP_DIR_INSTALL;
                        }
                        else
                        {
                            //
                            // Add PID\TID to szDir.
                            // If this fails, add the dir info held in szDir to the DRIVER_INFO struct
                            // anyway as we'll attempt the install with this.
                            //
                            AddDirectoryTag( szDir, sizeof(szDir)/sizeof(TCHAR) );

                        }
                        ASSERT(pLocalData);

                        //
                        // Change DI6 to have the full szDir path included.
                        // Can't do anything if this fails, so try finish install anyway.
                        //
                        AddDirToDriverInfo( szDir, &(pLocalData->InfInfo.DriverInfo6) );

                    }
                    break;

                case PRINT_PROC_DIRECTORY_ID:
                    if ( dwInstallFlags & DRVINST_DRIVERFILES_ONLY ) {

                        lstrcpy(szDir, gpszSkipDir);
                    } else if ( !GetPrintProcessorDirectory(
                                    (LPTSTR)pszServerName,
                                    PlatformEnv[platform].pszName,
                                    1,
                                    (LPBYTE)szDir,
                                    sizeof(szDir),
                                    &dwNeeded) )
                        goto Cleanup;

                    break;

                case SYSTEM_DIRECTORY_ID_ONLY_FOR_NATIVE_ARCHITECTURE:
                    if ( !(dwInstallFlags & DRVINST_DRIVERFILES_ONLY)   &&
                         platform == MyPlatform                         &&
                         MyName(pszServerName) ) {

                        if ( !GetSystemDirectory(szDir, dwNeeded) )
                            goto Cleanup;

                    } else {

                        lstrcpy(szDir, gpszSkipDir);
                    }
                    break;

                case  ICM_PROFILE_DIRECTORY_ID:
                    if ( !GetColorDirectory(pszServerName, szDir, &dwNeeded) )
                        goto Cleanup;
                    break;

                case WEBPAGE_DIRECTORY_ID:
                    if ( !GetWebPageDir(pLocalData, szDir) )
                        goto Cleanup;
                    break;

                default:
                    //
                    // This is for any new DRIDs we may add in the future
                    //
                    lstrcpy(szDir, gpszSkipDir);
            }

            if ( !SetupSetDirectoryId(hInf, DRID, szDir) )
                goto Cleanup;
        }
    }

    bRet = TRUE;

Cleanup:
    return bRet;
}


BOOL
PSetupInstallICMProfiles(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    )
/*++

Routine Description:
    Install ICM color profiles associated with a printer driver.

Arguments:
    pszServerName   : Server name to which we are installing
    pszzICMFiles    : ICM profiles to install (multi-sz)

Return Value:
    TRUE on success, FALSE else

--*/
{
    TCHAR   szDir[MAX_PATH], *p;
    DWORD   dwSize, dwNeeded;
    BOOL    bRet = TRUE;

    if ( !pszzICMFiles || !*pszzICMFiles )
        return bRet;

    dwSize      = SIZECHARS(szDir);
    dwNeeded    = sizeof(szDir);

    if ( !GetColorDirectory(pszServerName, szDir, &dwNeeded) )
        return FALSE;

    dwNeeded           /= sizeof(TCHAR);
    szDir[dwNeeded-1]   = TEXT('\\');

    //
    // Install and assoicate each profiles from the multi-sz field
    //
    for ( p = (LPTSTR) pszzICMFiles; bRet && *p ; p += lstrlen(p) + 1 ) {

        if ( dwNeeded + lstrlen(p) + 1 > dwSize ) {

            ASSERT(dwNeeded + lstrlen(p) + 1 <= dwSize);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        lstrcpy(szDir + dwNeeded, p);

        // This function only supports NULL as the servername
        // bRet = InstallColorProfile(pszServerName, szDir);
        bRet = InstallColorProfile( NULL, szDir);
    }

    return bRet;
}

BOOL
MonitorRedirectDisable(
    IN  LPCTSTR pszMonitorDll,
    OUT PTCHAR  *ppszDir
    )
{
    BOOL   bRet        = FALSE;
    PTCHAR pszBuffer   = NULL;
    DWORD  dwDirLen    = 0; 
    
    if( IsInWow64() )
    {
        pszBuffer = (PTCHAR)LocalAllocMem( MAX_PATH * sizeof( TCHAR ) );

        if((pszBuffer != NULL) && GetSystemDirectory(pszBuffer, MAX_PATH))
        {
            dwDirLen = lstrlen(pszBuffer);

            //
            // Size of the returned string + size of file name + '\' + terminating null. 
            //
            if( (dwDirLen + lstrlen(pszMonitorDll) + 2) < MAX_PATH )
            {
                if( *(pszBuffer + dwDirLen-1) != _T('\\') )
                {
                    *(pszBuffer + dwDirLen++) = _T('\\');
                    *(pszBuffer + dwDirLen)   = 0;
                }
                lstrcat(pszBuffer,pszMonitorDll);
#if !_WIN64
                Wow64DisableFilesystemRedirector(pszBuffer);
#endif
                bRet = TRUE;
            }
        }
        if (ppszDir != NULL)
        {
            *ppszDir = pszBuffer;
        }
    }

    return bRet;
}

BOOL
MonitorRedirectEnable(
    IN OUT PTCHAR *ppszDir
    )
{
    BOOL bRet = FALSE;

    if( IsInWow64() )
    {
        //
        // This MACRO works on the current thread.  Only one file can be disabled for redirection at a time.
        //
#if !_WIN64
        Wow64EnableFilesystemRedirector();
#endif
    }

    if ((ppszDir != NULL) && (*ppszDir != NULL))
    {
        LocalFreeMem( *ppszDir );
        *ppszDir = NULL;
        bRet = TRUE;
    }

    return bRet;
}

BOOL
UseUniqueDirectory(
    IN LPCTSTR pszServerName
    )
/*++

Routine Description:
    Determines whether the unique install directory flags should be used or not.

Arguments:
    pszServerName - the name of the remote server.  NULL means local machine.

Return Value:
    TRUE if we are going remote to a whistler or more recent server
         or we are installing locally but not in setup.
    FALSE else

--*/
{
    BOOL bRet = FALSE;

    if( pszServerName && *pszServerName )
    {
        bRet = IsWhistlerOrAbove(pszServerName);
    }
    else
    {
        if( !IsSystemSetupInProgress() )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

DWORD
PSetupShowBlockedDriverUI(HWND hwnd, 
                          DWORD BlockingStatus)
/*++

Routine Description:
    Throws UI to ask user what to do with a blocked/warned driver

Arguments:
    hwnd: parent window
    BlockingStatus: the DWORD containing the BSP_* flags that indicate whether driver is blocked

Return Value:
    New blocking status, the user selection is OR'd. Treats errors as if the user cancelled.
    
--*/

{
    DWORD NewBlockingStatus = BlockingStatus;
    LPTSTR pszTitle = NULL, pszPrompt = NULL;

    switch (BlockingStatus & BSP_BLOCKING_LEVEL_MASK)
    {
    
    case BSP_PRINTER_DRIVER_WARNED:

        if (BlockingStatus & BSP_INBOX_DRIVER_AVAILABLE)
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_WARN_WITH_INBOX);

            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_YESNOCANCEL | MB_ICONWARNING))
            {
            case IDYES:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_PROCEEDED;
                break;
            case IDNO:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_REPLACED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        else // warned but not inbox available
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_WARN_NO_INBOX);

            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }
            
            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_OKCANCEL | MB_ICONWARNING))
            {
            case IDOK:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_PROCEEDED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        break;
    
    case BSP_PRINTER_DRIVER_BLOCKED:

        if (BlockingStatus & BSP_INBOX_DRIVER_AVAILABLE)
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_WARN);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_BLOCK_WITH_INBOX);
            
            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            switch (MessageBox(hwnd, pszPrompt, pszTitle, MB_OKCANCEL | MB_ICONWARNING))
            {
            case IDOK:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_REPLACED;
                break;
            default:
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                break;
            }
        }
        else // blocked and no inbox available - don't allow installation
        {
            pszTitle  = GetStringFromRcFile(IDS_TITLE_BSP_ERROR);
            pszPrompt = GetLongStringFromRcFile(IDS_BSP_BLOCK_NO_INBOX);
            
            if (!pszTitle || !pszPrompt)
            {
                NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
                goto Cleanup;
            }

            MessageBox(hwnd, pszPrompt, pszTitle, MB_OK | MB_ICONSTOP);
            NewBlockingStatus |= BSP_PRINTER_DRIVER_CANCELLED;
        }
        break;
    }

Cleanup:
    if (pszTitle)
    {
        LocalFreeMem(pszTitle);
    }

    if (pszPrompt)
    {
        LocalFreeMem(pszPrompt);
    }

    return NewBlockingStatus; 
}


DWORD
InstallDriverFromCurrentInf(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  HWND                hwnd,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HSPFILEQ            CopyQueue,
    IN  PVOID               QueueContext,
    IN  PSP_FILE_CALLBACK   InstallMsgHandler,
    IN  DWORD               Flags,
    IN  LPCTSTR             pszSource,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    IN  LPCTSTR             pszFileSrcPath,
    OUT LPTSTR              *ppszNewDriverName,
    OUT PDWORD              pBlockingStatus
)
{
    HINF                 hPrinterInf        = INVALID_HANDLE_VALUE;
    BOOL                 bRet               = FALSE;
    BOOL                 bAddMon            = FALSE;
    BOOL                 bKeepMonName       = FALSE;
    BOOL                 bCatInInf          = FALSE;
    DWORD                dwStatus           = EXIT_FAILURE;
    LPTSTR               pszMonitorDll,
                         psz;
    PSELECTED_DRV_INFO   pDrvInfo           = &pLocalData->DrvInfo;
    PPARSEINF_INFO       pInfInfo           = &pLocalData->InfInfo;
    PVOID                pDSInfo            = NULL;   // Holds pointer to the driver signing class that C can't understand.
    FILE_QUEUE_CONTEXT   FileQContext;

    //
    // The following are only used during Cleanup
    //
    BOOL                bZeroInf  = FALSE,
                        bCopyInf = FALSE;
    DWORD dwMediaType = SPOST_NONE;
    DWORD dwInstallLE = ERROR_SUCCESS;               // We record the LastError in case Cleanup
                                                     // alters it
    LPTSTR pszINFName = NULL;                        // This will record whether the inf was
                                                     // copied in
    LPTSTR pszNewINFName = NULL;                     // Hold the name of the inf to be zeroed if necessary
    TCHAR  szFullINFName[ MAX_PATH ];                // The Original Inf Name
    TCHAR  szFullNewINFName[ MAX_PATH ];             // The fully qualified inf name as copied onto the system.
    HANDLE hDriverFile          = INVALID_HANDLE_VALUE;
    LPTSTR pszNewDriverName     = NULL;
    DWORD  fBlockingStatus      = BSP_PRINTER_DRIVER_OK;
    PTCHAR pszDirPtr            = NULL;
    DWORD  ScanResult           = 0;

    //
    // Those below are used to manage the situation when the driver is not signed
    //
    BOOL   bIsPersonalOrProfessional = FALSE;
    HANDLE hRestorePointHandle       = NULL; 
    BOOL   bDriverNotInstalled       = TRUE;
    BOOL   bIsWindows64              = FALSE;
    BOOL   bPreviousNames            = FALSE;

    DWORD        dwOEMInfFileAttrs   = 0;
    const  DWORD dwGetFileAttrsError = 0xFFFFFFFF;
    
    szFullINFName[0]    = TEXT('\0');
    szFullNewINFName[0] = TEXT('\0');

    //
    // Set the unique directory flags if we are in a situation that uses them.
    //
    if( UseUniqueDirectory(pszServerName) ) {

        dwInstallFlags |= DRVINST_PRIVATE_DIRECTORY;
        dwAddDrvFlags  |= APD_COPY_FROM_DIRECTORY;
    }

    //
    // If this is a Windows update install, we need to ensure that all
    // cluster spooler resources get their drivers updated.
    //
    if (dwInstallFlags & DRVINST_WINDOWS_UPDATE)
    {
        dwAddDrvFlags |= APD_COPY_TO_ALL_SPOOLERS;

        pInfInfo->DriverInfo6.cVersion = dwVersion;
    }

    //
    // Open INF file and append layout.inf specified in Version section
    // Layout inf is optional
    //
    hPrinterInf = SetupOpenInfFile(pDrvInfo->pszInfName,
                                   NULL,
                                   INF_STYLE_WIN4,
                                   NULL);

    if ( hPrinterInf == INVALID_HANDLE_VALUE )
        goto Cleanup;

    SetupOpenAppendInfFile(NULL, hPrinterInf, NULL);

    pInfInfo->DriverInfo6.pEnvironment = PlatformEnv[platform].pszName;

    //
    // DI_VCP tells us not to create new file-queue and use user provided one
    //
    if ( !(Flags & DI_NOVCP) ) {

        CopyQueue = SetupOpenFileQueue();
        if ( CopyQueue == INVALID_HANDLE_VALUE )
           goto Cleanup;

        if ( dwInstallFlags & DRVINST_PROGRESSLESS ) {

            QueueContext   = SetupInitDefaultQueueCallbackEx(
                                            hwnd,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);
        } else {

            QueueContext   = SetupInitDefaultQueueCallback(hwnd);
        }

        InstallMsgHandler   = MyQueueCallback;

        ZeroMemory(&FileQContext, sizeof(FileQContext));
        FileQContext.hwnd           = hwnd;
        FileQContext.QueueContext   = QueueContext;
        FileQContext.dwInstallFlags = dwInstallFlags;
        FileQContext.pszSource      = (dwInstallFlags & DRVINST_FLATSHARE)
                                        ? pszSource : NULL;
        FileQContext.platform       = platform;
        FileQContext.dwVersion      = dwVersion;
        FileQContext.pszFileSrcPath = pszFileSrcPath;

        if (pDrvInfo->pszInfName)
        {
            _tcscpy(FileQContext.szInfPath, pDrvInfo->pszInfName);

            //
            // Cut off the inf file name
            //
            psz = _tcsrchr(FileQContext.szInfPath, _T('\\'));
            if (psz)
            {
                *psz = 0;
            }
        }
    }

    //
    // Setup the driver signing info.
    //
    if(NULL == (pDSInfo = SetupDriverSigning(hDevInfo, pszServerName,pDrvInfo->pszInfName,
                                             pszSource, platform, dwVersion, CopyQueue, dwInstallFlags & DRVINST_WEBPNP)))
    {
        goto Cleanup;
    }

    //
    // Find out if the cat was listed in a CatalogFile= entry.
    // This is used in the cleanup.
    //
    bCatInInf = IsCatInInf(pDSInfo);

    //
    // Check if this Driver is from CDM.
    // IF it is pass in the correct MediaType to Setup.
    //
    if ( (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER) || (dwInstallFlags & DRVINST_WINDOWS_UPDATE) )
       dwMediaType = SPOST_URL;

    //
    // For non admins, we install the catalog by calling AddDriverCatalog
    //
    // Do not fail the call when AddDriverCatalog fails
    //
    (void)AddDriverCatalogIfNotAdmin(pszServerName, pDSInfo, pDrvInfo->pszInfName, NULL, dwMediaType, 0);

    //
    // To support same INFs to install both NT and Win95 drivers actual
    // section to install could be different than the one corresponding
    // to the selected driver.
    //
    // SetupSetPlatformOverride tells setup which platform drivers we need
    // from the media
    // Also note setup does not reset PlatformPath override. So we need to
    // call this always
    //
    if ( !ParseInf(hDevInfo, pLocalData, platform, pszServerName, dwInstallFlags)    ||
         !SetupSetPlatformPathOverride(PlatformOverride[platform].pszName) ) {

        goto Cleanup;
    }

    // Now do the actual file copies...
    if ( !InstallAllInfSections( pLocalData,
                                 platform,
                                 pszServerName,
                                 CopyQueue,
                                 pszSource,
                                 dwInstallFlags,
                                 hPrinterInf,
                                 pInfInfo->pszInstallSection ) )
        goto Cleanup;

    //
    // If there is a language monitor make sure it is getting copied to
    // system32. On NT 4 we used to manually queue it to system32
    //
    if ( pInfInfo->DriverInfo6.pMonitorName             &&
         platform == MyPlatform                         &&
         !(dwInstallFlags & DRVINST_DRIVERFILES_ONLY)   &&
         !pszServerName)
    {
        //
        // if it's an alternate platform but the platform really is the same (checked above)
        // it's an NT4 driver on an x86 server. In this case install the LM too if not
        // already installed, see XP-bug 416129, else point-and-print from an NT4 client
        // that has the same driver installed locally will delete the LM info from the NT4 driver.
        // The logic is a little twisted: install the monitor if it's not an alternate platform 
        // or if it is (within the limits checked above) but no monitor with this name is installed yet.
        //
        if (!(dwInstallFlags & DRVINST_ALT_PLATFORM_INSTALL) ||
            !IsLanguageMonitorInstalled(pInfInfo->DriverInfo6.pMonitorName))
             
        {
            pszMonitorDll = pInfInfo->DriverInfo6.pMonitorName +
                                lstrlen(pInfInfo->DriverInfo6.pMonitorName) + 1;
            //
            // When we parse the INF we put the monitor dll name after \0
            //
            if ( !CheckAndEnqueueMonitorDll(pszMonitorDll,
                                            pszSource,
                                            CopyQueue,
                                            hPrinterInf) )
                goto Cleanup;

            MonitorRedirectDisable( pszMonitorDll, &pszDirPtr );

            bAddMon = TRUE;
        }
        else
        {
            //
            // we get here if it's an alternate platform driver and the monitor is already installed
            // in this case, don't clean out the monitor name from the driver info 6 below.
            // 
            bKeepMonName = TRUE;
        }
    }

    //
    // DI_NOVCP is used for pre-install when the class installer is just
    // supposed to queue the files and return. Printing needs special
    // handling since APIs need to be called. But we will obey the flags
    // as much as possible for those who use it
    //
    if ( Flags & DI_NOVCP ) {

        bRet = TRUE;
        goto Cleanup;
    }

    // We need a Queue Context to actually install files
    if ( !QueueContext )
        goto Cleanup;

    // Check if this is a WebPnP install
    if ( dwInstallFlags & DRVINST_WEBPNP || !(bAddMon || bKeepMonName) )
    {
        //
        // Check to see if there is a Monitor. If so clear out if it is not installed already
        //
        if ( pInfInfo->DriverInfo6.pMonitorName &&
             !IsMonitorInstalled( pInfInfo->DriverInfo6.pMonitorName ) )
        {
            LocalFreeMem( pInfInfo->DriverInfo6.pMonitorName );
            pInfInfo->DriverInfo6.pMonitorName = NULL;
        }
    }
    if (!PruneInvalidFilesIfNotAdmin( hwnd,
                                      CopyQueue ))
         goto Cleanup;

    //
    // prune files that are already present (correct version etc. checked by signature), ignore return value
    //
    SetupScanFileQueue( CopyQueue,
                        (SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE),
                        hwnd,
                        NULL,
                        NULL,
                        &ScanResult);

    
    if (!pszServerName || !lstrlen(pszServerName))
    {
        bIsPersonalOrProfessional = IsProductType( VER_NT_WORKSTATION, VER_EQUAL) == S_OK;
    }
    else
    {
        bIsPersonalOrProfessional = FALSE;
    }

    if (bIsPersonalOrProfessional)
    {
        SetupSetFileQueueFlags( CopyQueue,
                                SPQ_FLAG_ABORT_IF_UNSIGNED,
                                SPQ_FLAG_ABORT_IF_UNSIGNED );
    }

    if ( !SetupCommitFileQueue(hwnd,
                               CopyQueue,
                               (PSP_FILE_CALLBACK)InstallMsgHandler,
                               (PVOID)&FileQContext) )
    {

        bIsWindows64 = IsInWow64();
        if ((bIsWindows64 == FALSE) && bIsPersonalOrProfessional && 
            (GetLastError() == ERROR_SET_SYSTEM_RESTORE_POINT))
        {

            //
            // Here we have to start a Restore Point because there is 
            // something unsigned and this is either a personal or 
            // professional.
            //
            hRestorePointHandle = StartSystemRestorePoint( NULL,
                                                           (PCWSTR)(pLocalData->DrvInfo.pszModelName),
                                                           ghInst,
                                                           IDS_BSP_WARN_UNSIGNED_DRIVER );

            //
            // Terminate the default setupapi callback
            //
            SetupTermDefaultQueueCallback( QueueContext );       
            QueueContext = NULL;

            //             
            // Initialize the QueueContext structure            
            //
            if ( dwInstallFlags & DRVINST_PROGRESSLESS ) 
            {
                QueueContext = SetupInitDefaultQueueCallbackEx(hwnd,
                                                               INVALID_HANDLE_VALUE,
                                                               0,
                                                               0,
                                                               NULL);
            } 
            else 
            {
                QueueContext = SetupInitDefaultQueueCallback(hwnd);
            }

            if (!QueueContext)
            {
                goto Cleanup;
            }             
            else
            {
                FileQContext.QueueContext = QueueContext;
            } 

            // 
            //  Reset the flag and call the function again
            //
            SetupSetFileQueueFlags( CopyQueue,
                                    SPQ_FLAG_ABORT_IF_UNSIGNED,
                                    0 );

            if ( !SetupCommitFileQueue(hwnd,
                                       CopyQueue,
                                       (PSP_FILE_CALLBACK)InstallMsgHandler,
                                       (PVOID)&FileQContext) )
            {
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }

    //
    // Now that we did the file copy part of install we will do anything
    // else specified in the INF
    //
    if ( !pszServerName && platform == MyPlatform ) 
    {

        SetupInstallFromInfSection(hwnd,
                                   hPrinterInf,
                                   pInfInfo->pszInstallSection,
                                   SPINST_ALL & (~SPINST_FILES),
                                   NULL,
                                   pszSource,
                                   0,
                                   NULL,
                                   QueueContext,
                                   hDevInfo,
                                   pDrvInfo->pDevInfoData);
    }

    if ( bAddMon )
    {
        if( !AddPrintMonitor(pInfInfo->DriverInfo6.pMonitorName, pszMonitorDll) ) 
        {
            DWORD dwSavedLastError = EXIT_FAILURE;

            //
            // Fix bug 346937: when we can not add monitor, check whether this
            // driver is in printupg. If it is, consider it blocked then and 
            // popups a UI asking whether to install the replacement driver.
            //
            // After this point bRet is allways false, we only try to change
            // the error code in last error.
            //

            //
            // Save the last error first
            //
            dwSavedLastError = GetLastError();

            if (BlockedDriverPrintUpgUI(pszServerName,
                                        &pInfInfo->DriverInfo6,
                                        dwInstallFlags & DRVINST_PRIVATE_DIRECTORY,    // whether use full path
                                        !(dwInstallFlags & DRVINST_DONT_OFFER_REPLACEMENT), // whether to offer replacement
                                        !(dwInstallFlags & (DRVINST_NO_WARNING_PROMPT | DRVINST_PROMPTLESS)), // whether to popup UI
                                        &pszNewDriverName,
                                        &fBlockingStatus) &&
                (fBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
            {
                SetLastError(ERROR_PRINTER_DRIVER_BLOCKED);
            } 
            else
            {
                SetLastError(dwSavedLastError); // restore the error code
            }
               
            goto Cleanup;
        }

        MonitorRedirectEnable( &pszDirPtr );
    }

    //
    // If a print processor is specified in the INF need to install it.
    // For non-native architectur spooler fails this call (for remote case)
    //
    if ( pInfInfo->pszPrintProc                                             &&
         !AddPrintProcessor((LPTSTR)pszServerName,
                            PlatformEnv[platform].pszName,
                            pInfInfo->pszPrintProc
                                   + lstrlen(pInfInfo->pszPrintProc) + 1,
                            pInfInfo->pszPrintProc)                         &&
         GetLastError() != ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED          &&
         GetLastError() != ERROR_INVALID_ENVIRONMENT ) 
    {
        goto Cleanup;
    }

    if (IsTheSamePlatform(pszServerName, platform) && IsWhistlerOrAbove(pszServerName))
    {
        bPreviousNames = CheckAndKeepPreviousNames( pszServerName, &pInfInfo->DriverInfo6, platform );
    }

    bRet = AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry(pszServerName,
                                                              &pInfInfo->DriverInfo6,
                                                              dwAddDrvFlags | APD_DONT_SET_CHECKPOINT,
                                                              dwInstallFlags & DRVINST_PRIVATE_DIRECTORY,    // whether use full path
                                                              !(dwInstallFlags & DRVINST_DONT_OFFER_REPLACEMENT), // whether to offer replacement
                                                              !(dwInstallFlags & (DRVINST_NO_WARNING_PROMPT | DRVINST_PROMPTLESS)), // whether to popup UI
                                                              &pszNewDriverName,
                                                              &fBlockingStatus) &&
           PSetupInstallICMProfiles(pszServerName, pInfInfo->pszzICMFiles);

    if (bPreviousNames) 
    {
        LocalFreeMem( pInfInfo->DriverInfo6.pszzPreviousNames );
    }

    bDriverNotInstalled = FALSE;

Cleanup:

    dwInstallLE = GetLastError(); // Get the real error message

    if (bAddMon && pszDirPtr)
    {
        MonitorRedirectEnable( &pszDirPtr );
    }

    if ((bIsWindows64 == FALSE) && hRestorePointHandle)
    {
        //
        // Here we have to end the Restore Point because one was 
        // started
        //
        EndSystemRestorePoint(hRestorePointHandle, bDriverNotInstalled);
    }

    if (hDriverFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDriverFile);
    }

    //
    // Zero the inf if DI_NOVCP and - either we've fail, it is a Web PNP 
    // install. or - this is installing from a non-system ntprint.inf AND 
    // there is a cat to be protected. - not yet!!
    //
    bZeroInf = (!bRet || ( dwInstallFlags & DRVINST_WEBPNP )
                      || (IsNTPrintInf( pDrvInfo->pszInfName ) && bCatInInf)) &&
               !(Flags & DI_NOVCP);

    //
    // We have to copy the INF if the following conditions are satisfied
    //

    bCopyInf = // bRet is TRUE (the call to AddPrinterDriverUsingCorrectLevelWithPrintUpgRetry succeeded)
               bRet                                                           &&
               // and the Installation flags say the INF to be copied 
               !(dwInstallFlags & DRVINST_DONOTCOPY_INF)                      &&
               // and the platform is the same as ours 
               platform == MyPlatform                                         &&
               // and the INF it's not the system ntprint.inf (obviously) or
               // it's from WU 
               (!IsSystemNTPrintInf(pDrvInfo->pszInfName) || (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER)) &&
               // and DI_NOVCP flag is not set
               !(Flags & DI_NOVCP)                                            &&
               // and this is not Web PnP or there is a cat to protect
               !((dwInstallFlags & DRVINST_WEBPNP) && !bCatInInf)             &&
               // and this is not ntprint.inf or there is a cat to protect
               !(IsNTPrintInf( pDrvInfo->pszInfName ) && !bCatInInf);


    //
    // How we have to call SetupCopyOEMInf to take the name of the INF which
    // has been copied on our system when we called SetupCommitFileQueue
    //
    if (!SetupCopyOEMInf(pDrvInfo->pszInfName,
                         NULL,
                         dwMediaType,
                         SP_COPY_REPLACEONLY,
                         szFullINFName,
                         MAX_PATH,
                         NULL,
                         &pszINFName) ) 
    {
        // If we can't find the original name might as well not copy or
        // zero

        if (bZeroInf && !bCopyInf)
        {
            bZeroInf = FALSE;
        }
    } 
    else 
    {
        if (bZeroInf) 
        {
            bCopyInf = FALSE;
        }
    }

    //
    // If we succesfully installed a native architecture driver
    // then is when we copy the OEM INF file and give it a unique name
    //
    if ( bCopyInf ) 
    {

        //
        // Earlier we used to call CopyOEMInfFileAndGiveUniqueName here
        // Now that Setup API has this and we are going to support CDM
        // we call this setup API
        //
        (VOID)SetupCopyOEMInf(pDrvInfo->pszInfName,
                              NULL,
                              dwMediaType,
                              SP_COPY_NOOVERWRITE,
                              szFullNewINFName,
                              MAX_PATH,
                              NULL,
                              &pszNewINFName);
       //
       // If this fails we don't give the proverbial, since the file won't 
       // be there
       // 
    }
    else
    {
        if (!bZeroInf && !(Flags & DI_NOVCP))
        {
            //
            // We have to remove the INF in the case of unsuccessful installation and ONLY if the DI_NOVCP
            // flag is not set. If the flag is set then we don't have to change the state because the file
            // queue hasn't been commited and the INF just has been already there before the call to our
            // function.
            //

            //
            // Remove the READONLY file attribute if set
            //
            dwOEMInfFileAttrs = GetFileAttributes( szFullINFName );
            if ((dwOEMInfFileAttrs != dwGetFileAttrsError) &&
                (dwOEMInfFileAttrs & FILE_ATTRIBUTE_READONLY))
            {
                dwOEMInfFileAttrs &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes( szFullINFName, dwOEMInfFileAttrs);
            }
            DeleteFile( szFullINFName );
        }
    }

    // Ignore the error message from SetupCopyOEMInf and DeleteFile
    dwStatus = bRet ? ERROR_SUCCESS : dwInstallLE;

    // If the install failed or this was Web Point&Print
    // we may need to get rid of the INF
    if ( bZeroInf )
    {
       // If INFName is different then possibly set to 0 length
       // Or this is ntprint.inf being renamed to OEMx.inf - we want it zeroed.
       if (( pszINFName                                 &&
             (psz=FileNamePart( pDrvInfo->pszInfName )) &&
             lstrcmp( psz, pszINFName )                   ) ||
           ( IsNTPrintInf( pDrvInfo->pszInfName )       &&
             bCatInInf                                  &&
             pszNewINFName                              &&
             (psz=FileNamePart( pDrvInfo->pszInfName )) &&
             lstrcmp( psz, pszINFName )                   )   )
       {
          HANDLE       hFile;

          //
          // Remove the READONLY file attribute if set
          //
          dwOEMInfFileAttrs = GetFileAttributes(szFullINFName ? szFullINFName : szFullNewINFName);
          if ((dwOEMInfFileAttrs != dwGetFileAttrsError) &&
              (dwOEMInfFileAttrs & FILE_ATTRIBUTE_READONLY))
          {
              dwOEMInfFileAttrs &= ~FILE_ATTRIBUTE_READONLY;
              SetFileAttributes(szFullINFName ? szFullINFName : szFullNewINFName, dwOEMInfFileAttrs);
          }

          // Open the File
          hFile = CreateFile( szFullINFName ? szFullINFName : szFullNewINFName,
                              (GENERIC_READ | GENERIC_WRITE),
                              ( FILE_SHARE_READ | FILE_SHARE_WRITE ),
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

          // If we opened a file
          if ( hFile != INVALID_HANDLE_VALUE )
          {
                SetFilePointer( hFile, 0, 0, FILE_BEGIN );
                SetEndOfFile( hFile );
                CloseHandle( hFile );
          }
       }
    }

    if ( hPrinterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(hPrinterInf);

    //
    // Free the Driver Signing class.
    //
    if(pDSInfo)
    {
        CleanupDriverSigning(pDSInfo);
    }

    if ( !(Flags & DI_NOVCP) ) {

        //
        // The driver signing code may have associated the queue to the SP_DEVINSTALL_PARAMS.
        // We've finished with this and need to remove the queue from the SP_DEVINSTALL_PARAMS before we delete it.
        //
        SP_DEVINSTALL_PARAMS DevInstallParams = {0};
        DevInstallParams.cbSize = sizeof(DevInstallParams);

        if(SetupDiGetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams))
        {
            if(DevInstallParams.FileQueue == CopyQueue)
            {
                DevInstallParams.FlagsEx &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
                DevInstallParams.Flags &= ~DI_NOVCP;
                DevInstallParams.FileQueue = INVALID_HANDLE_VALUE;
                SetupDiSetDeviceInstallParams(hDevInfo,
                                              NULL,
                                              &DevInstallParams);
            }
        }

        //
        // Now free up the queue.
        //
        if ( CopyQueue != INVALID_HANDLE_VALUE )
        {
            SetupCloseFileQueue(CopyQueue);
        }

        if ( QueueContext )
        {
            SetupTermDefaultQueueCallback(QueueContext);
        }

        if( dwAddDrvFlags & APD_COPY_FROM_DIRECTORY ) 
        {

            //
            // if this was an installation with a path derived from the Pnp-ID,
            // do not cleanup, else users will get prompted for media when they re-pnp the driver
            //
            if ( ! (pLocalData->Flags & LOCALDATAFLAG_PNP_DIR_INSTALL) )
            {
                CleanupUniqueScratchDirectory( pszServerName, platform );
            }
        } 
        else 
        {

            CleanupScratchDirectory( pszServerName, platform );
        }
    }

    //
    // Return the new driver name and the blocking flags if they were asked for.
    // 
    if (ppszNewDriverName)
    {
        *ppszNewDriverName = pszNewDriverName;
    }
    else if (pszNewDriverName)
    {
        LocalFreeMem(pszNewDriverName);
    }

    if (pBlockingStatus)
    {
        *pBlockingStatus = fBlockingStatus;
    }

    return  dwStatus;
}

DWORD
InstallDriverAfterPromptingForInf(
    IN      PLATFORM    platform,
    IN      LPCTSTR     pszServerName,
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModelName,
    IN      DWORD       dwVersion,
    IN OUT  TCHAR       szInfPath[MAX_PATH],
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags,
    OUT     LPTSTR      *ppszNewDriverName
    )
{
    DWORD               dwRet, dwTitleId, dwMediaId;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    LPTSTR               pszFileSrcPath = NULL;
    DWORD               dwBlockingStatus = BSP_PRINTER_DRIVER_OK;

    switch (platform) {

        case PlatformAlpha:
            dwTitleId = IDS_DRIVERS_FOR_NT4_ALPHA;
            break;

        case PlatformX86:
            if( dwVersion == 2 )
            {
                dwTitleId = IDS_DRIVERS_FOR_NT4_X86;
            }
            else
            {
                dwTitleId = IDS_DRIVERS_FOR_X86;
            }
            break;

        case PlatformMIPS:
            dwTitleId = IDS_DRIVERS_FOR_NT4_MIPS;
            break;

        case PlatformPPC:
            dwTitleId = IDS_DRIVERS_FOR_NT4_PPC;
            break;

        case PlatformIA64:
            dwTitleId = IDS_DRIVERS_FOR_IA64;
            break;

        default:
            ASSERT(0);
            return  ERROR_INVALID_PARAMETER;
    }

    dwMediaId = IDS_PROMPT_ALT_PLATFORM_DRIVER;

    dwInstallFlags |= DRVINST_ALT_PLATFORM_INSTALL | DRVINST_NO_WARNING_PROMPT;
    
    hDevInfo = GetInfAndBuildDrivers(hwnd,
                                     dwTitleId,
                                     dwMediaId,
                                     szInfPath,
                                     dwInstallFlags,
                                     platform, dwVersion,
                                     pszModelName,
                                     &pLocalData,
                                     &pszFileSrcPath);

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {

        dwRet = GetLastError();
        goto Cleanup;
    }

    //
    // we want the printupg prompt
    //
    dwInstallFlags &= ~DRVINST_NO_WARNING_PROMPT;

    dwRet = InstallDriverFromCurrentInf(hDevInfo,
                                        pLocalData,
                                        hwnd,
                                        platform,
                                        dwVersion,
                                        pszServerName,
                                        INVALID_HANDLE_VALUE,
                                        NULL,
                                        NULL,
                                        0,
                                        szInfPath,
                                        dwInstallFlags,
                                        dwAddDrvFlags,
                                        pszFileSrcPath,
                                        ppszNewDriverName,
                                        &dwBlockingStatus);

    if (((ERROR_PRINTER_DRIVER_BLOCKED == dwRet) || (ERROR_PRINTER_DRIVER_WARNED == dwRet)) && 
        (ppszNewDriverName && *ppszNewDriverName) &&
        (dwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
    {
        dwRet = InstallReplacementDriver(hwnd, 
                                         pszServerName, 
                                         *ppszNewDriverName,
                                         platform,
                                         dwVersion,
                                         dwInstallFlags,
                                         dwAddDrvFlags);
    }
    else if (ppszNewDriverName && *ppszNewDriverName)
    {
        LocalFreeMem(*ppszNewDriverName);
        *ppszNewDriverName = NULL;
    }

Cleanup:

    if (pszFileSrcPath)
    {
        //
        // we did the NT4 copy/expand thing -> delete the expanded inf!
        //
        _tcscat(szInfPath, _T("ntprint.inf"));

        DeleteFile(szInfPath);

        LocalFreeMem(pszFileSrcPath);
    }

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    DestroyLocalData(pLocalData);

    return dwRet;
}


const TCHAR   gcszNTPrint[]  = _TEXT("inf\\ntprint.inf");

DWORD GetNtprintDotInfPath(LPTSTR pszNTPrintInf, DWORD len)
{
    DWORD dwLastError = ERROR_INVALID_DATA, dwSize;
    LPTSTR pData;

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //  If the return is greater than MAX_PATH we want to fail as something has managed to change
    //  the system dir to longer than MAX_PATH which is invalid.
    //
    dwSize = GetSystemWindowsDirectory( pszNTPrintInf, len );
    if( !dwSize || dwSize > len )
        goto Cleanup;

    //
    // If we don't end in a \ then add one.
    //
    dwSize = _tcslen(pszNTPrintInf);
    pData = &(pszNTPrintInf[ dwSize ]);
    if (*pData != _TEXT('\\') )
    {
        if (dwSize + 1 < len)
        {
            *(pData++) = _TEXT('\\');
            dwSize++;
        }
    }

    *(pData) = 0;
    dwSize += _tcslen( gcszNTPrint ) + 1;

    //
    // If what we've got sums up to a longer string than the allowable length MAX_PATH - fail
    //
    if ( dwSize > len )
        goto Cleanup;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    _tcscpy( pData, gcszNTPrint );

    dwLastError = ERROR_SUCCESS;

Cleanup:

    if (dwLastError != ERROR_SUCCESS)
    {
        //
        // Got here due to some error.  Get what the called function set the last error to.
        // If the function set a success, set some error code.
        //
        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS)
        {
            dwLastError = ERROR_INVALID_DATA;
        }

        if (len)
        {
            pszNTPrintInf[0] = 0;
        }
    }
    return dwLastError;
}

DWORD
InstallReplacementDriver(HWND       hwnd, 
                         LPCTSTR    pszServerName, 
                         LPCTSTR    pszModelName, 
                         PLATFORM   platform,
                         DWORD      version,
                         DWORD      dwInstallFlags,
                         DWORD      dwAddDrvFlags)
/*++

Routine Description:
    Install an inbox replacement driver for blocked/warned drivers.

Arguments:
    hwnd            : parent windows handle.
    pszServerName   : Server name to which we are installing
    pszModelName    : driver model name to install
Return Value:
    ERROR_SUCCESS on success, error code otherwise

--*/

{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    PPSETUP_LOCAL_DATA pLocalData = NULL;
    TCHAR szNtprintDotInf[MAX_PATH];
    DWORD dwLastError;

    if ((dwLastError = GetNtprintDotInfPath(szNtprintDotInf, COUNTOF(szNtprintDotInf))) != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    if ((hDevInfo = PSetupCreatePrinterDeviceInfoList(NULL)) != INVALID_HANDLE_VALUE    &&
        PSetupBuildDriversFromPath(hDevInfo, szNtprintDotInf, TRUE)                     &&
        PSetupPreSelectDriver(hDevInfo, NULL, pszModelName)                             &&
        (pLocalData = BuildInternalData(hDevInfo, NULL)) != NULL                        &&
        ParseInf(hDevInfo, pLocalData, platform, NULL, dwInstallFlags))
    {
        //
        // Don't prompt for blocked or warned drivers.
        // 
        dwInstallFlags |= DRVINST_NO_WARNING_PROMPT;

        dwLastError = InstallDriverFromCurrentInf(  hDevInfo,
                                                    pLocalData,
                                                    hwnd,
                                                    platform,
                                                    version,
                                                    pszServerName,
                                                    INVALID_HANDLE_VALUE,
                                                    NULL,
                                                    NULL,
                                                    0,
                                                    szNtprintDotInf,
                                                    dwInstallFlags,
                                                    dwAddDrvFlags,
                                                    NULL,
                                                    NULL,
                                                    NULL);
    }
    else
    {
        dwLastError = GetLastError();
    }

Cleanup:
    if(pLocalData != NULL)
    {
        PSetupDestroySelectedDriverInfo(pLocalData);
    }

    //
    // Release the driver setup parameter handle.
    //
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        PSetupDestroyPrinterDeviceInfoList( hDevInfo );
    }

    return dwLastError;
}

DWORD
InvokeSetup(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszOption,
    IN  LPCTSTR     pszInfFile,
    IN  LPCTSTR     pszSourcePath,
    IN  LPCTSTR     pszServerName       OPTIONAL
    )
/*++

Routine Description:
    Invoke setup to do an install operation associated with an INF.
    Will be used to install drivers from printer.inf, monitors from monitor.inf

Arguments:
    hwnd            : Window handle of current top-level window
    pszOption       : Option from the INF file to install
    pszInfFile      : Name of the INF file to be used for the setup
    pszSourcePath   : Location where the required files are available
    pszServerName   : Server to install printer driver on (NULL if local)

Return Value:
    ERROR_SUCCESS on succesfully installing the driver
    Erro code on failure

--*/
{
    TCHAR   szAppName[] = TEXT("%s\\SETUP.exe");
    TCHAR   szCmd[]     = TEXT(" -f -s %s -i %s -c ExternalInstallOption \
/t STF_LANGUAGE = ENG /t OPTION = \"%s\" \
/t STF_PRINTSERVER = \"%s\" /t ADDCOPY = YES /t DOCOPY = YES \
/t DOCONFIG = YES /w %d");

    MSG                     Msg;
    DWORD                   dwSize, dwLastError = ERROR_SUCCESS;
    LPTSTR                  pszSetupExe = NULL;
    LPTSTR                  pszSetupCmd = NULL;
    TCHAR                   szSystemPath[MAX_PATH];
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInformation;


#if defined(_WIN64)
    //
    // Setup.exe must be loaded from the wow64 directory.
    //
    if( (dwSize = GetSystemWindowsDirectory(szSystemPath,SIZECHARS(szSystemPath))))
    {
        if( szSystemPath[dwSize-1] != _TEXT('\\') && dwSize + 1 < SIZECHARS(szSystemPath) )
        {
            szSystemPath[dwSize++]   = _TEXT('\\');
            szSystemPath[dwSize] = 0;
        }
    }
#ifdef UNICODE
    if(dwSize + lstrlen(WOW64_SYSTEM_DIRECTORY_U) + 1 < SIZECHARS(szSystemPath))
    {
        lstrcat( szSystemPath, WOW64_SYSTEM_DIRECTORY_U );
    }
#else
    if(dwSize + lstrlen(WOW64_SYSTEM_DIRECTORY) + 1 < SIZECHARS(szSystemPath))
    {
        lstrcat( szSystemPath, WOW64_SYSTEM_DIRECTORY );
    }
#endif // #ifdef UNICODE

#else
    //
    // Setup.exe is in the system path
    //
    if( (dwSize = GetSystemDirectory(szSystemPath,SIZECHARS(szSystemPath))))
    {
        if( szSystemPath[dwSize-1] != _TEXT('\\') && dwSize + 1 < SIZECHARS(szSystemPath) )
        {
            szSystemPath[dwSize++]   = _TEXT('\\');
            szSystemPath[dwSize] = 0;
        }
    }
#endif // #if defined(_WIN64)

    if ( !pszServerName )
        pszServerName = TEXT("");

    dwSize = lstrlen(pszOption) + 1 + lstrlen(pszSourcePath) + 1 +
             lstrlen(pszServerName) + 1 + lstrlen(pszInfFile) + 1;

    dwSize *= sizeof(TCHAR);
    //
    // 20 for window handle in ASCII
    //
    dwSize += sizeof(szCmd) + 20;

    pszSetupCmd = (LPTSTR) LocalAllocMem(dwSize);

    if ( !pszSetupCmd ) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    dwSize      = (lstrlen(szAppName) + lstrlen(szSystemPath) + 1) * sizeof(TCHAR);
    pszSetupExe = LocalAllocMem( dwSize );
    if ( !pszSetupExe ) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // Now print the full path including SETUP.EXE
    //
    wsprintf(pszSetupExe, szAppName, szSystemPath);


    //
    // Now print the command to invoke setup with all the arguments
    //
    wsprintf(pszSetupCmd, szCmd, pszSourcePath, pszInfFile, pszOption, 
             pszServerName, hwnd);

    //
    // Invoke setup as a separate process
    //
    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_SHOW;

    if ( !CreateProcess(pszSetupExe, pszSetupCmd, NULL, NULL, FALSE, 0, NULL,
                        NULL, &StartupInfo, &ProcessInformation) ) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    EnableWindow (hwnd, FALSE);
    while ( MsgWaitForMultipleObjects(1, (LPHANDLE)&ProcessInformation,
                                      FALSE, (DWORD)-1, QS_ALLINPUT) ) {

        //
        // This message loop is a duplicate of main
        // message loop with the exception of using
        // PeekMessage instead of waiting inside of
        // GetMessage.  Process wait will actually
        // be done in MsgWaitForMultipleObjects api.
        //
            while ( PeekMessage (&Msg, NULL, 0, 0, PM_REMOVE)) {

                TranslateMessage (&Msg);
                DispatchMessage (&Msg);
            }
    }

    //
    // Did setup complete succesfully?
    //
    GetExitCodeProcess(ProcessInformation.hProcess, &dwLastError);

    //
    // Setup.exe magic return codes I found out by trial and error
    //
    if ( dwLastError == 1 )
        SetLastError(dwLastError = ERROR_CANCELLED);
    else if ( dwLastError == 2 )
        SetLastError(dwLastError = ERROR_UNKNOWN_PRINTER_DRIVER);
    else if ( dwLastError )
        SetLastError(dwLastError=(DWORD)STG_E_UNKNOWN);

    CloseHandle (ProcessInformation.hProcess);
    CloseHandle (ProcessInformation.hThread);

    EnableWindow (hwnd, TRUE);

    SetForegroundWindow(hwnd);

Cleanup:

    LocalFreeMem(pszSetupCmd);
    LocalFreeMem(pszSetupExe);
    return dwLastError;
}


DWORD
InstallNt3xDriver(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszDriverName,
    IN      PLATFORM    platform,
    IN      LPCTSTR     pszServerName,
    IN  OUT LPTSTR      pszSourcePath,
    IN      LPCTSTR     pszDiskName,
    IN      DWORD       dwInstallFlags
    )
{
    LPTSTR      pszTitle = NULL, pszFormat, pszPrompt = NULL;
    TCHAR       szInfPath[MAX_PATH];
    DWORD       dwLastError;

    //
    // Build strings to use in the path dialog ..
    //
    pszFormat   = GetStringFromRcFile(IDS_DRIVERS_FOR_PLATFORM);
    if ( pszFormat ) {

        pszTitle = LocalAllocMem((lstrlen(pszFormat) + lstrlen(pszDiskName) + 2)
                                                * sizeof(*pszTitle));
        if ( pszTitle )
            wsprintf(pszTitle, pszFormat, pszDiskName);
    }

    //
    // First see if the inf could be found on our default location
    //
    if ( MAX_PATH >
            lstrlen(pszSourcePath) + lstrlen(TEXT("printer.inf")) + 1 ) {

        lstrcpy(szInfPath, pszSourcePath);
        lstrcat(szInfPath, TEXT("printer.inf"));
    } else {

        SetLastError(dwLastError=ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    if ( !FileExists(szInfPath) ) {

        if ( dwInstallFlags & DRVINST_PROMPTLESS ) {

            dwLastError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Always just prompt with the CD-ROM path
        //
        GetCDRomDrive(pszSourcePath);

        dwInstallFlags |= DRVINST_ALT_PLATFORM_INSTALL;

        pszPrompt = GetStringFromRcFile(IDS_PROMPT_ALT_PLATFORM_DRIVER);

        if (!pszPrompt)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Ask the user where the printer.inf, printer driver files reside
        //
        if ( !PSetupGetPathToSearch(hwnd, pszTitle, pszPrompt,
                                    TEXT("printer.inf"), TRUE, pszSourcePath) ) {

            dwLastError = GetLastError();
            goto Cleanup;
        }

        if ( MAX_PATH >
                lstrlen(pszSourcePath) + lstrlen(TEXT("printer.inf")) + 1 ) {

            lstrcpy(szInfPath, pszSourcePath);
            lstrcat(szInfPath, TEXT("printer.inf"));
        } else {

            SetLastError(dwLastError=ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }
    }

    dwLastError = InvokeSetup(hwnd,
                              pszDriverName,
                              szInfPath,
                              pszSourcePath,
                              pszServerName);

Cleanup:

    LocalFreeMem(pszPrompt);
    LocalFreeMem(pszTitle);
    LocalFreeMem(pszFormat);

    CleanupScratchDirectory(pszServerName, platform);

    return dwLastError;
}


//
// Paths where we search for the driver files
//
SPLPLATFORMINFO szPlatformExtn[] = {

    { TEXT("\\alpha") },
    { TEXT("\\i386") },
    { TEXT("\\mips") },
    { TEXT("\\ppc") },
    { TEXT("") },
    { TEXT("\\ia64") }
};


VOID
GetCDRomDrive(
    TCHAR   szDrive[5]
    )
{
    DWORD   dwDrives;
    INT     iIndex;

    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\\');
    szDrive[3] = TEXT('\0');
    dwDrives = GetLogicalDrives();

    for ( iIndex = 0 ; iIndex < 26 ; ++iIndex )
        if ( dwDrives & (1 << iIndex) ) {

            szDrive[0] = TEXT('A') + iIndex;
            if ( GetDriveType(szDrive) == DRIVE_CDROM )
                goto Done;
        }

    szDrive[0] = TEXT('A');

Done:
    return;
}


BOOL
BuildPathToPrompt(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  TCHAR               szPathOut[MAX_PATH]
    )
/*++
--*/
{
    LPTSTR  pszExtn = TEXT("");
    DWORD   dwLen;

    //
    // The CD we installed from OS can have only the following drivers:
    //      -- NT5 same platform drivers
    //      -- NT4 same platform drivers (only on server CD)
    //      -- Win9x drivers (only on server CD)
    //
    if ( (platform == MyPlatform && dwVersion >= 2)     ||
         platform == PlatformWin95 ) {

        GetDriverPath(hDevInfo, pLocalData, szPathOut);
    } else {

        GetCDRomDrive(szPathOut);
    }

    if ( dwVersion >= dwThisMajorVersion && platform == MyPlatform )
        return TRUE;

    //
    // append a backslash if needed
    //
    dwLen = lstrlen(szPathOut);

    if (dwLen && (dwLen + 1 < MAX_PATH) && (szPathOut[dwLen-1] != TEXT('\\')))
    {
        szPathOut[dwLen] = TEXT('\\');
        szPathOut[++dwLen]   = 0;
    }

    switch (dwVersion) {

        case    0:
            if ( platform == PlatformWin95 )
                pszExtn   = TEXT("printers\\Win9X\\");

            //
            // For NT 3.51 and 3.1 we do not include drivers on CD, so
            // nothing to add to the base path
            //
        case    1:
            break;

        case    2:
            if ( platform == PlatformX86 )  // Alpha is now on the NT4.0 CD
                pszExtn = TEXT("printers\\NT4\\");
            break;

                case    3:
                        break;

        default:
            ASSERT(dwVersion <= 3);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    if ( dwLen + lstrlen(pszExtn) + lstrlen(szPlatformExtn[platform].pszName) + 1
                > MAX_PATH ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    lstrcat(szPathOut, pszExtn);

    //
    // Skip the leading \ of the platform extension as we have one already.
    //
    lstrcat(szPathOut, &(szPlatformExtn[platform].pszName[1]));

    return TRUE;
}


DWORD
PSetupInstallPrinterDriver(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszDriverName,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszServerName,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszDiskName,
    IN  LPCTSTR             pszSource       OPTIONAL,
    IN  DWORD               dwInstallFlags,
    IN  DWORD               dwAddDrvFlags,
    OUT LPTSTR             *ppszNewDriverName
    )
/*++

Routine Description:
    Copies all the necessary driver files to the printer driver directory so
    that an AddPrinterDriver call could be made.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pLocalData      : Gives information got by parsing the inf
    pszDriverName   : Printer driver name, used only if pLocalData is NULL
    platform        : Platform for which drivers need to be installed
    dwVersion       : Version of the driver to install
    pszServerName   : Server on which driver should be installed
    hwnd            : Parent windows handle for UI
    pszDiskName     : Disk name for prompting
    pszSource       : If provided this is a flat directory having all the files
    dwAddDrvFlags   : Flags for AddPrinterDriverEx

Return Value:
    On succesfully copying files ERROR_SUCCESS, else the error code

--*/
{
    BOOL            bDeleteLocalData = pLocalData == NULL;
    DWORD           dwRet;
    TCHAR           szPath[MAX_PATH];

    szPath[0] = 0;

    if ( pszSource && !*pszSource )
        pszSource = NULL;

    if ( pLocalData )
    {
        ASSERT(pLocalData->signature == PSETUP_SIGNATURE && !pszDriverName);
    }
    else
    {
        ASSERT(pszDriverName && *pszDriverName);
    }

    //
    // If FLATSHARE bit is set then a path should be given
    //
    ASSERT( (dwInstallFlags & DRVINST_FLATSHARE) == 0 || pszSource != NULL );

Retry:

    //
    // If a path is given use it. Otherwise if this is a driver for different
    // version or platform then we determine the path, otherwise let SetupAPI determine the
    // path.
    //
    if ( dwVersion != dwThisMajorVersion || platform != MyPlatform ) {

        // If this is not an NT5 driver and we are asked to get it
        //  from the web, then just return.....
        if ( pLocalData &&
             ( pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER ) )
           return ERROR_SUCCESS;

        if ( pszSource )
            lstrcpy(szPath, pszSource);
        else if ( !BuildPathToPrompt(hDevInfo,
                                     pLocalData,
                                     platform,
                                     dwVersion,
                                     szPath) ) {

            if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
                dwRet = STG_E_UNKNOWN;

            return dwRet;
        }
    }

    //
    // For Win95 drivers we need to parse their INFs,
    // For Nt 3x driver we need to call setup
    // For non native environemnt dirvers ask user for path
    //
    if ( platform == PlatformWin95 ) {

        if ( pLocalData ) {

            //
            // Parse the inf as a X86 inf so that we can pick up any
            // previous names entries and use them.
            //
            if ( !ParseInf(hDevInfo, pLocalData, PlatformX86,
                           pszServerName, dwInstallFlags) )
                    return GetLastError();

            dwRet = InstallWin95Driver(hwnd,
                                       pLocalData->DrvInfo.pszModelName,
                                       pLocalData->DrvInfo.pszzPreviousNames,
                                       (pLocalData->DrvInfo.Flags &
                                            SDFLAG_PREVNAME_SECTION_FOUND),
                                       pszServerName,
                                       szPath,
                                       pszDiskName,
                                       dwInstallFlags,
                                       dwAddDrvFlags);
        } else {
            dwRet = InstallWin95Driver(hwnd,
                                       pszDriverName,
                                       NULL,
                                       TRUE, // Exact model name match only
                                       pszServerName,
                                       szPath,
                                       pszDiskName,
                                       dwInstallFlags,
                                       dwAddDrvFlags);
        }
    } else if ( dwVersion < 2 )  {

        dwRet = InstallNt3xDriver(hwnd,
                                  pLocalData ?
                                        pLocalData->DrvInfo.pszModelName :
                                        pszDriverName,
                                  platform,
                                  pszServerName,
                                  szPath,
                                  pszDiskName,
                                  dwInstallFlags);
    } else if ( dwVersion != dwThisMajorVersion || platform != MyPlatform ) {

        dwRet = InstallDriverAfterPromptingForInf(
                            platform,
                            pszServerName,
                            hwnd,
                            pLocalData ?
                                pLocalData->DrvInfo.pszModelName :
                                pszDriverName,
                            dwVersion,
                            szPath,
                            dwInstallFlags,
                            dwAddDrvFlags,
                            ppszNewDriverName);

    } else if ( pLocalData  &&
                (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER) ) {

        dwRet = PSetupInstallPrinterDriverFromTheWeb(hDevInfo,
                                                     pLocalData,
                                                     platform,
                                                     pszServerName,
                                                     &OsVersionInfo,
                                                     hwnd,
                                                     pszSource);
    } else {

        if ( !pLocalData )
        {
            pLocalData = PSetupDriverInfoFromName(hDevInfo, pszDriverName);
        }

        if ( pLocalData )
        {
            DWORD dwBlockingStatus = BSP_PRINTER_DRIVER_OK;

            dwRet = InstallDriverFromCurrentInf(hDevInfo,
                                                pLocalData,
                                                hwnd,
                                                platform,
                                                dwVersion,
                                                pszServerName,
                                                INVALID_HANDLE_VALUE,
                                                NULL,
                                                NULL,
                                                0,
                                                pszSource,
                                                dwInstallFlags,
                                                dwAddDrvFlags,
                                                NULL,
                                                ppszNewDriverName,
                                                &dwBlockingStatus);

            if ((ppszNewDriverName && *ppszNewDriverName)         &&
                (dwBlockingStatus & BSP_PRINTER_DRIVER_REPLACED))
            {
                dwRet = InstallReplacementDriver(hwnd, 
                                                 pszServerName, 
                                                 *ppszNewDriverName,
                                                 platform,
                                                 dwVersion,
                                                 dwInstallFlags,
                                                 dwAddDrvFlags);
            }
            else if (ppszNewDriverName && *ppszNewDriverName)
            {
                LocalFreeMem(*ppszNewDriverName);
                *ppszNewDriverName = NULL;
            }
        }
        else
        {
            dwRet = GetLastError();
        }

    }

    if (
         (dwRet == ERROR_EXE_MACHINE_TYPE_MISMATCH) &&
         !(dwInstallFlags & DRVINST_PROMPTLESS)
       ) 
    {

        int i;
        TCHAR   szTitle[256], szMsg[256];

        LoadString(ghInst,
                   IDS_INVALID_DRIVER,
                   szTitle,
                   SIZECHARS(szTitle));

        LoadString(ghInst,
                   IDS_WRONG_ARCHITECTURE,
                   szMsg,
                   SIZECHARS(szMsg));

        i = MessageBox(hwnd,
                       szMsg,
                       szTitle,
                       MB_RETRYCANCEL | MB_ICONSTOP | MB_DEFBUTTON1 | MB_APPLMODAL);

        if ( i == IDRETRY )
        {
            if ( bDeleteLocalData )
            {
                DestroyLocalData(pLocalData);
                pLocalData = NULL;
            }

            goto Retry;
        }
        else
        {
            SetLastError(dwRet =ERROR_CANCELLED);
        }
    }

    if ( bDeleteLocalData )
        DestroyLocalData(pLocalData);

    return dwRet;
}


//
// SCAN_INFO structure is used with SetupScanFileQueue to find dependent files
// and ICM files
//
typedef struct _SCAN_INFO {

    BOOL                bWin95;
    PPSETUP_LOCAL_DATA  pLocalData;
    DWORD               cchDependentFiles, cchICMFiles;
    DWORD               cchDriverDir, cchColorDir;
    LPTSTR              p1, p2;
    TCHAR               szDriverDir[MAX_PATH], szColorDir[MAX_PATH];
} SCAN_INFO, *PSCAN_INFO;


UINT
DriverInfoCallback(
    IN  PVOID    pContext,
    IN  UINT     Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:

    This callback routine is used with SetupScanFileQueue to findout the
    dependent files and ICM files associated in an INF. All files going to the
    printer driver directory are dependent files in DRIVER_INFO_6, and all
    files goint to the Color directory are ICM files.

    We use SetupScanFileQueue twice. We find the size of the buffers required
    for the multi-sz fields in the first pass. After allocating buffers of size
    found in first pass second pass is used to copy the strings and build the
    multi-sz fields.

Arguments:

    pContext        : Gives the SCAN_INFO structure
    Notification    : Ignored
    Param1          : Gives the target file name
    Param2          : Ignored

Return Value:
    Win32 error code

--*/
{
    DWORD               dwLen;
    LPTSTR              pszTarget = (LPTSTR)Param1, pszFileName;
    PSCAN_INFO          pScanInfo = (PSCAN_INFO)pContext;
    LPDRIVER_INFO_6     pDriverInfo6;

    pszFileName = FileNamePart(pszTarget);

    if ( pszFileName )
    {
        dwLen = lstrlen(pszFileName) + 1;

        if ( !lstrncmpi(pszTarget,
                        gpszSkipDir,
                        lstrlen( gpszSkipDir ) ) )
           goto Done;

        if ( !lstrncmpi(pszTarget,
                        pScanInfo->szDriverDir,
                        pScanInfo->cchDriverDir) ) {

            pDriverInfo6 = &pScanInfo->pLocalData->InfInfo.DriverInfo6;
            //
            // On NT dependent file list will not include files appearing as
            // other DRIVER_INFO_6 fields
            //
            if ( !pScanInfo->bWin95 &&
                 ( !lstrcmpi(pszFileName, pDriverInfo6->pDriverPath)  ||
                   !lstrcmpi(pszFileName, pDriverInfo6->pConfigFile)  ||
                   !lstrcmpi(pszFileName, pDriverInfo6->pDataFile)    ||
                   ( pDriverInfo6->pHelpFile &&
                     !lstrcmpi(pszFileName, pDriverInfo6->pHelpFile))) )
                goto Done;

            //
            // If pointer is not NULL this is pass 2
            //
            if ( pScanInfo->p1 ) {

                lstrcpy(pScanInfo->p1, pszFileName);
                pScanInfo->p1 += dwLen;
            } else {

                pScanInfo->cchDependentFiles  += dwLen;
            }
        } else if ( !lstrncmpi(pszTarget,
                               pScanInfo->szColorDir,
                               pScanInfo->cchColorDir) ) {

            //
            // If pointer is not NULL this is pass 2
            //
            if ( pScanInfo->p2 ) {

                lstrcpy(pScanInfo->p2, pszFileName);
                pScanInfo->p2 += dwLen;
            } else {

                pScanInfo->cchICMFiles  += dwLen;
            }
        }
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

Done:
    return NO_ERROR;
}


BOOL
InfGetDependentFilesAndICMFiles(
    IN      HDEVINFO            hDevInfo,
    IN      HINF                hInf,
    IN      BOOL                bWin95,
    IN OUT  PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags,
    IN      LPCTSTR             pszSectionNameWithExt,
    IN OUT  LPDWORD             pcchSize
    )
/*++

Routine Description:
    Findout the dependent files for the DRIVER_INFO_6 and the ICM files
    for the selected driver

    This is done by simulating the install operation by create a setup
    queue to do the install operations and scanning the queue to find out
    where files are getting copied to

    Dependent files are those getting copied to driver scratch directory
    without including other DRIVER_INFO_6 fields like pDriverPath. For Win95
    case all files getting copied to the driver directory are dependent files.

    ICM files are those getting copied to the color directory

Arguments:
    hInf                    : INF handle
    bWin95                  : TRUE if it is a Win95 INF
    pLocalData              : INF parsing information
    pszSectionNameWithExt   : Section name with extension for install
    pcchSize                : Size needed for DRIVER_INFO_6 and strings in it

Return Value:
    TRUE on success, FALSE on error

--*/
{
    BOOL        bRet         = FALSE;
    DWORD       dwResult;
    SCAN_INFO   ScanInfo;
    HSPFILEQ    ScanQueue    = INVALID_HANDLE_VALUE;
    LPTSTR      ppszDepFiles = NULL,
                pszzICMFiles = NULL;

    SP_DEVINSTALL_PARAMS StoreDevInstallParams = {0};
    SP_DEVINSTALL_PARAMS DevInstallParams      = {0};
    SP_ALTPLATFORM_INFO  AltPlat_Info          = {0};
    OSVERSIONINFO        OSVer                 = {0};

    ScanInfo.p1 = ScanInfo.p2 = NULL;
    ScanInfo.cchDependentFiles = ScanInfo.cchICMFiles = 0;

    ScanInfo.cchColorDir    = sizeof(ScanInfo.szColorDir);
    ScanInfo.cchDriverDir   = sizeof(ScanInfo.szDriverDir);

    if ( !GetColorDirectory( pszServerName, ScanInfo.szColorDir, &ScanInfo.cchColorDir) ||
         !GetSystemDirectory(ScanInfo.szDriverDir, ScanInfo.cchDriverDir) ) {

        goto Cleanup;
    }

    //
    // Set ScanInfo.cchColorDir to char count of ScanInfo.szColorDir without \0
    //
    ScanInfo.cchColorDir /= sizeof(TCHAR);
    --ScanInfo.cchColorDir;

    //
    // Win95 INFs tell setup to copy the driver files to system32 directory
    // NT INFs expect install programs to set the target using
    // SetupSetDirectoryId
    //
    if ( bWin95 ) {

        ScanInfo.cchDriverDir = lstrlen(ScanInfo.szDriverDir);
    } else {
        if ( !GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                        PlatformEnv[platform].pszName,
                                        1,
                                        (LPBYTE)ScanInfo.szDriverDir,
                                        ScanInfo.cchDriverDir,
                                        &ScanInfo.cchDriverDir) )
            goto Cleanup;
        //
        // Set ScanInfo.cchDriverDir to char count of ScanInfo.szDriverDir
        // without \0
        //
        ScanInfo.cchDriverDir   /= sizeof(TCHAR);
        --ScanInfo.cchDriverDir;
    }

    //
    // Inf MAY refer to another one (like layout.inf)
    //
    SetupOpenAppendInfFile(NULL, hInf, NULL);

    ScanInfo.bWin95     = bWin95;
    ScanInfo.pLocalData = pLocalData;

    ScanQueue = SetupOpenFileQueue();

    if (ScanQueue == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                      NULL,
                                      &DevInstallParams))
    {
        goto Cleanup;
    }

    if(!GetOSVersion(pszServerName, &OSVer))
    {
        goto Cleanup;
    }
    //
    // Save the current config...
    //
    memcpy(&StoreDevInstallParams, &DevInstallParams, sizeof(DevInstallParams));

    DevInstallParams.FlagsEx   |= DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
    DevInstallParams.Flags     |= DI_NOVCP;
    DevInstallParams.FileQueue = ScanQueue;

    AltPlat_Info.cbSize                     = sizeof(SP_ALTPLATFORM_INFO);
    AltPlat_Info.MajorVersion               = OSVer.dwMajorVersion;
    AltPlat_Info.MinorVersion               = OSVer.dwMinorVersion;
    AltPlat_Info.Platform                   = PlatformArch[ platform ][OS_PLATFORM];
    AltPlat_Info.ProcessorArchitecture      = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];
    AltPlat_Info.Reserved                   = 0;
    AltPlat_Info.FirstValidatedMajorVersion = AltPlat_Info.MajorVersion;
    AltPlat_Info.FirstValidatedMinorVersion = AltPlat_Info.MinorVersion;

    if(!SetupDiSetDeviceInstallParams(hDevInfo,
                                      NULL,
                                      &DevInstallParams) ||
       !SetupSetFileQueueAlternatePlatform(ScanQueue,
                                           &AltPlat_Info,
                                           NULL))
    {
        goto Cleanup;
    }

    //
    // First pass using SetupScanFileQueue will find the sizes required
    //
    if ( !InstallAllInfSections( pLocalData,
                                 platform,
                                 pszServerName,
                                 ScanQueue,
                                 NULL,
                                 dwInstallFlags,
                                 hInf,
                                 pszSectionNameWithExt ) ||
         !SetupScanFileQueue(ScanQueue,
                             SPQ_SCAN_USE_CALLBACK,
                             0,
                             DriverInfoCallback,
                             &ScanInfo,
                             &dwResult) ) {

        goto Cleanup;
    }

    if ( ScanInfo.cchDependentFiles ) {

        ++ScanInfo.cchDependentFiles;

        ppszDepFiles = (LPTSTR) LocalAllocMem(ScanInfo.cchDependentFiles * sizeof(TCHAR));
        if ( !ppszDepFiles )
            goto Cleanup;

        ScanInfo.p1 = ppszDepFiles;
    }

    if ( ScanInfo.cchICMFiles ) {

        ++ScanInfo.cchICMFiles;
        pszzICMFiles = (LPTSTR) LocalAllocMem(ScanInfo.cchICMFiles * sizeof(TCHAR));

        if ( !pszzICMFiles )
            goto Cleanup;

        ScanInfo.p2 = pszzICMFiles;
    }

    //
    // Second call to SetupScanFileQueue build the actual multi-sz fields
    //
    bRet = SetupScanFileQueue(ScanQueue,
                              SPQ_SCAN_USE_CALLBACK,
                              0,
                              DriverInfoCallback,
                              &ScanInfo,
                              &dwResult);

Cleanup:

    //
    // Save the last error as it may get toasted by the following calls.
    //
    dwResult = GetLastError();

    if ( ScanQueue != INVALID_HANDLE_VALUE )
    {
        DevInstallParams.FlagsEx   &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
        DevInstallParams.Flags     &= ~DI_NOVCP;
        DevInstallParams.FileQueue = INVALID_HANDLE_VALUE;
      
        if (!SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DevInstallParams))
        {
            dwResult = (ERROR_SUCCESS == dwResult) ? GetLastError() : dwResult;
        }

        SetupCloseFileQueue(ScanQueue);
    }

    if(StoreDevInstallParams.cbSize == sizeof(DevInstallParams))
    {
        //
        // Reset the HDEVINFO params.
        //
        SetupDiSetDeviceInstallParams(hDevInfo,
                                      NULL,
                                      &StoreDevInstallParams);
    }

    if ( bRet ) {

        *pcchSize  += ScanInfo.cchDependentFiles;
        pLocalData->InfInfo.DriverInfo6.pDependentFiles = ppszDepFiles;
        pLocalData->InfInfo.pszzICMFiles = pszzICMFiles;
    } else {

        LocalFreeMem(ppszDepFiles);
        LocalFreeMem(pszzICMFiles);
    }

    SetLastError(dwResult);

    return bRet;
}


VOID
DestroyCodedownload(
    PCODEDOWNLOADINFO   pCodeDownLoadInfo
    )
{
    if ( pCodeDownLoadInfo ) {

        pCodeDownLoadInfo->pfnClose(pCodeDownLoadInfo->hConnection);

        if ( pCodeDownLoadInfo->hModule )
            FreeLibrary(pCodeDownLoadInfo->hModule);

        LocalFreeMem(pCodeDownLoadInfo);
    }
}


BOOL
InitCodedownload(
    HWND    hwnd
    )
{
    BOOL                bRet = FALSE;
    PCODEDOWNLOADINFO   pCDMInfo = NULL;


    EnterCriticalSection(&CDMCritSect);

    // We already have a context & function pointers
    // So reuse them...
    if (gpCodeDownLoadInfo)
    {
       LeaveCriticalSection(&CDMCritSect);
       return TRUE;
    }

    pCDMInfo = (PCODEDOWNLOADINFO) LocalAllocMem(sizeof(CODEDOWNLOADINFO));

    if ( !pCDMInfo )
        goto Cleanup;

    pCDMInfo->hModule = LoadLibraryUsingFullPath(TEXT("cdm.dll"));

    if ( !pCDMInfo->hModule )
        goto Cleanup;

    (FARPROC)pCDMInfo->pfnOpen = GetProcAddress(pCDMInfo->hModule,
                                                "OpenCDMContext");

    (FARPROC)pCDMInfo->pfnDownload = GetProcAddress(pCDMInfo->hModule,
                                                    "DownloadUpdatedFiles");

    (FARPROC)pCDMInfo->pfnClose = GetProcAddress(pCDMInfo->hModule,
                                                 "CloseCDMContext");

    bRet = pCDMInfo->pfnOpen       &&
           pCDMInfo->pfnDownload   &&
           pCDMInfo->pfnClose;

    if ( bRet )
        pCDMInfo->hConnection = pCDMInfo->pfnOpen(hwnd);

Cleanup:

    if ( !bRet ||
         ( pCDMInfo && !pCDMInfo->hConnection ) ) {

        DestroyCodedownload(pCDMInfo);
        pCDMInfo = NULL;
        bRet = FALSE;
    }

    if (bRet)
       gpCodeDownLoadInfo = pCDMInfo;

    LeaveCriticalSection(&CDMCritSect);
    return bRet;
}


DWORD
PSetupInstallPrinterDriverFromTheWeb(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  LPOSVERSIONINFO     pOsVersionInfo,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszSource
    )
{
   BOOL                bRet = FALSE;
   DWORD               dwLen, dwReturn = ERROR_SUCCESS;
   UINT                uNeeded;
   TCHAR               szSourceDir[MAX_PATH];
   DOWNLOADINFO        DownLoadInfo;
   PPSETUP_LOCAL_DATA  pNewLocalData = NULL;

   INT                 clpFileBufferLength     = 0;
   INT                 cProviderNameLength     = 0;
   INT                 cManufacturerNameLength = 0;
   INT                 cDriverNameLength       = 0;


   ZeroMemory(&DownLoadInfo, sizeof(DownLoadInfo));

   if ( !gpCodeDownLoadInfo )
      goto Cleanup;

   DownLoadInfo.dwDownloadInfoSize = sizeof(DownLoadInfo);
   DownLoadInfo.localid            = lcid;

   // dwLen = lstrlen( cszWebNTPrintPkg );
   dwLen = lstrlen(pLocalData->DrvInfo.pszHardwareID);

   //
   // lpHardwareIDs is multi-sz
   //
   if ( !(DownLoadInfo.lpHardwareIDs = LocalAllocMem((dwLen + 2 ) * sizeof(TCHAR))) )
      goto Cleanup;

   // lstrcpy(DownLoadInfo.lpHardwareIDs, cszWebNTPrintPkg );
   lstrcpy( (LPTSTR) DownLoadInfo.lpHardwareIDs, pLocalData->DrvInfo.pszHardwareID);

   CopyMemory(&DownLoadInfo.OSVersionInfo,
              pOsVersionInfo,
              sizeof(OSVERSIONINFO));

   // Assign the correct Processor Architecture to the download
   DownLoadInfo.dwArchitecture = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];

   DownLoadInfo.lpFile = NULL;

   //
   // Below we have to check if we have valid Provider, Manufacturer, and
   // driver names and if this is the case then we have to prepare a
   // MULTISZ including Provider, Manufacturer, and Driver Names,
   // and to set a pointer to that MULTISZ into DownLoadInfo.lpFile
   //
   if (pLocalData->DrvInfo.pszProvider &&
       pLocalData->DrvInfo.pszManufacturer &&
       pLocalData->DrvInfo.pszModelName) 
   {
       cProviderNameLength = lstrlen(pLocalData->DrvInfo.pszProvider);
       if (cProviderNameLength) 
       {
           cManufacturerNameLength = lstrlen(pLocalData->DrvInfo.pszManufacturer);
           if (cManufacturerNameLength) 
           {
               cDriverNameLength = lstrlen(pLocalData->DrvInfo.pszModelName);
               if (cDriverNameLength) 
               {
                   clpFileBufferLength = cProviderNameLength + 1 +
                                         cManufacturerNameLength + 1 +
                                         cDriverNameLength + 1 +
                                         1;
                   DownLoadInfo.lpFile = (LPTSTR)LocalAllocMem(clpFileBufferLength * sizeof(TCHAR));
                   if (DownLoadInfo.lpFile) 
                   {
                       lstrcpy( (LPTSTR)(DownLoadInfo.lpFile), (LPTSTR)(pLocalData->DrvInfo.pszProvider));
                       lstrcpy( (LPTSTR)(DownLoadInfo.lpFile + cProviderNameLength + 1), (LPTSTR)(pLocalData->DrvInfo.pszManufacturer));
                       lstrcpy( (LPTSTR)(DownLoadInfo.lpFile + cProviderNameLength + 1 + cManufacturerNameLength + 1), (LPTSTR)(pLocalData->DrvInfo.pszModelName));
                   }
               }
           }
       }
   }

   if ( !gpCodeDownLoadInfo->pfnDownload(gpCodeDownLoadInfo->hConnection,
                                         hwnd,
                                         &DownLoadInfo,
                                         szSourceDir,
                                         SIZECHARS(szSourceDir),
                                         &uNeeded) )
      goto Cleanup;

   // Now rework install data based on the actual INF
   pNewLocalData = RebuildDeviceInfo( hDevInfo, pLocalData, szSourceDir );

   if ( pNewLocalData == NULL )
      goto Cleanup;

   pNewLocalData->DrvInfo.Flags |= SDFLAG_CDM_DRIVER;

   dwReturn = InstallDriverFromCurrentInf(hDevInfo,
                                          pNewLocalData,
                                          hwnd,
                                          platform,
                                          dwThisMajorVersion,
                                          pszServerName,
                                          INVALID_HANDLE_VALUE,
                                          NULL,
                                          NULL,
                                          0,
                                          szSourceDir,
                                          DRVINST_FLATSHARE | DRVINST_NO_WARNING_PROMPT,
                                          APD_COPY_NEW_FILES,
                                          NULL,
                                          NULL,
                                          NULL);

   (VOID) DeleteAllFilesInDirectory(szSourceDir, TRUE);

   if ( dwReturn == ERROR_SUCCESS )
      bRet = TRUE;

Cleanup:

   if ( pNewLocalData )
      DestroyLocalData( pNewLocalData );

   LocalFreeMem((PVOID)DownLoadInfo.lpHardwareIDs);
   LocalFreeMem((PVOID)DownLoadInfo.lpFile);

   CleanupScratchDirectory(pszServerName, platform);

   if ( !bRet && ( dwReturn == ERROR_SUCCESS ) )
      dwReturn = STG_E_UNKNOWN;

   return dwReturn;
}


/*++

Routine Name:

    PSetupInstallInboxDriverSilently

Routine Description:

    This is used to install inbox drivers silently. The driver must exist in
    ntprint.inf. The inf isn't passed in to make the only code that needs to know
    about ntprint.inf reside in setup.

Arguments:

    pszDriverName       -   The driver name that we want to install.

Return Value:

    BOOL, Last error

--*/
DWORD
PSetupInstallInboxDriverSilently(
    IN      LPCTSTR     pszDriverName
    )
{
    DWORD   Status  = ERROR_SUCCESS;
    TCHAR   szInfFile[MAX_PATH];

    Status = pszDriverName ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Get the system directory.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = GetSystemWindowsDirectory(szInfFile, COUNTOF(szInfFile)) ? ERROR_SUCCESS : GetLastError();
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = StrNCatBuff(szInfFile, COUNTOF(szInfFile), szInfFile, TEXT("\\"), szNtPrintInf, NULL);
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = InstallDriverSilently(szInfFile, pszDriverName, NULL);
    }

    return Status;
}

/*++

Routine Name:

    InstallDriverSilently

Routine Description:

    Install the given printer driver from the given inf from the optional
    source directory, do not pop up UI and fail if UI would be required.

Arguments:

    pszInfFile      -   The inf file to install the driver from.
    pszDriverName   -   The driver name.
    pszSource       -   The source installation location.

Return Value:

    BOOL, Last error

--*/
DWORD
InstallDriverSilently(
    IN      LPCTSTR     pszInfFile,
    IN      LPCTSTR     pszDriverName,
    IN      LPCTSTR     pszSource
    )
{
    HDEVINFO            hDevInfo        = INVALID_HANDLE_VALUE;
    DWORD               dwInstallFlags  = DRVINST_PROGRESSLESS | DRVINST_PROMPTLESS;
    PPSETUP_LOCAL_DATA  pData           = NULL;
    DWORD               Status          = ERROR_SUCCESS;

    Status = pszInfFile && pszDriverName ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Ensure that setupapi does not throw any UI
    //
    SetupSetNonInteractiveMode(TRUE);

    if (Status == ERROR_SUCCESS)
    {
        if ((hDevInfo = PSetupCreatePrinterDeviceInfoList(NULL)) != INVALID_HANDLE_VALUE    &&
            PSetupBuildDriversFromPath(hDevInfo, pszInfFile, TRUE)                          &&
            PSetupPreSelectDriver(hDevInfo, NULL, pszDriverName)                            &&
            (pData = BuildInternalData(hDevInfo, NULL)) != NULL                             &&
            ParseInf(hDevInfo, pData, MyPlatform, NULL, dwInstallFlags))
        {
            Status = ERROR_SUCCESS;
        }
        else
        {
            //
            // Ensure that if we have a failure the return is shown as such.
            //
            Status = GetLastError();

            Status = Status == ERROR_SUCCESS ? ERROR_INVALID_DATA : Status;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // We don't want to launch a vendor setup entry, but vendor setup
        // only gets launch after an AddPrinter call, which we're not doing - just adding drivers here.
        // NOTE: For future if this included Queue creation we WILL have to handle this.
        //
        Status = PSetupInstallPrinterDriver(hDevInfo,
                                            pData,
                                            NULL,
                                            MyPlatform,
                                            dwThisMajorVersion,
                                            NULL,
                                            NULL,
                                            NULL,
                                            pszSource,
                                            dwInstallFlags,
                                            APD_COPY_NEW_FILES,
                                            NULL);
    }

    //
    // Switch on setupapi UI again
    //
    SetupSetNonInteractiveMode(FALSE);

    if(pData != NULL)
    {
        PSetupDestroySelectedDriverInfo(pData);
    }

    //
    // Release the driver setup parameter handle.
    //
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        PSetupDestroyPrinterDeviceInfoList( hDevInfo );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\signing.cxx ===
/*

Copyright (c) 1995-2000 Microsoft Corporation
All rights reserved.

Module Name:

    Signing.cxx

Abstract:

    Driver signing functions

Author:

    Patrick Vine (PVine) 1-Jun-2000

Revision History:

*/

#include "precomp.h"
#include "wintrust.h"

#pragma hdrstop
#include "signing.hxx"

PVOID
SetupDriverSigning( 
    IN  HDEVINFO hDevInfo,
    IN LPCTSTR   pszServerName,
    IN LPTSTR    pszInfName,
    IN LPCTSTR   pszSource,
    IN PLATFORM  platform,
    IN DWORD     dwVersion,
    IN HSPFILEQ  CopyQueue,
    IN BOOL      bWeb
    )
{
    TDriverSigning * pDSInfo;

    //
    // Create Driver Signing object and process it.
    //
    pDSInfo = new TDriverSigning();

    if(pDSInfo)
    {
        //
        // Set up the driver signing info.
        // And then call the Setup API to change the parms on the FileQueue
        //        
        if(!pDSInfo->InitDriverSigningInfo(pszServerName,pszInfName, pszSource, platform, dwVersion, bWeb) ||
           !pDSInfo->SetAltPlatformInfo(hDevInfo, CopyQueue))
        {
            delete pDSInfo;
            pDSInfo = NULL;
        }
    }

    return pDSInfo;
}

BOOL
GetCatalogFile(
    IN  HANDLE hDriverSigning,
    OUT PCWSTR *ppszCat
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = hDriverSigning && ppszCat ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppszCat = reinterpret_cast<TDriverSigning*>(hDriverSigning)->GetCatalogFile();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return  SUCCEEDED(hRetval);
}

BOOL
DrvSigningIsLocalAdmin(
    IN  HANDLE hDriverSigning,
    OUT BOOL   *pbIsLocalAdmin
    )
{
    HRESULT hRetval = E_FAIL; 
    
    hRetval = hDriverSigning && pbIsLocalAdmin ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        *pbIsLocalAdmin = reinterpret_cast<TDriverSigning*>(hDriverSigning)->IsLocalAdmin();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }
    
    return  SUCCEEDED(hRetval);
}

BOOL
CleanupDriverSigning(
    IN PVOID pDSInfo
    )
{
    TDriverSigning * pDS = static_cast<TDriverSigning*>(pDSInfo);

    if(pDS)
    {
        delete pDS;
    }

    return TRUE;
}

BOOL
CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
    )
{
    TDriverSigning DSInfo;

    return (DSInfo.CheckForCatalogFileInInf(pszInfName,
                                            lppszCatFile));
}

BOOL
IsCatInInf(
    IN PVOID pDSInfo
    )
{
    if(!pDSInfo)
    {
        return FALSE;
    }

    return (((TDriverSigning*)pDSInfo)->CatInInf());
}



TDriverSigning::TDriverSigning( 
    ) : m_pszCatalogFileName(NULL),
        m_bCatInInf(TRUE),
        m_bDeleteTempCat(FALSE),
        m_bSetAltPlatform(FALSE),
        m_DSPlatform(MyPlatform),
        m_DSMajorVersion(dwThisMajorVersion),
        m_bIsLocalAdmin(TRUE)
{
    ZeroMemory(&m_AltPlat_Info, sizeof(SP_ALTPLATFORM_INFO));
    m_AltPlat_Info.cbSize = sizeof(SP_ALTPLATFORM_INFO);
}

TDriverSigning::~TDriverSigning()
{
    if(m_bDeleteTempCat) 
    {
        RemoveTempCat();
    }

    if(m_pszCatalogFileName) 
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = NULL;
    }
}

/*

Function: CreateCTLContextFromFileName

Purpose:  Given a fully qualified file name, create the CCTL_CONTEXT to use
          to search for the cat OsAttr field to use for testing the signing.

Returns:  TRUE on successfully getting a PCCTL_CONTEXT
          FALSE otherwise

*/
BOOL
TDriverSigning::CreateCTLContextFromFileName(
    IN  LPCTSTR         pszFileName,
    OUT PCCTL_CONTEXT   *ppCTLContext)
{
    LPVOID  pvMappedFile = NULL;
    BOOL    bRet         = FALSE;
    HANDLE  hFile        = INVALID_HANDLE_VALUE;
    DWORD   cbFile       = 0;
    HANDLE  hMappedFile  = NULL;

    if( !ppCTLContext )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    //
    // Initialize out params
    //
    *ppCTLContext = NULL;

    //
    // Open the existing catalog file 
    //
    if(INVALID_HANDLE_VALUE == (hFile = CreateFile(pszFileName,
                                                   GENERIC_READ,
                                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                   NULL,
                                                   OPEN_EXISTING,
                                                   FILE_ATTRIBUTE_NORMAL,
                                                   NULL)))
    {
        goto Cleanup;
    }

    if(0xFFFFFFFF == (cbFile = GetFileSize(hFile, NULL)))
    {
        goto Cleanup;
    }

    if(NULL == (hMappedFile = CreateFileMapping(hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                0,
                                                NULL)))
    {
        goto Cleanup;
    }
    
    pvMappedFile = (LPVOID) MapViewOfFile(hMappedFile, 
                                          FILE_MAP_READ, 
                                          0, 
                                          0, 
                                          cbFile);
    if (pvMappedFile)
    {
        //
        // Don't need the file handle since we have a mapped file handle
        //
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        if (NULL != (*ppCTLContext = (PCCTL_CONTEXT) 
                                        CertCreateContext(CERT_STORE_CTL_CONTEXT,
                                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                          (LPBYTE)pvMappedFile,
                                                          cbFile,
                                                          0,
                                                          NULL)))
        {
            bRet = TRUE;
        }
    }

Cleanup:

    if (pvMappedFile)
    {
        UnmapViewOfFile(pvMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return bRet;
}


/*
Stolen from newnt\ds\security\cryptoapi\pkitrust\softpub\drvprov.cpp - _FillVersionLongs
*/

BOOL
TDriverSigning::TranslateVersionInfo(
    IN OUT WCHAR *pwszMM, 
    IN OUT long *plMajor, 
    IN OUT long *plMinor, 
    IN OUT WCHAR *pwcFlag
    )
{
    //
    //  special characters:
    //      - = all versions less than or equal to
    //      < = all versions less than or equal to
    //      > = all versions greater than or equal to
    //      X = all sub-versions.
    //
    WCHAR   *pwszEnd;

    if(!pwszMM || !*pwszMM || !plMajor || !plMinor || !pwcFlag)
    {
        return FALSE;
    }

    *pwcFlag = L'\0';

    *plMajor = (-1L);

    *plMinor = (-1L);

    if (NULL == (pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
    {
        return FALSE;
    }

    *pwszEnd = L'\0';

    *plMajor = _wtol(pwszMM);

    *pwszEnd = OSATTR_VERSEP;

    pwszMM = pwszEnd;

    pwszMM++;

    if (*pwszMM)
    {
       if ((*pwszMM == OSATTR_GTEQ) ||
           (*pwszMM == OSATTR_LTEQ) ||
           (*pwszMM == OSATTR_LTEQ2) ||
           (towupper(*pwszMM) == OSATTR_ALL))
        {
            *pwcFlag = towupper(*pwszMM);
            return(TRUE);
        }

        if (!(pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
        {
            *plMinor = _wtol(pwszMM);
            return(TRUE);
        }

        *pwszEnd = L'\0';

        *plMinor = _wtol(pwszMM);

        *pwszEnd = OSATTR_VERSEP;

        pwszMM = pwszEnd;

        pwszMM++;
    }
    else
    {
        return(TRUE);
    }

    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlag = towupper(*pwszMM);
    }

    return(TRUE);
}


/*

Function: CheckVersioning

Purpose:  Takes the passed pszOsAttr string and determines what OS it represents.
          The OS numbers get returned in pdwMajorVersion and pdwMinorVersion.

Returns:  TRUE if the pszOsAttr represents a valid OS for the platform and dwVersion specified.
          FALSE otherwise

Parameters: 
          IN     LPWSTR   pszOsAttr         - the OsAttr string from the cat to verify against.
          IN     PLATFORM platform          - the platform that this is cat is being installed for.
          IN     DWORD    dwVersion         - the version that of driver that this is supposed to be signed for.
          IN OUT LPDWORD  pdwMajorVersion   - Initially holds the current major version OS.  
                                              Returns with the OS major version to test against for this OsAttr field.
          IN OUT LPDWORD  pdwMinorVersion   - Initially holds the current minor version OS.  
                                              Returns with the OS minor version to test against for this OsAttr field.

Notes:    If plaform != m_DSPlatform or dwVersion != m_DSMajorVersion then we are installing 
          an additional driver, in which case we just determine what the cat file is signed 
          for and use this.  Otherwise if the cat file is signed for anything less than or 
          equal to the current OS, then set that as the OS to test signing against.  If the 
          cat is signed only for NT4 return false in this case and hope the cat is signed for
          some other OS as well.  We want to warn on NT4 "have disk" installs.

*/
BOOL
TDriverSigning::CheckVersioning( 
    IN     LPWSTR   pszOsAttr,
    IN     PLATFORM platform,
    IN     DWORD    dwVersion,
    IN OUT LPDWORD  pdwMajorVersion,
    IN OUT LPDWORD  pdwMinorVersion 
    )
{
    BOOL  bRet        = FALSE;
    WCHAR wcFlag;
    long  lMajor,
          lMinor;

    //
    // Is this signed for NT/Win9x at all.
    //
    if((*pszOsAttr == OSATTR_VER || 
        ((*pszOsAttr == OSATTR_VER_WIN9X) && platform == PlatformWin95)) &&
       (*pszOsAttr ++)                                                   &&
       *pszOsAttr++ == OSATTR_OSSEP)
    {
        if(TranslateVersionInfo(pszOsAttr, &lMajor, &lMinor, &wcFlag))
        {
            //
            // Set the minor version number if it hasn't been set.
            //
            if(lMinor == -1)
                lMinor = 0;

            if(platform != m_DSPlatform || dwVersion != m_DSMajorVersion)
            {
                //
                // This isn't to run on this platform, so just test the signing for what it is signed for.
                //
                *pdwMajorVersion = lMajor;
                *pdwMinorVersion = lMinor;
                bRet = TRUE;
            }
            else
            {
                //
                // This is to run on this platform, so make sure it isn't signed for something 
                // newer than this platform.  Warn if it signed for NT4 as we want this for
                // "have disk" installs of NT4 drivers.
                //
                if(lMajor != 4)
                {
                    if(lMajor > (long)*pdwMajorVersion)
                    {
                        //
                        // Newer major version number
                        //
                        if(wcFlag == OSATTR_LTEQ ||
                           wcFlag == OSATTR_LTEQ2)
                        {
                            bRet = TRUE;
                        }
                    }
                    else
                    {
                        if(lMajor < (long)*pdwMajorVersion)
                        {
                            //
                            // Older major version number
                            // If OSATTR_GTEQ - we don't need to change the signing info.
                            //
                            if(wcFlag != OSATTR_GTEQ)
                            {
                                *pdwMajorVersion = lMajor;
                                *pdwMinorVersion = lMinor;
                            }
                            bRet = TRUE;
                        }
                        else
                        {
                            //
                            // Same major version number
                            // look at minor numbers...
                            //
                            if(wcFlag == OSATTR_ALL)
                            {
                                bRet = TRUE;
                            }
                            else
                            {
                                if(lMinor <= (long)*pdwMinorVersion)
                                {
                                    if(wcFlag != OSATTR_GTEQ)
                                    {
                                        *pdwMinorVersion = lMinor;
                                    }
                                    bRet = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return bRet;
}

/*

GetSigningInformation - Opens the passed catalog file and determines what the file is signed for.

Parameters:
    pszCatPathName    - The fully qualified path to the cat file to open.
    platform          - The platform we're doing this on.  There is slightly different logic for
                        if platform == m_DSPlatform vs. platform != m_DSPlatform
    dwVersion         - The printer driver version number that we are installing.
    pdwMajorVersion   - The major version number to use for testing the signing.
    pdwMinorVersion   - The minor version number to use for testing the signing.

Returns:
    The last error set.

Remarks:
    This loops through the OsAttr entry in the cat file and looks at what the cat file is signed for.
    If platform == m_DSPlatform and dwVersion == m_DSMajorVersion, then it must be signed for any 
         OS Version less than or equal to the current OS version that I'm installing on.
    Else it must be signed for some OS and we'll test the signing for that.

*/
DWORD
TDriverSigning::GetSigningInformation( 
    IN  PLATFORM platform,
    IN  DWORD    dwVersion,
    OUT LPDWORD  pdwMajorVersion,
    OUT LPDWORD  pdwMinorVersion
    )
{
    PCCTL_CONTEXT   pCTLContext  = NULL;
    CTL_INFO        *pCtlInfo    = NULL;
    CAT_NAMEVALUE   *pNV         = NULL;
    DWORD           cbDecoded;
    DWORD           i;
    OSVERSIONINFO   OSVerInfo    = {0};

    if(!pdwMajorVersion || !pdwMinorVersion)
    {
        return ERROR_INVALID_PARAMETER;
    }

    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&OSVerInfo))
    {
        //
        // Set up some defaults (why not 5.0?) and return
        // because this should never be failing.
        //
        *pdwMajorVersion = 5;
        *pdwMinorVersion = 0;
        goto Cleanup;
    }

    //
    //  Default the version info to that of the current version.
    //
    *pdwMajorVersion = OSVerInfo.dwMajorVersion;
    *pdwMinorVersion = OSVerInfo.dwMinorVersion;

    if(!m_pszCatalogFileName || !*m_pszCatalogFileName)
    {
        return ERROR_SUCCESS;
    }

    if( CreateCTLContextFromFileName(m_pszCatalogFileName, &pCTLContext) && 
        pCTLContext                                                      && 
        NULL != (pCtlInfo = pCTLContext->pCtlInfo))
    {
        for (i=0; i<pCtlInfo->cExtension; i++)
        {
            if (strcmp(CAT_NAMEVALUE_OBJID, pCtlInfo->rgExtension[i].pszObjId) == 0)
            {
                if (!CryptDecodeObject(  
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                CAT_NAMEVALUE_STRUCT,
                                pCtlInfo->rgExtension[i].Value.pbData,
                                pCtlInfo->rgExtension[i].Value.cbData,
                                0,
                                NULL,
                                &cbDecoded))
                {
                    goto Cleanup;
                }

                if (cbDecoded > 0)
                {
                    if (NULL == (pNV = (CAT_NAMEVALUE *) LocalAllocMem(cbDecoded)))
                    {
                        goto Cleanup;
                    }

                    if (!(CryptDecodeObject(    
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                CAT_NAMEVALUE_STRUCT,
                                pCtlInfo->rgExtension[i].Value.pbData,
                                pCtlInfo->rgExtension[i].Value.cbData,
                                0,
                                pNV,
                                &cbDecoded)))
                    {
                        goto Cleanup;
                    }

                    if (_wcsicmp(pNV->pwszTag, L"OSAttr") == 0)
                    {
                        PWCHAR pVersioning = NULL;
                        PWCHAR pEnd;

                        pVersioning = (PWCHAR)pNV->Value.pbData;

                        while(pVersioning && *pVersioning)
                        {
                            pEnd = wcschr(pVersioning, OSATTR_SEP);

                            if(pEnd)
                            {
                                *pEnd = L'\0';
                            }

                            if(CheckVersioning(pVersioning, platform, dwVersion, pdwMajorVersion, pdwMinorVersion))
                            {
                                break;
                            }
    
                            if(!pEnd)
                            {
                                break;
                            }
    
                            *pEnd = OSATTR_SEP;
                            pVersioning = pEnd+1;
                        }
    
                        SetLastError(ERROR_SUCCESS);
                    }
                }

            }
        }
    }

Cleanup:

    if(pCTLContext)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if(pNV)
    {
        LocalFreeMem(pNV);
    }

    return (GetLastError());
}


/*++

Routine Description:
    Checks to see if an INF specifies a CatalogFile= entry.

Arguments:
    hInf            : Printer driver INF file handle
    lppszCatFile    : CatFileName returned - may be passed as NULL

Return Value:
    TRUE  - CatalogFile= specified in the inf file.
    FALSE - None specified.

    If lppszCatFile is not NULL, it will hold the name of the cat referenced in the inf if there is one.

--*/
BOOL
TDriverSigning::CheckForCatalogFileInInf(
    IN  LPCTSTR pszInfName,
    OUT LPTSTR  *lppszCatFile    OPTIONAL
)
{
   PSP_INF_INFORMATION pInfInfo   = NULL;
   HINF                hInf       = INVALID_HANDLE_VALUE;
   BOOL                bRet       = FALSE;
   DWORD               dwBufNeeded;

   if(!pszInfName ||
      INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(pszInfName,
                                                       NULL,
                                                       INF_STYLE_WIN4,
                                                       NULL)))
   {
       goto Cleanup;
   }

   if(lppszCatFile)
   {
       *lppszCatFile = _TEXT('\0');
   }

   //
   // First Find out Buffer Needed
   //
   if(SetupGetInfInformation(hInf, INFINFO_INF_SPEC_IS_HINF,
                              NULL, 0, &dwBufNeeded))
   {
      //
      // Alloc Mem needed
      //
      pInfInfo = (PSP_INF_INFORMATION) LocalAllocMem(dwBufNeeded);
      if(pInfInfo)
      {
         //
         // Now get the info about the INF
         //
         if(SetupGetInfInformation(hInf, INFINFO_INF_SPEC_IS_HINF,
                                   pInfInfo, dwBufNeeded, &dwBufNeeded))
         {
            //
            // Ask Setup to find the name of the Catalog file in the INF
            //
            SP_ORIGINAL_FILE_INFO OrigInfo ={0};
            OrigInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
            if(SetupQueryInfOriginalFileInformation(pInfInfo, 0, NULL, &OrigInfo))
            {
                if(lstrlen(OrigInfo.OriginalCatalogName) != 0)
                {
                    if(lppszCatFile)
                    {
                        bRet = (NULL != (*lppszCatFile = AllocStr(OrigInfo.OriginalCatalogName)));
                    }
                    else
                    {
                        bRet = TRUE;
                    }
                }
            }
         }
      }
   }

Cleanup:
   if(hInf != INVALID_HANDLE_VALUE)
   {
       SetupCloseInfFile(hInf);
   }

   //
   // Free up the Inf Info if allocated.
   //
   if(pInfInfo)
   {
      LocalFreeMem(pInfInfo);
   }

   return bRet;
}



BOOL
TDriverSigning::GetExternalCatFile(
    IN LPCTSTR  pszInfName,
    IN LPCTSTR  pszSource,
    IN DWORD    dwVersion,
    IN BOOL     bWeb
)
/*++

Routine Description:
    This routine looks for a cat file external to an inf to use for signing.
    Process:-  If inf file name matches "ntprint.inf" - look for known catalog file names 
                      - nt5prtx.cat, nt5prtx.ca_, nt4prtx.cat, nt4prta.cat.
               If no cat found - look for the first cat in the source directory.

Returns
    NULL      - no cat file found.
    Otherwise - Cat file name.

--*/
{
    LPTSTR          pszCatFile          = NULL;
    TCHAR           CatName[ MAX_PATH ] = {0};
    PTCHAR          pFileName           = NULL;
    HANDLE          hSearch;
    WIN32_FIND_DATA FindFileData;
    DWORD           dwSourceLen,
                    dwCatCount          = 0;

    if(pszSource)
    {
        //
        // +2 -> ending zero and possible extra \
        //
        if(lstrlen(pszSource) + 2 >= MAX_PATH)
            goto Cleanup;

        lstrcpy(CatName, pszSource);
        dwSourceLen = lstrlen(CatName);
        if(CatName[dwSourceLen-1] != _TEXT('\\'))
        {
            CatName[dwSourceLen++] = _TEXT('\\');
            CatName[dwSourceLen]   = 0;
        }
    }
    else
    {
        //
        // If no source specified - try the dir where the inf is placed.
        //
        if(lstrlen(pszInfName) >= MAX_PATH)
            goto Cleanup;

        lstrcpy(CatName, pszInfName);
        if(NULL != (pFileName = _tcsrchr(CatName, _TEXT('\\'))))
        {
            *(++pFileName) = 0;
            dwSourceLen = lstrlen(CatName);
        }
        else
        {
            dwSourceLen = 0;
        }
    }

    //
    //  Get the inf name.
    //
    if(NULL != (pFileName = _tcsrchr(pszInfName, _TEXT('\\'))))
    {
        *pFileName++;
    }
    else
    {
        pFileName = (PTCHAR)pszInfName;
    }

    if(pFileName && (lstrcmpi(pFileName, cszNtprintInf) == 0))
    {
        //
        //  Loop through all the known catalog files for ntprint.inf.
        //  Final cat looped through looks for the first cat in source directory.
        //
        for(dwCatCount = 0; dwCatCount < MAX_KNOWNCATS; dwCatCount++)
        {
            if(lstrlen(KnownCats[dwCatCount]) + dwSourceLen + 1 >= MAX_PATH)
                continue;

            CatName[dwSourceLen] = 0;

            lstrcat(CatName, KnownCats[dwCatCount]);
            if((hSearch = FindFirstFile( CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
            {
                pszCatFile = AllocStr(CatName);
                FindClose(hSearch);
                goto Cleanup;
            }
        }
    }
    
    //
    // we ship multiple INFs for NT4 drivers on the CD, all of them signed in nt4prtx.cat
    // we warn if we try to create a queue with these driver (because the m_DSMajorVersion is 3 in this case)
    // and this is good
    //
    if (dwVersion == 2)
    {
        if(lstrlen(cszNT4CatX86) + dwSourceLen + 1 >= MAX_PATH)
            goto Cleanup;
        
        CatName[dwSourceLen] = 0;

        lstrcat(CatName, cszNT4CatX86);

        if((hSearch = FindFirstFile( CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
        {
            pszCatFile = AllocStr(CatName);
            FindClose(hSearch);
            goto Cleanup;
        }
    }

    if(bWeb)
    {
        //
        // If no cat found - could be web point and print
        //
        if(lstrlen(cszCatExt) + dwSourceLen + 1 >= MAX_PATH)
            goto Cleanup;

        CatName[dwSourceLen] = 0;
        lstrcat(CatName, cszCatExt);
        if((hSearch = FindFirstFile(CatName, &FindFileData)) != INVALID_HANDLE_VALUE)
        {
            CatName[dwSourceLen] = 0;
            pszCatFile = AllocAndCatStr(CatName, FindFileData.cFileName);
            FindClose(hSearch);
        }
    }

Cleanup:

    return (NULL != (m_pszCatalogFileName = pszCatFile));
}


LPTSTR
TDriverSigning::GetINFLang(
    IN LPTSTR pszINFName
)
/*

  Function: GetINFLang

  Returns: A localised string that can be used to differentiate different nt5prtx.cats when 
          installed into the cat root.

  Parameters: pszINFName - the fully qualified inf name to be loaded and searched for the localised string.

  Notes:  This is a real hack to ensure that the SetupSetAlternateFileQueue doesn't overwrite cat files 
          from different language installs.  This is only for backwards compat with Win2K.

*/
{
    INFCONTEXT context;
    DWORD      dwNeeded = 0;
    HINF       hINF     = INVALID_HANDLE_VALUE;
    LPTSTR     pszLang  = NULL;

    if(INVALID_HANDLE_VALUE != (hINF = SetupOpenInfFile(pszINFName, 
                                                        NULL,
                                                        INF_STYLE_WIN4,
                                                        NULL)))
    {
        if(SetupFindFirstLine(hINF, _T("printer_class_addreg"), NULL, &context))
        {
            if(!(SetupGetStringField(&context, 5, pszLang, 0, &dwNeeded)            &&
                 NULL != (pszLang = (LPTSTR) LocalAllocMem(dwNeeded*sizeof(TCHAR))) &&
                 SetupGetStringField(&context, 5, pszLang, dwNeeded, &dwNeeded)))
            {
                if(pszLang)
                {
                    LocalFreeMem(pszLang);
                    pszLang = NULL;
                }
            }
            else
            {
                //
                // If SetupGetStringField was true, but returned a NULL pszLang, allocate a NULL string.
                //
                if(!pszLang)
                {
                    pszLang = AllocStr(_T(""));
                }
            }
        }

        SetupCloseInfFile(hINF);
    }

    return pszLang;
}


DWORD
TDriverSigning::UnCompressCat( 
    IN LPTSTR pszINFName
)
/*

  Function: UnCompressCat 
  
  Purpose:  Takes cat name and determines whether it needs uncompressing or not.
            (Should only occur for nt5prtx.ca_)

  Returns: ERROR_SUCCESS on passing - successfully uncompressing the cat, or if the cat doesn't
           need compressing.

  Parameters:
           ppszCatName - the fully qualified cat name.  This is freed and replaced with the
                         new fully qualified cat name if the cat needs to be uncompressed.
           pbDeleteCat - If this returns as TRUE then the cat was expanded.  It needs to be deleted
                         when setup is finished with it.

  Notes:   This function takes the fully qualified cat path and determines if the cat file is compressed.
           If it is, then it uncompresses it into a unique directory under the TEMP directory.

*/
{
    PTCHAR pDot;
    DWORD  dwError         = ERROR_SUCCESS;
    LPTSTR pszRealFileName = NULL;
    LPTSTR pszPath         = NULL;
    LPTSTR pszLang         = NULL;
    DWORD  dwCompressSize,
           dwUncompressSize;
    UINT   uiCompressType;

    if(!m_pszCatalogFileName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_bDeleteTempCat = FALSE;

    pDot = _tcsrchr(m_pszCatalogFileName, _TEXT('.'));

    if(pDot)
    {
        if(lstrcmpi(pDot, cszExtCompressedCat) == 0)
        {
            //
            // We've got a compressed cat file.  
            // Get the temp dir to copy it to, get the language name to rename it with
            // and uncompress it for use.
            //

            if(NULL != (pszPath = GetMyTempDir())         &&
               NULL != (pszLang = GetINFLang(pszINFName)) &&
               NULL != (pszRealFileName = AllocAndCatStr2(pszPath, pszLang, FileNamePart(m_pszCatalogFileName))))
            {
                pszRealFileName[lstrlen(pszRealFileName)-1] = _TEXT('t');
                //
                // Decompress the file to the temp dir.
                //
                dwError = SetupDecompressOrCopyFile(m_pszCatalogFileName, pszRealFileName, NULL);

                LocalFreeMem(m_pszCatalogFileName);
                m_pszCatalogFileName = pszRealFileName;
                pszRealFileName      = NULL;
                m_bDeleteTempCat     = TRUE;
            }
            else
            {
                dwError = GetLastError();
            }

            if(pszRealFileName)
            {
                LocalFreeMem(pszRealFileName);
            }

            if(pszPath)
            {
                LocalFreeMem(pszPath);
            }

            if(pszLang)
            {
                LocalFreeMem(pszLang);
            }
        }
    }

    return dwError;
}

/*

  Function: RemoveTempCat

  Purpose:  To remove the uncompressed cat file and temp dir created due to UnCompressCat

  Parameters:
            pszCatName - the fully qualified file name to remove.

  Returns:  The last error of the function calls.

  Notes:    This removes the file and the directory that the file is in if the directory
            doesn't have any other files in it.
            BUGBUG - setupapi may still have a handle open to the cat file, in which case the
                     file deletion will fail and the uncompressed cat and directory will be left
                     behind.
            Note: the last error on entering the function is saved as we don't want to overwrite
                  the one already defined inside InstallDriverFromCurrentInf.

*/
DWORD
TDriverSigning::RemoveTempCat( 
    VOID
    )
{
    DWORD  dwSaveLastError = GetLastError();
    DWORD  dwReturnError   = ERROR_SUCCESS;
    PTCHAR pFileName       = NULL;

    if(m_pszCatalogFileName)
    {

        DeleteFile(m_pszCatalogFileName);
    
        if(NULL != (pFileName = FileNamePart(m_pszCatalogFileName)))
        {
            *pFileName = _TEXT('\0');
            RemoveDirectory(m_pszCatalogFileName);
        }

        dwReturnError = GetLastError();

        SetLastError(dwSaveLastError);
    }

    return dwReturnError;
}

/*

  Function: QualifyCatFile

  Purpose: Turn the passed cat file into a fully qualified path to the cat file.

  Parameters:
           pszSource           - the source directory of the cat file.
           ppszCatalogFileName - hold the unqualified cat file initially and returns with the fully qualified one.

  Returns: TRUE on success, FALSE otherwise.

*/
BOOL
TDriverSigning::QualifyCatFile( 
    IN     LPCTSTR  pszSource
    )
{
    LPTSTR pszQualifiedCat = NULL;

    if(!m_pszCatalogFileName || !*m_pszCatalogFileName)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // No source to add.
    //
    if(!pszSource || !*pszSource)
    {
        return TRUE;
    }

    if(pszSource[lstrlen(pszSource)-1] == _TEXT('\\'))
    {
        pszQualifiedCat = AllocAndCatStr(pszSource, m_pszCatalogFileName);
    }
    else
    {
        pszQualifiedCat = AllocAndCatStr2(pszSource, _TEXT("\\"), m_pszCatalogFileName);
    }

    if(pszQualifiedCat)
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = pszQualifiedCat;
    }

    return (pszQualifiedCat != NULL);
}

BOOL
TDriverSigning::SetMajorVersion(
    IN OSVERSIONINFO OSVerInfo
    )
{
    if(OSVerInfo.dwMajorVersion == 4)
    {
        m_DSMajorVersion = 2;
    }
    else
    {
        m_DSMajorVersion = dwThisMajorVersion;
    }

    return TRUE;
}

BOOL
TDriverSigning::SetPlatform(
    IN LPCTSTR pszServerName
    )
{
    BOOL bRet = FALSE;

    if(!pszServerName || !*pszServerName)
    {
        bRet = TRUE;
        m_DSPlatform = MyPlatform;
    }
    else
    {
        TCHAR pArch[MAX_PATH];
        DWORD cbNeeded;

        cbNeeded = COUNTOF(pArch);
        if(GetArchitecture(pszServerName, pArch, &cbNeeded))
        {
            DWORD_PTR dwPlatform = (DWORD_PTR)MIN_PLATFORM;

            bRet = TRUE;

            for(;
                dwPlatform <= (DWORD_PTR)MAX_PLATFORM && lstrcmpi(PlatformEnv[(PLATFORM)dwPlatform].pszName, pArch) != 0;
                dwPlatform++)
                ;
    
            if(dwPlatform > (DWORD_PTR)MAX_PLATFORM)
            {
                m_DSPlatform = MyPlatform;
            }
            else
            {
                m_DSPlatform = (PLATFORM)dwPlatform;
            }
        }
    }

    return bRet;
}

BOOL
TDriverSigning::InitDriverSigningInfo( 
    IN LPCTSTR  pszServerName,
    IN LPTSTR   pszInfName,
    IN LPCTSTR  pszSource,
    IN PLATFORM platform,
    IN DWORD    dwVersion,
    IN BOOL     bWeb
    )
{
    OSVERSIONINFO OSVerInfo = {0};
    BOOL          bRet      = FALSE;
    DWORD         dwMajorVersion,
                  dwMinorVersion;

    //
    // Make sure there is no allocation done.
    //
    if(m_pszCatalogFileName)
    {
        LocalFreeMem(m_pszCatalogFileName);
        m_pszCatalogFileName = NULL;
    }

    if (!::IsLocalAdmin(&m_bIsLocalAdmin))
    {
        goto Cleanup;
    }
    
    //
    // Reset the Alt platform info.
    //
    ZeroMemory(&m_AltPlat_Info, sizeof(SP_ALTPLATFORM_INFO));
    m_AltPlat_Info.cbSize = sizeof(SP_ALTPLATFORM_INFO);
    m_bSetAltPlatform = FALSE;

    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    //
    // If this fails we are not doing very well, just fail.
    //
    if(!GetOSVersion(pszServerName,&OSVerInfo))
    {
        goto Cleanup;
    }

    SetMajorVersion(OSVerInfo);
    SetPlatform(pszServerName);

    //
    // in case we have no inf yet, just take the first one in the directory and look for a CatalogFile
    // we're doing this for Win9x drivers, where I need to setup the alternate platform information
    // 
    if (!pszInfName && platform == PlatformWin95)
    {
        m_pszCatalogFileName = FindCatInDirectory(pszSource);
        m_bCatInInf = m_pszCatalogFileName ? TRUE : FALSE;
    }
    
    //
    // Get cat file name.  If it is in the inf, then let setupapi handle the situation.
    // Otherwise we need to find one for legacy cases - eg "have disking" to ntprint.inf on
    // released server CD.
    //
    else if(!(m_bCatInInf = CheckForCatalogFileInInf(pszInfName, &m_pszCatalogFileName)))
    {
        if(GetExternalCatFile(pszInfName, pszSource, dwVersion, bWeb))
        {
            if(ERROR_SUCCESS != UnCompressCat(pszInfName))
            {
                if(m_pszCatalogFileName)
                {
                    LocalFreeMem(m_pszCatalogFileName);
                    m_pszCatalogFileName = NULL;
                }
            }
        }
    }
    else
    {
        //
        // We need to fully qualify the cat file so we can determine what it is signed for.
        //
        if(pszSource)
        {
            QualifyCatFile(pszSource);
        }
        else
        {
            PTCHAR pFileName = NULL;

            pFileName = FileNamePart(pszInfName);
            if(pFileName)
            {
                TCHAR pChar = *pFileName;

                *pFileName = _TEXT('\0');
                QualifyCatFile(pszInfName);
                *pFileName = pChar;
            }
        }
    }

    //
    // If we have a catalog file then lets find out what it is signed for.
    // Don't check the return value as this may be a cat that is referenced in an inf and we may not find it.
    // Rather warn than fail.
    //
    if(m_pszCatalogFileName)
    {
        GetSigningInformation(platform, dwVersion, &dwMajorVersion, &dwMinorVersion);
    }
    else
    {
        dwMajorVersion = OSVerInfo.dwMajorVersion;
        dwMinorVersion = OSVerInfo.dwMinorVersion;
    }

    //
    // If this is to be installable and runable on this platform,
    // Verify that this in not signed only for an OS version > than this one.
    // If it is, we need to warn the user though driver signing that this has never
    // been signed for this OS - hence probably not tested for it.
    //
    if(platform  == m_DSPlatform && 
       dwVersion == m_DSMajorVersion)
    {
        if(dwMajorVersion > OSVerInfo.dwMajorVersion || 
           (dwMajorVersion == OSVerInfo.dwMajorVersion && dwMinorVersion > OSVerInfo.dwMinorVersion))
        {
            dwMajorVersion = OSVerInfo.dwMajorVersion;
            dwMinorVersion = OSVerInfo.dwMinorVersion;
        }
    }
    
    m_AltPlat_Info.MajorVersion               = dwMajorVersion;
    m_AltPlat_Info.MinorVersion               = dwMinorVersion;
    m_AltPlat_Info.Platform                   = PlatformArch[ platform ][OS_PLATFORM];
    m_AltPlat_Info.ProcessorArchitecture      = (WORD) PlatformArch[ platform ][PROCESSOR_ARCH];
    m_AltPlat_Info.Reserved                   = 0;
    m_AltPlat_Info.FirstValidatedMajorVersion = m_AltPlat_Info.MajorVersion;
    m_AltPlat_Info.FirstValidatedMinorVersion = m_AltPlat_Info.MinorVersion;


    //
    // We need an Alternate platform info struct if:
    //       1) We need to associate another Cat File with the queue.
    //       2) We need to change the version that we want to test the signing against.
    //       3) We need to change the platform that we want to test the signing against.
    //
    m_bSetAltPlatform = ((!CatInInf() && 
                          m_pszCatalogFileName                           ) || 
                         !(dwMajorVersion == OSVerInfo.dwMajorVersion && 
                           dwMinorVersion == OSVerInfo.dwMinorVersion    ) ||
                           platform != m_DSPlatform);

    bRet = TRUE;

Cleanup:

    return bRet;
}

BOOL
TDriverSigning::CatInInf(
    VOID
    )
{
    return m_bCatInInf;
}

BOOL
TDriverSigning::SetAltPlatformInfo(
    IN  HDEVINFO hDevInfo,
    IN  HSPFILEQ CopyQueue
    )
{
    if(m_bSetAltPlatform)
    {
        SP_DEVINSTALL_PARAMS DevInstallParams = {0}; 
        //
        // Set up Alternative platform searches so that when we set up the driver signing OS below 
        // it will be used throughout the alternate OS installation.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if(SetupDiGetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams))
        {
            DevInstallParams.FlagsEx |= DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            DevInstallParams.Flags   |= DI_NOVCP;

            if(DevInstallParams.FileQueue == NULL || DevInstallParams.FileQueue == INVALID_HANDLE_VALUE)
            {
                DevInstallParams.FileQueue = CopyQueue;
            }

            SetupDiSetDeviceInstallParams(hDevInfo, 
                                          NULL,
                                          &DevInstallParams);

        }

        return (SetupSetFileQueueAlternatePlatform(CopyQueue, 
                                                   &m_AltPlat_Info,
                                                   (m_bCatInInf ? NULL : m_pszCatalogFileName)));
    }

    return TRUE;
}

/*

  Function: FindCatInDirectory

  Purpose: In case we only have a directory but no INF selected, find the first CatalogFile= entry in all the
           INFs in the directory. This is done explicitly to fit the distribution of Win9x drivers on Server CDs

  Parameters:
           pszSource           - the source directory of the inf files.

  Returns: pszCatFile          - the fully qualified name of the first referenced CAT file

*/

LPTSTR TDriverSigning::FindCatInDirectory(IN LPCTSTR pszSource)
{
    TCHAR  InfName[MAX_PATH];
    LPTSTR pCatName = NULL, pTmp = NULL;
    DWORD  len;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData = {0};

    if (!pszSource)
    {
        goto Cleanup;
    }

    len = _tcslen(pszSource);
    if (len + _tcslen(cszInfExt) +1 > MAX_PATH)
    {
        goto Cleanup;
    }

    _tcscpy(InfName, pszSource);

    //
    // cszInfExt contains a backslash, so remove it from the source path if there
    //
    
    if (InfName[len-1] == _T('\\'))
    {
        InfName[len-1] = 0;
        len--;
    }

    _tcscpy(&InfName[len], cszInfExt);

    
    if((hSearch = FindFirstFile( InfName, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        //
        // append a backslash - the length is already checked above.
        //
        InfName[len++]  = _T('\\');
        InfName[len]    = 0;

        do
        {
            if (len + _tcslen(FindFileData.cFileName) + 1 > MAX_PATH)
            {
                goto Cleanup;
            }

            _tcscpy(&InfName[len], FindFileData.cFileName);

            if (CheckForCatalogFileInInf(InfName, &pCatName))
            {
                pTmp = pCatName;

                InfName[len] = 0;
                
                pCatName = AllocAndCatStr(InfName, pTmp);
                
                LocalFreeMem(pTmp);

                goto Cleanup;
            }

        } while (FindNextFile(hSearch, &FindFileData));

        //
        // no catalog file entry found - don't attempt anything funny
        //
    }


Cleanup:
    if (hSearch != INVALID_HANDLE_VALUE)
    {
        FindClose(hSearch);
    }
    return pCatName;
}

LPCTSTR
TDriverSigning::GetCatalogFile(
    VOID    
    )
{
    return m_pszCatalogFileName;
}

BOOL
TDriverSigning::IsLocalAdmin(
    VOID    
    )
{
    return m_bIsLocalAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\web.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    web.h

Abstract:

    Code download API definitions.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#ifndef _WEB_H
#define _WEB_H

// Include the CDM defines & declares

typedef struct _CODEDOWNLOADINFO    {

    HMODULE     hModule;
    HANDLE      hConnection;
    cdecl HANDLE  (*pfnOpen)(HWND hwnd);
    cdecl BOOL    (*pfnDownload)(HANDLE         hConnection,
                                 HWND           hwnd,
                                 PDOWNLOADINFO  pDownloadInfo,
                                 LPTSTR         pszDownloadPath,
                                 UINT           uSize,
                                 PUINT          puNeeded);
    cdecl VOID    (*pfnClose)(HANDLE  hConnection);
} CODEDOWNLOADINFO, *PCODEDOWNLOADINFO;


#endif  // #ifndef _WEB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\util.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Driver Setup UI Utility functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 06-Sep-1995

Revision History:

--*/

#include "precomp.h"
#include "splcom.h"

#define MAX_DWORD_LENGTH          11

//
// Keys to search for in ntprint.inf
//
TCHAR   cszDataSection[]                = TEXT("DataSection");
TCHAR   cszDriverFile[]                 = TEXT("DriverFile");
TCHAR   cszConfigFile[]                 = TEXT("ConfigFile");
TCHAR   cszDataFile[]                   = TEXT("DataFile");
TCHAR   cszHelpFile[]                   = TEXT("HelpFile");
TCHAR   cszDefaultDataType[]            = TEXT("DefaultDataType");
TCHAR   cszLanguageMonitor[]            = TEXT("LanguageMonitor");
TCHAR   cszPrintProcessor[]             = TEXT("PrintProcessor");
TCHAR   cszCopyFiles[]                  = TEXT("CopyFiles");
TCHAR   cszVendorSetup[]                = TEXT("VendorSetup");
TCHAR   cszVendorInstaller[]            = TEXT("VendorInstaller");

TCHAR   cszPreviousNamesSection[]       = TEXT("Previous Names");
TCHAR   cszOEMUrlSection[]              = TEXT("OEM URLS");

TCHAR   cszWebNTPrintPkg[]              = TEXT("3FBF5B30-DEB4-11D1-AC97-00A0C903492B");

TCHAR   cszAllInfs[]                    = TEXT("*.inf");
TCHAR   cszInfExt[]                     = TEXT("\\*.inf");

TCHAR   sComma                          = TEXT(',');
TCHAR   sHash                           = TEXT('@');
TCHAR   sZero                           = TEXT('\0');

TCHAR   cszSystemSetupKey[]             = TEXT("System\\Setup");
TCHAR   cszSystemUpgradeValue[]         = TEXT("UpgradeInProgress");
TCHAR   cszSystemSetupInProgress[]      = TEXT("SystemSetupInProgress");

TCHAR   cszMonitorKey[]                 = TEXT("SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors\\");

//
// Native environment name used by spooler
//
SPLPLATFORMINFO PlatformEnv[] = {

    { TEXT("Windows NT Alpha_AXP") },
    { TEXT("Windows NT x86") },
    { TEXT("Windows NT R4000") },
    { TEXT("Windows NT PowerPC") },
    { TEXT("Windows 4.0") },
    { TEXT("Windows IA64") },
    { TEXT("Windows Alpha_AXP64") }
};

//
// Platform override strings to be used to upgrade non-native architecture
// printer drivers
//
SPLPLATFORMINFO PlatformOverride[] = {

    { TEXT("alpha") },
    { TEXT("i386") },
    { TEXT("mips") },
    { TEXT("ppc") },
    { NULL },       // Win95
    { TEXT("ia64") },
    { TEXT("axp64") }
};

DWORD                PlatformArch[][2] =
{
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_ALPHA },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_INTEL },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_MIPS },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_PPC },
   { VER_PLATFORM_WIN32_WINDOWS, PROCESSOR_ARCHITECTURE_INTEL },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_IA64 },
   { VER_PLATFORM_WIN32_NT, PROCESSOR_ARCHITECTURE_ALPHA64 }
};

PLATFORM    MyPlatform =
#if defined(_ALPHA_)
        PlatformAlpha;
#elif defined(_MIPS_)
        PlatformMIPS;
#elif defined(_PPC_)
        PlatformPPC;
#elif defined(_X86_)
        PlatformX86;
#elif   defined(_IA64_)
        PlatformIA64;
#elif   defined(_AXP64_)
        PlatformAlpha64;
#elif   defined(_AMD64_)
        0;                              // ****** fixfix ****** amd64
#else
#error "No Target Architecture"
#endif

// Declare the CritSec for CDM
CRITICAL_SECTION CDMCritSect;

#define         SKIP_DIR                TEXT("\\__SKIP_")

CRITICAL_SECTION SkipCritSect;
LPTSTR           gpszSkipDir = NULL;


PVOID
LocalAllocMem(
    IN UINT cbSize
    )
{
    return LocalAlloc( LPTR, cbSize );
}

VOID
LocalFreeMem(
    IN PVOID p
    )
{
    LocalFree(p);
}

//
// For some reason these are needed by spllib when you use StrNCatBuf.
// This doesn't make any sense, but just implement them.
//
LPVOID
DllAllocSplMem(
    DWORD cbSize
)
{
    return LocalAllocMem(cbSize);
}

BOOL
DllFreeSplMem(
   LPVOID pMem
)
{
    LocalFreeMem(pMem);
    return TRUE;
}

VOID
PSetupFreeMem(
    IN PVOID p
    )
{
    LocalFreeMem(p);
}



LPTSTR
AllocStr(
    LPCTSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of a string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPTSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = LocalAllocMem((lstrlen(pszStr) + 1) * sizeof(*pszRet));
        if ( pszRet )
            lstrcpy(pszRet, pszStr);
    }

    return pszRet;
}

LPTSTR
AllocStrWCtoTC(LPWSTR lpStr)
/*++

Routine Description:
    Allocate memory and make a copy of a string field, convert it from a WCHAR *
    to a TCHAR *

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
#ifdef UNICODE
    return AllocStr(lpStr);
#else
    LPSTR pszRet = NULL;
    INT   iSize;

    iSize = WideCharToMultiByte( CP_ACP, 0, lpStr, -1, NULL, 0, NULL, NULL);


    if (iSize <= 0)
        goto Cleanup;

    pszRet = LocalAllocMem( iSize );

    if (!pszRet)
        goto Cleanup;

    iSize = WideCharToMultiByte( CP_ACP, 0, lpStr, -1, pszRet, iSize, NULL, NULL);

    if (!iSize) {
        LocalFreeMem( pszRet );
        pszRet = NULL;
    }

Cleanup:
    return pszRet;
#endif
}


LPTSTR
AllocAndCatStr(
    LPCTSTR  pszStr1,
    LPCTSTR  pszStr2
    )
/*++

Routine Description:
    Allocate memory and make a copy of two string fields, cancatenate the second to
    the first

Arguments:
    pszStr1   : String to copy
    pszStr2   : String to CAT

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
    {
    LPTSTR  pszRet = NULL;

    if ( pszStr1 && *pszStr1 &&
         pszStr2 && *pszStr2 ) {

        pszRet = LocalAllocMem((lstrlen(pszStr1) + lstrlen(pszStr2) + 1) * sizeof(*pszRet));
        if ( pszRet ) {
            lstrcpy( pszRet, pszStr1 );
            lstrcat( pszRet, pszStr2 );
        }
     }
    return pszRet;
}

LPTSTR
AllocAndCatStr2(
    LPCTSTR  pszStr1,
    LPCTSTR  pszStr2,
    LPCTSTR  pszStr3
    )
/*++

Routine Description:
    Allocate memory and make a copy of two string fields, cancatenate the second to
    the first

Arguments:
    pszStr1   : String to copy
    pszStr2   : String to CAT
    pszStr3   : Second string to CAT

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
    {
    LPTSTR    pszRet = NULL;
    DWORD     cSize  = 0;

    if ( pszStr1 &&
         pszStr2 &&
         pszStr3 ) {

        if(*pszStr1)
        {
            cSize += lstrlen(pszStr1);
        }

        if(*pszStr2)
        {
            cSize += lstrlen(pszStr2);
        }

        if(*pszStr3)
        {
            cSize += lstrlen(pszStr3);
        }

        pszRet = LocalAllocMem((cSize+1)*sizeof(*pszRet));

        if ( pszRet ) {

            if(*pszStr1)
            {
                lstrcpy( pszRet, pszStr1 );

                if(*pszStr2)
                {
                    lstrcat( pszRet, pszStr2 );
                }

                if(*pszStr3)
                {
                    lstrcat( pszRet, pszStr3 );
                }
            }
            else
            {
                if(*pszStr2)
                {
                    lstrcpy( pszRet, pszStr2 );

                    if(*pszStr3)
                    {
                        lstrcat( pszRet, pszStr3 );
                    }
                }
                else
                {
                    if(*pszStr3)
                    {
                        lstrcpy( pszRet, pszStr3 );
                    }
                }
            }
        }
    }
    return pszRet;
}




VOID
FreeStructurePointers(
    LPBYTE      pStruct,
    PULONG_PTR  pOffsets,
    BOOL        bFreeStruct
    )
/*++

Routine Description:
    Frees memory allocated to fields given by the pointers in a structure.
    Also optionally frees the memory allocated for the structure itself.

Arguments:
    pStruct     : Pointer to the structure
    pOffsets    : Array of DWORDS (terminated by -1) givings offsets
    bFreeStruct : If TRUE structure is also freed

Return Value:
    nothing

--*/
{
    INT i;

    if ( pStruct ) {

        for( i = 0 ; pOffsets[i] != -1; ++i )
            LocalFreeMem(*(LPBYTE *) (pStruct+pOffsets[i]));

        if ( bFreeStruct )
            LocalFreeMem(pStruct);
    }
}


VOID
DestroyLocalData(
    IN  PPSETUP_LOCAL_DATA   pLocalData
    )
{
    if ( pLocalData ) {

        if ( pLocalData->Flags & VALID_INF_INFO )
            FreeStructurePointers((LPBYTE)&pLocalData->InfInfo,
                                  InfInfoOffsets,
                                  FALSE);

        if ( pLocalData->Flags & VALID_PNP_INFO )
            FreeStructurePointers((LPBYTE)&pLocalData->PnPInfo,
                                  PnPInfoOffsets,
                                  FALSE);

        FreeStructurePointers((LPBYTE)pLocalData, LocalDataOffsets, TRUE);
    }
}


VOID
InfGetString(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a string field from an Inf file

Arguments:
    lpInfContext    : Inf context for the line
    dwFieldIndex    : Index of the field within the specified line
    ppszField       : Pointer to the field to allocate memory and copy
    pcchCopied      : On success number of charaters copied is added
    pbFail          : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    TCHAR   Buffer[MAX_PATH];
    DWORD   dwNeeded;

    if ( *pbFail )
        return;

    if ( SetupGetStringField(pInfContext,
                             dwFieldIndex,
                             Buffer,
                             SIZECHARS(Buffer),
                             &dwNeeded) ) {

        *ppszField      = AllocStr(Buffer);
        *pcchCopied    += dwNeeded;
        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
         !(*ppszField = LocalAllocMem(dwNeeded*sizeof(Buffer[0]))) ) {

        *pbFail = TRUE;
        return;
    }

    if ( !SetupGetStringField(pInfContext,
                              dwFieldIndex,
                              *ppszField,
                              dwNeeded,
                              &dwNeeded) ) {

        *pbFail = TRUE;
        return;
    }

    *pcchCopied += dwNeeded;
}


VOID
InfGetMultiSz(
    IN      PINFCONTEXT     pInfContext,
    IN      DWORD           dwFieldIndex,
    OUT     LPTSTR         *ppszField,
    IN OUT  LPDWORD         pcchCopied,
    IN OUT  LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a multi-sz field from an Inf file

Arguments:
    lpInfContext    : Inf context for the line
    dwFieldIndex    : Index of the field within the specified line
    ppszField       : Pointer to the field to allocate memory and copy
    pcchCopied      : On success number of charaters copied is added
    pbFail          : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    TCHAR   Buffer[MAX_PATH];
    DWORD   dwNeeded;

    if ( *pbFail )
        return;

    if ( SetupGetMultiSzField(pInfContext,
                              dwFieldIndex,
                              Buffer,
                              SIZECHARS(Buffer),
                              &dwNeeded) ) {

        if ( *ppszField = LocalAllocMem(dwNeeded*sizeof(Buffer[0])) ) {

            CopyMemory(*ppszField, Buffer, dwNeeded * sizeof(Buffer[0]));
            *pcchCopied    += dwNeeded;
        } else {

            *pbFail = TRUE;
        }
        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
         !(*ppszField = LocalAllocMem(dwNeeded * sizeof(Buffer[0]))) ) {

        *pbFail = TRUE;
        return;
    }

    if ( !SetupGetMultiSzField(pInfContext,
                               dwFieldIndex,
                               *ppszField,
                               dwNeeded,
                               &dwNeeded) ) {

        *pbFail = TRUE;
        return;
    }

    *pcchCopied += dwNeeded;
}


VOID
InfGetDriverInfoString(
    IN     HINF            hInf,
    IN     LPCTSTR         pszDriverSection,
    IN     LPCTSTR         pszDataSection, OPTIONAL
    IN     BOOL            bDataSection,
    IN     LPCTSTR         pszKey,
    OUT    LPTSTR         *ppszData,
    IN     LPCTSTR         pszDefaultData,
    IN OUT LPDWORD         pcchCopied,
    IN OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a driver info field from an inf file

Arguments:
    hInf             : Handle to the Inf file
    pszDriverSection : Section name for the driver
    pszDataSection   : Data section for the driver (optional)
    bDataSection     : Specifies if there is a data section
    pszKey           : Key value of the field to look for
   *ppszData         : Pointer to allocate memory and copy the data field
    pszDefaultData   : If key found this is the default value, coule be NULL
    pcchCopied       : On success number of charaters copied is added
   *pbFail           : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    INFCONTEXT  InfContext;

    if ( *pbFail )
        return;

    if ( SetupFindFirstLine(hInf, pszDriverSection,
                            pszKey, &InfContext) ||
         (bDataSection && SetupFindFirstLine(hInf,
                                             pszDataSection,
                                             pszKey,
                                             &InfContext)) ) {

        InfGetString(&InfContext, 1, ppszData, pcchCopied, pbFail);
    } else if ( pszDefaultData && *pszDefaultData ) {

        if ( !(*ppszData = AllocStr(pszDefaultData)) )
            *pbFail = TRUE;
        else
            *pcchCopied += lstrlen(pszDefaultData) + 1;
    } else
        *ppszData = NULL;
}


VOID
InfGet2PartString(
    IN     HINF            hInf,
    IN     LPCTSTR         pszDriverSection,
    IN     LPCTSTR         pszDataSection, OPTIONAL
    IN     BOOL            bDataSection,
    IN     LPCTSTR         pszKey,
    OUT    LPTSTR         *ppszData,
    IN OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Allocates memory and gets a 2 part string field from an inf file

Arguments:
    hInf             : Handle to the Inf file
    pszDriverSection : Section name for the driver
    pszDataSection   : Data section for the driver (optional)
    bDataSection     : Specifies if there is a data section
    pszKey           : Key value of the field to look for
   *ppszData         : Pointer to allocate memory and copy the data field
   *pbFail           : Set on error, could be TRUE when called

Return Value:
    Nothing; If *pbFail is not TRUE memory is allocated and the field is copied

--*/
{
    INFCONTEXT  InfContext;
    LPTSTR      psz   = NULL,
                psz2  = NULL;
    DWORD       dwLen = 0;

    if ( *pbFail )
        return;

    if ( SetupFindFirstLine(hInf, pszDriverSection,
                            pszKey, &InfContext) ||
         (bDataSection && SetupFindFirstLine(hInf,
                                             pszDriverSection = pszDataSection,
                                             pszKey,
                                             &InfContext)) ) {

        InfGetString(&InfContext, 1, ppszData, &dwLen, pbFail);

        if ( *pbFail || !*ppszData )
            return; //Success, field is NULL

        //
        // Usual case : field is of the form "Description, DLL-Name"
        //
        if ( psz = lstrchr(*ppszData, sComma) ) {

            *psz = sZero;
            return; // Success, field is not NULL
        } else {

            //
            // This is for the case "Description", DLL-Name
            //
            InfGetString(&InfContext, 2, &psz, &dwLen, pbFail);
            if ( *pbFail || !psz )
                goto Fail;

            dwLen = lstrlen(*ppszData) + lstrlen(psz) + 2;
            if ( psz2 = LocalAllocMem(dwLen * sizeof(*psz2)) ) {

                lstrcpy(psz2, *ppszData);
                LocalFreeMem(*ppszData);
                *ppszData = psz2;

                psz2 += lstrlen(psz2) + 1;
                lstrcpy(psz2, psz);
                LocalFreeMem(psz);
            } else
                goto Fail;
        }
    } else
        *ppszData = NULL;

    return;

Fail:
    LocalFreeMem(*ppszData);
    LocalFreeMem(psz);
    LocalFreeMem(psz2);

    *ppszData = NULL;
    *pbFail = TRUE;
    SetLastError(STG_E_UNKNOWN);
}


VOID
PSetupDestroyDriverInfo3(
    IN  LPDRIVER_INFO_3 pDriverInfo3
    )
/*++

Routine Description:
    Frees memory allocated for a DRIVER_INFO_3 structure and all the string
    fields in it

Arguments:
    pDriverInfo3    : Pointer to the DRIVER_INFO_3 structure to free memory

Return Value:
    None

--*/
{
    LocalFreeMem(pDriverInfo3);
}


LPTSTR
PackString(
    IN  LPTSTR  pszEnd,
    IN  LPTSTR  pszSource,
    IN  LPTSTR *ppszTarget
    )
/*++

Routine Description:
    After parsing the INF the DRIVER_INFO_6 is packed in a buffer where the
    strings are at the end.

Arguments:
    pszEnd      : Pointer to the end of the buffer
    pszSource   : String to copy to the end of the buffer
    ppszTarget  : After copying the source to end of buffer this will receive
                  addess of the packed string

Return Value:
    New end of buffer

--*/
{
    if ( pszSource && *pszSource ) {

        pszEnd -= lstrlen(pszSource) + 1;
        lstrcpy(pszEnd, pszSource);
        *ppszTarget   = pszEnd;
    }

    return pszEnd;
}


LPTSTR
PackMultiSz(
    IN  LPTSTR  pszEnd,
    IN  LPTSTR  pszzSource,
    IN  LPTSTR *ppszzTarget
    )
/*++

Routine Description:
    After parsing the INF the DRIVER_INFO_6 is packed in a buffer where the
    strings are at the end.

Arguments:
    pszEnd      : Pointer to the end of the buffer
    pszSource   : Multi-sz field to copy to the end of the buffer
    ppszTarget  : After copying the source to end of buffer this will receive
                  addess of the packed multi-sz field

Return Value:
    New end of buffer

--*/
{
    size_t      dwLen = 0;
    LPTSTR      psz1, psz2;

    if ( (psz1 = pszzSource) != NULL && *psz1 ) {

        while ( *psz1 )
            psz1 += lstrlen(psz1) + 1;

        dwLen = (size_t)(psz1 - pszzSource + 1);
    }

    if ( dwLen == 0 ) {

        *ppszzTarget = NULL;
        return pszEnd;
    }

    pszEnd -= dwLen;
    *ppszzTarget = pszEnd;
    CopyMemory((LPBYTE)pszEnd, (LPBYTE)pszzSource, dwLen * sizeof(TCHAR));

    return pszEnd;
}


VOID
PackDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  LPDRIVER_INFO_6 pTargetDriverInfo6,
    IN  DWORD           cbDriverInfo6
    )
/*++

Routine Description:
    Make a copy of a DRIVER_INFO_6 in a buffer where the strings are packed at
    end of the buffer.

Arguments:
    pSourceDriverInfo6  : The DRIVER_INFO_6 to make a copy
    pTargetDriverInfo6  : Points to a buffer to copy the pSourceDriverInfo6
    cbDriverInfo3       : Size of the buffer cbDriverInfo3, which is the size
                          needed for DRIVER_INFO_6 and the strings

Return Value:
    None

--*/
{
    LPTSTR              pszStr, pszStr2, pszMonitorDll;
    DWORD               dwLen = 0;

    // Copy over he couple non-string fields
    pTargetDriverInfo6->cVersion = pSourceDriverInfo6->cVersion;
    pTargetDriverInfo6->ftDriverDate = pSourceDriverInfo6->ftDriverDate;
    pTargetDriverInfo6->dwlDriverVersion = pSourceDriverInfo6->dwlDriverVersion;

    pszStr    = (LPTSTR)(((LPBYTE)pTargetDriverInfo6) + cbDriverInfo6);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pName,
                        &pTargetDriverInfo6->pName);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDriverPath,
                        &pTargetDriverInfo6->pDriverPath);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDataFile,
                        &pTargetDriverInfo6->pDataFile);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pConfigFile,
                        &pTargetDriverInfo6->pConfigFile);

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pHelpFile,
                        &pTargetDriverInfo6->pHelpFile);

    //
    // Monitor dll is put right after the name
    // (ex. PJL Language monitor\0pjlmon.dd\0)
    //
    if ( pSourceDriverInfo6->pMonitorName ) {

        pszMonitorDll = pSourceDriverInfo6->pMonitorName
                            + lstrlen(pSourceDriverInfo6->pMonitorName) + 1;

        pszStr = PackString(pszStr,
                            pszMonitorDll,
                            &pszStr2);  // Don't care

        pszStr = PackString(pszStr,
                            pSourceDriverInfo6->pMonitorName,
                            &pTargetDriverInfo6->pMonitorName);

    }

    pszStr = PackString(pszStr,
                        pSourceDriverInfo6->pDefaultDataType,
                        &pTargetDriverInfo6->pDefaultDataType);

    pszStr = PackMultiSz(pszStr,
                         pSourceDriverInfo6->pDependentFiles,
                         &pTargetDriverInfo6->pDependentFiles);

    pszStr = PackMultiSz(pszStr,
                         pSourceDriverInfo6->pszzPreviousNames,
                         &pTargetDriverInfo6->pszzPreviousNames);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszMfgName,
                         &pTargetDriverInfo6->pszMfgName);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszOEMUrl,
                         &pTargetDriverInfo6->pszOEMUrl);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszHardwareID,
                         &pTargetDriverInfo6->pszHardwareID);

    pszStr = PackString(pszStr,
                         pSourceDriverInfo6->pszProvider,
                         &pTargetDriverInfo6->pszProvider);

    if ( pTargetDriverInfo6->pszProvider )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszProvider
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszHardwareID )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszHardwareID
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszOEMUrl )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszOEMUrl
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszMfgName )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszMfgName
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pszzPreviousNames )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pszzPreviousNames
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
    else if ( pTargetDriverInfo6->pDependentFiles )
    {
       ASSERT((LPBYTE)pTargetDriverInfo6->pDependentFiles
           >= ((LPBYTE) pTargetDriverInfo6) + sizeof(DRIVER_INFO_6));
    }
}


LPDRIVER_INFO_6
CloneDriverInfo6(
    IN  LPDRIVER_INFO_6 pSourceDriverInfo6,
    IN  DWORD           cbDriverInfo6
    )
/*++

Routine Description:
    Allocate memory and build a DRIVER_INFO_6 from the information we got by
    parsing the INF

Arguments:
    pszEnd      : Pointer to the end of the buffer
    pszSource   : String to copy to the end of the buffer
    ppszTarget  : After copying the source to end of buffer this will receive
                  addess of the packed string

Return Value:
    New end of buffer

--*/
{
    LPDRIVER_INFO_6     pTargetDriverInfo6;
    LPTSTR              pszStr, pszStr2;
    DWORD               dwLen = 0;

    pTargetDriverInfo6 = (LPDRIVER_INFO_6) LocalAllocMem(cbDriverInfo6);

    if ( pTargetDriverInfo6 )
        PackDriverInfo6(pSourceDriverInfo6,
                        pTargetDriverInfo6,
                        cbDriverInfo6);

    return pTargetDriverInfo6;
}


VOID
InfGetVendorSetup(
    IN OUT  PPARSEINF_INFO      pInfInfo,
    IN      HINF                hInf,
    IN      LPTSTR              pszDriverSection,
    IN      LPTSTR              pszDataSection,
    IN      BOOL                bDataSection,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Get the VendowSetup field, if specified, from the INF

Arguments:
    pInfInfo            : This is where the parsed info from the INF is stored
    hInf                : INF handle
    pszDriverSection    : Gives the driver installation section
    pszDataSection      : Data section specified (optional) in driver install section
    bDataSection        : Tells if a data section is specified
    pbFail              : Set on error

Return Value:
    New end of buffer

--*/
{
    LPTSTR      p;
    DWORD       dwSize;
    TCHAR       szBuf[MAX_PATH];
    INFCONTEXT  InfContext;

    if ( *pbFail )
        return;

    //
    // If VendorSetup key is not found return; the key is optional
    //
    if ( !SetupFindFirstLine(hInf, pszDriverSection,
                             cszVendorSetup, &InfContext)   &&
         ( !bDataSection    ||
           !SetupFindFirstLine(hInf, pszDataSection,
                               cszVendorSetup, &InfContext)) ) {

        return;
    }

    if ( SetupGetLineText(&InfContext, hInf, NULL, NULL,
                          szBuf, SIZECHARS(szBuf), &dwSize) ) {

        if ( dwSize == 0 || szBuf[0] == TEXT('\0') )
            return;

        if ( !(pInfInfo->pszVendorSetup = AllocStr(szBuf)) )
            *pbFail = TRUE;

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

        *pbFail = TRUE;
        return;
    }

    pInfInfo->pszVendorSetup = (LPTSTR) LocalAllocMem(dwSize * sizeof(TCHAR));
    if ( pInfInfo->pszVendorSetup &&
         SetupGetLineText(&InfContext, hInf, NULL, NULL,
                          pInfInfo->pszVendorSetup, dwSize, &dwSize) ) {

        return;
    }

    LocalFreeMem(pInfInfo->pszVendorSetup);
    pInfInfo->pszVendorSetup = NULL;

    *pbFail = TRUE;
}


VOID
InfGetPreviousNames(
    IN      HINF                hInf,
    IN      PSELECTED_DRV_INFO  pDrvInfo,
    IN OUT  LPDWORD             pcchCopied,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Gets the pszzPreviousNames field for the selected driver. This field is
    optional, and if specified gives previous names under which the driver was
    known

Arguments:
    hInf        : INF handle
    pDrvInfo    : Pointer to selected driver info
    pcchCopied  : Number of characters copied
    pbFail      : Set on failure

Return Value:
    None. On failure *pbFail is set

--*/
{
    INFCONTEXT      Context;

    if ( *pbFail )
        return;

    //
    // Previous names is optional; if not found we are done
    //
    if ( SetupFindFirstLine(hInf,
                            cszPreviousNamesSection,
                            pDrvInfo->pszModelName,
                            &Context) ) {

        pDrvInfo->Flags     |= SDFLAG_PREVNAME_SECTION_FOUND;
        InfGetMultiSz(&Context, 1, &pDrvInfo->pszzPreviousNames,
                      pcchCopied, pbFail);
    } else if ( GetLastError() != ERROR_LINE_NOT_FOUND )
        pDrvInfo->Flags     |= SDFLAG_PREVNAME_SECTION_FOUND;
}


VOID
InfGetOEMUrl(
    IN      HINF                hInf,
    IN      PSELECTED_DRV_INFO  pDrvInfo,
    IN OUT  LPBOOL              pbFail
    )
/*++

Routine Description:
    Gets the OEM URL Info for the selected driver. This field is optional

Arguments:
    hInf        : INF handle
    pDrvInfo    : Pointer to selected driver info
    pbFail      : Set on failure

Return Value:
    None. On failure *pbFail is set

--*/
{
    INFCONTEXT      Context;
    DWORD           dwDontCare = 0;

    if ( *pbFail )
        return;

    //
    // OEM URL is optional; if not found we are done
    //
    if ( SetupFindFirstLine(hInf,
                            cszOEMUrlSection,
                            pDrvInfo->pszManufacturer,
                            &Context) ) {

        InfGetString(&Context, 1, &pDrvInfo->pszOEMUrl, &dwDontCare, pbFail);
    }
}

VOID
AddAllIncludedInf(
   IN  HINF         hInf,
   IN  LPTSTR       pszInstallSection
   )

{
   INFCONTEXT INFContext;
   PINFCONTEXT pINFContext = &INFContext;
   DWORD dwBufferNeeded;

   if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "Include" ), pINFContext ) )
   {
      // Find each INF and load it & it's LAYOUT files
      DWORD dwINFs = SetupGetFieldCount( pINFContext );
      DWORD dwIndex;

      for ( dwIndex = 1; dwIndex <= dwINFs; dwIndex++ )
      {
         if ( SetupGetStringField(  pINFContext, dwIndex, NULL, 0, &dwBufferNeeded ) )
         {
            PTSTR pszINFName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
            if ( pszINFName )
            {
               if ( SetupGetStringField(  pINFContext, dwIndex, pszINFName, ( dwBufferNeeded * sizeof(TCHAR) ), &dwBufferNeeded ) )
               {
                  //
                  // Open INF file and append layout.inf specified in Version section
                  // Layout inf is optional
                  //
                  SetupOpenAppendInfFile( pszINFName, hInf, NULL);
                  SetupOpenAppendInfFile( NULL, hInf, NULL);
               }  // Got an INF Name

               LocalFreeMem( pszINFName );
               pszINFName = NULL;
            }  // Allocated pszINFName
         }  // Got the Field from the INF Line
      }  // Process all INFs in the Include Line
   }  // Found an Include= Line
}

BOOL
InstallAllInfSections(
   IN  PPSETUP_LOCAL_DATA  pLocalData,
   IN  PLATFORM            platform,
   IN  LPCTSTR             pszServerName,
   IN  HSPFILEQ            CopyQueue,
   IN  LPCTSTR             pszSource,
   IN  DWORD               dwInstallFlags,
   IN  HINF                hInf,
   IN  LPCTSTR             pszInstallSection
   )

{
   BOOL         bRet = FALSE;
   HINF hIncludeInf;
   INFCONTEXT INFContext;
   PINFCONTEXT pINFContext = &INFContext;
   INFCONTEXT NeedsContext;
   PINFCONTEXT pNeedsContext = &NeedsContext;
   DWORD dwBufferNeeded;
   PTSTR pszINFName = NULL;
   PTSTR pszSectionName = NULL;

   if ( CopyQueue == INVALID_HANDLE_VALUE              ||
        !SetTargetDirectories( pLocalData,
                               platform,
                               pszServerName,
                               hInf,
                               dwInstallFlags ) ||
        !SetupInstallFilesFromInfSection(
                       hInf,
                       NULL,
                       CopyQueue,
                       pszInstallSection,
                       pszSource,
                       SP_COPY_LANGUAGEAWARE) )
       goto Cleanup;

   // To get the source directories correct, we need to load all included INFs
   //  separately. THen use their associated layout files.
   if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "Include" ), pINFContext ) )
   {
      // Find each INF and load it & it's LAYOUT files
      DWORD dwINFs = SetupGetFieldCount( pINFContext );
      DWORD dwIIndex;

      for ( dwIIndex = 1; dwIIndex <= dwINFs; dwIIndex++ )
      {
         if ( SetupGetStringField(  pINFContext, dwIIndex, NULL, 0, &dwBufferNeeded ) )
         {
            pszINFName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
            if ( pszINFName )
            {
               if ( SetupGetStringField(  pINFContext, dwIIndex, pszINFName, ( dwBufferNeeded * sizeof(TCHAR) ), &dwBufferNeeded ) )
               {
                  //
                  // Open INF file and append layout.inf specified in Version section
                  // Layout inf is optional
                  //
                  // SetupOpenAppendInfFile( pszINFName, hPrinterInf, NULL);
                  hIncludeInf = SetupOpenInfFile(pszINFName,
                                                 NULL,
                                                 INF_STYLE_WIN4,
                                                 NULL);

                  if ( hIncludeInf == INVALID_HANDLE_VALUE )
                      goto Cleanup;
                  SetupOpenAppendInfFile( NULL, hIncludeInf, NULL);

                  // Now process all need sections for this INF
                  // Now find the Needs Line and install all called sections
                  if ( SetupFindFirstLine(  hInf, pszInstallSection, TEXT( "needs" ), pNeedsContext ) )
                  {
                     // Find each INF and load it & it's LAYOUT files
                     DWORD dwSections = SetupGetFieldCount( pNeedsContext );
                     DWORD dwNIndex;

                     for ( dwNIndex = 1; dwNIndex <= dwSections; dwNIndex++ )
                     {
                        if ( SetupGetStringField(  pNeedsContext, dwNIndex, NULL, 0, &dwBufferNeeded ) )
                        {
                           pszSectionName = (PTSTR) LocalAllocMem( dwBufferNeeded * sizeof(TCHAR) );
                           if ( pszSectionName )
                           {
                              if ( SetupGetStringField(  pNeedsContext, dwNIndex, pszSectionName, ( dwBufferNeeded * sizeof(TCHAR) ), &dwBufferNeeded ) )
                              {
                                 if ( SetTargetDirectories(pLocalData,
                                                           platform,
                                                           pszServerName,
                                                           hIncludeInf,
                                                           dwInstallFlags) )
                                 {
                                    if ( !SetupInstallFilesFromInfSection(
                                                   hIncludeInf,
                                                   NULL,
                                                   CopyQueue,
                                                   pszSectionName,
                                                   NULL,
                                                   SP_COPY_LANGUAGEAWARE) )
                                       goto Cleanup;
                                 }  //  Able to setup Target Dirs
                                 else
                                    goto Cleanup;
                              }  // Got a Section Name

                              LocalFreeMem( pszSectionName );
                              pszSectionName = NULL;
                           }  // Allocated pszSectionName
                        }  // Got the Field from the Section Line
                     }  // Process all Sections in the Needs Line
                  }  // Found a Needs= Line

                  // Close included INF
                  if ( hIncludeInf != INVALID_HANDLE_VALUE )
                      SetupCloseInfFile(hIncludeInf);
               }  // Got an INF Name

               LocalFreeMem( pszINFName );
               pszINFName = NULL;
            }  // Allocated pszINFName
         }  // Got the Field from the INF Line
      }  // Process all INFs in the Include Line
   }  // Found an Include= Line

   bRet = TRUE;

Cleanup:
   if ( pszINFName )
      LocalFreeMem( pszINFName );

   if ( pszSectionName )
      LocalFreeMem( pszSectionName );

   return bRet;
}


BOOL
ParseInf(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      DWORD               dwInstallFlags
    )
/*++

Routine Description:
    Copies driver information from an Inf file to a DriverInfo3 structure.

    The following fields are filled on successful return
            pName
            pDriverPath
            pDataFile
            pConfigFile
            pHelpFile
            pMonitorName
            pDefaultDataType

Arguments:
    pLocalData      :
    platform        : Platform for which inf should be parsed

Return Value:
    TRUE    -- Succesfully parsed the inf and built info for the selected driver
    FALSE   -- On Error

--*/
{
    PPARSEINF_INFO      pInfInfo = &pLocalData->InfInfo;
    PDRIVER_INFO_6      pDriverInfo6 = &pLocalData->InfInfo.DriverInfo6;
    LPTSTR              pszDataSection, psz, pszInstallSection;
    BOOL                bWin95 = platform == PlatformWin95,
                        bFail = TRUE, bDataSection = FALSE;
    INFCONTEXT          Context;
    DWORD               cchDriverInfo6, dwNeeded, dwDontCare;
    HINF                hInf;

    //
    // Check if INF is already parsed, and if so for the right platform
    //
    if ( pLocalData->Flags & VALID_INF_INFO ) {

        if ( platform == pInfInfo->platform )
            return TRUE;

        FreeStructurePointers((LPBYTE)pInfInfo, InfInfoOffsets, FALSE);
        pLocalData->Flags   &= ~VALID_INF_INFO;
        ZeroMemory(pInfInfo, sizeof(*pInfInfo));
    }

    pszDataSection  = NULL;

    hInf = SetupOpenInfFile(pLocalData->DrvInfo.pszInfName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if ( hInf == INVALID_HANDLE_VALUE )
        goto Cleanup;

    if ( bWin95 ) {

        pszInstallSection = AllocStr(pLocalData->DrvInfo.pszDriverSection);
        if ( !pszInstallSection )
            goto Cleanup;
    } else {

        if ( !SetupSetPlatformPathOverride(PlatformOverride[platform].pszName) )
            goto Cleanup;

        if ( !SetupDiGetActualSectionToInstall(
                            hInf,
                            pLocalData->DrvInfo.pszDriverSection,
                            NULL,
                            0,
                            &dwNeeded,
                            NULL)                                               ||
            !(pInfInfo->pszInstallSection
                        = (LPTSTR) LocalAllocMem(dwNeeded * sizeof(TCHAR)))          ||
            !SetupDiGetActualSectionToInstall(
                            hInf,
                            pLocalData->DrvInfo.pszDriverSection,
                            pInfInfo->pszInstallSection,
                            dwNeeded,
                            NULL,
                            NULL) ) {

            SetupSetPlatformPathOverride(NULL);
            goto Cleanup;
        }

        SetupSetPlatformPathOverride(NULL);
        pszInstallSection = pInfInfo->pszInstallSection;
    }

    //
    // Now load all other INFs referenced in the Install Section
    //
    AddAllIncludedInf( hInf, pszInstallSection );

    if ( !(pDriverInfo6->pName = AllocStr(pLocalData->DrvInfo.pszModelName)) )
        goto Cleanup;

    bFail = FALSE;

    if(bFail)
    {
        goto Cleanup;
    }

    //
    // Does the driver section have a data section name specified?
    //
    if ( SetupFindFirstLine(hInf, pszInstallSection,
                            cszDataSection, &Context) ) {

        InfGetString(&Context, 1, &pszDataSection, &dwDontCare, &bFail);
        bDataSection = TRUE;
    }

    cchDriverInfo6 = lstrlen(pDriverInfo6->pName) + 1;

    //
    // If DataFile key is not found data file is same as driver section name
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDataFile,
                           &pDriverInfo6->pDataFile,
                           pszInstallSection,
                           &cchDriverInfo6,
                           &bFail);

    //
    // If DriverFile key is not found driver file is the driver section name
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDriverFile,
                           &pDriverInfo6->pDriverPath,
                           pszInstallSection,
                           &cchDriverInfo6,
                           &bFail);

    //
    // If ConfigFile key is not found config file is same as driver file
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszConfigFile,
                           &pDriverInfo6->pConfigFile,
                           pDriverInfo6->pDriverPath,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Help file is optional, and by default NULL
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszHelpFile,
                           &pDriverInfo6->pHelpFile,
                           NULL,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Monitor name is optional, and by default none
    //
    InfGet2PartString(hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      cszLanguageMonitor,
                      &pDriverInfo6->pMonitorName,
                      &bFail);

    if ( psz = pDriverInfo6->pMonitorName ) {

        psz += lstrlen(psz) + 1;
        cchDriverInfo6 += lstrlen(pDriverInfo6->pMonitorName) + lstrlen(psz) + 2;
    }

    //
    // Print processor is optional, and by default none
    //
    InfGet2PartString(hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      cszPrintProcessor,
                      &pLocalData->InfInfo.pszPrintProc,
                      &bFail);

    //
    // Default data type is optional, and by default none
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszDefaultDataType,
                           &pDriverInfo6->pDefaultDataType,
                           NULL,
                           &cchDriverInfo6,
                           &bFail);

    //
    // Vendor setup is optional, and by default none
    //
    InfGetVendorSetup(pInfInfo,
                      hInf,
                      pszInstallSection,
                      pszDataSection,
                      bDataSection,
                      &bFail);

    //
    // Vendor installation is optional, and by default none
    //
    InfGetDriverInfoString(hInf,
                           pszInstallSection,
                           pszDataSection,
                           bDataSection,
                           cszVendorInstaller,
                           &pInfInfo->pszVendorInstaller,
                           NULL,
                           &dwDontCare,
                           &bFail);

    bFail =  bFail || !InfGetDependentFilesAndICMFiles(hDevInfo,
                                              hInf,
                                              bWin95,
                                              pLocalData,
                                              platform,
                                              pszServerName,
                                              dwInstallFlags,
                                              pszInstallSection,
                                              &cchDriverInfo6);
    if ( !bWin95 ) {

        InfGetPreviousNames(hInf,
                            &pLocalData->DrvInfo,
                            &cchDriverInfo6,
                            &bFail);

        InfGetOEMUrl(hInf,
                     &pLocalData->DrvInfo,
                     &bFail);
    }

Cleanup:

    //
    // Save the last error is we've failed.  SetupCloseInfFile can change the last error and we
    // don't care about it's last error in any way.
    //
    if( bFail ) {

        dwDontCare = GetLastError();
    }

    LocalFreeMem(pszDataSection);

    if ( hInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(hInf);

    //
    // On failure free all the fields filled by this routine
    //
    if ( bFail ) {

        FreeStructurePointers((LPBYTE)pInfInfo, InfInfoOffsets, FALSE);
        ZeroMemory(pInfInfo, sizeof(*pInfInfo));
        SetLastError( dwDontCare );

    } else {

        // Point members of DriverInfo6 to strings in pDrvInfo
        pInfInfo->DriverInfo6.pszzPreviousNames          = pLocalData->DrvInfo.pszzPreviousNames;

        pLocalData->InfInfo.DriverInfo6.pszMfgName       = pLocalData->DrvInfo.pszManufacturer;
        if ( pLocalData->InfInfo.DriverInfo6.pszMfgName )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszMfgName ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszOEMUrl        = pLocalData->DrvInfo.pszOEMUrl;
        if ( pLocalData->InfInfo.DriverInfo6.pszOEMUrl )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszOEMUrl ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszHardwareID    = pLocalData->DrvInfo.pszHardwareID;
        if ( pLocalData->InfInfo.DriverInfo6.pszHardwareID )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszHardwareID ) + 1 );

        pLocalData->InfInfo.DriverInfo6.pszProvider      = pLocalData->DrvInfo.pszProvider;
        if ( pLocalData->InfInfo.DriverInfo6.pszProvider )
           cchDriverInfo6 += ( lstrlen( pLocalData->InfInfo.DriverInfo6.pszProvider ) + 1 );

        pLocalData->InfInfo.DriverInfo6.ftDriverDate     = pLocalData->DrvInfo.ftDriverDate;
        pLocalData->InfInfo.DriverInfo6.dwlDriverVersion = pLocalData->DrvInfo.dwlDriverVersion;

        pInfInfo->cbDriverInfo6 = sizeof(DRIVER_INFO_6) +
                                    cchDriverInfo6 * sizeof(TCHAR);

        pLocalData->Flags  |= VALID_INF_INFO;
        pInfInfo->platform  = platform;
    }

    return !bFail;
}


LPDRIVER_INFO_6
GetDriverInfo6(
    IN  PSELECTED_DRV_INFO  pSelectedDrvInfo
    )
/*++

Routine Description:
    Gets the selected drivers information in a DRIVER_INFO_6 structure.

Arguments:

Return Value:
    Pointer to the DRIVER_INFO_6 structure. Memory is allocated for it.

--*/
{
    HINF                 hInf;
    PPSETUP_LOCAL_DATA   LocalData    = NULL;
    LPDRIVER_INFO_6      pDriverInfo6 = NULL;
    HDEVINFO             hDevInfo     = INVALID_HANDLE_VALUE;

    if ( !pSelectedDrvInfo                      ||
         !pSelectedDrvInfo->pszInfName          ||
         !*pSelectedDrvInfo->pszInfName         ||
         !pSelectedDrvInfo->pszModelName        ||
         !*pSelectedDrvInfo->pszModelName       ||
         !pSelectedDrvInfo->pszDriverSection    ||
         !*pSelectedDrvInfo->pszDriverSection ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        return NULL;
    }

    LocalData = PSetupDriverInfoFromName(hDevInfo, pSelectedDrvInfo->pszModelName);
    if (!LocalData) 
    {
        return NULL;
    }

    if ( ParseInf(hDevInfo, LocalData, MyPlatform, NULL, 0) ) {

        pDriverInfo6 = CloneDriverInfo6(&(LocalData->InfInfo.DriverInfo6),
                                        LocalData->InfInfo.cbDriverInfo6);
    }

    DestroyOnlyPrinterDeviceInfoList(hDevInfo);
    DestroyLocalData( LocalData );

    return pDriverInfo6;
}


LPDRIVER_INFO_3
PSetupGetDriverInfo3(
    IN  PSELECTED_DRV_INFO  pSelectedDrvInfo
    )
/*++

Routine Description:
    Gets the selected drivers information in a DRIVER_INFO_3 structure.
    This is for the test teams use

Arguments:

Return Value:
    Pointer to the DRIVER_INFO_3 structure. Memory is allocated for it.

--*/
{
    return (LPDRIVER_INFO_3) GetDriverInfo6(pSelectedDrvInfo);
}

LPTSTR
GetStringFromRcFile(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    TCHAR    buffer[MAX_SETUP_LEN];
    int      RetVal = 0;

    RetVal = LoadString(ghInst, uId, buffer, SIZECHARS(buffer));

    if ( RetVal )
    {
        return AllocStr(buffer);
    }
    else
    {
        return NULL;
    }
}

LPTSTR
GetLongStringFromRcFile(
    UINT    uId
    )
/*++

Routine Description:
    Load a long string from the .rc file, up to MAX_SETUP_ALLOC_STRING_LEN characters

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    LPTSTR   pBuf = NULL;
    int    Retry = 0, RetVal;

    //
    // I couldn't find a way to determine the length of a string the resource file, hence
    // I just try until the length returned by LoadString is smaller than the buffer I passed in
    //
    for (Retry = 1; Retry <= MAX_SETUP_ALLOC_STRING_LEN/MAX_SETUP_LEN; Retry++)
    {
        int CurrentSize = Retry * MAX_SETUP_LEN;

        pBuf = LocalAllocMem(CurrentSize * sizeof(TCHAR));
        if (!pBuf)
        {
            return NULL;
        }

        RetVal = LoadString(ghInst, uId, pBuf, CurrentSize);
    
        if (RetVal == 0)
        {
            LocalFreeMem(pBuf);
            return NULL;
        }

        if (RetVal < CurrentSize -1) // -1 because the LoadString ret value doesn't include the termination
        {
            return pBuf;
        }
        
        // 
        // RetVal is CurrentSize - retry
        //
        LocalFreeMem(pBuf);
    }

    return NULL;
}

BOOL
PSetupGetPathToSearch(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszDiskName,
    IN      LPCTSTR     pszFileName,
    IN      BOOL        bPromptForInf,
    IN OUT  TCHAR       szPath[MAX_PATH]
    )
/*++

Routine Description:
    Get path to search for some files by prompting the user

Arguments:
    hwnd            : Window handle of current top-level window
    pszTitle        : Title for the UI
    pszDiskName     : Diskname ot prompt the user
    pszFileName     : Name of the file we are looking for (NULL ok)
    pszPath         : Buffer to get the path entered by the user

Return Value:
    TRUE    on succesfully getting a path from user
    FALSE   else, Do GetLastError() to get the error

--*/
{
    DWORD   dwReturn, dwNeeded;

    dwReturn = SetupPromptForDisk(hwnd,
                                  pszTitle,
                                  pszDiskName,
                                  szPath[0] ? szPath : NULL,
                                  pszFileName,
                                  NULL,
                                  bPromptForInf ?
                                        (IDF_NOSKIP | IDF_NOBEEP | IDF_NOREMOVABLEMEDIAPROMPT | IDF_USEDISKNAMEASPROMPT) :
                                        (IDF_NOSKIP | IDF_NOBEEP),
                                  szPath,
                                  MAX_PATH,
                                  &dwNeeded);

    if ( dwReturn == DPROMPT_SUCCESS ) {

        //
        // Remove this from source list so that next time we are looking for
        // native drivers we do not end up picking from wrong source
        //
        SetupRemoveFromSourceList(SRCLIST_SYSIFADMIN, szPath);

        //
        // Terminate with a \ at the end
        //
        dwNeeded = lstrlen(szPath);
        if ( *(szPath + dwNeeded - 1) != TEXT('\\') &&
             dwNeeded < MAX_PATH - 2 ) {

            *(szPath + dwNeeded) = TEXT('\\');
            *(szPath + dwNeeded + 1) = sZero;
        }

        return TRUE;
    }

    if ( dwReturn == DPROMPT_OUTOFMEMORY ||
         dwReturn == DPROMPT_BUFFERTOOSMALL ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    } else {

        SetLastError(ERROR_CANCELLED);
    }

    return FALSE;
}



INT
IsDifferent(
    LPTSTR  p1,
    LPTSTR  p2,
    DWORD   (*pfn)(LPTSTR, LPTSTR)
    )
/*++

Routine Description:
    Extended version of strcmp/memcmp kind of function. Treats NULL pointer and
    the pointer to NULL as a match. For other cases call function passed in.

Arguments:
    p1      : First address to compare
    p2      : Second address to compare
    pfn     : Function to call if both p1 and p2 are non-NULL

Return Value:
    + means p1 > p2 (like how memcmp or strcmp defines), - means p1 < p2.
    0 if the values match

--*/
{
    //
    // We want to treat NULL ptr and ptr to NULL as the same thing
    //
    if ( p1 && !*p1 )
        p1 = NULL;

    if ( p2 && !*p2 )
        p2 = NULL;

    //
    // If both are NULL then they match
    //
    if ( !p1 && !p2 )
        return 0;

    //
    // Both are non NULL
    //
    if ( p1 && p2 )
        return pfn(p1, p2);

    //
    // One of them is NULL
    //
    if ( p1 )
        return 1;
    else
        return -1;
}


LPTSTR
FileNamePart(
    IN  LPCTSTR pszFullName
    )
/*++

Routine Description:
    Find the file name part of a fully qualified file name

Arguments:
    pszFullName : Fully qualified path to the file

Return Value:
    Pointer to the filename part in the fully qulaified string

--*/
{
    LPTSTR pszSlash, pszTemp;

    if ( !pszFullName )
        return NULL;

    //
    // First find the : for the drive
    //
    if ( pszTemp = lstrchr(pszFullName, TEXT(':')) )
        pszFullName = pszFullName + 1;

    for ( pszTemp = (LPTSTR)pszFullName ;
          pszSlash = lstrchr(pszTemp, TEXT('\\')) ;
          pszTemp = pszSlash + 1 )
    ;

    return *pszTemp ? pszTemp : NULL;

}


BOOL
SameMultiSz(
    LPTSTR  ppsz1,
    LPTSTR  ppsz2,
    BOOL    bFileName
    )
/*++

Routine Description:
    Checks if 2 multi-sz fields are the same. If bFileName is TRUE then
    get the file name part and compare that only (i.e. dependent files)

Arguments:
    ppsz1       : DependentFiles field from the INF
    ppsz2       : DependentFiles field from the spooler
    bFileName   : If TRUE compare file names, ignoring full path

Return Value:
    TRUE if the string are identical, FALSE else
    0 if the values match

--*/
{
    LPTSTR  p1, p2, p3;

    if ( !ppsz1 && !ppsz2 )
        return TRUE;

    if ( !ppsz1 || !ppsz2 )
        return FALSE;

    //
    // Check the file count is the same in the two lists
    //
    for ( p1 = ppsz1, p2 = ppsz2 ;
          *p1 && *p2 ;
          p1 += lstrlen(p1) + 1, p2 += lstrlen(p2) + 1 )
    ; // Nul body

    //
    // If one of them is not NULL the number of strings is different
    //
    if ( *p1 || *p2 )
        return FALSE;

    //
    // For each file in the first list see if it is present in the second list
    //
    for ( p1 = ppsz1 ; *p1 ; p1 += lstrlen(p1) + 1 ) {

        for ( p2 = ppsz2 ; *p2 ; p2 += lstrlen(p2) + 1 ) {

            p3 = bFileName ? FileNamePart(p2) : p2;
            if ( p3 && !lstrcmpi(p1, p3) )
                break;
        }

        //
        // We did not find p1 in ppsz2
        //
        if ( !*p2 )
            return FALSE;
    }

    return TRUE;
}


BOOL
IdenticalDriverInfo6(
    IN  LPDRIVER_INFO_6 p1,
    IN  LPDRIVER_INFO_6 p2
    )
/*++

Routine Description:
    Checks if DRIVER_INFO_6 are the same

Arguments:
    p1  : DRIVER_INFO_6 from the INF
    p2  : DRIVER_INFO_6 returned by the spooler

Return Value:
    TRUE if the DRIVER_INFO_6s are identical, FALSE else

--*/
{
    LPTSTR  psz;

    return (p1->dwlDriverVersion == (DWORDLONG)0    ||
            p2->dwlDriverVersion == (DWORDLONG)0    ||
            p1->dwlDriverVersion == p2->dwlDriverVersion)               &&
           !lstrcmpi(p1->pName, p2->pName)                              &&
            (psz = FileNamePart(p2->pDriverPath))                       &&
           !lstrcmpi(p1->pDriverPath, psz)                              &&
            (psz = FileNamePart(p2->pDataFile))                         &&
           !lstrcmpi(p1->pDataFile, psz)                                &&
            (psz = FileNamePart(p2->pConfigFile))                       &&
           !lstrcmpi(p1->pConfigFile, psz)                              &&
           !IsDifferent(p1->pHelpFile,
                        FileNamePart(p2->pHelpFile),
                        lstrcmpi)                                       &&
           !IsDifferent(p1->pMonitorName,
                        p2->pMonitorName,
                        lstrcmpi);

/*

    We changed the way we find dependent files from NT4 to NT5.
    So we do not want to look at them while deciding if a driver came from
    an INF.

           !IsDifferent(p1->pDefaultDataType,
                        p2->pDefaultDataType,
                        lstrcmpi);
           SameMultiSz(p1->pDependentFiles, p2->pDependentFiles, TRUE)  &&
           SameMultiSz(p1->pszzPreviousNames, p2->pszzPreviousNames, FALSE);
*/
}


BOOL
AllICMFilesInstalled(
    IN  LPCTSTR     pszServerName,
    IN  LPTSTR      pszzICMFiles
    )
/*++

Routine Description:
    Checks if all the icm files given are installed on the specified machine

Arguments:
    pszServerName   : Name of the server
    pszzICMFiles    : Multi-sz field giving all the ICM files

Return Value:
    TRUE if all the ICM profiles are installed on the server, FALSE else

--*/
{
    BOOL        bRet = FALSE;
    LPBYTE      buf = NULL;
    LPTSTR      p1, p2;
    DWORD       dwNeeded, dwReturned;
    ENUMTYPE    EnumType;

    if ( !pszzICMFiles || !*pszzICMFiles )
        return TRUE;

    //
    // ICM apis are not remotablr for now
    //
    if ( pszServerName )
        goto Cleanup;

    ZeroMemory(&EnumType, sizeof(EnumType));
    EnumType.dwSize     = sizeof(EnumType);
    EnumType.dwVersion  = ENUM_TYPE_VERSION;

    //
    // Get all the color profiles installed on the machine
    //
    dwNeeded = 0;
    if ( EnumColorProfiles((LPTSTR)pszServerName,
                           &EnumType,
                           NULL,
                           &dwNeeded,
                           &dwReturned) ||
         GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(buf = LocalAllocMem(dwNeeded))                    ||
         !EnumColorProfiles((LPTSTR)pszServerName,
                            &EnumType,
                            buf,
                            &dwNeeded,
                            &dwReturned) ) {

        goto Cleanup;
    }

    for ( p1 = pszzICMFiles ; *p1 ; p1 += lstrlen(p1) + 1 ) {

        for ( p2 = (LPTSTR)buf, dwNeeded = 0 ;
              dwNeeded < dwReturned && *p2 && lstrcmpi(p1, p2) ;
              ++dwNeeded, p2 += lstrlen(p2) + 1 )
        ;

        //
        // Did we find p1 in the enumerated color profiles?
        //
        if ( dwNeeded == dwReturned )
            goto Cleanup;
    }

    bRet = TRUE;

Cleanup:
    LocalFreeMem(buf);

    return bRet;
}


BOOL
CorrectVersionDriverFound(
    IN  LPDRIVER_INFO_2 pDriverInfo2,
    IN  DWORD           dwCount,
    IN  LPCTSTR         pszDriverName,
    IN  DWORD           dwMajorVersion
    )
/*++

Routine Description:
    Check if the correct version driver we are looking for is found in the list
    we got from spooler

Arguments:
    pDriverInfo2    : Points to the buffer of DRIVER_INFO_2 structs
    dwCount         : Number of DRIVER_INFO_2 elements in the buffer
    szDriverName    : Driver name
    dwMajorVersion  : Version no

Return Value:
    TRUE if driver is found in the lise, FALSE else

--*/
{
    DWORD   dwIndex;

    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex, ++pDriverInfo2 ) {

        //
        // Check if the driver is for the correct version
        //
        if ( dwMajorVersion != KERNEL_MODE_DRIVER_VERSION   &&
             dwMajorVersion != pDriverInfo2->cVersion )
            continue;

        if ( dwMajorVersion == KERNEL_MODE_DRIVER_VERSION   &&
             pDriverInfo2->cVersion < 2 )
            continue;

        if ( !lstrcmpi(pDriverInfo2->pName, pszDriverName) )
            return TRUE;
    }

    return FALSE;
}


BOOL
PSetupIsDriverInstalled(
    IN LPCTSTR      pszServerName,
    IN LPCTSTR      pszDriverName,
    IN PLATFORM     platform,
    IN DWORD        dwMajorVersion
    )
/*++

Routine Description:
    Findsout if a particular version of a printer driver is already installed
    in the system by querying spooler

Arguments:
    pszServerName   : Server name (NULL for local)
    pszDriverName    : Driver name
    platform        : platform for which we want to check the driver
    dwMajorVersion  : Version no

Return Value:
    TRUE if driver is installed,
    FALSE else (on error too)

--*/
{
    BOOL                bReturn = FALSE;
    DWORD               dwReturned, dwNeeded = 1024, dwReturned2;
    LPBYTE              p = NULL, p2 = NULL;
    LPTSTR              psz;
    LPDRIVER_INFO_6     pDriverInfo6;
    LPTSTR              pszServerArchitecture = NULL;

    if ( !(p = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             2,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        LocalFreeMem(p);
        p = NULL;

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(p = LocalAllocMem(dwNeeded))                          ||
             !EnumPrinterDrivers((LPTSTR)pszServerName,
                                 PlatformEnv[platform].pszName,
                                 2,
                                 p,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned) ) {

            goto Cleanup;
        }
    }

    bReturn = CorrectVersionDriverFound((LPDRIVER_INFO_2)p,
                                        dwReturned,
                                        pszDriverName,
                                        dwMajorVersion);

    //
    // Win95 drivers could have a different name than NT driver
    //
    if ( bReturn || platform != PlatformWin95 )
        goto Cleanup;

    dwNeeded = 1024;
    if ( !(p2 = LocalAllocMem(dwNeeded)) )
        goto Cleanup;

    pszServerArchitecture = GetArchitectureName( (LPTSTR)pszServerName );
    if (!pszServerArchitecture)
    {
        goto Cleanup;
    }

    if ( !EnumPrinterDrivers((LPTSTR)pszServerName,
                             pszServerArchitecture,
                             6,
                             p2,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned2) ) {

        LocalFreeMem(p2);
        p2 = NULL;

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(p2 = LocalAllocMem(dwNeeded))                         ||
             !EnumPrinterDrivers((LPTSTR)pszServerName,
                                 pszServerArchitecture,
                                 6,
                                 p2,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned2) )
            goto Cleanup;
    }

    for ( dwNeeded = 0, pDriverInfo6 = (LPDRIVER_INFO_6)p2 ;
          dwNeeded < dwReturned2 ;
          ++pDriverInfo6, ++dwNeeded ) {

        if ( pDriverInfo6->cVersion < 2 )
            continue;

        if ( !lstrcmpi(pDriverInfo6->pName, pszDriverName) )
            break;
    }

    if ( dwNeeded < dwReturned2 && (psz = pDriverInfo6->pszzPreviousNames) )
        while ( *psz ) {

            if ( bReturn = CorrectVersionDriverFound((LPDRIVER_INFO_2)p,
                                                     dwReturned,
                                                     psz,
                                                     dwMajorVersion) )
                break;

            psz += lstrlen(psz) + 1;
        }

Cleanup:
    LocalFreeMem(p);
    LocalFreeMem(p2);
    LocalFreeMem( pszServerArchitecture );

    return bReturn;
}


INT
PSetupIsTheDriverFoundInInfInstalled(
    IN  LPCTSTR             pszServerName,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwMajorVersion
    )
/*++
Routine Description:
    Findsout if a particular version of a printer driver is already installed
    in the system by querying spooler; Additionally check if the installed
    driver is the same found in the INF (file name matches only)

Arguments:
    pszServerName   : Server name (NULL for local)
    szDriverName    : Driver name
    platform        : platform for which we want to check the driver
    dwMajorVersion  : Version no;
                      If KERNEL_MODE_DRIVER_VERSION check for a KM driver

Return Value:
    DRIVER_MODEL_INSTALLED_AND_IDENTICAL :
        if driver is installed and all files are identical
    DRIVER_MODEL_NOT_INSTALLED :
       if a driver with the given model name is not available
    DRIVER_MODEL_INSTALLED_BUT_DIFFERENT :
       a driver with the given model name is installed but not all files
       are identical

--*/
{
    INT             iRet           = DRIVER_MODEL_NOT_INSTALLED;
    DWORD           dwReturned,
                    dwNeeded,
                    dwLastError;
    LPBYTE          p              = NULL;
    LPDRIVER_INFO_6 p1DriverInfo6,
                    p2DriverInfo6;
    HDEVINFO        hDevInfo       = INVALID_HANDLE_VALUE;

    ASSERT(pLocalData && pLocalData->signature == PSETUP_SIGNATURE);

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        goto Cleanup;
    }

    if ( !ParseInf(hDevInfo, pLocalData, platform, pszServerName, 0) )
        goto Cleanup;

    p1DriverInfo6 = &pLocalData->InfInfo.DriverInfo6;

    if ( EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             6,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned) ) {

        goto Cleanup;
    }

    if ( (dwLastError = GetLastError()) == ERROR_INVALID_LEVEL ) {

        iRet = PSetupIsDriverInstalled(pszServerName,
                                       p1DriverInfo6->pName,
                                       platform,
                                       dwMajorVersion)
                        ? DRIVER_MODEL_INSTALLED_BUT_DIFFERENT
                        : DRIVER_MODEL_NOT_INSTALLED;
        goto Cleanup;
    }

    if ( dwLastError != ERROR_INSUFFICIENT_BUFFER   ||
         !(p = LocalAllocMem(dwNeeded))                  ||
         !EnumPrinterDrivers((LPTSTR)pszServerName,
                             PlatformEnv[platform].pszName,
                             6,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        goto Cleanup;
    }

    for ( dwNeeded = 0, p2DriverInfo6 = (LPDRIVER_INFO_6) p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, (LPBYTE) p2DriverInfo6 += sizeof(DRIVER_INFO_6) ) {

        //
        // Check if the driver is for the correct version
        //
        if ( dwMajorVersion != KERNEL_MODE_DRIVER_VERSION   &&
             dwMajorVersion != p2DriverInfo6->cVersion )
            continue;

        if ( dwMajorVersion == KERNEL_MODE_DRIVER_VERSION   &&
             p2DriverInfo6->cVersion < 2 )
            continue;

        if ( !lstrcmpi(p2DriverInfo6->pName, p1DriverInfo6->pName) ) {

            if ( IdenticalDriverInfo6(p1DriverInfo6,
                                      p2DriverInfo6) &&
                 AllICMFilesInstalled(pszServerName,
                                      pLocalData->InfInfo.pszzICMFiles) )
                iRet = DRIVER_MODEL_INSTALLED_AND_IDENTICAL;
            else
                iRet = DRIVER_MODEL_INSTALLED_BUT_DIFFERENT;

            goto Cleanup;
        }
    }

Cleanup:
    LocalFreeMem(p);

    DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    return iRet;
}


PLATFORM
PSetupThisPlatform(
    VOID
    )
{
    return MyPlatform;
}


BOOL
DeleteAllFilesInDirectory(
    LPCTSTR     pszDir,
    BOOL        bDeleteDirectory
    )
/*++

Routine Description:
    Delete all the files in a directory, and optionally the directory as well.

Arguments:
    pszDir              : Directory name to cleanup
    bDeleteDirectory    : If TRUE the directory gets deleted as well

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL                bRet = TRUE;
    HANDLE              hFile;
    DWORD               dwLen;
    TCHAR               *pszFile        = NULL;
    TCHAR               *pszBuf         = NULL;
    INT                 cbLength        = 0;
    INT                 cbBufLength     = 0;
    INT                 cbInitialLength = 4 * MAX_PATH;
    WIN32_FIND_DATA     FindData;


    if (!pszDir) 
    {
        bRet = FALSE;
        goto Cleanup;
    }

    cbLength = max( cbInitialLength, lstrlen( pszDir ) + lstrlen( TEXT("\\*") ) + 1);
    pszFile  = LocalAllocMem( cbLength * sizeof( TCHAR ));
    if (!pszFile) 
    {
        bRet = FALSE;
        goto Cleanup;
    }

    lstrcpy(pszFile, pszDir);
    dwLen = lstrlen(pszFile);
    lstrcpy(pszFile + dwLen, TEXT("\\*"));

    hFile = FindFirstFile(pszFile, &FindData);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        bRet = FALSE;
        goto Cleanup;
    }

    *(pszFile + dwLen + 1) = TEXT('\0');
    pszBuf = AllocStr( pszFile );
    if (!pszBuf) 
    {
        bRet = FALSE;
        goto Cleanup;
    }
    cbBufLength = lstrlen( pszBuf );

    do {

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            continue;

        cbLength = cbBufLength + lstrlen( FindData.cFileName ) + 1;
        if (cbLength > cbInitialLength) 
        {
            LocalFreeMem( pszFile );
            pszFile = LocalAllocMem( cbLength * sizeof( TCHAR ));
            if (!pszFile) 
            {
                bRet = FALSE;
                goto Cleanup;
            }
            cbInitialLength = cbLength;
        }
        lstrcpy(pszFile, pszBuf);
        lstrcat(pszFile, FindData.cFileName );

        //
        // Remove the FILE_ATTRIBUTE_READONLY file attribute if it has been set
        //
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
        {
            SetFileAttributes( pszFile, 
                               FindData.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY );
        } 
        
        if ( !DeleteFile(pszFile) )
            bRet = FALSE;
    } while ( FindNextFile(hFile, &FindData) );

    FindClose(hFile);
    if ( bDeleteDirectory && !RemoveDirectory(pszDir) )
        bRet = FALSE;

Cleanup:

    LocalFreeMem( pszFile );
    LocalFreeMem( pszBuf );
    return bRet;
}

//
// enum to store the NT-CD type
//
typedef enum _eCDType {
    CD_Unknown,
    CD_NT4,
    CD_W2K_SRV,
    CD_W2K_PRO,
    CD_WHISTLER_SRV,
    CD_WHISTLER_WKS
} CD_TYPE;

//
// structure that stores the tag file names of the NT CDs
//
typedef struct _CD_TAGFILE_MAP_ENTRY {
    CD_TYPE CdType;
    LPTSTR  pszTagFileName;
}CD_TAGFILE_MAP_ENTRY;

CD_TAGFILE_MAP_ENTRY TagEntries[] =
{
    //
    // the following entry for the Whistler CD is special in a couple of ways:
    // - it uses a wildcard because the tag filename changes from Beta1 to Beta2 and again to RTM
    // - it identifies the CD as W2k despite it being for Whistler. The reason is that the layout regarding
    //   printer drivers is identical to W2k, no need to distinguish (and duplicate entries)
    //
    { CD_W2K_SRV, _T("WIN51.*") },

    { CD_W2K_SRV, _T("CDROM_NT.5") },
    { CD_NT4, _T("CDROM_S.40") },
    { CD_NT4, _T("CDROM_W.40") },
    //
    // no need to identify NT3.x CDs - different codepath !
    //
    { CD_Unknown, NULL }
};


//
// structure to store the subpaths to printer INFs on the NT CDs
//
typedef struct _CD_SUBPATHS_FOR_PLATFORMS {
    CD_TYPE     CdType;
    PLATFORM    Platform;
    DWORD       Version;
    LPCTSTR     pszSubPath;
} CD_SUBPATHS_FOR_PLATFORMS;

//
// this list is used for lookup of pathes as well - must be sorted so that paths
// that contain other paths must come before them (e.g. xxx\zzz before \zzz)
//
CD_SUBPATHS_FOR_PLATFORMS SubPathInfo[] =
{
    { CD_W2K_SRV, PlatformX86, 2, _T("printers\\nt4\\i386\\") },
    { CD_W2K_SRV, PlatformWin95, 0, _T("printers\\win9x\\") },
    { CD_W2K_SRV, PlatformX86, 3, _T("i386\\") },
    { CD_W2K_SRV, PlatformIA64, 3, _T("ia64\\") },

    { CD_NT4, PlatformX86, 2, _T("i386\\") },
    { CD_NT4, PlatformAlpha, 2, _T("alpha\\") },
    { CD_NT4, PlatformMIPS, 2, _T("mips\\") },
    { CD_NT4, PlatformPPC, 2, _T("ppc\\") },

    //
    // path = NULL terminates the array
    //
    { CD_Unknown, PlatformX86, 0 , NULL }
};

CD_TYPE
DetermineCDType(LPTSTR pszInfPath, LPTSTR pszRootPath)
/*++

Routine Description:
    From a path to a printer INF, figure out what (if any) NT CD this is.
    It does so by figuring out the root path if it's one of the NT CDs and
    then checking the tag file that should be there.

Arguments:
    pszInfPath  : path to INF
    pszRootPath : caller-supplied buffer (MAX_PATH long) that receives the
                  path to the CD "root". This is nontrivial in case the CD
                  is on a network share. Ends with a backslash

Return Value:
    The type of CD detected, CD_Unknown if not one that we know of (i.e. an OEM CD)

--*/
{
    LPTSTR pszTemp;
    DWORD i;

    //
    // find the root path
    //
    DWORD_PTR MinPathLen = 0, SubPathLen, len;

    _tcscpy(pszRootPath, pszInfPath);
    len = _tcslen(pszRootPath);

    //
    // make sure it ends with a backslash
    //
    if (pszRootPath[len-1] != _T('\\'))
    {
        pszRootPath[len++] = _T('\\');
        pszRootPath[len] = 0;
    }

    //
    // Is it a UNC path ?
    //

    if (!_tcsncmp(pszRootPath, _T("\\\\"), 2))
    {
        pszTemp = _tcschr(pszRootPath + 2, _T('\\'));
        if (pszTemp)
        {
            pszTemp = _tcschr(pszTemp+1, _T('\\'));
            if (pszTemp)
            {
                MinPathLen = pszTemp - pszRootPath;
            }
        }

        //
        // check for illegal path, shouldn't happen
        //
        if ((MinPathLen == 0) || (MinPathLen > len))
        {
            return CD_Unknown;
        }
    }
    else
    {
        MinPathLen = 2;
    }

    //
    // now check whether the final part of the path is one that I know of
    //
    for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
    {
        SubPathLen = _tcslen(SubPathInfo[i].pszSubPath);
        if (SubPathLen + MinPathLen <= len)
        {
            if (!_tcsnicmp(&(pszRootPath[len - SubPathLen]),
                           SubPathInfo[i].pszSubPath, SubPathLen))
            {
                pszRootPath[len-SubPathLen] = 0;
                len = _tcslen(pszRootPath);
                break;
            }
        }
    }

    //
    // if it's none of the paths I know of, it can still be the root itself.
    // now I know where the tag files should be if they're there
    //
    for (i = 0;TagEntries[i].pszTagFileName != NULL; ++i)
    {
        _tcscpy(&(pszRootPath[len]), TagEntries[i].pszTagFileName);

        if (FileExists(pszRootPath))
        {
            pszRootPath[len] = 0; // cut off the tag file name
            return TagEntries[i].CdType;
        }
    }

    return CD_Unknown;
}

BOOL
CheckValidInfInPath(HWND hwnd, LPTSTR pszInfPath, DWORD dwVersion, PLATFORM Platform)
{
    TCHAR szInfFiles[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    DWORD PathLen;
    BOOL bRet = FALSE;

    //
    // first, find the INF in the path. There must be one else SetupPromptForPath would've complained
    //
    _tcscpy(szInfFiles, pszInfPath);
    PathLen = _tcslen(szInfFiles);

    if (szInfFiles[PathLen-1] != _T('\\'))
    {
        szInfFiles[PathLen++] = _T('\\');
        szInfFiles[PathLen] = 0;
    }

    _tcscat(szInfFiles, _T("*.inf"));

    hFind = FindFirstFile(szInfFiles, &FindData);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        DWORD InfStyle;
        HANDLE hInfFile;

        if ((dwVersion == 0) && (Platform != PlatformWin95))
        {
            InfStyle = INF_STYLE_OLDNT;
        }
        else
        {
            InfStyle = INF_STYLE_WIN4;
        }

        do
        {
            _tcscpy(&(szInfFiles[PathLen]), FindData.cFileName);

            hInfFile = SetupOpenInfFile(szInfFiles, _T("Printer"), InfStyle, NULL);

            if (hInfFile != INVALID_HANDLE_VALUE)
            {
                SetupCloseInfFile(hInfFile);
                bRet = TRUE;
                break;
            }
        } while ( FindNextFile(hFind, &FindData) );

        FindClose(hFind);
    }

    if (!bRet)
    {
        LPTSTR pszFormat = NULL, pszPrompt = NULL, pszTitle = NULL;

        pszFormat   = GetStringFromRcFile(IDS_WARN_NO_ALT_PLATFORM_DRIVER);
        pszTitle    = GetStringFromRcFile(IDS_WARN_NO_DRIVER_FOUND);

        if ( pszFormat && pszTitle)
        {
            pszPrompt = LocalAllocMem((lstrlen(pszFormat) + lstrlen(pszInfPath) + 2)
                                                * sizeof(TCHAR));

            if ( pszPrompt )
            {
                wsprintf(pszPrompt, pszFormat, pszInfPath);

                MessageBox(hwnd, pszPrompt, pszTitle, MB_OK);

                LocalFreeMem(pszPrompt);
            }

        }
        LocalFreeMem(pszFormat);
        LocalFreeMem(pszTitle);
    }

    return bRet;
}


BOOL
CheckInfPath(HWND hwnd, LPTSTR pszInfPath, DWORD dwVersion, PLATFORM platform,
             LPTSTR *ppFileSrcPath)
/*++

Routine Description:
    Check whether the path that a user selected as a path to install a printer
    from points to one of our CDs and correct the path if necessary, i.e. if
    the luser selected the \i386 subdir for an NT4 driver.

Arguments:
    hwnd        : windows handle of the main window
    pszInfPath  : path to INF
    dwVersion   : driver version that the new driver is installed for
    platform    : the platform that the new driver is installed for
    ppFileSrcPath: if not NULL, receives the path to the printer files. This
                  is used for installation from the NT4 CD that contains a
                  compressed INF that I have to uncompress  and install from
                  without copying all the files possibly referenced in it.
                  Needs to be freed by the caller.

Return Value:
    TRUE: path contains a valid print inf
    FALSE: path doesn't contain a print inf, prompt user again

--*/
{
    CD_TYPE CDType;
    TCHAR   szRootPath[MAX_PATH];
    DWORD   i;

    //
    // determine the type of CD
    //
    CDType = DetermineCDType(pszInfPath, szRootPath);

    if (CDType == CD_Unknown)
    {
        return CheckValidInfInPath(hwnd, pszInfPath, dwVersion, platform);
    }

    //
    // NT 4 drivers are compressed -> uncompress into temp dir
    //
    if ((dwVersion == 2) && (CDType == CD_NT4))
    {
        //
        // Make sure the file is actually the compressed one
        //
        DWORD rc, CompressedFileSize, UncompressedFileSize;
        UINT  CompType;
        LPTSTR pszUncompFilePath = NULL, pszInfFileName = _T("ntprint.in_");
        TCHAR szInf[MAX_PATH];

        _tcscpy(szInf, szRootPath);

        //
        // append the correct subpath
        //
        for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
        {
            if ((SubPathInfo[i].CdType == CD_NT4) &&
                (platform == SubPathInfo[i].Platform) &&
                (dwVersion == SubPathInfo[i].Version))
            {
                _tcscat(szInf, SubPathInfo[i].pszSubPath);
                break;
            }
        }
        _tcscat(szInf, pszInfFileName);

        rc = SetupGetFileCompressionInfo(szInf,
                                         &pszUncompFilePath,
                                         &CompressedFileSize,
                                         &UncompressedFileSize,
                                         &CompType);

        if (rc == NO_ERROR)
        {
            LocalFree(pszUncompFilePath); // don't need that

            if (CompType != FILE_COMPRESSION_NONE)
            {
                TCHAR UncompFilePath[MAX_PATH], *pTmp;

                //
                // decompress into temp directory
                //
                if (GetTempPath(MAX_PATH, UncompFilePath) &&
                    (_tcscat(UncompFilePath, _T("ntprint.inf")) != NULL) &&
                    (SetupDecompressOrCopyFile(szInf, UncompFilePath, NULL) == NO_ERROR))
                {
                    if (ppFileSrcPath)
                    {
                        //
                        // delete the inf name from the path
                        //
                        pTmp = _tcsrchr(szInf, _T('\\'));
                        if (pTmp)
                        {
                            *(pTmp+1) = 0;
                        }
                        *ppFileSrcPath = AllocStr(szInf);
                    }

                    _tcscpy(pszInfPath, UncompFilePath);

                    //
                    // delete the inf name from the path
                    //
                    pTmp = _tcsrchr(pszInfPath, _T('\\'));
                    if (pTmp)
                    {
                        *(pTmp+1) = 0;
                    }

                    return TRUE;
                }
            }
        }
    }

    //
    // correct the path if it's the one for a different platform
    //
    for (i = 0; SubPathInfo[i].pszSubPath != NULL; ++i)
    {
        if ((CDType == SubPathInfo[i].CdType) &&
            (platform == SubPathInfo[i].Platform) &&
            (dwVersion == SubPathInfo[i].Version))
        {
            _tcscpy(pszInfPath, szRootPath);
            _tcscat(pszInfPath, SubPathInfo[i].pszSubPath);

            break;
        }
    }

    return CheckValidInfInPath(hwnd, pszInfPath, dwVersion, platform);
}


HDEVINFO
GetInfAndBuildDrivers(
    IN  HWND                hwnd,
    IN  DWORD               dwTitleId,
    IN  DWORD               dwDiskId,
    IN  TCHAR               szInfPath[MAX_PATH],
    IN  DWORD               dwInstallFlags,
    IN  PLATFORM            platform,
    IN  DWORD               dwVersion,
    IN  LPCTSTR             pszDriverName,              OPTIONAL
    OUT PPSETUP_LOCAL_DATA *ppLocalData,                OPTIONAL
    OUT LPTSTR             *ppFileSrcPath               OPTIONAL

    )
/*++

Routine Description:
    Prompt for an INF and build the list of printer drivers from INFs found
    in the directory. If pszDriverName is passed in then the INF should have
    a model with matching name (i.e. alternate driver installation case)

Arguments:
    hwnd            : Parent window handle for UI
    dwTitleId       : Gives the identifier to be used to load the title string
                      from the rc file
    dwDiskId        : Gives the identifier to be used to load the disk identifier
                      from the rc file
    szInfPath       : Directory name where inf was found
    pszDriverName   : Name of the driver needed in the INF
    ppLocalData     : If a driver nam is given on return this will give
                      the local data for that
    dwInstallFlags  : Flags to control installation operation

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL        bDoRetry = TRUE;
    DWORD       dwLen, dwLastError;
    LPTSTR      pszTitle = NULL, pszDisk = NULL;
    HDEVINFO    hDevInfo = INVALID_HANDLE_VALUE;

    dwLen = lstrlen(szInfPath);
    szInfPath[dwLen]    = TEXT('\\');

    if ( dwLen + lstrlen(cszAllInfs) + 1 > MAX_PATH )
        goto Cleanup;

    lstrcpy(szInfPath+dwLen + 1, cszAllInfs);

Retry:
    if ( bDoRetry && FileExists(szInfPath) ) {

        szInfPath[dwLen] = TEXT('\0');
    } else {

        //
        // if the file doesn't exist in the first place, prompt only once !
        //
        bDoRetry = FALSE;

        //
        // Always just prompt with the CD-ROM path
        //
        GetCDRomDrive(szInfPath);

        if ( dwInstallFlags & DRVINST_PROMPTLESS ) {

            SetLastError(ERROR_FILE_NOT_FOUND);
            goto Cleanup;
        }

        if ( dwTitleId && !(pszTitle = GetStringFromRcFile(dwTitleId)) )
            goto Cleanup;

        if ( dwDiskId && !(pszDisk = GetStringFromRcFile(dwDiskId)) )
            goto Cleanup;

        do
        {
            if ( !PSetupGetPathToSearch(hwnd, pszTitle, pszDisk,
                                        cszAllInfs, TRUE, szInfPath) )
                goto Cleanup;

        } while (!CheckInfPath(hwnd, szInfPath, dwVersion, platform, ppFileSrcPath));
    }

    hDevInfo = CreatePrinterDeviceInfoList(hwnd);

    if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
         !SetDevInstallParams(hDevInfo, NULL, szInfPath)        ||
         !BuildClassDriverList(hDevInfo)                        ||
         (pszDriverName &&
          !(*ppLocalData = PSetupDriverInfoFromName(hDevInfo,
                                                    pszDriverName))) ) {

        dwLastError = GetLastError();
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;
        SetLastError(dwLastError);
        if ( bDoRetry ) {

            bDoRetry = FALSE;
            goto Retry;
        }
        goto Cleanup;
    }

Cleanup:
    LocalFreeMem(pszTitle);
    LocalFreeMem(pszDisk);

    return hDevInfo;
}


BOOL
MyName(
    IN  LPCTSTR     pszServerName
    )
/*++

Routine Description:
    Tells if the string passed in identifies the local machine. Currently
    it checks for NULL and computer name only

Arguments:
    pszServerName   : Name of the server passed in

Return Value:
    TRUE if the name is recognized as that for local machine, FALSE else

--*/
{
    TCHAR   szBuf[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   dwNeeded;

    if ( !pszServerName || !*pszServerName )
        return TRUE;

    return FALSE;
/*
    dwNeeded = SIZECHARS(szBuf);

    if ( *pszServerName == TEXT('\\')       &&
         *(pszServerName+1) == TEXT('\\')   &&
         GetComputerName(szBuf, &dwNeeded)  &&
         !lstrcmpi(pszServerName+2, szBuf) ) {

        return TRUE;
    }
*/

}


BOOL
PSetupGetLocalDataField(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    )
/*++

Routine Description:
    Returns a driver installation field found from inf parsing.
    Printui uses this routine for all the queries.
    Since INF could have different sections for different platforms
    (notably for Win95 and NT but architecture specific install sections
     are possible too)

Arguments:
    pLocalData  : Pointer to local data
    platform    : Which platform the field is for
    pDrvField   : Points to DRIVER_FIELD where field is copied to

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL     bRet     = FALSE;
    DWORD    cbSize;
    LPTSTR   psz;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;

    ASSERT(pLocalData   &&
           pDrvField    &&
           pLocalData->signature == PSETUP_SIGNATURE);

    if(INVALID_HANDLE_VALUE == (hDevInfo = CreatePrinterDeviceInfoList(NULL)))
    {
        return bRet;
    }

    switch ( pDrvField->Index ) {

        case    DRIVER_NAME:
            if ( pDrvField->pszDriverName = AllocStr(pLocalData->DrvInfo.pszModelName) )
                bRet = TRUE;
            break;

        case    INF_NAME:
            if ( pDrvField->pszInfName = AllocStr(pLocalData->DrvInfo.pszInfName) )
                bRet = TRUE;
            break;

        case    DRV_INFO_4:
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0)     &&
                 (pDrvField->pDriverInfo4
                        = (LPDRIVER_INFO_4) CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                           pLocalData->InfInfo.cbDriverInfo6)) )
                bRet = TRUE;
            break;

        case    DRV_INFO_6:
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0)     &&
                 (pDrvField->pDriverInfo6
                        = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                           pLocalData->InfInfo.cbDriverInfo6)) )
                bRet = TRUE;
            break;

        case    PRINT_PROCESSOR_NAME:
            pDrvField->pszPrintProc = NULL;

            if ( ParseInf(hDevInfo, pLocalData, platform, NULL, 0) ) {

                if ( !pLocalData->InfInfo.pszPrintProc  ||
                     (pDrvField->pszPrintProc = AllocStr(pLocalData->InfInfo.pszPrintProc)) )
                    bRet = TRUE;
            }
            break;

        case    ICM_FILES:
            pDrvField->pszzICMFiles = NULL;
            if ( ParseInf(hDevInfo, pLocalData, platform, NULL ,0) ) {

                for ( cbSize = 0, psz = pLocalData->InfInfo.pszzICMFiles ;
                      psz && *psz ;
                      cbSize += lstrlen(psz) + 1, psz += lstrlen(psz) + 1 )
                ;

                if ( cbSize == 0 ) {

                    bRet = TRUE;
                    break;
                }

                //
                // One more char for the last \0 in the multi-sz
                //
                cbSize = (cbSize + 1 ) * sizeof(TCHAR);

                if ( pDrvField->pszzICMFiles = LocalAllocMem(cbSize) ) {

                    CopyMemory((LPBYTE)pDrvField->pszzICMFiles,
                               (LPBYTE)pLocalData->InfInfo.pszzICMFiles,
                               cbSize);
                    bRet = TRUE;
                }
            }

            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;

    }

    DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    return bRet;
}


VOID
PSetupFreeDrvField(
    IN  PDRIVER_FIELD   pDrvField
    )
/*++

Routine Description:
    Frees the memory allocated for a driver installation field in a previous
    call

Arguments:
    pDrvField   : Points to DRIVER_FIELD where field is copied to

Return Value:
    None

--*/
{
    LocalFreeMem(pDrvField->pszPrintProc);
}

BOOL
FileExists(
    IN  LPCTSTR  pszFileName
    )
/*++

Routine Description:
    Checks if the given file exists setting correct error modes not to bring
    up any pop-ups.
    call

Arguments:
    pszFileName : File name (fully qualified)

Return Value:
    TRUE if file exists, FALSE else.

--*/
{
    UINT                OldMode;
    HANDLE              hFile;
    WIN32_FIND_DATA     FindData;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hFile = FindFirstFile(pszFileName, &FindData);

    if ( hFile != INVALID_HANDLE_VALUE )
        FindClose(hFile);

    SetErrorMode(OldMode);

    return hFile != INVALID_HANDLE_VALUE;
}


BOOL
IsMonitorInstalled(
   IN LPTSTR pszMonitorName
   )
{
   LPBYTE pMonitors = NULL;
   DWORD  dwNeeded, dwReturned;
   BOOL   bMonFound = FALSE;

   // First Build a list of Monitors installed on machine

   //
   // First query spooler for installed monitors. If we fail let's quit
   //
   if ( !EnumMonitors((LPTSTR) NULL, 2, NULL, 0, &dwNeeded, &dwReturned) )
   {
      if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
           !(pMonitors = LocalAllocMem(dwNeeded)) ||
           !EnumMonitors((LPTSTR) NULL, 2, pMonitors, dwNeeded, &dwNeeded, &dwReturned) )
      {
          goto Cleanup;
      }

      // Now see if the monitor is already installed
      if ( IsMonitorFound(pMonitors, dwReturned, pszMonitorName) )
         bMonFound = TRUE;
   }

   Cleanup:

   if (pMonitors)
      LocalFreeMem( pMonitors );

   return bMonFound;
}

BOOL
IsLanguageMonitorInstalled(PCTSTR pszMonitorName)
/*++

Routine Description:
    Checks for whether a language monitor is installed. The function above only checks for
    port monitors, because EnumMonitors doesn't enumerate language monitors. Since there is 
    no API to do that, we sneak a peek at the registry. XP-Bug 416129.

Arguments:
    pszMonitorName   : Monitor name to check

Return Value:
    TRUE if installed

--*/
{
    PTSTR pKeyName = NULL;
    BOOL  IsInstalled = FALSE;

    StrCatAlloc(&pKeyName, cszMonitorKey, pszMonitorName, NULL);
    if (pKeyName)
    {
        HKEY hKey;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            IsInstalled = TRUE;
            RegCloseKey(hKey);
        }
        FreeSplMem(pKeyName);
    }

    return IsInstalled;
}

BOOL
CleanupUniqueScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
)
{
    BOOL        bRet;
    TCHAR       szDir[MAX_PATH];
    DWORD       dwNeeded;

    bRet = GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                      PlatformEnv[platform].pszName,
                                      1,
                                      (LPBYTE)szDir,
                                      sizeof(szDir),
                                      &dwNeeded);

    if (bRet)
    {
        bRet = AddDirectoryTag(szDir, MAX_PATH);
    }
    
    if (bRet)
    { 
        bRet = DeleteAllFilesInDirectory(szDir, TRUE);
    }

    return bRet;
}


BOOL
CleanupScratchDirectory(
    IN  LPCTSTR     pszServerName,
    IN  PLATFORM    platform
    )
{
    TCHAR       szDir[MAX_PATH];
    DWORD       dwNeeded;

    return  GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                      PlatformEnv[platform].pszName,
                                      1,
                                      (LPBYTE)szDir,
                                      sizeof(szDir),
                                      &dwNeeded)                        &&
            DeleteAllFilesInDirectory(szDir, FALSE);
}

LPTSTR
GetSystemInstallPath(
    VOID
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwSize, dwType;
    HKEY    hKey;
    TCHAR   szSetupKey[] = TEXT( "Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    TCHAR   szSourceValue[] = TEXT("SourcePath");
    LPTSTR  pszSourcePath = NULL;

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       szSetupKey,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKey) ) {

        if ( ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              szSourceValue,
                                              NULL,
                                              &dwType,
                                              NULL,
                                              &dwSize) )
        {
           if (pszSourcePath = (LPTSTR) LocalAllocMem(dwSize))
           {
              if ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                    szSourceValue,
                                                    NULL,
                                                    &dwType,
                                                    (LPBYTE)pszSourcePath,
                                                    &dwSize) )
              {
                 LocalFreeMem(pszSourcePath);
                 pszSourcePath = NULL;
              }
           }
        }

        RegCloseKey(hKey);
    }

    return pszSourcePath;
}

PPSETUP_LOCAL_DATA
RebuildDeviceInfo(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszSource
    )
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData, TempDriverInfoData;
    PPSETUP_LOCAL_DATA  pNewLocalData = NULL;
    DWORD Err;

    //
    // Retrieve the current device install parameters, in preparation for modifying them to
    // target driver search at a particular INF.
    //
    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DeviceInstallParams)) {
        return NULL;
    }

    SetupDiDestroyDriverInfoList(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER);

    // Set the path of the INF
    lstrcpy( DeviceInstallParams.DriverPath, pszSource );

    //
    // set the flag that indicates DriverPath represents a single INF to be searched (and
    // not a directory path).  Then store the parameters back to the device information element.
    //
    // DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DeviceInstallParams))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now build a class driver list from this INF.
    //
    if(!SetupDiBuildDriverInfoList(hDevInfo, pLocalData->DrvInfo.pDevInfoData, SPDIT_CLASSDRIVER))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // OK, now select the driver node from that INF that was used to install this device.
    // The three parameters that uniquely identify a driver node are INF Provider,
    // Device Manufacturer, and Device Description.  Retrieve these three pieces of information
    // in preparation for selecting the proper driver node in the class list we just built.
    //
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
    DriverInfoData.Reserved = 0;  // Search for the driver matching the specified criteria and
                                  // select it if found.
    // Fill in the Model & Mfg from original INF
    lstrcpy( DriverInfoData.Description, pLocalData->DrvInfo.pszModelName );
    lstrcpy( DriverInfoData.MfgName, pLocalData->DrvInfo.pszManufacturer );

    // Enum One driver entry to get the INF provider
    ZeroMemory(&TempDriverInfoData, sizeof(TempDriverInfoData));
    TempDriverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
    if (!SetupDiEnumDriverInfo (hDevInfo, NULL, SPDIT_CLASSDRIVER, 0, &TempDriverInfoData))
    {
        Err = GetLastError();
        goto clean0;
    }
    lstrcpy( DriverInfoData.ProviderName, TempDriverInfoData.ProviderName );


    if(!SetupDiSetSelectedDriver(hDevInfo, pLocalData->DrvInfo.pDevInfoData, &DriverInfoData))
    {
        Err = GetLastError();
        goto clean0;
    }

    //
    // At this point, we've successfully selected the currently installed driver for the specified
    // device information element.
    //
    // Now build the new LocalData
    //
    pNewLocalData = BuildInternalData(hDevInfo, NULL);
    if ( pNewLocalData )
    {
        if ( !ParseInf(hDevInfo, pNewLocalData, MyPlatform, NULL, 0) )
        {
            Err = GetLastError();
            DestroyLocalData( pNewLocalData );
            pNewLocalData = NULL;
        }
        else
        {
           SELECTED_DRV_INFO TempDrvInfo;

           TempDrvInfo.pszInfName        = AllocStr( pNewLocalData->DrvInfo.pszInfName );
           TempDrvInfo.pszDriverSection  = AllocStr( pNewLocalData->DrvInfo.pszDriverSection );
           TempDrvInfo.pszModelName      = AllocStr( pNewLocalData->DrvInfo.pszModelName );
           TempDrvInfo.pszManufacturer   = AllocStr( pNewLocalData->DrvInfo.pszManufacturer );
           TempDrvInfo.pszHardwareID     = AllocStr( pNewLocalData->DrvInfo.pszHardwareID );
           TempDrvInfo.pszOEMUrl         = AllocStr( pNewLocalData->DrvInfo.pszOEMUrl );

           // Check that all strings were allocated
           if ( !TempDrvInfo.pszInfName       ||
                !TempDrvInfo.pszDriverSection ||
                !TempDrvInfo.pszModelName     ||
                !TempDrvInfo.pszManufacturer  ||
                !TempDrvInfo.pszHardwareID    ||
                !TempDrvInfo.pszOEMUrl      )
           {
              // Free up all that worked
              LocalFreeMem( TempDrvInfo.pszInfName );
              LocalFreeMem( TempDrvInfo.pszDriverSection );
              LocalFreeMem( TempDrvInfo.pszModelName );
              LocalFreeMem( TempDrvInfo.pszManufacturer );
              LocalFreeMem( TempDrvInfo.pszHardwareID );
              LocalFreeMem( TempDrvInfo.pszOEMUrl );

           }
           else
           {
              // Free the DrvInfo pointers & refill from new local data
              LocalFreeMem( pLocalData->DrvInfo.pszInfName );
              LocalFreeMem( pLocalData->DrvInfo.pszDriverSection );
              LocalFreeMem( pLocalData->DrvInfo.pszModelName );
              LocalFreeMem( pLocalData->DrvInfo.pszManufacturer );
              LocalFreeMem( pLocalData->DrvInfo.pszHardwareID );
              LocalFreeMem( pLocalData->DrvInfo.pszOEMUrl );


              pLocalData->DrvInfo.pszInfName        = TempDrvInfo.pszInfName;
              pLocalData->DrvInfo.pszDriverSection  = TempDrvInfo.pszDriverSection;
              pLocalData->DrvInfo.pszModelName      = TempDrvInfo.pszModelName;
              pLocalData->DrvInfo.pszManufacturer   = TempDrvInfo.pszManufacturer;
              pLocalData->DrvInfo.pszHardwareID     = TempDrvInfo.pszHardwareID;
              pLocalData->DrvInfo.pszOEMUrl         = TempDrvInfo.pszOEMUrl;
           }

           Err = NO_ERROR;
        }
    }
    else
        Err = GetLastError();


clean0:

    SetLastError(Err);
    return pNewLocalData;

}

BOOL
SetupSkipDir(
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName
    )
{
   BOOL       bRet = FALSE;
   TCHAR      szDir[MAX_PATH];
   TCHAR      szMSecs[10];
   SYSTEMTIME SysTime;
   DWORD      dwNeeded = ( MAX_PATH * sizeof( TCHAR ) );

   EnterCriticalSection(&SkipCritSect);

   // We already have a skip dir created
   if ( !gpszSkipDir )
   {
      // Get a location for a Temp Path
      if ( !GetPrinterDriverDirectory((LPTSTR)pszServerName, PlatformEnv[platform].pszName,
                                      1, (LPBYTE) szDir, dwNeeded, &dwNeeded) )
          goto Cleanup;

      if ( dwNeeded == 0)
         goto Cleanup;

      // Add on the Skip Prefix
      lstrcat( szDir, SKIP_DIR );

      // Get System Time
      GetSystemTime( &SysTime );
      wsprintf( szMSecs, TEXT("%04X"), SysTime.wMilliseconds );

      lstrcat( szDir, szMSecs );
      gpszSkipDir = AllocStr( szDir );
      if (!gpszSkipDir )
         goto Cleanup;

      if (!CreateDirectory( gpszSkipDir, NULL ) )
         goto Cleanup;
   }

   bRet = TRUE;

Cleanup:

   if (!bRet)
   {
      if (gpszSkipDir)
      {
         LocalFreeMem( gpszSkipDir );
         gpszSkipDir = NULL;
      }
   }

   LeaveCriticalSection(&SkipCritSect);
   return bRet;
}


void
CleanupSkipDir(
    VOID
    )
{

   // We already have a skip dir created
   if ( gpszSkipDir )
   {
      RemoveDirectory( gpszSkipDir );
      LocalFreeMem( gpszSkipDir );
   }

   DeleteCriticalSection(&SkipCritSect);
}

BOOL
IsLocalAdmin(BOOL *pbAdmin)
/*++

Routine Description:
    This Routine determines if the user is a local admin.

Parameters:
    pbAdmin - Return Value, TRUE for local admin.

Return Value:
    TRUE             - Function succeded (return value is valid).

--*/ {
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL    bRet      = FALSE;
    PSID    pSIDAdmin = NULL;

    ASSERT( pbAdmin != NULL );  // Called locally

    *pbAdmin = FALSE;

    if (!AllocateAndInitializeSid( &SIDAuth, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &pSIDAdmin) )
        goto Cleanup;

    if (!CheckTokenMembership( NULL,
                               pSIDAdmin,
                               pbAdmin ) )
        goto Cleanup;

    bRet = TRUE;

Cleanup:

    if (pSIDAdmin != NULL) {
        FreeSid( pSIDAdmin );
    }

    return bRet;
}


BOOL
PruneInvalidFilesIfNotAdmin(
    IN     HWND                hWnd,
    IN OUT HSPFILEQ            CopyQueue
    )
/*++

Routine Description:
    This routine checks whether you have administrator privileges, if you do, then
    it does nothing and returns. If you do not, it scans the file queue for files
    that are already present and signed and prunes them from the queue. The commit
    will not allow mixing signed and unsigned files.
    Note: We do this because if you are a power-user the call to MoveFileEx fails inside
    SetupCommitFileQueue, this happens if the existing file cannot be overwritten. We
    could improve this routine by checking if a file is actually in use before pruning
    it.

Parameters:
    CopyQueue        - The copy queue to scan.

Return Value:
    TRUE             - Either you were an administrator and no action was taken, or
                       you were not and the FileQueue was successfully pruned.
    FALSE            - The operation failed.

--*/ {
    BOOL  bLocalAdmin;
    BOOL  bRet = FALSE;
    DWORD dwScanQueueResult;

    if (!IsLocalAdmin( &bLocalAdmin) )
        goto Cleanup;

    if (bLocalAdmin) {
        bRet = TRUE;
        goto Cleanup;
    }

    if (!SetupScanFileQueue( CopyQueue,
                             SPQ_SCAN_FILE_PRESENCE | SPQ_SCAN_PRUNE_COPY_QUEUE,
                             hWnd ,
                             NULL ,
                             NULL ,
                             &dwScanQueueResult ) )

        goto Cleanup;

   bRet = TRUE;

Cleanup:

    return bRet;
}

BOOL
AddDriverCatalogIfNotAdmin(
    IN     PCWSTR    pszServer,
    IN     HANDLE    hDriverSigningInfo,
    IN     PCWSTR    pszInfPath,
    IN     PCWSTR    pszSrcLoc,
    IN     DWORD     dwMediaType,
    IN     DWORD     dwCopyStyle
    )
/*++

Routine Description:
    
    This routine calls AddDriverCatalog for non-admin, aka power user.
    
Parameters:

    pszServer           - Name of the server
    hDriverSigningInfo  - Handle to driver signing info

Return Value:

    TRUE             - Either you are an administrator and no action was taken,
                       or you are not and the catalog was successfully added
    FALSE            - The operation failed. Call GetLastError() to get 
                       detailed error information

--*/ {
    BOOL                 bRet            = FALSE;
    BOOL                 bLocalAdmin     = TRUE;
    HANDLE               hPrinter        = NULL;
    PRINTER_DEFAULTS     PrinterDefaults = {0};
    DRIVER_INFCAT_INFO_1 DrvInfCatInfo1  = {0};
    DRIVER_INFCAT_INFO_2 DrvInfCatInfo2  = {0};
    PCWSTR               pszCatPath      = NULL;

    if (!hDriverSigningInfo ||
        !DrvSigningIsLocalAdmin(hDriverSigningInfo, &bLocalAdmin) || 
        !GetCatalogFile(hDriverSigningInfo, &pszCatPath))
    {
        goto Cleanup;
    }
    
    //
    // If there is no Cat file or we are local admin, there is nothing to do
    // because for local admin, we use setup api to install the catalog file
    //
    if (!pszCatPath || bLocalAdmin)
    {
        bRet = TRUE;
        goto Cleanup;
    }

    PrinterDefaults.DesiredAccess = SERVER_ALL_ACCESS;

    if (!OpenPrinterW((PWSTR) pszServer, &hPrinter, &PrinterDefaults)) 
    {
        goto Cleanup;
    }

    //
    // If there is a catalogfile entry in the inf file, we should call private
    // spooler API AddDriverCatalog with level 2 to install the catalog which
    // will install the inf and cat file by calling SetupCopyOEMInf. For inf 
    // files that do not have catalogfile entry we shall call AddDriverCatalog 
    // with level 1 which will install the catalog by using CryptoAPI
    //
    if (!IsCatInInf(hDriverSigningInfo))
    {
        DrvInfCatInfo1.pszCatPath = pszCatPath;

        if (!AddDriverCatalog(hPrinter, 1, &DrvInfCatInfo1, APDC_USE_ORIGINAL_CAT_NAME))
        {
            goto Cleanup;
        }
    }
    else
    {
        DrvInfCatInfo2.pszCatPath  = pszCatPath;
        DrvInfCatInfo2.pszInfPath  = pszInfPath;
        DrvInfCatInfo2.pszSrcLoc   = pszSrcLoc;
        DrvInfCatInfo2.dwMediaType = dwMediaType;
        DrvInfCatInfo2.dwCopyStyle = dwCopyStyle;

        if (!AddDriverCatalog(hPrinter, 2, &DrvInfCatInfo2, APDC_NONE))
        {
            goto Cleanup;
        }
    }
    
    bRet = TRUE;

Cleanup:

    if (hPrinter) 
    {
        ClosePrinter(hPrinter);
    }

    return bRet;
}

/*

Function: AddDirectoryTag

  pszDir - TCHAR string to add the two tags to.
  dwSize - size in CHARACTERs of the allocated string buffer.

Purpose - Takes the string pszDir and tags on "\dwPIDdwTID" on the end of it.
          This is used in the creation of a unique directory to copy the driver
          files for a specific install to.

*/
BOOL
AddDirectoryTag(
    IN LPTSTR pszDir,
    IN DWORD  dwSize )
{
    DWORD  dwDirSize,
           dwPID,
           dwTID;
    PTCHAR pEnd;

    if( !pszDir || !dwSize || !(dwDirSize = lstrlen( pszDir )) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    dwPID = GetCurrentProcessId();
    dwTID = GetCurrentThreadId();

    if( (pszDir[dwDirSize-1] != _TEXT('\\'))    &&
        (dwDirSize + 1 < dwSize) )
    {
        pszDir[dwDirSize++] = _TEXT('\\');
        pszDir[dwDirSize]   = 0;
    }

    pEnd = &pszDir[dwDirSize];

    _sntprintf( pEnd,
                (dwSize-dwDirSize),
                _TEXT("%d%d"),
                dwPID,
                dwTID );

    return TRUE;
}

/*

Function: AddPnpDirTag

  pszDir - TCHAR string to add the tag to.
  dwSize - size in CHARACTERs of the allocated string buffer.

Purpose - Takes the string pszDir and tags on the pnp-ID on to it.
          This is used in the creation of a unique directory to copy the driver
          files for a specific install to.

*/
BOOL
AddPnpDirTag(
    IN LPTSTR     pszHardwareId,
    IN OUT LPTSTR pszDir,
    IN DWORD      dwSize )
{
    DWORD  dwDirSize;
    PTCHAR pEnd, pPnpId;

    if( !pszHardwareId  || 
        !pszDir         || 
        !dwSize         || 
        !(dwDirSize = lstrlen( pszDir )) ||
        dwSize < dwDirSize + 3 ) // need at least space for backslash, one char + 0 terminator
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( (pszDir[dwDirSize-1] != _TEXT('\\')))
    {
        pszDir[dwDirSize++] = _TEXT('\\');
        pszDir[dwDirSize]   = 0;
    }

    pEnd = &pszDir[dwDirSize];

    //
    // Try to strip off the port enumerator, if applicable. The printer driver
    // should be independent of it.
    //
    if ((pPnpId = _tcsrchr(pszHardwareId, _TEXT('\\'))) == NULL)
    {
        // 
        // it doesn't have a port enumerator, so the whole thing is the pnp ID
        //
        pPnpId = pszHardwareId;
    }
    else
    {
        //
        // found one: advance one beyond it if it's not the last character
        // to illustrate LPTENUM\abcd would become \abcd instead of abcd
        //
        if (*(pPnpId+1))
        {
            pPnpId++;
        }
    }
    _tcsncpy(pEnd, pPnpId, dwSize - dwDirSize - 1);
    
    //
    // make sure the string is zero-terminated, so a pnp-ID that's too long doesn't result
    // in a runaway string.
    //
    pszDir[dwSize - 1] = 0; 

    //
    // change all suspicious characters to underscores to avoid problems with / & \ etc.
    // all the distinguishing information should be in the alphanumerical characters
    //
    while (*pEnd)
    {
        if (!_istalnum(*pEnd))
        {
            *pEnd = _TEXT('_');
        }
        pEnd++;
    }

    return TRUE;
}

/*

Function:  AddDirToDriverInfo

  pszDir       - Directory to append to driver info structure.
  pDriverInfo6 - Pointer to the driver info structure to update.

Purpose: This function will ensure that there is no directory structure specified in the
         driver info structure yet (so as not to add it multiple times).
         If there isn't then it will update the driver file entries with the full path
         passed in in pszDir.

*/
BOOL
AddDirToDriverInfo(
    IN LPTSTR          pszDir,
    IN LPDRIVER_INFO_6 pDriverInfo6
    )
{
    PTCHAR pOldString,
           pCurrentString,
           pNewString;
    DWORD  dwLength,
           dwDirLength,
           dwNeeded = 0;

    if( !pszDir || !pDriverInfo6 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  If the path is zero length, nothing to do.
    //
    if( !(dwDirLength = lstrlen( pszDir )) )
        return TRUE;

    if( pDriverInfo6->pDriverPath &&
        FileNamePart( pDriverInfo6->pDriverPath ) == pDriverInfo6->pDriverPath )
    {
        pOldString = pDriverInfo6->pDriverPath;

        pDriverInfo6->pDriverPath = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
    }

    if( pDriverInfo6->pDataFile &&
        FileNamePart( pDriverInfo6->pDataFile ) == pDriverInfo6->pDataFile )
    {
        pOldString = pDriverInfo6->pDataFile;

        pDriverInfo6->pDataFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
    }

    if( pDriverInfo6->pConfigFile &&
        FileNamePart( pDriverInfo6->pConfigFile ) == pDriverInfo6->pConfigFile )
    {
        pOldString = pDriverInfo6->pConfigFile;

        pDriverInfo6->pConfigFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
    }

    if( pDriverInfo6->pHelpFile &&
        FileNamePart( pDriverInfo6->pHelpFile ) == pDriverInfo6->pHelpFile )
    {
        pOldString = pDriverInfo6->pHelpFile;

        pDriverInfo6->pHelpFile = AllocAndCatStr2( pszDir, _TEXT("\\"), pOldString );

        LocalFreeMem( pOldString );
    }

    if( pDriverInfo6->pDependentFiles )
    {
        pCurrentString = pDriverInfo6->pDependentFiles;

        while( *pCurrentString )
        {
            dwLength = lstrlen( pCurrentString );
            if( pCurrentString == FileNamePart( pCurrentString ) )
            {
                //
                // Amount needed - the two lengths + \ + 0
                //
                dwNeeded += dwLength + dwDirLength + 1 + 1;
            }
            else
            {
                //
                // Amount needed - the existing + 0
                //
                dwNeeded += dwLength + 1;
            }

            pCurrentString += dwLength + 1;
        }

        //
        // Increment for the final 0
        //
        dwNeeded++;

        if(pNewString = LocalAllocMem( dwNeeded*sizeof(TCHAR) ))
        {
            pCurrentString = pNewString;

            pOldString = pDriverInfo6->pDependentFiles;

            while( *pOldString )
            {
                if( pOldString == FileNamePart( pOldString ) )
                {
                    //
                    //  Add the directory info.
                    //
                    lstrcpy( pCurrentString, pszDir );
                    pCurrentString += dwDirLength;
                    *pCurrentString++ = _TEXT('\\');
                }

                //
                // Add the existing file info.
                //
                lstrcpy( pCurrentString, pOldString );

                pCurrentString += lstrlen( pOldString );
                *pCurrentString++ = 0;
                pOldString += lstrlen( pOldString ) + 1;
            }
            *pCurrentString = 0;

            LocalFreeMem( pDriverInfo6->pDependentFiles );

            pDriverInfo6->pDependentFiles = pNewString;

        }
    }

    return TRUE;
}


BOOL
IsSystemUpgradeInProgress(
    VOID
    )
/*++

Routine Description:
    Tells if we are in the middle of system setup

Arguments:
    None

Return Value:
    TRUE if system setup in progress, FALSE else

--*/
{
    HKEY    hKey = NULL;
    DWORD   dwValue = 0, dwSize;

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       cszSystemSetupKey,
                                       0,
                                       KEY_READ,
                                       &hKey) ) {

        dwSize = sizeof(dwValue);
        if( ERROR_SUCCESS != RegQueryValueEx(hKey, cszSystemUpgradeValue, NULL, NULL,
                                             (LPBYTE)&dwValue, &dwSize) ) {
            dwValue = 0;
        }

        RegCloseKey(hKey);
    }

    return dwValue == 1;
}

BOOL
IsSystemSetupInProgress(
        VOID
        )
/*++

Routine Description:
    Tells if we are in the middle of system setup (GUI mode)

Arguments:
    None

Return Value:
    TRUE if system setup in progress, FALSE else

--*/
{
    HKEY    hKey = NULL;
    DWORD   dwValue = 0, dwSize;

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       cszSystemSetupKey,
                                       0,
                                       KEY_READ,
                                       &hKey) ) {

        dwSize = sizeof(dwValue);
        if( ERROR_SUCCESS != RegQueryValueEx(hKey, cszSystemSetupInProgress, NULL, NULL,
                                             (LPBYTE)&dwValue, &dwSize) ) {
            dwValue = 0;
        }
        RegCloseKey(hKey);
    }

    return dwValue == 1;
}

/*

Function: GetMyTempDir

Purpose:  Creates a unique temporary directory off the TEMP directory.
          This gets called by UnCompressCat to create a unique directory to store the cat
          file that is to be expanded in.

Returns:  NULL if failed.  The full qualified path to the new directory otherwise.

Note:     The returned string does contain the ending '\'.

*/
LPTSTR
GetMyTempDir()
{
    LPTSTR pszPath      = NULL;
    PTCHAR pEnd;
    DWORD  dwSize       = 0;
    DWORD  dwActualSize = 0;
    DWORD  dwThreadID   = GetCurrentThreadId();
    DWORD  dwProcessID  = GetCurrentProcessId();
    DWORD  dwIDCounter  = dwThreadID;
    BOOL   bContinue    = TRUE;

    dwSize = GetTempPath( 0, pszPath );
    //
    // dwSize + size of the two DWORDs + \ + 0
    //
    dwActualSize = dwSize+MAX_DWORD_LENGTH*2+2;

    if( dwSize &&
        NULL != (pszPath = (LPTSTR)LocalAllocMem(dwActualSize*sizeof(TCHAR))))
    {
        //
        // If this fails, then we assume that someone is playing with the temp path at the instant that
        // we are requesting it - unlikely so just fail (worst effect = probably leads to driver signing warning)
        //
        if( dwSize >= GetTempPath( dwSize, pszPath ))
        {
            dwSize = lstrlen(pszPath);

            pEnd = &pszPath[lstrlen(pszPath)];

            do
            {
                _sntprintf( pEnd, dwActualSize-dwSize, _TEXT("%d%d%s"),
                            dwProcessID, dwIDCounter, _TEXT("\\") );

                if(CreateDirectory( pszPath, NULL ) || GetLastError() == ERROR_FILE_EXISTS)
                {
                    //
                    // We've got a directory, so drop out of loop.
                    //
                    bContinue = FALSE;
                }
                dwIDCounter++;

            //
            // Will stop loop when we have an unused directory or we loop round on the dwIDCounter
            //
            } while (bContinue && dwIDCounter != dwThreadID);

            if(bContinue)
            {
                LocalFreeMem( pszPath );
                pszPath = NULL;
            }
        }
        else
        {
            LocalFreeMem( pszPath );
            pszPath = NULL;
        }
    }

    return pszPath;
}

BOOL
GetOSVersion(
    IN     LPCTSTR        pszServerName,
    OUT    POSVERSIONINFO pOSVer
    )
{
    BOOL bRet = FALSE;

    if(pOSVer)
    {
        ZeroMemory(pOSVer,sizeof(OSVERSIONINFO));
        pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if(!pszServerName || !*pszServerName)
        {
            bRet = GetVersionEx(pOSVer);
        }
        else
        {
            HANDLE hServer      = NULL;
            DWORD dwNeeded      = 0;
            DWORD dwType        = REG_BINARY;
            PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            if( OpenPrinter( (LPTSTR) pszServerName, &hServer, &Defaults ) )
            {
                //
                // Get the os version from the remote spooler.
                //
                if( ERROR_SUCCESS == ( GetPrinterData( hServer,
                                                       SPLREG_OS_VERSION,
                                                       &dwType,
                                                       (PBYTE)pOSVer,
                                                       sizeof( OSVERSIONINFO ),
                                                       &dwNeeded ) ) )
                {
                    bRet = TRUE;
                }
                else
                {
                    //
                    // Assume that we're on NT4 as it doesn't support SPLREG_OS_VERSION
                    // at it's the only OS that doesn't that could land up in this remote code path.
                    //
                    ZeroMemory(pOSVer, sizeof(OSVERSIONINFO));

                    pOSVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                    pOSVer->dwMajorVersion      = 4;
                    pOSVer->dwMinorVersion      = 0;

                    bRet = TRUE;
                }

                ClosePrinter( hServer );
            }
        }
    }

    return bRet;
}

BOOL
GetOSVersionEx(
    IN     LPCTSTR          pszServerName,
    OUT    POSVERSIONINFOEX pOSVerEx
    )
{
    BOOL bRet = FALSE;

    if(pOSVerEx)
    {
        ZeroMemory(pOSVerEx,sizeof(OSVERSIONINFOEX));
        pOSVerEx->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        if(!pszServerName || !*pszServerName)
        {
            bRet = GetVersionEx((POSVERSIONINFO) pOSVerEx);
        }
        else
        {
            HANDLE hServer      = NULL;
            DWORD dwNeeded      = 0;
            DWORD dwType        = REG_BINARY;
            PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            if( OpenPrinter( (LPTSTR) pszServerName, &hServer, &Defaults ) )
            {
                //
                // Get the os version from the remote spooler.
                //
                if( ERROR_SUCCESS == ( GetPrinterData( hServer,
                                                       SPLREG_OS_VERSIONEX,
                                                       &dwType,
                                                       (PBYTE)pOSVerEx,
                                                       sizeof( OSVERSIONINFOEX ),
                                                       &dwNeeded ) ) )
                {
                    bRet = TRUE;
                }
                else
                {
                    //
                    // Assume that we're on NT4 as it doesn't support SPLREG_OS_VERSION
                    // at it's the only OS that doesn't that could land up in this remote code path.
                    //
                    ZeroMemory(pOSVerEx, sizeof(OSVERSIONINFOEX));

                    pOSVerEx->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                    pOSVerEx->dwMajorVersion      = 4;
                    pOSVerEx->dwMinorVersion      = 0;

                    bRet = TRUE;
                }

                ClosePrinter( hServer );
            }
        }
    }

    return bRet;
}

BOOL
GetArchitecture(
    IN     LPCTSTR   pszServerName,
    OUT    LPTSTR    pszArch,
    IN OUT LPDWORD   pcArchSize
    )
/*++

Routine Description:
    Obtains the local or remote server's architecture.

Arguments:
    pszServerName - NULL = local machine.
    pszArch       - will hold the machine's architecture.
    cArchSize     - IN  - size of pszArch in characters.
                    OUT - character count that was filled.
                          If failure is ERROR_MORE_DATA it will hold the needed character count.

Return Value:
    TRUE on success.

--*/
{
    BOOL  bRet        = FALSE;
    DWORD dwByteCount = 0;
    DWORD cLen        = 0;

    if( !pszArch )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }
    else
    {
        *pszArch = 0;

        if( !pszServerName || !*pszServerName )
        {
            cLen = _tcslen(PlatformEnv[MyPlatform].pszName);

            if( cLen <= *pcArchSize )
            {
                _tcsncpy( pszArch, PlatformEnv[MyPlatform].pszName, *pcArchSize );

                bRet = TRUE;
            }

            *pcArchSize = cLen;
        }
        else
        {
            HANDLE hServer  = NULL;
            DWORD dwNeeded  = 0;
            DWORD dwType    = REG_SZ;
            PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_READ };

            //
            // Open the server for read access.
            //
            if( OpenPrinter( (LPTSTR) pszServerName, &hServer, &Defaults ) ) 
            {
                dwByteCount = *pcArchSize * sizeof( TCHAR );

                //
                // Get the os version from the remote spooler.
                //
                if(ERROR_SUCCESS == GetPrinterData(hServer,
                                                   SPLREG_ARCHITECTURE,
                                                   &dwType,
                                                   (PBYTE)pszArch,
                                                   dwByteCount,
                                                   &dwNeeded))
                {
                    bRet = TRUE;
                }
                else
                {
                    *pszArch = 0;
                }

                *pcArchSize = dwNeeded / sizeof(TCHAR);

                ClosePrinter( hServer );
            }
        }
    }

    return bRet;
}

BOOL IsInWow64()
//
// find out whether we're running in WOW64
//
{
    BOOL      bRet = FALSE;
    ULONG_PTR ul;
    NTSTATUS  st;


    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);
    if (NT_SUCCESS(st))
    {
        //
        // If this call succeeds, we're on Win2000 or newer machines.
        //
        if (0 != ul)
        {
            //
            // 32-bit code running on Win64
            //
            bRet = TRUE;
        }
    }

    return bRet;
}


BOOL
IsWhistlerOrAbove(
    IN LPCTSTR pszServerName
    )
/*++

Routine Description:
    Determines whether the machine identified by ServerName is at least OS version 5.1

Arguments:
    pszServerName - the name of the remote server.  NULL means local machine.

Return Value:
    TRUE if the remote server is whistler or more recent server or local
    FALSE else

--*/

{
    OSVERSIONINFO OsVer = {0};
    BOOL bRet = FALSE;
    
    if (!pszServerName)
    {
        bRet = TRUE;
    }
    else if (GetOSVersion(pszServerName,&OsVer))
    {
        if( (OsVer.dwMajorVersion > 5) ||
            (OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion > 0) )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}


HRESULT
IsProductType(
    IN BYTE ProductType,
    IN BYTE Comparison
    )
/*++

Routine Description:
    Determines whether the version of the OS is personal, professional or server 
    depending on the given ProductType and Comparison

Arguments:
    ProductType - VER_NT_WORKSTATION or VER_NT_SERVER
    Comaprison  - VER_EQUAL, VER_GREATER, VER_GREATER_EQUAL, VER_LESS, VER_LESS_EQUAL
    
Return Value:
    S_OK if the OS version if the OS satisfies the given conditions
    S_FALSE else

--*/
{
    HRESULT             hRetval          = S_FALSE;
    OSVERSIONINFOEX     OsVerEx          = {0};
    ULONGLONG           dwlConditionMask = 0;

    OsVerEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVerEx.wProductType = ProductType;

    VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE, Comparison );

    if (VerifyVersionInfo(&OsVerEx, VER_PRODUCT_TYPE, dwlConditionMask))
    {
        hRetval = S_OK;
    }

    return hRetval;
}


HMODULE LoadLibraryUsingFullPath(
    LPCTSTR lpFileName
    )
{
    TCHAR szSystemPath[MAX_PATH];
    INT   cLength         = 0;
    INT   cFileNameLength = 0;


    if (!lpFileName || ((cFileNameLength = lstrlen(lpFileName)) == 0)) 
    {
        return NULL;
    }
    if (GetSystemDirectory(szSystemPath, SIZECHARS(szSystemPath) ) == 0)
    {
        return NULL;
    }
    cLength = lstrlen(szSystemPath);
    if (szSystemPath[cLength-1] != TEXT('\\'))
    {
        if ((cLength + 1) >= MAX_PATH)
        {
            return NULL;
        }
        szSystemPath[cLength]     = TEXT('\\');
        szSystemPath[cLength + 1] = TEXT('\0');
        cLength++;
    }
    if ((cLength + cFileNameLength) >= MAX_PATH)
    {
        return NULL;
    }
    lstrcat(szSystemPath, lpFileName);

    return LoadLibrary( szSystemPath );
}

BOOL
IsSpoolerRunning(
    VOID
    )
{
    HANDLE ph;
    BOOL IsRunning = FALSE;

    if (OpenPrinter(NULL, &ph, NULL))
    {
        IsRunning = TRUE;    
        ClosePrinter(ph);
    }

    return IsRunning;
}

BOOL
CheckAndKeepPreviousNames(
    IN  LPCTSTR          pszServer,
    IN  PDRIVER_INFO_6   pDriverInfo6,
    IN  PLATFORM         platform
)
{
    DWORD            dwNeeded         = 0;
    DWORD            dwReturned       = 0;
    DWORD            dwIndex          = 0;
    LPDRIVER_INFO_4  pCurDriverInfo   = NULL;
    BOOL             bRet             = FALSE;
    INT              cPrevNamesLength = 0;

    PLATFORM         Platform2Enumerate = pszServer ? platform : MyPlatform;

    if (pDriverInfo6 && pDriverInfo6->pName && 
        (*(pDriverInfo6->pName) == TEXT('\0')) )
    {
        goto Cleanup;
    }
    if ( !EnumPrinterDrivers((LPTSTR)pszServer,
                             PlatformEnv[Platform2Enumerate].pszName,
                             4,
                             (LPBYTE)pCurDriverInfo,
                             0,
                             &dwNeeded,
                             &dwReturned) ) 
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER        ||
             !(pCurDriverInfo = LocalAllocMem(dwNeeded))        ||
             !EnumPrinterDrivers((LPTSTR)pszServer,
                                 PlatformEnv[Platform2Enumerate].pszName,
                                 4,
                                 (LPBYTE)pCurDriverInfo,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned)                   ||
             (dwReturned <= 0)) 
        {
            goto Cleanup;
        }
    }
    for (dwIndex = 0; dwIndex < dwReturned; dwIndex++) 
    {
        if ((pCurDriverInfo+dwIndex)->pName &&
            (*(pCurDriverInfo+dwIndex)->pName != TEXT('\0')) &&
            !lstrcmp(pDriverInfo6->pName,(pCurDriverInfo+dwIndex)->pName) )
        {
            if ((pCurDriverInfo+dwIndex)->pszzPreviousNames &&
                (*(pCurDriverInfo+dwIndex)->pszzPreviousNames != TEXT('\0')))
            {
                cPrevNamesLength = lstrlen((pCurDriverInfo+dwIndex)->pszzPreviousNames);
                pDriverInfo6->pszzPreviousNames = (LPTSTR)LocalAllocMem( (cPrevNamesLength + 2) * sizeof(TCHAR) );
                if (pDriverInfo6->pszzPreviousNames) 
                {
                    bRet = TRUE;
                    CopyMemory( pDriverInfo6->pszzPreviousNames, (pCurDriverInfo+dwIndex)->pszzPreviousNames, cPrevNamesLength * sizeof(TCHAR) );
                    *(pDriverInfo6->pszzPreviousNames + cPrevNamesLength)     = TEXT('\0');
                    *(pDriverInfo6->pszzPreviousNames + cPrevNamesLength + 1) = TEXT('\0');
                }
                else
                {
                    bRet = FALSE;
                }
                goto Cleanup;
            }
        }
    }

Cleanup:

    if (pCurDriverInfo) 
    {
        LocalFreeMem(pCurDriverInfo);
    }
    return bRet;
}

BOOL
IsTheSamePlatform(
    IN LPCTSTR           pszServer,
    IN PLATFORM          platform

)
{
    BOOL  bRet                    = FALSE;
    DWORD dwServerArchSize        = 0;
    DWORD dwServerArchSizeInChars = 0;
    TCHAR *pszServerArchitecture  = NULL;

    if (!pszServer) 
    {
        bRet = TRUE;
        goto Cleanup;
    }
    dwServerArchSizeInChars = lstrlen( PlatformEnv[platform].pszName ) + 1;
    dwServerArchSize        = dwServerArchSizeInChars * sizeof(TCHAR);
    pszServerArchitecture   = LocalAllocMem(dwServerArchSize);
    if (!pszServerArchitecture ||
        !GetArchitecture(pszServer, pszServerArchitecture, &dwServerArchSizeInChars )) 
    {
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = !lstrcmp( pszServerArchitecture, PlatformEnv[platform].pszName );

Cleanup:

    if (pszServerArchitecture) 
    {
        LocalFreeMem( pszServerArchitecture );
    }
    return bRet;
}


LPTSTR 
GetArchitectureName(
    IN     LPCTSTR   pszServerName
)
{
    LPTSTR   pszArch    = NULL;
    DWORD    dwArchSize = 80;

    if (pszServerName && (*pszServerName == TEXT('\0')))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    if (!pszServerName) 
    {
        return AllocStr( PlatformEnv[MyPlatform].pszName );
    }
    pszArch = LocalAllocMem( dwArchSize * sizeof(TCHAR));
    if (!pszArch) 
    {
        return NULL;
    }

    if (!GetArchitecture( pszServerName, pszArch, &dwArchSize))
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            LocalFreeMem( pszArch );
            dwArchSize += 1;
            pszArch = LocalAllocMem( dwArchSize * sizeof(TCHAR) );
            if (!pszArch ||
                !GetArchitecture( pszServerName, pszArch, &dwArchSize)) 
            {
                return NULL;
            }
        }
    }
    return pszArch;
}

/************************************************************************************
** End of File (util.c)
************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\utildi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Utildi.c

Abstract:

    Driver Setup DeviceInstaller Utility functions

Author:

    Muhunthan Sivapragasam (MuhuntS) 06-Sep-1995

Revision History:

--*/

#include "precomp.h"

static  const   GUID    GUID_DEVCLASS_PRINTER   =
    { 0x4d36e979L, 0xe325, 0x11ce,
        { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };


#if 0
TCHAR   cszOEMInfGen[]                  = TEXT("%s\\inf\\OEM%d.INF");
TCHAR   cszInfGen[]                     = TEXT("%s\\inf\\%s");
TCHAR   cszClass[]                      = TEXT("Class");
TCHAR   cszProvider[]                   = TEXT("Provider");
TCHAR   cszPNF[]                        = TEXT ("PNF");
TCHAR   cszINF[]                        = TEXT ("\\INF\\");
TCHAR   cszInfWildCard[]                = TEXT ("*.inf");
#endif

extern  TCHAR   cszPrinter[];

LPTSTR
GetInfQueryString(
    IN  PSP_INF_INFORMATION  pSpInfInfo,
    IN  LPCTSTR              pszKey
)
/*++

Routine Description:
    Gets a specified string in a INF info list and put it into allocated memory

Arguments:
    pSpInfInfo  : Pointer to Handle to the information of an INF file
    pszKey      : Key of the string to be queried

Return Value:
    The allocated string on success
    NULL else

--*/
{
    DWORD                   dwNeeded = 128;
    LPTSTR                  pszStr;

    if (! (pszStr = LocalAllocMem (dwNeeded * sizeof (*pszStr))))
        return NULL;

    if (SetupQueryInfVersionInformation(pSpInfInfo, 0, pszKey, pszStr,
                                         dwNeeded, &dwNeeded)) {
        return pszStr;
    }
    else {
        LocalFreeMem (pszStr);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER ) return NULL;

        // Allocate Memory
        if (! (pszStr = LocalAllocMem (dwNeeded * sizeof (*pszStr))))
            return NULL;

        if (!SetupQueryInfVersionInformation(pSpInfInfo, 0, pszKey, pszStr,
                                         dwNeeded, &dwNeeded)){
            LocalFreeMem (pszStr);
            return NULL;
        }
        else
            return pszStr;
    }
}

BOOL
SetSelectDevParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  BOOL                bWin95,
    IN  LPCTSTR             pszModel    OPTIONAL
    )
/*++

Routine Description:
    Sets the select device parameters by calling setup apis

Arguments:
    hDevInfo    : Handle to the printer class device information list
    bWin95      : TRUE if selecting Win95 driver, else WinNT driver
    pszModel    : Printer model we are looking for -- only for Win95 case

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams;
    LPTSTR                  pszWin95Instn;

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
    SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we want to be different from default
    //
    if ( !SetupDiGetClassInstallParams(
                        hDevInfo,
                        pDevInfoData,
                        &SelectDevParams.ClassInstallHeader,
                        sizeof(SelectDevParams),
                        NULL) ) {

        if ( GetLastError() != ERROR_NO_CLASSINSTALL_PARAMS )
            return FALSE;

        ZeroMemory(&SelectDevParams, sizeof(SelectDevParams));  // NEEDED 10/11 ?
        SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
        SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;
    }

    //
    // Set the strings to use on the select driver page ..
    //
    LoadString(ghInst,
               IDS_PRINTERWIZARD,
               SelectDevParams.Title,
               SIZECHARS(SelectDevParams.Title));

    //
    // For Win95 drivers instructions are different than NT drivers
    //
    if ( bWin95 ) {

        pszWin95Instn = GetStringFromRcFile(IDS_WIN95DEV_INSTRUCT);
        if ( !pszWin95Instn )
            return FALSE;

        if ( lstrlen(pszWin95Instn) + lstrlen(pszModel) + 1
                            > sizeof(SelectDevParams.Instructions) ) {

            LocalFreeMem(pszWin95Instn);
            return FALSE;
        }

        wsprintf(SelectDevParams.Instructions, pszWin95Instn, pszModel);
        LocalFreeMem(pszWin95Instn);
    } else {

        LoadString(ghInst,
                   IDS_WINNTDEV_INSTRUCT,
                   SelectDevParams.Instructions,
                   SIZECHARS(SelectDevParams.Instructions));
    }

    LoadString(ghInst,
               IDS_SELECTDEV_LABEL,
               SelectDevParams.ListLabel,
               SIZECHARS(SelectDevParams.ListLabel));

    return SetupDiSetClassInstallParams(
                                hDevInfo,
                                pDevInfoData,
                                &SelectDevParams.ClassInstallHeader,
                                sizeof(SelectDevParams));

}


BOOL
PSetupSetSelectDevTitleAndInstructions(
    HDEVINFO    hDevInfo,
    LPCTSTR     pszTitle,
    LPCTSTR     pszSubTitle,
    LPCTSTR     pszInstn
    )
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams;

    if ( pszTitle && lstrlen(pszTitle) + 1 > MAX_TITLE_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszSubTitle && lstrlen(pszSubTitle) + 1 > MAX_SUBTITLE_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszInstn && lstrlen(pszInstn) + 1 > MAX_INSTRUCTION_LEN ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);
    SelectDevParams.ClassInstallHeader.InstallFunction
                                 = DIF_SELECTDEVICE;

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       NULL,
                                       &SelectDevParams.ClassInstallHeader,
                                       sizeof(SelectDevParams),
                                       NULL) )
        return FALSE;

    if ( pszTitle )
        lstrcpy(SelectDevParams.Title, pszTitle);

    if ( pszSubTitle )
        lstrcpy(SelectDevParams.SubTitle, pszSubTitle);

    if ( pszInstn )
        lstrcpy(SelectDevParams.Instructions, pszInstn);

    return SetupDiSetClassInstallParams(
                                hDevInfo,
                                NULL,
                                &SelectDevParams.ClassInstallHeader,
                                sizeof(SelectDevParams));

}

BOOL
PSetupSelectDeviceButtons(
   HDEVINFO hDevInfo,
   DWORD dwFlagsSet,
   DWORD dwFlagsClear
   )
{
    PSP_DEVINFO_DATA       pDevInfoData = NULL;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    // Check that no flags are both set & cleared
    if (dwFlagsSet & dwFlagsClear)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    //
    // Set Flag based on Argument for Web Button
    if ( dwFlagsSet & SELECT_DEVICE_FROMWEB )
       DevInstallParams.FlagsEx   |= DI_FLAGSEX_SHOWWINDOWSUPDATE;

    if ( dwFlagsClear & SELECT_DEVICE_FROMWEB )
       DevInstallParams.FlagsEx   &= ~DI_FLAGSEX_SHOWWINDOWSUPDATE;

    if ( dwFlagsSet & SELECT_DEVICE_HAVEDISK )
       DevInstallParams.Flags     |= DI_SHOWOEM;

    if ( dwFlagsClear & SELECT_DEVICE_HAVEDISK )
       DevInstallParams.Flags     &= ~DI_SHOWOEM;

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         pDevInfoData,
                                         &DevInstallParams);
}

BOOL
SetDevInstallParams(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData,
    IN  LPCTSTR             pszDriverPath   OPTIONAL
    )
/*++

Routine Description:
    Sets the device installation parameters by calling setup apis

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszDriverPath   : Path where INF file should be searched

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pDevInfoData,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    //
    // Drivers are class drivers,
    // ntprint.inf is sorted do not waste time sorting,
    // show Have Disk button,
    // use our strings on the select driver page
    //
    DevInstallParams.Flags     |= DI_SHOWCLASS | DI_INF_IS_SORTED
                                               | DI_SHOWOEM
                                               | DI_USECI_SELECTSTRINGS;

    if ( pszDriverPath && *pszDriverPath )
        lstrcpy(DevInstallParams.DriverPath, pszDriverPath);

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         pDevInfoData,
                                         &DevInstallParams);
}


BOOL
PSetupBuildDriversFromPath(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszDriverPath,
    IN  BOOL        bEnumSingleInf
    )
/*++

Routine Description:
    Builds the list of printer drivers from infs from a specified path.
    Path could specify a directory or a single inf.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszDriverPath   : Path where INF file should be searched
    bEnumSingleInf  : If TRUE pszDriverPath is a filename instead of path

Return Value:
    TRUE on success
    FALSE else

--*/
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Get current SelectDevice parameters, and then set the fields
    // we wanted changed from default
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        NULL,
                                        &DevInstallParams) ) {

        return FALSE;
    }

    DevInstallParams.Flags  |= DI_INF_IS_SORTED;

    if ( bEnumSingleInf )
        DevInstallParams.Flags  |= DI_ENUMSINGLEINF;

    lstrcpy(DevInstallParams.DriverPath, pszDriverPath);

    SetupDiDestroyDriverInfoList(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER);

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams) &&
           SetupDiBuildDriverInfoList(hDevInfo, NULL, SPDIT_CLASSDRIVER);
}


BOOL
DestroyOnlyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    This routine should be called at the end to destroy the printer device
    info list

Arguments:
    hDevInfo        : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{

    return hDevInfo == INVALID_HANDLE_VALUE
                        ? TRUE : SetupDiDestroyDeviceInfoList(hDevInfo);
}


BOOL
PSetupDestroyPrinterDeviceInfoList(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    This routine should be called at the end to destroy the printer device
    info list

Arguments:
    hDevInfo        : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{
    // Cleanup and CDM Context  created by windows update.
    DestroyCodedownload( gpCodeDownLoadInfo );
    gpCodeDownLoadInfo = NULL;

    return DestroyOnlyPrinterDeviceInfoList(hDevInfo);
}


HDEVINFO
CreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    )
{
    return SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER, hwnd);
}


HDEVINFO
PSetupCreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    )
/*++

Routine Description:
    This routine should be called at the beginning to do the initialization
    It returns a handle which will be used on any subsequent calls to the
    driver setup routines.

Arguments:
    None

Return Value:
    On success a handle to an empty printer device information set.

    If the function fails INVALID_HANDLE_VALUE is returned

--*/
{
    HDEVINFO    hDevInfo;

    hDevInfo = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER, hwnd);

    if ( hDevInfo != INVALID_HANDLE_VALUE ) {

        if ( !SetSelectDevParams(hDevInfo, NULL, FALSE, NULL) ||
             !SetDevInstallParams(hDevInfo, NULL, NULL) ) {

            DestroyOnlyPrinterDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }
    }

    return hDevInfo;
}


HPROPSHEETPAGE
PSetupCreateDrvSetupPage(
    IN  HDEVINFO    hDevInfo,
    IN  HWND        hwnd
    )
/*++

Routine Description:
    Returns the print driver selection property page

Arguments:
    hDevInfo    : Handle to the printer class device information list
    hwnd        : Window handle that owns the UI

Return Value:
    Handle to the property page, NULL on failure -- use GetLastError()

--*/
{
    SP_INSTALLWIZARD_DATA   InstallWizardData;

    ZeroMemory(&InstallWizardData, sizeof(InstallWizardData));
    InstallWizardData.ClassInstallHeader.cbSize
                            = sizeof(InstallWizardData.ClassInstallHeader);
    InstallWizardData.ClassInstallHeader.InstallFunction
                            = DIF_INSTALLWIZARD;

    InstallWizardData.DynamicPageFlags  = DYNAWIZ_FLAG_PAGESADDED;
    InstallWizardData.hwndWizardDlg     = hwnd;

    return SetupDiGetWizardPage(hDevInfo,
                                NULL,
                                &InstallWizardData,
                                SPWPT_SELECTDEVICE,
                                0);
}
PPSETUP_LOCAL_DATA
BuildInternalData(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pSpDevInfoData
    )
/*++

Routine Description:
    Fills out the selected driver info in the SELECTED_DRV_INFO structure

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pSpDevInfoData  : Gives the selected device info element.

Return Value:
    On success a non-NULL pointer to PSETUP_LOCAL_DATA struct
    NULL on error

--*/
{
    PSP_DRVINFO_DETAIL_DATA     pDrvInfoDetailData;
    PSP_DRVINSTALL_PARAMS       pDrvInstallParams;
    PPSETUP_LOCAL_DATA          pLocalData;
    PSELECTED_DRV_INFO          pDrvInfo;
    SP_DRVINFO_DATA             DrvInfoData;
    DWORD                       dwNeeded;
    BOOL                        bRet = FALSE;

    pLocalData          = (PPSETUP_LOCAL_DATA) LocalAllocMem(sizeof(*pLocalData));
    pDrvInfoDetailData  = (PSP_DRVINFO_DETAIL_DATA)
                                LocalAllocMem(sizeof(*pDrvInfoDetailData));
    pDrvInstallParams   = (PSP_DRVINSTALL_PARAMS) LocalAllocMem(sizeof(*pDrvInstallParams));

    if ( !pLocalData || !pDrvInstallParams || !pDrvInfoDetailData )
        goto Cleanup;

    pDrvInfo                            = &pLocalData->DrvInfo;
    pLocalData->DrvInfo.pDevInfoData    = pSpDevInfoData;
    pLocalData->signature               = PSETUP_SIGNATURE;

    DrvInfoData.cbSize = sizeof(DrvInfoData);
    if ( !SetupDiGetSelectedDriver(hDevInfo, pSpDevInfoData, &DrvInfoData) )
        goto Cleanup;

    // Need to Check the flag in the DrvInstallParms
    pDrvInstallParams->cbSize     = sizeof(*pDrvInstallParams);
    if ( !SetupDiGetDriverInstallParams(hDevInfo,
                                        pSpDevInfoData,
                                        &DrvInfoData,
                                        pDrvInstallParams) ) {

        goto Cleanup;
    }

    //
    // Did the user press the "Web" button
    //
    if ( pDrvInstallParams->Flags & DNF_INET_DRIVER )
        pDrvInfo->Flags     |= SDFLAG_CDM_DRIVER;

    LocalFreeMem(pDrvInstallParams);
    pDrvInstallParams = NULL;

    dwNeeded                    = sizeof(*pDrvInfoDetailData);
    pDrvInfoDetailData->cbSize  = dwNeeded;

    if ( !SetupDiGetDriverInfoDetail(hDevInfo,
                                     pSpDevInfoData,
                                     &DrvInfoData,
                                     pDrvInfoDetailData,
                                     dwNeeded,
                                     &dwNeeded) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

            goto Cleanup;
        }

        LocalFreeMem(pDrvInfoDetailData);
        pDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA) LocalAllocMem(dwNeeded);

        if ( !pDrvInfoDetailData )
            goto Cleanup;

        pDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        if ( !SetupDiGetDriverInfoDetail(hDevInfo,
                                         pSpDevInfoData,
                                         &DrvInfoData,
                                         pDrvInfoDetailData,
                                         dwNeeded,
                                         NULL) ) {

            goto Cleanup;
        }
    }

    pDrvInfo->pszInfName        = AllocStr(pDrvInfoDetailData->InfFileName);
    pDrvInfo->pszDriverSection  = AllocStr(pDrvInfoDetailData->SectionName);
    pDrvInfo->pszModelName      = AllocStr(DrvInfoData.Description);
    pDrvInfo->pszManufacturer   = AllocStr(DrvInfoData.MfgName);
    pDrvInfo->pszProvider       = AllocStr(DrvInfoData.ProviderName);
    pDrvInfo->ftDriverDate = DrvInfoData.DriverDate;
    pDrvInfo->dwlDriverVersion = DrvInfoData.DriverVersion;

    if ( pDrvInfoDetailData->HardwareID && *pDrvInfoDetailData->HardwareID ) {

        pDrvInfo->pszHardwareID = AllocStr(pDrvInfoDetailData->HardwareID);
        if(!pDrvInfo->pszHardwareID)
            goto Cleanup;
    }

    bRet = pDrvInfo->pszInfName         &&
           pDrvInfo->pszDriverSection   &&
           pDrvInfo->pszModelName       &&
           pDrvInfo->pszProvider        &&
           pDrvInfo->pszManufacturer;

Cleanup:
    LocalFreeMem(pDrvInfoDetailData);
    LocalFreeMem(pDrvInstallParams);

    if ( bRet ) {
       return pLocalData;
    } else {

        //
        // On failure we will leave the old private local data around
        //
        DestroyLocalData(pLocalData);
        return NULL;
    }
}


PPSETUP_LOCAL_DATA
PSetupGetSelectedDriverInfo(
    IN  HDEVINFO    hDevInfo
    )
{
    return BuildInternalData(hDevInfo, NULL);
}


#if             0
DWORD GetDriverNumber (HDEVINFO hDevInfo)
/*++

Routine Description:

    This routine returns the number of drivers in a particular INF file

Arguments:

    hDevInfo   : Handle got by calling PSetupCreateDrvSetupParams

Return Value:
    Number of drivers (from 1 if no error happens)

++*/
{
    SP_DRVINFO_DATA         DrvInfoData;
    DWORD                   dwLast = 0;
    DWORD                   dwMiddle;
    DWORD                   dwLastFailed = 10;

    DrvInfoData.cbSize = sizeof (DrvInfoData);

    // Expand the number
    while (SetupDiEnumDriverInfo (hDevInfo, NULL,SPDIT_CLASSDRIVER,
                                  dwLastFailed, &DrvInfoData)) {
            dwLast = dwLastFailed;
            dwLastFailed *= 2;
    }

    if (GetLastError() == ERROR_NO_MORE_ITEMS) {
        // We've got an boundary, the number is between dwLast and dwLastFailed

        while (dwLastFailed - dwLast > 1) {
            dwMiddle = (dwLastFailed + dwLast) / 2;
            if (!SetupDiEnumDriverInfo (hDevInfo, NULL,SPDIT_CLASSDRIVER,
                                        dwMiddle, &DrvInfoData)) {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    dwLastFailed = dwMiddle;
                else
                // Some other errors. Ignore them by assuming the driver number is 0
                    return 0;
            }
            else dwLast = dwMiddle;
        }
        return dwLast + 1;
    }
    else
        return 0;
}

BOOL
IsSubSet (
    IN  HDEVINFO            hDevInfoA,
    IN  HDEVINFO            hDevInfoB
)
/*++

Routine Description:

    This routine checks if the driver list in hDevInfoA is a subset of
    the driver list in hDevInfoB

Arguments:

    hDevInfoA   : The handle of the driver list A
    hDevInfoB   : The handle of the driver list B

Return Value:
    TRUE if A is a subset of B, FALSE else

++*/

{
    SP_DRVINFO_DATA         DrvInfoDataA;
    SP_DRVINFO_DATA         DrvInfoDataB;
    DWORD                   j,k;
    DWORD                   lastUnmatched;
    BOOL                    found;
    BOOL                    bRet = FALSE;
    BOOL                    bSameMfgName;

    DrvInfoDataA.cbSize = sizeof (DrvInfoDataA);
    DrvInfoDataB.cbSize = sizeof (DrvInfoDataB);

    j = 0;
    lastUnmatched = 0;

    // Get a set of driver data
    while (bRet = SetupDiEnumDriverInfo (hDevInfoA, NULL,
        SPDIT_CLASSDRIVER, j, &DrvInfoDataA)) {
        //Compare the old one with the new driver set to see if it is in the set

        k = lastUnmatched;
        found = FALSE;
        bSameMfgName = FALSE;

        while (SetupDiEnumDriverInfo (hDevInfoB, NULL, SPDIT_CLASSDRIVER, k,
                                      &DrvInfoDataB) && !found) {

            if (lstrcmpi (DrvInfoDataA.MfgName, DrvInfoDataB.MfgName)) {
                if (bSameMfgName) {
                    // This means, we've scanned all the entries with the
                    // same manufacture name, but none of them matches
                    // So the list A contains an entry which the list B
                    // does not. Stop,
                    return FALSE;
                }
                // Different Manufacture name, never visit it again
                k++;
                lastUnmatched = k;
            }
            else {
                bSameMfgName = TRUE;    // Set the flag

                // Manufacture matched
                if (DrvInfoDataB.DriverType == DrvInfoDataA.DriverType &&
                    !lstrcmpi (DrvInfoDataB.Description, DrvInfoDataA.Description)) {
                    found = TRUE;
                    // A match
                    if (lastUnmatched == k) { // Continuous match
                        k++;
                        lastUnmatched = k;
                    }
                    else {
                        // It is a match, but some models in the new list is not on the
                        // old list
                        // Don't update lastUnmatched, because we've to revisit it again.
                        k++;
                    }
                }
                else { // does not match
                    k++;
                }
            }
        }

        // Can not delete the existing driver, quit the loop
        if (!found) return FALSE;

        // Otherwise, check the next existing driver in the list A
        j++;
    }

    if (GetLastError() == ERROR_NO_MORE_ITEMS)
        // All the drivers in the list A have been found in list B
        return TRUE;
    else
        return FALSE;
}


BOOL
CopyOEMInfFileAndGiveUniqueName(
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pSpDevInfoData,
    IN  LPTSTR              pszInfFile
    )
/*++

Routine Description:

    This routine checks if an OEM driver list is a subset of the driver
    to be installed and if so
    copies the OEM printer inf file to "<systemroot>\Inf\OEM<n>.INF".
    Where n is the first unused file number.


Arguments:

    hDevInfo   : Handle got by calling PSetupCreateDrvSetupParams
    pszInfFile  : Fully qualified path of OEM inf file

Return Value:
    TRUE if no error, FALSE else

++*/
{
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    TCHAR                   szNewFileName[MAX_PATH];
    TCHAR                   szSystemDir[MAX_PATH];
    DWORD                   i,j;
    BOOL                    bRet = FALSE;
    SP_DRVINFO_DATA         DrvInfoData;
    DWORD                   dwNeeded;
    PSP_INF_INFORMATION     pSpInfInfo = NULL;
    LPTSTR                  pszProviderName                 = NULL;
    LPTSTR                  pszNewProvider                  = NULL;
    LPTSTR                  pszInfFullName                  = NULL;
    LPTSTR                  pszInfName                      = NULL;
    HDEVINFO                hOldDevInfo                     = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS    DevInstallParams;
    DWORD                   dwNumNewDrivers;
    DWORD                   dwNumOldDrivers;
    DWORD                   dwLen;
    WIN32_FIND_DATA         FindData;
    HANDLE                  hFindFile                       = INVALID_HANDLE_VALUE;
    HANDLE                  hInfFile                        = INVALID_HANDLE_VALUE;
    UINT                    uErrorLine;
    DWORD                   dwInfNeeded                     = 2048;
                            // Since to get file list takes long time,
                            // so we try to use the previous values to
                            // Allocate the memeory first.

    DevInstallParams.cbSize         = sizeof(DevInstallParams);
    DevInstallParams.DriverPath[0]  = 0;
    DrvInfoData.cbSize = sizeof (DrvInfoData);

    //
    // Check DeviceInstallParams to see if OEM driver list is built
    //
    if ( !SetupDiGetDeviceInstallParams(hDevInfo,
                                        pSpDevInfoData,
                                        &DevInstallParams) )
        return FALSE;


    // If DriverPath is clear then not an OEM driver
    if ( !DevInstallParams.DriverPath[0] ) {
        return TRUE;
    }


    if (!GetSystemDirectory(szSystemDir, SIZECHARS (szSystemDir)))
        return FALSE;

    dwLen = lstrlen (szSystemDir);

    // 2 mean equal. If pszInfFile is in the system directory, don't copy it
    if (2 == CompareString(LOCALE_SYSTEM_DEFAULT,
                           NORM_IGNORECASE,
                           szSystemDir,
                           dwLen,
                           pszInfFile,
                           dwLen))
        return TRUE;


    if ( !GetWindowsDirectory(szSystemDir,SIZECHARS(szSystemDir)))
        goto Cleanup;


    // Check to see if there is any existing .INF files which are subsets of the
    // new driver to be installed
    if (! PSetupBuildDriversFromPath(hDevInfo, pszInfFile, TRUE)) goto Cleanup;

    dwNumNewDrivers = GetDriverNumber (hDevInfo);

    // Get a set of driver data
    if (!SetupDiEnumDriverInfo (hDevInfo, NULL, SPDIT_CLASSDRIVER, 0, &DrvInfoData))
        goto Cleanup;

    if (! (pszNewProvider = AllocStr (DrvInfoData.ProviderName))) goto Cleanup;


    // Allocate enough memeory for the full path
    if (! (pszInfFullName = LocalAllocMem ((lstrlen (szSystemDir) + lstrlen (cszINF)
                                       + MAX_PATH + 1) * sizeof (TCHAR))))
        goto Cleanup;

    lstrcpy (pszInfFullName, szSystemDir);
    lstrcat (pszInfFullName, cszINF);

    // pszInfName always points to the begining of the name
    pszInfName = pszInfFullName + lstrlen (pszInfFullName);
    lstrcpy (pszInfName, cszInfWildCard);

    hFindFile = FindFirstFile (pszInfFullName, &FindData);
    if (hFindFile != INVALID_HANDLE_VALUE)  {

        do {
            //
            // Skip directories
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }

            // We've got a name
            lstrcpy (pszInfName, FindData.cFileName);

            hInfFile = SetupOpenInfFile(pszInfFullName,
                                        cszPrinter,
                                        INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                                        &uErrorLine);
            if (hInfFile == INVALID_HANDLE_VALUE)
                continue;

            // We've opened a file which has a printer as the class name

            if (! (pSpInfInfo = LocalAllocMem (dwInfNeeded * sizeof (TCHAR)))) goto NextFile;

            // use dwNeeded so that dwInfNeeded is modified only when the buffer is insufficient
            dwNeeded = dwInfNeeded;
            if (!SetupGetInfInformation (hInfFile, INFINFO_INF_SPEC_IS_HINF, pSpInfInfo,
                                         dwInfNeeded, &dwNeeded)) {
                if (ERROR_INSUFFICIENT_BUFFER == GetLastError ()) {
                    LocalFree (pSpInfInfo);
                    if (! (pSpInfInfo = LocalAllocMem (dwNeeded * sizeof (TCHAR)))) goto NextFile;
                    dwInfNeeded = dwNeeded;

                    if (!SetupGetInfInformation (hInfFile, INFINFO_INF_SPEC_IS_HINF,
                                                 pSpInfInfo, dwInfNeeded, &dwNeeded))
                        goto NextFile;
                }
                else goto NextFile;

            }

            if (! (pszProviderName = GetInfQueryString(pSpInfInfo, cszProvider)))
                goto NextFile;

            if (!lstrcmpi (pszNewProvider, pszProviderName)) {
                // If both INF files are from the same provider, try to check if it can be deleted

                if ((hOldDevInfo = SetupDiCreateDeviceInfoList(
                    (LPGUID)&GUID_DEVCLASS_PRINTER, NULL)) == INVALID_HANDLE_VALUE)
                    goto NextFile;

                if (! PSetupBuildDriversFromPath(hOldDevInfo, pszInfFullName, TRUE))
                    goto NextFile;

                dwNumOldDrivers = GetDriverNumber (hOldDevInfo);

                // It is not possible to be a subset of the new one
                if (dwNumOldDrivers >= dwNumNewDrivers)  {
                    if (IsSubSet (hDevInfo, hOldDevInfo)) {
                        // No need to copy the new one
                        bRet = TRUE;
                        goto Cleanup;
                    }
                }

                if (dwNumOldDrivers <= dwNumNewDrivers)  {
                    if (IsSubSet (hOldDevInfo, hDevInfo)) {
                        // All the drivers in the current file have been found in the new
                        // driver file, delete the old file
                        DeleteFile (pszInfFullName);
                        // and its corresponding .PNF file
                        lstrcpyn (pszInfName + lstrlen (pszInfName) - 3, cszPNF, 4);
                        DeleteFile (pszInfFullName);
                    }
                }

                // Else Close the file and continue on the next one
            }   // End of provider name comparison


NextFile:
            if (hInfFile != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile (hInfFile);
                hInfFile = INVALID_HANDLE_VALUE;
            }
            if (hOldDevInfo != INVALID_HANDLE_VALUE) {
                SetupDiDestroyDeviceInfoList (hOldDevInfo);
                hOldDevInfo = INVALID_HANDLE_VALUE;
            }
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);
                hFile = INVALID_HANDLE_VALUE;
            }
            // Clear the pointers so that the clean up won't free them again
            LocalFreeMem (pSpInfInfo);
            pSpInfInfo = NULL;

        }           // End of the loop
        while (FindNextFile(hFindFile,&FindData));
    }

    // All the duplicate files are deleted. Let's create a new one

    for ( i = 0 ; i < 10000 ; ++i ) {

        wsprintf(szNewFileName, cszOEMInfGen, szSystemDir, i);

        //
        // By using the CREATE_NEW flag we reserve the file name and
        // will not end up overwriting another file which gets created
        // by another setup (some inf) thread
        //
        hFile = CreateFile(szNewFileName,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile != INVALID_HANDLE_VALUE ) {
            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;

            bRet = CopyFile(pszInfFile, szNewFileName, FALSE);
            goto Cleanup;
        }
        else if ( GetLastError() != ERROR_FILE_EXISTS )
            break;
    }

Cleanup:
    if (hFindFile != INVALID_HANDLE_VALUE)
        FindClose (hFindFile);
    if (hInfFile != INVALID_HANDLE_VALUE)
        SetupCloseInfFile (hInfFile);
    if (hOldDevInfo != INVALID_HANDLE_VALUE)
        SetupDiDestroyDeviceInfoList (hOldDevInfo);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);
    LocalFreeMem (pszInfFullName);
    LocalFreeMem (pszNewProvider);
    LocalFreeMem (pszProviderName);
    LocalFreeMem (pSpInfInfo);
    return bRet;
}
#endif


BOOL
PSetupSelectDriver(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    Display manufacturer/model information and have the user select a
    printer driver. Selected driver is remembered and PSetupGetSelectedDriver
    call will give the selected driver.

Arguments:
    hDevInfo    - Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{

    return BuildClassDriverList(hDevInfo) &&
           SetupDiSelectDevice(hDevInfo, NULL);
}

VOID
GetDriverPath(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    OUT TCHAR               szDriverPath[MAX_PATH]
    )
/*++

Routine Description:
    Gets the path where driver files should be searched first to copy from

Arguments:
    pszDriverPath   : Pointer to a buffer of MAX_PATH size. Gives path where
                      system was installed from

Return Value:
    Nothing

--*/
{
    BOOL        bOemDriver = FALSE;
    LPTSTR     *List, psz;
    DWORD       dwCount;
    LPTSTR      pszTempPath = NULL;

    //
    // For OEM drivers look at the place where the inf came from, else
    // look at the place we installed NT from
    //
    if ( pLocalData && 
         !(IsSystemNTPrintInf(pLocalData->DrvInfo.pszInfName) || (pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER ))) {

        lstrcpy(szDriverPath, pLocalData->DrvInfo.pszInfName);
        if ( psz = FileNamePart(szDriverPath) ) {

            *psz = TEXT('\0');
            return;
        }
    }

    pszTempPath = GetSystemInstallPath();
    if ( pszTempPath != NULL )
    {
        lstrcpy(szDriverPath, pszTempPath);
        LocalFreeMem(pszTempPath);
    }
    else
        // Default put A:\ since we have to give something to setup
        lstrcpy(szDriverPath, TEXT("A:\\"));
}

BOOL
BuildClassDriverList(
    IN HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    Build the class driver list.

    Note: If driver list is already built this comes back immediately

Arguments:
    hDevInfo    : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD               dwLastError;
    SP_DRVINFO_DATA     DrvInfoData;
    //
    // Build the class driver list and also make sure there is atleast one driver
    //
    if ( !SetupDiBuildDriverInfoList(hDevInfo, NULL, SPDIT_CLASSDRIVER) )
        return FALSE;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if ( !SetupDiEnumDriverInfo(hDevInfo,
                                NULL,
                                SPDIT_CLASSDRIVER,
                                0,
                                &DrvInfoData)           &&
         GetLastError() == ERROR_NO_MORE_ITEMS ) {

        SetLastError(SPAPI_E_DI_BAD_PATH);
        return FALSE;
    }

    return TRUE;
}


BOOL
PSetupRefreshDriverList(
    IN HDEVINFO hDevInfo
    )
/*++

Routine Description:
    Destroy current driver list and build new one if currently an OEM driver
    list is associated. This way if you go back after choosing HaveDisk you
    would still see drivers from inf directory instead of the OEM inf ...

Arguments:
    hDevInfo    : Handle to the printer class device information list

Return Value:
    TRUE on success, FALSE on error

--*/
{
    SP_DEVINSTALL_PARAMS    DevInstallParams = { 0 };

    DevInstallParams.cbSize         = sizeof(DevInstallParams);

    //
    // Check DeviceInstallParams to see if OEM driver list is built
    //
    if ( SetupDiGetDeviceInstallParams(hDevInfo,
                                       NULL,
                                       &DevInstallParams) &&
         !DevInstallParams.DriverPath[0] ) {

        return TRUE;
    }

    //
    // Destroy current list and build another one
    //
    SetupDiDestroyDriverInfoList(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER);

    DevInstallParams.DriverPath[0] = sZero;

    return SetupDiSetDeviceInstallParams(hDevInfo,
                                         NULL,
                                         &DevInstallParams) &&

           BuildClassDriverList(hDevInfo);
}

BOOL
IsNTPrintInf(
    IN LPCTSTR pszInfName
    )
/*

  Function: IsNTPrintInf

  Purpose:  Verifies is the inf file being copied is a system inf - ntprint.inf.

  Parameters:
            pszInfName - the fully qualified inf name that is being installed.

  Notes:    This is needed to make the decision of whether to zero or even copy the inf
            with SetupCopyOEMInf.
            Should we be doing a deeper comparison than this to decide?

*/
{
    BOOL   bRet      = FALSE;
    PTCHAR pFileName = FileNamePart( pszInfName );

    if( pFileName )
    {
        bRet = ( 0 == lstrcmpi( pFileName, cszNtprintInf ) );
    }

    return bRet;
}

BOOL
IsSystemNTPrintInf(
    IN PCTSTR pszInfName
    )
/*

  Function: IsSystemNTPrintInf

  Purpose:  Verifies if the inf file the one system printer inf : %windir\inf\ntprint.inf.

  Parameters:
            pszInfName - the fully qualified inf name that is being verified.

  Notes:    Needed to decide whether to downrank our inbox drivers
  
*/
{
    BOOL   bRet      = FALSE;
    TCHAR  szSysInf[MAX_PATH] = {0};
    UINT   Len;
    PCTSTR pRelInfPath = _T("inf\\ntprint.inf");

    Len = GetSystemWindowsDirectory(szSysInf, MAX_PATH);
    
    if (
            (Len != 0)       && 
            (Len + _tcslen(pRelInfPath) + 2 < MAX_PATH)
       )
    {
        if (szSysInf[Len-1] != _T('\\'))
        {
            szSysInf[Len++] = _T('\\'); 
        }
        _tcscat(szSysInf, pRelInfPath);
        if (!_tcsicmp(szSysInf, pszInfName))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL
PSetupIsOemDriver(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PBOOL               pbIsOemDriver
    )
/*++

Routine Description:
    Returns indication if the currently selected driver list
    is an OEM driver list.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pLocalData      : Gives the selected driver information
    pbIsOemDriver   : Pointer to bool where to return OEM driver indicator.
                      Set to TRUE if driver is an OEM driver.
                      Set to FALSE if driver is not an OEM driver.

Return Value:
    TRUE on success, FALSE on error.

--*/
{
    TCHAR                   szSystemDir[MAX_PATH];
    BOOL                    bRet = FALSE;
    DWORD                   dwLen;

    //
    // Ideally Setup API should have an export for this. But rather than
    // waiting for them to do this let me write the code and get it done with
    //
    if ( pLocalData &&
       ( pLocalData->DrvInfo.Flags & SDFLAG_CDM_DRIVER ) )
    {
       *pbIsOemDriver = FALSE;
       bRet = TRUE;
    }
    else if ( dwLen = GetSystemWindowsDirectory(szSystemDir, SIZECHARS(szSystemDir)) )
    {
        bRet = TRUE;

        //
        // If Inf is not under %windir% then it is OEM
        //
        *pbIsOemDriver = lstrncmpi(pLocalData->DrvInfo.pszInfName,
                                   szSystemDir,
                                   dwLen) != 0;
    }

    return bRet;
}


BOOL
PSetupPreSelectDriver(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszManufacturer,
    IN  LPCTSTR     pszModel
    )
/*++

Routine Description:
    Preselect a manufacturer and model for the driver dialog

    If same model is found select it, else if a manufacturer is given and
    a match in manufacturer is found select first driver for the manufacturer.

Arguments:
    hDevInfo        : Handle to the printer class device information list
    pszManufacturer : Manufacterer name to preselect
    pszModel        : Model name to preselect

Return Value:
    TRUE on a model or manufacturer match
    FALSE else

--*/
{
    SP_DRVINFO_DATA     DrvInfoData;
    DWORD               dwIndex, dwManf, dwMod;

    if ( !BuildClassDriverList(hDevInfo) ) {

        return FALSE;
    }

    dwIndex = 0;

    //
    // To do only one check later
    //
    if ( pszManufacturer && !*pszManufacturer )
        pszManufacturer = NULL;

    if ( pszModel && !*pszModel )
        pszModel = NULL;

    //
    // If no model/manf given select first driver
    //
    if ( pszManufacturer || pszModel ) {

        dwManf = dwMod = MAX_DWORD;
        DrvInfoData.cbSize = sizeof(DrvInfoData);

        while ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                                      dwIndex, &DrvInfoData) ) {

            if ( pszManufacturer        &&
                 dwManf == MAX_DWORD    &&
                 !lstrcmpi(pszManufacturer, DrvInfoData.MfgName) ) {

                dwManf = dwIndex;
            }

            if ( pszModel &&
                 !lstrcmpi(pszModel, DrvInfoData.Description) ) {

                dwMod = dwIndex;
                break; // the for loop
            }

            DrvInfoData.cbSize = sizeof(DrvInfoData);
            ++dwIndex;
        }

        if ( dwMod != MAX_DWORD ) {

            dwIndex = dwMod;
        } else if ( dwManf != MAX_DWORD ) {

            dwIndex = dwManf;
        } else {

            SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
            return FALSE;
        }
    }

    DrvInfoData.cbSize = sizeof(DrvInfoData);
    if ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                               dwIndex, &DrvInfoData)   &&
         SetupDiSetSelectedDriver(hDevInfo, NULL, &DrvInfoData) ) {

        return TRUE;
    }

    return FALSE;
}


PPSETUP_LOCAL_DATA
PSetupDriverInfoFromName(
    IN HDEVINFO     hDevInfo,
    IN LPCTSTR      pszModel
    )
{
    return PSetupPreSelectDriver(hDevInfo, NULL, pszModel)  ?
                BuildInternalData(hDevInfo, NULL)  :
                NULL;
}


LPDRIVER_INFO_6
Win95DriverInfo6FromName(
    IN  HDEVINFO    hDevInfo,
    IN  PPSETUP_LOCAL_DATA*  ppLocalData,
    IN  LPCTSTR     pszModel,
    IN  LPCTSTR     pszzPreviousNames
    )
{
    LPDRIVER_INFO_6     pDriverInfo6=NULL;
    PPSETUP_LOCAL_DATA  pLocalData;
    BOOL                bFound;
    LPCTSTR             pszName;

    bFound = PSetupPreSelectDriver(hDevInfo, NULL, pszModel);
    for ( pszName = pszzPreviousNames ;
          !bFound && pszName && *pszName ;
          pszName += lstrlen(pszName) + 1 ) {

        bFound = PSetupPreSelectDriver(hDevInfo, NULL, pszName);
    }

    if ( !bFound )
        return NULL;

    if ( (pLocalData = BuildInternalData(hDevInfo, NULL))           &&
         ParseInf(hDevInfo, pLocalData, PlatformWin95, NULL, 0) ) {

        pDriverInfo6 = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                        pLocalData->InfInfo.cbDriverInfo6);
        *ppLocalData = pLocalData;
    }

    if (!pDriverInfo6 && pLocalData)
    {
        DestroyLocalData(pLocalData);
        *ppLocalData = NULL;
    }

    return pDriverInfo6;
}


BOOL
PSetupDestroySelectedDriverInfo(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    )
{
    ASSERT(pLocalData && pLocalData->signature == PSETUP_SIGNATURE);
    DestroyLocalData(pLocalData);
    return TRUE;
}


BOOL
PSetupGetDriverInfForPrinter(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszPrinterName,
    IN OUT  LPTSTR      pszInfName,
    IN OUT  LPDWORD     pcbInfNameSize
    )
{
    BOOL                        bRet = FALSE;
    DWORD                       dwSize, dwIndex;
    HANDLE                      hPrinter;
    LPTSTR                      pszInf;
    PPSETUP_LOCAL_DATA          pLocalData = NULL;
    LPDRIVER_INFO_6             pDriverInfo6 = NULL;
    SP_DRVINFO_DATA             DrvInfoData;


    if ( !OpenPrinter((LPTSTR)pszPrinterName, &hPrinter, NULL) )
        return FALSE;

    if ( !BuildClassDriverList(hDevInfo) )
        goto Cleanup;

    GetPrinterDriver(hPrinter,
                     NULL,
                     6,
                     NULL,
                     0,
                     &dwSize);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Cleanup;

    if ( !((LPBYTE)pDriverInfo6 = LocalAllocMem(dwSize))   ||
         !GetPrinterDriver(hPrinter,
                           NULL,
                           6,
                           (LPBYTE)pDriverInfo6,
                           dwSize,
                           &dwSize) ) {

        goto Cleanup;
    }

    dwIndex = 0;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    while ( SetupDiEnumDriverInfo(hDevInfo, NULL, SPDIT_CLASSDRIVER,
                                      dwIndex, &DrvInfoData) ) {

        //
        // Is the driver name same?
        //
        if ( !lstrcmpi(pDriverInfo6->pName, DrvInfoData.Description) ) {

            if ( !SetupDiSetSelectedDriver(hDevInfo, NULL, &DrvInfoData)    ||
                 !(pLocalData = BuildInternalData(hDevInfo, NULL))          ||
                 !ParseInf(hDevInfo, pLocalData, MyPlatform, NULL, 0) ) {

                if ( pLocalData ) {

                    DestroyLocalData(pLocalData);
                    pLocalData = NULL;
                }
                break;
            }

            //
            // Are the DRIVER_INFO_6's identical?
            //
            if ( IdenticalDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                      pDriverInfo6) )
                break;

            DestroyLocalData(pLocalData);
            pLocalData = NULL;
        }

        DrvInfoData.cbSize = sizeof(DrvInfoData);
        ++dwIndex;
    }

    if ( pLocalData == NULL ) {

        SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
        goto Cleanup;
    }

    pszInf= pLocalData->DrvInfo.pszInfName;
    dwSize = *pcbInfNameSize;
    *pcbInfNameSize = (lstrlen(pszInf) + 1) * sizeof(TCHAR);

    if ( dwSize < *pcbInfNameSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    lstrcpy(pszInfName, pszInf);
    bRet = TRUE;

Cleanup:
    ClosePrinter(hPrinter);
    LocalFreeMem(pDriverInfo6);
    DestroyLocalData(pLocalData);

    return  bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\upgrade.c ===
/*++

Copyright (c) 1995 Microsoft Corporation
All rights reserved.

Module Name:

    Upgrade.c

Abstract:

    Code to upgrade printer drivers during system upgrade

Author:

    Muhunthan Sivapragasam (MuhuntS) 20-Dec-1995

Revision History:

--*/

#include "precomp.h"
#include <syssetup.h>
#include <shlwapi.h>
#include <regstr.h>

//
// Strings used  in PrintUpg.inf
//
TCHAR   cszUpgradeInf[]                 = TEXT("printupg.inf");
TCHAR   cszPrintDriverMapping[]         = TEXT("Printer Driver Mapping");
TCHAR   cszVersion[]                    = TEXT("Version");
TCHAR   cszExcludeSection[]             = TEXT("Excluded Driver Files");

TCHAR   cszSyssetupInf[]                = TEXT("layout.inf");
TCHAR   cszMappingSection[]             = TEXT("Printer Driver Mapping");
TCHAR   cszSystemServers[]              = TEXT("System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers\\");
TCHAR   cszSystemConnections[]          = TEXT("System\\CurrentControlSet\\Control\\Print\\Connections\\");
TCHAR   cszSoftwareServers[]            = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers\\");
TCHAR   cszSoftwarePrint[]              = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print");
TCHAR   cszBadConnections[]             = TEXT("Bad Connections");
TCHAR   cszPrinters[]                   = TEXT("\\Printers\\");
TCHAR   cszDriver[]                     = TEXT("Printer Driver");
TCHAR   cszShareName[]                  = TEXT("Share Name");
TCHAR   cszConnections[]                = TEXT("\\Printers\\Connections");
TCHAR   cszSetupKey[]                   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
TCHAR   cszSourcePath[]                 = TEXT("SourcePath");

//
// What level info we wanted logged in setup log
//
LogSeverity    gLogSeverityLevel           = LogSevInformation;

//
// Define structure used to track printer drivers
// that need to be added via AddPrinterDriver().
//
typedef struct _DRIVER_TO_ADD {

    struct _DRIVER_TO_ADD  *pNext;
    PPSETUP_LOCAL_DATA      pLocalData;
    PLATFORM                platform;
} DRIVER_TO_ADD, *PDRIVER_TO_ADD;

typedef struct _DRIVER_TO_DELETE {

    struct _DRIVER_TO_DELETE   *pNext;
    LPTSTR                      pszDriverName;
    LPTSTR                      pszNewDriverName; // In box driver to replace
} DRIVER_TO_DELETE, *PDRIVER_TO_DELETE;

typedef struct _CONNECTION_TO_DELETE {

    struct _CONNECTION_TO_DELETE   *pNext;
    LPTSTR                          pszConnectionName;
} CONNECTION_TO_DELETE, *PCONNECTION_TO_DELETE;


//
// gpDriversToAdd list will have all the drivers we are trying to upgrade
//
PDRIVER_TO_ADD          gpDriversToAdd = NULL;
PDRIVER_TO_DELETE       gpBadDrvList = NULL;

// Forward Reference for recursive call

BOOL
PruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers
    );

VOID
DeleteRegKey(
    IN  HKEY      hRegKey,
    IN  LPTSTR    pszSubKey
    );

DWORD
DeleteCache(
    VOID
    );

VOID
LogError(
    IN  LogSeverity     Severity,
    IN  UINT            uMessageId,
    ...
    )
/*++

Routine Description:
    Logs an error in driver upgrade. We will do driver level error logging
    and not file level (ie. Faile to upgrade "HP Laser Jet 4" for Alpha
    instead of failure on RASDDUI.DLL for Alpha)

Arguments:

Return Value:
    None.

--*/
{
    LPTSTR      pszFormat;
    TCHAR       szMsg[1024];
    va_list     vargs;

    if ( Severity < gLogSeverityLevel )
        return;

    if ( pszFormat = GetStringFromRcFile(uMessageId) ) 
    {
        va_start(vargs, uMessageId);
        wvnsprintf(szMsg, SIZECHARS(szMsg), pszFormat, vargs);
        SetupLogError(szMsg, Severity);
        LocalFreeMem(pszFormat);
    }
    return;
}


VOID
AddEntryToDriversToAddList(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  LPBOOL              pbFail
    )
{
    PDRIVER_TO_ADD  pDriverToAdd;

    if ( *pbFail )
        return;

    pDriverToAdd = (PDRIVER_TO_ADD) LocalAllocMem(sizeof(DRIVER_TO_ADD));
    if ( !pDriverToAdd ) {

        *pbFail = TRUE;
        return;
    }

    pDriverToAdd->pLocalData    = pLocalData;
    pDriverToAdd->platform      = platform;
    pDriverToAdd->pNext         = gpDriversToAdd;
    gpDriversToAdd              = pDriverToAdd;
}


VOID
FreeDriversToAddList(
    )
/*++

Routine Description:
    Free drivers to add list

Arguments:
    None

Return Value:
    None.

--*/
{
    PDRIVER_TO_ADD  pCur, pNext;

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;
        DestroyLocalData(pCur->pLocalData);
        LocalFreeMem((PVOID)pCur);
    }

    gpDriversToAdd  = NULL;
}


VOID
AddEntryToDriversToDeleteList(
    IN      LPTSTR          pszDriverName,
    IN      LPTSTR          pszNewDriverName
    )
{
    PDRIVER_TO_DELETE   pDrvEntry;

    if ( pDrvEntry = (PDRIVER_TO_DELETE) LocalAllocMem(sizeof(DRIVER_TO_DELETE)) ) {

        pDrvEntry->pszDriverName        = pszDriverName;
        pDrvEntry->pszNewDriverName     = pszNewDriverName;
        pDrvEntry->pNext                = gpBadDrvList;
        gpBadDrvList                    = pDrvEntry;
    }
}


LPTSTR
ReadDigit(
    LPTSTR  ptr,
    LPWORD  pW
    )
{
    TCHAR   c;
    //
    // Skip spaces
    //
    while ( !iswdigit(c = *ptr) && c != TEXT('\0') )
        ++ptr;

    if ( c == TEXT('\0') )
        return NULL;

    //
    // Read field
    //
    for ( *pW = 0 ; iswdigit(c = *ptr) ; ++ptr )
        *pW = *pW * 10 + c - TEXT('0');

    return ptr;
}


BOOL
StringToDate(
    LPTSTR          pszDate,
    SYSTEMTIME     *pInfTime
    )
{
    BOOL    bRet = FALSE;

    ZeroMemory(pInfTime, sizeof(*pInfTime));

    bRet = (pszDate = ReadDigit(pszDate, &(pInfTime->wMonth)))      &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wDay)))        &&
           (pszDate = ReadDigit(pszDate, &(pInfTime->wYear)));

    //
    // Y2K compatible check
    //
    if ( bRet && pInfTime->wYear < 100 ) {

        ASSERT(pInfTime->wYear >= 100);

        if ( pInfTime->wYear < 10 )
            pInfTime->wYear += 2000;
        else
            pInfTime->wYear += 1900;
    }

    return bRet;
}

BOOL
FindPathOnSource(
    IN      LPCTSTR     pszFileName,
    IN      HINF        MasterInf,
    IN OUT  LPTSTR      pszPathOnSource,
    IN      DWORD       dwLen,
    OUT     LPTSTR     *ppszMediaDescription,       OPTIONAL
    OUT     LPTSTR     *ppszTagFile                 OPTIONAL
    )
/*++

Routine Description:
    Find the path of a driver file for a specific platform in the installation
    directory

Arguments:
    pszFileName             : Name of the file to find source location
    MasterInf               : Handle to the master inf
    pszPathOnSource         : Pointer to string to build source path
    dwLen                   : Length of pszSourcePath
    ppszMediaDescription    : Optionally function will return media description
                                (caller should free memory)
    ppszTagFile             : Optionally function will return tagfile name
                                (caller should free memory)

Return Value:
    TRUE on succes, FALSE on error.

--*/
{
    UINT        DiskId;
    TCHAR       szRelativePath[MAX_PATH];
    DWORD       dwNeeded;

    if ( !SetupGetSourceFileLocation(
                        MasterInf,
                        NULL,
                        pszFileName,
                        &DiskId,
                        szRelativePath,
                        SIZECHARS(szRelativePath),
                        &dwNeeded)                                          ||
         !SetupGetSourceInfo(MasterInf,
                             DiskId,
                             SRCINFO_PATH,
                             pszPathOnSource,
                             dwLen,
                             &dwNeeded)                                     ||

         (DWORD)(lstrlen(szRelativePath) + lstrlen(pszPathOnSource) + 1) > dwLen ) {

        return FALSE;
    }

    lstrcat(pszPathOnSource, szRelativePath);

    if ( ppszMediaDescription ) {

        *ppszMediaDescription = NULL;

        if ( !SetupGetSourceInfo(MasterInf,
                                 DiskId,
                                 SRCINFO_DESCRIPTION,
                                 NULL,
                                 0,
                                 &dwNeeded)                                 ||
             !(*ppszMediaDescription = LocalAllocMem(dwNeeded * sizeof(TCHAR)))  ||
             !SetupGetSourceInfo(MasterInf,
                                DiskId,
                                SRCINFO_DESCRIPTION,
                                *ppszMediaDescription,
                                dwNeeded,
                                &dwNeeded) ) {

            LocalFreeMem(*ppszMediaDescription);
            return FALSE;
        }
    }

    if ( ppszTagFile ) {

        *ppszTagFile = NULL;

        if ( !SetupGetSourceInfo(MasterInf,
                                 DiskId,
                                 SRCINFO_TAGFILE,
                                 NULL,
                                 0,
                                 &dwNeeded)                         ||
             !(*ppszTagFile = LocalAllocMem(dwNeeded * sizeof(TCHAR)))   ||
             !SetupGetSourceInfo(MasterInf,
                                DiskId,
                                SRCINFO_TAGFILE,
                                *ppszTagFile,
                                dwNeeded,
                                &dwNeeded) ) {

            if ( ppszMediaDescription )
                LocalFreeMem(*ppszMediaDescription);
            LocalFreeMem(*ppszTagFile);
            return FALSE;
        }
    }

    return TRUE;
}


VOID
CheckAndEnqueueFile(
    IN      LPCTSTR         pszFileName,
    IN      LPTSTR          pszTargetDir,
    IN      HINF            MasterInf,
    IN      LPCTSTR         pszInstallationSource,
    IN OUT  HSPFILEQ        CopyQueue,
    IN OUT  LPBOOL          pFail
    )
/*++

Routine Description:
    If the given file does not appear as a dependent file enque it for copying

Arguments:
    pszFileName             : Name of the file to find source location
    pszTargetDir            : Target directory to copy the file
    MasterInf               : Handle to the master inf
    pszInstallationSource   : Installation source path
    CopyQueue               : Setup filecopy queue
    pFail                   : Will be set to TRUE on error

Return Value:
    Nothing

--*/
{
    TCHAR       szPathOnSource[MAX_PATH];

    if ( *pFail )
        return;

    if ( !FindPathOnSource(
                pszFileName,
                MasterInf,
                szPathOnSource,
                SIZECHARS(szPathOnSource),
                NULL,
                NULL)                           ||
         !SetupQueueCopy(
                CopyQueue,
                pszInstallationSource,
                szPathOnSource,
                pszFileName,
                NULL,
                NULL,
                pszTargetDir,
                NULL,
                0) ) {

        *pFail = TRUE;
        return;
    }

}


VOID
BuildUpgradeInfoForDriver(
    IN      LPDRIVER_INFO_2 pDriverInfo2,
    IN      HDEVINFO        hDevInfo,
    IN      PLATFORM        platform,
    IN      LPTSTR          pszDriverDir,
    IN      LPTSTR          pszColorDir,
    IN      HINF            MasterInf,
    IN      HINF            PrinterInf,
    IN      HINF            UpgradeInf,
    IN OUT  HSPFILEQ        CopyQueue
    )
/*++

Routine Description:
    Given a printer driver name and a platform add a DRIVER_TO_ADD entry
    in the global list of drivers to add.

    The routine
        -- parses printer inf file to findout the DriverInfo3 info
           Note: driver files may change between versions
        -- finds out location of driver files from the master inf

Arguments:
    pDriverInfo2            - DriverInfo2 for the existing driver
    hDevInfo                - Printer class device information list
    platform                - Platform for which driver needs to be installed
    pszDriverDir            - Target directory for driver files
    pszColorDir             - Target directory for color files
    MasterInf               - MasterInf giving location of driver files
    PrinterInf              - Printer inf file giving driver information
    UpgradeInf              - Upgrade inf file handle
    CopyQueue               - Setup CopyQueue to queue the files to be copied

Return Value:
    None. Errors will be logged

--*/
{
    BOOL                bFail                = FALSE;
    PPSETUP_LOCAL_DATA  pLocalData           = NULL;
    DWORD               BlockingStatus       = BSP_PRINTER_DRIVER_OK;
    LPTSTR              pszNewDriverName     = NULL;
    LPTSTR              pszDriverNameSaved   = NULL;
    LPTSTR              pszNewDriverNameSaved= NULL;
    
    if (!InfIsCompatibleDriver(pDriverInfo2->pName,
                               pDriverInfo2->pDriverPath,  // full path for main rendering driver dll
                               pDriverInfo2->pEnvironment,
                               UpgradeInf,       
                               &BlockingStatus,
                               &pszNewDriverName))
    {
        goto Cleanup;
    }
         
    if (BSP_PRINTER_DRIVER_BLOCKED == (BlockingStatus & BSP_BLOCKING_LEVEL_MASK)) {
        
        
        pszDriverNameSaved = AllocStr(pDriverInfo2->pName);            
        if (!pszDriverNameSaved) 
        {
            goto Cleanup;
        }
       
        //
        // no replacement driver -> just delete the old one, do nothing else
        //
        if (!pszNewDriverName) 
        {
            AddEntryToDriversToDeleteList(pszDriverNameSaved, NULL);
            goto Cleanup;
        }

        pszNewDriverNameSaved = AllocStr(pszNewDriverName);           
        if (!pszNewDriverNameSaved) {
            LocalFreeMem(pszDriverNameSaved);
            goto Cleanup;
        }
        
        AddEntryToDriversToDeleteList(pszDriverNameSaved, pszNewDriverNameSaved);
        pLocalData = PSetupDriverInfoFromName(hDevInfo, pszNewDriverNameSaved);
    } 
       
    if ( pLocalData == NULL )
        pLocalData = PSetupDriverInfoFromName(hDevInfo, pDriverInfo2->pName);


    if ( !pLocalData || !ParseInf(hDevInfo, pLocalData, platform, NULL, 0) ) {

        bFail = TRUE;
        goto Cleanup;
    }

    if ( SetTargetDirectories(pLocalData,
                              platform,
                              NULL,
                              PrinterInf,
                              0)                                &&
         SetupInstallFilesFromInfSection(PrinterInf,
                                         NULL,
                                         CopyQueue,
                                         pLocalData->InfInfo.pszInstallSection,
                                         NULL,
                                         0) ) {

        AddEntryToDriversToAddList(pLocalData, platform, &bFail);
    } else
        bFail = TRUE;

Cleanup:
    
    if (pszNewDriverName) {
        LocalFreeMem(pszNewDriverName);
        pszNewDriverName = NULL;
    }

    if ( bFail ) {

        DestroyLocalData(pLocalData);
        //
        // Driver could be OEM so it is ok not to upgrade it
        //
        LogError(LogSevInformation, IDS_DRIVER_UPGRADE_FAILED, pDriverInfo2->pName);
    }
}


VOID
BuildUpgradeInfoForPlatform(
    IN      PLATFORM     platform,
    IN      HDEVINFO     hDevInfo,
    IN      HINF         MasterInf,
    IN      HINF         PrinterInf,
    IN      HINF         UpgradeInf,
    IN      LPTSTR       pszColorDir,
    IN OUT  HSPFILEQ     CopyQueue
    )
/*++

Routine Description:
    Build the printer driver upgrade information for the platform

Arguments:
    platform                - Platform id
    hDevInfo                - Printer class device information list
    MasterInf               - Handle to master layout.inf
    PrinterInf              - Handle to printer inf (ntprint.inf)
    UpgradeInf              - Handle to upgrade inf (printupg.inf)
    pszColorDir             - Path returned by GetColorDirectory
    CopyQueue               - Setup CopyQueue to queue the files to be copied

Return Value:
    None. Errors will be logged

--*/
{
    DWORD               dwLastError, dwNeeded, dwReturned;
    LPBYTE              p = NULL;
    LPDRIVER_INFO_2     pDriverInfo2;
    TCHAR               szTargetDir[MAX_PATH];

    if ( EnumPrinterDrivers(NULL,
                            PlatformEnv[platform].pszName,
                            2,
                            NULL,
                            0,
                            &dwNeeded,
                            &dwReturned) ) {

        //
        // Success no installed printer drivers for this platform
        //
        goto Cleanup;
    }

    dwLastError = GetLastError();
    if ( dwLastError != ERROR_INSUFFICIENT_BUFFER ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("EnumPrinterDrivers"), dwLastError);
        goto Cleanup;
    }

    p = LocalAllocMem(dwNeeded);
    if ( !p ||
         !EnumPrinterDrivers(NULL,
                             PlatformEnv[platform].pszName,
                             2,
                             p,
                             dwNeeded,
                             &dwNeeded,
                             &dwReturned) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("EnumPrinterDrivers"), dwLastError);
        goto Cleanup;
    }

    if ( !GetPrinterDriverDirectory(NULL,
                                    PlatformEnv[platform].pszName,
                                    1,
                                    (LPBYTE)szTargetDir,
                                    sizeof(szTargetDir),
                                    &dwNeeded) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("GetPrinterDriverDirectory"), dwLastError);
        goto Cleanup;
    }

    if ( !SetupSetPlatformPathOverride(PlatformOverride[platform].pszName) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupSetPlatformPathOverride"), dwLastError);
        goto Cleanup;
    }

    for ( dwNeeded = 0, pDriverInfo2 = (LPDRIVER_INFO_2) p ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pDriverInfo2 ) {

        //
        // ICM files need to be copied once only, for native architecture ..
        //
        BuildUpgradeInfoForDriver(pDriverInfo2,
                                  hDevInfo,
                                  platform,
                                  szTargetDir,
                                  platform == MyPlatform ? pszColorDir
                                                         : NULL,
                                  MasterInf,
                                  PrinterInf,
                                  UpgradeInf,
                                  CopyQueue);
    }

Cleanup:

    if ( p )
        LocalFreeMem(p);
}


VOID
InstallInternetPrintProvider(
    VOID
    )
/*++

Routine Description:
    Installs internet print provider on upgrade

Arguments:
    None

Return Value:
    None. Errors will be logged

--*/
{
    PROVIDOR_INFO_1     ProviderInfo1;


    ProviderInfo1.pName         = TEXT("Internet Print Provider");
    ProviderInfo1.pEnvironment  = NULL;
    ProviderInfo1.pDLLName      = TEXT("inetpp.dll");

    if ( !AddPrintProvidor(NULL, 1, (LPBYTE)(&ProviderInfo1)) )
        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("AddPrintProvidor"), GetLastError());

    return;
}

BOOL
KeepPreviousName(
    IN      PDRIVER_INFO_4 pEnumDrvInfo, 
    IN      DWORD          dwCount,
    IN OUT  PDRIVER_INFO_6 pCurDrvInfo
)
/*++

Routine Description:
    Modifies the DRIVER_INFO_6 of a driver to upgrade to keep the previous names setting
    of the old driver.

Arguments:
    PDRIVER_INFO_4  the array of DRIVER_INFO_4s of the installed drivers
    DWORD           number of entries in the array
    PDRIVER_INFO_6  the DRIVER_INFO_6 structure of the driver that is going to be upgraded

Return Value:
    TRUE if the previous names section was changed, FALSE if not

--*/
{
    PDRIVER_INFO_4  pCur;
    DWORD           dwIndex;
    BOOL            Changed = FALSE;

    //
    // search the current driver in the enumerated ones
    //
    for (dwIndex = 0; dwIndex < dwCount ; dwIndex++)
    {
        pCur = pEnumDrvInfo + dwIndex;

        if (!lstrcmp(pCur->pName, pCurDrvInfo->pName))
        {
            //
            // if the previous PreviousNames is not NULL/empty: set the new one to
            // the old one. I can do without additional buffers because I keep the
            // enumerated buffer around till I'm done.
            //
            if (pCur->pszzPreviousNames && *pCur->pszzPreviousNames)
            {
                pCurDrvInfo->pszzPreviousNames = pCur->pszzPreviousNames;
                Changed = TRUE;
            }
            break;
        }
    }

    return Changed;
}
    
VOID
ProcessPrinterDrivers(
    )
/*++

Routine Description:
    Process printer drivers for upgrade

Arguments:
    None

Return Value:
    None. Errors will be logged

--*/
{
    PDRIVER_TO_ADD      pCur, pNext;
    DWORD               dwNeeded, dwReturned;
    PDRIVER_INFO_4      pEnumDrv = NULL;

    //
    // Enumerate all the installed drivers. We need that later on to check for whether a 
    // previous names entry was set.
    //
    if ( !EnumPrinterDrivers(NULL,
                         PlatformEnv[MyPlatform].pszName,
                         4,
                         NULL,
                         0,
                         &dwNeeded,
                         &dwReturned) ) 
    {


        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER            ||
             !(pEnumDrv = (PDRIVER_INFO_4) LocalAllocMem(dwNeeded)) ||
             !EnumPrinterDrivers(NULL,
                                 PlatformEnv[MyPlatform].pszName,
                                 4,
                                 (LPBYTE) pEnumDrv,
                                 dwNeeded,
                                 &dwNeeded,
                                 &dwReturned) ) 
        {
            //
            // I do not want to stop the upgrade of printer drivers just because I can't 
            // keep the previous names
            //
            if (pEnumDrv)
            {
                LocalFreeMem(pEnumDrv);
                pEnumDrv   = NULL;
                dwReturned = 0;
            }
        }
    }
    

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;
        pCur->pLocalData->InfInfo.DriverInfo6.pEnvironment
                    = PlatformEnv[pCur->platform].pszName;
        
        //
        // keep previous names if set
        //
        if (pEnumDrv)
        {
            KeepPreviousName(pEnumDrv, dwReturned, &pCur->pLocalData->InfInfo.DriverInfo6);
        }

        if ( !AddPrinterDriver(NULL,
                               6,
                               (LPBYTE)&pCur->pLocalData->InfInfo.DriverInfo6)  ||
             !PSetupInstallICMProfiles(NULL,
                                       pCur->pLocalData->InfInfo.pszzICMFiles) ) {

            LogError(LogSevWarning, IDS_DRIVER_UPGRADE_FAILED,
                     pCur->pLocalData->InfInfo.DriverInfo6.pName);
        }
    }

    LocalFreeMem((PVOID) pEnumDrv);
}


VOID
ProcessBadOEMDrivers(
    )
/*++

Routine Description:
    Kill the bad OEM drivers so that they do not cause problems after upgrade

Arguments:

Return Value:
    None. Errors will be logged

--*/
{
    PDRIVER_TO_DELETE   pCur, pNext;

    PruneBadConnections( gpBadDrvList );

    for ( pCur = gpBadDrvList ; pCur ; pCur = pNext ) {

        pNext = pCur->pNext;

        DeletePrinterDriverEx(NULL,
                              PlatformEnv[PlatformX86].pszName,
                              pCur->pszDriverName,
                              DPD_DELETE_SPECIFIC_VERSION
                                    | DPD_DELETE_UNUSED_FILES,
                              2);

        DeletePrinterDriverEx(NULL,
                              PlatformEnv[PlatformAlpha].pszName,
                              pCur->pszDriverName,
                              DPD_DELETE_SPECIFIC_VERSION
                                    | DPD_DELETE_UNUSED_FILES,
                              2);

        LocalFreeMem(pCur->pszDriverName);
        LocalFreeMem(pCur->pszNewDriverName);
        LocalFreeMem(pCur);
    }
}


PPSETUP_LOCAL_DATA
FindLocalDataForDriver(
    IN  LPTSTR  pszDriverName
    )
/*++

Routine Description:
    Given a driver name find the local data for local platform for that driver

Arguments:
    pszDriverName   : Name of the printer driver we are looking for

Return Value:
    NULL if one is not found, otherwise pointer to PSETUP_LOCAL_DATA

--*/
{
    PDRIVER_TO_ADD  pCur;

    for ( pCur = gpDriversToAdd ; pCur ; pCur = pCur->pNext ) {

        if ( pCur->platform == MyPlatform   &&
             !lstrcmpi(pCur->pLocalData->InfInfo.DriverInfo6.pName,
                       pszDriverName) )
            return pCur->pLocalData;
    }

    return NULL;
}


VOID
ProcessPrintQueues(
    IN  HDEVINFO    hDevInfo,
    IN  HINF        PrinterInf,
    IN  HINF        MasterInf
    )
/*++

Routine Description:
    Process per printer upgrade for each print queue

Arguments:
    hDevInfo    - Printer class device information list
    MasterInf   - Handle to master layout.inf
    PrinterInf  - Handle to printer inf (ntprint.info)

Return Value:
    None. Errors will be logged

--*/
{
    LPBYTE              pBuf=NULL;
    DWORD               dwNeeded, dwReturned, dwRet, dwDontCare;
    HANDLE              hPrinter;
    LPTSTR              pszDriverName;
    LPPRINTER_INFO_2    pPrinterInfo2;
    PPSETUP_LOCAL_DATA  pLocalData;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    PDRIVER_TO_DELETE   pDrv;


    //
    // If no printers installed return
    //
    if ( EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      2,
                      NULL,
                      0,
                      &dwNeeded,
                      &dwReturned) ) {

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = LocalAllocMem(dwNeeded))                   ||
         !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       &dwReturned) ) {

        LocalFreeMem(pBuf);
        LogError(LogSevError, IDS_UPGRADE_FAILED, TEXT("EnumPrinters"),
                 GetLastError());
        return;
    }

    for ( pPrinterInfo2 = (LPPRINTER_INFO_2)pBuf, dwNeeded = 0 ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName, &hPrinter, &PrinterDefault) ) {

            LogError(LogSevError, IDS_PRINTER_UPGRADE_FAILED,
                     pPrinterInfo2->pPrinterName, TEXT("OpenPrinter"),
                     GetLastError());
            continue;
        }

        pszDriverName = pPrinterInfo2->pDriverName;

        //
        // See if this is in the bad driver list
        //
        for ( pDrv = gpBadDrvList ; pDrv ; pDrv = pDrv->pNext )
            if ( !lstrcmpi(pPrinterInfo2->pDriverName, pDrv->pszDriverName) )
                break;

        //
        // If this printer is using a bad OEM driver need to fix it
        //
        if ( pDrv ) {

            if ( pDrv->pszNewDriverName && *pDrv->pszNewDriverName ) {

                pszDriverName = pDrv->pszNewDriverName;
                pPrinterInfo2->pDriverName = pszDriverName;

                if ( SetPrinter(hPrinter, 2, (LPBYTE)pPrinterInfo2, 0) ) {

                    LogError(LogSevWarning, IDS_DRIVER_CHANGED,
                             pPrinterInfo2->pPrinterName);
                }
            } else {

                if ( DeletePrinter(hPrinter) ) {

                    LogError(LogSevError,
                             IDS_PRINTER_DELETED,
                             pPrinterInfo2->pPrinterName,
                             pPrinterInfo2->pDriverName);
                }
                ClosePrinter(hPrinter);
                continue; // to next printer
            }
        }

        pLocalData = FindLocalDataForDriver(pszDriverName);

        dwRet =  EnumPrinterDataEx(hPrinter,
                                   TEXT("CopyFiles\\ICM"),
                                   NULL,
                                   0,
                                   &dwDontCare,
                                   &dwDontCare);

        if ( pLocalData )
        {
            (VOID)SetPnPInfoForPrinter(hPrinter,
                                       NULL, // Don't set PnP id during upgrade
                                       NULL,
                                       pLocalData->DrvInfo.pszManufacturer,
                                       pLocalData->DrvInfo.pszOEMUrl);
        }

        ClosePrinter(hPrinter);

        //
        // If the CopyFiles\ICM key is already found then ICM has already
        // been used with this printer (i.e. we are upgrading a post NT4
        // machine). Then we want to leave the settings the user has chosen
        //
        if ( dwRet != ERROR_FILE_NOT_FOUND )
            continue;

        if ( pLocalData && pLocalData->InfInfo.pszzICMFiles ) {

            (VOID)PSetupAssociateICMProfiles(pLocalData->InfInfo.pszzICMFiles,
                                             pPrinterInfo2->pPrinterName);
        }
    }
    LocalFreeMem(pBuf);
}

VOID
ClearPnpReinstallFlag(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    DWORD dwReturn, dwConfigFlags, cbRequiredSize, dwDataType = REG_DWORD;

    //
    // get the config flags
    //
    dwReturn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                pDevInfoData,
                                                SPDRP_CONFIGFLAGS,
                                                &dwDataType,
                                                (PBYTE) &dwConfigFlags,
                                                sizeof(dwConfigFlags),
                                                &cbRequiredSize) ? 
                                                    (REG_DWORD == dwDataType ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER) 
                                                    : GetLastError();                   

    if ((ERROR_SUCCESS == dwReturn) && (dwConfigFlags & CONFIGFLAG_REINSTALL)) 
    {
        //
        // clear to flag to make setupapi not install this device on first boot
        //
        dwConfigFlags &= ~CONFIGFLAG_REINSTALL;

        dwReturn = SetupDiSetDeviceRegistryProperty(hDevInfo,
                                                    pDevInfoData,
                                                    SPDRP_CONFIGFLAGS,
                                                    (PBYTE) &dwConfigFlags,
                                                    sizeof(dwConfigFlags)) ? 
                                                        ERROR_SUCCESS : GetLastError();
    }
}

BOOL
IsInboxInstallationRequested(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData)
{
    SP_DEVINFO_DATA DevData   = {0};
    DWORD           IsInbox   = 0;
    DWORD           dwBufSize = sizeof(IsInbox);
    DWORD           dwType    = REG_DWORD;
    HKEY            hKey;

    //
    // open the dev reg key and get the rank
    //
    hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
    if (hKey != INVALID_HANDLE_VALUE)
    {
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, cszBestDriverInbox, NULL, &dwType, (LPBYTE) &IsInbox, &dwBufSize))
        {
            IsInbox = 0;
        }
    
        RegCloseKey(hKey);
    }

    return IsInbox ? TRUE : FALSE;
}

VOID    
ProcessPnpReinstallFlags(HDEVINFO hDevInfo)
{
    LPBYTE              pBuf = NULL;
    DWORD               dwNeeded, dwReturned, dwDontCare;
    HANDLE              hPrinter;
    LPPRINTER_INFO_2    pPrinterInfo2;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};
    TCHAR               szDeviceInstanceId[MAX_PATH];
    DWORD               dwType = REG_DWORD;
    SP_DEVINFO_DATA     DevData = {0};
    PDRIVER_TO_DELETE   pDrv;

    
    //
    // If no printers installed return
    //
    if ( EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      2,
                      NULL,
                      0,
                      &dwNeeded,
                      &dwReturned) ) {

        return;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = LocalAllocMem(dwNeeded))                   ||
         !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       &dwReturned) ) {

        LocalFreeMem(pBuf);
        LogError(LogSevError, IDS_UPGRADE_FAILED, TEXT("EnumPrinters"),
                 GetLastError());
        return;
    }
   
    for ( pPrinterInfo2 = (LPPRINTER_INFO_2)pBuf, dwNeeded = 0 ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        if ( !OpenPrinter(pPrinterInfo2->pPrinterName, &hPrinter, &PrinterDefault) ) {

            LogError(LogSevError, IDS_PRINTER_UPGRADE_FAILED,
                     pPrinterInfo2->pPrinterName, TEXT("OpenPrinter"),
                     GetLastError());
            continue;
        }

        //
        // Get the device instance ID
        //
        if (GetPrinterDataEx(  hPrinter,
                               cszPnPKey,
                               cszDeviceInstanceId,
                               &dwType,
                               (LPBYTE) szDeviceInstanceId,
                               sizeof(szDeviceInstanceId),
                               &dwDontCare
                               ) == ERROR_SUCCESS)
        {
            DevData.cbSize = sizeof(DevData);

            //
            // get the devnode
            //
            if (SetupDiOpenDeviceInfo(hDevInfo, szDeviceInstanceId, INVALID_HANDLE_VALUE, 0, &DevData))
            {
                //
                // if the driver that pnp wanted to install in the first place is an IHV driver, delete the
                // CONFIGFLAG_REINSTALL. That information was stored during the DIF_ALLOW_INSTALL
                // that we fail during the first phase of GUI mode setup. We want a reinstallation
                // happening in case of inbox so we replace the unsigned driver with an inbox driver and
                // and Pnp is happy because we don't switch out drivers behind their backs.
                // Side effect is that drivers that require user interaction (vendor setup or 
                // multiple Pnp matches) will require that once more after the upgrade.
                //
                if (!IsInboxInstallationRequested(hDevInfo, &DevData))
                {
                    ClearPnpReinstallFlag( hDevInfo, &DevData);
                }
            }
        }

        ClosePrinter(hPrinter);
    }
    
    LocalFreeMem(pBuf);
}

BOOL
OpenServerKey(
    OUT PHKEY  phKey
    )
{
   // Open the Servers Key
   if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwareServers, 0,
                                      KEY_ALL_ACCESS, phKey) )
   {
      return TRUE;
   }
   else if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSystemServers, 0,
                                      KEY_ALL_ACCESS, phKey) )
   {
      return TRUE;
   }
   else
      return FALSE;
}

BOOL
OpenPrintersKey(
    IN  DWORD     dwIndex,
    IN  HKEY      hInKey,
    OUT LPTSTR*   ppszServerName,
    OUT PHKEY     phOutKey
    )
{
   BOOL  bRC = TRUE;
   DWORD dwSrvSize, dwSrvRC, dwPrnLen, dwPrnRC;
   LPTSTR pszSrvPrnKey = NULL;
   TCHAR szServerName[MAX_PATH+1];

   // If we have a current ServerName free it
   if ( *ppszServerName )
   {
      LocalFreeMem( *ppszServerName );
      *ppszServerName = NULL;
   }
   if ( *phOutKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey(*phOutKey);
      *phOutKey = INVALID_HANDLE_VALUE;
   }

   dwSrvSize = COUNTOF(szServerName);
   dwSrvRC = RegEnumKey( hInKey,
                         dwIndex,
                         szServerName,
                         dwSrvSize );
   if ( dwSrvRC == ERROR_SUCCESS )
   {
      // Save the ServerName to return
      *ppszServerName = AllocStr( szServerName );
      if (!*ppszServerName)
         return FALSE;

      // Now Open the Printers key under ServerName
      dwPrnLen = lstrlen( szServerName ) + lstrlen( cszPrinters ) + 2;
      pszSrvPrnKey = (LPTSTR) LocalAllocMem( dwPrnLen * sizeof(TCHAR) );
      if ( pszSrvPrnKey )
      {
         // Build the next key name
         lstrcpy( pszSrvPrnKey, szServerName );
         lstrcat( pszSrvPrnKey, cszPrinters );
      }
      else
         return FALSE;

      dwPrnRC = RegOpenKeyEx( hInKey, pszSrvPrnKey, 0,
                              KEY_ALL_ACCESS, phOutKey );
      bRC = ( dwPrnRC == ERROR_SUCCESS );
   }
   else if ( dwSrvRC != ERROR_NO_MORE_ITEMS )
      bRC = FALSE;

   if ( pszSrvPrnKey )
      LocalFreeMem( pszSrvPrnKey );

   return bRC;
}

BOOL
GetConnectionInfo(
   IN  DWORD      dwIndex,
   IN  HKEY       hKey,
   OUT LPTSTR*    ppszConnectionName,
   OUT LPTSTR*    ppszDriverName,
   OUT LPTSTR*    ppszShareName
   )
{
   // Now enum the Connection Names
   BOOL bRC = FALSE;
   TCHAR   szConnectionName[MAX_PATH+1];
   DWORD   dwConnSize, dwConnRC, dwPrinterIndex;

   if ( *ppszConnectionName )
   {
      LocalFreeMem( *ppszConnectionName );
      *ppszConnectionName = NULL;
   }
   if ( *ppszDriverName )
   {
      LocalFreeMem( *ppszDriverName );
      *ppszDriverName = NULL;
   }

   if ( *ppszShareName )
   {
      LocalFreeMem( *ppszShareName );
      *ppszShareName = NULL;
   }

   dwConnSize = COUNTOF( szConnectionName );
   dwConnRC = RegEnumKey( hKey,
                          dwIndex,
                          szConnectionName,
                          dwConnSize );
   if ( dwConnRC == ERROR_SUCCESS )
   {
      // Now Get the Driver Model
      HKEY   hConnectionKey = INVALID_HANDLE_VALUE;

      // Save the COnnection Name
      *ppszConnectionName = AllocStr( szConnectionName );
      if ( !*ppszConnectionName )
         return FALSE;

      if ( ERROR_SUCCESS == RegOpenKeyEx( hKey, szConnectionName, 0,
                                          KEY_ALL_ACCESS, &hConnectionKey) )
      {
         DWORD dwSize, dwType;
         // Get the buffer size for the Driver Name
         if ( ERROR_SUCCESS == RegQueryValueEx(hConnectionKey, cszDriver, NULL,
                                               &dwType, NULL, &dwSize) )
         {
            *ppszDriverName = (LPTSTR) LocalAllocMem( dwSize );
            if ( *ppszDriverName &&
                 ( ERROR_SUCCESS == RegQueryValueEx(hConnectionKey, cszDriver, NULL,
                                                    &dwType, (LPBYTE) *ppszDriverName,
                                                    &dwSize) ) )
               bRC = TRUE;
         }

         // Get the buffer size for the Share Name
         if ( bRC && ( ERROR_SUCCESS == RegQueryValueEx( hConnectionKey, cszShareName, NULL,
                                                         &dwType, NULL, &dwSize) ) )
         {
            *ppszShareName = (LPTSTR) LocalAllocMem( dwSize );
            if ( *ppszShareName &&
                 ( ERROR_SUCCESS == RegQueryValueEx(hConnectionKey, cszShareName, NULL,
                                                    &dwType, (LPBYTE) *ppszShareName,
                                                    &dwSize) ) )
               bRC = TRUE;
         }
      }

      if ( hConnectionKey != INVALID_HANDLE_VALUE )
         RegCloseKey( hConnectionKey );

   }
   else if ( dwConnRC == ERROR_NO_MORE_ITEMS )
      bRC = TRUE;

   return bRC;
}

BOOL
IsDriverBad(
    IN  LPTSTR             pszDriverName,
    IN  PDRIVER_TO_DELETE  pCurBadDriver
    )
{
   BOOL bFound = FALSE;

   while ( !bFound && pCurBadDriver )
   {
      if ( !lstrcmpi( pszDriverName, pCurBadDriver->pszDriverName ) )
         bFound = TRUE;
      else
         pCurBadDriver = pCurBadDriver->pNext;
   }

   return bFound;
}

VOID
AddToBadConnList(
    IN  LPTSTR             pszServerName,
    IN  LPTSTR             pszConnectionName,
    OUT PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   // Allocate space for the Struct & String
   DWORD dwAllocSize, dwStrLen;
   LPTSTR pszSrvConn;
   PCONNECTION_TO_DELETE pBadConn;

   dwStrLen = lstrlen(pszServerName) + lstrlen(pszConnectionName) + 4;
   dwAllocSize = sizeof(CONNECTION_TO_DELETE) + ( dwStrLen * sizeof(TCHAR) );
   pBadConn = (PCONNECTION_TO_DELETE) LocalAllocMem( dwAllocSize );
   if ( pBadConn )
   {
      pszSrvConn = (LPTSTR) (pBadConn+1);
      lstrcpy( pszSrvConn, TEXT(",,") );
      lstrcat( pszSrvConn, pszServerName );
      lstrcat( pszSrvConn, TEXT(",") );
      lstrcat( pszSrvConn, pszConnectionName );

      pBadConn->pszConnectionName = pszSrvConn;
      pBadConn->pNext = *ppBadConnections;
      *ppBadConnections = pBadConn;
   }
}

VOID
DeleteSubKeys(
    IN  HKEY      hRegKey
    )
{
   BOOL  bContinue = TRUE;
   DWORD dwIndex, dwSize, dwRC;
   TCHAR szSubKeyName[MAX_PATH];
   dwIndex = 0;
   do
   {
      dwSize = COUNTOF(szSubKeyName);
      dwRC = RegEnumKey( hRegKey,
                         dwIndex,
                         szSubKeyName,
                         dwSize );
      if ( dwRC == ERROR_SUCCESS )
         DeleteRegKey( hRegKey, szSubKeyName );
      else if ( dwRC != ERROR_NO_MORE_ITEMS )
         bContinue = FALSE;
   }
   while ( bContinue && ( dwRC != ERROR_NO_MORE_ITEMS ) );
}

VOID
DeleteRegKey(
    IN  HKEY      hRegKey,
    IN  LPTSTR    pszSubKey
    )
{
   HKEY hSubKey;
   // First Open the SubKey
   if ( ERROR_SUCCESS == RegOpenKeyEx(hRegKey,
                                      pszSubKey,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hSubKey) )
   {
       DeleteSubKeys( hSubKey );
       RegCloseKey( hSubKey );
   }

   RegDeleteKey( hRegKey, pszSubKey );
}

VOID
WriteBadConnsToReg(
    IN PCONNECTION_TO_DELETE pBadConnections
    )
{
   // First Figure out how big a buffer is neeeded to hold all Connections
   PCONNECTION_TO_DELETE pCurConnection = pBadConnections;
   DWORD dwSize = 0, dwError;
   LPTSTR pszAllConnections = NULL,
          pszCurBuf = NULL,
          pszEndBuf = NULL;
   HKEY   hKey = INVALID_HANDLE_VALUE;

   if ( !pBadConnections )
      return;

   while ( pCurConnection )
   {
      dwSize += lstrlen( pCurConnection->pszConnectionName ) + 1;
      pCurConnection = pCurConnection->pNext;
   }

   dwSize++;  // Add one for the Last NULL
   pszAllConnections = LocalAllocMem( dwSize * sizeof(TCHAR) );
   if ( pszAllConnections)
   {
      pszCurBuf = pszAllConnections;
      *pszCurBuf = 0x00;
      pszEndBuf = pszAllConnections + dwSize;
      pCurConnection = pBadConnections;
      while ( pCurConnection && ( pszCurBuf < pszEndBuf ) )
      {
         // Copy the Current Connection Name
         lstrcpy( pszCurBuf, pCurConnection->pszConnectionName );
         pszCurBuf += lstrlen( pCurConnection->pszConnectionName );
         pszCurBuf++;
         pCurConnection = pCurConnection->pNext;
      }
      *pszCurBuf = 0x00;

      // Open the Registry Software\Print Key
      dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwarePrint, 0,
                             KEY_ALL_ACCESS, &hKey);
      if ( dwError == ERROR_SUCCESS )
      {
         RegSetValueEx( hKey, cszBadConnections, 0, REG_MULTI_SZ,
                        (LPBYTE) pszAllConnections,  ( dwSize * sizeof(TCHAR) ) );
      }
   }

   if ( pszAllConnections )
      LocalFreeMem( pszAllConnections );

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hKey );
}


BOOL
FindAndPruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers,
    OUT PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   BOOL    bRC = FALSE;
   HKEY    hServerKey = INVALID_HANDLE_VALUE,
           hPrinterKey = INVALID_HANDLE_VALUE;
   DWORD   dwServerIndex, dwPrinterIndex;
   LPTSTR  pszServerName = NULL,
           pszConnectionName = NULL,
           pszDriverName = NULL,
           pszShareName = NULL;


   // Open the Server Key
   if ( !OpenServerKey( &hServerKey ) )
      goto Cleanup;

   dwServerIndex = 0;
   do
   {
      // Open Printers Key for the new Server and get Server Name
      if ( !OpenPrintersKey( dwServerIndex++, hServerKey, &pszServerName, &hPrinterKey ) )
         goto Cleanup;

      if ( !pszServerName )
         break;

      dwPrinterIndex = 0;
      do
      {
         if ( !GetConnectionInfo( dwPrinterIndex++, hPrinterKey,
                                  &pszConnectionName, &pszDriverName, &pszShareName ) )
            goto Cleanup;

         if ( !pszConnectionName )
            break;

         // Check if this is a bad driver
         if ( IsDriverBad( pszDriverName, pBadDrivers ) )
         {
            AddToBadConnList( pszServerName, pszConnectionName, ppBadConnections );
            AddToBadConnList( pszServerName, pszShareName, ppBadConnections );
            DeleteRegKey( hPrinterKey, pszConnectionName );
            dwPrinterIndex--;
            LogError( LogSevError, IDS_CONNECTION_DELETED, pszConnectionName,
                      pszServerName, pszDriverName );
         }
      }
      while ( pszConnectionName );

   }
   while ( pszServerName );

   // Write all the bad connections to the Registry
   WriteBadConnsToReg( *ppBadConnections );

   bRC = TRUE;

Cleanup:
   if ( hServerKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hServerKey);
   if ( hPrinterKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hPrinterKey);

   if ( pszServerName )
      LocalFreeMem( pszServerName );
   if ( pszConnectionName )
      LocalFreeMem( pszConnectionName );
   if ( pszDriverName )
      LocalFreeMem( pszDriverName );
   if ( pszShareName )
      LocalFreeMem( pszShareName );

   return bRC;
}

BOOL
GetUserConnectionKey(
    IN  DWORD     dwIndex,
    OUT PHKEY     phKey
    )
{
   DWORD dwSize, dwRC, dwConnRC;
   TCHAR szUserKey[MAX_PATH];
   DWORD  dwConnLen;
   LPTSTR pszConnKey;

   if ( *phKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey(*phKey);
      *phKey = INVALID_HANDLE_VALUE;
   }

   dwSize = COUNTOF(szUserKey);
   dwRC = RegEnumKey( HKEY_USERS,
                      dwIndex,
                      szUserKey,
                      dwSize );
   if ( dwRC == ERROR_SUCCESS )
   {
      // Open Connections Key for this user
      dwConnLen = lstrlen( szUserKey ) + lstrlen( cszConnections ) + 3;
      pszConnKey = (LPTSTR) LocalAllocMem( dwConnLen * sizeof(TCHAR) );
      if ( pszConnKey )
      {
         // Build the next key name
         lstrcpy( pszConnKey, szUserKey );
         lstrcat( pszConnKey, cszConnections );
      }
      else
         return FALSE;

      dwConnRC = RegOpenKeyEx( HKEY_USERS, pszConnKey, 0, KEY_ALL_ACCESS, phKey );
      if (dwConnRC != ERROR_SUCCESS)
         *phKey = INVALID_HANDLE_VALUE;
   }
   else
      return FALSE;

   if ( pszConnKey )
      LocalFreeMem( pszConnKey );

   return TRUE;
}

VOID
GetMachineConnectionKey(
    OUT PHKEY     phKey
    )
{
   *phKey = INVALID_HANDLE_VALUE;
   // Open the Machine Connections Key
   if( ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSystemConnections, 0,
                                     KEY_ALL_ACCESS, phKey))
   {
       *phKey = INVALID_HANDLE_VALUE;
   }
}

BOOL
GetNextConnection(
    IN  DWORD     dwIndex,
    IN  HKEY      hKey,
    OUT LPTSTR*   ppszConnectionName
    )
{
   // Enum Connection Names
   TCHAR   szConnectionName[MAX_PATH];
   DWORD   dwConnSize, dwConnRC;

   if ( *ppszConnectionName )
   {
      LocalFreeMem( *ppszConnectionName );
      *ppszConnectionName = NULL;
   }

   dwConnSize = COUNTOF( szConnectionName );
   dwConnRC = RegEnumKey( hKey,
                          dwIndex++,
                          szConnectionName,
                          dwConnSize );
   if ( dwConnRC == ERROR_SUCCESS )
   {
      // Save the Connection Name
      *ppszConnectionName = AllocStr( szConnectionName );
      if ( !*ppszConnectionName )
         return FALSE;
   }
   else if ( dwConnRC != ERROR_NO_MORE_ITEMS )
      return FALSE;

   return TRUE;
}

BOOL
IsConnectionBad(
    IN  LPTSTR                 pszConnectionName,
    IN  PCONNECTION_TO_DELETE  pCurBadConn
    )
{
   BOOL bFound = FALSE;

   while ( !bFound && pCurBadConn )
   {
      if ( !lstrcmpi( pszConnectionName, pCurBadConn->pszConnectionName ) )
         bFound = TRUE;
      else
         pCurBadConn = pCurBadConn->pNext;
   }

   return bFound;
}

BOOL
PruneUserOrMachineEntries(
    IN  PCONNECTION_TO_DELETE pBadConnections,
    IN  BOOL                  bPruneUsers
    )
{
   BOOL    bRC = FALSE, bMoreUsers;
   DWORD   dwUserIndex = 0;
   HKEY    hConnectionKey = INVALID_HANDLE_VALUE;
   LPTSTR  pszConnectionName = NULL;
   DWORD   dwConnectionIndex;

   do
   {
      if ( bPruneUsers)
         bMoreUsers = GetUserConnectionKey( dwUserIndex++, &hConnectionKey );
      else
      {
         GetMachineConnectionKey( &hConnectionKey );
         bMoreUsers = FALSE;
      }

      if ( hConnectionKey == INVALID_HANDLE_VALUE )
         continue;

      dwConnectionIndex = 0;
      do
      {
         if ( !GetNextConnection( dwConnectionIndex++, hConnectionKey, &pszConnectionName ) )
            goto Cleanup;

         if ( pszConnectionName && IsConnectionBad( pszConnectionName, pBadConnections ) )
         {
            DeleteRegKey( hConnectionKey, pszConnectionName );
            dwConnectionIndex--;
         }
      }
      while ( pszConnectionName );
   }
   while ( bMoreUsers );

   bRC = TRUE;

Cleanup:
   if ( hConnectionKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hConnectionKey );

   if ( pszConnectionName )
      LocalFreeMem( pszConnectionName );

   return bRC;
}

VOID
ClearConnList(
    IN  PCONNECTION_TO_DELETE pCurBadConn
    )
{
   PCONNECTION_TO_DELETE pNextBadConn;
   while (pCurBadConn)
   {
      pNextBadConn = pCurBadConn->pNext;
      LocalFreeMem( pCurBadConn );
      pCurBadConn = pNextBadConn;
   }
}

BOOL
PruneBadConnections(
    IN  PDRIVER_TO_DELETE  pBadDrivers
    )
{
   BOOL bRC;
   PCONNECTION_TO_DELETE pBadConnections = NULL;

   bRC = FindAndPruneBadConnections( pBadDrivers, &pBadConnections );

   if ( bRC )
      bRC = PruneUserOrMachineEntries( pBadConnections, TRUE );

   if ( bRC )
      bRC = PruneUserOrMachineEntries( pBadConnections, FALSE );

   ClearConnList( pBadConnections );
   return( bRC );
}


DWORD
NtPrintUpgradePrinters(
    IN  HWND                    WindowToDisable,
    IN  PCINTERNAL_SETUP_DATA   pSetupData
    )
/*++

Routine Description:
    Routine called by setup to upgrade printer drivers.

    Setup calls this routine after putting up a billboard saying something like
    "Upgrading printer drivers" ...

Arguments:
    WindowToDisable     : supplies window handle of current top-level window
    pSetupData          : Pointer to INTERNAL_SETUP_DATA

Return Value:
    ERROR_SUCCESS on success, else Win32 error code
    None.

--*/
{
    HINF                MasterInf = INVALID_HANDLE_VALUE,
                        PrinterInf = INVALID_HANDLE_VALUE,
                        UpgradeInf = INVALID_HANDLE_VALUE;
    PVOID               QueueContext = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    DWORD               dwLastError = ERROR_SUCCESS, dwNeeded;
    HSPFILEQ            CopyQueue;
    BOOL                bRet = FALSE, bColor = FALSE;
    LPCTSTR             pszInstallationSource;
    TCHAR               szColorDir[MAX_PATH];

    if ( !pSetupData )
        return ERROR_INVALID_PARAMETER;

    InstallInternetPrintProvider();

    pszInstallationSource = (LPCTSTR)pSetupData->SourcePath; //ANSI wont work

    //
    // Create a setup file copy queue.
    //
    CopyQueue = SetupOpenFileQueue();
    if ( CopyQueue == INVALID_HANDLE_VALUE ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupOpenFileQueue"), GetLastError());
        goto Cleanup;
    }

    //
    // Open ntprint.inf -- all the printer drivers shipped with NT should
    // be in ntprint.inf
    //
    PrinterInf  = SetupOpenInfFile(cszNtprintInf, NULL, INF_STYLE_WIN4, NULL);
    MasterInf   = SetupOpenInfFile(cszSyssetupInf, NULL, INF_STYLE_WIN4, NULL);
    UpgradeInf  = SetupOpenInfFile(cszUpgradeInf, NULL, INF_STYLE_WIN4, NULL);

    if ( PrinterInf == INVALID_HANDLE_VALUE ||
         MasterInf == INVALID_HANDLE_VALUE  ||
         UpgradeInf == INVALID_HANDLE_VALUE ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("SetupOpenInfFile"), GetLastError());
        goto Cleanup;
    }

    //
    // Build printer driver class list
    //
    hDevInfo = CreatePrinterDeviceInfoList(WindowToDisable);

    if ( hDevInfo == INVALID_HANDLE_VALUE   ||
         !PSetupBuildDriversFromPath(hDevInfo, cszNtprintInf, TRUE) ) {

        LogError(LogSevError, IDS_UPGRADE_FAILED,
                 TEXT("Building driver list"), GetLastError());
        goto Cleanup;
    }

    ProcessPnpReinstallFlags(hDevInfo);

    dwNeeded = sizeof(szColorDir);
    bColor = GetColorDirectory(NULL, szColorDir, &dwNeeded);

    BuildUpgradeInfoForPlatform(MyPlatform,
                                hDevInfo,
                                MasterInf,
                                PrinterInf,
                                UpgradeInf,
                                bColor ? szColorDir : NULL,
                                CopyQueue);

    //
    // If no printer drivers to upgrade we are done
    //
    if ( !gpDriversToAdd && !gpBadDrvList ) {

        bRet = TRUE;
        goto Cleanup;
    }

    //
    // Copy the printer driver files over
    //
    if ( gpDriversToAdd )
    {
        QueueContext = SetupInitDefaultQueueCallbackEx( WindowToDisable, INVALID_HANDLE_VALUE, 0, 0, NULL );
        if ( !QueueContext ) {

            LogError(LogSevError, IDS_UPGRADE_FAILED,
                     TEXT("SetupInitDefaultQueue"), GetLastError());
            goto Cleanup;
        }

        if ( !SetupCommitFileQueue(WindowToDisable,
                                   CopyQueue,
                                   SetupDefaultQueueCallback,
                                   QueueContext) ) {

            LogError(LogSevError, IDS_UPGRADE_FAILED,
                     TEXT("SetupCommitFileQueue"), GetLastError());
            goto Cleanup;
        }

        ProcessPrinterDrivers();
    }

    ProcessPrintQueues(hDevInfo, PrinterInf, MasterInf);
    FreeDriversToAddList();
    ProcessBadOEMDrivers();

    bRet            = TRUE;

Cleanup:

    if ( !bRet )
        dwLastError = GetLastError();

    if ( QueueContext )
        SetupTermDefaultQueueCallback(QueueContext);

    if ( CopyQueue != INVALID_HANDLE_VALUE )
        SetupCloseFileQueue(CopyQueue);

    if ( PrinterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(PrinterInf);

    if ( MasterInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(MasterInf);

    if ( UpgradeInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile(UpgradeInf);
    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    CleanupScratchDirectory(NULL, PlatformAlpha);
    CleanupScratchDirectory(NULL, PlatformX86);
    CleanupScratchDirectory(NULL, PlatformMIPS);
    CleanupScratchDirectory(NULL, PlatformPPC);
    CleanupScratchDirectory(NULL, PlatformWin95);
    CleanupScratchDirectory(NULL, PlatformIA64);
    CleanupScratchDirectory(NULL, PlatformAlpha64);

    // Cleanup the Connection Cache
    DeleteCache();

    (VOID) SetupSetPlatformPathOverride(NULL);

    return dwLastError;
}

/*++

Routine Name

    DeleteSubkeys

Routine Description:

    Deletes the subtree of a key in registry.
    The key and ites values remeain, only subkeys are deleted

Arguments:

    hKey - handle to the key

Return Value:

    Error code of the operation

--*/

DWORD
DeleteSubkeys(
    HKEY hKey
    )
{
    DWORD    cchData;
    TCHAR    SubkeyName[MAX_PATH];
    HKEY     hSubkey;
    LONG     Status;
    FILETIME ft;

    cchData = SIZECHARS(SubkeyName);

    while ( ( Status = RegEnumKeyEx( hKey, 0, SubkeyName, &cchData,
                                   NULL, NULL, NULL, &ft ) ) == ERROR_SUCCESS )
    {
        Status = RegCreateKeyEx(hKey, SubkeyName, 0, NULL, 0,
                                KEY_READ | KEY_WRITE, NULL, &hSubkey, NULL );

        if (Status == ERROR_SUCCESS)
        {
            Status = DeleteSubkeys(hSubkey);
            RegCloseKey(hSubkey);
            if (Status == ERROR_SUCCESS)
                RegDeleteKey(hKey, SubkeyName);
        }

        //
        // N.B. Don't increment since we've deleted the zeroth item.
        //
        cchData = SIZECHARS(SubkeyName);
    }

    if( Status == ERROR_NO_MORE_ITEMS)
        Status = ERROR_SUCCESS;

    return Status;
}


/*++

Routine Name

    RemoveRegKey

Routine Description:

    Deletes the subtree of a key in registry.
    The key and ites values remeain, only subkeys are deleted

Arguments:

    pszKey - location of the key in registry
    Ex: "\\Software\\Microsoft"

Return Value:

    Error code of the operation

--*/

DWORD
RemoveRegKey(
    IN LPTSTR pszKey
    )
{
    DWORD LastError;
    HKEY  hRootKey;

    LastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0,
                             KEY_ALL_ACCESS, &hRootKey);

    if (LastError != ERROR_SUCCESS)
    {
        DBGMSG( DBG_TRACE, ("RemoveRegKey RegOpenKeyEx Error %d\n", LastError));
    }
    else
    {
        LastError = DeleteSubkeys(hRootKey);
        
        RegCloseKey(hRootKey);
    }

    return LastError;
}


/*++

Routine Name

    DeleteCache

Routine Description:

    Deletes the printer connection cache, including the old location in Registry

Arguments:

    None

Return Value:

    Error code of the operation

--*/

DWORD
DeleteCache(
    VOID
    )
{
    DWORD  LastError;
    LPTSTR pszRegWin32Root = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers");
    LPTSTR pszPrevWin32CacheLocation = TEXT("System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers");

    LastError = RemoveRegKey(pszPrevWin32CacheLocation);

    LastError = RemoveRegKey(pszRegWin32Root);

    return LastError;
}


VOID
GetBadConnsFromReg(
    IN PCONNECTION_TO_DELETE *ppBadConnections
    )
{
   // Open the Key in the User Space
   // First Figure out how big a buffer is neeeded to hold all Connections
   PCONNECTION_TO_DELETE pCurConnection;
   DWORD dwSize, dwError, dwType;
   LPTSTR pszAllConnections = NULL,
          pszCurBuf = NULL,
          pszEndBuf = NULL;
   HKEY   hKey = INVALID_HANDLE_VALUE;

   // Open the Registry Software\Print Key
   dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszSoftwarePrint, 0,
                          KEY_READ, &hKey);

   if ( dwError != ERROR_SUCCESS )
      return;

   // Get the buffer size for the Share Name
   if ( ERROR_SUCCESS == RegQueryValueEx( hKey, cszBadConnections, NULL,
                                          &dwType, NULL, &dwSize) )
   {
      pszAllConnections = (LPTSTR) LocalAllocMem( dwSize );
      if ( pszAllConnections &&
           ( ERROR_SUCCESS == RegQueryValueEx(hKey, cszBadConnections, NULL,
                                              &dwType, (LPBYTE) pszAllConnections,
                                              &dwSize) ) )
      {
         // Build all the Bad Connection structures
         DWORD dwAllocSize, dwStrLen;
         PCONNECTION_TO_DELETE pBadConn;

         pszCurBuf = pszAllConnections;

         while ( ( dwStrLen = lstrlen(pszCurBuf) ) > 0 )
         {
            dwAllocSize = sizeof(CONNECTION_TO_DELETE) + ( (dwStrLen+1) * sizeof(TCHAR) );
            pBadConn = (PCONNECTION_TO_DELETE) LocalAllocMem( dwAllocSize );
            if ( pBadConn )
            {
               pBadConn->pszConnectionName = (LPTSTR) (pBadConn+1);
               lstrcpy( pBadConn->pszConnectionName, pszCurBuf );
               pBadConn->pNext = *ppBadConnections;
               *ppBadConnections = pBadConn;
            }
            else
               break;

            pszCurBuf +=  dwStrLen + 1;
         }
      }
   }

   // Free up the Allocated Mem
   if ( pszAllConnections )
      LocalFreeMem( pszAllConnections );

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey( hKey );

}

VOID
PSetupKillBadUserConnections(
    VOID
    )
{
   BOOL bRC;
   PCONNECTION_TO_DELETE pBadConnections = NULL;

   GetBadConnsFromReg( &pBadConnections );

   PruneUserOrMachineEntries( pBadConnections, TRUE );

   ClearConnList( pBadConnections );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\srvinst.cxx ===
/*++

  Copyright (c) 1995-97 Microsoft Corporation
  All rights reserved.

  Module Name:

        SrvInst.c

  Purpose:


        Server side install code.  This code will be called from a process created by the spooler to do a
        "server" side install of a printer driver.

  Author:

        Patrick Vine (pvine) - 22 March 2000

  Revision History:

--*/

#include "precomp.h"

#pragma hdrstop
#include "srvinst.hxx"

const TCHAR   gcszNTPrint[]  = _TEXT("inf\\ntprint.inf");
const TCHAR   gcszPrintKey[] = _TEXT("SYSTEM\\CurrentControlSet\\Control\\Print");
const TCHAR   gcszTimeOut[]  = _TEXT("ServerInstallTimeOut");
const TCHAR   gcSpace        = _TEXT(' ');
#define DEFAULT_MAX_TIMEOUT    300000 // 5 minute timeout.


/*++

Routine Name:

    ServerInstall

Routine Description:

    Server side install code to be called by a process created by spooler.

Arguments:

    hwnd            - Window handle of stub window.
    hInstance,      - Rundll instance handle.
    pszCmdLine      - Pointer to command line.
    nCmdShow        - Show command value always TRUE.

Return Value:

    Returns the last error code.  This can be read by the spooler by getting the return code from the process.

--*/
DWORD
ServerInstallW(
    IN HWND        hwnd,
    IN HINSTANCE   hInstance,
    IN LPCTSTR     pszCmdLine,
    IN UINT        nCmdShow
    )
{
    CServerInstall Installer;

    if( Installer.ParseCommand( (LPTSTR)pszCmdLine) && Installer.OpenPipe())
    {
        if( Installer.GetInstallParameters() )
            Installer.InstallDriver();

        Installer.SendError();
        Installer.ClosePipe();
    }

    return Installer.GetLastError();
}

////////////////////////////////////////////////////////////////////////////////
//
// Method definitions for CServerInstall Class.
//
////////////////////////////////////////////////////////////////////////////////

CServerInstall::
CServerInstall() : _dwLastError(ERROR_SUCCESS),
                   _tsDriverName(),
                   _tsInf(),
                   _tsSource(),
                   _tsFlags(),
                   _tsPipeName(),
                   _hPipe(INVALID_HANDLE_VALUE)
{
    SetMaxTimeOut();
}

CServerInstall::
~CServerInstall()
{
    ClosePipe();
}

void
CServerInstall::
SetMaxTimeOut()
{
    HKEY  hKey;
    DWORD dwDummy;
    DWORD dwSize = sizeof(_dwMaxTimeOut);

    _dwMaxTimeOut = DEFAULT_MAX_TIMEOUT;
    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, gcszPrintKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        if(RegQueryValueEx( hKey, gcszTimeOut, 0, &dwDummy, (LPBYTE)&_dwMaxTimeOut, &dwSize ) != ERROR_SUCCESS)
        {
            _dwMaxTimeOut = DEFAULT_MAX_TIMEOUT;
        }
        RegCloseKey( hKey );
    }
}

BOOL
CServerInstall::
InstallDriver()
{

    if(  SetInfDir() &&
         bValidateSourcePath() &&
         DriverNotInstalled() )
    {
        _dwLastError = ::InstallDriverSilently(_tsInf, _tsDriverName, _tsSource);
    }

    return (_dwLastError == ERROR_SUCCESS);
}


/*++

    Parameter structure:

          1st word : Flags = default == 0 for now

          if flags = 0
             2nd word : Pipe name to open

--*/
BOOL
CServerInstall::
ParseCommand( LPTSTR pszCommandStr )
{
    TCHAR * pTemp;
    DWORD   dwCount = 0;

    //
    // If we don't have a valid command string
    //
    if( !pszCommandStr || !*pszCommandStr )
    {
        _dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Lets grab the flags field
    //
    pTemp = _tcschr( pszCommandStr, gcSpace );
    if( !pTemp )
    {
        //
        // No flags field, fail.
        //
        _dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    *(pTemp++) = 0;
    if( !_tsFlags.bUpdate( pszCommandStr ))
    {
        _dwLastError = ::GetLastError();
        goto Cleanup;
    }

    //
    //  Currently we only have one case - so we don't need to worry about the
    //  flags nor branch on them.  however we may want to in the future.
    //

    //
    // The rest of the command line is the pipe's name.
    //
    if( !_tsPipeName.bUpdate( pTemp ))
        _dwLastError = ::GetLastError();

Cleanup:
    return (_dwLastError == ERROR_SUCCESS);
}

BOOL
CServerInstall::
GetInstallParameters()
{
    if(!GetOneParam( &_tsDriverName ))
        goto Done;

    if( _tsDriverName.bEmpty() )
    {
        _dwLastError = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    if(!GetOneParam( &_tsInf ))
        goto Done;

    GetOneParam( &_tsSource );

Done:
    return (_dwLastError == ERROR_SUCCESS);
}


//
// Read the size of the string to follow from the pipe.
// Then reads the string and places it in the TString passed.
//
BOOL
CServerInstall::
GetOneParam( TString * tString )
{
    DWORD  dwSize    = 0;
    DWORD  dwRet     = 0;
    LPTSTR pszString = NULL;
    LPVOID pData     = NULL;

    if( !ReadOverlapped( _hPipe, &dwSize, sizeof(dwSize), &dwRet ))
        goto Done;

    if( dwSize == 0 )
        goto Done;

    //
    // The data that we're receiving will be WCHARs as spooler only works with UNICODE.
    //
    if(!(pData = LocalAllocMem((dwSize + 1)*sizeof(WCHAR))))
    {
        _dwLastError = ::GetLastError();
        goto Done;
    }

    if( !ReadOverlapped( _hPipe, pData, dwSize*sizeof(WCHAR), &dwRet ) )
        goto Done;

    if( dwRet != dwSize*sizeof(WCHAR) )
        _dwLastError = ERROR_INVALID_PARAMETER;

//
// Because ntprint compiles to both unicode and ansi we need to do this conversion.
// The string coming in will be unicode as it comes from spooler which only
// uses wchars.
//
#ifdef UNICODE
    pszString = (LPTSTR)pData;
    pData = NULL;
#else
    //Get the length of the unicode string
    dwSize = WideCharToMultiByte( CP_ACP, 0, (LPWSTR)pData, -1, NULL, 0, NULL, NULL );

    //Create the TCHAR string of the same length
    if( !(pszString = (LPTSTR)LocalAllocMem((dwSize + 1)*sizeof(TCHAR))))
        goto Done;

    //Convert the string from unicode to ansi.
    if( !WideCharToMultiByte( CP_ACP, 0, (LPWSTR)pData, -1, pszString, dwSize, NULL, NULL ) )
    {
        _dwLastError = ::GetLastError();
    }
#endif

Done:
    if( !tString->bUpdate( pszString ))
        _dwLastError = ::GetLastError();

    if( pData )
        LocalFreeMem( pData );

    if( pszString )
        LocalFreeMem( pszString );

    return (_dwLastError == ERROR_SUCCESS);
}


DWORD
CServerInstall::
GetLastError()
{
    SetLastError(_dwLastError);
    return _dwLastError;
}


BOOL
CServerInstall::
SetInfDir()
{
    if( _tsInf.bEmpty() )
    {
        SetInfToNTPRINTDir();
    }
    else
    {
        //
        // The inf name must be fully qualified.
        //
        TCHAR  szFullInfName[MAX_PATH];
        LPTSTR pszDummy;
        DWORD  dwLength = GetFullPathName( _tsInf, COUNTOF( szFullInfName ), szFullInfName, &pszDummy );

        if( !dwLength || !_tsInf.bUpdate( szFullInfName ))
            _dwLastError = ::GetLastError();
    }

    return (_dwLastError == ERROR_SUCCESS);
}


//
//  Returns: TRUE if SUCCESS, FALSE otherwise
//
//  Sets the _stInf string to contain %windir%\inf\ntprint.inf
//
BOOL
CServerInstall::
SetInfToNTPRINTDir()
{
    UINT   uiSize        = 0;
    UINT   uiAllocSize   = 0;
    PTCHAR pData         = NULL;
    TCHAR  szNTPrintInf[MAX_PATH];

    _dwLastError = ERROR_INVALID_DATA;

    //
    //  Get %windir%
    //  If the return is 0 - the call failed.
    //  If the return is greater than MAX_PATH we want to fail as something has managed to change
    //  the system dir to longer than MAX_PATH which is invalid.
    //
    uiSize = GetSystemWindowsDirectory( szNTPrintInf, COUNTOF(szNTPrintInf) );
    if( !uiSize || uiSize > COUNTOF(szNTPrintInf) )
        goto Cleanup;

    //
    // If we don't end in a \ then add one.
    //
    pData = &szNTPrintInf[ _tcslen(szNTPrintInf) ];
    if( *pData != _TEXT('\\') )
        *(pData++) = _TEXT('\\');

    *(pData) = 0;
    uiSize = _tcslen( szNTPrintInf ) + _tcslen( gcszNTPrint ) + 1;

    //
    // If what we've got sums up to a longer string than the allowable length MAX_PATH - fail
    //
    if( uiSize > COUNTOF(szNTPrintInf) )
        goto Cleanup;

    //
    //  Copy the inf\ntprint.inf string onto the end of the %windir%\ string.
    //
    _tcscpy( pData, gcszNTPrint );

    _dwLastError = ERROR_SUCCESS;

Cleanup:

    if( _dwLastError != ERROR_SUCCESS && szNTPrintInf )
    {
        //
        // Got here due to some error.  Get what the called function set the last error to.
        // If the function set a success, set some error code.
        //
        if( (_dwLastError = ::GetLastError()) == ERROR_SUCCESS )
            _dwLastError = ERROR_INVALID_DATA;

        szNTPrintInf[0] = 0;
    }

    if( !_tsInf.bUpdate( szNTPrintInf ) )
        _dwLastError = ::GetLastError();

    return (_dwLastError == ERROR_SUCCESS);
}


BOOL
CServerInstall::
bValidateSourcePath(
    )
{
    if( !_tsSource.bEmpty() &&
        !(GetFileAttributes( (LPCTSTR)_tsSource ) & FILE_ATTRIBUTE_DIRECTORY) )
    {
        _dwLastError = ERROR_DIRECTORY;
    }

    return (_dwLastError == ERROR_SUCCESS);
}


BOOL
CServerInstall::
OpenPipe()
{
    if( !_tsPipeName.bEmpty() )
    {
        _hPipe = CreateFile( _tsPipeName,
                             GENERIC_WRITE | GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED,
                             NULL );

        if( _hPipe == INVALID_HANDLE_VALUE )
            _dwLastError = ::GetLastError();
    }
    else
        _dwLastError = ERROR_INVALID_HANDLE;

    return (_dwLastError == ERROR_SUCCESS);
}


BOOL
CServerInstall::
SendError()
{
    DWORD dwDontCare;

    return (WriteOverlapped( _hPipe, &_dwLastError, sizeof(_dwLastError), &dwDontCare ));
}


BOOL
CServerInstall::
ClosePipe()
{
    BOOL bRet = TRUE;

    if( _hPipe != INVALID_HANDLE_VALUE )
    {
        bRet = CloseHandle( _hPipe );
        _hPipe = INVALID_HANDLE_VALUE;
    }

    return bRet;
}

BOOL
CServerInstall::
ReadOverlapped( HANDLE  hFile,
                LPVOID  lpBuffer,
                DWORD   nNumberOfBytesToRead,
                LPDWORD lpNumberOfBytesRead )
{
    if( hFile != INVALID_HANDLE_VALUE )
    {
        OVERLAPPED Ov;

        ZeroMemory( &Ov,sizeof(Ov));

        if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }

        if( !ReadFile( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, &Ov ) &&
            ::GetLastError() != ERROR_IO_PENDING )
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }

        if( WaitForSingleObject(Ov.hEvent, _dwMaxTimeOut) == WAIT_TIMEOUT )
        {
            CancelIo(hFile);
            WaitForSingleObject(Ov.hEvent, INFINITE);
        }

        if( !GetOverlappedResult(hFile, &Ov, lpNumberOfBytesRead, FALSE) )
            _dwLastError = ::GetLastError();

Cleanup:
        if ( Ov.hEvent )
            CloseHandle(Ov.hEvent);
    }
    else
        _dwLastError = ERROR_INVALID_HANDLE;

    return (_dwLastError == ERROR_SUCCESS);
}

BOOL
CServerInstall::
WriteOverlapped( HANDLE  hFile,
                 LPVOID  lpBuffer,
                 DWORD   nNumberOfBytesToRead,
                 LPDWORD lpNumberOfBytesRead )
{
    if( hFile != INVALID_HANDLE_VALUE )
    {
        OVERLAPPED Ov;

        ZeroMemory( &Ov,sizeof(Ov));

        if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }

        if( !WriteFile( hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, &Ov ) &&
            ::GetLastError() != ERROR_IO_PENDING )
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }

        if( WaitForSingleObject(Ov.hEvent, _dwMaxTimeOut) == WAIT_TIMEOUT )
        {
            CancelIo(hFile);
            WaitForSingleObject(Ov.hEvent, INFINITE);
        }

        if( !GetOverlappedResult(hFile, &Ov, lpNumberOfBytesRead, FALSE) )
            _dwLastError = ::GetLastError();

Cleanup:
        if ( Ov.hEvent )
            CloseHandle(Ov.hEvent);
    }
    else
        _dwLastError = ERROR_INVALID_HANDLE;

    return (_dwLastError == ERROR_SUCCESS);
}


/*+

  This function enumerates the drivers and finds if there is one of the same name currently installed.
  If there is then open the inf to install with and verify that the inf's version date is newer than the
  already installed driver.

  Returns: TRUE  - if anything fails or the installed date isn't newer than the inf date.
           FALSE - only if the driver is installed AND it's date is newer than the inf's date.

-*/
BOOL
CServerInstall::
DriverNotInstalled()
{
    LPCTSTR             pszKey       = _TEXT("DriverVer");
    LPTSTR              pszEntry     = NULL;
    LPDRIVER_INFO_6     pDriverInfo6 = NULL;
    LPBYTE              pBuf         = NULL;
    PSP_INF_INFORMATION pInfo        = NULL;
    SYSTEMTIME          Time         = {0};
    BOOL                bRet         = TRUE;
    DWORD               dwLength,
                        dwRet,
                        dwIndex;
    TCHAR               *pTemp,
                        *pTemp2;

    if(!EnumPrinterDrivers( NULL, PlatformEnv[MyPlatform].pszName, 6, pBuf, 0, &dwLength, &dwRet ))
    {
        if( ::GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            return TRUE;

        if( (pBuf = (LPBYTE) AllocMem( dwLength )) == NULL ||
            !EnumPrinterDrivers( NULL, PlatformEnv[MyPlatform].pszName, 6, pBuf, dwLength, &dwLength, &dwRet ))
        {
            _dwLastError = ::GetLastError();
            goto Cleanup;
        }
    }
    else
    {
        //
        // Only way this could succeed is if no drivers installed.
        //
        _dwLastError = ERROR_UNKNOWN_PRINTER_DRIVER;
        return TRUE;
    }

    for( dwIndex = 0, pDriverInfo6 = (LPDRIVER_INFO_6)pBuf; dwIndex < dwRet; dwIndex++, pDriverInfo6++ )
    {
        if( _tcscmp( pDriverInfo6->pName, (LPCTSTR)_tsDriverName ) == 0 )
            break;
    }

    if(dwIndex >= dwRet)
    {
        //
        // Driver not found
        //
        _dwLastError = ERROR_UNKNOWN_PRINTER_DRIVER;
        goto Cleanup;
    }

    //
    // The driver has been found...  Open up inf and look at it's date.
    //

    //
    // Firstly get the size that will be needed for pInfo.
    //
    if( !SetupGetInfInformation( (LPCTSTR)_tsInf, INFINFO_INF_NAME_IS_ABSOLUTE, pInfo, 0, &dwLength ) )
    {
        _dwLastError = ::GetLastError();
        goto Cleanup;
    }

    //
    // Alloc pInfo and fill it.
    //
    if( (pInfo = (PSP_INF_INFORMATION) AllocMem( dwLength )) != NULL &&
        SetupGetInfInformation( (LPCTSTR)_tsInf, INFINFO_INF_NAME_IS_ABSOLUTE, pInfo, dwLength, &dwLength ) )
    {
        //
        //  Get the size of the date string
        //
        if( SetupQueryInfVersionInformation( pInfo, 0, pszKey, pszEntry, 0, &dwLength ))
        {
            //
            // Alloc pszEntry and fill it.
            //
            if( (pszEntry = (LPTSTR) AllocMem( dwLength*sizeof(TCHAR) )) != NULL &&
                SetupQueryInfVersionInformation( pInfo, 0, pszKey, pszEntry, dwLength, &dwLength ))
            {
                //
                // Now convert the date string into a SYSTEMTIME
                // Date is of the form 03/22/2000
                //
                // Get the month - 03 part
                //
                if( (pTemp = _tcschr( pszEntry, _TEXT('/'))) != NULL )
                {
                    *pTemp++ = 0;
                    Time.wMonth = (WORD)_ttoi( pszEntry );
                    pTemp2 = pTemp;

                    //
                    // Get the day - 22 part
                    //
                    if( (pTemp = _tcschr( pTemp2, _TEXT('/'))) != NULL )
                    {
                        *pTemp++ = 0;
                        Time.wDay = (WORD)_ttoi( pTemp2 );
                        pTemp2 = pTemp;

                        //
                        // Get the year - 2000 part
                        //
                        pTemp = _tcschr( pTemp2, _TEXT('/'));
                        if( pTemp )
                            *pTemp = 0;
                        Time.wYear = (WORD)_ttoi( pTemp2 );
                    }
                    else
                        _dwLastError = ERROR_INVALID_PARAMETER;
                }
                else
                    _dwLastError = ERROR_INVALID_PARAMETER;
            }
            else
                _dwLastError = ::GetLastError();
        }
        else
            _dwLastError = ::GetLastError();
    }
    else
        _dwLastError = ::GetLastError();


    //
    //  If we got all the way to filling in the year, we may have something useful...
    //
    if( Time.wYear )
    {
        FILETIME ftTime = {0};
        if(SystemTimeToFileTime( &Time, &ftTime ))
        {
            //
            // If the inf time is more recent than what is installed,
            // reinstall, otherwise don't
            //
            if( CompareFileTime(&ftTime, &pDriverInfo6->ftDriverDate) < 1 )
            {
                bRet = FALSE;
            }
        }
        //
        // Getting here and return TRUE or FALSE is still a successful call.
        //
        _dwLastError = ERROR_SUCCESS;
    }
    else
        _dwLastError = ERROR_INVALID_PARAMETER;

Cleanup:
    if( pBuf )
        FreeMem( pBuf );

    if( pInfo )
        FreeMem( pInfo );

    if( pszEntry )
        FreeMem( pszEntry );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\ci.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Ci.c

Abstract:

    Class installer test program

Author:


Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <initguid.h>
#include <devguid.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>

#include "..\splsetup.h"

HDEVINFO    hDevInfo;

void
DoInstallWizard(
    )
{
    SP_INSTALLWIZARD_DATA InstWizData;

    ZeroMemory(&InstWizData, sizeof(SP_INSTALLWIZARD_DATA));
    InstWizData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    InstWizData.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
    InstWizData.hwndWizardDlg = 0;

    if ( !SetupDiSetClassInstallParams(hDevInfo,
                                       NULL,
                                       &InstWizData.ClassInstallHeader,
                                       sizeof(InstWizData),
                                       NULL) ) {

        printf("SetupDiSetClassInstallParams fails with %d\n", GetLastError());
        return;
    }

    SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hDevInfo, NULL);
    SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hDevInfo, NULL);
}


void
InstallDevice(
    )
{
    SP_DEVINFO_DATA     DevInfoData;
    DWORD               Error;
    HKEY                hKey;

    do {

        PSetupSelectDriver(hDevInfo);

        if ( GetLastError() != ERROR_SUCCESS )
            break;
        
        DevInfoData.cbSize = sizeof(DevInfoData);
        if ( !SetupDiCreateDeviceInfo(hDevInfo,
                                      TEXT("Printer"),
                                      (LPGUID)&GUID_DEVCLASS_PRINTER,
                                      NULL,
                                      0,
                                      DICD_GENERATE_ID | DICD_INHERIT_CLASSDRVS,
                                      &DevInfoData) ) {

            printf("SetupDiCreateDeviceInfo failed with %d\n", GetLastError());
            continue;
        }

        if ( Error = CM_Open_DevNode_Key(DevInfoData.DevInst,
                                         KEY_WRITE,
                                         0,
                                         RegDisposition_OpenAlways,
                                         &hKey,
                                         CM_REGISTRY_HARDWARE) ) {

            printf("CM_Open_DevNode_Key failed with %d\n", Error);
            continue;
        }

        if ( Error = RegSetValueEx(hKey,
                                   TEXT("PortName"), 
                                   NULL,
                                   REG_SZ,  
                                   TEXT("LPT1:"),
                                   (lstrlen(TEXT("LPT1")) + 1 ) * sizeof(TCHAR)) ) {

            printf("RegSetValueEx failed with %d\n", Error);
            continue;
        }

        RegCloseKey(hKey);

        SetupDiCallClassInstaller(DIF_INSTALLDEVICE, hDevInfo, &DevInfoData);
    } while ( 1 );

}


void
InstallDriver(
    )
{
}

int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD   dwLastError;

    hDevInfo = PSetupCreatePrinterDeviceInfoList(0);

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {

        printf("%s: PSetupCreatePrinterDeviceInfoList fails with %d\n",
               argv[0], GetLastError());
        return 0;
    }

    DoInstallWizard();
    InstallDevice();

    PSetupDestroyPrinterDeviceInfoList(hDevInfo);
}


void
DumpDriverInfo3(
    LPDRIVER_INFO_3 p3
    )
{
    LPTSTR   pp;

    printf("\tDriverInfo3:\n");
    printf("\t----------------------------------------------------------\n");
    printf("Driver Name     : %ws\n", p3->pName);
    printf("Driver File     : %ws\n", p3->pDriverPath);
    printf("Config File     : %ws\n", p3->pConfigFile);
    printf("Data File       : %ws\n", p3->pDataFile);
    printf("Help File       : %ws\n", p3->pHelpFile);

    if ( p3->pDependentFiles && *p3->pDependentFiles ) {

        printf("Dependent File  : ");
        for ( pp = p3->pDependentFiles; pp && *pp ; pp += wcslen(pp) + 1 )
            printf("%ws ", pp);
       printf("\n");
    } else
        printf("Dependent File  : %ws\n", p3->pDependentFiles);

    printf("Monitor Name    : %ws\n", p3->pMonitorName);
    printf("DefaultData     : %ws\n", p3->pDefaultDataType);
}

void
DumpSelectedDriver(
    HDEVINFO    hDevInfo
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\drv.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Drv.c

Abstract:

    Test driver installation

Author:


Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>

#include "..\splsetup.h"

BOOL    Dbg1 = TRUE;
void
DumpSelectedDriver(
    HDEVINFO  hDevInfo
    );

BOOL    Dbg2 = TRUE;
void
DumpDriverInfo3(
    LPDRIVER_INFO_3 p3
    );

BOOL    Dbg3 = TRUE;
void
InstallDriver(
    HDEVINFO    hDevInfo,
    HANDLE      h
    );

HDEVINFO    hDevInfo;

int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD   dwLastError;

    hDevInfo = PSetupCreatePrinterDeviceInfoList(0);

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {

        printf("%s: PSetupCreatePrinterDeviceInfoList fails with %d\n",
               argv[0], GetLastError());
        return 0;
    }

    do {

        PSetupSelectDriver(hDevInfo);

        dwLastError = GetLastError();
        if ( !dwLastError )
            DumpSelectedDriver(hDevInfo);
        
        if ( !PSetupRefreshDriverList(hDevInfo) ) {

            printf("%s: PSetupRefreshDriverList fails with %d\n",
                   argv[0], GetLastError());
        }

    } while ( dwLastError == ERROR_SUCCESS);

    printf("%s: Exiting because of last error %d\n", argv[0], GetLastError());

    PSetupDestroyPrinterDeviceInfoList(hDevInfo);
    
}

void
DumpSelectedDriver(
    HDEVINFO    hDevInfo
    )
{
    HANDLE          h;
    DRIVER_FIELD    DrvField;

    if ( !Dbg1 )
        return;

    h = PSetupGetSelectedDriverInfo(hDevInfo);

    if ( !h ) {

        printf("PSetupBuildDriverInfo fails with %d\n", GetLastError());
        return;
    }

    DrvField.Index = DRV_INFO_3;
    if ( !PSetupGetLocalDataField(h, PSetupThisPlatform(), &DrvField) ) {

        printf("PSetupGetLocalDataField fails with %d\n", GetLastError());
        return;
    }
    
    DumpDriverInfo3(DrvField.pDriverInfo3);
    InstallDriver(hDevInfo,
                  h);

Cleanup:
    PSetupFreeDrvField(&DrvField);
    PSetupDestroySelectedDriverInfo(h);
}


void
DumpDriverInfo3(
    LPDRIVER_INFO_3 p3
    )
{
    LPTSTR   pp;

    printf("\tDriverInfo3:\n");
    printf("\t----------------------------------------------------------\n");
    printf("Driver Name     : %ws\n", p3->pName);
    printf("Driver File     : %ws\n", p3->pDriverPath);
    printf("Config File     : %ws\n", p3->pConfigFile);
    printf("Data File       : %ws\n", p3->pDataFile);
    printf("Help File       : %ws\n", p3->pHelpFile);

    if ( p3->pDependentFiles && *p3->pDependentFiles ) {

        printf("Dependent File  : ");
        for ( pp = p3->pDependentFiles; pp && *pp ; pp += wcslen(pp) + 1 )
            printf("%ws ", pp);
       printf("\n");
    } else
        printf("Dependent File  : %ws\n", p3->pDependentFiles);

    printf("Monitor Name    : %ws\n", p3->pMonitorName);
    printf("DefaultData     : %ws\n", p3->pDefaultDataType);
}

void
InstallDriver(
    HDEVINFO    hDevInfo,
    HANDLE      h
    
    )
{
    DWORD   dwLastError;

    if ( !Dbg3 )
        return;

    dwLastError = PSetupInstallPrinterDriver(hDevInfo,
                                             h,
                                             PlatformX86,
                                             3,
                                             NULL,
                                             0,
                                             L"X86",
                                             NULL);

    if ( dwLastError ) {

        printf(":PSetupeInstallPrinterDriver fails with %d\n", GetLastError());
    }

    dwLastError = PSetupInstallPrinterDriver(hDevInfo,
                                             h,
                                             PlatformMIPS,
                                             3,
                                             NULL,
                                             0,
                                             L"MIPS",
                                             NULL);

    if ( dwLastError ) {

        printf(":PSetupeInstallPrinterDriver fails with %d\n", GetLastError());
    }

    dwLastError = PSetupInstallPrinterDriver(hDevInfo,
                                             h,
                                             PlatformAlpha,
                                             3,
                                             NULL,
                                             0,
                                             L"Alpha",
                                             NULL);

    if ( dwLastError ) {

        printf(":PSetupeInstallPrinterDriver fails with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win95.c ===
/*++

Copyright (c) 1995-97 Microsoft Corporation
All rights reserved.

Module Name:

    Win95.c

Abstract:

    Routines for installing win95 driver files

Author:

    Muhunthan Sivapragasam (MuhuntS) 30-Nov-1995

Revision History:

--*/

#include "precomp.h"

const TCHAR cszPrtupg9x[]               = TEXT("prtupg9x.inf");
const TCHAR cszPrinterDriverMapping[]   = TEXT("Printer Driver Mapping");
const TCHAR cszPrinterDriverMappingNT[] = TEXT("Printer Driver Mapping WINNT");

void
CutLastDirFromPath(LPTSTR pszPath)
/*++

Routine Description:
    Cuts of the last directory from a path, e.g. c:\a\b\c\f.x -> c:\a\b\f.x

Arguments:
    pszPath  : the path to operate on

Return Value:
    none

--*/
{
    LPTSTR pLastWhack, pSecondButLastWhack;

    pLastWhack = _tcsrchr(pszPath, _T('\\'));
    if (!pLastWhack)
    {
       return;
    }

    *pLastWhack = 0;
    pSecondButLastWhack = _tcsrchr(pszPath, _T('\\'));
    if (!pSecondButLastWhack)
    {
       return;
    }

    _tcscpy(pSecondButLastWhack+1, pLastWhack+1);
}

BOOL
CopyDriverFileAndModPath(LPTSTR pszPath)

/*++

Routine Description:
    Copies a driver file from the original location one dir up and modifies the
    path name accordingly

Arguments:
    pszPath  : the path of the file to copy and to operate on

Return Value:
    TRUE if OK, FALSE on error

--*/
{
    BOOL  bRes    = TRUE;
    TCHAR *pszTmp = NULL;

    if (!pszPath)
    {
        goto Cleanup; // nothing to copy
    }

    pszTmp = AllocStr( pszPath );
    if (!pszTmp) 
    {
        bRes = FALSE;
        goto Cleanup;
    }

    CutLastDirFromPath(pszPath);
    bRes = CopyFile(pszTmp, pszPath, FALSE);

Cleanup:
   
    LocalFreeMem( pszTmp );
    return bRes;
}

BOOL
CopyDependentFiles(LPTSTR pszzDepFiles)
/*++

Routine Description:
    Copies the dependent files one directory up and modifies the name buffers.

Arguments:
    pszzDepFiles  : the multi-sz string containing the pathes of the files to
                    copy and to operate on

Return Value:
    TRUE if OK, FALSE on error

--*/
{
    LPTSTR pCur = pszzDepFiles, pBuf = NULL, pCurCopy;
    DWORD  ccBufLen;
    BOOL   bRet = FALSE;

    if (pszzDepFiles == NULL)
    {
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // count the total length of the buffer
    //
    for (ccBufLen = 0;
         *(pszzDepFiles + ccBufLen) != 0;
         ccBufLen += _tcslen(pszzDepFiles + ccBufLen) + 1)
             ;

    ccBufLen +=2; // for the two terminating zeros

    pBuf = LocalAllocMem(ccBufLen * sizeof(TCHAR));
    if (!pBuf)
    {
         goto Cleanup;
    }


    //
    // go through the source buffer file by file, modify names and copy files
    //
    for (pCur = pszzDepFiles, pCurCopy = pBuf;
         *pCur != 0;
         pCur += _tcslen(pCur) +1, pCurCopy += _tcslen(pCurCopy) +1)
    {
        _tcscpy(pCurCopy, pCur);
        CutLastDirFromPath(pCurCopy);
        if (!CopyFile(pCur, pCurCopy, FALSE))
        {
            goto Cleanup;
        }
    }

    //
    // 00-terminate the new buffer
    //
    *pCurCopy = 0;
    *(++pCurCopy) = 0;

    //
    // copy it back - the new version is always shorter than the original
    //
    CopyMemory(pszzDepFiles, pBuf, (pCurCopy - pBuf + 1) * sizeof(TCHAR));

    bRet = TRUE;

Cleanup:
    if (pBuf)
    {
        LocalFreeMem(pBuf);
    }

    return bRet;
}

BOOL
SetPreviousNamesSection(LPCTSTR pszServer, LPCTSTR pszModelName,
                        LPCTSTR pszAddPrevName)

/*++

Routine Description:
    Adds a printer name to the list of previous names of a W2k/NT4 driver.
    This makes the driver usable under that name for point-and-print.
    To change the previous name section, do another call to AddPrinterDriver
    with all the files in place

Arguments:
    pszServer       : the machine we're operating on.
    pszModelName    : the model name of the native driver
    pszAddPrevName  : the name of the Win9x driver to be added to the previous
                      names entry.

Return Value:
    TRUE if OK, FALSE on error.

--*/
{
    PBYTE         pBuf = NULL;
    DRIVER_INFO_6 *pDrvInfo6 = NULL;
    DWORD         cbNeeded, cReceived, i;
    BOOL          bRet = FALSE;
    LPTSTR        pTmp;
    TCHAR         pArch[MAX_PATH];

    //
    // previous names section only supported from Whistler upwards
    //
    if (!IsWhistlerOrAbove(pszServer))
    {
        bRet = TRUE;
        goto Cleanup;
    }

    cbNeeded = COUNTOF(pArch);

    if(!GetArchitecture( pszServer, pArch, &cbNeeded ))
    {
        _tcsncpy( pArch, PlatformEnv[MyPlatform].pszName, COUNTOF(pArch) );
    }

    //
    // Check whether the name is different in the first place
    //
    if (!_tcscmp(pszModelName, pszAddPrevName))
    {
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // Get the DRIVER_INFO_6 of the W2k driver
    //
    EnumPrinterDrivers((LPTSTR) pszServer, pArch, 6, pBuf,
                        0, &cbNeeded, &cReceived);

    pBuf = LocalAllocMem(cbNeeded);
    if (!pBuf)
    {
        goto Cleanup;
    }

    if (!EnumPrinterDrivers((LPTSTR) pszServer, pArch, 6, pBuf,
                        cbNeeded, &cbNeeded, &cReceived))
    {
        goto Cleanup;
    }

    for (i = 0; i < cReceived ; i++)
    {
        pDrvInfo6 = (DRIVER_INFO_6 *) (pBuf + i*sizeof(DRIVER_INFO_6));
        if (!_tcscmp(pszModelName, pDrvInfo6->pName))
        {
            break;
        }
    }

    //
    // was the corresponding W2k driver found ?
    //
    if (i == cReceived)
    {
        //
        // Couldn't find the W2k driver to set the previous names section on.
        // This must be the AddPrinterDriver wizard, else there would be one. 
        // Just let the user install this driver.
        //
        bRet = TRUE;
        goto Cleanup;
    }

    //
    // check whether the name to add is already in the list
    //
    if (pDrvInfo6->pszzPreviousNames)
    {
        for (pTmp = pDrvInfo6->pszzPreviousNames; *pTmp; pTmp += _tcslen(pTmp) +1)
        {
            if (!_tcscmp(pTmp, pszAddPrevName))
            {
                bRet = TRUE;
                goto Cleanup;
            }
        }
    }

    //
    // Copy all the files into the driver dir
    //
    if (!CopyDriverFileAndModPath(pDrvInfo6->pDriverPath) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pConfigFile) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pDataFile) ||
        !CopyDriverFileAndModPath(pDrvInfo6->pHelpFile) ||
        !CopyDependentFiles(pDrvInfo6->pDependentFiles))
    {
        goto Cleanup;
    }

    //
    // Modify the PreviousNames section.
    // No reallocation since string lives in the same buffer as the DrvInfo6 !
    // +2 for the psz terminating zero and the second zero for the whole
    //
    pDrvInfo6->pszzPreviousNames = LocalAllocMem((_tcslen(pszAddPrevName) + 2) * sizeof(TCHAR));

    if (!pDrvInfo6->pszzPreviousNames)
    {
        goto Cleanup;
    }

    _tcscpy(pDrvInfo6->pszzPreviousNames, pszAddPrevName);

    //
    // write the driver info 6 back
    //
    bRet = AddPrinterDriver((LPTSTR) pszServer, 6, (LPBYTE) pDrvInfo6);

    LocalFreeMem (pDrvInfo6->pszzPreviousNames);

Cleanup:
    if (pBuf)
    {
        LocalFreeMem (pBuf);
    }

    return bRet;
}

DWORD
InstallWin95Driver(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszModel,
    IN      LPCTSTR     pszzPreviousNames,
    IN      BOOL        bPreviousNamesSection,
    IN      LPCTSTR     pszServerName,
    IN  OUT LPTSTR      pszInfPath,
    IN      LPCTSTR     pszDiskName,
    IN      DWORD       dwInstallFlags,
    IN      DWORD       dwAddDrvFlags
    )
/*++

Routine Description:
    List all the printer drivers from Win95 INF files and install the
    printer driver selected by the user

Arguments:
    hwnd                    : Window handle that owns the UI
    pszModel                : Printer driver model
    pszzPreviousNames       : Multi-sz string giving other names for the driver
    bPreviousNamesSection   : If TRUE the NT inf had a Previous Names section
    pszServerName           : Server for which driver is to be installed
                                (NULL : local)
    pszInfPath              : Default path for inf. Prompt will have this name
                              for user
    pszDiskName             : Name of the disk to prompt for and use in title
    dwInstallFlags          : Installation flags given by caller
    dwAddDrvFlags           : Flags for AddPrinterDriverEx

Return Value:
    On succesfully installing files ERROR_SUCCESS, else the error code

--*/
{
    BOOL                bFreeDriverName=FALSE, bFirstTime=TRUE;
    DWORD               dwNeeded, dwRet = ERROR_CANCELLED;
    TCHAR               szTargetPath[MAX_PATH];
    LPDRIVER_INFO_6     pDriverInfo6 = NULL;
    PPSETUP_LOCAL_DATA  pLocalData = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;

Retry:
    //
    // If we get here second time that means default path has INFs but not the
    // model we are looking for. Ex. an OEM driver in the previous names section
    // that is not on Win2K CD. So make sure we prompt
    //
    if ( !bFirstTime )
    {
        dwInstallFlags |= DRVINST_ALT_PLATFORM_INSTALL;
        if (pszInfPath)
        {
            *pszInfPath = 0;
        }
    }

    hDevInfo = GetInfAndBuildDrivers(hwnd,
                                     IDS_DRIVERS_FOR_WIN95,
                                     IDS_PROMPT_ALT_PLATFORM_DRIVER,
                                     pszInfPath,
                                     dwInstallFlags, PlatformWin95, 0,
                                     NULL, NULL, NULL);

    if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
         !SetSelectDevParams(hDevInfo, NULL, TRUE, pszModel) ) {

        goto Cleanup;
    }

    //
    // First look for an exact model match.
    //
    // If previous name is found then we will allow one retry since now we
    // have some previous names with no driver on CD (since it is an OEM driver)
    // If previous name is not found ask user to select a model
    //
    if ( !(pDriverInfo6 = Win95DriverInfo6FromName(hDevInfo,
                                                   &pLocalData,
                                                   pszModel,
                                                   pszzPreviousNames)) ) {

        if ( bPreviousNamesSection ) {

            if ( bFirstTime == TRUE ) {

                ASSERT(pLocalData == NULL);
                DestroyOnlyPrinterDeviceInfoList(hDevInfo);
                hDevInfo = INVALID_HANDLE_VALUE;
                bFirstTime = FALSE;
                goto Retry;
            }
        } 
        
        if ( (dwInstallFlags & DRVINST_PROMPTLESS) == 0)
        {
            PVOID       pDSInfo = NULL;   // Holds pointer to the driver signing class that C can't understand.
            HSPFILEQ    CopyQueue;
            SP_DEVINSTALL_PARAMS    DevInstallParams = {0};

            DevInstallParams.cbSize = sizeof(DevInstallParams);
            
            DestroyOnlyPrinterDeviceInfoList(hDevInfo);
            
            hDevInfo = CreatePrinterDeviceInfoList(hwnd);
            
            if ( hDevInfo == INVALID_HANDLE_VALUE                       ||
                 !SetDevInstallParams(hDevInfo, NULL, pszInfPath))
            {
                DWORD dwLastError;
                dwLastError = GetLastError();
                DestroyOnlyPrinterDeviceInfoList(hDevInfo);
                hDevInfo = INVALID_HANDLE_VALUE;
                SetLastError(dwLastError);
                goto Cleanup;
            }
            
            CopyQueue = SetupOpenFileQueue();
            if ( CopyQueue == INVALID_HANDLE_VALUE )
            {
                goto Cleanup;
            }

            //
            // associate the queue with the HDEVINFO
            //
            
            if ( SetupDiGetDeviceInstallParams(hDevInfo,
                                               NULL,
                                               &DevInstallParams) ) 
            {
                DevInstallParams.Flags |= DI_NOVCP;
                DevInstallParams.FileQueue = CopyQueue;

                SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DevInstallParams);
            }
            
            if (NULL == (pDSInfo = SetupDriverSigning(hDevInfo, pszServerName, NULL,
                                         pszInfPath, PlatformWin95, 0, CopyQueue, FALSE)))
            {
                SetupCloseFileQueue(CopyQueue);
                goto Cleanup;
            }

            if ( BuildClassDriverList(hDevInfo)                          &&
                 PSetupSelectDriver(hDevInfo)                            &&                 
                 (pLocalData = BuildInternalData(hDevInfo, NULL))        &&
                 ParseInf(hDevInfo, pLocalData, PlatformWin95,
                            pszServerName, dwInstallFlags) ) 
            {

                LPCTSTR pDriverName;

                pDriverInfo6 = CloneDriverInfo6(&pLocalData->InfInfo.DriverInfo6,
                                               pLocalData->InfInfo.cbDriverInfo6);
    
                //
                // if setup selected a "compatible" driver: 
                // pre-Whistler: rename the compatible driver to the requested model name
                // on Whistler: set the driver name to the compatible one and set the previous names section accordingly
                //
                if (IsWhistlerOrAbove(pszServerName))
                {
                    pDriverName = pLocalData->DrvInfo.pszModelName;
                }
                else
                {
                    pDriverName = pszModel;
                }
                
                if ( pDriverInfo6 && (pDriverInfo6->pName = AllocStr(pDriverName)) )
                {
                    bFreeDriverName = TRUE;
                }

            }
            //
            // disassociate the queue before deleting it
            //
            
            DevInstallParams.Flags    &= ~DI_NOVCP;
            DevInstallParams.FlagsEx  &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            DevInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(hDevInfo, NULL, &DevInstallParams);

            SetupCloseFileQueue(CopyQueue);
            
            CleanupDriverSigning(pDSInfo);
        }
    }
    else if (lstrcmp(pDriverInfo6->pName, pszModel))
    {
        //
        // if the driver was selected because of an entry in the previous names section
        // then on anything before Whistler we need to rename the driver to the queue driver's name
        //
        if (!IsWhistlerOrAbove(pszServerName))
        {
            if (pDriverInfo6->pName = AllocStr(pszModel) )
            {
                bFreeDriverName = TRUE;
            }
        }
    }


    if ( !pDriverInfo6 || !pDriverInfo6->pName )
        goto Cleanup;

    pDriverInfo6->pEnvironment = PlatformEnv[PlatformWin95].pszName;


    //
    // For Win95 driver pszzPreviousNames does not make sense
    //
    ASSERT(pDriverInfo6->pszzPreviousNames == NULL);

    if ( GetPrinterDriverDirectory((LPTSTR)pszServerName,
                                   pDriverInfo6->pEnvironment,
                                   1,
                                   (LPBYTE)szTargetPath,
                                   sizeof(szTargetPath),
                                   &dwNeeded)               &&
         CopyPrinterDriverFiles(pDriverInfo6,
                                pLocalData->DrvInfo.pszInfName,
                                pszInfPath,
                                pszDiskName,
                                szTargetPath,
                                hwnd,
                                dwInstallFlags,
                                TRUE)                       &&
         SetPreviousNamesSection(pszServerName, pszModel,
                                 (LPCTSTR) pLocalData->DrvInfo.pszModelName) &&
         AddPrinterDriverUsingCorrectLevel(pszServerName,
                                           pDriverInfo6,
                                           dwAddDrvFlags)
        )

    {
        dwRet = ERROR_SUCCESS;
    }


Cleanup:

    if (pLocalData)
    {
        DestroyLocalData(pLocalData);
        pLocalData = NULL;
    }

    if ( dwRet != ERROR_SUCCESS )
        dwRet = GetLastError();

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        DestroyOnlyPrinterDeviceInfoList(hDevInfo);

    if ( pDriverInfo6 ) {

        if ( bFreeDriverName )
            LocalFreeMem(pDriverInfo6->pName);
        PSetupDestroyDriverInfo3((LPDRIVER_INFO_3)pDriverInfo6);
    }

    CleanupScratchDirectory(pszServerName, PlatformWin95);
    CleanupScratchDirectory(pszServerName, PlatformX86);

    return dwRet;
}

/*++

Routine Name:

    PSetupFindMappedDriver
    
Routine Description:

    Find the remapped NT printer driver name for the given driver name. If the
    function does not find a remapped driver, it simply returns the name that was
    passed in. This looks in the [Printer Driver Mapping] and 
    [Printer Driver Mapping WINNT] sections of prtupg9x.inf.

Arguments:

    bWinNT                  -   If TRUE, find this from the WINNT section.
    pszDriverName           -   The driver name to be remapped.
    ppszRemappedDriverName  -   The remapped driver name, allocated and returned
                                to the caller. (Free with PSetupFreeMem).
    pbDriverFound           -   If TRUE, the driver was remapped. Otherwise, the
                                output is simpy a copy of the input.

Return Value:

    If there is an unexpected error, FALSE, otherwise TRUE. Last Error has the
    error code.

--*/
BOOL
PSetupFindMappedDriver(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    )
{
    HINF        hInf                    = INVALID_HANDLE_VALUE;
    BOOL        bRet                    = FALSE;
    BOOL        bFound                  = FALSE;
    LPTSTR      pszRemappedDriverName   = NULL;
    INFCONTEXT  InfContext;
    TCHAR       szNtName[LINE_LEN];
    
    bRet = pszDriverName && ppszRemappedDriverName && pbDriverFound;

    if (ppszRemappedDriverName)
    {
        *ppszRemappedDriverName = NULL;
    }

    if (pbDriverFound)
    {
        *pbDriverFound = FALSE;
    }

    if (!bRet)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    //
    // Open ntprint.inf, it should be in the %windir%\inf directory.
    //
    if (bRet)
    {
        hInf = SetupOpenInfFile(cszPrtupg9x, NULL, INF_STYLE_WIN4, NULL);

        bRet = hInf != INVALID_HANDLE_VALUE;
    }

    //
    // Find the driver in the appropriate Printer Driver Mapping section of the
    // inf.
    //
    if (bRet)
    {
        bFound = SetupFindFirstLine(hInf, bWinNT ? cszPrinterDriverMappingNT : cszPrinterDriverMapping, pszDriverName, &InfContext);

        //
        // Get the name of the in-box driver.
        // 
        if (bFound)
        {
            bRet = SetupGetStringField(&InfContext, 1, szNtName, COUNTOF(szNtName), NULL);        
        }
        else if (ERROR_LINE_NOT_FOUND != GetLastError())
        {
            bRet = FALSE;
        }
    }

    //
    // If we found the driver, return it. Otherwise, just allocate and return the
    // string that was passed in.
    //
    if (bRet)
    {
        if (bFound)
        {
             pszRemappedDriverName = AllocStr(szNtName);

             *pbDriverFound = pszRemappedDriverName != NULL;
        }
        else
        {
            //
            // The remapped driver is not in the inf. Return the one we were passed in.
            //
            pszRemappedDriverName = AllocStr(pszDriverName);
        }

        bRet = pszRemappedDriverName != NULL;
    }

    if (bRet)
    {
        *ppszRemappedDriverName = pszRemappedDriverName;
        pszRemappedDriverName = NULL;
    }

    if (hInf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hInf);
    }

    if (pszRemappedDriverName)
    {
        LocalFreeMem(pszRemappedDriverName);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\upg.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Drv.c

Abstract:

    Test driver installation

Author:


Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <prsht.h>
#include <syssetup.h>

int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main (argc, argv)
    int argc;
    char *argv[];
{
    INTERNAL_SETUP_DATA IntSetupData;
    WCHAR               szPath[] = L"C:\\$WIN_NT$.~LS";
    HANDLE              hModule;
    DWORD               (*upg)(HWND, PCINTERNAL_SETUP_DATA);

    ZeroMemory(&IntSetupData, sizeof(IntSetupData));
    IntSetupData.SourcePath     = szPath;
    IntSetupData.OperationFlags = 0;

    hModule = LoadLibrary(L"ntprint");
    if ( !hModule ) 
        return(0);

    (FARPROC)upg = GetProcAddress(hModule, (LPCSTR)1);

    if ( !upg )
        return 0;

    (*upg)(NULL, &IntSetupData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\fileio.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileIo.c

Abstract:

    Routines to do File IO for the migration of Win95 printing to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 24-Aug-1998

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop


CHAR
My_fgetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a character from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   cbRead;

    if ( ReadFile(hFile, (LPBYTE)&c, sizeof(c), &cbRead, NULL)  &&
         cbRead == sizeof(c) )
        return c;
    else
        return (CHAR) EOF;
}


LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a line, or at most n characters from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   dwRead;
    LPSTR   ptr;

    ptr = pszBuf;
    while ( --dwSize > 0 && (c = My_fgetc(hFile)) != EOF )
        if ( (*ptr++ = c) == '\n' )
            break;

    *ptr = '\0';
    return ( c == EOF && ptr == pszBuf ) ? NULL : pszBuf;
}


DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    )
/*++

Routine Description:
    Read at most dwSize bytes to buffer

Arguments:

Return Value:
    Number of bytes read

--*/
{
    DWORD   cbRead;

    return  ReadFile(hFile, pBuf, dwSize, &cbRead, NULL) ? cbRead : 0;
}


BOOL
My_ungetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Unread one character

Arguments:

Return Value:

--*/
{
    return SetFilePointer(hFile, -1, NULL, FILE_CURRENT) != 0xFFFFFFFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\pnpid.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    PnpId.c

Abstract:
    Generate pnp hardware id from model manufacturer

Author:


Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

WORD    wCRC16a[16]={
    0000000,    0140301,    0140601,    0000500,
    0141401,    0001700,    0001200,    0141101,
    0143001,    0003300,    0003600,    0143501,
    0002400,    0142701,    0142201,    0002100,
};

WORD    wCRC16b[16]={
    0000000,    0146001,    0154001,    0012000,
    0170001,    0036000,    0024000,    0162001,
    0120001,    0066000,    0074000,    0132001,
    0050000,    0116001,    0104001,    0043000,
};

//
// From win95
//
#define MAX_DEVNODE_NAME_ROOT   20

USHORT
GetCheckSum(
    PBYTE   ptr,
    ULONG   ulSize
    )
{
    BYTE    byte;
    USHORT  CS=0;

    for ( ; ulSize ; --ulSize, ++ptr) {

        byte = (BYTE)(((WORD)*ptr)^((WORD)CS));  // Xor CRC with new char
        CS      = ((CS)>>8) ^ wCRC16a[byte&0x0F] ^ wCRC16b[byte>>4];
    }

    printf("Check sum: %04X\n", CS);
    return CS;
}


int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main (argc, argv)
    int argc;
    char *argv[];
{
    TCHAR   szHwId[100], szCheckSum[10],
            szDevNodeName[100], *p;
    USHORT  usCheckSum;
    DWORD   dwLastError, dwcbHardwareIDSize;

    if ( argc != 3 ) {

        printf("Usage: %s ""Manufacturer Name"" ""Model Name""\n", argv[0]);
        return 0;
    }

    lstrcpy(szHwId, argv[1]);
    lstrcat(szHwId, argv[2]);

    usCheckSum = GetCheckSum(szHwId, strlen(szHwId));
    sprintf( szCheckSum, "%04X", usCheckSum );

    dwcbHardwareIDSize = strlen(argv[1]) + strlen(argv[2]);
    if ( dwcbHardwareIDSize > MAX_DEVNODE_NAME_ROOT )
        dwcbHardwareIDSize  = MAX_DEVNODE_NAME_ROOT;

    szHwId[dwcbHardwareIDSize] = TEXT('\0');

    for ( p = szHwId ; p = strchr(p, TEXT(' ')) ; )
        *p = TEXT('_');

    lstrcat(szHwId, szCheckSum);

    lstrcpy(szDevNodeName, TEXT("LPTENUM"));
    lstrcat(szDevNodeName, TEXT("\\"));
    lstrcat(szDevNodeName, szHwId);

    printf("Hardware Id :   %s\n", szHwId);
    printf("Devnode name:   %s\n", szDevNodeName);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\mon.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Monitor.c

Abstract:

    Test monitor installation

Author:


Revision History:


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>

#include "..\splsetup.h"

int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main (argc, argv)
    int argc;
    char *argv[];
{
    HANDLE  h;
    DWORD   dwLastError, dwNeeded, dwIndex;
    WCHAR   szName[MAX_PATH];

    h = PSetupCreateMonitorInfo(0, FALSE);

    if ( !h ) {

        printf("%s: PSetupCreateMonitorInfo fails with %d\n",
               argv[0], GetLastError());
        return 0;
    }

    do {

        dwNeeded = MAX_PATH; // change in PSetupEnumMonitor to take char count instead of byte count
        for ( dwIndex = 0 ;
              PSetupEnumMonitor(h, dwIndex, szName, &dwNeeded) ;
              ++dwIndex ) {

            printf("%s: Monitor %ws\n", argv[0], szName);
            if ( !PSetupInstallMonitor(h, 0, szName) ) {

                printf("%s: PSetupInstallMonitor fails with %d for %ws\n",
               argv[0], GetLastError(), szName);
            }
        }

        dwLastError = GetLastError();
    } while ( dwLastError == ERROR_SUCCESS);

    printf("%s: Exiting because of last error %d\n", argv[0], GetLastError());

    if ( h )
        PSetupDestroyMonitorInfo(h);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\fileq.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileQ.c

Abstract:

    File queue routines for upgrade

Author:

    Muhunthan Sivapragasam (MuhuntS) 22-Jan-1996

Revision History:

--*/


#include "precomp.h"


//
// If the source disk is missing we will retry it 4 times waiting for
// 3 seconds between every try
//
#define     MISSING_MEDIA_RETRY_COUNT           4
#define     MISSING_MEDIA_RETRY_INTERVAL     3000


typedef struct _FILE_QUEUE_CONTEXT {

    PVOID   QueueContext;
} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;


UINT
MyQueueCallback(
    IN  PVOID   QueueContext,
    IN  UINT    Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:
    File queue callback routine for the upgrade. We will not prompt the user
    for missing file. But we will retry few times before failing

Arguments:
    QueueContext    : Points to FILE_QUEUE_CONTEXT
    Notification    : The event which is being notified
    Param1          : Depends on the notification
    Param2          : Depends on the notification

Return Value:
    None

--*/
{
    PFILE_QUEUE_CONTEXT     pFileQContext=(PFILE_QUEUE_CONTEXT)QueueContext;
    PSOURCE_MEDIA_W         pSource;
    PFILEPATHS_W            pFilePaths;

    switch (Notification) {

        case SPFILENOTIFY_COPYERROR:
            //
            // We know atleast pjlmon will be missing since it is copied
            // during textmode setup
            //
            pFilePaths = (PFILEPATHS_W) Param1;

            DebugMsg("Error %d copying %ws to %ws.",
                     pFilePaths->Win32Error, pFilePaths->Source,
                     pFilePaths->Target);

            return FILEOP_SKIP;

        case SPFILENOTIFY_NEEDMEDIA:
            pSource = (PSOURCE_MEDIA_W)Param1;

            //
            // Setup is going to add \i386 to the end. Tell it to look
            // right in the directory we give. Particularly needed for the
            // upgrade over the network case
            //
            if ( wcscmp(pSource->SourcePath, UpgradeData.pszSourceW) ) {

                wcscpy((LPWSTR)Param2, UpgradeData.pszSourceW);
                return FILEOP_NEWPATH;
            }

            DebugMsg("Error copying %ws from %ws.",
                     pSource->SourceFile, pSource->SourcePath);

            return FILEOP_SKIP;
    }

    return SetupDefaultQueueCallbackW(pFileQContext->QueueContext,
                                      Notification,
                                      Param1,
                                      Param2);
}


BOOL
InitFileCopyOnNT(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    On NT we will call ntprint.dll via SetupDiCallClassInstaller api with the
    DI_NOVCP flag so that all the necessary printer driver files are queued
    and copied at the end.

    This sets the necessary queue etc before calling the class installer

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    HSPFILEQ                    CopyQueue;
    PFILE_QUEUE_CONTEXT         pFileQContext;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;

    //
    // Call the current device installation parameters
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    //
    // Set the parameters so that ntprint will just queue files and not commit
    // the file copy operations
    //
    if ( !(pFileQContext = AllocMem(sizeof(FILE_QUEUE_CONTEXT))) )
        goto Cleanup;

    pFileQContext->QueueContext = SetupInitDefaultQueueCallbackEx(
                                            INVALID_HANDLE_VALUE,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);

    DevInstallParams.FileQueue                  = SetupOpenFileQueue();
    DevInstallParams.InstallMsgHandlerContext   = pFileQContext;
    DevInstallParams.InstallMsgHandler          = MyQueueCallback;
    DevInstallParams.Flags                     |= DI_NOVCP;
    DevInstallParams.hwndParent                 = INVALID_HANDLE_VALUE;

    //
    // The files should be from the source dir
    //
    wcscpy(DevInstallParams.DriverPath, UpgradeData.pszSourceW);

    if ( DevInstallParams.FileQueue == INVALID_HANDLE_VALUE     ||
         pFileQContext->QueueContext == NULL                    ||
         !SetupDiSetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) ) {

        if ( DevInstallParams.FileQueue != INVALID_HANDLE_VALUE )
            SetupCloseFileQueue(DevInstallParams.FileQueue);

        if ( pFileQContext->QueueContext )
            SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    } else {

        bRet = TRUE;
    }

Cleanup:

    if ( !bRet )
        FreeMem(pFileQContext);

    return bRet;
}


BOOL
CommitFileQueueToCopyFiles(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    After calling ntprint for each printer driver to queue up the files this
    routine is called to commit the file queue and do the actual file copy
    operations

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;
    PFILE_QUEUE_CONTEXT         pFileQContext;

    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    pFileQContext = DevInstallParams.InstallMsgHandlerContext;

    bRet = SetupCommitFileQueueW(DevInstallParams.hwndParent,
                                 DevInstallParams.FileQueue,
                                 DevInstallParams.InstallMsgHandler,
                                 pFileQContext);

    SetupCloseFileQueue(DevInstallParams.FileQueue);
    SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    FreeMem(pFileQContext);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\makefile.inc ===
all: msg.h msg.rc msg00001.bin msg.mc

clean: cleansrc all

cleansrc:
    -erase msg.h msg00001.bin msg.rc msg.mc

msg.mc: $(BASE_INC_PATH)\vendinfo.mc
        copy $(BASE_INC_PATH)\vendinfo.mc msg.mc

msg.h msg00001.bin msg.rc:msg.mc
        mc -A -v msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\test\infcreate.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Create New Inf from Old Inf

Author:

    Muhunthan Sivapragasam (MuhuntS) 5-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#define COUNT   1000
#define LEN       25
#define LEN2      55
#define MANF       4

int
main (argc, argv)
    int argc;
    char *argv[];
{
    FILE    *OldInf, *NewInf;
    char    Line[MAX_PATH];
    char    *DriverName, *ui, *secn, *type, *p;
    char    Section[COUNT][LEN], Model[COUNT][LEN2];
    int     i, Lines;

    if ( argc != 3 ) {

        printf("Usage: %s <old-inf-name> <new-inf-name>\n", argv[0]);
        return;
    }

    OldInf = NewInf = NULL;

    OldInf      = fopen(argv[1], "r");
    NewInf      = fopen(argv[2], "w");
    
    if ( !OldInf ) {

        printf("%s: Can't open %s to read\n", argv[0], argv[1]);
        goto Cleanup;
    }
    
    if ( !NewInf ) {

        printf("%s: Can't open %s to write\n", argv[0], argv[2]);
        goto Cleanup;
    }

    Lines = 0;

    while ( fgets(Line, MAX_PATH-1, OldInf) ) {

        DriverName  = strtok(Line+1, "\"");
        strtok(NULL, "=");
        ui          = strtok(NULL, ",");
        secn        = strtok(NULL, ",") + 1;
        type        = strtok(NULL, "\n");

        while ( *ui == ' ' )
            ++ui;

        while ( *secn == ' ' )
            ++secn;

        while ( *type == ' ' )
            ++type;

        strcpy(Section[Lines], secn);
        strcpy(Model[Lines], DriverName);

        for ( p = Section[Lines] ; *p ; ++p )
            *p = toupper(*p);

        for ( p = DriverName ; *p ; ++p ) {

            if ( isalpha(*p) )
                *p = toupper(*p);
            else if ( !isdigit(*p) )
                *p = '_';
        }

        if ( strcmp(type, "rasdd") )
            strcat(Section[Lines], ".DLL");
        else if ( strcmp(type, "pscript") )
            strcat(Section[Lines], ".PPD");
        else if ( strcmp(type, "plotter") )
            strcat(Section[Lines], ".PCD");
        else
            printf("Error: <%s> <%s> <%s> <%s> on Line %d\n",
                   DriverName, ui, secn, type, Lines);

        if ( !Lines || strncmp(Model[Lines], Model[Lines-1], 3) )
            fprintf(NewInf, "\n[%s]\n", DriverName);

        fprintf(NewInf, "%%%s%%", DriverName);
        for ( i = strlen(DriverName)+1 ; i < 54 ; ++i )
            fputc(' ', NewInf);
        fprintf(NewInf, "= %s\n", Section[Lines]);
        ++Lines;
    }

    fprintf(NewInf,"\n\n\n\n\n");

    qsort(Section, Lines, LEN, strcmp);

    i = 0;
    while ( i < Lines ) {

        fprintf(NewInf, "\[%s\]\n", Section[i]);
        fprintf(NewInf, "CopyFiles=@%s,", Section[i]);

        p = Section[i] + strlen(Section[i]) - 3;
        if ( strcmp(p, "DLL") ) {

            fprintf(NewInf, "RASDD\nDataSection=RASDD_DATA\n\n");
        } else if ( strcmp(p, "PPD") ) {

            fprintf(NewInf, "PSCRIPT\nDataSection=PSCRIPT_DATA\n\n");
        } else if ( strcmp(p, "PCD") ) {

            fprintf(NewInf, "PLOTTER\nDataSection=PLOTTER_DATA\n\n");
        } else
            printf("%s -- ???\n", p);


        ++i;
    }

    fprintf(NewInf, "\n\n\n\n\n");

    fprintf(NewInf, "[PSCRIPT]\n");
    fprintf(NewInf, "PSCRIPT.DLL\n");
    fprintf(NewInf, "PSCRPTUI.DLL\n");
    fprintf(NewInf, "PSCRIPT.HLP\n\n");
    
    fprintf(NewInf, "[RASDD]\n");
    fprintf(NewInf, "RASDD.DLL\n");
    fprintf(NewInf, "RASDDUI.DLL\n");
    fprintf(NewInf, "RASDDUI.HLP\n\n");
    
    fprintf(NewInf, "[PLOTTER]\n");
    fprintf(NewInf, "PLOTTER.DLL\n");
    fprintf(NewInf, "PLOTUI.DLL\n");
    fprintf(NewInf, "PLOTUI.HLP\n\n");
    
    fprintf(NewInf, "\n\n\n\n\n");

    fprintf(NewInf, "[PSCRIPT_DATA]\n");
    fprintf(NewInf, "DriverFile=PSCRIPT.DLL\n");
    fprintf(NewInf, "ConfigFile=PSCRPTUI.DLL\n");
    fprintf(NewInf, "HelpFile=PSCRIPT.HLP\n\n");
    
    fprintf(NewInf, "[RASDD_DATA]\n");
    fprintf(NewInf, "DriverFile=RASDD.DLL\n");
    fprintf(NewInf, "ConfigFile=RASDDUI.DLL\n");
    fprintf(NewInf, "HelpFile=RASDD.HLP\n\n");
    
    fprintf(NewInf, "[PLOTTER_DATA]\n");
    fprintf(NewInf, "DriverFile=PLOTTER.DLL\n");
    fprintf(NewInf, "ConfigFile=PLOTUI.DLL\n");
    fprintf(NewInf, "HelpFile=PLOTUI.HLP\n\n");
    
    fprintf(NewInf, "\n\n\n\n\n");
    fprintf(NewInf, "[Strings]\n");

    i = 0;
    for ( i = 0 ; i < Lines ; ++i ) {

        for ( p = Model[i] ; *p ; ++p ) {

            if ( isalpha(*p) )
                fputc(toupper(*p), NewInf);
            else if ( !isdigit(*p) )
                fputc('_', NewInf);
            else
                fputc(*p, NewInf);

        }

        fprintf(NewInf, "=\"%s\"\n", Model[i]);
    }
    

Cleanup:

    if ( OldInf )
        fclose(OldInf);

    if ( NewInf )
        fclose(NewInf);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\local.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Utility functions for Win95 upgrade of printing

Author:

    Muhunthan Sivapragasam (MuhuntS)  15-Jan-1997

Revision History:

--*/

//
// Type definitions
//
typedef struct  _UPGRADE_DATA {

    HINSTANCE   hInst;
    LPSTR       pszDir;
    LPSTR       pszProductId;
    LPSTR       pszSourceA;
    LPWSTR      pszSourceW;
} UPGRADE_DATA, *PUPGRADE_DATA;

typedef struct  _OEM_UPGRADE_INFO {

    LPSTR               pszModuleName;
    HMODULE             hModule;
} OEM_UPGRADE_INFO, *POEM_UPGRADE_INFO;

typedef struct  _UPGRADABLE_LIST {

    LPSTR   pszName;
} UPGRADABLE_LIST, *PUPGRADABLE_LIST;

typedef struct _SELECTED_DRV_INFO {

    LPTSTR              pszInfName;
    LPTSTR              pszModelName;
    LPTSTR              pszDriverSection;
    PSP_DEVINFO_DATA    pDevInfoData;
    LPTSTR              pszHardwareID;
    LPTSTR              pszManufacturer;
    LPTSTR              pszOEMUrl;
    LPTSTR              pszProvider;
    FILETIME            ftDriverDate;
    DWORDLONG           dwlDriverVersion;
    DWORD               Flags;
    LPTSTR              pszzPreviousNames;
} SELECTED_DRV_INFO, *PSELECTED_DRV_INFO;

typedef struct  _PARSEINF_INFO {

    PLATFORM            platform;
    LPTSTR              pszInstallSection;  // Can be platform dependent
    LPTSTR              pszzICMFiles;
    LPTSTR              pszPrintProc;
    LPTSTR              pszVendorSetup;
    LPTSTR              pszVendorInstaller;
    DWORD               cbDriverInfo6;
    DRIVER_INFO_6       DriverInfo6;
} PARSEINF_INFO, *PPARSEINF_INFO;

typedef struct _PNP_INFO {

    LPTSTR              pszPortName;
    LPTSTR              pszDeviceInstanceId;
} PNP_INFO, *PPNP_INFO;

typedef struct  _PSETUP_LOCAL_DATA {

    SELECTED_DRV_INFO   DrvInfo;
    DWORD               signature;
    DWORD               Flags;
    PARSEINF_INFO       InfInfo;
    PNP_INFO            PnPInfo;
} PSETUP_LOCAL_DATA;

typedef BOOL (WINAPI* AllOCANDINITSID)(
    PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD,
    DWORD, DWORD, PSID 
    );

typedef BOOL (WINAPI* CHECKTOKENMEMBERSHIP)(
    HANDLE, PSID, PBOOL
    );

typedef PVOID (WINAPI* FREESID)(
    PSID
    );


extern  CHAR                szNetprnFile[];
extern  const   GUID        GUID_DEVCLASS_PRINTER;
extern  UPGRADE_DATA        UpgradeData;
extern  OEM_UPGRADE_INFO    OEMUpgradeInfo[];
extern  LPSTR               pszNetPrnEntry;
extern  BOOL                bDoNetPrnUpgrade;
extern  DWORD               dwRunOnceCount;


#define     MAX_STRING_LEN               MAX_PATH


#define     IDS_PRODUCTID                   1001
#define     IDS_TITLE                       1002

#define     IDS_DRIVERS_UPGRADE_FAILED      2001
#define     IDS_DRIVER_UPGRADE_FAILED       2002
#define     IDS_ADDDRIVER_FAILED            2003
#define     IDS_ICM_FAILED                  2004
#define     IDS_DEFAULT_PRINTER_FAILED      2005
#define     IDS_ADDPRINTER_FAILED           2006
#define     IDS_ADDMONITOR_FAILED           2007

#define     IDS_PRINTER_CANT_MIGRATE        3001

#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

#if DBG
#define ASSERT(expr)    if ( !(expr) ) DebugBreak();
#else
#define ASSERT(expr)    ;
#endif



//
// Debug functions
//
VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    );

//
// Heap management
//

PVOID
AllocMem(
    IN UINT cbSize
    );

VOID
FreeMem(
    IN PVOID pMem
    );

LPSTR
AllocStrA(
    IN LPCSTR  pszStr
    );

LPWSTR
AllocStrW(
    IN LPCWSTR  pszStr
    );

LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    );

LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    );

VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    );

//
// Functions to write print config to the text file
//
VOID
WriteToFile(
    HANDLE  hFile,
    LPBOOL  pbFail,
    LPCSTR  pszFormat,
    ...
    );

VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    );

VOID
WritePrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN      LPSTR               pszDriver,
    IN  OUT LPBOOL              pbFail
    );

//
// Functions to parse the text file having printing config info
//
LPSTR
GetLine(
    IN      HANDLE  hFile,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadString(
    IN      HANDLE  hFile,
    IN      LPSTR   pszPrefix,
    OUT     LPSTR  *pszStr,
    IN      BOOL    bOptional,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    );


VOID
ReadPrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  OUT LPBOOL              pbFail
    );

//
// Misc stuff
//
VOID
CopyFilesToWorkingDir(
    IN  OUT LPBOOL  pbFail
    );

VOID
CleanupDriverMapping(
    IN  OUT HDEVINFO   *phDevInfo,
    IN  OUT HINF       *phNtInf,
    IN  OUT HINF       *phUpgInf
    );

VOID
InitDriverMapping(
    OUT     HDEVINFO   *phDevInfo,
    OUT     HINF       *phNtInf,
    OUT     HINF       *phUpgInf,
    IN  OUT LPBOOL      pbFail
    );

BOOL
InitFileCopyOnNT(
    IN  HDEVINFO    hDevInfo
    );

BOOL
CommitFileQueueToCopyFiles(
    IN  HDEVINFO    hDevInfo
    );

LPSTR
ErrorMsg(
    VOID
    );

VOID
LogError(
    IN  LogSeverity Severity,
    IN  UINT        MessageId,
    ...
    );

LPSTR
GetStringFromRcFileA(
    IN  UINT    uId
    );

VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    );

BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    );

DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    );

VOID
WriteRunOnceCount(
    );

LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    );

CHAR
My_fgetc(
    HANDLE  hFile
    );

LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    );

DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    );

BOOL
My_ungetc(
    HANDLE  hFile
    );

DWORD
GetFileNameInSpoolDir(
    IN  LPSTR   szBuf,
    IN  DWORD   cchBuf,
    IN  LPSTR   pszFileName
    );

LPSTR
GetVendorSetupRunOnceValueToSet(
    VOID
    );

LONG
WriteVendorSetupInfoInRegistry(
    IN CHAR *pszVendorSetup,
    IN CHAR *pszPrinterName
    );

LONG
RemoveVendorSetupInfoFromRegistry(
    VOID
    );

VOID
CallVendorSetupDlls(
    VOID
    );

BOOL
IsLocalAdmin(
    BOOL *pbAdmin
    );

LONG
DecrementVendorSetupEnumerator(
    VOID
    );

BOOL 
MakeACopyOfMigrateDll( 
    IN  LPCSTR pszWorkingDir 
    );

HMODULE LoadLibraryUsingFullPathW(
    LPCTSTR lpFileName
    );

HMODULE LoadLibraryUsingFullPathA(
    LPCTSTR lpFileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\migmain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Migmain.c

Abstract:

    Routines to migrate Win95 to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop
#include    <devguid.h>
#include    "msg.h"


VENDORINFO      VendorInfo;
UPGRADE_DATA    UpgradeData;
CHAR            szNetprnFile[] = "netwkprn.txt";

BOOL 
DllMain(
    IN HINSTANCE  hInst,
    IN DWORD      dwReason,
    IN LPVOID     lpRes   
    )
/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:
            UpgradeData.hInst = hInst;
            break;

        case DLL_PROCESS_DETACH:
            FreeMem(UpgradeData.pszProductId);
            FreeMem(UpgradeData.pszSourceA);
            FreeMem(UpgradeData.pszSourceW);
            FreeMem(UpgradeData.pszDir);
            FreeMem(pszNetPrnEntry);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

LONG
QueryVersion(
    OUT     LPCSTR         *pszProductID,
    OUT     LPUINT          plDllVersion,
    OUT     LPINT          *pCodePageArray    OPTIONAL,
    OUT     LPCSTR         *ExeNamesBuf       OPTIONAL,
    OUT     PVENDORINFO    *pVendorInfo
    )
{
    BOOL    bFail = TRUE;
    DWORD   dwRet, dwNeeded, dwReturned, dwLangId;


    if ( !(UpgradeData.pszProductId = GetStringFromRcFileA(IDS_PRODUCTID)) )
        goto Done;

    ZeroMemory(&VendorInfo, sizeof(VendorInfo));
    dwLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_COMPANY_NAME,
                   dwLangId,
                   VendorInfo.CompanyName,
                   sizeof(VendorInfo.CompanyName),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_SUPPORT_NUMBER,
                   dwLangId,
                   VendorInfo.SupportNumber,
                   sizeof(VendorInfo.SupportNumber),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_SUPPORT_URL,
                   dwLangId,
                   VendorInfo.SupportUrl,
                   sizeof(VendorInfo.SupportUrl),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)UpgradeData.hInst,
                   MSG_VI_INSTRUCTIONS,
                   dwLangId,
                   VendorInfo.InstructionsToUser,
                   sizeof(VendorInfo.InstructionsToUser),
                   0);


    *pszProductID   = UpgradeData.pszProductId;
    *plDllVersion   = 1;
    *pCodePageArray = NULL;
    *ExeNamesBuf    = NULL;
    *pVendorInfo    = &VendorInfo;

    //
    // Call this DLL only if there are some printers or printer drivers
    // installed
    //
    if ( EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned)   &&
          EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        NULL,
                        0,
                        &dwNeeded,
                        &dwReturned) ) {

        return ERROR_NOT_INSTALLED;
    }

    bFail = FALSE;

Done:
    if ( bFail ) {

        if ( dwRet = GetLastError() )
            return dwRet;

        return STG_E_UNKNOWN;
    }

    return ERROR_SUCCESS;
}


P_QUERY_VERSION     pQueryVersion   = QueryVersion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam (MuhuntS)  17-Oct-1995

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <objbase.h>
#include <shellapi.h>
#include <setupapi.h>
#include <initguid.h>
#include <cfgmgr32.h>
#include "splsetup.h"
#include "local.h"
#include <plugin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\win9x.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Win9x.c

Abstract:

    Routines to pre-migrate Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"

//
// This data structure is used to keep track of printer drivers installed on
// Win9x and their NT names
//
typedef struct  _DRIVER_INFO_9X {

    struct  _DRIVER_INFO_9X *pNext;
    LPSTR                    pszWin95Name;
    LPSTR                    pszNtName;
} DRIVER_INFO_9X, *PDRIVER_INFO_9X;


UPGRADABLE_LIST UpgradableMonitors[]    = { {"Local Port"}, { NULL } };


DWORD   dwNetPrinters       = 0;
DWORD   dwSharedPrinters    = 0;

CHAR    szRegPrefix[]     = "HKLM\\System\\CurrentControlSet\\Control\\Print\\";
CHAR    szRegPrefixOnly[] = "System\\CurrentControlSet\\control\\Print\\Printers";
CHAR    cszPrinterID[]    = "PrinterID";
CHAR    cszWinPrint[]     = "winprint";
CHAR    cszRaw[]          = "RAW";

//
// the following drivers need not be warned or upgraded, they're handled by 
// the fax folks. The names are not localized.
//
CHAR    *pcszIgnoredDrivers[] = {
    "Microsoft Shared Fax Driver",
    "Microsoft Fax Client",
    NULL
};

BOOL
IsIgnoredDriver(LPCSTR pszDriverName)
{
    DWORD i;

    for (i=0; pcszIgnoredDrivers[i] != NULL; i++)
    {
        if (!strcmp(pcszIgnoredDrivers[i], pszDriverName))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
SearchRegTreeForPrinterId(
    IN  DWORD   dwPrinterId,
    IN  LPCSTR  pszRegRoot,
    IN  LPSTR   pszBuf,
    IN  DWORD   cchBufLen
    )
/*++

Routine Description:
    This routine searchs a given registry tree of DevNodes for a given
    printer id.

Arguments:
    dwPrinterId     : Unique printer id we are searching for
    pszRegRoot      : Registry path relative to HKLM
    pszBuf          : Buffer to fill the registry key path on success
    cchBufLen       : size of key buffer in characters

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL        bFound = FALSE;
    DWORD       dwLen, dwIndex, dwDontCare, dwId, dwSize;
    HKEY        hKey, hSubKey;
    LPSTR       pszCur;
    DWORD       dwLastError;

    //
    // Copy the registry path
    //
    dwLen = strlen(pszRegRoot) + 1;
    if ( dwLen + 1 > cchBufLen )
        return FALSE;

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        pszRegRoot,
                                        0,
                                        KEY_READ,
                                        &hKey) )
        return FALSE;

    strcpy(pszBuf, pszRegRoot);
    pszCur = pszBuf + dwLen;
    *(pszCur-1) = '\\';
    *pszCur = 0;

    //
    // Walk thru each devnode looking for a matching PrinterId
    //
    for ( dwIndex = 0, dwSize = cchBufLen - dwLen ;
          !bFound                                                   &&
          !RegEnumKeyExA(hKey, dwIndex, pszCur, &dwSize,
                         NULL, NULL, NULL, NULL)                    &&
          !RegOpenKeyExA(hKey, pszCur, 0, KEY_READ, &hSubKey) ;
          ++dwIndex, dwSize = cchBufLen - dwLen ) {

            dwSize = sizeof(dwId);
            if ( ERROR_SUCCESS == RegQueryValueExA(hSubKey,
                                                   cszPrinterID,
                                                   0,
                                                   &dwDontCare,
                                                   (LPBYTE)&dwId,
                                                   &dwSize) ) {
                if ( dwId == dwPrinterId ) {

                    bFound = TRUE;
                    dwLen  = strlen(pszBuf);
                    if ( dwLen + 2 < cchBufLen )
                        strcpy(pszBuf + dwLen, "\"");
                }
            } else {

                bFound = SearchRegTreeForPrinterId(dwPrinterId,
                                                   pszBuf,
                                                   pszBuf,
                                                   cchBufLen);

                if ( !bFound ) {

                    strcpy(pszBuf, pszRegRoot);
                    pszCur = pszBuf + dwLen;
                    *(pszCur-1) = '\\';
                    *pszCur = 0;
                }
            }

            RegCloseKey(hSubKey);
    }

    RegCloseKey(hKey);

    return bFound;
}


DWORD
GetPrinterId(
    LPSTR   pszPrinterName
    )
/*++

Routine Description:
    Given a printer id finds the printer id from PrinterDriverData.
    Call to GetPrinterData screws up migration dll local data for unknown
    reasons. So now we access the registry directly

Arguments:
    pszPrinterName  : Printer name to get id for

Return Value:
    0 on failure else PrinterID from registry is returned

--*/
{
    CHAR    szKey[MAX_PATH];
    HKEY    hKey;
    DWORD   dwId = 0, dwType, dwSize;

    if ( strlen(szRegPrefixOnly) + strlen(pszPrinterName)
                                 + strlen("PrinterDriverData")
                                 + 3 > MAX_PATH )
        return dwId;

    sprintf(szKey, "%s\\%s\\PrinterDriverData", szRegPrefixOnly, pszPrinterName);

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szKey,
                                        0,
                                        KEY_READ,
                                        &hKey) ) {

        dwSize = sizeof(dwId);
        if ( ERROR_SUCCESS != RegQueryValueExA(hKey,
                                               cszPrinterID,
                                               0,
                                               &dwType,
                                               (LPBYTE)&dwId,
                                               &dwSize) )
            dwId = 0;

        RegCloseKey(hKey);
    }

    return dwId;
}


BOOL
RegPathFromPrinter(
    IN  LPSTR   pszPrinterName,
    OUT LPSTR   szKeyBuffer,
    IN  DWORD   cchKeyBufLen
    )
/*++

Routine Description:
    This routine returns the registry path of the DevNode for a printer.
    This should be marked as Handled or as Incompatible in the migrate.inf
    to report to the user

Arguments:
    pszPrinterName  : Printer name
    szKeyBuffer     : Buffer to fill in the registry path
    cchKeyBufLen    : Length of key buffer in characters

Return Value:
    TRUE on success, FALSE else

--*/
{
    DWORD       dwPrinterId, dwLen;
    CHAR        szHeader[] = "\"HKLM\\";
    CHAR        szRegPrinterPrefix[] = "Printers\\";

    //
    // Add "HKLM\ at the beginning and "\" at the end
    //
    dwLen = strlen(szHeader);

    if ( dwLen + 1 > cchKeyBufLen )
        return FALSE;

    strcpy(szKeyBuffer, szHeader);

    //
    // If a printer id is found then there is a DevNode list that
    // registry path, otherwise return spooler registry path
    //
    if ( dwPrinterId = GetPrinterId(pszPrinterName) ) {

        return SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\Root\\printer",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen)      ||
               SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\LPTENUM",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen)      ||
               SearchRegTreeForPrinterId(dwPrinterId,
                                         "Enum\\IRDA",
                                         szKeyBuffer + dwLen,
                                         cchKeyBufLen - dwLen);

    } else {

        dwLen = strlen(szRegPrefix) + strlen(szRegPrinterPrefix)
                                    + strlen(pszPrinterName) + 3;

        if ( dwLen >= cchKeyBufLen )
            return FALSE;

        szKeyBuffer[0] = '"';
        strcpy(szKeyBuffer + 1, szRegPrefix);
        strcat(szKeyBuffer, szRegPrinterPrefix);
        strcat(szKeyBuffer, pszPrinterName);
        strcat(szKeyBuffer, "\"");

        return TRUE;
    }

    return FALSE;

}


LONG
CALLBACK
Initialize9x(
    IN  LPCSTR      pszWorkingDir,
    IN  LPCSTR      pszSourceDir,
        LPVOID      Reserved
    )
/*++

Routine Description:
    This is an export for setup to call during the report phase.
    This is the first function called on the migration DLL.

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing
    pszSourceDir    : Source location for NT distribution files
    Reserved        : Leave it alone

Return Value:
    Win32 error code

--*/
{
    POEM_UPGRADE_INFO   pOemUpgradeInfo;
    BOOL                bFail = TRUE;

    UpgradeData.pszDir          = AllocStrA(pszWorkingDir);
    UpgradeData.pszSourceA      = AllocStrA(pszSourceDir);
    UpgradeData.pszSourceW      = NULL;

    bFail = UpgradeData.pszDir      == NULL     ||
            UpgradeData.pszSourceA  == NULL;

    return bFail ? GetLastError() : ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x(
    IN  HWND        hwndParent,
    IN  LPCSTR      pszUnattendFile,
    IN  HKEY        hUserRegKey,
    IN  LPCSTR      pszUserName,
        LPVOID      Reserved
    )
/*++

Routine Description:
    Process per user settings

Arguments:

Return Value:
    None

--*/
{
    //
    // Nothing to do
    //

    return  ERROR_SUCCESS;
}


VOID
DestroyDriverInfo9xList(
    IN  PDRIVER_INFO_9X pDriverInfo9x
    )
/*++

Routine Description:
    Free memory for the driver entries in DRIVER_INFO_9X linked list

Arguments:
    pDriverInfo9x   : Beginning of the linked list

Return Value:
    None

--*/
{
    PDRIVER_INFO_9X pNext;

    while ( pDriverInfo9x ) {

        pNext = pDriverInfo9x->pNext;
        FreeMem(pDriverInfo9x);
        pDriverInfo9x = pNext;
    }
}


PDRIVER_INFO_9X
AllocateDriverInfo9x(
    IN      LPSTR   pszNtName,
    IN      LPSTR   pszWin95Name,
    IN  OUT LPBOOL  pbFail
    )
/*++

Routine Description:
    Allocate memory and create a DRIVER_INFO_9X structure

Arguments:
    pszNtName       : NT printer driver model name. This could be NULL if no
                      matching entry is found on ntprint.inf
    pszWin95Name    : Win95 printer driver name
    pbFail          : Set on an error -- no more processing needed

Return Value:
    Returns pointer to the allocated DRIVER_INFO_9X structure. Memory is also
    allocated for the strings

--*/
{
    PDRIVER_INFO_9X     pInfo;
    DWORD               cbSize;
    LPSTR               pszEnd;

    if ( *pbFail )
        return NULL;

    cbSize = strlen(pszWin95Name) + 1;
    if ( pszNtName )
        cbSize += strlen(pszNtName) + 1;

    cbSize *= sizeof(CHAR);
    cbSize += sizeof(DRIVER_INFO_9X);

    if ( pInfo = AllocMem(cbSize) ) {

        pszEnd = (LPBYTE) pInfo + cbSize;

        if ( pszNtName ) {

            pszEnd -= strlen(pszNtName) + 1;
            strcpy(pszEnd, pszNtName);
            pInfo->pszNtName = pszEnd;
        }
        pszEnd -= strlen(pszWin95Name) + 1;
        strcpy(pszEnd, pszWin95Name);
        pInfo->pszWin95Name = pszEnd;

    } else {

        *pbFail = TRUE;
    }

    return pInfo;
}


LPSTR
FindNtModelNameFromWin95Name(
    IN  OUT HDEVINFO    hDevInfo,
    IN      HINF        hNtInf,
    IN      HINF        hUpgInf,
    IN      LPCSTR      pszWin95Name,
    IN  OUT LPBOOL      pbFail
    )
/*++

Routine Description:
    This routine finds the NT printer driver model name from the Win9x name
    Rules followed:
        1. If a name mapping is used in prtupg9x.inf use it
        2. Else just use the Win95 as it is

Arguments:

    hDevInfo        : Printer device class list. Has all drivers from NT built
    hNtInf          : Handle to the NT ntprint.inf
    hUpgInfo        : Handle to prtupg9x.inf
    DiskSpaceList   : Handle to disk space list. Add driver files to this
    pszWin95Name    : Windows 95 printer driver name
    pbFail          : Set on an error -- no more processing needed

Return Value:
    Pointer to the NT printer driver name. Memory is allocated and caller has
    to free it

--*/
{
    BOOL                        bFound = FALSE;
    DWORD                       dwIndex, dwNeeded;
    CHAR                        szNtName[LINE_LEN];
    INFCONTEXT                  InfContext;
    SP_DRVINFO_DATA_A           DrvInfoData;
    PSP_DRVINFO_DETAIL_DATA_A   pDrvInfoDetailData = NULL;

    if ( *pbFail )
        return NULL;

    //
    // See in prtupg9x.inf to see if the driver has a different name on NT
    //
    if ( SetupFindFirstLineA(hUpgInf,
                             "Printer Driver Mapping",
                             pszWin95Name,
                             &InfContext) ) {

        //
        // If for some reason we could not get NT name we will still continue
        // with other driver models
        //
        if ( !SetupGetStringField(&InfContext,
                                  1,
                                  szNtName,
                                  sizeof(szNtName)/sizeof(szNtName[0]),
                                  NULL) )
            return NULL;
    } else {

        //
        // If there is no mapping in the upgrade inf then look for Win95 name
        // in ntprint.inf
        //
        if ( strlen(pszWin95Name) > LINE_LEN - 1 )
            return NULL;

        strcpy(szNtName, pszWin95Name);
    }

    //
    // NOTE only for beta2
    // DrvInfoData.cbSize = sizeof(DrvInfoData);

    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA_V1);
    for ( dwIndex = 0 ;
          SetupDiEnumDriverInfoA(hDevInfo,
                                 NULL,
                                 SPDIT_CLASSDRIVER,
                                 dwIndex,
                                 &DrvInfoData);
          ++dwIndex ) {

        if ( !_strcmpi(DrvInfoData.Description, szNtName) ) {

            bFound = TRUE;
            break;
        }
    }

    if ( !bFound )
        return NULL;

    //
    // Now that we found a driver for the device on NT we need to calculate
    // the disk space required
    //
    if ( ( !SetupDiGetDriverInfoDetailA(hDevInfo,
                                        NULL,
                                        &DrvInfoData,
                                        NULL,
                                        0,
                                        &dwNeeded)          &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER)        ||
         !(pDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA_A)AllocMem(dwNeeded)) )
        return NULL;


    pDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA_A);
    if ( !SetupDiGetDriverInfoDetailA(hDevInfo,
                                      NULL,
                                      &DrvInfoData,
                                      pDrvInfoDetailData,
                                      dwNeeded,
                                      &dwNeeded) ) {

        FreeMem(pDrvInfoDetailData);
        return NULL;
    }

    //
    // NOTE should we subtract the Win95 driver size since we do not need it
    //

    FreeMem(pDrvInfoDetailData);
    return AllocStrA(szNtName);
}


VOID
WriteFileToBeDeletedInInf(
    IN  LPCSTR  pszInfName,
    IN  LPCSTR  pszFileName
    )
/*++

Routine Description:
    Writes a file which is to be deleted on migration to NT in the migrate.inf

Arguments:
    pszInfName      : Full path to the migrate.inf
    pszFileName     : Fully qualified filename to be deleted

Return Value:
    None

--*/
{
    CHAR    szString[MAX_PATH+2];

    szString[0] = '"';
    if ( GetSystemDirectoryA(szString + 1, SIZECHARS(szString)-2) ) {

        strcat(szString, "\\");
        strcat(szString, pszFileName);
        strcat(szString, "\"");
        WritePrivateProfileStringA("Moved", szString, "", pszInfName);
    }
}


VOID
WriteRegistryEntryHandled(
    IN  LPCSTR  pszInfName,
    IN  LPCSTR  pszRegEntry
    )
/*++

Routine Description:
    Writes a registry entry which is being handled by printer upgrade code in
    migrate.inf. Setup looks at these entries across all mig dlls to see what
    componnets can't be upgraded.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pszRegEntry     : Fully qualified registry entry which is handled

Return Value:
    None

--*/
{
    WritePrivateProfileStringA("Handled", pszRegEntry, "\"Registry\"", pszInfName);
}


BOOL
IsAnICMFile(
    IN  LPCSTR  pszFileName
    )
{
    DWORD   dwLen = strlen(pszFileName);
    LPCSTR  psz = pszFileName + dwLen - 4;

    if ( dwLen > 3 && (!_strcmpi(psz, ".ICM") || !_strcmpi(psz, ".ICC")) )
        return TRUE;

    return FALSE;
}


VOID
LogDriverEntry(
    IN      LPCSTR              pszInfName,
    IN      LPDRIVER_INFO_3A    pDriverInfo3,
    IN      BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a printer driver in the migrate.inf.
    Write all printer driver files to be deleted. Also if a matching NT
    driver is found write the driver as handled.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pDriverInfo3    : Pointer to DRIVER_INFO_3A of the driver
    bUpgradable     : If TRUE a matching NT driver is found

Return Value:
    None

--*/
{
    CHAR    szRegDrvPrefix[] = "Environments\\Windows 4.0\\Drivers\\";
    LPSTR   psz;
    DWORD   dwLen;

    //
    // Write each driver file as to be deleted
    //
    for ( psz = pDriverInfo3->pDependentFiles ;
          psz && *psz ;
          psz += strlen(psz) + 1) {

        //
        // ICM migration dll will handle color profiles
        //
        if ( IsAnICMFile(psz) )
            continue;

        WriteFileToBeDeletedInInf(pszInfName, psz);
    }

    //
    // If a matching NT driver entry is found make an entry to indicate the
    // driver will be upgraded against the registry entry name'
    //
    if ( !bUpgradable )
        return;

    dwLen = strlen(szRegPrefix) + strlen(szRegDrvPrefix)
                                + strlen(pDriverInfo3->pName) + 3;
    if ( !(psz = AllocMem(dwLen * sizeof(CHAR))) )
        return;

    *psz = '"';
    strcpy(psz + 1, szRegPrefix);
    strcat(psz, szRegDrvPrefix);
    strcat(psz, pDriverInfo3->pName);
    strcat(psz, "\"");

    WriteRegistryEntryHandled(pszInfName, psz);

    FreeMem(psz);
}


VOID
LogMonitorEntry(
    IN      LPCSTR              pszInfName,
    IN      LPMONITOR_INFO_1A   pMonitorInfo1,
    IN      BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a print monitor in the migrate.inf. Write the
    monitor.dll to be deleted. Also if the monitor will be upgraded write
    it in the handled section

Arguments:
    pszInfName      : Full path to the migrate.inf
    pMonitorInfo1   : Pointer to MONITOR_INFO_1A of the monitor
    bUpgradable     : If TRUE a matching NT driver is found

Return Value:
    None

--*/
{
    CHAR    szRegMonPrefix[] = "Monitors\\";
    LPSTR   psz;
    DWORD   dwLen;

    //
    // If a matching NT driver entry is found make an entry to indicate the
    // driver will be upgraded against the registry entry name'
    //
    if ( !bUpgradable )
        return;

    dwLen = strlen(szRegPrefix) + strlen(szRegMonPrefix)
                                + strlen(pMonitorInfo1->pName) + 3;

    if ( !(psz = AllocMem(dwLen * sizeof(CHAR))) )
        return;

    *psz = '"';
    strcpy(psz + 1, szRegPrefix);
    strcat(psz, szRegMonPrefix);
    strcat(psz, pMonitorInfo1->pName);
    strcat(psz, "\"");

    WriteRegistryEntryHandled(pszInfName, psz);

    FreeMem(psz);
}


VOID
LogPrinterEntry(
    IN  LPCSTR              pszInfName,
    IN  LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  BOOL                bUpgradable
    )
/*++

Routine Description:
    Log information about a printer in the migrate.inf.
    If the printer will be upgraded write it in the handled section.
    Otherwise we will write a incompatibility message.

Arguments:
    pszInfName      : Full path to the migrate.inf
    pPrinterInfo2   : Pointer to PRINTER_INFO_2A of the printer
    bUpgradable     : If TRUE printer will be migrated, else not

Return Value:
    None

--*/
{
    CHAR    szRegPath[MAX_PATH], szPrefix[] = "\\Hardware\\";
    LPSTR   psz, psz2, psz3;
    DWORD   dwLen;

    if ( !RegPathFromPrinter(pPrinterInfo2->pPrinterName,
                             szRegPath,
                             MAX_PATH) ) {

        return;
    }

    if ( bUpgradable ) {

        WriteRegistryEntryHandled(pszInfName, szRegPath);
    } else {

        dwLen   = strlen(pPrinterInfo2->pPrinterName) + strlen(szPrefix) + 3;
        psz2    = AllocMem(dwLen * sizeof(CHAR));

        if ( psz2 ) {

            sprintf(psz2, "%s%s", szPrefix, pPrinterInfo2->pPrinterName);

            WritePrivateProfileStringA(psz2,
                                       szRegPath,
                                       "\"Registry\"",
                                       pszInfName);

            if ( psz = GetStringFromRcFileA(IDS_PRINTER_CANT_MIGRATE) ) {

                dwLen = strlen(psz) + strlen(psz2);
                if ( psz3 = AllocMem(dwLen * sizeof(CHAR)) ) {

                    sprintf(psz3, psz, pPrinterInfo2->pPrinterName);

                    WritePrivateProfileStringA("Incompatible Messages",
                                               psz2,
                                               psz3,
                                               pszInfName);

                    FreeMem(psz3);
                }
                FreeMem(psz);
            }
            FreeMem(psz2);
        }
    }
}


VOID
ProcessPrinterDrivers(
    IN      HANDLE              hFile,
    IN      LPCSTR              pszInfName,
    IN      HWND                hwnd,
    OUT     PDRIVER_INFO_9X    *ppDriverInfo9x,
    IN  OUT LPBOOL              pbFail
    )
/*++

Routine Description:
    Process printer drivers for upgrade

Arguments:
    hFile           : Handle to print9x.txt. Printing configuration
                      info is written here for use on NT side
    pszInfName      : Inf name to log upgrade info
    hwnd            : Parent window handle for any UI
    DiskSpaceList   : Handle to disk space list to queue up file operations
    ppDriverInfo9x  : On return gives the list of printer drivers and
                      their Nt names
    pbFail          : Set on an error -- no more processing needed


Return Value:
    None

--*/
{
    LPBYTE              pBuf = NULL;
    DWORD               dwNeeded, dwReturned;
    LPSTR               psz, pszNtModelName;
    HDEVINFO            hDevInfo;
    HINF                hUpgInf, hNtInf;
    LPDRIVER_INFO_3A    pDriverInfo3;
    PDRIVER_INFO_9X     pCur;

    hDevInfo = hUpgInf = hNtInf = INVALID_HANDLE_VALUE;

    //
    // Get the list of drivers installed from spooler
    if ( *pbFail                                    ||
         EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned) ) {

        if ( !*pbFail )
            WriteToFile(hFile, pbFail, "[PrinterDrivers]\n");
        goto Cleanup;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = AllocMem(dwNeeded))                   ||
         !EnumPrinterDriversA(NULL,
                              NULL,
                              3,
                              pBuf,
                              dwNeeded,
                              &dwNeeded,
                              &dwReturned) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    InitDriverMapping(&hDevInfo, &hNtInf, &hUpgInf, pbFail);

    //
    // For each driver ...
    //      If we find a suitable NT driver name write it to file
    //      else write Win95 name with a * at the beginning of the line
    //      to tell this can't be upgraded (but log error on NT)
    //
    WriteToFile(hFile, pbFail, "[PrinterDrivers]\n");

    for ( dwNeeded = 0, pDriverInfo3 = (LPDRIVER_INFO_3A)pBuf ;
          dwNeeded < dwReturned ;
          ++dwNeeded, ++pDriverInfo3 ) {

        if (IsIgnoredDriver(pDriverInfo3->pName))
        {
            continue;
        }

        pszNtModelName = FindNtModelNameFromWin95Name(hDevInfo,
                                                      hNtInf,
                                                      hUpgInf,
                                                      pDriverInfo3->pName,
                                                      pbFail);

        if ( !(pCur = AllocateDriverInfo9x(pszNtModelName,
                                           pDriverInfo3->pName,
                                           pbFail)) ) {

            FreeMem(pszNtModelName);
            goto Cleanup;
        }

        //
        // Add the info in the linked lise
        //
        if ( *ppDriverInfo9x )
            pCur->pNext = *ppDriverInfo9x;

        *ppDriverInfo9x = pCur;

        //
        // If pszNtModelName is NULL we could not decide which driver to
        // install
        //
        if ( pszNtModelName ) {

            LogDriverEntry(pszInfName, pDriverInfo3, TRUE);
            WriteString(hFile, pbFail, pszNtModelName);
        } else {

            LogDriverEntry(pszInfName, pDriverInfo3, FALSE);
            WriteString(hFile, pbFail, pDriverInfo3->pName);
        }

        FreeMem(pszNtModelName);
    }

Cleanup:
    WriteToFile(hFile, pbFail, "\n");

    //
    // Close all the inf since we do not need them
    //
    CleanupDriverMapping(&hDevInfo, &hNtInf, &hUpgInf);

    FreeMem(pBuf);
}


VOID
FixupPrinterInfo2(
    LPPRINTER_INFO_2A   pPrinterInfo2
    )
/*++

Routine Description:
    Fixup the PRINTER_INFO_2 we got from Win95 spooler before writing to the
    text file so that AddPrinter will be ok on NT side

Arguments:
    pPrinterInfo2   : Points to the PRINTER_INFO_2

Return Value:
    None

--*/
{
    //
    // Default datatype is always RAW
    //
    pPrinterInfo2->pDatatype = cszRaw;

    //
    // Only print processor for in-box drivers is winprint
    //
    pPrinterInfo2->pPrintProcessor  = cszWinPrint;

    //
    // Remove the enable bidi bit. NT driver may or may not have a LM
    // If it does AddPrinter on NT automatically enables bidi
    //
    pPrinterInfo2->Attributes   &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

    //
    // Remove the work-offline bit. It makes no sense to carry it over.
    // With network printers this is a big problem because Win2K does not set
    // work offline, and UI does not allow user to disable it if set.
    //
    pPrinterInfo2->Attributes   &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;

    //
    // Ignore Win9x separator page
    //
    pPrinterInfo2->pSepFile = NULL;

    //
    // We will ignore PRINTER_STATUS_PENDING_DELETION and still add it on NT
    //
}


VOID
ProcessPrinters(
    IN      HANDLE          hFile,
    IN      HANDLE          hFile2,
    IN      LPCSTR          pszInfName,
    IN      PDRIVER_INFO_9X pDriverInfo9x,
    IN  OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Process printers for upgrade

Arguments:
    hFile           : Handle to print9x.txt. Printing configuration
                      info is written here for use on NT side
    hFile2          : Handle to netwkprn.txt
    pDriverInfo9x   : Gives the list of drivers and corresponding NT drivers
    pbFail          : Set on an error -- no more processing needed

Return Value:
    None

--*/
{
    LPBYTE              pBuf1 = NULL;
    BOOL                bFirst = TRUE, bFound;
    DWORD               dwLevel, dwNeeded, dwPrinters, dwSize, dwIndex;
    LPPRINTER_INFO_2A   pPrinterInfo2;
    PDRIVER_INFO_9X     pCur;
    PUPGRADABLE_LIST    pUpg;
    LPSTR               pWinIniPorts = NULL, psz;

    //
    // Get the list of printers installed from spooler
    //
    if ( *pbFail                                    ||
         EnumPrintersA(PRINTER_ENUM_LOCAL,
                       NULL,
                       2,
                       NULL,
                       0,
                       &dwNeeded,
                       &dwPrinters) ) {

        if ( !*pbFail )
            WriteToFile(hFile, pbFail, "[Ports]\n\n[Printers]\n");
        goto Cleanup;
    }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf1 = AllocMem(dwNeeded))                  ||
         !EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        pBuf1,
                        dwNeeded,
                        &dwNeeded,
                        &dwPrinters) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Extract all the used local ports
    //
    WriteToFile(hFile, pbFail, "[Ports]\n");

    for ( dwNeeded = 0, pPrinterInfo2 = (LPPRINTER_INFO_2A)pBuf1 ;
          dwNeeded < dwPrinters ;
          ++dwNeeded, ++pPrinterInfo2 )
    {
        DWORD i;

        //
        // check for ignored drivers
        //
        if (IsIgnoredDriver(pPrinterInfo2->pDriverName))
        {
            continue;
        }
        
        //
        // Point-and-print printers are processed through netwkprn.txt
        //

        if (pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK)
        {
            continue;
        }

        //
        // check whether portname has been processed already
        //

        for (i = 0; i < dwNeeded; i++ )
        {
            if (strcmp(pPrinterInfo2->pPortName, (((LPPRINTER_INFO_2A)pBuf1)+i)->pPortName) == 0)
            {
                break;
            }
        }
        if (i < dwNeeded)
        {
            DebugMsg("Port with multiple attached printers skipped");
            continue;
        }

        //
        // if the printers is a FILE, LPT*: or COM*: port do nothing
        //

        if (_strnicmp(pPrinterInfo2->pPortName, "FILE:", 5) == 0)

        {
            DebugMsg("FILE: port skipped");
            continue;
        }

        if ((_strnicmp(pPrinterInfo2->pPortName, "COM", 3) == 0) ||
            (_strnicmp(pPrinterInfo2->pPortName, "LPT", 3) == 0) )
        {
            LPSTR psz = pPrinterInfo2->pPortName + 3;

            if (isdigit(*psz))
            {
                do
                {
                    psz++;
                } while ( isdigit(*psz) );

                if (*psz == ':')
                {
                    DebugMsg("Local port COMx:/LPTx skipped");
                    continue;
                }
            }
        }

        //
        // check whether the port is listed in win.ini - if so, it's a local port that needs to be migrated
        // if not, it's a third-party port that won't be migrated - warn !
        //

        //
        // retrieve the win.ini section on ports only once
        //
        if (!pWinIniPorts)
        {
            DWORD dwBufSize = 32767; // this is the max. size acc. to MSDN

            pWinIniPorts = AllocMem(dwBufSize);
            if (!pWinIniPorts)
            {
                *pbFail = TRUE;
                goto Cleanup;
            }

            GetProfileSection("Ports", pWinIniPorts, dwBufSize);
        }

        //
        // search for the current port within the section, note that the entry is in the form
        // <portname>=
        // so I need to skip the = at the end
        //

        for (psz = pWinIniPorts; *psz ; psz += strlen(psz) + 1)
        {
            if (_strnicmp(pPrinterInfo2->pPortName, psz, strlen(pPrinterInfo2->pPortName)) == 0)
            {
                break;
            }
        }

        if (!*psz)
        {
            //
            // not found - this printer queue will not be migrated !
            //

            LogPrinterEntry(pszInfName, pPrinterInfo2, FALSE);
        }
        else
        {
            //
            // found - write the entry for it to allow creation of the port on the NT side
            //
            WriteToFile(hFile, pbFail, "PortName:        ");
            WriteString(hFile, pbFail, pPrinterInfo2->pPortName);
        }
    }

    //
    // Write the PRINTER_INFO_2 in the print95.txt file
    //
    WriteToFile(hFile, pbFail, "\n[Printers]\n");
    WriteToFile(hFile2, pbFail, "[Printers]\n");

    for ( dwNeeded = 0, pPrinterInfo2 = (LPPRINTER_INFO_2A)pBuf1 ;
          dwNeeded < dwPrinters ;
          ++dwNeeded, ++pPrinterInfo2 ) {

        //
        // check for ignored drivers
        //
        if (IsIgnoredDriver(pPrinterInfo2->pDriverName))
        {
            continue;
        }
        
        FixupPrinterInfo2(pPrinterInfo2);

        //
        // Find the driver name from the installed drivers on Win9x and get
        // the NT driver name
        //
        for ( pCur = pDriverInfo9x ;
              pCur && _strcmpi(pCur->pszWin95Name, pPrinterInfo2->pDriverName) ;
              pCur = pCur->pNext )
        ;

        if ( !pCur ) {

            ASSERT(pCur != NULL);
            *pbFail = TRUE;
            goto Cleanup;
        }

        //
        // Pass the NT driver name here. If it is not NULL that gets written
        // to the file, we won't need Win9x driver name on NT. If can't find
        // an NT driver we will just write the Win9x driver name. It will be
        // useful for error loggging
        //
        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_NETWORK ) {

            ++dwNetPrinters;

            WritePrinterInfo2(hFile2, pPrinterInfo2, pCur->pszNtName, pbFail);
        } else {

            //
            // If the printer is shared write it to network printer file too
            // since it needs to be shared when user logs in for the first time
            //
            if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                ++dwSharedPrinters;
                WritePrinterInfo2(hFile2, pPrinterInfo2, pCur->pszNtName, pbFail);
                pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            }

            WritePrinterInfo2(hFile, pPrinterInfo2, pCur->pszNtName, pbFail);
        }

        //
        // Now see if this printer is going to disappear on NT:
        //      Check if an NT driver is found
        //
        LogPrinterEntry(pszInfName, pPrinterInfo2, pCur->pszNtName != NULL);
    }

Cleanup:
    if (pWinIniPorts)
    {
        FreeMem(pWinIniPorts);
    }

    WriteToFile(hFile, pbFail, "\n");

    FreeMem(pBuf1);
}


VOID
ProcessPrintMonitors(
    IN  LPCSTR  pszInfName
    )
/*++

Routine Description:
    Process print monitors for upgrade.

    We just look for monitors which are not in the list of upgradable monitors
    and add to the unupgradable list so that we can warn the user

Arguments:
    pszInfName  : Inf name to log upgrade info

Return Value:
    None
--*/
{
    LPBYTE              pBuf = NULL;
    DWORD               dwCount, dwNeeded, dwReturned;
    LPSTR               psz;
    LPMONITOR_INFO_1A   pMonitorInfo1;
    PUPGRADABLE_LIST    pUpg;
    BOOL                bFound;

    if ( EnumMonitorsA(NULL,
                       1,
                       NULL,
                       0,
                       &dwNeeded,
                       &dwReturned)                     ||
         GetLastError() != ERROR_INSUFFICIENT_BUFFER    ||
         !(pBuf = AllocMem(dwNeeded))                   ||
         !EnumMonitorsA(NULL,
                        1,
                        pBuf,
                        dwNeeded,
                        &dwNeeded,
                        &dwReturned) ) {

        goto Cleanup;
    }

    for ( dwNeeded = dwCount = 0, pMonitorInfo1 = (LPMONITOR_INFO_1A)pBuf ;
          dwCount < dwReturned ;
          ++dwCount, ++pMonitorInfo1 ) {

        for ( pUpg = UpgradableMonitors, bFound = FALSE ;
              pUpg->pszName ; ++pUpg ) {

            if ( !strcmp(pMonitorInfo1->pName, pUpg->pszName) ) {

                bFound = TRUE;
                break;
            }
        }

        LogMonitorEntry(pszInfName, pMonitorInfo1, bFound);
    }

Cleanup:
    FreeMem(pBuf);
}


LONG
CALLBACK
MigrateSystem9x(
    IN      HWND        hwndParent,
    IN      LPCSTR      pszUnattendFile,
            LPVOID      Reserved
    )
/*++

Routine Description:
    Process system setttings for printing. This does all the work for printing
    upgrade

Arguments:
    hwndParent      : Parent window for any UI
    pszUnattendFile : Pointer to unattend file
    pqwDiskSpace    : On return gives the additional disk space needed on NT

Return Value:
    Win32 error code

--*/
{
    BOOL                    bFail = FALSE;
    DWORD                   dwRet;
    HANDLE                  hFile, hFile2;
    CHAR                    szFile[MAX_PATH], szInfName[MAX_PATH];
    PDRIVER_INFO_9X         pDriverInfo9x = NULL;
#if DBG
    CHAR                    szFile2[MAX_PATH];
#endif

    wsprintfA(szFile, "%s\\%s", UpgradeData.pszDir, "print95.txt");
    wsprintfA(szInfName, "%s\\%s", UpgradeData.pszDir, "migrate.inf");


    hFile = CreateFileA(szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    wsprintfA(szFile, "%s\\%s", UpgradeData.pszDir, szNetprnFile);
    hFile2 = CreateFileA(szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE || hFile2 == INVALID_HANDLE_VALUE ) {

        bFail = TRUE;
        goto Cleanup;
    }

    ProcessPrinterDrivers(hFile,
                          szInfName,
                          hwndParent,
                          &pDriverInfo9x,
                          &bFail);

    ProcessPrintMonitors(szInfName);

    ProcessPrinters(hFile,
                    hFile2,
                    szInfName,
                    pDriverInfo9x,
                    &bFail);

    //
    // If no network, shared printers found remove netwkprn.txt since it will be
    // empty
    //
    if ( dwNetPrinters == 0 && dwSharedPrinters == 0 ) {

        CloseHandle(hFile2);
        hFile2 = INVALID_HANDLE_VALUE;
        DeleteFileA(szFile);
    }

Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    if ( hFile2 != INVALID_HANDLE_VALUE )
        CloseHandle(hFile2);

    DestroyDriverInfo9xList(pDriverInfo9x);

#if DBG
    //
    // Make a copy in temp dir on debug builds so that if we messed up the
    // upgrade we can figure out what went wrong.
    // Setup deletes the working directory.
    //
    if ( GetTempPathA(SIZECHARS(szFile2), szFile2) ) {

        wsprintfA(szFile, "%s\\%s", UpgradeData.pszDir, "print95.txt");
        strcat(szFile2, "print95.txt");
        CopyFileA(szFile, szFile2, FALSE);
    }
#endif

    dwRet = bFail ? GetLastError() : ERROR_SUCCESS;
    if ( bFail && dwRet == ERROR_SUCCESS )
        dwRet = STG_E_UNKNOWN;

    if ( bFail )
        DebugMsg("MigrateSystem9x failed with %d", dwRet);

    return  dwRet;
}


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_9X     pfnInitialize9x         = Initialize9x;
P_MIGRATE_USER_9X   pfnMigrateUser9x        = MigrateUser9x;
P_MIGRATE_SYSTEM_9X pfnMigrateSystem9x      = MigrateSystem9x;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\network.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Network.c

Abstract:

    Routines to migrate Win95 network printers to NT via using RunOnce entries

Author:

    Muhunthan Sivapragasam (MuhuntS) 18-Aug-1997

Revision History:

--*/


#include "precomp.h"

BOOL            bDoNetPrnUpgrade        = FALSE;
LPSTR           pszNetPrnEntry          = NULL;
CHAR            szSpool[]               = "\\spool\\";
CHAR            szMigDll[]              = "migrate.dll";
CHAR            szRunOnceCount[]        = "RunOnceCount";
CHAR            szRunOnceCountPath[]    = "System\\CurrentControlSet\\control\\Print";
CHAR            szRunOnceRegistryPath[] = "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
//
//  This is stored in the registry so when network printer upgrade using
//  RunOnce key is tries enough times without success we can delete files
//
#define         MIN_NETWORK_PRN_RETRIES         5
DWORD           dwRunOnceCount          = 0;


LPSTR
GetRunOnceValueToSet(
    )
/*++
--*/
{
    CHAR    szPath[MAX_PATH];
    DWORD   dwLen, dwSize;
    LPSTR   pszRet = NULL;

    dwSize  = sizeof(szPath)/sizeof(szPath[0]);

    if ( !(dwLen = GetFileNameInSpoolDir(szPath, dwSize, szMigDll)) )
        goto Done;

    //
    // Now build up the RunOnce key which will be set for each user
    //
    dwSize = strlen("rundll32.exe") + dwLen +
                                    + strlen("ProcessWin9xNetworkPrinters") + 4;

    if ( pszRet = AllocMem(dwSize * sizeof(CHAR)) )
        sprintf(pszRet,
                "rundll32.exe %s,ProcessWin9xNetworkPrinters",
                szPath);
Done:
    return pszRet;
}


VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    )
/*++

Routine Description:
    This is called during InitializeSystemNT to setup the upgrade of network
    printers

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing

Return Value:
    None

    If everything was setup right bDoNetPrnUpgrade is TRUE, and pszNetPrnEntry
    is the value to set in per user registry for RunOnce

--*/
{
    CHAR    szSource[MAX_PATH], szTarget[MAX_PATH];
    DWORD   dwSize, dwLen;

    //
    // First check if the source paths is ok
    //
    dwLen   = strlen(szNetprnFile);

    dwSize  = sizeof(szTarget)/sizeof(szTarget[0]);

    if ( strlen(pszWorkingDir) + dwLen + 2 > dwSize )
        return;

    //
    // Need to make a copy of migrate.dll and netwkprn.txt to
    // the %windir%\system32\spool directory
    //
    sprintf(szSource, "%s\\%s", pszWorkingDir, szNetprnFile);
    if ( !GetFileNameInSpoolDir(szTarget, dwSize, szNetprnFile)         ||
         !CopyFileA(szSource, szTarget, FALSE) )
        return;

    if (!MakeACopyOfMigrateDll( pszWorkingDir ))
    {
        return;
    }
    
    bDoNetPrnUpgrade = (pszNetPrnEntry = GetRunOnceValueToSet()) != NULL;
}


VOID
WriteRunOnceCount(
    )
/*++

Routine Description:
    This routine is called to write the number of times we need to try the
    network printer upgrade

Arguments:
    None

Return Value:
    None

--*/
{
    HKEY    hKey;
    DWORD   dwSize;

    if ( dwRunOnceCount == 0 )
        return;

    //
    // We will try number of user + MIN_NETWORK_PRN_RETRIES till we succeed
    //
    dwRunOnceCount += MIN_NETWORK_PRN_RETRIES;

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szRunOnceCountPath,
                                        0,
                                        KEY_WRITE,
                                        &hKey) )
        return;

    dwSize = sizeof(dwRunOnceCount);
    RegSetValueExA(hKey,
                   szRunOnceCount,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwRunOnceCount,
                   dwSize);

    RegCloseKey(hKey);

}


BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    )
/*++

Routine Description:
    This is called during MigrateUserNT to handle network printer upgrade
    for the user

Arguments:
    hKeyUser    : Handle to the user registry key

Return Value:
    Return TRUE on success, and FALSE else

--*/
{
    HKEY    hKey = NULL;
    DWORD   dwLastError;

    dwLastError = RegCreateKeyExA(hKeyUser,
                                  szRunOnceRegistryPath,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey,
                                  NULL);

    if ( dwLastError == ERROR_SUCCESS ) {

        dwLastError = RegSetValueExA(hKey,
                                     "Printing Migration",
                                     0,
                                     REG_SZ,
                                     pszNetPrnEntry,
                                     ( strlen(pszNetPrnEntry) + 1 )
                                        * sizeof(CHAR));

#ifdef VERBOSE
    if ( dwLastError == ERROR_SUCCESS )
        DebugMsg("Wrote %s to %s", pszNetPrnEntry, szRunOnceRegistryPath);
#endif
    }

    if ( hKey )
        RegCloseKey(hKey);

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


VOID
DecrementRunOnceCount(
    IN  DWORD   dwDiff,
    IN  BOOL    bResetRunOnceForUser
    )
/*++

Routine Description:
    Called after once network printer upgrade is called when user logged in,
    so we can decrement the retry count

    When ref count reaches 0 we then we can delete the files
Arguments:
    dwDiff                  : Value by which ref count should be decremented
    bResetRunOnceForUser    : We need to set RunOnce key again for the user

Return Value:
    None

--*/
{
    HKEY    hKey;
    DWORD   dwSize, dwCount, dwType;
    CHAR    szPath[MAX_PATH];

    if ( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szRunOnceCountPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey) )
        return;

    dwSize = sizeof(dwCount);
    if ( ERROR_SUCCESS == RegQueryValueExA(hKey, szRunOnceCount, 0, &dwType,
                                           (LPBYTE)&dwCount, &dwSize) ) {

        dwCount -= dwDiff;
        if ( dwCount ) {

            RegSetValueExA(hKey,
                           szRunOnceCount,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwCount,
                           dwSize);

            if ( bResetRunOnceForUser   &&
                 (pszNetPrnEntry = GetRunOnceValueToSet()) ) {

                ProcessNetPrnUpgradeForUser(HKEY_CURRENT_USER);
                FreeMem(pszNetPrnEntry);
                pszNetPrnEntry = NULL;

#ifdef  VERBOSE
            DebugMsg("Processing network/shared printers failed. Will try next time user logs in.");
#endif
            }
            
        } else {

            dwSize = sizeof(szPath)/sizeof(szPath[0]);
            RegDeleteValueA(hKey, szRunOnceCount);

            if ( GetFileNameInSpoolDir(szPath, dwSize, szMigDll) )
                DeleteFileA(szPath);

            if ( GetFileNameInSpoolDir(szPath, dwSize, szNetprnFile) )
                DeleteFileA(szPath);

            DebugMsg("Giving up on setting network/shared printers");
        }
    }

    RegCloseKey(hKey);
}


BOOL
AddNetworkPrinter(
    IN  LPPRINTER_INFO_2A   pPrinterInfo2
    )
/*++

Routine Description:
    This is called to add a windows 9x network printer. We will first try to
    make a conenction and if that fails we will add a masq. printer

Arguments:
    pPrinterInfo2   : Pointer to printer info 2 of the printer

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL    bRet = FALSE;
    LPSTR   pszName, psz;
    HANDLE  hPrinter = NULL;

    pszName = pPrinterInfo2->pPortName;

    if ( !OpenPrinterA(pszName, &hPrinter, NULL) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("OpenPrinter failed for %s. %s", pszName, psz);
            FreeMem(psz);
        }
        goto Done;
    }

    //
    // Try to make a printer connection. If that fails with some error
    // other than unknown driver create a masq printer
    //
    if (  AddPrinterConnectionA(pszName) ) {

        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DEFAULT )
            SetDefaultPrinterA(pszName);
        bRet = TRUE;
        goto Done;
    }

    if ( GetLastError() == ERROR_UNKNOWN_PRINTER_DRIVER ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("AddPrinterConnection failed for %s. %s", pszName, psz);
            FreeMem(psz);
        }
        goto Done;
    }

    ClosePrinter(hPrinter);

    //
    // Masc. printers should have port name, printer name both saying
    // \\server\share. Otherwise printui gets confused and does not refresh
    // server status correctly (this is since printui has to poll for masc.
    // printers)
    //
    // So we need to fixup PrinterInfo2 temporarily
    //
    psz = pPrinterInfo2->pPrinterName;
    pPrinterInfo2->pPrinterName = pPrinterInfo2->pPortName;

    if ( hPrinter  = AddPrinterA(NULL, 2, (LPBYTE)pPrinterInfo2) ) {

        if ( pPrinterInfo2->Attributes & PRINTER_ATTRIBUTE_DEFAULT )
            SetDefaultPrinterA(pPrinterInfo2->pPrinterName);

        pPrinterInfo2->pPrinterName = psz;
        bRet = TRUE;
        goto Done;
    }

    pPrinterInfo2->pPrinterName = psz;

    if ( psz = ErrorMsg() ) {

        DebugMsg("AddPrinterA failed for %s. %s", pszName, psz);
        FreeMem(psz);
    }

Done:
    if ( hPrinter )
        ClosePrinter(hPrinter);

    return bRet;
}


BOOL
SharePrinter(
    IN  LPSTR   pszPrinterName
    )
/*++

Routine Description:
    This is called to share a printer when the user logs in for the first time
    to NT. Printers can not be shared during GUI setup because we are not on
    the network yet.

Arguments:
    pszPrinterName  : Printer name

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL                bRet = FALSE;
    DWORD               dwNeeded;
    HANDLE              hPrinter = NULL;
    LPBYTE              pBuf = NULL;
    LPSTR               psz;
    PRINTER_DEFAULTS    PrinterDflts = { NULL, NULL, PRINTER_ALL_ACCESS };

    if ( !OpenPrinterA(pszPrinterName, &hPrinter, &PrinterDflts) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("OpenPrinterA failed for %s. %s", pszPrinterName, psz);
            FreeMem(psz);
        }

        goto Cleanup;
    }

    GetPrinterA(hPrinter, 2, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER            ||
         !(pBuf = AllocMem(dwNeeded))                           ||
         !GetPrinterA(hPrinter, 2, pBuf, dwNeeded, &dwNeeded) ) {

        if ( psz = ErrorMsg() ) {

            DebugMsg("GetPrinterA failed for %s. %s", pszPrinterName, psz);
            FreeMem(psz);
        }

        goto Cleanup;
    }

    ((LPPRINTER_INFO_2A)pBuf)->Attributes |= PRINTER_ATTRIBUTE_SHARED;

    bRet = SetPrinterA(hPrinter, 2, pBuf, 0);

    if ( !bRet && (psz = ErrorMsg()) ) {

        DebugMsg("OpenPrinterA failed for %s. %s", pszPrinterName, psz);
        FreeMem(psz);
    }

Cleanup:
    if ( hPrinter )
        ClosePrinter(hPrinter);
    FreeMem(pBuf);

    return bRet;
}


VOID
ProcessWin9xNetworkPrinters(
    )
/*++

Routine Description:
    This is called the first time the user logs in to create network printer
    connections/masq printers.
    Reads the Win9x printing configuration we stored in the text file
    so that printing components can be upgraded

Arguments:
    ppPrinterNode           : Gives the list of netowrk printers on Win9x

Return Value:
    TRUE on succesfully reading the config information, FALSE else

--*/
{
    BOOL                bFail = FALSE, bSuccess = TRUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    CHAR                c, szFile[MAX_PATH], szLine[2*MAX_PATH];
    DWORD               dwSize, dwLen;
    PRINTER_INFO_2A     PrinterInfo2;

#ifdef VERBOSE
    DebugMsg("ProcessWin9xNetworkPrinters called");
#endif
    //
    // If file is not found quit
    //
    dwSize = sizeof(szFile)/sizeof(szFile[0]);
    if ( !GetFileNameInSpoolDir(szFile, dwSize, szNetprnFile) ) {

        DebugMsg("ProcessWin9xNetworkPrinters: GetFileNameInSpoolDir failed\n");
        goto Cleanup;
    }

    hFile = CreateFileA(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                            FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE ) {

        DebugMsg("ProcessWin9xNetworkPrinters: CreateFile failed with %d for %s",
                 GetLastError(), szLine);
        goto Cleanup;
    }

    //
    // Read the printer info
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL                    ||    
         strncmp(szLine, "[Printers]", strlen("[Printers]")) )
        goto Cleanup;

    do {

        c = (CHAR) My_fgetc(hFile);

        if ( c == EOF || c == '\n' )
            break;  // Normal exit

        if ( c != 'S' || !My_ungetc(hFile) )
            goto Cleanup;

        ZeroMemory(&PrinterInfo2, sizeof(PrinterInfo2));

        ReadPrinterInfo2(hFile, &PrinterInfo2, &bFail);

        if ( bFail )
            goto Cleanup;

        //
        // If this was a network printer on Win9x it needs to be added as a
        // connection or as a masc printer
        //
        if ( PrinterInfo2.Attributes & PRINTER_ATTRIBUTE_NETWORK ) {

            if ( !AddNetworkPrinter(&PrinterInfo2) && bSuccess )
                bSuccess = FALSE;
        } else if ( PrinterInfo2.Attributes & PRINTER_ATTRIBUTE_SHARED ) {

            if ( !SharePrinter(PrinterInfo2.pPrinterName) && bSuccess )
                bSuccess = FALSE;
        }

    } while ( !bFail );


Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    if ( bSuccess && !bFail )
        DecrementRunOnceCount(MIN_NETWORK_PRN_RETRIES, FALSE);
    else
        DecrementRunOnceCount(1, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\test\win9x.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Win9x.c

Abstract:

    Test pre-migration of Win95 to NT

Author:
    MuhuntS


Revision History:
    01-17-97


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <plugin.h>

P_QUERY_VERSION         QueryVersion;
P_INITIALIZE_9X         Initialize9x;
P_MIGRATE_SYSTEM_9X     MigrateSystem9x;

P_INITIALIZE_NT         InitializeNT;
P_MIGRATE_SYSTEM_NT     MigrateSystemNT;

WCHAR   szSrcDir[MAX_PATH], szWrkDir[MAX_PATH];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    PVENDORINFO     pVI;
    HMODULE         hModule;
    HANDLE          hAlive = NULL;
    DWORD           dwLastError;
    LPSTR           p1, p2, p3, p4, p5;
    LONG            x;
    UINT            v;
    INT             c;
    LONG            lLastErr;
    char            error_buffer[300];

    p1 = p2 = p3 = p4 = p5 = NULL;

    if ( argc < 3 ) {

        printf("Usage: %s <working-dir> <source-dir>\n", argv[0]);
        return 0;
    }

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        lLastErr = GetLastError();

        FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, NULL, lLastErr, 0L, error_buffer,
            sizeof(error_buffer), NULL );

        printf("%s: LoadLibrary failed with %d - %s\n", argv[0], lLastErr, error_buffer);
        goto Cleanup;
    }

    //
    // Nt only?
    //
    if ( argc == 4 && argv[3][0] == '+' )
        goto DoNT;

    (FARPROC) QueryVersion      = GetProcAddress(hModule, "QueryVersion");
    (FARPROC) Initialize9x      = GetProcAddress(hModule, "Initialize9x");
    (FARPROC) MigrateSystem9x   = GetProcAddress(hModule, "MigrateSystem9x");

    if ( !QueryVersion || !Initialize9x || !MigrateSystem9x )
        goto Cleanup;

    x = QueryVersion(&p1, (LPUINT)&p2, (LPINT*)&p3, &p4, (PVENDORINFO*)&pVI);

    printf("QueryVersion returned %d\n", x);

    x = Initialize9x(argv[1], argv[2], 0);

    printf("Initialize9x returned %d\n", x);

    x = MigrateSystem9x(0, NULL, 0);

    printf("MigrateSystem9x returned %d\n", x);

    FreeLibrary(hModule);

    //
    // Win95 only?
    //
    if ( argc == 4 && argv[3][0] == '-' )
        goto Cleanup;

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        lLastErr = GetLastError();

        FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, NULL, lLastErr, 0L, error_buffer,
            sizeof(error_buffer), NULL );

        printf("%s: LoadLibrary II failed with %d - %s\n", argv[0], lLastErr, error_buffer);
        goto Cleanup;
    }

DoNT:
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[1],
                        -1,
                        szWrkDir,
                        MAX_PATH);

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[2],
                        -1,
                        szSrcDir,
                        MAX_PATH);

    InitializeNT     = (P_INITIALIZE_NT)GetProcAddress(hModule, "InitializeNT");
    MigrateSystemNT  = (P_MIGRATE_SYSTEM_NT)GetProcAddress(hModule, "MigrateSystemNT");

    if ( !InitializeNT || !MigrateSystemNT )
        goto Cleanup;

    hAlive = CreateEventA(NULL, FALSE, FALSE, "MigDllAlive");

    if ( ERROR_SUCCESS == InitializeNT(szWrkDir, szSrcDir, 0) )
        MigrateSystemNT(INVALID_HANDLE_VALUE, 0);

    FreeLibrary(hModule);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    if ( hAlive )
        CloseHandle(hAlive);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\nt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Nt.c

Abstract:

    Routines to migrate Win95 printing components to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"


//
// Data structures to gather info from the text files created on Win95 to
// store the printing configuration
//
typedef struct _DRIVER_NODE {

    struct _DRIVER_NODE    *pNext;
    DRIVER_INFO_1A          DrvInfo1;
    PPSETUP_LOCAL_DATA      pLocalData;
    BOOL                    bCantAdd;
} DRIVER_NODE, *PDRIVER_NODE;

typedef struct _PRINTER_NODE {

    struct _PRINTER_NODE   *pNext;
    PRINTER_INFO_2A         PrinterInfo2;
} PRINTER_NODE, *PPRINTER_NODE;

typedef struct _PORT_NODE {

    struct _PORT_NODE   *pNext;
    LPSTR                pPortName;
} PORT_NODE, *PPORT_NODE;

LPSTR           pszDefaultPrinterString = NULL;
PPRINTER_NODE   pDefPrinter = NULL;

//
// They kill the migration dll if it does not finish in 3 minutes.
// To prevent that I need to set this handle atleast every 3 mins
//
HANDLE          hAlive = NULL;

//
// We want to lazy load ntprint.dll and mscms.dll.
//      Note : If we link to them our DLL will not run on Win9x
//
struct {

    HMODULE                     hNtPrint;

    pfPSetupCreatePrinterDeviceInfoList         pfnCreatePrinterDeviceInfoList;
    pfPSetupDestroyPrinterDeviceInfoList        pfnDestroyPrinterDeviceInfoList;
    pfPSetupBuildDriversFromPath                pfnBuildDriversFromPath;
    pfPSetupDriverInfoFromName                  pfnDriverInfoFromName;
    pfPSetupDestroySelectedDriverInfo           pfnDestroySelectedDriverInfo;
    pfPSetupGetLocalDataField                   pfnGetLocalDataField;
    pfPSetupFreeDrvField                        pfnFreeDrvField;
    pfPSetupProcessPrinterAdded                 pfnProcessPrinterAdded;
    pfPSetupInstallICMProfiles                  pfnInstallICMProfiles;
    pfPSetupAssociateICMProfiles                pfnAssociateICMProfiles;
} LAZYLOAD_INFO;


VOID
FreePrinterNode(
    IN  PPRINTER_NODE    pPrinterNode
    )
/*++

Routine Description:
    Free the memory allocated for a PRINTER_NODE element and strings in it

Arguments:
    pPrinterNode    : Points to the structure to free memory

Return Value:
    None

--*/
{

    FreePrinterInfo2Strings(&pPrinterNode->PrinterInfo2);
    FreeMem(pPrinterNode);
}


VOID
FreePrinterNodeList(
    IN  PPRINTER_NODE   pPrinterNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PRINTER_NODE linked list

Arguments:
    pPrinterNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PPRINTER_NODE   pNext;

    while ( pPrinterNode ) {

        pNext = pPrinterNode->pNext;
        FreePrinterNode(pPrinterNode);
        pPrinterNode = pNext;
    }
}


VOID
FreeDriverNode(
    IN  PDRIVER_NODE    pDriverNode
    )
/*++

Routine Description:
    Free the memory allocated for a DRIVER_NODE element and fields in it

Arguments:
    pDriverNode : Points to the structure to free memory

Return Value:
    None

--*/
{
    if ( pDriverNode->pLocalData )
        LAZYLOAD_INFO.pfnDestroySelectedDriverInfo(pDriverNode->pLocalData);
    FreeMem(pDriverNode->DrvInfo1.pName);
    FreeMem(pDriverNode);
}


VOID
FreeDriverNodeList(
    IN  PDRIVER_NODE   pDriverNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PDRIVER_NODE linked list

Arguments:
    pDriverNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PDRIVER_NODE   pNext;

    while ( pDriverNode ) {

        pNext = pDriverNode->pNext;
        FreeDriverNode(pDriverNode);
        pDriverNode = pNext;
    }
}

VOID
FreePortNode(
    IN  PPORT_NODE   pPortNode
    )
/*++

Routine Description:
    Free the memory allocated for a PORT_NODE element and fields in it

Arguments:
    PPORT_NODE : Points to the structure to free memory

Return Value:
    None

--*/
{
    if (pPortNode->pPortName)
    {
        FreeMem(pPortNode->pPortName);
    }

    FreeMem(pPortNode);
}

VOID
FreePortNodeList(
    IN  PPORT_NODE   pPortNode
    )
/*++

Routine Description:
    Free the memory allocated for elements in the PORT_NODE linked list

Arguments:
    pPortNode    : Points to the head of linked list to free memory

Return Value:
    None

--*/
{
    PPORT_NODE   pNext;

    while ( pPortNode ) {

        pNext = pPortNode->pNext;
        FreePortNode(pPortNode);
        pPortNode = pNext;
    }
}

PPSETUP_LOCAL_DATA
FindLocalDataForDriver(
    IN  PDRIVER_NODE    pDriverList,
    IN  LPSTR           pszDriverName
    )
/*++

Routine Description:
    Find the local data for a given driver name from the list

Arguments:

Return Value:
    Valid PPSETUP_LOCAL_DATA on success, else NULL

--*/
{

    while ( pDriverList ) {

        if ( !_strcmpi(pszDriverName, pDriverList->DrvInfo1.pName) )
            return pDriverList->pLocalData;

        pDriverList = pDriverList->pNext;
    }

    return NULL;

}


BOOL
InitLazyLoadInfo(
    VOID
    )
/*++

Routine Description:
    Initializes the LAZYLOAD_INFO structure with LoadLibrary & GetProcAddress

Arguments:
    None

Return Value:
    TRUE on success, FALSE else

--*/
{
    if ( LAZYLOAD_INFO.hNtPrint = LoadLibraryUsingFullPathA("ntprint.dll") ) {

        (FARPROC)LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupCreatePrinterDeviceInfoList");

        (FARPROC)LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDestroyPrinterDeviceInfoList");

        (FARPROC)LAZYLOAD_INFO.pfnBuildDriversFromPath
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupBuildDriversFromPath");

        (FARPROC)LAZYLOAD_INFO.pfnDriverInfoFromName
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDriverInfoFromName");

        (FARPROC)LAZYLOAD_INFO.pfnDestroySelectedDriverInfo
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupDestroySelectedDriverInfo");

        (FARPROC)LAZYLOAD_INFO.pfnGetLocalDataField
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupGetLocalDataField");

        (FARPROC)LAZYLOAD_INFO.pfnFreeDrvField
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupFreeDrvField");

        (FARPROC)LAZYLOAD_INFO.pfnProcessPrinterAdded
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupProcessPrinterAdded");

        (FARPROC)LAZYLOAD_INFO.pfnInstallICMProfiles
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupInstallICMProfiles");

        (FARPROC)LAZYLOAD_INFO.pfnAssociateICMProfiles
            = GetProcAddress(LAZYLOAD_INFO.hNtPrint,
                             "PSetupAssociateICMProfiles");

        if ( LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList   &&
             LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList  &&
             LAZYLOAD_INFO.pfnBuildDriversFromPath          &&
             LAZYLOAD_INFO.pfnDriverInfoFromName            &&
             LAZYLOAD_INFO.pfnDestroySelectedDriverInfo     &&
             LAZYLOAD_INFO.pfnGetLocalDataField             &&
             LAZYLOAD_INFO.pfnFreeDrvField                  &&
             LAZYLOAD_INFO.pfnProcessPrinterAdded           &&
             LAZYLOAD_INFO.pfnInstallICMProfiles            &&
             LAZYLOAD_INFO.pfnAssociateICMProfiles ) {

#ifdef VERBOSE
    DebugMsg("Succesfully loaded Ntprint.dll");
#endif
            return TRUE;
    }

    }

    if ( LAZYLOAD_INFO.hNtPrint )
    {
        FreeLibrary(LAZYLOAD_INFO.hNtPrint);
        LAZYLOAD_INFO.hNtPrint = NULL;
    }

    return FALSE;
}


VOID
DeleteWin95Files(
    )
/*++

Routine Description:
    Read the migrate.inf and delete the files which are not needed on NT.

Arguments:
    None

Return Value:
    None

--*/
{
    HINF            hInf;
    CHAR            szPath[MAX_PATH];
    LONG            Count, Index;
    INFCONTEXT      InfContext;

    sprintf(szPath, "%s\\%s", UpgradeData.pszDir, "migrate.inf");

    hInf = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);

    if ( hInf == INVALID_HANDLE_VALUE )
        return;

    //
    // We will only do the deleting part here. Files which are handled by
    // the core migration dll do not have a destination directory since we
    // are recreating the printing environment from scratch
    //
    if ( (Count = SetupGetLineCountA(hInf, "Moved")) != -1 ) {

        for ( Index = 0 ; Index < Count ; ++Index ) {

            if ( SetupGetLineByIndexA(hInf, "Moved", Index, &InfContext)    &&
                 SetupGetStringFieldA(&InfContext, 0, szPath,
                                      SIZECHARS(szPath), NULL) )
                DeleteFileA(szPath);
        }
    }

    SetupCloseInfFile(hInf);
}


BOOL
ReadWin9xPrintConfig(
    IN  OUT PDRIVER_NODE   *ppDriverNode,
    IN  OUT PPRINTER_NODE  *ppPrinterNode,
    IN  OUT PPORT_NODE  *ppPortNode
    )
/*++

Routine Description:
    Reads the Win9x printing configuration we stored in the text file
    so that printing components can be upgraded

Arguments:
    ppDriverNode            : Gives the list of drivers on Win9x
    ppPrinterNode           : Gives the list of printers on Win9x

Return Value:
    TRUE on successfully reading the config information, FALSE else

--*/
{
    BOOL                bFail = FALSE, bRet = FALSE;
    HANDLE              hFile;
    CHAR                c, szLine[2*MAX_PATH];
    DWORD               dwCount, dwIndex, dwSize;
    PDRIVER_NODE        pDrv = NULL;
    PPRINTER_NODE       pPrn;
    PPORT_NODE          pPort;

    sprintf(szLine, "%s\\%s", UpgradeData.pszDir, "print95.txt");

    hFile = CreateFileA(szLine,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
        goto Cleanup;

    dwSize = sizeof(szLine)/sizeof(szLine[0]);

    //
    // First we have the drivers
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[PrinterDrivers]", strlen("[PrinterDrivers]")) )
        goto Cleanup;

    do {

        //
        // Skip blanks
        //
        do {
            c = (CHAR) My_fgetc(hFile);
        } while ( c == ' ');

        //
        // If we hit EOF it is an error. Configuration was not written properly
        // If we hit a new-line then we are at the end of the section
        //
        if ( c == EOF )
            goto Cleanup;
        else if ( c == '\n' )
            break;  // This is the normal exit from the do loop

        if ( isdigit(c) ) {

            //
            // Put the string lengh digit back
            //
            if ( !My_ungetc(hFile) )
                goto Cleanup;
        }

        if ( !(pDrv = AllocMem(sizeof(DRIVER_NODE))) )
            goto Cleanup;

        ReadString(hFile, "", &pDrv->DrvInfo1.pName, FALSE, &bFail);

        if ( bFail ) {

            FreeDriverNode(pDrv);
            goto Cleanup;
        }

        pDrv->pNext     = *ppDriverNode;
        *ppDriverNode   = pDrv;
    } while ( !bFail );


    //
    // Now we have port info
    //

    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[Ports]", strlen("[Ports]")) )
        goto Cleanup;

    do {

        //
        // Skip blanks
        //
        do {
            c = (CHAR) My_fgetc(hFile);
        } while ( isspace(c)  && c != '\n' );

        //
        // EOF can happen if no ports and no printers, else it's an error
        //
        if ( c == EOF)
        {
            if (!pDrv)
            {
                bRet = TRUE;
            }
            goto Cleanup;
        }

        //
        // a blank line means the end of the port info section
        //
        if (c == '\n')
            break;

        if ( c != 'P' || !My_ungetc(hFile) )
            goto Cleanup;

        //
        // Create port node
        //
        if ( !(pPort = AllocMem(sizeof(PORT_NODE))) )
        {
            goto Cleanup;
        }

        ReadString(hFile, "PortName:", &pPort->pPortName, FALSE, &bFail);

        if (bFail)
        {
            FreePortNode(pPort);
            goto Cleanup;
        }

        pPort->pNext = *ppPortNode;
        *ppPortNode = pPort;

    } while ( !bFail );

    //
    // Now we have printer info
    //
    if ( My_fgets(szLine, dwSize, hFile) == NULL    ||
         strncmp(szLine, "[Printers]", strlen("[Printers]")) )
        goto Cleanup;

    do {

        c = (CHAR) My_fgetc(hFile);

        if ( c == EOF || c == '\n' )
            break;  // Normal exit

        if ( c != 'S' || !My_ungetc(hFile) )
            goto Cleanup;

        if ( !(pPrn = AllocMem(sizeof(PRINTER_NODE))) )
            goto Cleanup;

        ReadPrinterInfo2(hFile, &pPrn->PrinterInfo2, &bFail);

        if ( bFail ) {

            FreePrinterNode(pPrn);
            goto Cleanup;
        }

        pPrn->pNext = *ppPrinterNode;
        *ppPrinterNode = pPrn;
    } while ( !bFail );

    bRet = TRUE;

Cleanup:

    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle(hFile);

    return bRet && !bFail;
}


BOOL
CheckAndAddMonitor(
    IN  LPDRIVER_INFO_6W    pDrvInfo6
    )
/*++

Routine Description:
    Check if there is a language monitor associated with the given driver
    and add it.

Arguments:

Return Value:
    TRUE on success, FALSE on failure
    None

--*/
{
    MONITOR_INFO_2W MonitorInfo2;
    LPWSTR          psz = pDrvInfo6->pMonitorName;
    LPSTR           pszStr;

    if ( psz && *psz ) {

        MonitorInfo2.pName          = psz;
        MonitorInfo2.pEnvironment   = NULL;
        MonitorInfo2.pDLLName       = (LPWSTR) (psz+wcslen(psz)+1);

        //
        // Add is succesful, or monitor is already installed?
        //
        if ( AddMonitorW(NULL, 2, (LPBYTE) &MonitorInfo2) ||
            GetLastError() == ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) {

            return TRUE;
        } else {

            if ( pszStr = ErrorMsg() ) {

                LogError(LogSevError, IDS_ADDMONITOR_FAILED,
                         psz, pszStr);
                FreeMem(pszStr);
            }
            return FALSE;
        }
    }

    return TRUE;
}


VOID
KeepAliveThread(
    HANDLE  hRunning
    )
/*++

Routine Description:
    Printing migration may take a long time depending on number of printers and
    how long spooler takes to return. To inform setup that we are still alive
    I need to set a named event atleast once every 3 minutes

Arguments:
    hRunning    : When this gets closed we know processing is done

Return Value:
    None

--*/
{
    //
    // Every 30 seconds set the global event telling we are still alive
    //
    do {

        SetEvent(hAlive);
    } while ( WAIT_TIMEOUT == WaitForSingleObject(hRunning, 1000*30) );

    CloseHandle(hAlive);
    hAlive = NULL;
}


VOID
UpgradePrinterDrivers(
    IN      PDRIVER_NODE    pDriverNode,
    IN      HDEVINFO        hDevInfo,
    IN  OUT LPBOOL          pbFail
    )
/*++

Routine Description:
    Upgrades printer drivers by doing the file copy operations and calling
    AddPrinterDriver on spooler

Arguments:
    pUpgradableDrvNode      : List of drivers to upgrade
    pbFail                  : Set on an error -- no more processing needed

Return Value:
    None

--*/
{
    BOOL            bDriverToUpgrade = FALSE;
    LPWSTR          pszDriverW, pszICMW;
    LPSTR           pszDriverA, pszStr;
    PDRIVER_NODE    pCur;
    DRIVER_FIELD    DrvField;

    //
    // Set device install parameters so ntprint.dll will just queue up the
    // driver files and return without doing the copy. We will commit the
    // file queue at the end
    //
    if ( !InitFileCopyOnNT(hDevInfo) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Now for each printer driver call ntprint.dll to queue up the driver files
    // If it fails log an error
    //
    for ( pCur = pDriverNode ; pCur ; pCur = pCur->pNext ) {

        pszDriverA = pCur->DrvInfo1.pName;

        if ( (pszDriverW = AllocStrWFromStrA(pszDriverA))                   &&
             (pCur->pLocalData = LAZYLOAD_INFO.pfnDriverInfoFromName(
                                            hDevInfo, (LPSTR)pszDriverW))   &&
             SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                       hDevInfo,
                                       NULL) ) {

            bDriverToUpgrade = TRUE;
        } else {

            pCur->bCantAdd = TRUE;
        }

        FreeMem(pszDriverW);
    }

    if ( !bDriverToUpgrade )
        goto Cleanup;


#ifdef  VERBOSE
    DebugMsg("Starting file copy ...");
#endif

    //
    // Now commit the file queue to copy the files
    //
    if ( !CommitFileQueueToCopyFiles(hDevInfo) ) {

        *pbFail = TRUE;
        if ( pszStr = ErrorMsg() ) {

            LogError(LogSevError, IDS_DRIVERS_UPGRADE_FAILED, pszStr);
            FreeMem(pszStr);
        }
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("... files copied successfully");
#endif

    //
    // Now call spooler to install the printer driver. Also install the
    // ICM profiles associated with the printer driver
    //
    for ( pCur = pDriverNode ; pCur ; pCur = pCur->pNext ) {

        //
        // We already logged an error if bCantAdd is TRUE
        //
        if ( pCur->bCantAdd )
            continue;

        DrvField.Index          = DRV_INFO_6;
        DrvField.pDriverInfo4   = NULL;

        if ( !LAZYLOAD_INFO.pfnGetLocalDataField(pCur->pLocalData,
                                                 PlatformX86,
                                                 &DrvField)                 ||
             !CheckAndAddMonitor((LPDRIVER_INFO_6W) DrvField.pDriverInfo6)  ||
             !AddPrinterDriverW(NULL,
                                6,
                                (LPBYTE)DrvField.pDriverInfo6) ) {

            if ( pszStr = ErrorMsg() ) {

                LogError(LogSevError, IDS_ADDDRIVER_FAILED, pCur->DrvInfo1.pName, pszStr);
                FreeMem(pszStr);
            }
        }

        LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);

        DrvField.Index          = ICM_FILES;
        DrvField.pszzICMFiles   = NULL;

        if ( !LAZYLOAD_INFO.pfnGetLocalDataField(pCur->pLocalData,
                                                 PlatformX86,
                                                 &DrvField) ) {

            continue;
        }

        if ( DrvField.pszzICMFiles )
            LAZYLOAD_INFO.pfnInstallICMProfiles(NULL,
                                                DrvField.pszzICMFiles);

        LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);

    }

Cleanup:
    return;
}


PSECURITY_DESCRIPTOR
GetSecurityDescriptor(
    IN  LPCSTR  pszUser
    )
/*++

Routine Description:
    Get the users security

Arguments:
    pszUser     : sub key under HKEY_USER

Return Value:
    NULL on error, else a valid SECURITY_DESCRIPTOR.
    Memory is allocated in the heap and caller should free it.

--*/
{
    HKEY                    hKey = NULL;
    DWORD                   dwSize;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if ( RegOpenKeyExA(HKEY_USERS,
                       pszUser,
                       0,
                       KEY_READ|KEY_WRITE,
                       &hKey)                                       ||
         RegGetKeySecurity(hKey,
                           DACL_SECURITY_INFORMATION,
                           NULL,
                           &dwSize) != ERROR_INSUFFICIENT_BUFFER    ||
         !(pSD = (PSECURITY_DESCRIPTOR) AllocMem(dwSize))           ||
         RegGetKeySecurity(hKey,
                           DACL_SECURITY_INFORMATION,
                           pSD,
                           &dwSize) ) {

        if ( hKey )
            RegCloseKey(hKey);

        FreeMem(pSD);
        pSD = NULL;
    }

    return pSD;
}


typedef BOOL (WINAPI *P_XCV_DATA_W)(
                                    IN HANDLE  hXcv,
                                    IN PCWSTR  pszDataName,
                                    IN PBYTE   pInputData,
                                    IN DWORD   cbInputData,
                                    OUT PBYTE   pOutputData,
                                    IN DWORD   cbOutputData,
                                    OUT PDWORD  pcbOutputNeeded,
                                    OUT PDWORD  pdwStatus
                                );

BOOL
AddLocalPort(
    IN  LPSTR           pPortName
)
/*++

Routine Description:
    Adds a local port

Arguments:
    pPortName    : Name of the local port to add

Return Value:
    FALSE if a port can't be added.

--*/

{
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE  hXcvMon = NULL;
    BOOL  bReturn = FALSE;

    if (OpenPrinterA(",XcvMonitor Local Port", &hXcvMon, &PrinterDefault))
    {
        DWORD cbOutputNeeded = 0;
        DWORD Status         = NO_ERROR;
        WCHAR *pUnicodePortName = NULL;
        P_XCV_DATA_W pXcvData = NULL;
        HMODULE hWinSpool = NULL;

        //
        // if I implib-link to XcvData, loading the migrate.dll on Win9x will fail !
        //
        hWinSpool = LoadLibraryUsingFullPathA("winspool.drv");

        if (!hWinSpool)
        {
            DebugMsg("LoadLibrary on winspool.drv failed");
            goto Done;
        }

        pXcvData = (P_XCV_DATA_W) GetProcAddress(hWinSpool, "XcvDataW");

        if (!pXcvData)
        {
            DebugMsg("GetProcAddress on winspool.drv failed");
            goto Done;
        }

        pUnicodePortName = AllocStrWFromStrA(pPortName);
        if (pUnicodePortName)
        {
            bReturn = (*pXcvData)(hXcvMon,
                              L"AddPort",
                              (LPBYTE) pUnicodePortName,
                              (wcslen(pUnicodePortName) +1) * sizeof(WCHAR),
                              NULL,
                              0,
                              &cbOutputNeeded,
                              &Status
                              );

            FreeMem(pUnicodePortName);
        }

    Done:
        if (hWinSpool)
        {
            FreeLibrary(hWinSpool);
        }
        ClosePrinter(hXcvMon);
   }

   return bReturn;
}

VOID
UpgradePrinters(
    IN  PPRINTER_NODE   pPrinterNode,
    IN  PDRIVER_NODE    pDriverNode,
    IN  PPORT_NODE     *ppPortNode,
    IN  HDEVINFO        hDevInfo
    )
/*++

Routine Description:
    Upgrade printers on NT

Arguments:
    pPrinterNode    : Gives the list giving information about the printers
                      which existed on Win9x

Return Value:
    None

--*/
{
    DWORD               dwLen, dwLastError;
    LPSTR               pszStr, pszPrinterNameA;
    LPWSTR              pszPrinterNameW;
    HANDLE              hPrinter;
    DRIVER_FIELD        DrvField;
    PPSETUP_LOCAL_DATA  pLocalData;
    PPORT_NODE          pCurPort, pPrevPort = NULL;
    DWORD               dwSize;
    LPSTR               pszVendorSetupA = NULL;


    for ( ; pPrinterNode ; pPrinterNode = pPrinterNode->pNext ) {

        pszPrinterNameA = pPrinterNode->PrinterInfo2.pPrinterName;

        //
        // check whether this printer uses a non-standard local file port
        //
        for (pCurPort = *ppPortNode; pCurPort != NULL; pPrevPort = pCurPort, pCurPort = pCurPort->pNext)
        {
            if (lstrcmpi(pPrinterNode->PrinterInfo2.pPortName, pCurPort->pPortName) == 0)
            {
                //
                // Create the port
                //
                AddLocalPort(pCurPort->pPortName);

                //
                // remove it from the list
                //
                if (pCurPort == *ppPortNode)
                {
                    *ppPortNode = pCurPort->pNext;
                }
                else
                {
                    pPrevPort->pNext = pCurPort->pNext;
                }

                FreePortNode(pCurPort);

                break;
            }
        }

        hPrinter = AddPrinterA(NULL,
                               2,
                               (LPBYTE)&pPrinterNode->PrinterInfo2);

        if ( !hPrinter ) {

            dwLastError = GetLastError();

            //
            // If driver is unknown we already logged warned the user
            // If printer already exists it is ok (for Fax printer this is true)
            //
            if ( dwLastError != ERROR_UNKNOWN_PRINTER_DRIVER        &&
                 dwLastError != ERROR_INVALID_PRINTER_NAME          &&
                 dwLastError != ERROR_PRINTER_ALREADY_EXISTS        &&
                 (pszStr = ErrorMsg()) ) {

                LogError(LogSevError,
                         IDS_ADDPRINTER_FAILED,
                         pszPrinterNameA,
                         pszStr);
                FreeMem(pszStr);
            }
            continue;
        }

        pLocalData = FindLocalDataForDriver(pDriverNode,
                                            pPrinterNode->PrinterInfo2.pDriverName);
        pszPrinterNameW = AllocStrWFromStrA(pszPrinterNameA);

        if ( pLocalData && pszPrinterNameW ) {

            DrvField.Index          = ICM_FILES;
            DrvField.pszzICMFiles   = NULL;

            if ( LAZYLOAD_INFO.pfnGetLocalDataField(pLocalData,
                                                    PlatformX86,
                                                    &DrvField) ) {

                if ( DrvField.pszzICMFiles )
                    LAZYLOAD_INFO.pfnAssociateICMProfiles(
                                            (LPTSTR)pszPrinterNameW,
                                            DrvField.pszzICMFiles);

                LAZYLOAD_INFO.pfnFreeDrvField(&DrvField);
            }

            LAZYLOAD_INFO.pfnProcessPrinterAdded(hDevInfo,
                                                 pLocalData,
                                                 (LPTSTR)pszPrinterNameW,
                                                 INVALID_HANDLE_VALUE);

            dwSize = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)(pLocalData->InfInfo.pszVendorSetup), 
                                         -1, NULL, 0, NULL, NULL);
            if (dwSize > 0)
            {
                pszVendorSetupA = (LPSTR)AllocMem( dwSize );
                if (pszVendorSetupA)
                {
                    if (WideCharToMultiByte (CP_ACP, 0, (LPCWSTR)(pLocalData->InfInfo.pszVendorSetup),
                                             -1, pszVendorSetupA, dwSize, NULL, NULL))
                    {
                        WriteVendorSetupInfoInRegistry( pszVendorSetupA, pszPrinterNameA );

                    }
                    FreeMem( pszVendorSetupA );
                }
            }
        }

        //
        // Default printer will be the one with PRINTER_ATTRIBUTE_DEFAULT attribute
        // If the Win95 default printer could not be added to NT we will set the
        // first printer as the default printer
        //
        if ( (pPrinterNode->PrinterInfo2.Attributes
                                    & PRINTER_ATTRIBUTE_DEFAULT) ||
             !pDefPrinter )
            pDefPrinter = pPrinterNode;


        FreeMem(pszPrinterNameW);
        ClosePrinter(hPrinter);
    }

    if ( pDefPrinter )
        pszDefaultPrinterString = GetDefPrnString(
                                    pDefPrinter->PrinterInfo2.pPrinterName);
}


HDEVINFO
PrinterDevInfo(
    IN OUT  LPBOOL  pbFail
    )
/*++

--*/
{
    HDEVINFO                hDevInfo = INVALID_HANDLE_VALUE;

    if ( *pbFail || !InitLazyLoadInfo() ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

    hDevInfo = LAZYLOAD_INFO.pfnCreatePrinterDeviceInfoList(INVALID_HANDLE_VALUE);
    if ( hDevInfo == INVALID_HANDLE_VALUE   ||
         !LAZYLOAD_INFO.pfnBuildDriversFromPath(hDevInfo,
                                                (LPSTR)L"ntprint.inf",
                                                TRUE) ) {

        *pbFail = TRUE;
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("Built the list of printer drivers from ntprint.inf");
#endif

    if ( *pbFail && hDevInfo != INVALID_HANDLE_VALUE ) {

        LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;
    }

Cleanup:
    return hDevInfo;
}


LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR pszWorkingDir,
    IN  LPCWSTR pszSourceDir,
    LPVOID      Reserved
    )
/*++

Routine Description:
    Setup calls this to intialize us on NT side

Arguments:
    pszWorkingDir   : Gives the working directory assigned for printing
    pszSourceDir    : Source location for NT distribution files
    Reserved        : Leave it alone

Return Value:
    Win32 error code

--*/
{
    BOOL                    bFail = FALSE;
    DWORD                   dwReturn, ThreadId;
    HANDLE                  hRunning = NULL, hThread;
    HDSKSPC                 DiskSpace;
    LPSTR                   pszStr;
    HDEVINFO                hDevInfo = INVALID_HANDLE_VALUE;
    PDRIVER_NODE            pDriverNode = NULL;
    PPRINTER_NODE           pPrinterNode = NULL;
    PPORT_NODE              pPortNode = NULL;


#ifdef VERBOSE
    DebugMsg("InitializeNT : %ws, %ws", pszSourceDir, pszWorkingDir);
#endif

    UpgradeData.pszDir      = AllocStrAFromStrW(pszWorkingDir);
    UpgradeData.pszSourceW  = AllocStrW(pszSourceDir);
    UpgradeData.pszSourceA  = AllocStrAFromStrW(pszSourceDir);

    if ( !UpgradeData.pszDir        ||
         !UpgradeData.pszSourceW    ||
         !UpgradeData.pszSourceA ) {

        return GetLastError();
    }

    if ( (hAlive = OpenEventA(EVENT_MODIFY_STATE, FALSE, "MigDllAlive"))    &&
         (hRunning = CreateEventA(NULL, FALSE, FALSE, NULL))                &&
         (hThread = CreateThread(NULL, 0,
                                 (LPTHREAD_START_ROUTINE)KeepAliveThread,
                                 hRunning,
                                 0, &ThreadId)) )
        CloseHandle(hThread);

    SetupOpenLog(FALSE);

    DeleteWin95Files();

    if ( !ReadWin9xPrintConfig(&pDriverNode, &pPrinterNode, &pPortNode) ) {

        bFail = TRUE;
        DebugMsg("Unable to read Windows 9x printing configuration");
        goto Cleanup;
    }

#ifdef  VERBOSE
    DebugMsg("Succesfully read Windows 9x printing configuration");
#endif

    //
    // If no printers or drivers found nothing to do
    //
    if ( !pDriverNode && !pPrinterNode )
        goto Cleanup;

    if ( (hDevInfo = PrinterDevInfo(&bFail)) == INVALID_HANDLE_VALUE )
        goto Cleanup;

    UpgradePrinterDrivers(pDriverNode, hDevInfo, &bFail);

    UpgradePrinters(pPrinterNode, pDriverNode, &pPortNode, hDevInfo);

    MakeACopyOfMigrateDll( UpgradeData.pszDir );

Cleanup:

    SetupCloseLog();

    if ( bFail && (pszStr = ErrorMsg()) ) {

        DebugMsg("Printing migration failed. %s", pszStr);
        FreeMem(pszStr);
    }

    FreePrinterNodeList(pPrinterNode);
    FreeDriverNodeList(pDriverNode);
    FreePortNodeList(pPortNode);

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        LAZYLOAD_INFO.pfnDestroyPrinterDeviceInfoList(hDevInfo);

    if ( LAZYLOAD_INFO.hNtPrint )
        FreeLibrary(LAZYLOAD_INFO.hNtPrint);

    if ( bFail ) {

        if ( (dwReturn = GetLastError()) == ERROR_SUCCESS ) {

            ASSERT(dwReturn != ERROR_SUCCESS);
            dwReturn = STG_E_UNKNOWN;
        }
    } else {

        SetupNetworkPrinterUpgrade(UpgradeData.pszDir);
        dwReturn = ERROR_SUCCESS;

#ifdef VERBOSE
        DebugMsg("InitializeNT returning success");
#endif

    }

    if ( hRunning )
        CloseHandle(hRunning);

    while (hAlive)
        Sleep(100); // Check after 0.1 second for the main thread to die

    return  dwReturn;
}


DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    )
/*++

Routine Description:
    Sets the default printer for the user by writing it to the registry

Arguments:

Return Value:

--*/
{
    DWORD   dwReturn;
    HKEY    hKey = NULL;

    //
    // Create the printers key in the user hive and write DeviceOld value
    //
    dwReturn = RegCreateKeyExA(hUserRegKey,
                               "Printers",
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL);

    if ( dwReturn == ERROR_SUCCESS ) {

        dwReturn = RegSetValueExA(hKey,
                                  "DeviceOld",
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszDefaultPrinterString,
                                  (strlen(pszDefaultPrinterString) + 1)
                                            * sizeof(CHAR));

        RegCloseKey(hKey);
    }

    return dwReturn;
}


LONG
CALLBACK
MigrateUserNT(
    IN  HINF        hUnattendInf,
    IN  HKEY        hUserRegKey,
    IN  LPCWSTR     pszUserName,
        LPVOID      Reserved
    )
/*++

Routine Description:
    Migrate user settings

Arguments:

Return Value:

--*/
{
    LPSTR   pszStr;
    DWORD   dwReturn = ERROR_SUCCESS;

#ifdef  VERBOSE
        DebugMsg("Migrating settings for %ws", pszUserName);
#endif

    if ( pszDefaultPrinterString ) {

         dwReturn = MySetDefaultPrinter(hUserRegKey,
                                        pszDefaultPrinterString);

        if ( dwReturn )
            DebugMsg("MySetDefaultPrinter failed with %d", dwReturn);
    }

    if ( bDoNetPrnUpgrade ) {

        if ( ProcessNetPrnUpgradeForUser(hUserRegKey) )
            ++dwRunOnceCount;
        else {

            if ( dwReturn == ERROR_SUCCESS )
                dwReturn = GetLastError();
            DebugMsg("ProcessNetPrnUpgradeForUser failed with %d", dwReturn);
        }
    }

#ifdef  VERBOSE
    if ( dwReturn )
        DebugMsg("MigrateUserNT failed with %d", dwReturn);
    else
        DebugMsg("MigrateUserNT succesful");
#endif

    return  dwReturn;
}


LONG
CALLBACK
MigrateSystemNT(
    IN  HINF    hUnattendInf,
        LPVOID  Reserved
    )
/*++

Routine Description:
    Process system setttings for printing. All the printing setting are
    migrated in InitializeNT since we need to know the default printer for
    each user in the MigrateSystemNT call

Arguments:
    hUnattendInf    : Handle to the unattended INF

Return Value:
    Win32 error code

--*/
{
    WriteRunOnceCount();
    return ERROR_SUCCESS;
}


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_NT     pfnInitializeNT         = InitializeNT;
P_MIGRATE_USER_NT   pfnMigrateUserNt        = MigrateUserNT;
P_MIGRATE_SYSTEM_NT pfnMigrateSystemNT      = MigrateSystemNT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\splsetup\win9xupg\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Uitility routines for printer migration from Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"

extern CHAR szRunOnceRegistryPath[];
extern CHAR szSpool[];
extern CHAR szMigDll[];

//
// These are used in the process of creating registry keys where the
// data necessary the vendor setup to be started will be stored
//
CHAR *pszVendorSetupInfoPath         = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Print";
CHAR *pszVendorSetupInfo             = "VendorSetupInfo";
CHAR *pszVendorSetupID               = "VendorSetup";
CHAR *pszVendorSetupEnumerator       = "VendorInfoEnumerator";
CHAR *pszPrinterNameKey              = "PrinterName";
CHAR *pszMigrationVendorSetupCaller  = "MigrationVendorSetupCaller";
CHAR  szVendorSetupRunRegistryPath[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
const CHAR *pszVendorSetupCaller     = "CallVendorSetupDlls";

const LONG  dwMaxVendorSetupIDLength  = 10;
const DWORD dwFourMinutes             = 240000;
BOOL  bMigrateDllCopyed               = FALSE;


VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    On debug builds brings up a message box on severe errors

Arguments:
    pszFormat   : Format string

Return Value:
    None

--*/
{
#if DBG
    LPSTR       psz;
    CHAR        szMsg[1024];
    va_list     vargs;

    va_start(vargs, pszFormat);
    vsprintf(szMsg, pszFormat, vargs);
    va_end(vargs);

#ifdef  MYDEBUG
    if ( psz = GetStringFromRcFileA(IDS_TITLE) ) {

        MessageBoxA(NULL, szMsg, psz, MB_OK);
        FreeMem(psz);
    }
#else
    OutputDebugStringA("Printing Migration : ");
    OutputDebugStringA(szMsg);
    OutputDebugStringA("\n");
#endif


#endif
}



VOID
LogError(
    IN  LogSeverity     Severity,
    IN  UINT            uMessageId,
    ...
    )
/*++

Routine Description:
    Logs an error in the setup error log on NT side when something can not be
    upgraded

Arguments:
    uMessageId  : Id to string in .rc file

Return Value:
    None

--*/
{
    LPSTR      pszFormat;
    CHAR       szMsg[1024];

    va_list     vargs;

    va_start(vargs, uMessageId);

    pszFormat = GetStringFromRcFileA(uMessageId);

    if ( pszFormat ) {

        wvsprintfA(szMsg, pszFormat, vargs);
        DebugMsg("%s", szMsg);
        SetupLogErrorA(szMsg, Severity);
    }

    FreeMem(pszFormat);

    va_end(vargs);
}


LPSTR
ErrorMsg(
    VOID
    )
/*++

Routine Description:
    Returns the error message string from a Win32 error

Arguments:
    None

Return Value:
    Pointer to a message string. Caller should free the string

--*/
{
    DWORD   dwLastError;
    LPSTR   pszStr = NULL;

    if ( !(dwLastError = GetLastError()) )
        dwLastError = STG_E_UNKNOWN;

    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER    |
                        FORMAT_MESSAGE_IGNORE_INSERTS   |
                        FORMAT_MESSAGE_FROM_SYSTEM      |
                        FORMAT_MESSAGE_MAX_WIDTH_MASK,
                   NULL,
                   dwLastError,
                   0,
                   (LPSTR)&pszStr,
                   0,
                   NULL);

    return pszStr;
}


PVOID
AllocMem(
    IN UINT cbSize
    )
/*++

Routine Description:
    Allocate memory from the heap

Arguments:
    cbSize  : Byte count

Return Value:
    Pointer to the allocated memory

--*/
{
    return LocalAlloc(LPTR, cbSize);
}


VOID
FreeMem(
    IN PVOID    p
    )
/*++

Routine Description:
    Free memory allocated on the heap

Arguments:
    p   : Pointer to the memory to be freed

Return Value:
    None

--*/
{
    LocalFree(p);
}


LPSTR
AllocStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of an ansi string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = AllocMem((strlen(pszStr) + 1) * sizeof(CHAR));
        if ( pszRet )
            strcpy(pszRet, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrW(
    LPCWSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of a unicode string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPWSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = AllocMem((wcslen(pszStr) + 1) * sizeof(WCHAR));
        if ( pszRet )
            wcscpy(pszRet, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Returns the unicode string for a give ansi string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPWSTR  pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = strlen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1) * sizeof(WCHAR))) ) {

        if ( MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 pszStr,
                                 dwLen,
                                 pszRet,
                                 dwLen) ) {

            pszRet[dwLen] = 0;
        } else {

            FreeMem(pszRet);
            pszRet = NULL;
        }

    }

    return pszRet;
}


LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    )
/*++

Routine Description:
    Returns the ansi string for a give unicode string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied ansi string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPSTR   pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = wcslen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1 ) * sizeof(CHAR))) ) {

        WideCharToMultiByte(CP_ACP,
                            0,
                            pszStr,
                            dwLen,
                            pszRet,
                            dwLen,
                            NULL,
                            NULL );
    }

    return pszRet;
}


VOID
WriteToFile(
    HANDLE  hFile,
    LPBOOL  pbFail,
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    Format and write a string to the text file. This is used to write the
    printing configuration on Win9x

Arguments:
    hFile       : File handle
    pbFail      : Set on error -- no more processing needed
    pszFormat   : Format string for the message

Return Value:
    None

--*/
{
    CHAR        szMsg[1024];
    va_list     vargs;
    DWORD       dwSize, dwWritten;

    if ( *pbFail )
        return;

    va_start(vargs, pszFormat);
    vsprintf(szMsg, pszFormat, vargs);  
    va_end(vargs);

    dwSize = strlen(szMsg) * sizeof(CHAR);

    if ( !WriteFile(hFile, (LPCVOID)szMsg, dwSize, &dwWritten, NULL)    ||
         dwSize != dwWritten ) {

        *pbFail = TRUE;
    }
}


VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    )
/*++

Routine Description:
    Writes a string to the upgrade file on Win9x side. Since spooler strings
    (ex. printer name, driver name) can have space in them we would write
    all strings with []\n. So we can read strings with space on NT.

Arguments:
    hFile       : File handle
    pszFormat   : Format string for the message
    pszStr      : String to write

Return Value:
    None

--*/
{
    DWORD   dwLen;

    if ( pszStr ) {

        dwLen = strlen(pszStr);
        WriteToFile(hFile, pbFail, "%3d [%s]\n", dwLen, pszStr);
    }
    else
        WriteToFile(hFile, pbFail, "  0 []\n");

}


VOID
WriteDevMode(
    IN      HANDLE      hFile,
    IN OUT  LPBOOL      pbFail,
    IN      LPDEVMODEA  pDevMode
    )
/*++

Routine Description:
    Writes a devmode to the upgrade file on Win9x side. We write the size of
    devmode and write this as a binary field

Arguments:
    hFile       : File handle
    pbFail      : On error set to TRUE
    pDevMode    : Pointer to devmode

Return Value:
    None

--*/
{
    DWORD   cbSize, cbWritten;

    if ( *pbFail )
        return;

    cbSize = pDevMode ? pDevMode->dmSize + pDevMode->dmDriverExtra : 0;

    if ( cbSize ) {

        WriteToFile(hFile, pbFail, "DevMode:         %d [", cbSize);

        if ( !WriteFile(hFile, (LPCVOID)pDevMode, cbSize, &cbWritten, NULL) ||
             cbWritten != cbSize )
            *pbFail = TRUE;

        WriteToFile(hFile, pbFail, "]\n");
    } else {

        WriteToFile(hFile, pbFail, "DevMode: 0\n");
    }
}


LPSTR
GetStringFromRcFileA(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    CHAR    buf[MAX_STRING_LEN];

    if ( LoadStringA(UpgradeData.hInst, uId, buf, SIZECHARS(buf)) )
        return AllocStrA(buf);
    else
        return NULL;
}


VOID
CleanupDriverMapping(
    IN  OUT HDEVINFO   *phDevInfo,
    IN  OUT HINF       *phNtInf,
    IN  OUT HINF       *phUpgInf
    )
/*++

Routine Description:
    Close INF handles and delete the printer device info list

Arguments:
    phDevInfo   : Points to printer device info list
    phNtInf     : Points to INF handle for ntprint.inf
    phUpgInfo   : Points to the handle to upgrade inf

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    if ( phUpgInf && *phUpgInf != INVALID_HANDLE_VALUE ) {

        SetupCloseInfFile(*phUpgInf);
        *phUpgInf = INVALID_HANDLE_VALUE;
    }

    if ( *phNtInf != INVALID_HANDLE_VALUE ) {

        SetupCloseInfFile(*phNtInf);
        *phNtInf = INVALID_HANDLE_VALUE;
    }

    if ( *phDevInfo != INVALID_HANDLE_VALUE ) {

        SetupDiDestroyDeviceInfoList(*phDevInfo);
        *phDevInfo = INVALID_HANDLE_VALUE;
    }
}


VOID
InitDriverMapping(
    OUT     HDEVINFO   *phDevInfo,
    OUT     HINF       *phNtInf,
    OUT     HINF       *phUpgInf,
    IN  OUT LPBOOL      pbFail
    )
/*++

Routine Description:
    Opens necessary inf files and create the printer device info list for
    driver upgrade

Arguments:
    phDevInfo   : Points to printer device info list
    phNtInf     : Points to INF handle for ntprint.inf
    phUpgInfo   : Points to the handle to upgrade inf
    pbFail      : Set on error -- no more processing needed

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    DWORD                   dwLen;
    CHAR                    szPath[MAX_PATH];
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    if ( *pbFail )
    {
        return;
    }

    *phDevInfo = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_PRINTER,
                                             NULL);
    
    strcpy(szPath, UpgradeData.pszDir);
    dwLen = strlen(szPath);
    szPath[dwLen++] = '\\';
    strcpy(szPath+dwLen, "prtupg9x.inf");
    *phUpgInf   = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);
    
    strcpy(szPath, UpgradeData.pszSourceA);
    dwLen = strlen(szPath);
    szPath[dwLen++] = '\\';

    strcpy(szPath+dwLen, "ntprint.inf");
    *phNtInf    = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);

    strcpy(szPath+dwLen, "layout.inf");

    if ( *phDevInfo == INVALID_HANDLE_VALUE                 ||
         (phUpgInf && *phUpgInf == INVALID_HANDLE_VALUE)    ||
         *phNtInf == INVALID_HANDLE_VALUE                   ||
         !SetupOpenAppendInfFileA(szPath, *phNtInf, NULL) ) 
    {
        *pbFail = TRUE;
        goto Cleanup;
    }

    //
    // Build the list of drivers from ntprint.inf in the working directory
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);
    if ( !SetupDiGetDeviceInstallParamsA(*phDevInfo,
                                         NULL,
                                         &DevInstallParams) ) 
    {
        *pbFail = TRUE;
        goto Cleanup;
    }

    DevInstallParams.Flags  |= DI_INF_IS_SORTED | DI_ENUMSINGLEINF;

    strcpy(szPath+dwLen, "ntprint.inf");
    strcpy(DevInstallParams.DriverPath, szPath);

    if ( !SetupDiSetDeviceInstallParamsA(*phDevInfo, NULL, &DevInstallParams) ||
         !SetupDiBuildDriverInfoList(*phDevInfo, NULL, SPDIT_CLASSDRIVER) ) 
    {
        *pbFail = TRUE;
    }

Cleanup:
    if ( *pbFail )
        CleanupDriverMapping(phDevInfo, phNtInf, phUpgInf);
}


VOID
WritePrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN      LPSTR               pszDriver,
    IN  OUT LPBOOL              pbFail
    )
{
    DWORD       dwSize;
    LPINT       ptr;

    if ( *pbFail )
        return;

    WriteToFile(hFile, pbFail, "ServerName:      ");
    WriteString(hFile, pbFail, pPrinterInfo2->pServerName);

    WriteToFile(hFile, pbFail, "PrinterName:     ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPrinterName);

    WriteToFile(hFile, pbFail, "ShareName:       ");
    WriteString(hFile, pbFail, pPrinterInfo2->pShareName);

    WriteToFile(hFile, pbFail, "PortName:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPortName);

    //  
    // On the Win9x side we could have found a different driver name on NT side
    // if so write it instead of the one returned by spooler
    //
    WriteToFile(hFile, pbFail, "DriverName:      ");
    WriteString(hFile, pbFail, 
                pszDriver ? pszDriver : pPrinterInfo2->pDriverName);

    WriteToFile(hFile, pbFail, "Comment:         ");
    WriteString(hFile, pbFail, pPrinterInfo2->pComment);

    WriteToFile(hFile, pbFail, "Location:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pLocation);

    WriteDevMode(hFile, pbFail, pPrinterInfo2->pDevMode);

    WriteToFile(hFile, pbFail, "SepFile:         ");
    WriteString(hFile, pbFail, pPrinterInfo2->pSepFile);

    WriteToFile(hFile, pbFail, "PrintProcessor:  ");
    WriteString(hFile, pbFail, pPrinterInfo2->pPrintProcessor);

    WriteToFile(hFile, pbFail, "Datatype:        ");
    WriteString(hFile, pbFail, pPrinterInfo2->pDatatype);

    WriteToFile(hFile, pbFail, "Parameters:      ");
    WriteString(hFile, pbFail, pPrinterInfo2->pParameters);

    // Security descriptor ???

    WriteToFile(hFile, pbFail, "Attributes:      %3d\n", pPrinterInfo2->Attributes);

    WriteToFile(hFile, pbFail, "Priority:        %3d\n", pPrinterInfo2->Priority);

    WriteToFile(hFile, pbFail, "DefaultPriority: %3d\n", pPrinterInfo2->DefaultPriority);

    WriteToFile(hFile, pbFail, "StartTime:       %3d\n", pPrinterInfo2->StartTime);

    WriteToFile(hFile, pbFail, "UntilTime:       %3d\n", pPrinterInfo2->UntilTime);

    WriteToFile(hFile, pbFail, "Status:          %3d\n", pPrinterInfo2->Status);

    // cJobs not needed
    // AveragePPM not needed
    WriteToFile(hFile, pbFail, "\n");
}


VOID
ReadString(
    IN      HANDLE  hFile,
    IN      LPSTR   pszPrefix,
    OUT     LPSTR  *ppszStr,
    IN      BOOL    bOptional,
    IN  OUT LPBOOL  pbFail
    )
{
    CHAR    c;
    LPSTR   psz;
    DWORD   dwLen;

    if ( *pbFail )
        return;

    //
    // First skip the prefix
    //
    while ( *pszPrefix && (c = (CHAR) My_fgetc(hFile)) == *pszPrefix++ )
    ;

    if ( *pszPrefix )
        goto Fail;

    //
    // Skip spaces
    //
    while ( (c = (CHAR) My_fgetc(hFile)) == ' ' )
    ;

    //
    // Now is the string length
    //
    if ( !isdigit(c) )
        goto Fail;

    dwLen = c - '0';
    while ( isdigit(c = (CHAR) My_fgetc(hFile)) )
        dwLen = dwLen * 10 + c - '0';

    if ( c != ' ' )
        goto Fail;

    //
    // Now the string is there between []
    //
    if ( *ppszStr = (LPSTR) AllocMem((dwLen + 1) * sizeof(CHAR)) ) {

        if ( (c = (CHAR) My_fgetc(hFile)) != '[' )
            goto Fail;

        for ( psz = *ppszStr ;
              dwLen && (*psz = (CHAR) My_fgetc(hFile)) != (CHAR) EOF ;
              ++psz, --dwLen )
        ;

        if ( dwLen )
            goto Fail;

        *psz = '\0';

        //
        // Make sure line ends with "]\n"
        //
        if ( (CHAR) My_fgetc(hFile) != ']' || (CHAR) My_fgetc(hFile) != '\n' )
            goto Fail;

        return;
    }

Fail:
    *pbFail = TRUE;
     FreeMem(*ppszStr);
    *ppszStr = NULL;
}


VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    )
{
    LPSTR   psz;

    if ( *pbFail || My_fgets(pszLine, dwLineSize, hFile) == NULL ) {

        *pbFail = TRUE;
        return;
    }

    //
    // First check the prefix matches to make sure we are in the right line
    //
    for ( psz = (LPSTR)pszLine ;
          *pszPrefix && *psz == *pszPrefix ;
          ++psz, ++pszPrefix )
    ;

    if ( *pszPrefix ) {

        *pbFail = TRUE;
        return;
    }

    //
    // Skip spaces
    //
    while ( *psz && *psz == ' ' )
        ++psz;

    *pdwValue = atoi(psz);
}


VOID
ReadDevMode(
    IN      HANDLE  hFile,
    OUT     LPDEVMODEA *ppDevMode,
    IN  OUT LPBOOL      pbFail
    )
{
    LPSTR   pszPrefix = "DevMode:";
    CHAR    c;
    DWORD   dwLen;
    LPINT   ptr;

    if ( *pbFail )
        return;

    // First skip the prefix
    //
    while ( *pszPrefix && (c = (CHAR) My_fgetc(hFile)) == *pszPrefix++ )
    ;

    if ( *pszPrefix )
        goto Fail;

    //
    // Skip spaces
    //
    while ( (c = (CHAR) My_fgetc(hFile)) == ' ' )
    ;

    //
    // Now is the devmode size
    //
    if ( !isdigit(c) )
        goto Fail;

    dwLen = c - '0';
    while ( isdigit(c = (CHAR) My_fgetc(hFile)) )
        dwLen = dwLen * 10 + c - '0';

    if ( dwLen == 0 )
        return;

    if ( c != ' ' )
        goto Fail;

    //
    // Now the devmode is there between []
    //
    if ( *ppDevMode = (LPDEVMODEA) AllocMem(dwLen) ) {

        if ( (c = (CHAR) My_fgetc(hFile)) != '[' )
            goto Fail;

        if ( dwLen != My_fread((LPVOID)*ppDevMode, dwLen, hFile) )
            goto Fail;

        //
        // Make sure now we have "]\n" to End
        //
        if ( (CHAR) My_fgetc(hFile) != ']' || (CHAR) My_fgetc(hFile) != '\n' ) {

            DebugMsg("Char check fails");
            goto Fail;
        }

        return; // Succesful exit
    }

Fail:
    *pbFail = TRUE;
}


VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    )
{
    if ( pPrinterInfo2 ) {

        FreeMem(pPrinterInfo2->pServerName);
        FreeMem(pPrinterInfo2->pPrinterName);
        FreeMem(pPrinterInfo2->pShareName);
        FreeMem(pPrinterInfo2->pPortName);
        FreeMem(pPrinterInfo2->pDriverName);
        FreeMem(pPrinterInfo2->pComment);
        FreeMem(pPrinterInfo2->pLocation);
        FreeMem(pPrinterInfo2->pDevMode);
        FreeMem(pPrinterInfo2->pSepFile);
        FreeMem(pPrinterInfo2->pPrintProcessor);
        FreeMem(pPrinterInfo2->pDatatype);
    }
}


VOID
ReadPrinterInfo2(
    IN      HANDLE              hFile,
    IN      LPPRINTER_INFO_2A   pPrinterInfo2,
    IN  OUT LPBOOL              pbFail
    )
{
    CHAR                szLine[2*MAX_PATH];
    DWORD               dwSize;

    dwSize = sizeof(szLine)/sizeof(szLine[0]);

    ReadString(hFile, "ServerName:",
               &pPrinterInfo2->pServerName, TRUE, pbFail);

    ReadString(hFile, "PrinterName:",
               &pPrinterInfo2->pPrinterName, FALSE, pbFail);

    ReadString(hFile, "ShareName:",
               &pPrinterInfo2->pShareName, TRUE, pbFail);

    ReadString(hFile, "PortName:",
               &pPrinterInfo2->pPortName, FALSE, pbFail);

    ReadString(hFile, "DriverName:",
               &pPrinterInfo2->pDriverName, FALSE, pbFail);

    ReadString(hFile, "Comment:",
               &pPrinterInfo2->pComment, TRUE, pbFail);

    ReadString(hFile, "Location:",
               &pPrinterInfo2->pLocation, TRUE, pbFail);

    ReadDevMode(hFile, &pPrinterInfo2->pDevMode, pbFail);

    ReadString(hFile, "SepFile:",
               &pPrinterInfo2->pSepFile, TRUE, pbFail);

    ReadString(hFile, "PrintProcessor:",
               &pPrinterInfo2->pPrintProcessor, FALSE, pbFail);

    ReadString(hFile, "Datatype:",
               &pPrinterInfo2->pDatatype, TRUE, pbFail);

    ReadString(hFile, "Parameters:",
               &pPrinterInfo2->pParameters, TRUE, pbFail);

    ReadDword(hFile, szLine, dwSize, "Attributes:",
               &pPrinterInfo2->Attributes, pbFail);

    ReadDword(hFile, szLine, dwSize, "Priority:",
              &pPrinterInfo2->Priority, pbFail);

    ReadDword(hFile, szLine, dwSize, "DefaultPriority:",
              &pPrinterInfo2->DefaultPriority, pbFail);

    ReadDword(hFile, szLine, dwSize, "StartTime:",
              &pPrinterInfo2->StartTime, pbFail);

    ReadDword(hFile, szLine, dwSize, "UntilTime:",
              &pPrinterInfo2->UntilTime, pbFail);

    ReadDword(hFile, szLine, dwSize, "Status:",
              &pPrinterInfo2->Status, pbFail);

    //
    // Skip the blank line
    //
    My_fgets(szLine, dwSize, hFile);

    if ( *pbFail ) {

        FreePrinterInfo2Strings(pPrinterInfo2);
        ZeroMemory(pPrinterInfo2, sizeof(*pPrinterInfo2));
    }
}


LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    )
{
    DWORD   dwLen;
    LPSTR   pszRet;

    dwLen = strlen(pszPrinterName) + 1 + strlen("winspool") + 1;
    if ( pszRet = (LPSTR) AllocMem(dwLen * sizeof(CHAR)) ) {

        sprintf(pszRet, "%s,%s", pszPrinterName, "winspool");
    }

    return pszRet;
}


DWORD
GetFileNameInSpoolDir(
    IN  LPSTR   szBuf,
    IN  DWORD   cchBuf,
    IN  LPSTR   pszFileName
    )
/*++

Routine Description:
    Function returns fully qualified path of the given file name in the spool
    directory

Arguments:
    szPath      : Buffer to put the file name in
    cchBuf      : Buffer size in characters
    pszFileName : File name part

Return Value:
    Number of chars copied without \0 on success, 0 on failure

--*/
{
    DWORD   dwLen, dwLen1;

    dwLen   = GetSystemDirectoryA(szBuf, cchBuf);

    if ( !dwLen )
        return 0;

    dwLen += strlen(szSpool) + strlen(pszFileName);

    if ( dwLen + 1 > cchBuf )
        return 0;

    strcat(szBuf, szSpool);
    strcat(szBuf, pszFileName);

    return dwLen;
}


LPSTR
GetVendorSetupRunOnceValueToSet(
    VOID
    )
/*++
--*/
{
    CHAR    szPath[MAX_PATH];
    DWORD   dwLen, dwSize;
    LPSTR   pszRet = NULL;

    dwSize  = sizeof(szPath)/sizeof(szPath[0]);

    if ( !(dwLen = GetFileNameInSpoolDir(szPath, dwSize, szMigDll)) )
        goto Done;

    //
    // Now build up the RunOnce key which will be set for each user
    //
    dwSize = strlen("rundll32.exe") + dwLen +
                                    + strlen(pszVendorSetupCaller) + 4;

    if ( pszRet = AllocMem(dwSize * sizeof(CHAR)) )
        sprintf(pszRet,
                "rundll32.exe %s,%s",
                szPath, pszVendorSetupCaller);
Done:
    return pszRet;
}


LONG
WriteVendorSetupInfoInRegistry(
    IN CHAR *pszVendorSetup,
    IN CHAR *pszPrinterName
    )
/*++

Routine Description:
    This routine is called to write the name of the vendor's installer DLL,
    the entry point of that DLL, and the name of the printer
    
    The vendor setup information is stored as described below:
    
    HKLM
     \Software
       \Microsoft
         \Windows NT
           \CurrentVersion
             \Print
               \VendorSetupInfo
                 \VendorInfoEnumerator   N
                 \VendorSetup1           Vendor1Dll,EntryPoint "Printer1 Name"
                 \VendorSetup2           Vendor2Dll,EntryPoint "Printer2 Name"
                 .............................................................
                 \VendorSetupN           VendorNDll,EntryPoint "PrinterN Name"
               
    The value N of VendorInfoEnumerator is equal to the number of the printers
    for which vendor setup is provided. That value will be used to enumerate
    the Dll's provided by vendors in the process of calling the entry points
    of those Dlls.
    
    The type of VendorInfoEnumerator is REG_DWORD. 
    The value of each VendorSetupX key (where 1<= X <= N) is a string containing
    the name of the VendorSetup DLL, the entry point of that DLL and the
    corresponding printer name. WrireVendorSetupInfoInRegistry function 
    concatenates its input parameters to produce that value and to write in into
    the registry. The type of every VendorSetupX value is REG_SZ.
    
    The information about the function in migrate.dll which to be called after
    the first administrator's logon is stored into the registry as it is shown
    below:
    
    HKLM
     \Software
       \Microsoft
         \Windows
           \CurrentVersion
             \Run
               \MigrationVendorSetupCaller  

    The value of MigrationVendorSetupCaller is:                     
                     
        rundll32.exe %WinRoot%\system32\spool\migrate.dll,CallVendorSetupDlls
        
    The type of the value is REG_SZ.
    

Arguments:
    pszVendorSetup - null terminated string containing both the name of the
    vendor's DLL and the entry point of that DLL
    pszPrinterName - null terminated string containing the name of the printer
                                                                           
Return Value:
    ERROR_SUCCES in the case of success.
    error code in the other case.
    
--*/
{
    LONG   lRet                               = ERROR_BADKEY; 
    HKEY   hKeyVendorInfo                     = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoPath                 = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoInstaller            = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoEnumerator           = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorRunOnceValuePath         = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorRunOnceCallerValue       = INVALID_HANDLE_VALUE;
    CHAR  *pszBuffer                          = NULL;
    CHAR  *pszBuffer1                         = NULL;
    DWORD  dwType                             = 0;
    DWORD  dwSize                             = 0;
    LONG   lEnumerator                        = 0;
    DWORD  dwDisposition                      = 0;
    UINT   cbBufferSize                       = 0;
    UINT   cbBuffer1Size                      = 0;
    CHAR  *pszVendorSetupIDAsStr              = NULL;
    CHAR  *pszVendorSetupRunOnceValue         = NULL;

    
    if (!pszVendorSetup || (strlen(pszVendorSetup) == 0) ||
        !pszPrinterName || (strlen(pszPrinterName) == 0)) 
    {
        goto Cleanup;
    }

    //
    // We have to open the HKLM\Software\Microsoft\Windows NT\CurrentVersion\Print\VendorSetupInfo
    // key first.
    // 
    lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0, 
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfoPath, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Now we will try to create the VendorSetupInfo key
    //
    lRet = RegCreateKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0, 
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfo, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Here we can create/open the VendorInfoEnumerator key.
    //
    lRet = RegCreateKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0, 
                           NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorInfoEnumerator, &dwDisposition );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    else
    {
        if (dwDisposition == REG_OPENED_EXISTING_KEY) 
        {
            //
            // The VendorInfoEnumerator alredy exists. We opened and existing
            // key. So we have to increment its value with 1 because we intend
            // to create another VendorSetup key and to store there the
            // corresponding information.
            //
            dwType = REG_DWORD;
            dwSize = sizeof( lEnumerator );
            if (ERROR_SUCCESS != RegQueryValueEx(hKeyVendorInfoEnumerator, 
                                                 pszVendorSetupEnumerator, 0, 
                                                 &dwType, (LPBYTE)(&lEnumerator), 
                                                 &dwSize ) )
            {
                goto Cleanup;
            }
            lEnumerator++;
        }
        else
        {
            //
            // The VendorInfoEnumerator has been created. So this is the first
            // printer for which we have VendorSetup provided.
            //
            lEnumerator = 1;
        }
    }

    //
    // Below we will convert the value of VendorInfoEnumerator to a string and
    // will concatenate that string to "VendorSetup" to produce the names of
    // the Registry key and value where the data about the vendor provided DLL,
    // its entry point and the printer will be stored.
    //
    pszVendorSetupIDAsStr = AllocMem( dwMaxVendorSetupIDLength * sizeof(CHAR) );
    if (!pszVendorSetupIDAsStr) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }

    _itoa( lEnumerator, pszVendorSetupIDAsStr, 10 );

    //
    // Below the memory necessary to build the vendor setup data and the
    // registry key name from the input data and from the value of 
    // the VendorInfoEnumerator will be allocated.
    //
    cbBufferSize  = (strlen(pszVendorSetup) + strlen(pszPrinterName) + strlen(TEXT(" \"\"")) + 2) * sizeof(CHAR);
    cbBuffer1Size = (strlen(pszVendorSetupID) + strlen(pszVendorSetupIDAsStr) + 2) * sizeof(CHAR);
    pszBuffer1    = AllocMem( cbBuffer1Size );
    pszBuffer     = AllocMem( cbBufferSize );
    if (!pszBuffer || !pszBuffer1) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }
    else
    {
        strcpy( pszBuffer1, pszVendorSetupID);
        strcat( pszBuffer1, pszVendorSetupIDAsStr );

        //
        // At this point pszBuffer1 points to the following string:
        // VendorSetupK where K is an integer - the value of VendorInfoEnumerator
        //
        lRet = RegCreateKeyEx( hKeyVendorInfo, pszBuffer1, 0, NULL, 
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                               &hKeyVendorInfoInstaller, NULL );
        if (ERROR_SUCCESS != lRet)
        {
            goto Cleanup;
        }
        else
        {
            //
            // The Registry Key where to store the vendor setup data was
            // created successfully.
            //

            strcpy( pszBuffer, pszVendorSetup);
            strcat( pszBuffer, " \"");
            strcat( pszBuffer, pszPrinterName );
            strcat( pszBuffer, "\"");

            //
            // At this point pszBuffer points to the following string:
            // VendorSetup.DLL,EntryPoint "PrinterName". We will store
            // that string in the Registry Key which we just created.
            //
            lRet = RegSetValueEx(hKeyVendorInfoInstaller, pszBuffer1, 0,
                                  REG_SZ, (BYTE *)pszBuffer, cbBufferSize );
            if (lRet != ERROR_SUCCESS) 
            {
                goto Cleanup;
            }
        }
    }

    // 
    // Here we will store the value of VendorInfoEnumerator.
    //
    dwSize = sizeof( lEnumerator );
    lRet = RegSetValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator,
                         0, REG_DWORD, (BYTE*)(&lEnumerator), dwSize );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }

    //
    // Now we can try to store into the registry the information how to invoke 
    // the migrate.dll after the first log on of an administrator.
    //
    pszVendorSetupRunOnceValue = GetVendorSetupRunOnceValueToSet();
    if (!pszVendorSetupRunOnceValue) 
    {
        lRet = GetLastError();
        goto Cleanup;
    }

    //
    // We will try to open the 
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Run
    //
    lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
                           szVendorSetupRunRegistryPath, 0, NULL, 
                           REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &hKeyVendorRunOnceValuePath, NULL );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    else
    {
        //
        // We will try to create the 
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Run\MigrationVendorSetupCaller
        //
        lRet = RegCreateKeyEx( hKeyVendorRunOnceValuePath, pszMigrationVendorSetupCaller, 0, 
                               NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                               &hKeyVendorRunOnceCallerValue, &dwDisposition );
        if (ERROR_SUCCESS != lRet)
        {
            goto Cleanup;
        }
        if (dwDisposition == REG_OPENED_EXISTING_KEY) 
        {
            goto Cleanup;
        }

        //
        // Here we will store the "rundll.exe %WinRoot%\System32\spool\migrate.dll,CallVendorSetupDlls"
        // string into the registry
        //
        lRet = RegSetValueEx(hKeyVendorRunOnceCallerValue, pszMigrationVendorSetupCaller,
                             0, REG_SZ, (BYTE *)pszVendorSetupRunOnceValue, 
                             strlen(pszVendorSetupRunOnceValue) * sizeof(CHAR) );
    }

Cleanup:
    
    if (pszVendorSetupRunOnceValue)
    {
        FreeMem(pszVendorSetupRunOnceValue);
    }
    if (pszVendorSetupIDAsStr)
    {
        FreeMem(pszVendorSetupIDAsStr);
    }
    if (pszBuffer) 
    {
        FreeMem(pszBuffer);
    }
    if (pszBuffer1) 
    {
        FreeMem(pszBuffer1);
    }
    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }
    if (hKeyVendorRunOnceCallerValue != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceCallerValue );
    }
    if (hKeyVendorInfoInstaller != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoInstaller );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoPath );
    }
   
    return lRet;
}


LONG
RemoveVendorSetupInfoFromRegistry(
    VOID
    )
/*++

Routine Description:
    This routine is called to remove the vendor setup information from the
    registry
    
Arguments:
                                                                           
Return Value:
    ERROR_SUCCESS in the case of success
    error code in any other case
    
--*/
{
    LONG  lRet                       = ERROR_SUCCESS;
    HKEY  hKeyVendorInfoPath         = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfo             = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfoEnumerator   = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorRunOnceValuePath = INVALID_HANDLE_VALUE;
    LONG  lVendorSetupKeysNum        = 0;
    DWORD dwMaxSubKeyLen             = 0;
    DWORD dwMaxClassLen              = 0;
    DWORD dwValues                   = 0;
    DWORD dwMaxValueNameLen          = 0;
    DWORD dwMaxValueLen              = 0;
    LONG  lIndex                     = 0;
    DWORD dwSize                     = 0;
    DWORD dwType                     = 0;
    DWORD dwKeyNameBufferLen         = 0;
    CHAR  *pszKeyNameBuffer          = NULL;


    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szVendorSetupRunRegistryPath, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorRunOnceValuePath );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    //
    // Delete the registry keys used to store the location and the entry point
    // of migrate.dll
    //
    lRet = RegDeleteKey( hKeyVendorRunOnceValuePath, pszMigrationVendorSetupCaller);
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Below we have to delete the registry keys used to store the descriptions
    // of the vendor provided setup DLLs.
    //
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    
    //
    // Here we have to open the VendorInfoEnumerator and to read the
    // number of vendor provided setup DLLs.
    //
    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfoEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    dwType = REG_DWORD;
    dwSize = sizeof( lVendorSetupKeysNum );
    lRet  = RegQueryValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator, 0, 
                            &dwType, (LPBYTE)(&lVendorSetupKeysNum), &dwSize );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }
    RegCloseKey( hKeyVendorInfoEnumerator );
    hKeyVendorInfoEnumerator = INVALID_HANDLE_VALUE;
    lRet = RegDeleteKey( hKeyVendorInfo, pszVendorSetupEnumerator);
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }
    
    if (lVendorSetupKeysNum <= 0) 
    {
        goto Cleanup;
    }

    //
    // We have to add 1 for the the enumerator key itself to calculate the
    // number of registry keys where the vendor setup descriptions are
    // stored.
    //
    lVendorSetupKeysNum += 1;

    //
    // Below we will find the longest string used in the registry keys where
    // the vendor setup information is stored. 
    //
    lRet = RegQueryInfoKey( hKeyVendorInfo, NULL, NULL, NULL, &lVendorSetupKeysNum,
                            &dwMaxSubKeyLen, &dwMaxClassLen, &dwValues, &dwMaxValueNameLen,
                            &dwMaxValueLen, NULL, NULL );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }
    dwKeyNameBufferLen = __max( __max( dwMaxClassLen, dwMaxSubKeyLen), 
                                __max( dwMaxValueNameLen, dwMaxValueLen ));
    dwKeyNameBufferLen += 1;

    //
    // Now we have data enough to allocate a buffer long enough to store
    // the longest string describing a key to delete.
    //
    pszKeyNameBuffer = AllocMem( dwKeyNameBufferLen * sizeof( CHAR ) );
    if (!pszKeyNameBuffer) 
    {
        goto Cleanup;
    }

    //
    // Enumerate and delete the keys used to store the VendorSetup
    // descriptions
    //
    lIndex = lVendorSetupKeysNum;
    while (lIndex >= 0)
    {
        if (ERROR_SUCCESS != (lRet = RegEnumKey( hKeyVendorInfo, lIndex, pszKeyNameBuffer, dwKeyNameBufferLen))) 
        {
            goto Cleanup;
        }
        lRet = RegDeleteKey( hKeyVendorInfo, pszKeyNameBuffer);
        if (ERROR_SUCCESS != (lRet = RegDeleteKey( hKeyVendorInfo, pszKeyNameBuffer))) 
        {
            goto Cleanup;
        }
        lIndex--;
    }

Cleanup:

    if (pszKeyNameBuffer) 
    {
        FreeMem( pszKeyNameBuffer );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegDeleteKey( hKeyVendorInfoPath, pszVendorSetupInfo );
        RegCloseKey( hKeyVendorInfoPath );
    }
    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE)
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }

    return lRet;
}


VOID
CallVendorSetupDlls(
    VOID
    )
/*++

Routine Description:
    This is called after the first log on of an administrator. It calls
    vendor setup DLLs using the information we stored in the registry
    
Arguments:

Return Value:

--*/
{
    LONG  lRet                         = ERROR_SUCCESS;
    HKEY  hKeyVendorInfoPath           = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfo               = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorInfoEnumerator     = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorSetup              = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorRunOnceValuePath   = INVALID_HANDLE_VALUE;
    HKEY  hKeyVendorRunOnceCallerValue = INVALID_HANDLE_VALUE;
    HWND  hwnd                         = INVALID_HANDLE_VALUE;
    LONG  lVendorSetupKeysNum          = 0;
    DWORD dwMaxSubKeyLen               = 0;
    DWORD dwMaxClassLen                = 0;
    DWORD dwValues                     = 0;
    DWORD dwMaxValueNameLen            = 0;
    DWORD dwMaxValueLen                = 0;
    LONG  lIndex                       = 0;
    DWORD dwSize                       = 0;
    DWORD dwType                       = 0;
    DWORD dwKeyNameBufferLen           = 0;
    CHAR  *pszKeyNameBuffer            = NULL;
    CHAR  *pszVendorSetupRunOnceValue  = NULL;
    BYTE  *pszVendorSetupPtr           = NULL;
    BOOL  bLocalAdmin                  = FALSE;

    CHAR             szParams[2*MAX_PATH+1];
    CHAR             szCmd[] = "rundll32.exe";
    SHELLEXECUTEINFO  ShellExecInfo;


    if (!IsLocalAdmin(&bLocalAdmin))
    {
        lRet = GetLastError();
        goto Cleanup;
    }
    if (!bLocalAdmin) 
    {
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (lRet != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // The vendor setup registry keys are missing. 
        // So there is nothing to do and we can remove from the registry 
        // all the keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }
    
    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfoEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // The vendor setup registry enumerator is missing. 
        // So the registry is damaged and the best is to remove from  
        // it the other keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }
    
    dwType = REG_DWORD;
    dwSize = sizeof( lVendorSetupKeysNum );
    lRet  = RegQueryValueEx(hKeyVendorInfoEnumerator, pszVendorSetupEnumerator, 0, 
                            &dwType, (LPBYTE)(&lVendorSetupKeysNum), &dwSize );
    if (ERROR_SUCCESS != lRet)
    {
        //
        // We cannot read the vendor setup registry enumerator. 
        // So the registry is damaged and the best is to remove from
        // it the other keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }

    RegCloseKey( hKeyVendorInfoEnumerator );
    hKeyVendorInfoEnumerator = INVALID_HANDLE_VALUE;

    if (lVendorSetupKeysNum <= 0) 
    {
        //
        // We have only the enumerator and no any vendor setup info key.
        // So there is nothing to do and we can remove from the registry 
        // all the keyes we use to call the vendor setup Dlls
        //
        RemoveVendorSetupInfoFromRegistry();
        goto Cleanup;
    }

    //
    // We have to add 1 for the enumerator key itself
    //
    lVendorSetupKeysNum += 1;

    lRet = RegQueryInfoKey( hKeyVendorInfo, NULL, NULL, NULL, &lVendorSetupKeysNum,
                            &dwMaxSubKeyLen, &dwMaxClassLen, &dwValues, &dwMaxValueNameLen,
                            &dwMaxValueLen, NULL, NULL );
    if (ERROR_SUCCESS != lRet) 
    {
        goto Cleanup;
    }

    dwKeyNameBufferLen = __max( __max( dwMaxClassLen, dwMaxSubKeyLen), 
                                __max( dwMaxValueNameLen, dwMaxValueLen ));
    dwKeyNameBufferLen += 2;
    if ( dwKeyNameBufferLen  > SIZECHARS(szParams) ) 
    {
        goto Cleanup;
    }
    pszKeyNameBuffer = AllocMem( dwKeyNameBufferLen * sizeof( CHAR ) );
    if (!pszKeyNameBuffer) 
    {
        goto Cleanup;
    }

    dwSize = dwKeyNameBufferLen * sizeof( CHAR );
    pszVendorSetupPtr = AllocMem( dwSize );
    if (!pszVendorSetupPtr) 
    {
        goto Cleanup;
    }

    hwnd = GetDesktopWindow();
    for (lIndex = lVendorSetupKeysNum - 1; lIndex >= 0; lIndex--)
    {
        lRet = RegEnumKeyA( hKeyVendorInfo, lIndex, pszKeyNameBuffer, dwKeyNameBufferLen);
        if (ERROR_SUCCESS != lRet) 
        {
            continue;
        }
        if (strcmp( pszKeyNameBuffer, pszVendorSetupEnumerator)) 
        {
            lRet = RegOpenKeyEx( hKeyVendorInfo, pszKeyNameBuffer, 0, 
                                 KEY_ALL_ACCESS, &hKeyVendorSetup );
            if (ERROR_SUCCESS != lRet)
            {
                goto Cleanup;
            }
            
            dwType = REG_SZ;
            lRet  = RegQueryValueExA(hKeyVendorSetup, pszKeyNameBuffer, 0, 
                                     &dwType, pszVendorSetupPtr, &dwSize );
            if (ERROR_SUCCESS != lRet) 
            {
                if (ERROR_MORE_DATA == lRet) 
                {
                    FreeMem( pszVendorSetupPtr );
                    pszVendorSetupPtr = AllocMem( dwSize );
                    if (!pszVendorSetupPtr) 
                    {
                        goto Cleanup;
                    }
                    lRet  = RegQueryValueExA(hKeyVendorSetup, pszKeyNameBuffer, 0, 
                                             &dwType, pszVendorSetupPtr, &dwSize );
                    if (ERROR_SUCCESS != lRet) 
                    {
                        goto Cleanup;
                    }
                }
                else
                {
                    goto Cleanup;
                }
            }
            RegCloseKey( hKeyVendorSetup );
            hKeyVendorSetup = INVALID_HANDLE_VALUE;

            ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
            ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
            ShellExecInfo.hwnd          = hwnd;
            ShellExecInfo.lpFile        = szCmd;
            ShellExecInfo.nShow         = SW_SHOWNORMAL;
            ShellExecInfo.fMask         = SEE_MASK_NOCLOSEPROCESS;
            ShellExecInfo.lpParameters  = pszVendorSetupPtr;

            //
            // Call run32dll and wait for the vendor dll to return before proceeding
            //
            if ( ShellExecuteEx(&ShellExecInfo) && ShellExecInfo.hProcess ) 
            {
                WaitForSingleObject(ShellExecInfo.hProcess, dwFourMinutes);
                CloseHandle(ShellExecInfo.hProcess);
            }
            RegDeleteKey( hKeyVendorInfo, pszKeyNameBuffer);

            //
            // One of the registry keys describing a vendor provided setup DLL
            // was removed. So the value of VendorInfoEnumerator must be
            // decremented by 1.
            //
            DecrementVendorSetupEnumerator();
        }
    }

    RemoveVendorSetupInfoFromRegistry();

Cleanup:

    if (pszVendorSetupPtr) 
    {
        FreeMem(pszVendorSetupPtr);
        pszVendorSetupPtr = NULL;
    }
    if (pszVendorSetupRunOnceValue) 
    {
        FreeMem(pszVendorSetupRunOnceValue);
    }
    if (pszKeyNameBuffer) 
    {
        FreeMem( pszKeyNameBuffer );
    }

    if (hKeyVendorRunOnceValuePath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceValuePath );
    }
    if (hKeyVendorRunOnceCallerValue != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorRunOnceCallerValue );
    }
    if (hKeyVendorSetup != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorSetup );
    }
    if (hKeyVendorInfoEnumerator != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoEnumerator );
    }
    if (hKeyVendorInfo != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfo );
    }
    if (hKeyVendorInfoPath != INVALID_HANDLE_VALUE) 
    {
        RegCloseKey( hKeyVendorInfoPath );
    }

    return;
}


BOOL
IsLocalAdmin(
    BOOL *pbAdmin
    )
/*++

Routine Description:
    This Routine determines if the user is a local admin.

Parameters:
    pbAdmin - Return Value, TRUE for local admin.

Return Value:
    TRUE             - Function succeded (return value is valid).

--*/ 
{
    HMODULE AdvApi32Dll;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL    bRet      = FALSE;
    PSID    pSIDAdmin = NULL;

    AllOCANDINITSID      pAllocAndInitID    = NULL;
    CHECKTOKENMEMBERSHIP pCheckTokenMemship = NULL;
    FREESID              pFreeSid           = NULL;


    ASSERT( pbAdmin != NULL );  // Called locally

    *pbAdmin = FALSE;

    AdvApi32Dll = LoadLibraryUsingFullPathA( "advapi32.dll" );
    if (AdvApi32Dll == NULL)
    {
        goto Cleanup;
    }
    pAllocAndInitID    = (AllOCANDINITSID)GetProcAddress( AdvApi32Dll, "AllocateAndInitializeSid");
    pCheckTokenMemship = (CHECKTOKENMEMBERSHIP)GetProcAddress( AdvApi32Dll, "CheckTokenMembership");
    pFreeSid           = (FREESID)GetProcAddress( AdvApi32Dll, "FreeSid");

    if (!pAllocAndInitID || !pCheckTokenMemship || !pFreeSid) 
    {
        goto Cleanup;
    }

    if (!((*pAllocAndInitID)( &SIDAuth, 2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS,
                              0, 0, 0, 0, 0, 0,
                              &pSIDAdmin))) 
    {
        goto Cleanup;
    }
    if (!((*pCheckTokenMemship)( NULL,
                                 pSIDAdmin,
                                 pbAdmin ))) 
    {
        goto Cleanup;
    }
    bRet = TRUE;

Cleanup:

    if (pSIDAdmin != NULL) 
    {
        (*pFreeSid)( pSIDAdmin );
    }
    if (AdvApi32Dll)
    {
        FreeLibrary( AdvApi32Dll );
    }

    return bRet;
}


LONG
DecrementVendorSetupEnumerator(
    VOID
    )
/*++

Routine Description:
    This routine is called to decrement the value of the VendorInfoEnumerator.
    It is called after removing of one of the registry keys containing a description 
    of a vendor provided DLL.
    
Arguments:
   
                                                                           
Return Value:
    ERROR_SUCCESS in the case of success
    error code in any other case.
    
--*/
{
    LONG   lRet                     = ERROR_BADKEY;
    HKEY   hKeyVendorInfo           = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorInfoPath       = INVALID_HANDLE_VALUE;
    HKEY   hKeyVendorEnumerator     = INVALID_HANDLE_VALUE;
    LONG   lEnumerator              = 0;
    DWORD  dwDisposition            = 0;
    DWORD  dwSize                   = 0;
    DWORD  dwType                   = 0;


    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszVendorSetupInfoPath, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfoPath );
    if (ERROR_SUCCESS != lRet)
    {
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( hKeyVendorInfoPath, pszVendorSetupInfo, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorInfo );
    if (ERROR_SUCCESS != lRet)
    {
        RegCloseKey( hKeyVendorInfoPath );
        goto Cleanup;
    }

    lRet = RegOpenKeyEx( hKeyVendorInfo, pszVendorSetupEnumerator, 0, 
                         KEY_ALL_ACCESS, &hKeyVendorEnumerator );
    if (ERROR_SUCCESS != lRet)
    {
        RegCloseKey( hKeyVendorInfo );
        RegCloseKey( hKeyVendorInfoPath );
        goto Cleanup;
    }
    else
    {
        dwType = REG_DWORD;
        dwSize = sizeof( lEnumerator );
        lRet  = RegQueryValueEx(hKeyVendorEnumerator, pszVendorSetupEnumerator, 0, 
                                 &dwType, (LPBYTE)(&lEnumerator), &dwSize );
        if (ERROR_SUCCESS == lRet)
        {
            lEnumerator--;
            lRet = RegSetValueEx(hKeyVendorEnumerator, pszVendorSetupEnumerator,
                                  0, REG_DWORD, (BYTE*)(&lEnumerator), dwSize );
        }
    }
    RegCloseKey( hKeyVendorEnumerator );
    RegCloseKey( hKeyVendorInfo );
    RegCloseKey( hKeyVendorInfoPath );

Cleanup:

    return lRet;
}

BOOL 
MakeACopyOfMigrateDll( 
    IN  LPCSTR pszWorkingDir 
    )
/*++

Routine Description:
    This routine is called to copy the Migrate.Dll into the given 
    directory.
    
Arguments:
    pszWorkingDir - the path where the Migrate.Dll to be copied.

Return Value:
    FALSE - in the case of error 
    TRUE  - in the case of success
    The bMigrateDllCopyed global variable is set to the corresponding value
    
--*/
{
    CHAR  szSource[MAX_PATH];
    CHAR  szTarget[MAX_PATH];
    DWORD dwSize;
    DWORD dwLen;

    if (bMigrateDllCopyed || !pszWorkingDir || !strlen(pszWorkingDir)) 
    {
        goto Cleanup;
    }
    //
    // First check if the source paths are ok
    //
    dwLen  = strlen(szMigDll);

    dwSize = sizeof(szTarget)/sizeof(szTarget[0]);

    if ( strlen(pszWorkingDir) + dwLen + 2 > dwSize )
    {
        goto Cleanup;
    }

    //
    // Need to make a copy of migrate.dll to the %windir%\system32\spool 
    // directory
    //
    sprintf(szSource, "%s\\%s", pszWorkingDir, szMigDll);
    if ( !(dwLen = GetFileNameInSpoolDir(szTarget, dwSize, szMigDll))   ||
         !CopyFileA(szSource, szTarget, FALSE) )
    {
        goto Cleanup;
    }
    
    bMigrateDllCopyed = TRUE;

Cleanup:
    return bMigrateDllCopyed;
}


HMODULE LoadLibraryUsingFullPathA(
    LPCSTR lpFileName
    )
{
    CHAR szSystemPath[MAX_PATH];
    INT  cLength         = 0;
    INT  cFileNameLength = 0;


    if (!lpFileName || ((cFileNameLength = strlen(lpFileName)) == 0)) 
    {
        return NULL;
    }
    if (GetSystemDirectoryA(szSystemPath, sizeof(szSystemPath)/sizeof(CHAR) ) == 0)
    {
        return NULL;
    }
    cLength = strlen(szSystemPath);
    if (szSystemPath[cLength-1] != '\\')
    {
        if ((cLength + 1) >= MAX_PATH)
        {
            return NULL;
        }
        szSystemPath[cLength]     = '\\';
        szSystemPath[cLength + 1] = '\0';
        cLength++;
    }
    if ((cLength + cFileNameLength) >= MAX_PATH)
    {
        return NULL;
    }
    strcat(szSystemPath, lpFileName);

    return LoadLibraryA( szSystemPath );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\dllmain.cpp ===
/*****************************************************************************\
* MODULE:       dllmain.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

extern "C" {

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR , DBG_ERROR );

#endif

}


///////////////////////////////////////////////////////////
//
// Global variables
//
static HMODULE g_hModule = NULL ;   // DLL module handle

const TCHAR g_szFriendlyName[] = _T ("Bidi Spooler APIs") ;
const TCHAR g_szRequestVerIndProgID[] = _T ("bidispl.bidirequest") ;
const TCHAR g_szRequestProgID[] = _T ("bidispl.bidirequest.1") ;

const TCHAR g_szContainerVerIndProgID[] = _T ("bidispl.bidirequestcontainer") ;
const TCHAR g_szContainerProgID[] = _T ("bidispl.bidirequestcontainer.1") ;

const TCHAR g_szSplVerIndProgID[] = _T ("bidispl.bidispl") ;
const TCHAR g_szSplProgID[] = _T ("bidispl.bidispl.1") ;

///////////////////////////////////////////////////////////
//
// Exported functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
	if ((g_cComponents == 0) && (g_cServerLocks == 0))
	{
		return S_OK ;
	}
	else
	{
		return S_FALSE ;
	}
}

//
// Get class factory
//
STDAPI DllGetClassObject(REFCLSID clsid,
                         REFIID iid,
                         PVOID * ppv)
{

    DBGMSG(DBG_TRACE,("Enter DllGetClassObject\n"));

	// Can we create this component?
	if (clsid != CLSID_BidiRequest &&
        clsid != CLSID_BidiRequestContainer &&
        clsid != CLSID_BidiSpl) {

		return CLASS_E_CLASSNOTAVAILABLE ;
	}

	// Create class factory.
	TFactory* pFactory = new TFactory (clsid) ;  // Reference count set to 1
                                                 // in constructor
	if (pFactory == NULL)
	{
		return E_OUTOFMEMORY ;
	}

	// Get requested interface.
	HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
	pFactory->Release() ;

	return hr ;

}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    BOOL bRet;
    TComRegistry ComReg;

	bRet = ComReg.RegisterServer(g_hModule,
                                 CLSID_BidiRequest,
                                 g_szFriendlyName,
                                 g_szRequestProgID,
                                 g_szRequestProgID) &&

           ComReg.RegisterServer (g_hModule,
                                  CLSID_BidiRequestContainer,
                                  g_szFriendlyName,
                                  g_szContainerVerIndProgID,
                                  g_szContainerProgID) &&

           ComReg.RegisterServer(g_hModule,
                                 CLSID_BidiSpl,
                                 g_szFriendlyName,
                                 g_szSplVerIndProgID,
                                 g_szSplProgID);
    return bRet;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    TComRegistry ComReg;
	
    return ComReg.UnregisterServer(CLSID_BidiRequest,
	                        g_szRequestVerIndProgID,
	                        g_szRequestProgID) &&

           ComReg.UnregisterServer(CLSID_BidiRequestContainer,
	                        g_szContainerVerIndProgID,
	                        g_szContainerProgID) &&

           ComReg.UnregisterServer(CLSID_BidiSpl,
	                        g_szSplVerIndProgID,
	                        g_szSplProgID);


}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		g_hModule = hModule ;

        //if( !bSplLibInit( NULL )){
        //
        //    DBGMSG( DBG_WARN,
        //            ( "DllEntryPoint: Failed to init SplLib %d\n", GetLastError()));
        //}

	}
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\enum.h ===
#ifndef _TBIDIREQUESTCONTAINERENUM
#define _TBIDIREQUESTCONTAINERENUM

class TBidiRequestContainer;

class TBidiRequestContainerEnum: 
    public IEnumUnknown
{
public:

	// IUnknown
	STDMETHOD(QueryInterface)(
        REFIID iid,
        void** ppv) ;         
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release)() ;

    STDMETHOD (Next)(
        IN  ULONG celt,          
        OUT  IUnknown ** rgelt,   
        OUT  ULONG * pceltFetched);
 
    STDMETHOD (Skip) (
        IN  ULONG celt);
 
    STDMETHOD (Reset)(void);
 
    STDMETHOD (Clone)(
        OUT IEnumUnknown ** ppenum);
        
    TBidiRequestContainerEnum (
        TBidiRequestContainer &refContainer,
        TReqInterfaceList &refReqList);

    TBidiRequestContainerEnum (
        TBidiRequestContainerEnum & refEnum);

    ~TBidiRequestContainerEnum ();

    inline BOOL 
    bValid () CONST {return m_bValid;};
    
private:    
    BOOL                    m_bValid;
	LONG                    m_cRef ;
    TReqInterfaceList &     m_refReqList;
    TReqInterfaceNode *     m_pHead;
    TReqInterfaceNode *     m_pCurrent;
    TBidiRequestContainer & m_refContainer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\globals.cpp ===
/*****************************************************************************\
* MODULE: globals.c
*
* This is the common global variable module.  Any globals used throughout the
* executable should be placed in here and the cooresponding declaration
* should be in "globals.h".
*
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   Weihai Chen (weihaic) 07-Mar-200
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

LONG g_cComponents = 0 ;
LONG g_cServerLocks = 0;



HRESULT STDMETHODCALLTYPE 
LastError2HRESULT (VOID) 
{
    return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError ());
}


HRESULT STDMETHODCALLTYPE 
WinError2HRESULT (DWORD dwError) 
{
    return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\enum.cpp ===
/*****************************************************************************\
* MODULE:       enum.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestContainerEnum::TBidiRequestContainerEnum (
    TBidiRequestContainer & refContainer,
    TReqInterfaceList & refReqList):
    m_refReqList (refReqList),
    m_refContainer (refContainer),
    m_cRef (1)
{
    m_refContainer.AddRef ();
    
    TAutoCriticalSection CritSec (m_refReqList);
    
    if (CritSec.bValid ())  {
        m_pHead = m_refReqList.GetHead();
        m_pCurrent = m_pHead;
        
        m_bValid = TRUE;
    }
    else 
        m_bValid = FALSE;

    
}

TBidiRequestContainerEnum::TBidiRequestContainerEnum (
    TBidiRequestContainerEnum & refEnum):
    m_refReqList (refEnum.m_refReqList),
    m_refContainer (refEnum.m_refContainer),
    m_cRef (1)
{
    m_refContainer.AddRef ();
    
    TAutoCriticalSection CritSec (m_refReqList);
    
    if (CritSec.bValid ())  {
        m_pHead = refEnum.m_pHead;
        m_pCurrent = refEnum.m_pCurrent;
        
        m_bValid = TRUE;
    }
    else 
        m_bValid = FALSE;
}


TBidiRequestContainerEnum::~TBidiRequestContainerEnum ()
{
    DBGMSG(DBG_TRACE,("TBidiRequestContainerEnum Destory Self\n"));
    m_refContainer.Release ();
}


STDMETHODIMP 
TBidiRequestContainerEnum::QueryInterface (
    REFIID iid,
    void** ppv)
{
    HRESULT hr = S_OK;
                
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IUnknown*>(this) ; 
	}
    else if (iid == IID_IEnumUnknown) {
    
		*ppv = static_cast<IEnumUnknown*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}
    
    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }
    
    DBGMSG(DBG_TRACE,("Leave TBidiRequestContainerEnum QI hr=%x\n", hr));
	return hr ;
    
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainerEnum::AddRef () 
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::AddRef ref= %d\n", m_cRef));
    
    // We add a reference to the container so that the container won't
    // delete the list where there is an outstadning enummeration 
    //
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainerEnum::Release () 
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}


STDMETHODIMP 
TBidiRequestContainerEnum::Next ( 
    IN  ULONG celt,          
    OUT IUnknown ** rgelt,   
    OUT ULONG * pceltFetched) 
{
    HRESULT hr;
    DWORD dwCount = 0;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Next\n"));

    if (m_bValid) {

        if (rgelt && pceltFetched) {
    
            TAutoCriticalSection CritSec (m_refReqList);
            
            if (CritSec.bValid ())  {
        
                while (m_pCurrent && dwCount < celt) {
                    TBidiRequestInterfaceData * pData = m_pCurrent->GetData ();
                    
                    *rgelt =  (IUnknown *) pData->GetInterface();
                    (*rgelt++)->AddRef ();
                    m_pCurrent = m_pCurrent->GetNext ();
                    dwCount++;
                }
            
                *pceltFetched = dwCount;
            
                hr =  S_OK;
            }
            else
                hr = LastError2HRESULT ();
        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;
    
    return hr;        
}

STDMETHODIMP 
TBidiRequestContainerEnum::Skip (
    IN  ULONG celt)
{
    HRESULT hr;

    DWORD dwCount = 0;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Skip\n"));
    
    if (m_bValid) {
        TAutoCriticalSection CritSec (m_refReqList);
        
        if (CritSec.bValid ())  {
        
            while (m_pCurrent && dwCount < celt) {
                m_pCurrent = m_pCurrent->GetNext ();
                dwCount++;
            }
            
            hr =  S_OK;
    
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;

    return hr;        
}

STDMETHODIMP 
TBidiRequestContainerEnum::Reset(void)
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Reset\n"));
    
    if (m_bValid) {
        m_pCurrent = m_pHead;
        return S_OK;
    }
    else
        return E_HANDLE;
    
}

STDMETHODIMP 
TBidiRequestContainerEnum::Clone(
    OUT IEnumUnknown ** ppenum)
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainerEnum::Clone\n"));
    
    if (m_bValid) {
        hr = PrivCreateComponent <TBidiRequestContainerEnum> (
                        new TBidiRequestContainerEnum (*this),
                        IID_IEnumUnknown, (void **)ppenum);
    }
    else 
        hr = E_HANDLE;

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\factory.h ===
/*****************************************************************************\
* MODULE:       TFactory.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TFACTORY
#define _TFACTORY

///////////////////////////////////////////////////////////
//
// Class factory
//
class TFactory : public IClassFactory
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(
        REFIID iid,
        void** ppv) ;

	STDMETHOD_ (ULONG, AddRef) () ;

	STDMETHOD_ (ULONG, Release)() ;

	// Interface IClassFactory
	STDMETHOD (CreateInstance) (
        IN  IUnknown* pUnknownOuter,
        IN  REFIID iid,
        OUT void** ppv) ;

	STDMETHOD (LockServer) (
        IN  BOOL bLock) ;

	TFactory(
        IN  REFGUID ClassId);

	~TFactory();

private:

	long m_cRef ;
    GUID m_ClassId;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\globals.h ===
/*****************************************************************************\
* MODULE:       globals.h
*
* PURPOSE:      Any globals used throughout the executable should be placed
*               in globals.c and the cooresponding declaration should
*               be in "globals.h".
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _GLOBALS_H
#define _GLOBALS_H

template <class T> 
HRESULT PrivCreateComponent (
    T * pIuk,
    REFIID iid, 
    void** ppv)
{
    HRESULT hr = E_FAIL;
    
    // Create component.
    if (pIuk) {
    
        if (pIuk->bValid ()) {
        
            // Get the requested interface.
            hr = pIuk->QueryInterface(iid, ppv) ;
        
        }
        else {
            hr = LastError2HRESULT ();
        }
        
        // Release the IUnknown pointer.
        pIuk->Release() ;

    }
    else {
        hr =  E_OUTOFMEMORY ;
    }
    return hr;
}



extern LONG g_cComponents;
extern LONG g_cServerLocks;

extern HRESULT STDMETHODCALLTYPE 
LastError2HRESULT (VOID);

extern HRESULT STDMETHODCALLTYPE 
WinError2HRESULT (
    DWORD dwError);

#define BIDI_NULL_SIZE 0
#define BIDI_INT_SIZE (sizeof (ULONG))
#define BIDI_FLOAT_SIZE (sizeof (FLOAT))
#define BIDI_BOOL_SIZE (sizeof (BOOL))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\factory.cpp ===
/*****************************************************************************\
* MODULE:       Factory.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

// Class factory IUnknown implementation
//
STDMETHODIMP
TFactory::QueryInterface(
    REFIID iid,
    void** ppv)
{
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ;
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

STDMETHODIMP_ (ULONG)
TFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TFactory::Release()
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

//
// IClassFactory implementation
//
STDMETHODIMP
TFactory::CreateInstance(
    IN  IUnknown* pUnknownOuter,
    IN  REFIID iid,
    OUT void** ppv)
{

    HRESULT hr = E_NOINTERFACE;

    DBGMSG(DBG_TRACE,("Class Factory:: CreateInstance\n"));

    // Cannot aggregate.
	if (pUnknownOuter != NULL) {
		return CLASS_E_NOAGGREGATION ;
	}

    if (IsEqualCLSID (CLSID_BidiRequestContainer, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiRequestContainer) || IsEqualIID (iid, IID_IUnknown)) {

            hr = PrivCreateComponent<TBidiRequestContainer> (new TBidiRequestContainer, iid, ppv);
        }
    }
    else if(IsEqualCLSID (CLSID_BidiRequest, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiRequest) || IsEqualIID (iid, IID_IUnknown) || IsEqualIID (iid, IID_IBidiRequestSpl)) {

            hr = PrivCreateComponent<TBidiRequest> (new TBidiRequest, iid, ppv);
        }
    }
    else if(IsEqualCLSID (CLSID_BidiSpl, m_ClassId))
    {
        if (IsEqualIID (iid, IID_IBidiSpl) || IsEqualIID (iid, IID_IUnknown)) {
            hr = PrivCreateComponent<TBidiSpl> (new TBidiSpl, iid, ppv);
        }
    }

    return hr;
}

// LockServer
STDMETHODIMP
TFactory::LockServer(
    BOOL bLock)
{
	if (bLock) {
		InterlockedIncrement(&g_cServerLocks) ;
	}
	else {
		InterlockedDecrement(&g_cServerLocks) ;
	}

    DBGMSG(DBG_TRACE,("Class Factory:: Lock Count = %d\n", g_cServerLocks));

	return S_OK ;
}


TFactory::TFactory(
    IN  REFGUID ClassId) :
    m_cRef(1),
    m_ClassId (ClassId)
{
    DBGMSG(DBG_TRACE,("Class Factory:: Created\n"));
}

TFactory::~TFactory()
{
    DBGMSG(DBG_TRACE,("Class Factory:: Destroy Itself\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\priv.h ===
#include "bidispl.h"
#include "bidisplp.h"
#include "globals.h"
#include "factory.h"
#include "request.h"
#include "registry.h"
#include "respdata.h"
#include "reqcont.h"
#include "splapi.h"
#include "reqdata.h"
#include "enum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\reqdata.h ===
#ifndef _TBIDIREQUESTINTERFACEDATA
#define _TBIDIREQUESTINTERFACEDATA


class TBidiRequestInterfaceData
{
public:           

    TBidiRequestInterfaceData (
        IBidiRequest *pRequest): 
        m_pRequest (pRequest),
        m_bValid (FALSE) {m_pRequest->AddRef ();};
        
    virtual ~TBidiRequestInterfaceData () {m_pRequest->Release ();};
    
    inline BOOL 
    bValid () CONST {return m_bValid;};
    
    inline IBidiRequest * 
    GetInterface (VOID) CONST {return m_pRequest;};
    
    
private:

    IBidiRequest *m_pRequest;
    BOOL m_bValid;                    
};

typedef TDoubleNode<TBidiRequestInterfaceData *, DWORD> TReqInterfaceNode;
typedef TDoubleListLock<TBidiRequestInterfaceData *, DWORD> TReqInterfaceList;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\reqcont.cpp ===
/*****************************************************************************\
* MODULE:       reqcont.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestContainer::TBidiRequestContainer():
    m_cRef(1)
{
	InterlockedIncrement(&g_cComponents) ; 
    
    m_bValid = m_ReqInterfaceList.bValid ();
    
    DBGMSG(DBG_TRACE,("TBidiRequestContainer Created\n"));
}

TBidiRequestContainer::~TBidiRequestContainer()
{
    InterlockedDecrement(&g_cComponents) ; 
    
    DBGMSG(DBG_TRACE,("TBidiRequestContainer Dstroy self\n"));
}


STDMETHODIMP 
TBidiRequestContainer::QueryInterface (
    REFIID iid, 
    void** ppv)
{
    HRESULT hr = S_OK;
                
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IBidiRequestContainer*>(this) ; 
	}
    else if (iid == IID_IBidiRequestContainer) {
    
		*ppv = static_cast<IBidiRequestContainer*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}
    
    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }
    
    DBGMSG(DBG_TRACE,("Leave TBidiRequestContainer QI hr=%x\n", hr));
	return hr ;
    
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainer::AddRef ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequestContainer::Release ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;

}
   
STDMETHODIMP 
TBidiRequestContainer::AddRequest (
    IN IBidiRequest *pRequest)
{
    HRESULT hr (E_FAIL);
    
    DBGMSG(DBG_TRACE,("Enter TBidiRequestContainer::AddRequest\n"));

    if (m_bValid) {
    
        TBidiRequestInterfaceData * pData = NULL;
        
        pData = new TBidiRequestInterfaceData (pRequest);
        
        if (pData) {
        
            if (m_ReqInterfaceList.AppendItem (pData)) {
                hr = S_OK;
            }
            else 
                delete pData;
        }
       
        if (hr != S_OK) {
            hr = LastError2HRESULT ();
        }
    }
    else
        hr = E_HANDLE;
                      
    return hr;
}
 
    
STDMETHODIMP 
TBidiRequestContainer::GetEnumObject (
    OUT IEnumUnknown **ppenum)
{
    HRESULT hr;
    
    if (m_bValid) {
        hr = PrivCreateComponent <TBidiRequestContainerEnum> (
                        new TBidiRequestContainerEnum (*this, m_ReqInterfaceList),
                        IID_IEnumUnknown, (void **)ppenum);
    }
    else
        hr = E_HANDLE;
    
    return hr;
}
        

STDMETHODIMP 
TBidiRequestContainer::GetRequestCount(
    OUT ULONG *puCount)
{
    HRESULT hr;
    
    if (m_bValid) {
        if (m_ReqInterfaceList.GetTotalNode (puCount)) {
            hr = S_OK;
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\registry.cpp ===
/*****************************************************************************\
* MODULE:       registry.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string

CONST DWORD TComRegistry::m_cdwClsidStringSize              = 39;
CONST TCHAR TComRegistry::m_cszCLSID[]                      = _T ("CLSID\\");
CONST TCHAR TComRegistry::m_cszCLSID2[]                     = _T ("CLSID");
CONST TCHAR TComRegistry::m_cszInprocServer32[]             = _T ("InprocServer32");
CONST TCHAR TComRegistry::m_cszProgID[]                     = _T ("ProgID");
CONST TCHAR TComRegistry::m_cszVersionIndependentProgID[]   = _T ("VersionIndependentProgID");
CONST TCHAR TComRegistry::m_cszCurVer[]                     = _T ("CurVer");
CONST TCHAR TComRegistry::m_cszThreadingModel[]             = _T ("ThreadingModel");
CONST TCHAR TComRegistry::m_cszBoth[]                       = _T ("Both");


/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
BOOL
TComRegistry::RegisterServer(
    IN  HMODULE hModule,            // DLL module handle
    IN  REFCLSID clsid,             // Class ID
    IN  LPCTSTR pszFriendlyName,    // Friendly Name
    IN  LPCTSTR pszVerIndProgID,    // Programmatic
    IN  LPCTSTR pszProgID)          //   IDs
{
    BOOL bRet = FALSE;
    // Get server location.
    TCHAR szModule [MAX_PATH];

    DWORD dwResult;
    TCHAR szCLSID[m_cdwClsidStringSize] ;

    DBGMSG(DBG_TRACE,("Enter RegisterServer"));


    if (GetModuleFileName(hModule, szModule,MAX_PATH) > 0) {

        // Convert the CLSID into a string.
        if (CLSIDtoString(clsid, szCLSID, sizeof(szCLSID))) {

            // Build the key CLSID\\{...}

            TCHAR szKey[64] ;
            lstrcpy(szKey, m_cszCLSID) ;
            lstrcat(szKey, szCLSID) ;

            // Add the CLSID to the registry.
            if (SetKeyAndValue(szKey, NULL, pszFriendlyName) &&

                // Add the server filename subkey under the CLSID key.
                SetKeyAndValue(szKey, m_cszInprocServer32, szModule) &&

                SetKeyAndNameValue(szKey, m_cszInprocServer32, m_cszThreadingModel, m_cszBoth) &&

                // Add the ProgID subkey under the CLSID key.
                SetKeyAndValue(szKey, m_cszProgID, pszProgID) &&

                // Add the version-independent ProgID subkey under CLSID key.
                SetKeyAndValue(szKey, m_cszVersionIndependentProgID, pszVerIndProgID) &&

                // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
                SetKeyAndValue(pszVerIndProgID, NULL, pszFriendlyName) &&
                SetKeyAndValue(pszVerIndProgID, m_cszCLSID2, szCLSID) &&
                SetKeyAndValue(pszVerIndProgID, m_cszCurVer, pszProgID) &&

                // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
                SetKeyAndValue(pszProgID, NULL, pszFriendlyName) &&
                SetKeyAndValue(pszProgID, m_cszCLSID2, szCLSID) ) {

                bRet = TRUE;
            }
        }
    }

    DBGMSG(DBG_TRACE,("Leave RegisterServer (Ret = %d)\n", bRet));

    return bRet;
}

//
// Remove the component from the registry.
//
BOOL
TComRegistry::UnregisterServer(
    IN  REFCLSID clsid,             // Class ID
    IN  LPCTSTR pszVerIndProgID,    // Programmatic
    IN  LPCTSTR pszProgID)          //   IDs
{
    BOOL bRet = FALSE;
    // Convert the CLSID into a char.
    TCHAR szCLSID[m_cdwClsidStringSize] ;

    DBGMSG(DBG_TRACE,("Enter UnregisterServer\n", bRet));

    if (CLSIDtoString(clsid, szCLSID, sizeof(szCLSID))) {

        TCHAR szKey[64] ;
        lstrcpy(szKey, m_cszCLSID) ;
        lstrcat(szKey, szCLSID) ;

        if (RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) &&
            RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszVerIndProgID) &&
            RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszProgID)) {

            bRet = TRUE;

        }
    }

    DBGMSG(DBG_TRACE,("Leave UnregisterServer (Ret = %d)\n", bRet));

    return bRet;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a string.
BOOL
TComRegistry::CLSIDtoString(
    IN      REFCLSID    clsid,
    IN OUT  LPTSTR      pszCLSID,
    IN      DWORD       dwLength)

{
    BOOL bRet = FALSE;
    HRESULT hr = E_FAIL;
    LPWSTR pwszCLSID = NULL ;

    if (dwLength >= m_cdwClsidStringSize ) {
        // Get CLSID

        hr = StringFromCLSID(clsid, &pwszCLSID);

        if (SUCCEEDED (hr)) {
            lstrcpy (pszCLSID, pwszCLSID);

            // Free memory.
            CoTaskMemFree(pwszCLSID) ;

            bRet = TRUE;
        }
        else
            SetLastError (HRESULTTOWIN32 (hr));
    }

    return bRet;
}

//
// Delete a key and all of its descendents.
//
BOOL
TComRegistry::RecursiveDeleteKey(
    IN  HKEY hKeyParent,            // Parent of key to delete
    IN  LPCTSTR lpszKeyChild)       // Key to delete
{
    BOOL bRet = FALSE;
    // Open the child.
    HKEY hKeyChild = NULL;
    LONG lResult = 0;
    FILETIME time ;
    TCHAR szBuffer[MAX_PATH] ;
    DWORD dwSize;

    lResult = RegOpenKeyEx (hKeyParent, lpszKeyChild, 0, KEY_ALL_ACCESS, &hKeyChild) ;

    if (lResult == ERROR_SUCCESS)
    {

        // Enumerate all of the decendents of this child.

        for (;;) {

            dwSize = MAX_PATH ;

            lResult = RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time);
            if (lResult == ERROR_NO_MORE_ITEMS) {
                break;
            }
            else if (lResult == ERROR_SUCCESS) {
                // Delete the decendents of this child.
                if (!RecursiveDeleteKey (hKeyChild, szBuffer)) {
                    goto Cleanup;
                }
            }
            else {
                goto Cleanup;
            }
        }

        // Close the child.
        RegCloseKey(hKeyChild) ;
        hKeyChild = NULL;

        // Delete this child.
        if (ERROR_SUCCESS == RegDeleteKey(hKeyParent, lpszKeyChild)) {
            bRet = TRUE;
        }

    }

Cleanup:
    // Cleanup before exiting.
    if (hKeyChild)
        RegCloseKey(hKeyChild) ;

    if (!bRet && lResult)
        SetLastError (lResult);

    return bRet;

}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL
TComRegistry::SetKeyAndValue(
    IN  LPCTSTR pszKey,
    IN  LPCTSTR pszSubkey,
    IN  LPCTSTR pszValue)
{
    return SetKeyAndNameValue  (pszKey, pszSubkey, NULL, pszValue);
}

BOOL
TComRegistry::SetKeyAndNameValue(
    IN  LPCTSTR pszKey,
    IN  LPCTSTR pszSubkey,
    IN  LPCTSTR pszName,
    IN  LPCTSTR pszValue)
{
    BOOL bRet = FALSE;
    HKEY hKey = NULL;
    LPTSTR pszKeyBuf = NULL;
    long lResult;
    DWORD dwLen = lstrlen (pszKey) + 1;

    if (pszSubkey)
    {
        dwLen += lstrlen (pszSubkey) + 1;
    }

    pszKeyBuf = new TCHAR [dwLen];

    if (pszKeyBuf)
    {
        // Copy keyname into buffer.
        lstrcpy(pszKeyBuf, pszKey) ;

        // Add subkey name to buffer.
        if (pszSubkey != NULL)
        {
            lstrcat(pszKeyBuf, _T ("\\")) ;
            lstrcat(pszKeyBuf, pszSubkey ) ;
        }

        // Create and open key and subkey.
        lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                 pszKeyBuf, 0, NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS, NULL, &hKey, NULL);

        if (ERROR_SUCCESS == lResult ) {

            // Set the Value.
            if (pszValue != NULL) {

                lResult = RegSetValueEx (hKey, pszName, 0, REG_SZ,
                            (PBYTE) pszValue, sizeof (TCHAR) * lstrlen(pszValue));

                if (ERROR_SUCCESS == lResult ) {

                    bRet = TRUE;
                }
            }
            else
                bRet = TRUE;
        }


        if (hKey) {
            RegCloseKey(hKey) ;
        }

        delete [] pszKeyBuf;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\reqcont.h ===
/*****************************************************************************\
* MODULE:       request.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDIREQUESTCONTAINER
#define _TBIDIREQUESTCONTAINER


#include "priv.h"
     
class TBidiRequestContainer : public IBidiRequestContainer
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID iid, 
        void** ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release) () ;
    
    STDMETHOD (AddRequest) (
        IN      IBidiRequest *pRequest);
    
    STDMETHOD (GetEnumObject) (
        OUT     IEnumUnknown **ppenum);

    STDMETHOD (GetRequestCount)(
        OUT     ULONG *puCount);
    
    // Constructor
	TBidiRequestContainer() ;

	// Destructor
	~TBidiRequestContainer();
    
    inline BOOL 
    bValid() CONST {return m_bValid;};

private:
    BOOL                m_bValid;
    LONG                m_cRef ;
    TReqInterfaceList   m_ReqInterfaceList;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\reqdata.cpp ===
/*****************************************************************************\
* MODULE:       respdata.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/08/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiRequestInterfaceData::TBidiRequestInterfaceData (
    IBidiRequest *pRequest):
    m_pRequest (pRequest),
    m_bValid (TRUE)
{
    pRequest->AddRef ();
}

TBidiRequestInterfaceData::~TBidiRequestInterfaceData ()
{
    pRequest->Release ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
/*****************************************************************************\
* MODULE:       bidireq.cpp
*
* PURPOSE:      Helper functions registering and unregistering a component.
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

class TComRegistry {
public:

    TComRegistry (){};
    ~TComRegistry () {};

    static BOOL
    RegisterServer(
        IN      HMODULE     hModule, 
        IN      REFCLSID    clsid,  
        IN      LPCTSTR     pszFriendlyName,
        IN      LPCTSTR     pszVerIndProgID,
        IN      LPCTSTR     pszProgID);     
                           
    
    static BOOL 
    UnregisterServer(
        IN      REFCLSID    clsid, 
        IN      LPCTSTR     pszVerIndProgID,
        IN      LPCTSTR     pszProgID);     
private:
    static BOOL 
    SetKeyAndValue(
        IN      LPCTSTR     pszKey,
        IN      LPCTSTR     pszSubkey,
        IN      LPCTSTR     pszValue);
    
               
    static BOOL 
    SetKeyAndNameValue(
        IN      LPCTSTR     pszKey,
        IN      LPCTSTR     pszSubkey,
        IN      LPCTSTR     pszName,
        IN      LPCTSTR     pszValue);
                            
    // Convert a CLSID into a char string.
    static BOOL  
    CLSIDtoString(
        IN      REFCLSID    clsid,
        IN OUT  LPTSTR      pszCLSID, 
        IN      DWORD       dwLength);
    
    // Delete szKeyChild and all of its descendents.
    static BOOL 
    RecursiveDeleteKey(
        IN      HKEY        hKeyParent,            // Parent of key to delete
        IN      LPCTSTR     lpszKeyChild);      // Key to delete

    // Size of a CLSID as a string
    static CONST DWORD m_cdwClsidStringSize;
    static CONST TCHAR m_cszCLSID[];
    static CONST TCHAR m_cszCLSID2[];
    static CONST TCHAR m_cszInprocServer32[];
    static CONST TCHAR m_cszProgID[];
    static CONST TCHAR m_cszVersionIndependentProgID[];
    static CONST TCHAR m_cszCurVer[];
    static CONST TCHAR m_cszThreadingModel[];
    static CONST TCHAR m_cszBoth[];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\request.cpp ===
/*****************************************************************************\
* MODULE:       request.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


//
// Constructor
//
TBidiRequest::TBidiRequest() : 
    m_cRef(1),
    m_kDataType (BIDI_NULL),
    m_dwDataSize (0),
    m_pbData (NULL),
    m_pSchema (NULL),
    m_bValid (FALSE)
{ 
	InterlockedIncrement(&g_cComponents) ; 
    
    m_bValid = m_CritSec.bValid () && m_ResponseDataList.bValid ();
    
    DBGMSG(DBG_TRACE,("TBidiRequest Created\n"));
}

//
// Destructor
//
TBidiRequest::~TBidiRequest() 
{ 
	
    InterlockedDecrement(&g_cComponents) ; 
    
    if (m_pSchema)
        delete [] m_pSchema;
    
    DBGMSG(DBG_TRACE,("TBidiRequest Dstroy self\n"));
}

//
// IUnknown implementation
//
STDMETHODIMP
TBidiRequest::QueryInterface(
    REFIID iid, 
    PVOID* ppv)
{    
    
    HRESULT hr = S_OK;
                
    DBGMSG(DBG_TRACE,("Enter TBidiRequest QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IBidiRequest*>(this) ; 
	}
    else if (iid == IID_IBidiRequest) {
    
		*ppv = static_cast<IBidiRequest*>(this) ;
	}
    else if (iid == IID_IBidiRequestSpl) {
    
		*ppv = static_cast<IBidiRequestSpl*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}
    
    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }
    
    DBGMSG(DBG_TRACE,("Leave TBidiRequest QI hr=%x\n", hr));
	return hr ;
}

STDMETHODIMP_ (ULONG)
TBidiRequest::AddRef()
{
    DBGMSG(DBG_TRACE,("Enter TBidiRequest::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiRequest::Release() 
{

    DBGMSG(DBG_TRACE,("Enter TBidiRequest::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}


STDMETHODIMP
TBidiRequest::SetSchema( 
    LPCWSTR pszSchema)
{
    HRESULT hr (E_FAIL);
    
    DBGMSG(DBG_TRACE,("Enter SetSchema %ws\n", pszSchema));
    
    if (m_bValid) {
    
        TAutoCriticalSection CritSec (m_CritSec);
        
        if (CritSec.bValid ()) {

            if (m_pSchema) {
                delete[] m_pSchema;
                m_pSchema = NULL;
            }

            if (pszSchema) {
                m_pSchema = new WCHAR [lstrlen (pszSchema) + 1];

                if (m_pSchema) {
                    lstrcpy (m_pSchema, pszSchema);
                    hr = S_OK;
                }
            }
            else
                SetLastError (ERROR_INVALID_PARAMETER);
        }
        
        if (FAILED (hr)) {
        
            hr = LastError2HRESULT();
        }
    }
    else
        hr = E_HANDLE;
    
    return hr;
}

STDMETHODIMP 
TBidiRequest::SetInputData( 
    IN CONST    DWORD   dwType,
    IN CONST    BYTE    *pData,
    IN CONST    UINT    uSize)
{
    HRESULT hr (S_OK);
    
    DBGMSG(DBG_TRACE,("Enter SetInputData dwType=%d\n", dwType));

    if (m_bValid) {
    
        // Verify data type and its size
        switch (dwType) {
        case BIDI_NULL:
            if (uSize)
                hr = E_INVALIDARG;
            break;
        case BIDI_INT:
        	if (uSize != sizeof (ULONG)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_FLOAT:
        	if (uSize != sizeof (FLOAT)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_BOOL:
        	if (uSize != sizeof (BOOL)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_ENUM:
        case BIDI_STRING:  
        case BIDI_TEXT:
            if (uSize != sizeof (WCHAR) * (lstrlen (reinterpret_cast<LPCWSTR> (pData)) + 1)) {
                hr = E_INVALIDARG;
            }
            break;
        case BIDI_BLOB:
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
        }
        
        if (hr == S_OK) {
    
            TAutoCriticalSection CritSec (m_CritSec);
            
            if (CritSec.bValid ()) {
            
                if (m_pbData) {
                    delete [] m_pbData;
                    m_pbData = NULL;
                }
        
                m_kDataType = (BIDI_TYPE) dwType;
                m_dwDataSize = uSize;
            
                if (uSize > 0) {
                    m_pbData = new BYTE [uSize];
                
                    if (m_pbData) {
                        CopyMemory (m_pbData, pData, uSize);
                        hr = S_OK;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else
                    hr = S_OK;
    
            }
            else {
                hr = LastError2HRESULT();
            }
        }
    }
    else
        hr = E_HANDLE;
        
    return hr;
}
    
        
STDMETHODIMP 
TBidiRequest::GetResult( 
    HRESULT  *phr)
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter GetResult\n"));
    
    if (m_bValid) {
    
        if (phr) {
            TAutoCriticalSection CritSec (m_CritSec);
        
            if (CritSec.bValid ()) {
                *phr = m_hr;
                hr = S_OK;
            }
            else
                hr = LastError2HRESULT();
                
        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;
        
    return hr;
}
        
        
         
STDMETHODIMP 
TBidiRequest::GetOutputData( 
    DWORD   dwIndex,
    LPWSTR  *ppszSchema,
    PDWORD  pdwType,
    PBYTE   *ppData,
    PULONG  puSize) 
{
    HRESULT hr (E_FAIL);
    
    DBGMSG(DBG_TRACE,("Enter GetOutputData\n"));
    
    if (m_bValid) {
    
        if (ppszSchema && ppData && pdwType && puSize) {
        
            TAutoCriticalSection CritSec (m_CritSec);
            PBYTE   pData       = NULL;
            LPWSTR  pszSchema   = NULL;
            DWORD   dwType      = 0;
            DWORD   dwSize      = 0;
        
            if (CritSec.bValid ()) {
                TResponseData * pRespData = m_ResponseDataList.GetItemFromIndex (dwIndex);
                
                if (pRespData) {
                
                    LPCTSTR pszRespSchema = pRespData->GetSchema ();
                    
                    if (pszRespSchema) {
                        pszSchema = (LPWSTR) CoTaskMemAlloc (( 1 + lstrlen (pszRespSchema)) * sizeof (TCHAR)); 
                        
                        if (pszSchema) {
                            lstrcpy (pszSchema, pszRespSchema);
                        }
                        else
                            goto Cleanup;
                    }
                    else
                        pszSchema = NULL;
                    
                    dwType = pRespData->GetType ();
                    dwSize = pRespData->GetSize ();
                    
                    if (dwSize == 0) {
                        hr = S_OK;
                    }
                    else {
                        pData = (PBYTE) CoTaskMemAlloc (dwSize);
                        
                        if (pData) {
                            CopyMemory (pData, pRespData->GetData (), dwSize);
                            hr = S_OK;
                        }
                    }
                }
                else {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }
    Cleanup:        
            if (FAILED (hr)) {
                hr = LastError2HRESULT ();
                
                if (pszSchema) {
                    CoTaskMemFree (pszSchema);
                    pszSchema = NULL;
                }
                if (pData) {
                    CoTaskMemFree (pData);
                    pData = NULL;
                }
            }
            else {
                *ppszSchema = pszSchema;
                *ppData = pData;
                *pdwType = dwType;
                *puSize = dwSize;
            }
            
        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;
            
    return hr;

}
        
STDMETHODIMP 
TBidiRequest::GetEnumCount(
    OUT PDWORD pdwTotal) 
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter GetOutputData\n"));
    
    if (m_bValid) {
    
        if (pdwTotal) {
            TAutoCriticalSection CritSec (m_CritSec);
        
            if (CritSec.bValid ()) {
                BOOL bRet;
                
                bRet = m_ResponseDataList.GetTotalNode (pdwTotal);
                
                if (bRet) {
                    hr = S_OK;
                }
                else 
                    hr = LastError2HRESULT();
            }
            else
                hr = LastError2HRESULT();
        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;
    
    return hr;
}


STDMETHODIMP
TBidiRequest::GetSchema  (
    OUT LPWSTR *ppszSchema)
{
    HRESULT hr;
    LPWSTR pStr;
    
    DBGMSG(DBG_TRACE,("Enter GetSchema\n"));
    
    if (m_bValid) {
    
        if (ppszSchema) {
            
            TAutoCriticalSection CritSec (m_CritSec);
        
            if (CritSec.bValid ()) {
            
                if (m_pSchema) {
                
                    pStr = (LPWSTR) CoTaskMemAlloc (( 1 + lstrlen (m_pSchema)) * sizeof (WCHAR));
                    
                    if (pStr) {
                        
                        lstrcpy (pStr, m_pSchema);
                        
                        *ppszSchema = pStr;
                        
                        hr = S_OK;
                        
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else {
                    *ppszSchema = NULL;
                    hr = S_OK;
                }
            }
            else
                hr = LastError2HRESULT();
        }
        else {
            hr = E_POINTER;
        }
    }
    else
        hr = E_HANDLE;
    
    return hr;
}

STDMETHODIMP
TBidiRequest::GetInputData  (
    OUT PDWORD   pdwType,
    OUT PBYTE   *ppData,
    OUT PULONG  puSize) 
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter GetInputData\n"));
    
    if (m_bValid) {
    
        if (pdwType && ppData && puSize) {
        
            TAutoCriticalSection CritSec (m_CritSec);
        
            if (CritSec.bValid ()) {
    
                *pdwType = m_kDataType;
            
                if (m_pbData) {
                
                    *ppData = (PBYTE) CoTaskMemAlloc (m_dwDataSize);
                    
                    if (*ppData) {
                        CopyMemory (*ppData, m_pbData, m_dwDataSize);
                        *puSize = m_dwDataSize;
                        
                        hr = S_OK;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else {
                    *ppData = NULL;
                    *puSize = 0;
                    hr = S_OK;
                }
            }
            else
                hr = LastError2HRESULT();
        }
        else
            hr = E_POINTER;
    }
    else
        hr = E_HANDLE;
        
    return hr;
}
                
STDMETHODIMP
TBidiRequest::SetResult (
    IN CONST HRESULT hrReq)
{
    HRESULT hr;
    
    DBGMSG(DBG_TRACE,("Enter SetResult\n"));
    
    if (m_bValid) {
    
        TAutoCriticalSection CritSec (m_CritSec);
        
        if (CritSec.bValid ()) {
            m_hr = hrReq;
            hr = S_OK;
        }
        else
            hr = LastError2HRESULT();
    }
    else
        hr = E_HANDLE;
        
    return hr;
}

STDMETHODIMP
TBidiRequest::AppendOutputData (
    IN  CONST   LPCWSTR pszSchema,
    IN  CONST   DWORD   dwType, 
    IN  CONST   BYTE    *pData,
    IN  CONST   ULONG   uSize)
{
    HRESULT hr (E_FAIL);
    BOOL bRet;
    
    DBGMSG(DBG_TRACE,("Enter AppendOutputData\n"));
    
    if (m_bValid) {
    
        TResponseData *pRespData = NULL;
        
        pRespData = new TResponseData (pszSchema, dwType, pData, uSize);
        
        bRet = pRespData && pRespData->bValid ();
        
        if (bRet) {
        
            TAutoCriticalSection CritSec (m_CritSec);
        
            if (CritSec.bValid ()) {
            
                bRet = m_ResponseDataList.AppendItem (pRespData);
            
                if (bRet) {
                    hr = S_OK;
                
                }
            }
        }
        
        if (FAILED (hr)) {
            hr = LastError2HRESULT();
            if (pRespData) {
                delete (pRespData);
            }
        }
    }
    else
        hr = E_HANDLE;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\respdata.h ===
#ifndef _TRESPONSEDATA
#define _TRESPONSEDATA

class TResponseData
{
public:

    TResponseData (
        IN  CONST LPCWSTR   pszSchema,
        IN  CONST DWORD     dwType,
        IN  CONST BYTE      *pData,
        IN  CONST ULONG     uSize);

    virtual ~TResponseData ();

    inline BOOL 
    bValid () CONST {return m_bValid;};

    inline LPCWSTR 
    GetSchema (VOID) CONST {return m_pSchema;};

    inline PBYTE 
    GetData (VOID) CONST {return m_pData;};

    inline DWORD 
    GetType (VOID) CONST {return m_dwType;};

    inline ULONG 
    GetSize (VOID) CONST {return m_uSize;};


private:

    BOOL m_bValid;
    LPWSTR m_pSchema;
    DWORD m_dwType;
    PBYTE m_pData;
    ULONG m_uSize;

};

typedef TDoubleList<TResponseData *, DWORD> TResponseDataList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\respdata.cpp ===
/*****************************************************************************\
* MODULE:       respdata.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/08/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TResponseData::TResponseData (
    IN  CONST LPCWSTR   pszSchema,
    IN  CONST DWORD     dwType,
    IN  CONST BYTE      *pData,
    IN  CONST ULONG     uSize):
    m_dwType (dwType),
    m_pData (NULL),
    m_uSize (uSize),
    m_pSchema (NULL),
    m_bValid (FALSE)
{
    BOOL bValid = FALSE;

    //
    // In the response, the schema string can be NULL for GET operation
    //

    if (pszSchema) {
        
        m_pSchema = new WCHAR [lstrlen (pszSchema) + 1];

        if (m_pSchema) {
            lstrcpy (m_pSchema, pszSchema);
            bValid = TRUE;
        }
    }
    else
        bValid = TRUE;
    
    if (bValid) {

        // Validate the type and size
        BOOL bRet;

        switch (dwType) {
        case BIDI_NULL:
            bRet = uSize == BIDI_NULL_SIZE;
            break;
        case BIDI_INT:
            bRet = uSize == BIDI_INT_SIZE;
            break;
        case BIDI_FLOAT:
            bRet = uSize == BIDI_FLOAT_SIZE;
            break;
        case BIDI_BOOL:
            bRet = uSize == BIDI_BOOL_SIZE;
            break;
        case BIDI_ENUM:
            bRet = (uSize > 0);
            break;

        case BIDI_STRING:
        case BIDI_TEXT:
        case BIDI_BLOB:
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
        }

        if (bRet) {

            if (uSize) {

                m_pData = new BYTE [uSize];
                if (m_pData) {
                    CopyMemory (m_pData, pData, uSize);
                    m_bValid = TRUE;
                }
            }
            else
                m_bValid = TRUE;
        }
    }
}

TResponseData::~TResponseData ()
{
    if (m_pData) {
        delete [] m_pData;
        m_pData = NULL;
    }

    if (m_pSchema) {
        delete [] m_pSchema;
        m_pSchema = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\splapi.cpp ===
/*****************************************************************************\
* MODULE:       splapi.cpp
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TBidiSpl::TBidiSpl():
    m_bValid (FALSE),
    m_cRef (1),
    m_CritSec (),
    m_hPrinter (NULL),
    m_pfnSendRecvBidiData (NULL),
    m_pfnRouterFreeBidiResponseContainer (NULL)


{
    HMODULE hModule = NULL;

    InterlockedIncrement(&g_cComponents) ;

    if (m_CritSec.bValid ()) {

        hModule = GetModuleHandle (_T ("winspool.drv"));

        if (hModule) {

            m_pfnSendRecvBidiData = (PFN_SENDRECVBIDIDATA) GetProcAddress (
                hModule, MAKEINTRESOURCEA (222));

            m_pfnRouterFreeBidiResponseContainer = (PFN_ROUTERFREEBIDIRESPONSECONTAINER) GetProcAddress (
                hModule, MAKEINTRESOURCEA (223));

            if (m_pfnSendRecvBidiData && m_pfnRouterFreeBidiResponseContainer) {
                m_bValid = TRUE;
            }
        }
    }

    DBGMSG(DBG_TRACE,("TBidiSpl Created\n"));
}

TBidiSpl::~TBidiSpl()
{
    UnbindDevice ();
    InterlockedDecrement(&g_cComponents) ;

    DBGMSG(DBG_TRACE,("TBidiSpl Dstroy self\n"));
}


STDMETHODIMP
TBidiSpl::QueryInterface (
    REFIID iid,
    void** ppv)
{
    HRESULT hr = S_OK;

    DBGMSG(DBG_TRACE,("Enter TBidiSpl QI\n"));
	
    if (iid == IID_IUnknown) {
		*ppv = static_cast<IBidiSpl*>(this) ;
	}
    else if (iid == IID_IBidiSpl) {

		*ppv = static_cast<IBidiSpl*>(this) ;
	}
	else {
		*ppv = NULL ;
		hr = E_NOINTERFACE ;
	}

    if (*ppv) {
    	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    }

    DBGMSG(DBG_TRACE,("Leave TBidiSpl QI hr=%x\n", hr));
	return hr ;

}

STDMETHODIMP_ (ULONG)
TBidiSpl::AddRef ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiSpl::AddRef ref= %d\n", m_cRef));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_ (ULONG)
TBidiSpl::Release ()
{
    DBGMSG(DBG_TRACE,("Enter TBidiSpl::Release ref= %d\n", m_cRef));
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;

}


STDMETHODIMP
TBidiSpl::BindDevice (
    IN  CONST   LPCWSTR pszDeviceName,
    IN  CONST   DWORD dwAccess)
{
    HRESULT hr (E_FAIL);

    HANDLE hPrinter = NULL;
    HANDLE hOldPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefault = {NULL, NULL, 0};

    BOOL bRet;

    if (m_bValid) {

        if (pszDeviceName) {

            if (dwAccess == BIDI_ACCESS_ADMINISTRATOR ) {
                PrinterDefault.DesiredAccess = PRINTER_ALL_ACCESS;
            }
            else if (dwAccess == BIDI_ACCESS_USER) {
                PrinterDefault.DesiredAccess = PRINTER_ACCESS_USE;
            }
            else {
                hr = E_INVALIDARG;
            }

            if (hr != E_INVALIDARG) {

                bRet = OpenPrinter ((LPWSTR)pszDeviceName, &hPrinter, &PrinterDefault);

                if (bRet) {

                    TAutoCriticalSection CritSec (m_CritSec);

                    bRet = CritSec.bValid ();
                    if (bRet) {
                        if (m_hPrinter != NULL) {
                            // Opened before

                            // Do not cache the handle, since the calling thread may
                            // impersonate different user credentials
                            //

                            hOldPrinter = m_hPrinter;
                        }

                        m_hPrinter = hPrinter;
                        hPrinter = NULL;
                        hr = S_OK;
                    }
                }

                if (hOldPrinter) {
                    ClosePrinter (hOldPrinter);
                }

                if (hPrinter) {
                    ClosePrinter (hPrinter);
                }

                if (FAILED (hr)) {
                    hr = LastError2HRESULT ();
                }
            }
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_HANDLE;

    return hr;
}

STDMETHODIMP
TBidiSpl::UnbindDevice ()
{
    HRESULT hr;
    BOOL bRet;
    HANDLE hPrinter = NULL;

    if (m_bValid) {

        {
            TAutoCriticalSection CritSec (m_CritSec);

            bRet = CritSec.bValid ();

            if (bRet) {

                if (hPrinter = m_hPrinter) {
                    m_hPrinter = NULL;
                }
                else {
                    // Nothing to unbind
                    bRet = FALSE;
                    SetLastError (ERROR_INVALID_HANDLE_STATE);
                }
            }
        }
        // Leave Critical Section

        if (hPrinter) {
            bRet = ClosePrinter (hPrinter);
        }

        if (bRet) {
            hr = S_OK;
        }
        else {
            hr = LastError2HRESULT();
        }
    }
    else
        hr = E_HANDLE;

    return hr;

}

STDMETHODIMP
TBidiSpl::SendRecv (
    IN CONST    LPCWSTR pszAction,
    IN          IBidiRequest * pRequest)
{
    IBidiRequestContainer * pIReqContainer = NULL ;
    HRESULT hr;

    hr = ValidateContext();
    if (FAILED (hr)) goto Failed;

    if (!pRequest) {
        hr = E_POINTER;
        goto Failed;
    }

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IBidiRequestContainer,
                                   (void**)&pIReqContainer) ;
    if (FAILED (hr))  goto Failed;

    hr = pIReqContainer->AddRequest (pRequest);
    if (FAILED (hr))  goto Failed;

    hr = MultiSendRecv (pszAction, pIReqContainer);
    if (FAILED (hr))  goto Failed;

Failed:

    if (pIReqContainer) {
        pIReqContainer->Release ();
    }

    return hr;

}

STDMETHODIMP
TBidiSpl::MultiSendRecv (
    IN CONST    LPCWSTR pszAction,
    IN          IBidiRequestContainer * pRequestContainer)
{

    DWORD                           dwTotal;
    DWORD                           dwRet;
    IBidiRequestContainer *         pIReqContainer = NULL;
    PBIDI_RESPONSE_CONTAINER        pResponse = NULL;
    TRequestContainer *             pReqContainer = NULL;

    HRESULT hr;


    hr = ValidateContext();
    if (FAILED (hr)) goto Failed;

    if (!pRequestContainer) {
        hr = E_POINTER;
        goto Failed;
    }


    hr = pRequestContainer->QueryInterface (
                    IID_IBidiRequestContainer,
                    (void **) & pIReqContainer);
    if (FAILED (hr)) goto Failed;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    if (FAILED (hr)) goto Failed;

    if (dwTotal == 0 && lstrcmpi (BIDI_ACTION_ENUM_SCHEMA, pszAction)) {
        // There is no request in the container
        //
        hr = E_INVALIDARG;
        DBGMSG (DBG_INFO, ("No request in an action"));
        goto Failed;
    }

    hr = ComposeRequestData (pRequestContainer, &pReqContainer);
    if (FAILED (hr)) goto Failed;

    dwRet = (*m_pfnSendRecvBidiData) (m_hPrinter,
                                      pszAction,
                                      pReqContainer->GetContainerPointer (),
                                      &pResponse);

    if (!dwRet && pResponse) {
        hr = ComposeReponseData (
                        pIReqContainer,
                        (PBIDI_RESPONSE_CONTAINER) pResponse);

        (*m_pfnRouterFreeBidiResponseContainer) (pResponse);
    }
    else
        hr = WinError2HRESULT (dwRet);

Failed:

    if (pReqContainer)
        delete pReqContainer;

    if (pIReqContainer)
        pIReqContainer ->Release ();

    return hr;
}


HRESULT
TBidiSpl::ValidateContext ()
{
    BOOL bRet;
    HRESULT hr;

    if (m_bValid) {
        TAutoCriticalSection CritSec (m_CritSec);

        bRet = CritSec.bValid ();
        if (bRet) {
            if (m_hPrinter == NULL) {
                // The application has not called BindDevice yet.
                hr =  E_HANDLE;
            }
            else
                hr = S_OK;
        }
        else
            hr = LastError2HRESULT ();
    }
    else
        hr = E_HANDLE;

    return hr;
}

HRESULT
TBidiSpl::ComposeRequestData (
    IN  IBidiRequestContainer *pIReqContainer,
    IN  TRequestContainer **ppReqContainer)
{


    DWORD   dwFetched;
    DWORD   dwSize;
    DWORD   dwTotal;
    DWORD   dwType;
    DWORD   i;
    LPWSTR  pszSchema;
    PBYTE   pData = NULL;

    IBidiRequestSpl   *     pISpl = NULL;
    IEnumUnknown      *     pEnumIunk = NULL;
    IUnknown          *     pIunk = NULL;
    TRequestContainer *     pReqContainer = NULL;

    BOOL bRet;
    HRESULT hr;

    *ppReqContainer = NULL;

    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;
    if (FAILED (hr)) goto Failed;

    hr = pIReqContainer->GetRequestCount (&dwTotal) ;
    if (FAILED (hr)) goto Failed;

    pReqContainer = new TRequestContainer (dwTotal);
    *ppReqContainer = pReqContainer;

    if (! (pReqContainer && pReqContainer->bValid ())) {
        hr = LastError2HRESULT();
        goto Failed;
    }

    for (i = 0; i < dwTotal; i++){

        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        if (FAILED (hr)) goto Failed;

        if (dwFetched != 1) {
            hr = E_INVALIDARG;
            goto Failed;
        }

        hr = pIunk->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
        if (FAILED (hr)) goto Failed;

        pIunk->Release ();
        pIunk = NULL;

        // Create the request
        hr = pISpl->GetSchema (&pszSchema);
        if (FAILED (hr)) goto Failed;

        hr = pISpl->GetInputData (&dwType, &pData, &dwSize);
        if (FAILED (hr)) goto Failed;

        bRet = pReqContainer->AddRequest (i, pszSchema, (BIDI_TYPE) dwType, pData, dwSize);

        if (!bRet) {
            hr = LastError2HRESULT();
            goto Failed;
        }

        pISpl->Release ();
        pISpl = NULL;

    }
    hr = S_OK;

Failed:

    if (pISpl)
        pISpl->Release ();

    if (pEnumIunk)
        pEnumIunk->Release ();

    if (pIunk)
        pIunk->Release();

    return hr;
}

HRESULT
TBidiSpl::SetData (
    IN  IBidiRequestSpl *pISpl,
    IN  PBIDI_RESPONSE_DATA pResponseData)
{
    HRESULT hr;

    hr = pISpl->SetResult (pResponseData->dwResult);

    if (!SUCCEEDED (hr)) {
        return hr;
    }

    PBIDI_DATA pData = & (pResponseData->data);

    switch (pData->dwBidiType) {
    case BIDI_NULL:
        break;
    case BIDI_INT:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.iData,
                                      sizeof (ULONG));
        break;
    case BIDI_BOOL:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.bData,
                                      sizeof (BOOL));
        break;
    case BIDI_FLOAT:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      (PBYTE) & pData->u.fData,
                                      sizeof (FLOAT));
        break;
    case BIDI_TEXT:
    case BIDI_ENUM:
    case BIDI_STRING:

        if (pData->u.sData)
        {
            hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                          pData->dwBidiType,
                                          (PBYTE) pData->u.sData,
                                          sizeof (WCHAR) * (lstrlen (pData->u.sData) + 1));
        }
        else
        {
            hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                          pData->dwBidiType,
                                          NULL, 
                                          0);
        }

        break;
    case BIDI_BLOB:
        hr = pISpl->AppendOutputData (pResponseData->pSchema,
                                      pData->dwBidiType,
                                      pData->u.biData.pData,
                                      pData->u.biData.cbBuf);
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;

}



HRESULT
TBidiSpl::ComposeReponseData (
    IN  IBidiRequestContainer *pIReqContainer,
    IN  PBIDI_RESPONSE_CONTAINER pResponse)
{

    HRESULT hr;
    IEnumUnknown* pEnumIunk = NULL;

    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    if (SUCCEEDED (hr)) {

        hr = pEnumIunk->Reset ();

        if (SUCCEEDED (hr)) {

            DWORD dwReqIndex = 0;
            BOOL bGotInterface = FALSE;;


            for (DWORD i = 0; i < pResponse->Count; i++) {

                PBIDI_RESPONSE_DATA pResponseData = & (pResponse->aData[i]);

                // Locate the request
                if (dwReqIndex <= pResponse->aData[i].dwReqNumber) {
                    hr = pEnumIunk->Skip (pResponse->aData[i].dwReqNumber - dwReqIndex);
                    dwReqIndex = pResponse->aData[i].dwReqNumber;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    bGotInterface = FALSE;

                }
                else if (dwReqIndex > pResponse->aData[i].dwReqNumber) {
                    hr = pEnumIunk->Reset ();

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    hr = pEnumIunk->Skip (pResponse->aData[i].dwReqNumber);
                    dwReqIndex = pResponse->aData[i].dwReqNumber;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    bGotInterface = FALSE;
                }

                IUnknown *pIunk = NULL;

                if (!bGotInterface) {
                    DWORD dwFetched;

                    hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);
                    dwReqIndex++;

                    if (FAILED (hr)) {
                        goto Failed;
                    }

                    if (dwFetched != 1) {
                        hr = E_INVALIDARG;
                        goto Failed;
                    }

                    bGotInterface = TRUE;
                }

                IBidiRequestSpl *pISpl;

                hr = pIunk->QueryInterface (IID_IBidiRequestSpl,
                                                   (void **) & pISpl);
                pIunk->Release();

                if (SUCCEEDED (hr)) {
                    hr = SetData (pISpl, pResponseData);
                    pISpl->Release ();
                }
            }
        }
    }

Failed:

    if (pEnumIunk)
        pEnumIunk->Release ();

    return hr;
}

TBidiSpl::TRequestContainer::TRequestContainer (
    DWORD dwCount):
    m_bValid (FALSE)
{
    DWORD dwSize = sizeof (BIDI_REQUEST_CONTAINER) + (dwCount - 1) * sizeof (BIDI_REQUEST_DATA);
    m_pContainer = (PBIDI_REQUEST_CONTAINER) new BYTE [dwSize];

    if (m_pContainer) {

        ZeroMemory (m_pContainer, dwSize);

        m_pContainer->Version = 1;
        m_pContainer->Count = dwCount;
        m_bValid = TRUE;
    }
}

TBidiSpl::TRequestContainer::~TRequestContainer ()
{
    if (m_pContainer) {
        PBIDI_DATA pBidiData;


        for (DWORD i = 0; i < m_pContainer->Count; i++) {

            pBidiData = & (m_pContainer->aData[i].data);

            switch (pBidiData->dwBidiType) {
            case BIDI_STRING:
            case BIDI_TEXT:
            case BIDI_ENUM:
                if (pBidiData->u.sData)
                    CoTaskMemFree (pBidiData->u.sData);
                break;
            case BIDI_BLOB:
                if (pBidiData->u.biData.pData) {
                    CoTaskMemFree (pBidiData->u.biData.pData);
                }
                break;
            default:
                break;
            }
        }

        delete [] m_pContainer;
    }
}

BOOL
TBidiSpl::TRequestContainer::AddRequest (
    IN  CONST   DWORD       dwIndex,
    IN  CONST   LPCWSTR     pszSchema,
    IN  CONST   BIDI_TYPE   dwDataType,
    IN          PBYTE       pData,
    IN  CONST   DWORD       dwSize)
{
    BOOL bRet (FALSE);
    BOOL bFreeData;

    if (m_pContainer) {
        PBIDI_DATA pBidiData;
        bFreeData = TRUE;

        m_pContainer->aData[dwIndex].dwReqNumber = dwIndex;
        m_pContainer->aData[dwIndex].pSchema = (LPWSTR) pszSchema;
        m_pContainer->aData[dwIndex].data.dwBidiType = dwDataType;
        pBidiData = & (m_pContainer->aData[dwIndex].data);

        switch (pBidiData->dwBidiType) {
        case BIDI_NULL:
            bRet = TRUE;
            break;

        case BIDI_BOOL:
            bRet = dwSize == BIDI_BOOL_SIZE;

            if(bRet) {
                pBidiData->u.iData = *(PBOOL)pData;
            }

            break;

        case BIDI_INT:
            bRet = dwSize == BIDI_INT_SIZE;

            if (bRet) {
                pBidiData->u.iData = *(PINT)pData;
               bRet = TRUE;
            }
            break;

        case BIDI_FLOAT:

            bRet = dwSize == BIDI_FLOAT_SIZE;

            if (bRet) {
                pBidiData->u.iData = *(PINT)pData;
            }
            break;

        case BIDI_STRING:
        case BIDI_TEXT:
        case BIDI_ENUM:
            pBidiData->u.sData =  (LPWSTR) pData;
            bFreeData = FALSE;
            bRet = TRUE;
            break;

        case BIDI_BLOB:
            pBidiData->u.biData.pData = pData;
            pBidiData->u.biData.cbBuf = dwSize;
            bFreeData = FALSE;
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
        }

        if (pData && bFreeData) {
            CoTaskMemFree (pData);
        }
    }

    if (!bRet) {
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\request.h ===
/*****************************************************************************\
* MODULE:       request.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/07/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDIREQUEST
#define _TBIDIREQUEST

#include "priv.h"

class TBidiRequest : public IBidiRequestSpl
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID  iid,
        void**  ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release)() ;
    
    STDMETHOD (SetSchema) ( 
        IN  CONST   LPCWSTR pszSchema);
        
    STDMETHOD (SetInputData) ( 
        IN  CONST   DWORD   dwType,
        IN  CONST   BYTE    *pData,
        IN  CONST   UINT    uSize);
        
    STDMETHOD (GetResult) ( 
        OUT         HRESULT *phr);
        
    STDMETHOD (GetOutputData) ( 
        IN  CONST   DWORD   dwIndex,
        OUT         LPWSTR  *ppszSchema,
        OUT         PDWORD  pdwType,
        OUT         PBYTE   *ppData,
        OUT         PULONG  uSize);
        
    STDMETHOD (GetEnumCount)(
        OUT         PDWORD  pdwTotal);
    
    STDMETHOD (GetSchema) (
        OUT         LPWSTR  *ppszSchema);

    STDMETHOD (GetInputData)  (
        OUT         PDWORD  pdwType,
        OUT         PBYTE   *ppData,
        OUT         PULONG  puSize);
                
    STDMETHOD (SetResult) (
        IN  CONST   HRESULT hr);

    STDMETHOD (AppendOutputData) (
        IN  CONST   LPCWSTR pszSchema,
        IN  CONST   DWORD   dwType, 
        IN  CONST   BYTE    *pData,
        IN  CONST   ULONG   uSize);
    
    // Constructor
	TBidiRequest() ;

    // Destructor
    ~TBidiRequest() ;
    
    inline BOOL 
    bValid() CONST {return m_bValid;};

private:
	// Reference count
    BOOL                m_bValid;
    LONG                m_cRef ;
    LPWSTR              m_pSchema;
    BIDI_TYPE           m_kDataType;
    DWORD               m_dwDataSize;
    PBYTE               m_pbData;
    DWORD               m_dwResponseCount;
    HRESULT             m_hr;
    TCriticalSection    m_CritSec;
    TResponseDataList   m_ResponseDataList;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\valid.h ===
/*****************************************************************************\
* Class  CValid - Header file
*
* Copyright (C) 1998 Microsoft Corporation
*
* Author:
*   Weihai Chen (weihaic) May 24, 1999
*
\*****************************************************************************/

#ifndef _VALID_H
#define _VALID_H

class TValid
{
public:
    TValid (BOOL bValid = TRUE):m_bValid(bValid) {};

    virtual ~TValid (void) {};

    const BOOL bValid () const {return m_bValid;};

protected:
    BOOL m_bValid;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\bidiutil\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>
#include "wingdip.h"

#include <wininet.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\splapi.h ===
/*****************************************************************************\
* MODULE:       splapi.h
*
* PURPOSE:      Implementation of COM interface for BidiSpooler
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     03/09/00  Weihai Chen (weihaic) Created
*
\*****************************************************************************/

#ifndef _TBIDISPL
#define _TBIDISPL

#include "priv.h"

class TBidiSpl : public IBidiSpl
{
public:
	// IUnknown
	STDMETHOD (QueryInterface) (
        REFIID iid, 
        void** ppv) ;
    
	STDMETHOD_ (ULONG, AddRef) () ;
    
	STDMETHOD_ (ULONG, Release) () ;
    
    STDMETHOD (BindDevice) (
        IN  CONST   LPCWSTR pszDeviceName,
        IN  CONST   DWORD dwAccess);
    
    STDMETHOD (UnbindDevice) ();
    
    STDMETHOD (SendRecv) (
        IN  CONST   LPCWSTR pszAction,
        IN          IBidiRequest * pRequest);
    
    STDMETHOD (MultiSendRecv) (
        IN  CONST   LPCWSTR pszAction,
        IN          IBidiRequestContainer * pRequestContainer);


    // Constructor
	TBidiSpl() ;

	// Destructor
	~TBidiSpl();
    
    inline BOOL bValid() CONST {return m_bValid;} ;

private:
    
    class TRequestContainer {
    public:
        TRequestContainer (
            CONST DWORD dwCount);

        ~TRequestContainer ();

        BOOL    
        AddRequest (
            IN  CONST   DWORD       dwIndex,
            IN  CONST   LPCWSTR     pszSchema,
            IN  CONST   BIDI_TYPE   dwDataType,
            IN          PBYTE       pData,
            IN  CONST   DWORD       dwSize);

        inline PBIDI_REQUEST_CONTAINER
        GetContainerPointer () CONST {return m_pContainer;};

        inline BOOL
        bValid () CONST {return m_bValid;};

    private:
        PBIDI_REQUEST_CONTAINER     m_pContainer;
        BOOL                        m_bValid;
    };

    typedef DWORD (*PFN_ROUTERFREEBIDIRESPONSECONTAINER) (
                    PBIDI_RESPONSE_CONTAINER pData);

    typedef DWORD (*PFN_SENDRECVBIDIDATA) (
                    IN  HANDLE                    hPrinter,
                    IN  LPCTSTR                   pAction,
                    IN  PBIDI_REQUEST_CONTAINER   pReqData,
                    OUT PBIDI_RESPONSE_CONTAINER* ppResData);

    HRESULT 
    ValidateContext ();
    
    HRESULT
    ComposeRequestData (
        IN  IBidiRequestContainer *pIReqContainer,
        OUT TRequestContainer **ppReqContainer);

    HRESULT
    SetData (
        IN  IBidiRequestSpl *pISpl,
        IN  PBIDI_RESPONSE_DATA pResponseData);

    HRESULT
    ComposeReponseData (
        IN  IBidiRequestContainer *pIReqContainerSpl,
        IN  PBIDI_RESPONSE_CONTAINER pResponse);


    BOOL                m_bValid;
    LONG                m_cRef;
    TCriticalSection    m_CritSec;
    HANDLE              m_hPrinter;
    
    PFN_SENDRECVBIDIDATA m_pfnSendRecvBidiData;
    PFN_ROUTERFREEBIDIRESPONSECONTAINER m_pfnRouterFreeBidiResponseContainer;
    

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\stress\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>
#include "wingdip.h"

#include <wininet.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\stress\biditest.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"
#include "bidispl.h"

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#ifndef MODULE

#define MODULE "BIDITEST:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}


DWORD gdwCount;
IBidiRequest ** gpIRequestArray;
DWORD gdwContainerCount;
IBidiRequestContainer ** gpIRequestContainerArray;
DWORD gdwSplCount;
IBidiSpl ** gpIBidiSplArray;
DWORD gdwMainLoopCount;
DWORD gdwLoopCount;
LPWSTR gpPrinterName;
LONG gdwRef;
HANDLE ghEvent;

VOID
CreateRequest (DWORD dwCount)
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
    typedef IBidiRequest * PIBidiRequest;

    gdwCount = dwCount;
    gpIRequestArray = new PIBidiRequest[gdwCount];
	
    for (DWORD i  = 0; i < gdwCount; i++) {
        hr = ::CoCreateInstance(CLSID_BidiRequest,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiRequest,
                                (void**)&pIReq) ;
       gpIRequestArray [i] = pIReq;
    }
}


VOID
ReleaseRequest ()
{
    for (DWORD i  = 0; i < gdwCount; i++) {
       DWORD dwRef = gpIRequestArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }

}

VOID
CreateContainer (DWORD dwContainerCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
    typedef IBidiRequestContainer * PIBidiRequestContainer;

    gdwContainerCount = dwContainerCount;
    gpIRequestContainerArray = new PIBidiRequestContainer[dwContainerCount];
	
    for (DWORD i  = 0; i < dwContainerCount; i++) {

        hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiRequestContainer,
                                (void**)&pIReqContainer) ;

        gpIRequestContainerArray [i] = pIReqContainer;
    }
}

VOID
ReleaseContainer ()
{
    for (DWORD i = 0; i < gdwContainerCount; i++) {
       DWORD dwRef = gpIRequestContainerArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }

}


VOID
CreateSpl (DWORD dwCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    typedef IBidiSpl * PIBidiSpl;

    gdwSplCount = dwCount;
    gpIBidiSplArray = new PIBidiSpl[dwCount];
	
    for (DWORD i  = 0; i < dwCount; i++) {

        hr = ::CoCreateInstance(CLSID_BidiSpl,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IBidiSpl,
                                (void**)&pIBidiSpl) ;
        gpIBidiSplArray[i] = pIBidiSpl;
    }
}

VOID
ReleaseSpl ()
{
    for (DWORD i  = 0; i < gdwSplCount; i++) {

       DWORD dwRef = gpIBidiSplArray [i]->Release ();

       SPLASSERT (dwRef == 0);
       if (dwRef != 0) {
           printf("ReleaseRequest: Ref count not zero!\n");
       }
    }
}




VOID
FillInRequest (DWORD dwIndex)
{
  	IBidiRequest * pIReq = gpIRequestArray[dwIndex];
    DWORD dwValidSize;
    HRESULT hr;
    BIDI_TYPE dwBidiType;

#define BIDI_SCHEMA_DUPLEX          L"/Printer/Installableoption/Duplexunit"
#define BIDI_SCHEMA_MULTICHANNEL    L"/Capability/MultiChannel"
#define BIDI_SCHEMA_VERSION         L"/Communication/Version"
#define BIDI_SCHEMA_BIDIPROTOCOL    L"/Communication/BidiProtocol"
#define BIDI_SCHEMA_INK_LEVEL       L"/Printer/BlackInk1/Level"
#define BIDI_SCHEMA_ALERTS          L"/Printer/Alerts"

    static PWSTR pSchemaArray[] = {
         BIDI_SCHEMA_DUPLEX,
         BIDI_SCHEMA_MULTICHANNEL,
         BIDI_SCHEMA_VERSION,
         BIDI_SCHEMA_BIDIPROTOCOL,
         BIDI_SCHEMA_INK_LEVEL,
         BIDI_SCHEMA_ALERTS
    };

    if (pIReq) {

        hr = pIReq->SetSchema (pSchemaArray[rand() %( sizeof (pSchemaArray) / sizeof (pSchemaArray[0]))]);

        dwBidiType = (BIDI_TYPE) (rand() % 7);
        switch (dwBidiType) {
        case BIDI_NULL:
            dwValidSize = 0;
            break;
        case BIDI_INT:
            dwValidSize = sizeof (INT);
            break;
        case BIDI_FLOAT:
            dwValidSize = sizeof (FLOAT);
            break;
        case BIDI_BOOL:
            dwValidSize = sizeof (BOOL);
            break;
        default:
            dwValidSize = rand () %(1024*1024);
            break;
        }

        PBYTE pByte = new BYTE [dwValidSize];

        hr = pIReq->SetInputData (dwBidiType, pByte, dwValidSize);
	}
}

VOID
FillInContainer (DWORD dwIndex)
{
    IBidiRequestContainer * pIReqContainer = gpIRequestContainerArray[dwIndex];

    if (pIReqContainer) {

        DWORD dwRequestCount = rand () % gdwCount;
        for (DWORD i = 0; i < dwRequestCount; i++) {
            HRESULT hr = pIReqContainer->AddRequest (gpIRequestArray[i]);
        }
    }
}



VOID
AccessRequest (IBidiRequest *pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData = NULL;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    if (pIRequest) {
        hr = pIRequest->GetResult (&hResult);
        hr = pIRequest->GetEnumCount (&dwTotal);

        for (i = 0; i < dwTotal; i++) {
            hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);

            if (pszSchema) {
                CoTaskMemFree (pszSchema);
            }

            if (pData) {
                CoTaskMemFree (pData);
            }
        }
    }
}

VOID
AccessRequest (DWORD dwIndex)
{
    IBidiRequest *pIRequest =  gpIRequestArray[dwIndex];

    AccessRequest (pIRequest);

}

VOID
AccessContainer (IBidiRequestContainer * pIReqContainer)
{
    DWORD dwTotal;

    DBGMSG (DBG_TRACE, ("Enter AccessContainer\n"));

    if (pIReqContainer) {

        HRESULT hr = pIReqContainer->GetRequestCount (&dwTotal);

        if (dwTotal > 0) {
            IEnumUnknown *pEnumIunk;
            IEnumUnknown *pEnumIunk2;
            hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

            if (pEnumIunk) {

                IUnknown ** pIunkArray;

                if ((rand()%2) == 1) {
                    hr = pEnumIunk->Reset ();
                }
                else {
                    hr = pEnumIunk->Clone (&pEnumIunk2);
                    pEnumIunk->Release ();
                    pEnumIunk = pEnumIunk2;
                }

                DWORD dwEnumIndex = 0;
                pIunkArray = new IUnknown* [dwTotal];

                while (dwEnumIndex < dwTotal + 2) {

                    IUnknown *pIunk;
                    DWORD dwFetched;

                    DWORD dwEnumCount = rand() % (dwTotal + 1);

                    hr = pEnumIunk->Next (dwEnumCount, pIunkArray, &dwFetched);

                    if (SUCCEEDED (hr)) {

                        for (DWORD i = 0; i < dwFetched; i++) {
                            IBidiRequest *pIRequest = NULL;

                            hr = pIunkArray[i]->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
                            pIunkArray[i]->Release ();
                            AccessRequest (pIRequest);
                            pIRequest->Release ();

                        }
                        dwEnumIndex +=dwEnumCount;
                    }
                    else
                        break;
                }
                pEnumIunk->Release ();
                delete [] pIunkArray;
            }
        }
    }
    DBGMSG (DBG_TRACE, ("Leave AccessContainer\n"));
}

VOID
AccessContainer (DWORD dwIndex)
{
    IBidiRequestContainer * pIReqContainer = gpIRequestContainerArray[dwIndex];

    AccessContainer (pIReqContainer);

}

VOID
AccessBidiSpl (IBidiSpl * pIBidiSpl, PWSTR pPrinterName, DWORD dwCount)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer *pIReqContainer;

    // Test Open/Close
    //hr = pIBidiSpl->BindDevice (L"No such Printer", 0);

    hr = pIBidiSpl->BindDevice (pPrinterName, BIDI_ACCESS_USER);

    for (DWORD i = 0; i < dwCount; i++) {
        DWORD dwContainerIndex = rand() % gdwContainerCount;

        DBGMSG (DBG_INFO, ("Before MultiSendRecv ... "));
        hr = pIBidiSpl->MultiSendRecv (BIDI_ACTION_GET, gpIRequestContainerArray[dwContainerIndex]);
        DBGMSG (DBG_INFO, ("MultiSendRecv hr=0x%x\n", hr))
        AccessContainer (dwContainerIndex);

    }

    hr = pIBidiSpl->UnbindDevice ();

}


VOID StartTestThread (void)
{
    DWORD i;

    printf("New Thrread ..\n");

    for (DWORD i = 0; i < gdwMainLoopCount; i++) {
        DWORD dwSplIndex = rand () % (gdwSplCount - 1);
        AccessBidiSpl (gpIBidiSplArray[dwSplIndex], gpPrinterName, rand()%gdwLoopCount);
    }

    DWORD dwRef = InterlockedDecrement (&gdwRef);
    if (dwRef == 0) {
        SetEvent (ghEvent);
    }

    printf("Quit Thrread (dwRef = %d)\n", dwRef);
}

VOID
StartTest (DWORD dwThreadCount)
{
    for (DWORD i = 0; i < dwThreadCount; i++) {
        CreateThread (NULL, 16*4096, (LPTHREAD_START_ROUTINE ) StartTestThread, NULL,NULL, NULL);
    }
}

void usage()
{
    printf("\n"
           "usage: biditest [-p pname] [-t n] [-m n] [-l n] [-r n] [-c n] [-s n]\n"
           "\n"
           "where:   -p printer name\n"
           "         -t Thread Number (default = 1) \n"
           "         -m Main loop count (default = 10)\n"
           "         -l Loop count (default = 10)\n"
           "         -r Request count (default = 100)\n"
           "         -c Container count (default = 100)\n"
           "         -s Spooler Bidi  count (default = 10)\n"
           );
    exit (0);
}

extern "C"
INT
_cdecl
_tmain(
    int argc,
    TCHAR **argv)
{
    DWORD dwReqCount = 100;
    DWORD dwContainerCount = 100;
    DWORD dwSplCount = 20;
    DWORD dwMainLoopCount = 10;
    DWORD dwLoopCount = 10;
    WCHAR szName [] = L"Test";
    PWSTR pPrinterName = szName;
    DWORD dwThreadCount = 1;

    HRESULT hr;

    for (--argc, ++argv; argc; --argc, ++argv) {

        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case L'?':
                usage();
                break;

            case L'p':
                ++argv;
                --argc;
                pPrinterName = *argv;
                break;

            case L't':
                ++argv;
                --argc;
                dwThreadCount = _ttol (*argv);
                break;

            case L'm':
                ++argv;
                --argc;
                dwMainLoopCount = _ttol (*argv);
                break;

            case L'l':
                ++argv;
                --argc;
                dwLoopCount = _ttol (*argv);
                break;

            case L'r':
                ++argv;
                --argc;
                dwReqCount = _ttol (*argv);
                break;

            case L'c':
                ++argv;
                --argc;
                dwContainerCount = _ttol (*argv);
                break;

            case L's':
                ++argv;
                --argc;
                dwSplCount = _ttol (*argv);
                break;

            default:
                usage();
                break;
            }
        }
        else {
            printf("Invalid Argument %s\n", *argv);
            exit (1);
        }
    }

    printf("Start Test ..\n");
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;

    gdwMainLoopCount = dwMainLoopCount;
    gdwLoopCount =  dwLoopCount;
    gpPrinterName =  pPrinterName;
    ghEvent = CreateEvent (NULL, NULL, FALSE, NULL);

    for (;;) {
        printf("Create Components ..\n");
        CreateRequest (dwReqCount);
        CreateContainer ( dwContainerCount);
        CreateSpl (dwSplCount);

        printf("Fill in data ..\n");

        for (DWORD i = 0; i < dwReqCount; i++) {
            FillInRequest (i);
        }

        for (i = 0; i < dwContainerCount; i++) {
            FillInContainer (i);
        }

        printf("Test ..\n");


        gdwRef = dwThreadCount;

        StartTest (dwThreadCount);

        WaitForSingleObject (ghEvent, INFINITE);
        ResetEvent (ghEvent);

        printf("Cleanup ..\n");


        ReleaseSpl();
        ReleaseContainer();
        ReleaseRequest();
    }
	
    CoUninitialize() ;
    printf("Test successfully finished!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\bidiutil\bidiutil.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"
#include "tchar.h"
#include "bidispl.h"

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#ifndef MODULE

#define MODULE "BIDIUTIL:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}

void DumpData (DWORD dwType, PBYTE pData, DWORD dwSize)
{

    DBGMSG (DBG_INFO, ("dwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize)) ;

    DWORD col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    for (DWORD i = 0; i < dwSize; i++) {

        sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
        if ((col ++) % 16 == 15) {
            DBGMSG (DBG_INFO, ("%s\n", szBuf));
            szBuf[0] = 0;
        }
    }
    DBGMSG (DBG_INFO, ("%s\n", szBuf));
}

void DumpOutputData (DWORD dwType, PBYTE pData, DWORD dwSize)
{
    DWORD i, col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    printf ("\tdwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize);

    switch (dwType) {
    case BIDI_NULL:
        printf("\tBIDI_NULL\n");
        break;
    case BIDI_INT:
        printf 	("\tBIDI_INT = %d\n", *(INT*)pData);
        break;
    case BIDI_FLOAT:
        printf 	("\tBIDI_FLOAT = %f\n", *(FLOAT*)pData);
        break;
    case BIDI_BOOL:
        printf 	("\tBIDI_BOOL = %s\n", (*(BOOL*)pData)?"TRUE":"FALSE");
        break;
    case BIDI_ENUM:
    case BIDI_TEXT:
    case BIDI_STRING:
        printf 	("\tBIDI_STRING = |%ws|\n", pData);
        break;
    case BIDI_BLOB:
        printf 	("\tBIDI_BLOB\n", pData);

        for (i = 0; i < dwSize; i++) {

            sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
            if ((col ++) % 16 == 15) {
                printf ("%s\n", szBuf);
                szBuf[0] = 0;
            }
        }
        printf ("%s\n", szBuf);
    default:
        printf 	("\tunsupported\n", pData);
    }


}


void DumpRequest (IBidiRequest * pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    hr = pIRequest->GetResult (&hResult);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIRequest->GetEnumCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    printf("hr = %x; total response = %d\n", hResult, dwTotal);

    for (i = 0; i < dwTotal; i++) {
        hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);
        printf("%d: %ws\n", i, (pszSchema)?pszSchema:L"");
        DumpOutputData (dwType, pData, uSize);
    }

}

void DumpContainer (IBidiRequestContainer * pIReqContainer)
{
    IBidiRequest * pRequest = NULL;
    DWORD dwRef, i;
    DWORD dwTotal;
    HRESULT hr;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequest *pIRequest = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
        SPLASSERT (SUCCEEDED (hr));

        printf("Request No.%d\n", i);

        DumpRequest (pIRequest);

        dwRef = pIunk->Release();
        dwRef = pIRequest->Release();
    }

    pEnumIunk->Release ();
}


IBidiRequest *  GenRequest (LPWSTR pSchema)
{
    HRESULT hr;
	
    IUnknown * pIUnk = NULL ;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IUnknown,
                            (void**)&pIUnk) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    hr = pIUnk->QueryInterface (IID_IBidiRequest, (void **)&pIReq);

    pIUnk->Release();

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("QueryInterface\n"));
        exit (0);
    }

    if (pSchema) {
        hr = pIReq->SetSchema (pSchema);
        if (FAILED (hr)) {
            DBGMSG (DBG_WARNING, ("SetSchema\n"));
            exit (0);
        }
    }
    return pIReq;
}


IBidiRequestContainer *CreateContainer ()
{
    HRESULT hr;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    return pIReqContainer;
}

void AddRequest (
    IBidiRequestContainer * pIReqContainer,
    LPWSTR pSchema)
{
    IBidiRequest * pRequest = NULL;
    HRESULT hr;
    DWORD dwRef;

    pRequest = GenRequest (pSchema);
    if (!pRequest) {
        DBGMSG (DBG_WARNING, ("GenRequest\n"));
        exit (0);
    }

    hr = pIReqContainer->AddRequest (pRequest);
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("AddRequest\n"));
        exit (0);
    }

    dwRef = pRequest->Release ();

}

void usage()
{
    printf("\n"
           "usage: bidiutil [-p pname] [-t] [-d] [-a action] [-s schema1 schema2 schema3 ... ] \n"
           "\n"
           "where:   -p printer name\n"
           "         -t SendRecv (default: MultiSendRecv)\n"
           "         -d admin (default: User) \n"
           "         -a action e.g. Enum, Get, GetAll) \n"
           "         -s schema e.g. /printer/installalableoption/duplexunit\n");
    exit (0);
}

extern "C"
INT
_cdecl
_tmain(
    int argc,
    TCHAR **argv)
{


    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;
    IBidiRequest * pRequest = NULL;
    LPTSTR pPrinter = NULL;
    LPTSTR pAction = NULL;;
    BOOL bLoop = TRUE;
    BOOL bSingle = FALSE;
    BOOL dwAccess = BIDI_ACCESS_USER;

    for (--argc, ++argv; argc && bLoop; --argc, ++argv) {

        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case L'?':
                usage();
                break;

            case L'p':
                ++argv;
                --argc;
                pPrinter = *argv;
                break;

            case L's':
                bLoop = FALSE;
                break;

            case L'a':
                ++argv;
                --argc;
                pAction = *argv;
                break;

            case L't':
                bSingle = TRUE;
                break;

            case L'd':
                dwAccess = BIDI_ACCESS_ADMINISTRATOR;
                break;

            default:
                usage();
                break;
            }
        }
        else {
            printf("Invalid Argument %s\n", *argv);
            exit (1);
        }
    }
    if (!pAction || !pPrinter) {
        usage ();
    }


    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoInitilaizeEx\n"));
        exit (0);
    }

    hr = CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("CoCreateInstance\n"));
        exit (0);
    }

    hr = pIBidiSpl->BindDevice (pPrinter, dwAccess);
    if (FAILED (hr)) {
        DBGMSG (DBG_WARNING, ("BindDevice\n"));
        exit (0);
    }

    if (bSingle) {

        if (argc > 0)
            pRequest = GenRequest (*argv);
        else
            pRequest = GenRequest (NULL);

        hr = pIBidiSpl->SendRecv (pAction, pRequest);
        if (FAILED (hr)) {
            printf  ("SendRecv failed (0x%x)\n", hr);
            exit (0);
        }

        DumpRequest (pRequest);
        dwRef =  pRequest->Release ();

    }
    else {
        pIReqContainer = CreateContainer ();

        if (argc > 0) {
            while (argc-- > 0)
                AddRequest (pIReqContainer, *argv++);
        }
        else
            AddRequest (pIReqContainer, NULL);


        hr = pIBidiSpl->MultiSendRecv (pAction, pIReqContainer);
        if (FAILED (hr)) {
            printf  ("MultiSendRecv failed (0x%x)\n", hr);
            exit (0);
        }

        DumpContainer (pIReqContainer);

        dwRef = pIReqContainer->Release ();
    }

    dwRef = pIBidiSpl->Release ();

    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\test\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  7-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#define MODULE "BIDISPL:"
#define MODULE_DEBUG BidiSplDebug

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
//#include "winspl.h"
//#include <offsets.h>
#include <change.h>
#include <windows.h>
#include <winddiui.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <objbase.h>
#include "spllib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\bidispl\clients\test\client.cpp ===
//
// Client.cpp - client implementation
//
#include "precomp.h"

#include "bidispl.h"
#include "bidisplp.h"

#ifndef MODULE

#define MODULE "BIDITST:"

#endif

#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE | DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING | DBG_TRACE, DBG_ERROR );

#endif

VOID DbgBreakPoint (VOID)
{
}

void DumpData (DWORD dwType, PBYTE pData, DWORD dwSize)
{

    DBGMSG (DBG_INFO, ("dwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize)) ;

    DWORD col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    for (DWORD i = 0; i < dwSize; i++) {

        sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
        if ((col ++) % 16 == 15) {
            DBGMSG (DBG_INFO, ("%s\n", szBuf));
            szBuf[0] = 0;
        }
    }
    DBGMSG (DBG_INFO, ("%s\n", szBuf));
}

void DumpOutputData (DWORD dwType, PBYTE pData, DWORD dwSize)
{
    DWORD i, col = 0;
    CHAR szBuf[512];
    szBuf[0] = 0;

    printf ("\tdwType = %d, pData = %x, dwSize = %d\n", dwType, pData, dwSize);

    switch (dwType) {
    case BIDI_NULL:
        printf("\tBIDI_NULL\n");
        break;
    case BIDI_INT:
        printf 	("\tBIDI_INT = %d\n", *(INT*)pData);
        break;
    case BIDI_FLOAT:
        printf 	("\tBIDI_FLOAT = %f\n", *(FLOAT*)pData);
        break;
    case BIDI_BOOL:
        printf 	("\tBIDI_BOOL = %d\n", *(BOOL*)pData);
        break;
    case BIDI_ENUM:
    case BIDI_TEXT:
    case BIDI_STRING:
        printf 	("\tBIDI_STRING = |%ws|\n", pData);
        break;
    case BIDI_BLOB:
        printf 	("\tBIDI_BLOB\n", pData);

        for (i = 0; i < dwSize; i++) {

            sprintf (szBuf + strlen (szBuf), "%02x ", pData[i]);
            if ((col ++) % 16 == 15) {
                printf ("%s\n", szBuf);
                szBuf[0] = 0;
            }
        }
        printf ("%s\n", szBuf);
    default:
        printf 	("\tunsupported\n", pData);
    }


}


void DumpRequest (IBidiRequest * pIRequest)
{
    DWORD dwTotoal, i;
    HRESULT hr, hResult;
    LPWSTR pszSchema = NULL;
    BYTE *pData;
    DWORD uSize;
    DWORD dwType;
    DWORD dwTotal;

    hr = pIRequest->GetResult (&hResult);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIRequest->GetEnumCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    printf("hr = %x; total = %d\n", hResult, dwTotal);

    for (i = 0; i < dwTotal; i++) {
        hr =  pIRequest->GetOutputData  (i, &pszSchema, &dwType, &pData, &uSize);
        printf("%d: %ws\n", i, (pszSchema)?pszSchema:L"");
        DumpOutputData (dwType, pData, uSize);
    }

}

void DumpContainer (IBidiRequestContainer * pIReqContainer)
{
    IBidiRequest * pRequest = NULL;
    DWORD dwRef, i;
    DWORD dwTotal;
    HRESULT hr;

    hr = pIReqContainer->GetRequestCount (&dwTotal);
    SPLASSERT (SUCCEEDED (hr));

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequest *pIRequest = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequest, (void **) & pIRequest);
        SPLASSERT (SUCCEEDED (hr));

        DumpRequest (pIRequest);

        dwRef = pIunk->Release();
        dwRef = pIRequest->Release();
    }

    pEnumIunk->Release ();
}

void TestBidiRequest ()
{
    HRESULT hr;
	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	if (SUCCEEDED(hr))
	{

        hr = pIReq->SetSchema (L"/printer/duplex");
        DBGMSG (DBG_TRACE, ("SetSchema hr = %x\n", hr));

        DWORD dwData = 30;
        DumpData (1, (PBYTE) &dwData, sizeof (DWORD));
        hr = pIReq->SetInputData (1, (LPBYTE) &dwData, sizeof (DWORD));
        DBGMSG (DBG_TRACE, ("SetInputData hr = 0x%x\n", hr));


        IBidiRequestSpl *pISpl = NULL;
        hr = pIReq->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
    	if (SUCCEEDED(hr))
	    {
            LPWSTR pSchema;

            DBGMSG (DBG_TRACE, ("Calling GetSchema\n"));
            hr = pISpl->GetSchema ( & pSchema);
            DBGMSG (DBG_TRACE, ("GetSchema hr=%x, %ws\n", hr, pSchema));


            hr = pISpl->SetResult (0x30);
            DBGMSG (DBG_TRACE, ("SetResult hr=%x\n", hr, pSchema));

            DWORD dwTotal = 2;
            for (DWORD i = 0; i <dwTotal; i++ ) {
                WCHAR szSchema[512];
                DWORD dwType;
                BYTE pData[512];
                ULONG uSize;

                for (int j = 0; j < rand() % 512 - 1; j++) {
                    szSchema[j] = L'0';
                }

                dwType = BIDI_BLOB;
                uSize = rand () % 512;
                for (j = 0; j < (int) uSize; j++) {
                    pData[j] = (BYTE) (j+i) ;
                }

                hr = pISpl->AppendOutputData (szSchema, dwType, pData, uSize);
                DumpData (dwType, pData, uSize);

                DBGMSG (DBG_TRACE, ("AppendOutputData hr = 0x%x\n", hr));
            }

        }

        HRESULT hrResult;
        hr = pIReq->GetResult (&hrResult);
        DBGMSG (DBG_TRACE, ("GetResult hr = 0x%x, Result=0x%x\n", hr, hrResult));
		
        DWORD dwTotal;
        hr = pIReq->GetEnumCount (&dwTotal);
        DBGMSG (DBG_TRACE, ("GetEnumCount hr = 0x%x, Result=%d\n", hr, dwTotal));

        for (DWORD i = 0; i <dwTotal; i++ ) {
            LPWSTR pSchema;
            DWORD dwType;
            LPBYTE pData;
            ULONG uSize;

            hr = pIReq->GetOutputData (i, &pSchema, &dwType, &pData, &uSize);
            DBGMSG (DBG_TRACE, ("GetOutputData hr = 0x%x, dwType=%d, dwSize=%d\n", hr, dwType, uSize));

            DumpData (dwType, pData, uSize);
        }


        DBGMSG (DBG_TRACE, ("Release IBididRequestSpl interface.\n")) ;
		pIReq->Release() ;

		DBGMSG (DBG_TRACE, ("Release IBididRequest interface.\n")) ;
		pISpl->Release() ;
	}
	else
	{
		DBGMSG (DBG_TRACE, ("Client: \t\tCould not create component. hr = %x\n ", hr));
	}
}



IBidiRequest *  GenRequest ()
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	if (SUCCEEDED(hr))
	{

        hr = pIReq->SetSchema (L"/printer/duplex");
        DBGMSG (DBG_TRACE, ("SetSchema hr = %x\n", hr));

        DWORD dwData = rand() % 1000;
        DumpData (1, (PBYTE) &dwData, sizeof (DWORD));
        hr = pIReq->SetInputData (BIDI_INT, (LPBYTE) &dwData, sizeof (DWORD));
        DBGMSG (DBG_TRACE, ("SetInputData hr = 0x%x\n", hr));

        DBGMSG (DBG_TRACE, ("Release IBididRequestSpl interface.\n")) ;
		return pIReq;

	}
	else
	{
		DBGMSG (DBG_TRACE, ("Client: \t\tCould not create component. hr = %x\n ", hr));
        return NULL;
	}


}

IBidiRequestContainer *  GenRequestContainer (DWORD dwTotal)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest ();
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }
    return pIReqContainer;
}

void TestContainer ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;
    DWORD dwTotal = 3;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest ();
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }


    DWORD dwTotal2;
    hr = pIReqContainer->GetRequestCount (&dwTotal2);
    SPLASSERT (SUCCEEDED (hr));
    SPLASSERT (dwTotal == dwTotal2);

    IEnumUnknown *pEnumIunk;
    hr = pIReqContainer->GetEnumObject (&pEnumIunk) ;

    SPLASSERT (SUCCEEDED (hr));

    for (i = 0; i < dwTotal2; i++){
        IUnknown *pIunk;
        DWORD dwFetched;
        hr = pEnumIunk->Next  (1, &pIunk, &dwFetched);

        SPLASSERT (SUCCEEDED (hr));
        SPLASSERT (dwFetched == 1);

        IBidiRequestSpl *pISpl = NULL;
        hr = pIunk->QueryInterface (IID_IBidiRequestSpl, (void **) & pISpl);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pIunk->Release();
        dwRef = pISpl->Release();

    }

    dwRef = pEnumIunk->Release ();

    DBGMSG (DBG_TRACE, ("Release IBididRequestContainer interface.\n")) ;
    dwRef = pIReqContainer->Release() ;
    SPLASSERT (dwRef == 0);
}

void TestBidiAPI ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;

    hr = ::CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    SPLASSERT (SUCCEEDED (hr));
    DBGMSG (DBG_TRACE, ("IBidiSpl created.\n")) ;

    pIReqContainer = GenRequestContainer (3);

    // Test Open/Close
    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (hr == E_HANDLE);

    hr = pIBidiSpl->BindDevice (L"No such Printer", 0);
    SPLASSERT (!SUCCEEDED (hr));

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));

    hr = pIBidiSpl->UnbindDevice ();
    SPLASSERT (SUCCEEDED (hr));

    hr = pIBidiSpl->UnbindDevice ();
    SPLASSERT (!SUCCEEDED (hr));

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));

    pIReqContainer = GenRequestContainer (3);
    hr = pIBidiSpl->MultiSendRecv (L"Get", NULL);
    SPLASSERT (!SUCCEEDED (hr));;

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);

    dwRef = pIBidiSpl->Release ();
    SPLASSERT (dwRef == 0);
    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

}

IBidiRequest *  GenRequest (LPWSTR pSchema)
{
    HRESULT hr;

	IBidiRequest * pIReq = NULL ;
	
    hr = ::CoCreateInstance(CLSID_BidiRequest,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequest,
                            (void**)&pIReq) ;
	SPLASSERT (SUCCEEDED(hr));

    hr = pIReq->SetSchema (pSchema);
	SPLASSERT (SUCCEEDED(hr));
    return pIReq;
}

IBidiRequestContainer *  GenRequestContainer2 (DWORD dwTotal, LPWSTR pSchema)
{
    HRESULT hr;
    ULONG dwRef;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    IBidiRequest * pRequest = NULL;

    for (DWORD i = 0; i < dwTotal; i++) {
        pRequest = GenRequest (pSchema);
        SPLASSERT (pRequest != NULL);

        hr = pIReqContainer->AddRequest (pRequest);
        SPLASSERT (SUCCEEDED (hr));

        dwRef = pRequest->Release ();
        SPLASSERT (dwRef == 1);
    }
    return pIReqContainer;
}

IBidiRequestContainer *CreateContainer ()
{
    HRESULT hr;
    IBidiRequestContainer * pIReqContainer = NULL ;
	

    hr = ::CoCreateInstance(CLSID_BidiRequestContainer,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiRequestContainer,
                            (void**)&pIReqContainer) ;

    SPLASSERT (SUCCEEDED (hr));

    return pIReqContainer;
}

void AddRequest (
    IBidiRequestContainer * pIReqContainer,
    LPWSTR pSchema)
{
    IBidiRequest * pRequest = NULL;
    HRESULT hr;
    DWORD dwRef;

    pRequest = GenRequest (pSchema);
    SPLASSERT (pRequest != NULL);

    hr = pIReqContainer->AddRequest (pRequest);
    SPLASSERT (SUCCEEDED (hr));

    dwRef = pRequest->Release ();
    SPLASSERT (dwRef == 1);

}


void TestBidiAPI2 ()
{
    HRESULT hr;
    ULONG dwRef;
    IBidiSpl * pIBidiSpl = NULL ;
    IBidiRequestContainer *pIReqContainer;
    IBidiRequest * pRequest = NULL;

    hr = ::CoCreateInstance(CLSID_BidiSpl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IBidiSpl,
                            (void**)&pIBidiSpl) ;

    SPLASSERT (SUCCEEDED (hr));
    DBGMSG (DBG_TRACE, ("IBidiSpl created.\n")) ;

    hr = pIBidiSpl->BindDevice (L"Test", BIDI_ACCESS_USER);
    SPLASSERT (SUCCEEDED (hr));
#if 0
    pIReqContainer = GenRequestContainer2 (10, L"/Printer/Installableoption/DuplexUnit");

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);
#endif

    // Case 2

    pIReqContainer = CreateContainer ();

    //AddRequest (pIReqContainer, L"/Printer/Installableoption/DuplexUnit");
    //AddRequest (pIReqContainer, L"/Communication/Version");
    AddRequest (pIReqContainer, L"/Communication/BidiProtocol");
    AddRequest (pIReqContainer, L"/Printer/BlackInk1/Level");

    hr = pIBidiSpl->MultiSendRecv (L"Get", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);


    // Case 3
    pIReqContainer = CreateContainer ();

    AddRequest (pIReqContainer, L"/Printers/Alerts");

    hr = pIBidiSpl->MultiSendRecv (L"GetAll", pIReqContainer);
    SPLASSERT (SUCCEEDED (hr));

    DumpContainer (pIReqContainer);

    dwRef = pIReqContainer->Release ();
    SPLASSERT (dwRef == 0);

    dwRef = pIBidiSpl->Release ();
    SPLASSERT (dwRef == 0);
    DBGMSG (DBG_TRACE, ("IBidiSpl released.\n")) ;

}

void StartTest ()
{
    //TestContainer ();
    //TestBidiRequest ();
    //TestBidiAPI ();
    TestBidiAPI2 ();

}

int __cdecl main(int argc, char **argv)
{
    HRESULT hr;

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;

#if 0
    hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED ) ;
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;


    hr = CoInitialize (NULL);
    SPLASSERT (SUCCEEDED (hr))
    StartTest ();
    // Uninitialize COM Library
	CoUninitialize() ;
#endif

    printf("Test successfully finished!\n");

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";

/* Security=[Impersonation | Identification | Anonymous] [Dynamic | Static] [True | False]
 * (where True | False corresponds to EffectiveOnly)
 */
LPWSTR StringBindingOptions = L"Security=Impersonation Dynamic False";
handle_t GlobalBindHandle;


handle_t
PRINTER_HANDLE_bind (
    PRINTER_HANDLE   hPrinter)

/*++

Routine Description:

    This routine is used to obtain a binding to the printer spooler.

Arguments:

    Server - Supplies the name of the server where the printer spooler
        should be binded with.

Return Value:

    A binding to the server will be returned, unless an error occurs,
    in which case zero will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;

    RpcStatus = RpcStringBindingComposeW(0, L"ncalrpc", 0, L"spoolss",
                                         StringBindingOptions, &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

    return(BindingHandle);
}



void
PRINTER_HANDLE_unbind (
    PRINTER_HANDLE hPrinter,
    handle_t       BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;

    RpcStatus = RpcStringBindingComposeW(0, L"ncalrpc", 0, L"spoolss",
                                         StringBindingOptions, &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

    return(BindingHandle);
}



void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds common winspool.drv header info

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <splcom.h>

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE hInst;
extern BOOL bLoadedBySpooler;
extern CRITICAL_SECTION ClientSection;
extern CRITICAL_SECTION  ListAccessSem;
extern LPWSTR InterfaceAddress;
extern LPWSTR szEnvironment;
extern CRITICAL_SECTION ProcessHndlCS;
extern HANDLE hSurrogateProcess;

extern DWORD (*fpYReadPrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
extern DWORD (*fpYSplReadPrinter)(HANDLE, LPBYTE *, DWORD, BOOL);
extern DWORD (*fpYWritePrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
extern DWORD (*fpYSeekPrinter)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD, BOOL, BOOL);
extern DWORD (*fpYGetPrinterDriver2)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, DWORD, DWORD, PDWORD, PDWORD, BOOL);
extern DWORD (*fpYGetPrinterDriverDirectory)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, BOOL);
extern VOID  (*fpYDriverUnloadComplete)(LPWSTR);
extern DWORD (*fpYFlushPrinter)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL);
extern DWORD (*fpYEndDocPrinter)(HANDLE,BOOL);
extern DWORD (*fpYSetPort)(LPWSTR, LPWSTR, LPPORT_CONTAINER, BOOL);
extern DWORD (*fpYSetJob)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL);

#define vEnterSem() EnterCriticalSection(&ClientSection)
#define vLeaveSem() LeaveCriticalSection(&ClientSection)

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;

typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
    BOOL     bHandleInvalid;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    HANDLE      hFile;
    DWORD       JobId;
    LPBYTE      pBuffer;
    DWORD       cbBuffer;
    DWORD       Status;
    DWORD       fdwFlags;
    DWORD       cCacheWrite;
    DWORD       cWritePrinters;
    DWORD       cFlushBuffers;
    DWORD       dwTickCount;
    DWORD       dwCheckJobInterval;
    PNOTIFY     pNotify;
    LPTSTR      pszPrinter;
    PRINTER_DEFAULTS Default;
    HANDLE      hSplPrinter;
    DWORD       cActive;
    HANDLE      hSpoolFile;
    DWORD       dwSpoolFileAttributes;
    DWORD       cbFlushPending;
    DWORD       cOKFlushBuffers;
    DWORD       Flushed;
    PDOCEVENT_FILTER    pDoceventFilter;
#ifdef DBG_TRACE_HANDLE
    PSPOOL      pNext;
    PVOID       apvBackTrace[32];
#endif
} SPOOL;

#define WIN2000_SPOOLER_VERSION 3

// cActive: There is a non-close call currently active on the handle.
//     Any ClosePrinter call should just mark SPOOL_STATUS_PENDING_DELETION
//     so that the handle will be closed when the other thread is one.


#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC              0x00000001
#define SPOOL_STATUS_ADDJOB                0x00000002
#define SPOOL_STATUS_ANSI                  0x00000004
#define SPOOL_STATUS_DOCUMENTEVENT_ENABLED 0x00000008
#define SPOOL_STATUS_TRAYICON_NOTIFIED     0x00000010
#define SPOOL_STATUS_NO_COLORPROFILE_HOOK  0x00000020

//
// CLOSE: There is a close call occuring.  Everything else should fail.
// PENDING_DELETION: The handle should be closed as soon as any call completes.
//    This occurs when ClosePrinter is called but another thread is executing
//    a non-close call.  In this case, the ClosePrinter doesn't do anything;
//    it just marks PENDING_DELETION and returns.
//
#define SPOOL_STATUS_CLOSE                 0x00000040
#define SPOOL_STATUS_PENDING_DELETION      0x00000080

#define MAX_STATIC_ALLOC     1024

#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2

#define NULL_TERMINATED 0


//
// This is the resource id that is used to locate the activation context
// for an image that has funsion version information.
//
#define ACTIVATION_CONTEXT_RESOURCE_ID  123

//
// SPOOL_FILE_INFO_1 trades handles in what amount to a 32 bit interface. The
// central assumption here is that kernel mode handles are 32 bit values (i.e.
// an offset into a table.) This isn't great, but since a 64 bit spooler will
// communicate with a 32 bit client GDI, this assumption is implicite anyway.
//
#define SPOOL_INVALID_HANDLE_VALUE_32BIT        ((HANDLE)(ULONG_PTR)0xffffffff)

// Struct for storing loaded driver config file handles
typedef  struct _DRVLIBNODE {
    struct _DRVLIBNODE   *pNext;
    LPWSTR    pConfigFile;
    DWORD     dwNumHandles;
    HANDLE    hLib;
    DWORD     dwVersion;
    BOOL      bArtificialIncrement;
} DRVLIBNODE, *PDRVLIBNODE;

//
// Struct for DocumentProperties UI monitoring
//
typedef struct _PUMPTHRDDATA
{
    ULONG_PTR  hWnd;
    LPWSTR     PrinterName;
    PDWORD     TouchedDevModeSize;
    PDWORD     ClonedDevModeOutSize;
    byte**     ClonedDevModeOut;
    DWORD      DevModeInSize;
    byte*      pDevModeInput;
    DWORD      fMode;
    DWORD      fExclusionFlags;
    PDWORD     dwRet;
    PLONG      Result;
    BOOL       ClonedDevModeFill;
} PumpThrdData;

typedef struct _PRTPROPSDATA
{
     ULONG_PTR  hWnd;
     PDWORD     dwRet;
     LPWSTR     PrinterName;
     DWORD      Flag;
} PrtPropsData;

typedef struct _PRINTERSETUPDATA
{
    ULONG_PTR hWnd;
    UINT      uAction;
    UINT      cchPrinterName;
    UINT      PrinterNameSize;
    LPWSTR    pszPrinterName;
    UINT      *pcchPrinterName;
    LPCWSTR   pszServerName;
}PrinterSetupData;

typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;

typedef enum {
    kProtectHandleSuccess = 0,
    kProtectHandleInvalid = 1,
    kProtectHandlePendingDeletion = 2
} EProtectResult;

typedef enum{
    RUN32BINVER = 4,
    RUN64BINVER = 8
}ClientVersion;

typedef enum{
    NATIVEVERSION = 0,
    THUNKVERSION  = 1
}ServerVersion;

struct SJOBCANCELINFO 
{ 
    PSPOOL pSpool;
    LPBYTE pInitialBuf;
    PDWORD pcbWritten;
    PDWORD pcTotalWritten;
    DWORD  NumOfCmpltWrts;
    DWORD  cbFlushed;
    DWORD  ReqTotalDataSize;
    DWORD  FlushPendingDataSize;
    DWORD  ReqToWriteDataSize;
    BOOL   ReturnValue;
};
typedef struct SJOBCANCELINFO SJobCancelInfo, *PSJobCancelInfo;

//
// The list used to maintain created windows waiting on
// end messages from the surrogate process
//
struct WNDHNDLNODE
{
    struct WNDHNDLNODE *PrevNode;
    struct WNDHNDLNODE *NextNode;
    HWND   hWnd;
};
typedef struct WNDHNDLNODE WndHndlNode,*LPWndHndlNode;

struct WNDHNDLLIST
{
    struct WNDHNDLNODE *Head;
    struct WNDHNDLNODE *Tail;
    DWORD  NumOfHndls;
};
typedef struct WNDHNDLLIST WndHndlList,*LPWndHndlList;

struct MONITORINGTHRDDATA
{
    HANDLE* hProcess;
    HANDLE  hEvent;
};
typedef struct MONITORINGTHRDDATA MonitorThrdData,*LPMonitorThrdData;

typedef struct _MONITORUIDATA
{
    HINSTANCE   hLibrary;
    HANDLE      hActCtx;
    ULONG_PTR   lActCtx;
    PWSTR       pszMonitorName;
    BOOL        bDidActivate;
} MONITORUIDATA, *PMONITORUIDATA;

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
    );

BOOL
WPCInit(
    VOID
    );

VOID
WPCDone(
    VOID
    );

PNOTIFY
WPCWaitFind(
    HANDLE hFind
    );

BOOL
FlushBuffer(
    PSPOOL  pSpool,
    PDWORD pcbWritten
    );

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
    );

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
    );

LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
    );

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
    );

LPWSTR
StartDocDlgW(
    HANDLE hPrinter,
    DOCINFO *pDocInfo
    );

LPSTR
StartDocDlgA(
    HANDLE hPrinter,
    DOCINFOA *pDocInfo
    );

HANDLE
LoadPrinterDriver(
    HANDLE  hPrinter
    );

HANDLE
RefCntLoadDriver(
    LPTSTR  pConfigFile,
    DWORD   dwFlags,
    DWORD   dwVersion,
    BOOL    bUseVersion
    );

BOOL
RefCntUnloadDriver(
    HANDLE  hLib,
    BOOL    bNotifySpooler
    );

BOOL
ForceUnloadDriver(
    LPTSTR  pConfigFile
    );

BOOL
WriteCurDevModeToRegistry(
    LPWSTR      pPrinterName,
    LPDEVMODEW  pDevMode
    );

BOOL
DeleteCurDevModeFromRegistry(
    PWSTR pPrinterName
);

BOOL
bValidDevModeW(
    const DEVMODEW *pDevModeW
    );

BOOL
bValidDevModeA(
    const DEVMODEA *pDevModeA
    );

DWORD
FindClosePrinterChangeNotificationWorker(
    IN  PNOTIFY     pNotify,
    IN  HANDLE      hPrinterRPC,
    IN  BOOL        bRevalidate
    );

BOOL
ScheduleJobWorker(
    PSPOOL pSpool,
    DWORD  JobId
    );

PSPOOL
AllocSpool(
    VOID
    );

VOID
FreeSpool(
    PSPOOL pSpool
    );

VOID
CloseSpoolFileHandles(
    PSPOOL pSpool
    );

EProtectResult
eProtectHandle(
    IN HANDLE hPrinter,
    IN BOOL bClose
    );

VOID
vUnprotectHandle(
    IN HANDLE hPrinter
    );

BOOL
UpdatePrinterDefaults(
    IN OUT PSPOOL pSpool,
    IN     LPCTSTR pszPrinter,  OPTIONAL
    IN     PPRINTER_DEFAULTS pDefault OPTIONAL
    );

BOOL
RevalidateHandle(
    PSPOOL pSpool
    );

BOOL
UpdateString(
    IN     LPCTSTR pszString,  OPTIONAL
       OUT LPTSTR* ppszOut
    );

INT
Message(
    HWND    hwnd,
    DWORD   Type,
    INT     CaptionID,
    INT     TextID,
    ...
    );

DWORD
ReportFailure(
    HWND  hwndParent,
    DWORD idTitle,
    DWORD idDefaultError
    );

BOOL
InCSRProcess(
    VOID
    );

INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR  pAnsi,
    DWORD  StringLength
    );

BOOL
RunInWOW64(
    VOID
    );

DWORD
AddHandleToList(
    HWND hWnd
    );

BOOL
DelHandleFromList(
    HWND hWnd
    );

HRESULT
GetCurrentThreadLastPopup(
    OUT HWND    *phwnd
    );

LPCWSTR
FindFileName(
    IN      LPCWSTR pPathName
    );

VOID
ReleaseAndCleanupWndList(
    VOID
    );

LONG_PTR
DocumentPropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    );

LONG_PTR
DevicePropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    );

VOID
vUpdateTrayIcon(
    IN HANDLE hPrinter,
    IN DWORD JobId
    );

LPWSTR
SelectFormNameFromDevMode(
    HANDLE      hPrinter,
    PDEVMODEW   pDevModeW,
    LPWSTR      pFormName
    );

LPWSTR
IsaFileName(
    LPWSTR pOutputFile,
    LPWSTR FullPathName,
    DWORD  cchFullPathName
    );

PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
    );

DWORD
GetMonitorUI(
    IN PCWSTR           pszMachineName,
    IN PCWSTR           pszObjectName,
    IN PCWSTR           pszObjectType,
    OUT PMONITORUI      *ppMonitorUI,
    OUT PMONITORUIDATA  *ppMonitorUIData
    );

HRESULT
CreateMonitorUIData(
    OUT MONITORUIDATA **ppMonitorUIData
    );

VOID
FreeMonitorUI(
    IN PMONITORUIDATA   pMonitorUIData
    );

HRESULT
GetMonitorUIActivationContext(
    IN PCWSTR           pszMonitorName,
    IN PMONITORUIDATA   pMonitorUIData
    );

HRESULT
GetMonitorUIFullName(
    IN PCWSTR   pszMonitorName,
    IN PWSTR    *ppszMonitorName
    );

DWORD
ConnectToLd64In32ServerWorker(
    HANDLE *hProcess
    );

DWORD
ConnectToLd64In32Server(
    HANDLE *hProcess
    );

DWORD
GetMonitorUIDll(
    PCWSTR      pszMachineName,
    PCWSTR      pszObjectName,
    PCWSTR      pszObjectType,
    PWSTR       *pMonitorUIDll
    );

HWND
GetForeGroundWindow(
    VOID
    );

BOOL
JobCanceled(
    PSJobCancelInfo
    );

BOOL
BuildSpoolerObjectPath(
    IN  PCWSTR  pszPath,
    IN  PCWSTR  pszName,
    IN  PCWSTR  pszEnvironment,
    IN  DWORD   Level,
    IN  PBYTE   pDriverDirectory,
    IN  DWORD   cbBuf,
    IN  PDWORD  pcbNeeded
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles the wait for printer change new code.

    FindFirstPrinterChangeNotification
    FindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

Author:

    Albert Ting (AlbertT) 20-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include <change.h>
#include <ntfytab.h>

//
// Globals
//
PNOTIFY pNotifyHead;
extern  DWORD   ClientHandleCount;

INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength);

VOID
CopyAnsiDevModeFromUnicodeDevMode(
    LPDEVMODEA  pANSIDevMode,
    LPDEVMODEW  pUnicodeDevMode);


//
// Prototypes:
//

PNOTIFY
WPCWaitAdd(
    PSPOOL pSpool);

VOID
WPCWaitDelete(
    PNOTIFY pNotify);


DWORD
WPCSimulateThreadProc(PVOID pvParm);


HANDLE
FindFirstPrinterChangeNotificationWorker(
    HANDLE hPrinter,
    DWORD  fdwFilter,
    DWORD  fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions
    )

/*++

Routine Description:

    The FindFirstChangeNotification function creates a change notification
    handle and sets up initial change notification filter conditions. A
    wait on a notification handle succeeds when a change matching
    the filter conditions occurs in the specified directory or subtree.

Arguments:

    hPrinter - Handle to a printer the user wishes to watch.

    fdwFlags - Specifies the filter conditions that satisfy a change
        notification wait. This parameter can be one or more of the
        following values:

        Value   Meaning

        PRINTER_CHANGE_PRINTER      Notify changes to a printer.
        PRINTER_CHANGE_JOB          Notify changes to a job.
        PRINTER_CHANGE_FORM         Notify changes to a form.
        PRINTER_CHANGE_PORT         Notify changes to a port.
        PRINTER_CHANGE_PRINT_PROCESSOR  Notify changes to a print processor.
        PRINTER_CHANGE_PRINTER_DRIVER   Notify changes to a printer driver.

    fdwOptions - Specifies options to FFPCN.

        PRINTER_NOTIFY_OPTION_SIM_FFPCN         Trying to simulate a FFPCN using a WPC
        PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE  Simulation of FFPCN active
        PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE   Waiting thread must close pSpool
        PRINTER_NOTIFY_OPTION_SIM_WPC           Trying to simulate a WPC using a FFPCN

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    -1 - The operation failed. Extended error status is available
         using GetLastError.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    DWORD dwError;
    PNOTIFY pNotify;

    HANDLE hEvent = INVALID_HANDLE_VALUE;

    //
    // Nothing to watch.
    //
    if (!fdwFilter && !pPrinterNotifyOptions) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    vEnterSem();

    if (eProtectHandle( hPrinter, FALSE )) {
        vLeaveSem();
        return INVALID_HANDLE_VALUE;
    }

    //
    // First check if we are already waiting.
    //
    // This is broken if we are daytona client->528 server and
    // the app does a FFPCN, FCPCN, FFPCN on the same printer,
    // and the WPC hasn't returned yet.  We really can't fix this
    // because there's no way to interrupt the WPC.
    //
    // The only thing we can do is check if it's simulating and waiting
    // to close.  If so, then we can reuse it.
    //
    if (pSpool->pNotify) {

        if ((pSpool->pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE) &&
            (fdwFilter == pSpool->pNotify->fdwFlags)) {

            //
            // No longer closing, since we are using it.
            //
            pSpool->pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE;
            hEvent = pSpool->pNotify->hEvent;
            goto Done;
        }

        SetLastError(ERROR_ALREADY_WAITING);
        goto Done;
    }

    //
    // Create and add our pSpool to the linked list of wait requests.
    //
    pNotify = WPCWaitAdd(pSpool);

    if (!pNotify) {

        goto Done;
    }

    vLeaveSem();

    pNotify->fdwOptions = fdwOptions;
    pNotify->fdwFlags = fdwFilter;

    RpcTryExcept {

        if (dwError = RpcClientFindFirstPrinterChangeNotification(
                          pSpool->hPrinter,
                          fdwFilter,
                          fdwOptions,
                          GetCurrentProcessId(),
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions,
                          (LPDWORD)&pNotify->hEvent)) {

            hEvent = INVALID_HANDLE_VALUE;

        } else {

            hEvent = pNotify->hEvent;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        hEvent = INVALID_HANDLE_VALUE;

    } RpcEndExcept

    vEnterSem();

    //
    // If we encounter a 528 server, then we need to simulate the
    // FFPCN using a WPC.  If the client originally wanted a WPC anyway,
    // then fail out and let the client thread do the blocking.
    //
    if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE &&
        !(fdwOptions & PRINTER_NOTIFY_OPTION_SIM_WPC)) {

        DWORD dwIDThread;
        HANDLE hThread;

        //
        // If pPrinterNotifyOptions is set, we can't handle it.
        // just fail.
        //
        if (pPrinterNotifyOptions) {

            WPCWaitDelete(pNotify);
            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
            hEvent = INVALID_HANDLE_VALUE;
            goto Done;
        }

        hEvent = pNotify->hEvent = CreateEvent(NULL,
                                               TRUE,
                                               FALSE,
                                               NULL);

        if( !hEvent ){

            hEvent = INVALID_HANDLE_VALUE;

        } else {

            //
            // We're simulating a FFPCN using WPC now.
            //
            pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN |
                                   PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

            //
            // Also mark that we failed trying to use FFPCN so we never
            // try again on this handle.
            //
            pSpool->fdwFlags |= SPOOL_FLAG_FFPCN_FAILED;


            hThread = CreateThread(NULL,
                                   INITIAL_STACK_COMMIT,
                                   WPCSimulateThreadProc,
                                   pNotify,
                                   0,
                                   &dwIDThread);

            if (hThread) {

                CloseHandle(hThread);

            } else {

                CloseHandle(hEvent);

                hEvent = INVALID_HANDLE_VALUE;
                dwError = GetLastError();

                pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;
            }
        }
    }

    //
    // On error case, remove us from the list of waiting handles
    //
    if( hEvent == INVALID_HANDLE_VALUE ){

        WPCWaitDelete(pNotify);
        SetLastError(dwError);
    }

Done:

    vUnprotectHandle( hPrinter );
    vLeaveSem();

    return hEvent;
}


HANDLE WINAPI
FindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  fdwFilter,
    DWORD  fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions)
{
    if (fdwOptions) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    return FindFirstPrinterChangeNotificationWorker(hPrinter,
                                                    fdwFilter,
                                                    fdwOptions,
                                                    pPrinterNotifyOptions);
}

BOOL WINAPI
FindNextPrinterChangeNotification(
    HANDLE hChange,
    LPDWORD pdwChange,
    LPVOID pPrinterNotifyOptions,
    LPVOID* ppInfo)
{
    BOOL bReturnValue;
    DWORD dwError;
    HANDLE hPrinter;
    PSPOOL pSpool;
    PNOTIFY pNotify;
    PVOID pvIgnore;
    DWORD dwIgnore;

    DWORD fdwFlags;

    if (!pdwChange) {

        pdwChange = &dwIgnore;
    }

    if (ppInfo) {

        *ppInfo = NULL;
        fdwFlags = PRINTER_NOTIFY_NEXT_INFO;

    } else {

        ppInfo = &pvIgnore;
        fdwFlags = 0;
    }

    vEnterSem();

    pNotify = WPCWaitFind(hChange);

    //
    // Either the handle is bad, or it doesn't have a wait or we have 
    // 
    if (!pNotify || !pNotify->pSpool || pNotify->bHandleInvalid) {

        SetLastError(ERROR_INVALID_HANDLE);
        goto FailExitWaitList;
    }

    pSpool = pNotify->pSpool;
    hPrinter = pSpool->hPrinter;

    //
    // If we are simulating FFPCN using WPC, we must use the thread.
    //
    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN) {

        HANDLE hThread;
        DWORD dwIDThread;

        ResetEvent(pNotify->hEvent);

        //
        // Get the last return status.  Client should not call FNCPN
        // until the WPC sets the event, so this value should be
        // initialized.
        //
        *pdwChange = pNotify->dwReturn;

        //
        // If the thread is active anyway, then don't try to create another
        // Best we can do at this point.
        //
        if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE) {

            vLeaveSem();
            return TRUE;
        }

        //
        // We're simulating a FFPCN using WPC now.
        //
        pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

        hThread = CreateThread(NULL,
                               INITIAL_STACK_COMMIT,
                               WPCSimulateThreadProc,
                               pNotify,
                               0,
                               &dwIDThread);

        if (hThread) {

            CloseHandle(hThread);

            vLeaveSem();
            return TRUE;

        }

        pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

        goto FailExitWaitList;
    }

    vLeaveSem();

    RpcTryExcept {

        if (dwError = RpcFindNextPrinterChangeNotification(
                          hPrinter,
                          fdwFlags,
                          pdwChange,
                          (PRPC_V2_NOTIFY_OPTIONS)pPrinterNotifyOptions,
                          (PRPC_V2_NOTIFY_INFO*)ppInfo)) {

            SetLastError(dwError);
            bReturnValue = FALSE;

        } else {

            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        bReturnValue = FALSE;

    } RpcEndExcept

    //
    // Thunk from W to A if necessary.
    //
    if (pSpool->Status & SPOOL_STATUS_ANSI    &&
        bReturnValue                          &&
        fdwFlags & PRINTER_NOTIFY_NEXT_INFO   &&
        *ppInfo) {

        DWORD i;
        PPRINTER_NOTIFY_INFO_DATA pData;

        for(pData = (*(PPRINTER_NOTIFY_INFO*)ppInfo)->aData,
                i=(*(PPRINTER_NOTIFY_INFO*)ppInfo)->Count;
            i;
            pData++, i--) {

            switch ((BYTE)pData->Reserved) {
            case TABLE_STRING:

                UnicodeToAnsiString(
                    pData->NotifyData.Data.pBuf,
                    pData->NotifyData.Data.pBuf,
                    (pData->NotifyData.Data.cbBuf/sizeof(WCHAR)) -1);

                break;

            case TABLE_DEVMODE:

                if (pData->NotifyData.Data.cbBuf) {

                    CopyAnsiDevModeFromUnicodeDevMode(
                        pData->NotifyData.Data.pBuf,
                        pData->NotifyData.Data.pBuf);
                }

                break;
            }
        }
    }

    return bReturnValue;

FailExitWaitList:

    vLeaveSem();
    return FALSE;
}


BOOL WINAPI
FindClosePrinterChangeNotification(
    HANDLE hChange)
{
    PNOTIFY pNotify;
    HANDLE hPrinterRPC = NULL;
    DWORD dwError;

    vEnterSem();

    pNotify = WPCWaitFind(hChange);

    if (!pNotify) {

        SetLastError(ERROR_INVALID_HANDLE);

        vLeaveSem();
        return FALSE;
    }

    if (pNotify->pSpool)
        hPrinterRPC = pNotify->pSpool->hPrinter;

    dwError = FindClosePrinterChangeNotificationWorker(pNotify,
                                                       hPrinterRPC,
                                                       FALSE);

    vLeaveSem();

    if (dwError) {

        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}


DWORD
FindClosePrinterChangeNotificationWorker(
    IN  PNOTIFY     pNotify,
    IN  HANDLE      hPrinterRPC,
    IN  BOOL        bRevalidate
    )

/*++

Routine Description:

    Does the actual FindClose work.

Arguments:

    pNotify     - notification to close
    hPrinterRPC - handle to printer to close
    bRevalidate - If this is TRUE, we were called to revalidate the handle 
                  rather than close it.

Return Value:

    TRUE - success
    FALSE - fail

    Note: assume in critical section

--*/

{
    DWORD dwError;
    PSPOOL pSpool;

    if (!pNotify) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Detach the pNotify and pSpool objects completely. Only if we are not 
    // revalidating.
    //
    pSpool = pNotify->pSpool;

    if (!bRevalidate) {

        if (pSpool) {
            pSpool->pNotify = NULL;
            pSpool->fdwFlags = 0;
        }

        pNotify->pSpool = NULL;
    }

    //
    // If we are simulating a FFPCN with a WPC, then let the WPC thread
    // free up the data structure or clean it up if the thread is done.
    //
    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN) {

        if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE) {

            pNotify->fdwOptions |= PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE;

        } else {

            //
            // The thread has exited, so we need to do the cleanup.
            // Set the event to release any waiting threads. Since the caller
            // does not necessarily know how to handle the failure on 
            // WaitForMultipleObjects, 
            //
            SetEvent(pNotify->hEvent);

            if (!bRevalidate) {

                CloseHandle(pNotify->hEvent);
                WPCWaitDelete(pNotify);

            } else {

                pNotify->bHandleInvalid = TRUE;
            }
        }

        return ERROR_SUCCESS;
    }

    SetEvent(pNotify->hEvent);

    //
    // If we are not revalidating, we can close the handle for real, otherwise
    // we just want to set the handle to invalid.
    // 
    if (!bRevalidate) {

        CloseHandle(pNotify->hEvent);
        WPCWaitDelete(pNotify);

    } else {

        pNotify->bHandleInvalid = TRUE;
    }

    if (!hPrinterRPC)
        return ERROR_SUCCESS;

    vLeaveSem();

    RpcTryExcept {

        dwError = RpcFindClosePrinterChangeNotification(hPrinterRPC);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());

    } RpcEndExcept

    vEnterSem();

    return dwError;
}

//
// WPC Wait structures
// Currently implemented as a linked list
//

PNOTIFY
WPCWaitAdd(
    PSPOOL pSpool)

/*++

Routine Description:

    Allocates a wait structure on the client side, which allows the
    user program to refer to events only.

Arguments:

    pSpool - object to add to list

Return Value:

    NOTE: Asssumes already in critical section

--*/

{
    PNOTIFY pNotify;

    pNotify = AllocSplMem(sizeof(NOTIFY));

    if (!pNotify)
        return NULL;

    pNotify->pSpool = pSpool;
    pSpool->pNotify = pNotify;

    pNotify->pNext = pNotifyHead;
    pNotifyHead = pNotify;

    return pNotify;
}

VOID
WPCWaitDelete(
    PNOTIFY pNotify)

/*++

Routine Description:

    Find wait structure based on hEvent.

Arguments:

    pNotify - delete it

Return Value:

    VOID

    NOTE: Asssumes already in critical section

--*/

{
    PNOTIFY pNotifyTmp;

    if (!pNotify)
        return;

    //
    // Check head case first
    //
    if (pNotifyHead == pNotify) {

        pNotifyHead = pNotify->pNext;

    } else {

        //
        // Scan list to delete
        //
        for(pNotifyTmp = pNotifyHead;
            pNotifyTmp;
            pNotifyTmp = pNotifyTmp->pNext) {

            if (pNotify == pNotifyTmp->pNext) {

                pNotifyTmp->pNext = pNotify->pNext;
                break;
            }
        }

        //
        // If not found, return without freeing
        //
        if (!pNotifyTmp)
            return;
    }

    //
    // Remove link from pSpool to us... but only if we've found
    // ourselves on the linked list (could have been removed by
    // ClosePrinter in a different thread).
    //
    if (pNotify->pSpool) {
        pNotify->pSpool->pNotify = NULL;
    }

    FreeSplMem(pNotify);
    return;
}


PNOTIFY
WPCWaitFind(
    HANDLE hFind)

/*++

Routine Description:

    Find wait structure based on hEvent.

Arguments:

    hFind - Handle to event returned from FindFirstPrinterChangeNotification
            or hPrinter

Return Value:

    pWait pointer, or NULL if not found

    NOTE: assumes already in critical section

--*/

{
    PNOTIFY pNotify;

    for(pNotify = pNotifyHead; pNotify; pNotify=pNotify->pNext) {

        if (hFind == pNotify->hEvent) {

            return pNotify;
        }
    }

    return NULL;
}



DWORD
WPCSimulateThreadProc(
    PVOID pvParm)

/*++

Routine Description:

    This thread simulates the FFPCN when daytona apps run on daytona
    clients connected to 528 servers.

Arguments:

    pvParm - pSpool

Return Value:

    VOID

    Note:

--*/

{
    PNOTIFY pNotify = (PNOTIFY)pvParm;

    pNotify->dwReturn = WaitForPrinterChange(pNotify->pSpool,
                                             pNotify->fdwFlags);

    vEnterSem();

    pNotify->fdwOptions &= ~PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE;

    //
    // !! POLICY !!
    //
    // How do we handle timeouts?
    //
    SetEvent(pNotify->hEvent);

    if (pNotify->fdwOptions & PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE) {

        CloseHandle(pNotify->hEvent);
        WPCWaitDelete(pNotify);
    }

    vLeaveSem();

    //
    // We are no longer active; the FindClose must clean up for us.
    //
    return 0;
}

DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    DWORD   ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    HANDLE  hEvent;
    DWORD   rc;

    if( eProtectHandle( hPrinter, FALSE )){
        return(FALSE);
    }


    //
    // Try using FFPCN first, if we haven't failed on this printer before.
    //

    if (!(pSpool->fdwFlags & SPOOL_FLAG_FFPCN_FAILED)) {

        if (pSpool->fdwFlags & SPOOL_FLAG_LAZY_CLOSE) {

            vEnterSem();

            if (pSpool->pNotify)
                hEvent = pSpool->pNotify->hEvent;

            vLeaveSem();

        } else {

            hEvent = FindFirstPrinterChangeNotificationWorker(
                         hPrinter,
                         Flags,
                         PRINTER_NOTIFY_OPTION_SIM_WPC,
                         NULL);
        }

        if (hEvent != INVALID_HANDLE_VALUE) {

            //
            // Found notification, now wait for it.
            //
            rc = WaitForSingleObject(hEvent, PRINTER_CHANGE_TIMEOUT_VALUE);

            switch (rc) {
            case WAIT_TIMEOUT:

                ReturnValue = PRINTER_CHANGE_TIMEOUT;
                break;

            case WAIT_OBJECT_0:

                if (!FindNextPrinterChangeNotification(
                    hEvent,
                    &ReturnValue,
                    0,
                    NULL)) {

                    ReturnValue = 0;

                    DBGMSG(DBG_WARNING,
                           ("QueryPrinterChange failed %d\n",
                           GetLastError()));
                }
                break;

            default:

                ReturnValue = 0;
                break;
            }

            //
            // !! Policy !!
            //
            // Do we want to close it?  The app might just reopen it.
            // If we leave it open, it will get cleaned-up at ClosePrinter
            // time.  We would need an api to clear out pending events.
            //
            pSpool->fdwFlags |= SPOOL_FLAG_LAZY_CLOSE;
            goto Done;
        }

        //
        // FFPCN failed.  Only if entry not found (511 client) do
        // we try old WPC.  Otherwise return here.
        //
        if (GetLastError() != RPC_S_PROCNUM_OUT_OF_RANGE) {
            ReturnValue = 0;
            goto Done;
        }

        pSpool->fdwFlags |= SPOOL_FLAG_FFPCN_FAILED;
    }

    RpcTryExcept {

        if (ReturnValue = RpcWaitForPrinterChange(
                              pSpool->hPrinter,
                              Flags,
                              &Flags)) {

            SetLastError(ReturnValue);
            ReturnValue = 0;

        } else

            ReturnValue = Flags;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = 0;

    } RpcEndExcept
Done:

    vUnprotectHandle( pSpool );
    return ReturnValue;
}


BOOL WINAPI
FreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo)
{
    DWORD i;
    PPRINTER_NOTIFY_INFO_DATA pData;

    if (!pInfo) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for(pData = pInfo->aData, i=pInfo->Count;
        i;
        pData++, i--) {

        if ((BYTE)pData->Reserved != TABLE_DWORD &&
            pData->NotifyData.Data.pBuf) {

            midl_user_free(pData->NotifyData.Data.pBuf);
        }
    }

    midl_user_free(pInfo);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\cstrings.h ===
#ifndef _CSTRINGS_H
#define _CSTRINGS_H

EXTERN_C const WCHAR szWindows[];
EXTERN_C const WCHAR szDevices[];
EXTERN_C const WCHAR szDevice[];
EXTERN_C const WCHAR szPrinterPorts[];
EXTERN_C const WCHAR szPrinters[];
EXTERN_C const WCHAR szDeviceOld[];
EXTERN_C const WCHAR szNULL[];
EXTERN_C const WCHAR szComma[];
EXTERN_C const WCHAR szSlash[];
EXTERN_C const WCHAR szFilePort[];
EXTERN_C const WCHAR szHelpFile[];
EXTERN_C const WCHAR szNetMsgDll[];
EXTERN_C const WCHAR szPrintUIDll[];
EXTERN_C const WCHAR cszWin95Environment[];
EXTERN_C const WCHAR szManifestExtension[];
EXTERN_C const WCHAR gszShell32[];
EXTERN_C const WCHAR cszTrayListenerClassName[];
EXTERN_C const WCHAR gszCSRDll[];
EXTERN_C const WCHAR gszUserProfileRegPath[];
EXTERN_C const WCHAR gszRegEnvironments[];
EXTERN_C const WCHAR gszSystem32Spool[];
EXTERN_C const WCHAR gszPrintProcessorsPath[];
EXTERN_C const WCHAR gszPrinterDriversPath[];
EXTERN_C const WCHAR gszEnivronmentDirectory[];

EXTERN_C const CHAR szCompstuiDll[];
EXTERN_C const CHAR szCommonPropertySheetUIW[];
EXTERN_C const CHAR szDrvDevPropSheets[];
EXTERN_C const CHAR szDrvDocPropSheets[];
EXTERN_C const CHAR szConstructPrinterFriendlyName[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\clusspl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    cluster.c

Abstract:

    Cluster support.

    Note: there is no handle revalidation support in the module because
    the cluster software should be informed when a group goes offline.

Author:

    Albert Ting (AlbertT)  1-Oct-96

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Client side stub for opening a cluster resource.

Arguments:

    pszServer - Server to open--currently must be NULL (local).

    pszResource - Spooler resource.

    phSpooler - Receives handle on success; recevies NULL otherwise.

    pszName - Comma delimited alternate netbios/computer names.

    pszAddress - Comma delimited tcpip address names.

Return Value:

    TRUE - Success, phHandle must be closed with ClusterSplClose.

    FALSE - Failed--use GetLastError.  *phSpooler is NULL.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    BOOL bReturnValue = TRUE;
    PSPOOL pSpool = NULL;

    //
    // Preinitialize the spooler handle return to NULL.
    //
    __try {
        *phSpooler = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ){
        SetLastError( ERROR_INVALID_PARAMETER );
        phSpooler = NULL;
    }

    if( !phSpooler ){
        goto Fail;
    }

    //
    // Disallow remote servers in this release.
    //
    if( pszServer ){
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Fail;
    }


    //
    // Preallocate the handle.
    //
    pSpool = AllocSpool();

    if (pSpool) 
    {
        RpcTryExcept {

            Status = RpcClusterSplOpen( (LPTSTR)pszServer,
                                        (LPTSTR)pszResource,
                                        &pSpool->hPrinter,
                                        (LPTSTR)pszName,
                                        (LPTSTR)pszAddress );
            if( Status ){
                SetLastError( Status );
                bReturnValue = FALSE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())){

            SetLastError( TranslateExceptionCode( RpcExceptionCode() ));
            bReturnValue = FALSE;

        } RpcEndExcept
    }
    else
    {
        SetLastError( ERROR_OUTOFMEMORY );
        bReturnValue = FALSE;
    }

    if( bReturnValue ){

        //
        // pSpool is orphaned to *phSpooler.
        //
        *phSpooler = (HANDLE)pSpool;
        pSpool = NULL;
    }

Fail:

    FreeSpool( pSpool );

    return bReturnValue;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Close the spooler.

Arguments:

    hSpooler - Spooler to close.

Return Value:

    Note: this function always returns TRUE, although it's spec'd out
    to return FALSE if the call fails.

--*/

{
    PSPOOL pSpool = (PSPOOL)hSpooler;
    HANDLE hSpoolerRPC;
    DWORD Status;

    switch( eProtectHandle( hSpooler, TRUE )){
    case kProtectHandlePendingDeletion:
        return TRUE;
    case kProtectHandleInvalid:
        return FALSE;
    default:
        break;
    }

    hSpoolerRPC = pSpool->hPrinter;

    RpcTryExcept {

        Status = RpcClusterSplClose( &hSpoolerRPC );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        Status = TranslateExceptionCode( RpcExceptionCode() );

    } RpcEndExcept

    if( hSpoolerRPC ){
        RpcSmDestroyClientContext(&hSpoolerRPC);
    }

    FreeSpool( pSpool );

    return TRUE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Determines whether a spooler is still alive.

Arguments:

    hSpooler - Spooler to check.

Return Value:

    TRUE - Success
    FALSE - Fail; LastError set.

--*/

{
    PSPOOL pSpool = (PSPOOL)hSpooler;
    BOOL bReturnValue = TRUE;

    if( eProtectHandle( hSpooler, FALSE )){
        return FALSE;
    }

    RpcTryExcept {

        DWORD Status;

        Status = RpcClusterSplIsAlive( pSpool->hPrinter );

        if( Status ){
            SetLastError( Status );
            bReturnValue = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError( TranslateExceptionCode( RpcExceptionCode() ));
        bReturnValue = FALSE;

    } RpcEndExcept

    vUnprotectHandle( hSpooler );

    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\defprn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    defprn.cxx

Abstract:

    Default printer header.

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#ifndef _DEFPRN_H
#define _DEFPRN_H


BOOL
IsPrinterDefaultW(
    IN LPCWSTR  pszPrinter
    );

BOOL
GetDefaultPrinterA(
    IN LPSTR    pszBuffer,
    IN LPDWORD  pcchBuffer
    );

BOOL
GetDefaultPrinterW(
    IN LPWSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    );

BOOL
SetDefaultPrinterA(
    IN LPCSTR pszPrinter
    );

BOOL
SetDefaultPrinterW(
    IN LPCWSTR pszPrinter
    );

BOOL
bGetActualPrinterName(
    IN      LPCTSTR  pszPrinter,
    IN      LPTSTR   pszBuffer,
    IN OUT  UINT     *pcchBuffer
    );

BOOL
DefPrnGetProfileString(
    IN PCWSTR   pAppName,
    IN PCWSTR   pKeyName,
    IN PWSTR    pReturnedString,
    IN DWORD    nSize
    );

BOOL
DefPrnWriteProfileString(
    IN PCWSTR lpAppName,
    IN PCWSTR lpKeyName,
    IN PCWSTR lpString
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\drvsetup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    drvsetup.h

Abstract:

    This file provides an interface between winspool.drv and ntprint.dll.     

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _DRVSETUP_H_
#define _DRVSETUP_H_
 
typedef struct
{
    HANDLE                      hLibrary;
    pfPSetupShowBlockedDriverUI pfnSetupShowBlockedDriverUI;    

} TSetupInterface;

DWORD
InitializeSetupInterface(
    IN  OUT TSetupInterface      *pSetupInterface
    );

DWORD
FreeSetupInterface(
    IN  OUT TSetupInterface     *pSetupInterface
    );

DWORD
ShowPrintUpgUI(
    IN      DWORD               dwBlockingErrorCode
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\cstrings.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    cstrings.c

Abstract:

    Constant strings

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

const WCHAR szWindows[]                 = L"Windows";
const WCHAR szDevices[]                 = L"Devices";
const WCHAR szDevice[]                  = L"Device";
const WCHAR szPrinterPorts[]            = L"PrinterPorts";
const WCHAR szPrinters[]                = L"Printers";
const WCHAR szDeviceOld[]               = L"DeviceOld";
const WCHAR szNULL[]                    = L"";
const WCHAR szComma[]                   = L",";
const WCHAR szSlash[]                   = L"\\";
const WCHAR szFilePort[]                = L"FILE:";
const WCHAR szHelpFile[]                = L"WINDOWS.HLP";
const WCHAR szNetMsgDll[]               = L"NETMSG.DLL";
const WCHAR szPrintUIDll[]              = L"PRINTUI.DLL";
const WCHAR cszWin95Environment[]       = L"Windows 4.0";
const WCHAR szManifestExtension[]       = L"manifest";
const WCHAR gszShell32[]                = L"shell32.dll";
const WCHAR cszTrayListenerClassName[]  = L"PrintTray_Notify_WndClass";
const WCHAR gszCSRDll[]                 = L"csrsrv.dll";
const WCHAR gszUserProfileRegPath[]     = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR gszRegEnvironments[]        = L"System\\CurrentControlSet\\Control\\Print\\Environments";
const WCHAR gszSystem32Spool[]          = L"system32\\spool";
const WCHAR gszPrintProcessorsPath[]    = L"PRTPROCS";
const WCHAR gszPrinterDriversPath[]     = L"DRIVERS";
const WCHAR gszEnivronmentDirectory[]   = L"Directory";

const CHAR szCompstuiDll[]                      = "compstui.dll";
const CHAR szCommonPropertySheetUIW[]           = "CommonPropertySheetUIW";
const CHAR szDrvDevPropSheets[]                 = "DrvDevicePropertySheets";
const CHAR szDrvDocPropSheets[]                 = "DrvDocumentPropertySheets";
const CHAR szConstructPrinterFriendlyName[]     = "ConstructPrinterFriendlyName";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\devmode.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved

Module Name:

    devmode.c

Abstract:

    Handles per-user devmode implementation.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

/********************************************************************

    Forward prototypes

********************************************************************/

LPWSTR
FormatPrinterForRegistryKey(
    LPWSTR pSource,
    LPWSTR pScratch
    );

BOOL
bGetDevModeLocation(
    IN PSPOOL pSpool,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    );

const WCHAR gszPrinterConnections[] = L"Printers\\Connections\\";
const WCHAR gszDevMode[] = L"DevMode";
const WCHAR gszDevModePerUserLocal[] = L"Printers\\DevModePerUser";


/********************************************************************

    Public functions

********************************************************************/

BOOL
bSetDevModePerUser(
    PSPOOL pSpool,
    PDEVMODE pDevMode
    )

/*++

Routine Description:

    Sets the per-user DevMode in HKCU.

Arguments:

    pSpool - Printer to set.

    pDevMode - DevMode to save.  If NULL, deletes value.

Return Value:

    TRUE - Success
    FALSE - Failure

--*/

{
    HKEY hKey = NULL;
    BOOL bReturn = FALSE;
    LPWSTR pszValue = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Retrieve the location of the DevMode.
    //
    bReturn = bGetDevModeLocation( pSpool,
                                   &hKey,
                                   &pszValue );

    if( bReturn ){

        if( !pDevMode ){

            //
            // NULL, so delete the value.
            //
            dwStatus = RegDeleteValue( hKey, pszValue );

        } else {

            dwStatus = RegSetValueEx( hKey,
                                      pszValue,
                                      0,
                                      REG_BINARY,
                                      (PBYTE)pDevMode,
                                      pDevMode->dmSize +
                                          pDevMode->dmDriverExtra );
        }

        RegCloseKey( hKey );
    }

    if( dwStatus != ERROR_SUCCESS ){
        SetLastError( dwStatus );
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
bGetDevModePerUser(
    PSPOOL pSpool,
    PDEVMODE *ppDevMode
    )

/*++

Routine Description:

    Retrieves the per-user DevMode based on the current user.

Arguments:

    pSpool - Printer to use.

    ppDevMode - Receives pointer to devmode.  Must be freed by callee.

Return Value:

    TRUE - Success: able to check if per-user DevMode exists.  *ppDevMode
        is NULL if no per-user DevMode is there.  (TRUE does not indicate
        that a per-user DevMode was found, only that we successfully checked.)

    FALSE - Failure.

--*/

{
    HKEY hKey = NULL;
    BOOL bReturn = FALSE;
    LPWSTR pszValue = NULL;
    LONG Status = ERROR_SUCCESS;

    *ppDevMode = NULL;

    //
    // Retrieve the location of the DevMode.
    //
    if( bGetDevModeLocation( pSpool,
                             &hKey,
                             &pszValue )){

        DWORD cbDevModePerUser;

        //
        // Key exists.  See if we can read it and get the per-user DevMode.
        //
        Status = RegQueryInfoKey( hKey,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &cbDevModePerUser,
                                  NULL,
                                  NULL );
        if( Status == ERROR_SUCCESS ){

            *ppDevMode = AllocSplMem( cbDevModePerUser );

            if( *ppDevMode ){

                Status = RegQueryValueEx( hKey,
                                          pszValue,
                                          NULL,
                                          NULL,
                                          (PBYTE)*ppDevMode,
                                          &cbDevModePerUser );

                if( Status == ERROR_SUCCESS ){
                    bReturn = TRUE;
                }
            }

            if( !bReturn ){
                FreeSplMem( *ppDevMode );
                *ppDevMode = NULL;
            }

            //
            // Allow ERROR_FILE_NOT_FOUND to return success.  *ppDevMode
            // is still NULL, but we return TRUE to indicate that we
            // successfully checked the registry--we just didn't find one.
            //
            if( Status == ERROR_FILE_NOT_FOUND ){
                bReturn = TRUE;
            }
        }

        RegCloseKey( hKey );
    }

    if( !bReturn ){

        SetLastError( Status );
    }

    return bReturn;
}


BOOL
bCompatibleDevMode(
    PSPOOL pSpool,
    PDEVMODE pDevModeBase,
    PDEVMODE pDevModeNew
    )

/*++

Routine Description:

    Check if two DevModes are compatible (e.g., they can be used
    interchangably).

    This is done by checking size and version information.  Not
    foolproof, but the best we can do since we can't look at private
    information.

Arguments:

    pSpool - Printer to check.

    pDevModeBase - Known good DevMode.

    pDevModeNew - DevMode to check.

Return Value:

    TRUE - Appears compatible.
    FALSE - Not compatible.

--*/
{
    if( !pDevModeBase || ! pDevModeNew ){
        return FALSE;
    }

    return pDevModeBase->dmSize == pDevModeNew->dmSize &&
           pDevModeBase->dmDriverExtra == pDevModeNew->dmDriverExtra &&
           pDevModeBase->dmSpecVersion == pDevModeNew->dmSpecVersion &&
           pDevModeBase->dmDriverVersion == pDevModeNew->dmDriverVersion;
}

/********************************************************************

    Support Functions

********************************************************************/


LPWSTR
FormatPrinterForRegistryKey(
    LPWSTR pSource,
    LPWSTR pScratch
    )
{
    if (pScratch != pSource) {

        //
        // Copy the string into the scratch buffer:
        //
        wcscpy(pScratch, pSource);
    }

    //
    // Check each character, and, if it's a backslash,
    // convert it to a comma:
    //
    for (pSource = pScratch; *pSource; pSource++) {
        if (*pSource == L'\\')
            *pSource = L',';
    }

    return pScratch;
}

BOOL
bGetDevModeLocation(
    IN PSPOOL pSpool,
    OUT PHKEY phKey,
    OUT LPCWSTR *ppszValue
    )

/*++

Routine Description:

    Retrieves the location of the per-user DevMode.

    On success, caller is responsible for closing phKey.  ppszValue's
    life is dependent on pSpool.

Arguments:

    pSpool - Printer to use.

    phKey - Receives R/W key of per-user DevMode.  On success, this
        must be closed by caller.

    ppszValue - Receives value of per-user DevMode (where to read/write).

Return Value:

    TRUE - Success

    FALSE - Failure, LastError set.

--*/

{
    WCHAR szPrinterScratch[MAX_PRINTER_NAME + COUNTOF( gszPrinterConnections )];
    BOOL bReturn = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    //
    // If it starts with two backslashes, it may be either a connection
    // or a masq printer.
    //
    if( pSpool->pszPrinter[0] == L'\\' && pSpool->pszPrinter[1] == L'\\' ){

        //
        // Query the registry for pSpool->pszPrinter and look for DevMode.
        // First look at the HKCU:Printer\Connections.
        //
        wcscpy( szPrinterScratch, gszPrinterConnections );
        FormatPrinterForRegistryKey(
            pSpool->pszPrinter,
            &szPrinterScratch[ COUNTOF( gszPrinterConnections )-1] );

        dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                                szPrinterScratch,
                                0,
                                KEY_READ | KEY_WRITE,
                                phKey );

        if( dwError == ERROR_SUCCESS ){
            *ppszValue = gszDevMode;
            bReturn = TRUE;
        }
    }

    if( !bReturn ){

        DWORD dwIgnore;

        //
        // Not a connection or didn't exist in the connections key.
        // Look in the Printers\DevModePerUser key.
        //
        dwError = RegCreateKeyEx( HKEY_CURRENT_USER,
                                  gszDevModePerUserLocal,
                                  0,
                                  NULL,
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  phKey,
                                  &dwIgnore );

        if( dwError == ERROR_SUCCESS ){
            *ppszValue = pSpool->pszPrinter;
            bReturn = TRUE;
        }
    }

    if( !bReturn ){
        SetLastError( dwError );
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\drvsetup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    drvsetup.c

Abstract:

    This file implements the interface between winspool.drv and ntprint.dll.

Author:

    Mark Lawrence   (mlawrenc).

Environment:

    User Mode -Win32

Revision History:

    Larry Zhu       (LZhu)  Feb 10 -- Added ShowPrintUpgUI
    
--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "drvsetup.h"

/*++
                                                       
                                                       
Routine Name:

    InitializeSetupInterface

Routine Description:

    This routine initializes the setup interfaces. This setup interface could be
    expanded over time to support more advance driver options.

Arguments:

    pSetupInterface -   The setup interface to load and initialize.

Return Value:

    Status Return.

--*/
DWORD 
InitializeSetupInterface(
    IN  OUT TSetupInterface      *pSetupInterface
    )
{
    DWORD   Status = ERROR_SUCCESS;

    pSetupInterface->hLibrary                       = NULL;
    pSetupInterface->pfnSetupShowBlockedDriverUI    = NULL;

    pSetupInterface->hLibrary = LoadLibrary(L"ntprint.dll");

    Status = pSetupInterface->hLibrary != NULL ? ERROR_SUCCESS : GetLastError();

    if (Status == ERROR_SUCCESS)
    {
        pSetupInterface->pfnSetupShowBlockedDriverUI= (pfPSetupShowBlockedDriverUI)
                                                      GetProcAddress(pSetupInterface->hLibrary,
                                                                     "PSetupShowBlockedDriverUI");
        
        Status = pSetupInterface->pfnSetupShowBlockedDriverUI ? ERROR_SUCCESS : ERROR_INVALID_FUNCTION;
    }

    return Status;
}

/*++

Routine Name:

    FreeSetupInterface

Routine Description:

    This routine frees the Setup Interface.

Arguments:

    pSetupInterface -   The setup interface to unload.

Return Value:

    Status Return.

--*/
DWORD
FreeSetupInterface(
    IN  OUT TSetupInterface     *pSetupInterface
    )
{
    DWORD   Status = ERROR_SUCCESS;

    if (pSetupInterface->hLibrary)
    {
        Status = FreeLibrary(pSetupInterface->hLibrary) ? ERROR_SUCCESS : GetLastError();
    }

    return Status;
}

/*++

Routine Name:

    ShowPrintUpgUI

Routine Description:

    This routine asks ntprint.dll to popup a message box either indicates
    the driver is blocked and installation will abort or at the case of
    warned driver, whether to preceed the driver installation.

Arguments:

    dwBlockingStatus   - ErrorCode for blocked or Warned driver   
     
Return Value:

    DWORD   -   If ERROR_SUCCESS, the driver may be installed, otherwise an error
                code indicating the failure.                    

--*/
DWORD
ShowPrintUpgUI(
    IN      DWORD               dwBlockingErrorCode
    )
{
    DWORD            dwStatus             = ERROR_SUCCESS;
    HWND             hWndParent           = NULL;
    DWORD            dwBlockingStatus     = BSP_PRINTER_DRIVER_OK;
    TSetupInterface  SetupInterface;
    
    if (ERROR_PRINTER_DRIVER_BLOCKED == dwBlockingErrorCode)
    {
        dwBlockingStatus = BSP_PRINTER_DRIVER_BLOCKED;
    } 
    else if (ERROR_PRINTER_DRIVER_WARNED == dwBlockingErrorCode)
    {
        dwBlockingStatus = BSP_PRINTER_DRIVER_WARNED;
    } 
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }   
    
    if (ERROR_SUCCESS == dwStatus)
    {
        dwStatus = InitializeSetupInterface(&SetupInterface);
            
        if ((dwStatus == ERROR_SUCCESS))
        {                        
            hWndParent = SUCCEEDED(GetCurrentThreadLastPopup(&hWndParent)) ? hWndParent : NULL;
    
            //
            // Ask the user what they want to do. If they don't want to proceed, 
            // then the error is what the would get from the localspl call.
            // 
            dwStatus = (SetupInterface.pfnSetupShowBlockedDriverUI(hWndParent, dwBlockingStatus) & BSP_PRINTER_DRIVER_PROCEEDED) ? ERROR_SUCCESS : dwBlockingErrorCode;
        }
    
        (VOID)FreeSetupInterface(&SetupInterface);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\dsutil.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Abstract:

    This module provides utilities useful for Directory Service interactions

Author:

    Steve Wilson (NT) November 1997

Revision History:

--*/

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "client.h"

#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "winsprlp.h"
#include "dnsapi.h"


#define DN_SPECIAL_CHARS L",=\r\n+<>#;\"\\"
#define DN_SPECIAL_FILTER_CHARS L"\\*()"


PWSTR
GetUNCName(
    HANDLE hPrinter
)
{
    PPRINTER_INFO_2    pInfo2 = NULL;
    DWORD            cbNeeded;
    PWSTR            pszUNCName = NULL;


    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            goto error;
    }

    if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded)))
        goto error;

    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded))
        goto error;


    // pPrinterName is already in correct UNC format since we
    // opened handle with UNC name: just copy it

    cbNeeded = wcslen(pInfo2->pPrinterName) + 1;
    cbNeeded *= sizeof(WCHAR);

    if (!(pszUNCName = (PWSTR) AllocSplMem(cbNeeded)))
        goto error;

    wcscpy(pszUNCName, pInfo2->pPrinterName);


error:

    if (pInfo2)
        FreeSplMem(pInfo2);

    return pszUNCName;
}

PWSTR
CreateEscapedDN(
    PCWSTR pszIn
)
{
    PWSTR psz, pszO;
    PWSTR pszOut = NULL;
    DWORD cb;
    
    // Count special characters
    for (cb = 0, psz = (PWSTR) pszIn ; psz = wcspbrk(psz, DN_SPECIAL_FILTER_CHARS) ; ++cb, ++psz)
        ;

    // Add in length of input string
    // 2 = (\5c) - '\'
    cb = (wcslen(pszIn) + cb*2 + 1)*sizeof *pszIn;    

    // Allocate output buffer and replace special chars with \HexEquivalent
    // Ex: replace \ with \5c , ( with \28
    if (pszOut = (PWSTR) AllocSplMem(cb)) {

        for(psz = (PWSTR) pszIn, pszO = pszOut ; *psz ; ++psz) {
            if (wcschr(DN_SPECIAL_FILTER_CHARS, *psz)) {
                pszO += wsprintf(pszO, L"\\%x", *psz);                                                
            } else {
                *pszO++ = *psz;
            }
        }
        *pszO = L'\0';
    }

    return pszOut;
}

DWORD
PrintQueueExists(
    HWND    hwnd,
    HANDLE  hPrinter,
    PWSTR   pszUNCName,
    DWORD   dwAction,
    PWSTR   pszTargetDN,
    PWSTR   *ppszObjectDN
)
{
    HRESULT                             hr = S_OK;
    DWORD                               dwRet = ERROR_SUCCESS;
    WCHAR                               szSearchPattern[MAX_UNC_PRINTER_NAME + 50];
    WCHAR                               szFullUNCName[MAX_UNC_PRINTER_NAME];
    PWSTR                               pNames[2];
    WCHAR                               szName[MAX_PATH + 1];
    WCHAR                               szDuplicateFormat[1024];
    PWSTR                               pszSearchRoot = NULL;
    PWSTR                               pszDuplicate = NULL;
    PWSTR                               pszUNCNameSearch = NULL;
    IDirectorySearch                    *pDSSearch = NULL;
    DS_NAME_RESULT                      *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    HANDLE                              hDS = NULL;
    ADS_SEARCH_HANDLE                   hSearchHandle = NULL;
    ADS_SEARCH_COLUMN                   ADsPath;
    ADS_SEARCH_COLUMN                   UNCName;
    PWSTR                               pszAttributes[] = {L"ADsPath", L"UNCName"};
    DWORD                               nSize;
    BOOL                                bRet = FALSE;
    BOOL                                bDeleteDuplicate;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;

    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    if (dwRet != ERROR_SUCCESS)
        goto error;

    wsprintf(szName, L"%ws\\", pDsRole->DomainNameFlat);

    pNames[0] = szName;
    pNames[1] = NULL;

    dwRet = Bind2DS(&hDS, &pDCI, DS_GC_SERVER_REQUIRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_UNKNOWN_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    } 

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
            dwRet = ERROR_PATH_NOT_FOUND;
        else
            dwRet = pDNR->rItems[0].status;

        goto error;
    }

    // GC:// + pDCName + 1
    nSize = (wcslen(pDNR->rItems[0].pName) + 6)*sizeof(WCHAR);

    if (!(pszSearchRoot = (PWSTR) AllocSplMem(nSize))) {
        dwRet = GetLastError();
        goto error;
    }

    wsprintf(pszSearchRoot, L"GC://%ws", pDNR->rItems[0].pName);


    hr = ADsGetObject(  pszSearchRoot,
                        IID_IDirectorySearch,
                        (void **)&pDSSearch);
    BAIL_ON_FAILURE(hr);

    if (!(pszUNCNameSearch = CreateEscapedDN(pszUNCName))) {
        dwRet = GetLastError();
        goto error;
    }

    wsprintf(szSearchPattern, L"(&(objectClass=printQueue)(uNCName=%ws))", pszUNCNameSearch);

    hr = pDSSearch->ExecuteSearch(
         szSearchPattern,
         pszAttributes,
         sizeof(pszAttributes)/sizeof *pszAttributes,
         &hSearchHandle);
    BAIL_ON_FAILURE(hr);


    hr = pDSSearch->GetNextRow(hSearchHandle);
    BAIL_ON_FAILURE(hr);


    while (hr != S_ADS_NOMORE_ROWS) {

        hr = pDSSearch->GetColumn(
                 hSearchHandle,
                 L"ADsPath",
                 &ADsPath
                 );

        if (hr == S_OK) {

            hr = pDSSearch->GetColumn(
                     hSearchHandle,
                     L"UNCName",
                     &UNCName
                     );

            if (hr == S_OK) {

                switch (dwAction) {
                    case PUBLISHPRINTER_QUERY:

                        if (!LoadString(hInst, IDS_DUPLICATE_PRINTQUEUE, szDuplicateFormat, COUNTOF(szDuplicateFormat))) {
                            dwRet = GetLastError();
                            goto error;
                        }

                        nSize = wcslen(szDuplicateFormat);
                        nSize += wcslen(ADsPath.pADsValues->DNString);
                        nSize += wcslen(pszTargetDN);
                        nSize = (nSize + 1)*sizeof(WCHAR);
                        if (!(pszDuplicate = (PWSTR) AllocSplMem(nSize))) {
                            dwRet = GetLastError();
                            goto error;
                        }

                        PWSTR   pszCanonicalSource;
                        PWSTR   pszCanonicalTarget;

                        pszCanonicalSource = pszCanonicalTarget = NULL;

                        FQDN2Canonical(ADsPath.pADsValues->DNString, &pszCanonicalSource);
                        FQDN2Canonical(pszTargetDN, &pszCanonicalTarget);

                        if (!pszCanonicalSource || !pszCanonicalTarget) {
                            wsprintf(pszDuplicate, szDuplicateFormat, ADsPath.pADsValues->DNString, pszTargetDN);
                        } else {
                            wsprintf(pszDuplicate, szDuplicateFormat, pszCanonicalSource, pszCanonicalTarget);
                        }

                        FreeSplStr(pszCanonicalSource);
                        FreeSplStr(pszCanonicalTarget);

                        if (!LoadString(hInst, IDS_DUPLICATE_PRINTQUEUE_TITLE, szDuplicateFormat, COUNTOF(szDuplicateFormat)))
                            goto error;

                        dwRet = MessageBox( hwnd,
                                            pszDuplicate,
                                            szDuplicateFormat,
                                            MB_YESNO);

                        bDeleteDuplicate = (dwRet == IDYES);
                        dwRet = (dwRet == IDYES) ? ERROR_SUCCESS : ERROR_CANCELLED;

                        pszDuplicate = NULL;
                        break;

                    case PUBLISHPRINTER_DELETE_DUPLICATES:
                        bDeleteDuplicate = TRUE;
                        break;

                    case PUBLISHPRINTER_FAIL_ON_DUPLICATE:
                        bDeleteDuplicate = FALSE;

                        if (ppszObjectDN) {
                            if (!(*ppszObjectDN = AllocGlobalStr(ADsPath.pADsValues->DNString))) {
                                dwRet = GetLastError();
                                goto error;
                            }
                        }

                        dwRet = ERROR_FILE_EXISTS;
                        break;

                    case PUBLISHPRINTER_IGNORE_DUPLICATES:
                        bDeleteDuplicate = FALSE;
                        break;

                    default:
                        bDeleteDuplicate = FALSE;
                        dwRet = ERROR_INVALID_PARAMETER;
                        break;
                }

                if (bDeleteDuplicate) {
                    hr = DeleteDSObject(ADsPath.pADsValues->DNString);                    

                    if ( hr == ERROR_DS_NO_SUCH_OBJECT ) {
                        hr = S_OK;
                    }
                }

                pDSSearch->FreeColumn(&UNCName);
            }

            pDSSearch->FreeColumn(&ADsPath);
        }

        if (dwRet != ERROR_SUCCESS || hr != S_OK)
                goto error;

        hr = pDSSearch->GetNextRow(hSearchHandle);
        BAIL_ON_FAILURE(hr);
    }


    hr = S_OK;


error:

    if (hr != S_OK)
        dwRet = ERROR_DS_UNAVAILABLE;

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    if (pszUNCNameSearch)
        FreeSplMem(pszUNCNameSearch);

    if (pDSSearch)
        pDSSearch->Release();

    if (pszSearchRoot)
        FreeSplMem(pszSearchRoot);

    if(pszDuplicate)
        FreeSplMem(pszDuplicate);

    return dwRet;
}



DWORD
MovePrintQueue(
    PCWSTR    pszObjectGUID,
    PCWSTR    pszNewContainer,    // Container path
    PCWSTR    pszNewCN            // Object CN
)
{
    PWSTR            pszCurrentContainer = NULL;
    PWSTR            pszCurrentCN = NULL;
    HRESULT            hr;
    IADsContainer    *pADsContainer = NULL;
    IDispatch        *pNewObject = NULL;


    // Get PublishPoint from GUID
    hr = GetPublishPointFromGUID(pszObjectGUID, &pszCurrentContainer, &pszCurrentCN);
    BAIL_ON_FAILURE(hr);

    if (pszCurrentContainer) {
        // Get container
        hr = ADsGetObject( pszCurrentContainer, IID_IADsContainer,    (void **) &pADsContainer);
        BAIL_ON_FAILURE(hr);


        // Move PrintQueue
        if (wcscmp(pszCurrentContainer, pszNewContainer)) {
            hr = pADsContainer->MoveHere((PWSTR) pszNewContainer, (PWSTR) pszNewCN, &pNewObject);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (pszCurrentContainer)
        FreeSplMem(pszCurrentContainer);

    if (pszCurrentCN)
        FreeSplMem(pszCurrentCN);

    if (pADsContainer)
        pADsContainer->Release();

    if (pNewObject)
        pNewObject->Release();

    return hr;
}


HRESULT
GetPublishPointFromGUID(
    PCWSTR   pszObjectGUID,
    PWSTR   *ppszDN,
    PWSTR   *ppszCN
)
{
    DWORD dwRet, nBytes, nChars;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;
    HRESULT hr = S_OK;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = (PWSTR) pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
                dwRet = ERROR_PATH_NOT_FOUND;
            else
                dwRet = pDNR->rItems[0].status;

            goto error;
        }


        // Separate DN into CN & PublishPoint
        // pDNR has form: CN=CommonName,DN...

        hr = FQDN2CNDN(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszCN, ppszDN);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

    if (FAILED(hr)) {
        FreeSplMem(*ppszCN);
        FreeSplMem(*ppszDN);
        *ppszCN = *ppszDN = NULL;
    }

    return hr;
}


DWORD
Bind2DS(
    HANDLE                  *phDS,
    DOMAIN_CONTROLLER_INFO  **ppDCI,
    ULONG                   Flags
)
{
    DWORD dwRet;

    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, Flags, ppDCI);
    if (dwRet == ERROR_SUCCESS) {

        if ((*ppDCI)->Flags & DS_DS_FLAG) {

            dwRet = DsBind (NULL, (*ppDCI)->DomainName, phDS);
            if (dwRet != ERROR_SUCCESS) {

                NetApiBufferFree(*ppDCI);
                *ppDCI = NULL;

                if (!(Flags & DS_FORCE_REDISCOVERY)) {
                    dwRet = Bind2DS(phDS, ppDCI, DS_FORCE_REDISCOVERY | Flags);
                }
            }
        } else {
            NetApiBufferFree(*ppDCI);
            *ppDCI = NULL;
            dwRet = ERROR_CANT_ACCESS_DOMAIN_INFO;
        }
    }

    return dwRet;
}



HRESULT
FQDN2CNDN(
    PWSTR   pszDCName,
    PWSTR   pszFQDN,
    PWSTR   *ppszCN,
    PWSTR   *ppszDN
)
{
    IADs    *pADs = NULL;
    PWSTR   pszCN = NULL;
    PWSTR   pszDN = NULL;
    PWSTR   pszLDAPPath = NULL;
    HRESULT hr;

    // Get LDAP path to object
    hr = BuildLDAPPath(pszDCName, pszFQDN, &pszLDAPPath);
    BAIL_ON_FAILURE(hr);

    // Get DN
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->get_Parent(&pszDN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszDN = AllocSplStr(pszDN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    // Get CN
    hr = pADs->get_Name(&pszCN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszCN = AllocSplStr(pszCN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (pszCN)
        SysFreeString(pszCN);

    if (pszDN)
        SysFreeString(pszDN);

    FreeSplStr(pszLDAPPath);

    if (FAILED(hr)) {
        FreeSplStr(*ppszCN);
        FreeSplStr(*ppszDN);
    }

    return hr;
}


HRESULT
BuildLDAPPath(
    PWSTR   pszDC,
    PWSTR   pszFQDN,
    PWSTR   *ppszLDAPPath
)
{
    DWORD   nBytes;
    HRESULT hr;

    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pszDC) + wcslen(pszFQDN) + 9)*sizeof(WCHAR);

    if (!(*ppszLDAPPath = (PWSTR) AllocSplMem(nBytes))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    wsprintf(*ppszLDAPPath, L"LDAP://%ws/%ws", pszDC,pszFQDN);

error:

    return hr;
}    

DWORD
UNC2Printer(
    PCWSTR pszUNC,
    PWSTR *ppszPrinter
)
{
    PWSTR psz;
    
    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcsrchr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    if (!(*ppszPrinter = (PWSTR) AllocSplStr(psz + 1)))
        return GetLastError();

    return ERROR_SUCCESS;
}

DWORD
UNC2Server(
    PCWSTR pszUNC,
    PWSTR *ppszServer
)
{
    PWSTR psz;
    DWORD cb;
    DWORD nChars;

    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcschr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    cb = (DWORD) ((ULONG_PTR) psz - (ULONG_PTR) pszUNC + sizeof *psz);

    if (!(*ppszServer = (PWSTR) AllocSplMem(cb)))
        return GetLastError();


    nChars = (DWORD) (psz - pszUNC);
    wcsncpy(*ppszServer, pszUNC, nChars);
    (*ppszServer)[nChars] = L'\0';

    return ERROR_SUCCESS;
}


//  Utility routine to report if a printer is color or monochrome

BOOL
ThisIsAColorPrinter(
    LPCTSTR lpstrName
)
{
    HANDLE      hPrinter = NULL;
    LPTSTR      lpstrMe = const_cast <LPTSTR> (lpstrName);
    BOOL        bReturn = FALSE;
    LPDEVMODE   lpdm = NULL;
    long        lcbNeeded;

    if  (!OpenPrinter(lpstrMe, &hPrinter, NULL)) {
        goto error;
    }


    //  First, use DocumentProperties to find the correct DEVMODE size- we
    //  must use the DEVMODE to force color on, in case the user's defaults
    //  have turned it off...

    lcbNeeded = DocumentProperties(NULL, hPrinter, lpstrMe, NULL, NULL, 0);
    if  (lcbNeeded <= 0) {
        goto error;
    }

    lpdm = (LPDEVMODE) AllocSplMem(lcbNeeded);
    if (lpdm) {

        lpdm->dmSize = sizeof(DEVMODE);
        lpdm->dmFields = DM_COLOR;
        lpdm->dmColor = DMCOLOR_COLOR;

        if (IDOK == DocumentProperties(NULL, hPrinter, lpstrMe, lpdm, lpdm,
            DM_IN_BUFFER | DM_OUT_BUFFER)) {

            //  Finally, we can create the DC!
            HDC hdcThis = CreateDC(NULL, lpstrName, NULL, lpdm);

            if  (hdcThis) {
                bReturn =  2 < (unsigned) GetDeviceCaps(hdcThis, NUMCOLORS);
                DeleteDC(hdcThis);
            }
        }
    }


error:

    FreeSplMem(lpdm);

    if (hPrinter)
        ClosePrinter(hPrinter);

    return  bReturn;
}




HRESULT
DeleteDSObject(
    PWSTR    pszADsPath
)
{
    BSTR             bstrCommonName = NULL;
    PWSTR            pszParent = NULL;
    PWSTR            pszCN = NULL;
    PWSTR            pszLDAPPath = NULL;
    IADs             *pADs = NULL;
    IADsContainer    *pContainer = NULL;
    DWORD            cb;
    HRESULT          hr;
    DWORD            nSize;

    if(pszADsPath && !_wcsnicmp(pszADsPath , L"GC://" , 5)){

        //
        // Build LDAP://..... path from GC://.... path
        // 3 comes from len(LDAP) - len(GC) + len(string_terminator)
        //
        nSize = (wcslen(pszADsPath) + 3)* sizeof(WCHAR);                        
        if (!(pszLDAPPath = (PWSTR) AllocSplMem(nSize))) {
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
        }
        wsprintf(pszLDAPPath, L"LDAP%ws", pszADsPath + 2);
    
    }

    // Get PrintQueue object
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);


    // Get the CommonName & don't forget the "CN="
    hr = get_BSTR_Property(pADs, L"cn", &bstrCommonName);
    BAIL_ON_FAILURE(hr);

    cb = (SysStringLen(bstrCommonName) + 4)*sizeof(WCHAR);

    if (!(pszCN = (PWSTR) AllocSplMem(cb))) {
        hr = dw2hr(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszCN, L"CN=");
    wcscat(pszCN, bstrCommonName);


    // Get the Parent ADsPath
    hr = pADs->get_Parent(&pszParent);
    BAIL_ON_FAILURE(hr);


    // Get the Parent object
    hr = ADsGetObject(  pszParent,
                        IID_IADsContainer,
                        (void **) &pContainer);
    BAIL_ON_FAILURE(hr);

    // Delete the printqueue
    hr = pContainer->Delete(SPLDS_PRINTER_CLASS, pszCN);


error:

    if (pADs)
        pADs->Release();

    if (pContainer)
        pContainer->Release();

    if (bstrCommonName)
        SysFreeString(bstrCommonName);

    if (pszParent)
        SysFreeString(pszParent);

    if (pszCN)
        FreeSplMem(pszCN);

    if(pszLDAPPath)
        FreeSplMem(pszLDAPPath);

    return hr;
}

DWORD
GetCommonName(
    HANDLE hPrinter,
    PWSTR *ppszCommonName
)
{
    DWORD           nBytes;
    PWSTR           psz;
    PPRINTER_INFO_2 pInfo2 = NULL;
    DWORD           cbNeeded;
    DWORD           dwRet;
    PWSTR           pszServerName, pszPrinterName;


    // Get Server & Share names
    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                dwRet = GetLastError();
                goto error;
        }

        if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
                dwRet = GetLastError();
                goto error;
        }

        if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded)) {
                dwRet = GetLastError();
                goto error;
        }
        pszServerName = pInfo2->pServerName;
        if (!pszServerName) {
            DBGMSG(DBG_ERROR,("GetPrinter returned NULL ServerName"));
            dwRet = ERROR_INVALID_DATA;
            goto error;
        }

        pszPrinterName = pInfo2->pShareName ? pInfo2->pShareName : pInfo2->pPrinterName;

    } else {
        // We should never get here.  If we do, something is wrong
        // with the server and we have no meaningful error to report,
        // so just claim invalid data.
        DBGMSG(DBG_ERROR,("INVALID GetPrinter return"));
        dwRet = ERROR_INVALID_DATA;
        goto error;
    }

    // "CN=Server-Printer"
    nBytes = (wcslen(pszPrinterName) + wcslen(pszServerName) + 5)*sizeof(WCHAR);
    if (!(*ppszCommonName = psz = (PWSTR) AllocSplMem(nBytes))) {
        dwRet = GetLastError();
        goto error;
    }

    // CN=
    wcscpy(psz, L"CN=");

    // Server
    for(psz += 3, pszServerName += 2 ; *pszServerName    ; ++psz, ++pszServerName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszServerName) ? TEXT('_') : *pszServerName;
    }
    *psz = L'-';

    // Printer
    for(++psz; *pszPrinterName ; ++psz, ++pszPrinterName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszPrinterName) ? TEXT('_') : *pszPrinterName;
    }

    // NULL
    *psz = *pszPrinterName;

    // DS only allows 64 characters in CN attribute, so shorten this if needed
    if (wcslen(pszPrinterName) > 62)
        pszPrinterName[63] = NULL;


error:

    FreeSplMem(pInfo2);

    return ERROR_SUCCESS;
}


PWSTR
AllocGlobalStr(
    PWSTR pszIn
)
{
    DWORD cb;
    PWSTR pszOut = NULL;

    if (!pszIn)
        return NULL;

    cb = (wcslen(pszIn) + 1)*sizeof *pszIn;

    if (pszOut = (PWSTR) GlobalAlloc(GMEM_FIXED, cb))
        wcscpy(pszOut, pszIn);

    return pszOut;
}

VOID
FreeGlobalStr(
    PWSTR pszIn
)
{
    if (pszIn)
        GlobalFree(pszIn);
}




DWORD
GetADsPathFromGUID(
    PCWSTR   pszObjectGUID,
    PWSTR   *ppszDN
)
{
    DWORD dwRet, nBytes, nChars;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = (PWSTR) pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
                dwRet = ERROR_PATH_NOT_FOUND;
            else
                dwRet = pDNR->rItems[0].status;

            goto error;
        }

        // LDAP:// + pDCName + / + pName + 1
        nBytes = (wcslen(pDCI->DomainControllerName + 2) + 
                  wcslen(pDNR->rItems[0].pName) + 9)*sizeof(WCHAR);

        if (!(*ppszDN = (PWSTR) AllocSplMem(nBytes))) {
            dwRet = GetLastError();
            goto error;
        }
        wsprintf(*ppszDN, L"LDAP://%ws/%ws", pDCI->DomainControllerName + 2,pDNR->rItems[0].pName);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        FreeSplMem(*ppszDN);
        *ppszDN = NULL;
    }

    return dwRet;
}



PWSTR
GetDNWithServer(
    PCWSTR  pszDNIn
)
{
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    DWORD                   nBytes;
    PWSTR                   pszDNOut = NULL;
    DWORD                   dwRet;

    // Convert pszDNIn into a DN with the DC name, if it isn't already there

    // Check for existing DC name or badly formed name
    if (wcsncmp(pszDNIn, L"LDAP://", 7) || wcschr(pszDNIn + 7, L'/'))
        goto error;

    // Get DC name
    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, 0, &pDCI);
    if (dwRet != ERROR_SUCCESS) {
        goto error;
    }


    // Build name
    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pDCI->DomainControllerName + 2) + 
              wcslen(pszDNIn + 7) + 9)*sizeof(WCHAR);

    if (!(pszDNOut = (PWSTR) AllocSplMem(nBytes)))
        goto error;

    wsprintf(pszDNOut, L"LDAP://%ws/%ws", pDCI->DomainControllerName + 2,pszDNIn + 7);


error:

    if (pDCI)
        NetApiBufferFree(pDCI);

    return pszDNOut;
}


DWORD
hr2dw(
    HRESULT hr
)
{
    if (SUCCEEDED(hr))
        return ERROR_SUCCESS;

    if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        return HRESULT_CODE(hr);

    if (hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        return ERROR_DS_UNAVAILABLE;

    return hr;
}



PWSTR
DelimString2MultiSz(
    PWSTR pszIn,
    WCHAR wcDelim
)
{
    DWORD cb;
    PWSTR pszOut = NULL;

    // pszIn looks like L"xxx,xxxx,xxx,xxx"
    // the output looks like L"xxx0xxxx0xxx0xxx00"
    // Replace all wcDelim characters with NULLs & add a NULL

    if (!pszIn || !*pszIn)
        return NULL;

    cb = (wcslen(pszIn) + 2)*sizeof *pszIn;

    pszOut = (PWSTR) AllocSplMem(cb);

    if (pszOut) {

        DWORD i;

        for (i = 0 ; pszIn[i] ; ++i) {
            pszOut[i] = (pszIn[i] == wcDelim) ? L'\0' : pszIn[i];
        }
        pszOut[i] = pszOut[i + 1] = L'\0';
    }

    return pszOut;
}


HRESULT
GetPrinterInfo2(
    HANDLE          hPrinter,
    PPRINTER_INFO_2 *ppInfo2
)
{
    HRESULT hr = S_OK;
    DWORD   cbNeeded;

    // Get PRINTER_INFO_2 properties
    if (!GetPrinter(hPrinter, 2, (PBYTE) *ppInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!(*ppInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    
        if (!GetPrinter(hPrinter, 2, (PBYTE) *ppInfo2, cbNeeded, &cbNeeded)) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    }

error:
    
    return hr;
}



DWORD
FQDN2Canonical(
    PWSTR pszIn,
    PWSTR *ppszOut
)
{
    DWORD                               dwRet = ERROR_SUCCESS;
    DS_NAME_RESULT                      *pDNR = NULL;
    PWSTR                               pNames[2];


    *ppszOut = NULL;

    if (wcslen(pszIn) < 8) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    pNames[0] = pszIn + 7;  // Input string is LDAP://CN=...  Strip off the LDAP:// portion
    pNames[1] = NULL;

    if (!(DsCrackNames(
                    INVALID_HANDLE_VALUE,
                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                    DS_FQDN_1779_NAME,
                    DS_CANONICAL_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDNR->rItems[0].status == DS_NAME_ERROR_RESOLVING)
            dwRet = ERROR_PATH_NOT_FOUND;
        else
            dwRet = pDNR->rItems[0].status;

        goto error;
    }

    *ppszOut = AllocSplStr(pDNR->rItems[0].pName);
    
error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    return dwRet;
}


BOOL
DevCapMultiSz(
    PWSTR   pszUNCName,
    IADs    *pPrintQueue,
    WORD    fwCapability,
    DWORD   dwElementBytes,
    PWSTR   pszAttributeName
)
{
    DWORD dwResult, cbBytes;
    PWSTR pszDevCapBuffer = NULL;
    PWSTR pszRegData = NULL;
    HRESULT hr;


    _try {
        dwResult = DeviceCapabilities(  pszUNCName,
                                        NULL,
                                        fwCapability,
                                        NULL,
                                        NULL);

        if (dwResult != GDI_ERROR) {
            pszDevCapBuffer = (PWSTR) AllocSplMem(dwResult*dwElementBytes*sizeof(WCHAR));

            if (pszDevCapBuffer) {
                dwResult = DeviceCapabilities(  pszUNCName,
                                                NULL,
                                                fwCapability,
                                                pszDevCapBuffer,
                                                NULL);

                if (dwResult != GDI_ERROR) {
                    if (!(pszRegData = DevCapStrings2MultiSz(pszDevCapBuffer, dwResult, dwElementBytes, &cbBytes))) {
                        dwResult = GDI_ERROR;
                    }
                }
            } else {
                dwResult = GDI_ERROR;
            }
        }
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            pszAttributeName,
                            REG_MULTI_SZ,
                            (PBYTE) pszRegData);

        if (FAILED(hr)) {
            SetLastError(HRESULT_CODE(hr));
            dwResult = GDI_ERROR;
        }
    }

    FreeSplStr(pszDevCapBuffer);
    FreeSplStr(pszRegData);
    
    return dwResult != GDI_ERROR;
}


PWSTR
DevCapStrings2MultiSz(
    PWSTR   pszDevCapString,
    DWORD   nDevCapStrings,
    DWORD   dwDevCapStringLength,
    DWORD   *pcbBytes
)
{
    DWORD   i, cbBytes, cbSize;
    PWSTR   pszMultiSz = NULL;
    PWSTR   pStr;


    if (!pszDevCapString || !pcbBytes)
        return NULL;

    *pcbBytes = 0;

    //
    // Devcap buffers may not be NULL terminated
    //
    cbBytes = (nDevCapStrings*(dwDevCapStringLength + 1) + 1)*sizeof(WCHAR);


    //
    // Allocate and copy
    //
    if (pszMultiSz = (PWSTR) AllocSplMem(cbBytes)) {
        for(i = 0, pStr = pszMultiSz, cbBytes = 0 ; i < nDevCapStrings ; ++i, pStr += cbSize, cbBytes +=cbSize ) {
            wcsncpy(pStr, pszDevCapString + i*dwDevCapStringLength, dwDevCapStringLength);
            cbSize = *pStr ? wcslen(pStr) + 1 : 0;
        }
        *pStr = L'\0';
        *pcbBytes = (cbBytes + 1) * sizeof(WCHAR);
    }

    return pszMultiSz;
}


HRESULT
MachineIsInMyForest(
    PWSTR   pszMachineName
)
{
    DWORD                               dwRet;
    HRESULT                             hr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pMachineRole = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pMyRole = NULL;

    dwRet = DsRoleGetPrimaryDomainInformation(  pszMachineName,
                                                DsRolePrimaryDomainInfoBasic, 
                                                (PBYTE *) &pMachineRole);
    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        goto error;
    }

    dwRet = DsRoleGetPrimaryDomainInformation(  NULL,
                                                DsRolePrimaryDomainInfoBasic, 
                                                (PBYTE *) &pMyRole);
    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        goto error;
    }

    dwRet = DnsNameCompare_W(pMachineRole->DomainForestName, pMyRole->DomainForestName);
    hr = MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIN32, dwRet);


error:

    if (pMachineRole)
        DsRoleFreeMemory((PVOID) pMachineRole);

    if (pMyRole)
        DsRoleFreeMemory((PVOID) pMyRole);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\defprn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    defprn.c

Abstract:

    Default printer.

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "defprn.h"

//
// The buffer size needed to hold the maximum printer name.
//
enum { kPrinterBufMax_  = MAX_UNC_PRINTER_NAME + 1 };

/*++

Name:

    IsPrinterDefault

Description:

    The IsPrinterDefault function checks if the specified
    printer is the default printer.  If the printer name
    specified is NULL or the NULL string then it returns
    success if there is a default printer.

Arguments:

    pszPrinter - Pointer a zero terminated string that
                 contains the printer name or NULL or the
                 NULL string.

Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get
    extended error information, call GetLastError.

Remarks:

    If a NULL is passed as the printer name this function
    will indicate if there is any default printer set.

--*/
BOOL
IsPrinterDefaultW(
    IN LPCTSTR  pszPrinter
    )
{
    BOOL    bRetval         = FALSE;
    DWORD   dwDefaultSize   = kPrinterBufMax_;
    PTSTR   pszDefault      = NULL;

    pszDefault = AllocMem(dwDefaultSize * sizeof(TCHAR));

    if (pszDefault)
    {
        //
        // Get the default printer.
        //
        bRetval = GetDefaultPrinterW( pszDefault, &dwDefaultSize );

        if( bRetval )
        {
            if( pszPrinter && *pszPrinter )
            {
                //
                // Check for a match.
                //
                bRetval =  !_tcsicmp( pszDefault, pszPrinter ) ? TRUE : FALSE;
            }
            else
            {
                bRetval = TRUE;
            }
        }
    }
    else
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    FreeMem(pszDefault);

    return bRetval;
}


/*++

Name:

    GetDefaultPrinter

Description:

    The GetDefaultPrinter function retrieves the printer
    name of the current default printer.

Arguments:

    pBuffer     - Points to a buffer to receive the null-terminated
                  character string containing the default printer name.
                  This parameter may be null if the caller want the size of
                  default printer name.

    pcchBuffer   - Points to a variable that specifies the maximum size,
                  in characters, of the buffer. This value should be
                  large enough to contain 2 + INTERNET_MAX_HOST_NAME_LENGTH
                  + 1 MAX_PATH + 1 characters.

Return Value:

    If the function succeeds, the return value is nonzero and
    the variable pointed to by the pnSize parameter contains the
    number of characters copied to the destination buffer,
    including the terminating null character.

    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

Notes:

    If this function fails with a last error of ERROR_INSUFFICIENT_BUFFER
    the variable pointed to by pcchBuffer is returned with the number of
    characters needed to hold the printer name including the
    terminating null character.

--*/
BOOL
GetDefaultPrinterW(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval     = FALSE;
    LPTSTR  psz         = NULL;
    UINT    uLen        = 0;
    PTSTR   pszDefault  = NULL;
    UINT    cchDefault  = kPrinterBufMax_+MAX_PATH;

    //
    // Validate the size parameter.
    //
    if( !pcchBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return bRetval;
    }

    //
    // Allocate the temp default printer buffer from the heap.
    //
    pszDefault = AllocMem(cchDefault * sizeof(TCHAR));

    if (!pszDefault)
    {
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Not enough memory to allocate default printer buffer.\n" ) );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return bRetval;
    }

    //
    // Get the devices key, which is the default device or printer.
    //
    if( DefPrnGetProfileString( szWindows, szDevice, pszDefault, cchDefault ) )
    {
        //
        // The string is returned in the form.
        // "printer_name,winspool,Ne00:" now convert it to
        // printer_name
        //
        psz = _tcschr( pszDefault, TEXT( ',' ));

        //
        // Set the comma to a null.
        //
        if( psz )
        {
            *psz = 0;

            //
            // Check if the return buffer has enough room for the printer name.
            //
            uLen = _tcslen( pszDefault );

            if( uLen < *pcchBuffer && pszBuffer )
            {
                //
                // Copy the default printer name to the prvided buffer.
                //
                _tcscpy( pszBuffer, pszDefault );

                bRetval = TRUE;

                DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );
            }
            else
            {
                DBGMSG( DBG_WARN,( "GetDefaultPrinter: buffer too small.\n" ) );
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }

            //
            // Return back the size of the default printer name.
            //
            *pcchBuffer = uLen + 1;
        }
        else
        {
            DBGMSG( DBG_WARN,( "GetDefaultPrinter: comma not found in printer name in devices section.\n" ) );
            SetLastError( ERROR_INVALID_NAME );
        }
    }
    else
    {
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: failed with %d Last error %d.\n", bRetval, GetLastError() ) );
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: No default printer.\n" ) );
        SetLastError( ERROR_FILE_NOT_FOUND );
    }

    //
    // Release any allocated memory, note FreeMem deals with a NULL pointer.
    //
    FreeMem(pszDefault);

    return bRetval;
}

/*++

Name:

    SetDefaultPrinter

Description:

    The SetDefaultPrinter function set the printer name to
    be used as the default printer.

Arguments:

    pPrinter    - Points to a null-terminated character string
                  that specifies the name of the default printer.
                  This parameter may be NULL or the NULL string in
                  which case this function will set the first printer
                  enumerated from the print sub system as the default
                  printer, if a default printer does not already exists.

Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

--*/
BOOL
SetDefaultPrinterW(
    IN LPCTSTR pszPrinter
    )
{
    PTSTR pszDefault    = NULL;
    PTSTR pszAnyPrinter = NULL;
    PTSTR pszBuffer     = NULL;
    UINT  cchDefault    = kPrinterBufMax_;
    UINT  cchAnyPrinter = kPrinterBufMax_;
    BOOL  bRetval       = FALSE;

    //
    // This calculation is large to accomodate the max printer name
    // plus the comma plus the processor name and port name.
    //
    UINT  cchBuffer     = kPrinterBufMax_+kPrinterBufMax_+1;

    //
    // Avoid broadcasts as much as possible.  See if the printer
    // is already the default, and don't do anything if it is.
    //
    if( IsPrinterDefaultW( pszPrinter ) )
    {
        DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: " TSTR " already the default printer.\n", pszPrinter ));
        bRetval = TRUE;
        goto Cleanup;
    }

    //
    // Allocate the temp default printer buffer from the heap.
    //
    pszDefault      = AllocMem(cchDefault * sizeof(TCHAR));
    pszAnyPrinter   = AllocMem(cchAnyPrinter * sizeof(TCHAR));
    pszBuffer       = AllocMem(cchBuffer * sizeof(TCHAR));

    if (!pszDefault || !pszAnyPrinter || !pszBuffer)
    {
        DBGMSG( DBG_TRACE,( "SetDefaultPrinter: Not enough memory for temp buffers.\n" ) );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto Cleanup;
    }

    //
    // If the printer name was not specified, get any printer from the devices section.
    //
    if( !pszPrinter || !*pszPrinter )
    {
        //
        // A printer name was not specified i.e. a NULL name or NULL string was passed then fetch
        // the first printer from the devices section and make this the default printer.
        //
        if( !DefPrnGetProfileString( szDevices, NULL, pszAnyPrinter, cchAnyPrinter ) )
        {
            DBGMSG( DBG_WARN, ( "SetDefaultPrinter: DefPrnGetProfileString failed, last error %d any printer not available.\n", GetLastError() ) );
            SetLastError( ERROR_INVALID_PRINTER_NAME );
            goto Cleanup;
        }
        else
        {
            pszPrinter = pszAnyPrinter;
        }
    }
    else
    {
        //
        // If the given name is not in the devices list then this function may have been passed
        // either a local share name a fully qualified local printer name a fully qualified
        // printer share name
        //
        if( !DefPrnGetProfileString( szDevices, pszPrinter, pszDefault, cchDefault ) )
        {
            //
            // Get the actual printer name, see bGetActualPrinterName for details.
            //
            if( bGetActualPrinterName( pszPrinter, pszAnyPrinter, &cchAnyPrinter ))
            {
                //
                // Point to the actual printer name.
                //
                pszPrinter = pszAnyPrinter;

                //
                // Avoid broadcasts as much as possible.  See if the printer
                // is already the default, and don't do anything if it is.
                //
                if( IsPrinterDefaultW( pszPrinter ) )
                {
                    DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: " TSTR " already the default printer.\n", pszPrinter ));
                    bRetval = TRUE;
                    goto Cleanup;
                }
            }
            else
            {
                DBGMSG( DBG_WARN, ( "SetDefaultPrinter: bGetActualPrinterName failed, last error %d " TSTR "\n", GetLastError(), pszPrinter ) );

                //
                // bGetActualPrinterName sets the last error on failure.
                //
                goto Cleanup;
            }
        }
    }

    //
    // Get the default string and check if the provided printer name is valid.
    //
    if( !DefPrnGetProfileString( szDevices, pszPrinter, pszDefault, cchDefault ) )
    {
        DBGMSG( DBG_WARN, ( "SetDefaultPrinter: DefPrnGetProfileString failed, last error %d " TSTR " not in devices section.\n", GetLastError(), pszPrinter ) );
        SetLastError( ERROR_INVALID_PRINTER_NAME );
        goto Cleanup;
    }

    //
    // Build the default printer string.  This call should not fail since we have allocated
    // pszBuffer to a size that should contain the printer name plus the comma plus the port name.
    //
    if (StrNCatBuff( pszBuffer,
                     cchBuffer,
                     pszPrinter,
                     szComma,
                     pszDefault,
                     NULL ) != ERROR_SUCCESS)
    {
        //
        // Set the last error to some error value, however, it cannot be set to ERROR_INSUFFICIENT_BUFFER
        // this error code implies the caller provided buffer is too small.  StrNCatBuff would only fail because
        // because of some internal error or the registry was hacked with a really large printer name.
        //
        DBGMSG( DBG_ERROR, ( "SetDefaultPrinter: Buffer size too small, this should not fail.\n" ) );
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }

    //
    // Set the default printer string in the registry.
    //
    if( !DefPrnWriteProfileString( szWindows, szDevice, pszBuffer ) )
    {
        DBGMSG( DBG_WARN, ( "SetDefaultPrinter: WriteProfileString failed, last error %d.\n", GetLastError() ) );
        SetLastError( ERROR_CANTWRITE );
        goto Cleanup;
    }

    //
    // Tell the world and make everyone flash.
    //
    SendNotifyMessage( HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM)szWindows );

    bRetval = TRUE;

    DBGMSG( DBG_TRACE, ( "SetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );

Cleanup:

    //
    // Release any allocated memory, note FreeMem deals with a NULL pointer.
    //
    FreeMem(pszDefault);
    FreeMem(pszAnyPrinter);
    FreeMem(pszBuffer);

    return bRetval;
}

/*++

Name:

    bGetActualPrinterName

Description:

    This routine converts the given printer name or printer name alias to
    the actual printer name.

Arguments:

    pszPrinter  - Points to a null-terminated character string
                  that specifies the name of printer.

    pszBuffer   - pointer to a buffer that recieves the actual
                  printer name on return if this function is successful.

    pcchBuffer  - Points to a variable that specifies the maximum size,
                  in characters of pszBuffer on input, on output this
                  argument contains the number of characters copied into
                  pszBuffer, not including the NULL terminator.

Return Value:

    If the function succeeds, the return value TRUE
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
bGetActualPrinterName(
    IN      LPCTSTR  pszPrinter,
    IN      LPTSTR   pszBuffer,
    IN OUT  UINT     *pcchBuffer
    )
{
    HANDLE  hPrinter    = NULL;
    BOOL    bStatus     = FALSE;

    SPLASSERT( pszPrinter );
    SPLASSERT( pszBuffer );
    SPLASSERT( pcchBuffer );

    //
    // Open the printer for default access, all we need is read.
    //
    bStatus = OpenPrinter( (LPTSTR)pszPrinter, &hPrinter, NULL );

    if (bStatus)
    {
        DWORD           cbNeeded        = 0;
        DWORD           cbReturned      = 0;
        PRINTER_INFO_4  *pInfo          = NULL;

        //
        // Get the printer info 4 size.
        //
        bStatus = GetPrinter( hPrinter, 4, NULL, 0, &cbNeeded );

        if (!bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Allocate the printer info 4 buffer.
            //
            pInfo = (PRINTER_INFO_4 *)LocalAlloc( LMEM_FIXED, cbNeeded );

            if (pInfo)
            {
                //
                // Get the printer name and attributes to determine if this printer is a local
                // or a remote printer connection.
                //
                bStatus = GetPrinter( hPrinter, 4, (LPBYTE)pInfo, cbNeeded, &cbReturned );

                if (bStatus)
                {
                    DBGMSG( DBG_TRACE, ( "bGetActualPrinterName: Name: " TSTR " Actual: " TSTR "\n", pszPrinter, pInfo->pPrinterName ) );

                    //
                    // Get the printer name, the spooler will strip the local-server
                    // name off the full printer name.
                    //
                    // Given:                       Result:
                    // printer                      printer
                    // sharename                    printer
                    // \\local-server\printer       printer
                    // \\local-server\sharename     printer
                    // \\remote-server\printer      \\remote-server\printer
                    // \\remote-server\sharename    \\remote-server\printer
                    //
                    pszPrinter = pInfo->pPrinterName;

                    //
                    // If we have a valid printer name and the provided buffer is
                    // large enought to hold the printer name then copy the
                    // actual printer name to the provided buffer.
                    //
                    bStatus = !!pszPrinter;

                    if (bStatus)
                    {
                        UINT uLength = _tcslen( pszPrinter );

                        //
                        // Verify there is enough room in the buffer.
                        //
                        if (uLength < *pcchBuffer)
                        {
                            //
                            // Copy the printer name to the provided buffer.
                            //
                            _tcscpy( pszBuffer, pszPrinter );
                        }
                        else
                        {
                            bStatus = FALSE;
                            SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        }

                        //
                        // Return the real length of the printer name
                        // not including the null terminator.
                        //
                        *pcchBuffer = uLength;
                    }
                }

                LocalFree( pInfo );
            }
        }

        ClosePrinter( hPrinter );
    }

    return bStatus;
}

/*++

Name:

    DefPrnGetProfileString

Description:

    Get the specified string from the users profile.  The uses profile is located
    in the current users hive in the following registry path.

    HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion

Arguments:

    pKey            - pointer to key name to open.
    pValue          - pointer to value to open, may be NULL
    pReturnedString - pointer to buffer where to store string
    nSize           - size of the buffer in characters

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
DefPrnGetProfileString(
    IN PCWSTR   pKey,
    IN PCWSTR   pValue,
    IN PWSTR    pReturnedString,
    IN DWORD    nSize
    )
{
    DWORD   Retval  = ERROR_SUCCESS;
    HKEY    hUser   = NULL;
    HKEY    hKey    = NULL;
    PCWSTR  pPath   = NULL;
    DWORD   cbSize  = 0;

    //
    // Do some basic parameter validation.
    //
    Retval = pKey && pReturnedString ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Build the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        cbSize = nSize * sizeof(*pReturnedString);

        Retval = StrCatAlloc(&pPath, gszUserProfileRegPath, szSlash, pKey, NULL);
    }

    //
    // Open the current user key, handle the case we are running in an inpersonating thread.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenCurrentUser(KEY_READ, &hUser);
    }

    //
    // Open the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenKeyEx(hUser, pPath, 0, KEY_READ, &hKey);
    }

    //
    // Read the value, in the case the value name is null we get the name of the
    // first named value.  Note if there is no named values the RegEnumValue api
    // will return success because it is returning the name if the unnamed value.
    // In this case we fail the call since no data was returned.
    //
    if (Retval == ERROR_SUCCESS)
    {
        if (!pValue)
        {
            Retval = RegEnumValue(hKey, 0, pReturnedString, &nSize, NULL, NULL, NULL, NULL);

            if (Retval == ERROR_SUCCESS && !*pReturnedString)
            {
                Retval = ERROR_NO_DATA;
            }
        }
        else
        {
            Retval = RegQueryValueEx(hKey, pValue, NULL, NULL, (PBYTE)pReturnedString, &cbSize);
        }
    }

    //
    // Clean up all allocated resources.
    //
    FreeSplMem((PWSTR)pPath);

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (hUser)
    {
        RegCloseKey(hUser);
    }

    if (Retval != ERROR_SUCCESS)
    {
        SetLastError(Retval);
    }

    return Retval == ERROR_SUCCESS;
}

/*++

Name:

    DefPrnWriteProfileString

Description:

    Writes the specified string to the users profile.

Arguments:

    pKey    - pointer to key name to open.
    pValue  - pointer to value to write to, may be NULL
    pString - pointer to string to write

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. Use GetLastError to
    get extended error information.

--*/
BOOL
DefPrnWriteProfileString(
    IN PCWSTR pKey,
    IN PCWSTR pValue,
    IN PCWSTR pString
    )
{
    DWORD   Retval  = ERROR_SUCCESS;
    DWORD   nSize   = 0;
    HKEY    hUser   = NULL;
    HKEY    hKey    = NULL;
    PCWSTR  pPath   = NULL;

    //
    // Do some basic parameter validation.
    //
    Retval = pKey && pString ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;

    //
    // Build the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        nSize = (wcslen(pString) + 1) * sizeof(*pString);

        Retval = StrCatAlloc(&pPath, gszUserProfileRegPath, szSlash, pKey, NULL);
    }

    //
    // Open the current user key, handle the case we are running in an inpersonating thread.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegOpenCurrentUser(KEY_WRITE, &hUser);
    }

    //
    // Open the full registry path.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval= RegOpenKeyEx(hUser, pPath, 0, KEY_WRITE, &hKey);
    }

    //
    // Set the string value data.
    //
    if (Retval == ERROR_SUCCESS)
    {
        Retval = RegSetValueEx(hKey, pValue, 0, REG_SZ, (LPBYTE)pString, nSize);
    }

    //
    // Clean up all allocated resources.
    //
    FreeSplMem((PWSTR)pPath);

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (hUser)
    {
        RegCloseKey(hUser);
    }

    if (Retval != ERROR_SUCCESS)
    {
        SetLastError(Retval);
    }

    return Retval == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\handle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    handle.c

Abstract:

    Contains all functions related to the maintanence of print handles.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

DWORD
OpenPrinterRPC(
    PSPOOL pSpool
    );

BOOL
ClosePrinterRPC(
    IN  PSPOOL      pSpool,
    IN  BOOL        bRevalidate
    );

BOOL
ClosePrinterContextHandle(
    HANDLE hPrinter
    );

BOOL
ClosePrinterWorker(
    PSPOOL pSpool
    );

DWORD  gcClientHandle = 0;

#ifdef DBG_TRACE_HANDLE
PSPOOL gpFirstSpool = NULL;
#endif


EProtectResult
eProtectHandle(
    IN HANDLE hPrinter,
    IN BOOL bClose
    )

/*++

Routine Description:

    Protect a print handle so that it will not be deleted while it is
    being used.  If this is called by the Close routine, then this call
    returns whether the Close should continue or be aborted.

    Note: This only provides close protection--it does not guard against
    simultaneous access by non-close operations.

    There must always be a matching vUnprotect call when the callee is
    done with the handle.

Arguments:

    hPrinter - pSpool to protect.

    bClose - If TRUE, indicates that the callee wants to close the handle.
        (Generally called by ClosePrinter only.)  The return value will
        indicate whether the calleeis allowed to close the printer.

Return Value:

    kProtectHandleSuccess - Call succeeded; printer handle can be used normally.

    kProtectHandleInvalid - Handle is invalid; call failed.

    kProtectHandlePendingDeletion - This only occurs when bClose is TRUE.  The
        Operation on handle is in process, and the close will happen when the
        other thread has completed.

    LastError only set if handle kProtectHandleInvalid is returned.

--*/

{
    EProtectResult eResult = kProtectHandleInvalid;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    vEnterSem();

    try {
        if( pSpool &&
            (pSpool->signature == SP_SIGNATURE ) &&
            !( pSpool->Status & ( SPOOL_STATUS_CLOSE |
                                  SPOOL_STATUS_PENDING_DELETION ))){

            //
            // Valid handle.
            //
            eResult = kProtectHandleSuccess;

        } else {

            DBGMSG( DBG_WARN,
                    ( "Bad hPrinter %x %x\n",
                      pSpool,
                      pSpool ? pSpool->signature : 0 ));
        }

    } except( EXCEPTION_EXECUTE_HANDLER ){

        DBGMSG( DBG_WARN, ( "Unmapped pSpool %x\n", pSpool ));
    }

    if( eResult == kProtectHandleSuccess ){

        //
        // If bClose, then see if an operation is currently executing.
        //
        if( bClose ){

            if(( pSpool->Status & SPOOL_STATUS_PENDING_DELETION ) ||
                 pSpool->cActive ){

                //
                // Mark pSpool to close itself once the operation has
                // completed in the other thread.
                //
                pSpool->Status |= SPOOL_STATUS_PENDING_DELETION;
                eResult = kProtectHandlePendingDeletion;

            } else {

                //
                // No call is active, so mark ourselves as closing so
                // that no other call will succeed using this handle.
                //
                pSpool->Status |= SPOOL_STATUS_CLOSE;
            }
        }

    } else {

        //
        // Not a valid handle.
        //
        SetLastError( ERROR_INVALID_HANDLE );
    }

    if( eResult == kProtectHandleSuccess ){

        //
        // Returning success, we are now active.
        //
        ++pSpool->cActive;
    }

    vLeaveSem();

    return eResult;

}


VOID
vUnprotectHandle(
    IN HANDLE hPrinter
    )

/*++

Routine Description:

    Unprotect a print handle.  This must be called once for each
    successful bProtectHandle.

Arguments:

    hPrinter - Handle to unprotect.

Return Value:

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL bCallClosePrinter = FALSE;

    vEnterSem();

    //
    // No longer active.  However, it it's closing, leave it marked
    // as closing since we don't want anyone else to use it.
    //
    --pSpool->cActive;

    if( pSpool->Status & SPOOL_STATUS_PENDING_DELETION &&
        !pSpool->cActive ){

        //
        // Someone called Close while we were active.  Since we are now
        // going to close it, don't let anyone else initiate a close by
        // marking SPOOL_STATUS_CLOSE.
        //
        pSpool->Status |= SPOOL_STATUS_CLOSE;
        pSpool->Status &= ~SPOOL_STATUS_PENDING_DELETION;
        bCallClosePrinter = TRUE;
    }

    vLeaveSem();

    if( bCallClosePrinter ){
        ClosePrinterWorker( pSpool );
    }
}



/********************************************************************

    OpenPrinter worker functions.

********************************************************************/


BOOL
OpenPrinterW(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    HANDLE  hPrinter;
    PSPOOL  pSpool = NULL;
    DWORD dwError;

    //
    // Pre-initialize the out parameter, so that *phPrinter is NULL
    // on failure.  This fixes Borland Paradox 7.
    //
    try {
        *phPrinter = NULL;
    } except( EXCEPTION_EXECUTE_HANDLER ){
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return FALSE;
    }

    pSpool = AllocSpool();

    if( !pSpool ){
        goto Fail;
    }

    //
    // Copy DevMode, defaults.  The printer name doesn't change.
    //
    if( !UpdatePrinterDefaults( pSpool, pPrinterName, pDefault )){
        goto Fail;
    }

    //
    // Update the access, since this is not set by UpdatePrinterDefaults.
    //
    if( pDefault ){
        pSpool->Default.DesiredAccess = pDefault->DesiredAccess;
    }

    dwError = OpenPrinterRPC( pSpool );

    if( dwError != ERROR_SUCCESS ){
        SetLastError( dwError );
        goto Fail;
    }

    //
    // We finally have a good pSpool.  Only now update the output
    // handle.  Since it was NULL initialized, this guarantees that
    // OpenPrinter returns *phPrinter NULL when it fails.
    //
    *phPrinter = pSpool;

    return TRUE;

Fail:

    FreeSpool( pSpool );

    return FALSE;
}

DWORD
OpenPrinterRPC(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Open the printer handle using information in the pSpool object.

Arguments:

    pSpool - Printer handle to open.  Internal state of pSpool updated.

Return Value:

    ERROR_SUCCES - Succeed.
    Status code - Failed.

--*/

{
    DEVMODE_CONTAINER DevModeContainer;
    HANDLE hPrinter = NULL;
    DWORD dwReturn;
    DWORD dwSize;
    SPLCLIENT_CONTAINER SplClientContainer;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SplClientContainer.Level = 2;
    SplClientContainer.ClientInfo.pClientInfo2 = NULL;

    RpcTryExcept {

        //
        // Construct the DevMode container.
        //
        if( bValidDevModeW( pSpool->Default.pDevMode )){

            dwSize = pSpool->Default.pDevMode->dmSize +
                     pSpool->Default.pDevMode->dmDriverExtra;

            DevModeContainer.cbBuf = pSpool->Default.pDevMode->dmSize +
                                     pSpool->Default.pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pSpool->Default.pDevMode;
        }

        //
        // If the call is made from within the spooler, we also retrieve the
        // server side hPrinter. This will help avoid unnecessary RPC. We cant,
        // however, avoid RPC in this case since the spooler may need a client side
        // handle to pass to other functions or the driver.
        //

        if (bLoadedBySpooler) {

            if (SplClientContainer.ClientInfo.pClientInfo2 =
                            (LPSPLCLIENT_INFO_2) AllocSplMem(sizeof(SPLCLIENT_INFO_2))) {

                 SplClientContainer.ClientInfo.pClientInfo2->hSplPrinter = 0;

                 dwReturn = RpcSplOpenPrinter( (LPTSTR)pSpool->pszPrinter,
                                               &hPrinter,
                                               pSpool->Default.pDatatype,
                                               &DevModeContainer,
                                               pSpool->Default.DesiredAccess,
                                               &SplClientContainer );
            } else {

                 SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                 dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            dwReturn = RpcOpenPrinter( (LPTSTR)pSpool->pszPrinter,
                                       &hPrinter,
                                       pSpool->Default.pDatatype,
                                       &DevModeContainer,
                                       pSpool->Default.DesiredAccess );
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwReturn = TranslateExceptionCode( RpcExceptionCode() );

    } RpcEndExcept


    if( dwReturn == ERROR_SUCCESS ){

        vEnterSem();

        //
        // hPrinter gets adopted by pSpool->hPrinter.
        //
        pSpool->hPrinter = hPrinter;

        if (bLoadedBySpooler) {
            pSpool->hSplPrinter = (HANDLE) SplClientContainer.ClientInfo.pClientInfo2->hSplPrinter;
        } else {
            pSpool->hSplPrinter = NULL;
        }

        vLeaveSem();
    }

    if (SplClientContainer.ClientInfo.pClientInfo2) {
        FreeSplMem(SplClientContainer.ClientInfo.pClientInfo2);
    }

    return dwReturn;
}


/********************************************************************

    ClosePrinter worker functions.

********************************************************************/

BOOL
ClosePrinter(
    HANDLE  hPrinter
    )
{
    PSPOOL pSpool = (PSPOOL)hPrinter;

    switch( eProtectHandle( hPrinter, TRUE  )){
    case kProtectHandleInvalid:
        return FALSE;
    case kProtectHandlePendingDeletion:
        return TRUE;
    default:
        break;
    }

    //
    // Note, there isn't a corresponding vUnprotectHandle, but that's ok
    // since we're deleting the handle.
    //

    return ClosePrinterWorker( pSpool );
}

//
// A simpler way to have a central function for closing spool file handles so we 
// don't have to reproduce code constantly.
//
VOID
CloseSpoolFileHandles(
    PSPOOL pSpool
    )
{
    if ( pSpool->hSpoolFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( pSpool->hSpoolFile );
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;
    }
    
    if (pSpool->hFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(pSpool->hFile);
        pSpool->hFile = INVALID_HANDLE_VALUE;
    }
}




BOOL
ClosePrinterWorker(
    PSPOOL pSpool
    )
{
    BOOL bReturnValue;
    FlushBuffer(pSpool, NULL);

    if (pSpool->Status & SPOOL_STATUS_ADDJOB)
        ScheduleJobWorker( pSpool, pSpool->JobId );

    vEnterSem();

    if( pSpool->pNotify ){

        //
        // There is a notification; disassociate it from
        // pSpool, since we are about to free it.
        //
        pSpool->pNotify->pSpool = NULL;
    }

    vLeaveSem();

    //
    // Close any open file handles, we do this before the RPC closeprinter
    // to allow the closeprinter on the other side a chance to delete the spool
    // files if they still exist.
    //
    CloseSpoolFileHandles( pSpool );

    bReturnValue = ClosePrinterRPC( pSpool, FALSE );
    FreeSpool( pSpool );

    return bReturnValue;
}

BOOL
ClosePrinterRPC(
    IN  PSPOOL      pSpool,
    IN  BOOL        bRevalidate
    )

/*++

Routine Description:

    Close down all RPC/network handles related to the pSpool object.
    Must be called outside the critical section. This function also
    is called handle revalidation in which case we don't want to
    close the event handle on the client side.

Arguments:

    pSpool      - Spooler handle to shut down.
    bRevalidate - If TRUE, this is being called as a result of a handle 
                  revalidation.

Return Value:

    TRUE - Success
    FALSE - Failed, LastError set.

--*/

{
    BOOL    bRetval     = FALSE;
    HANDLE  hPrinterRPC = NULL;

    vEnterSem();

    hPrinterRPC = pSpool->hPrinter;

    if ( hPrinterRPC )
    {
        pSpool->hPrinter = NULL;

        FindClosePrinterChangeNotificationWorker( pSpool->pNotify,
                                                  hPrinterRPC, 
                                                  bRevalidate );

        vLeaveSem();

        bRetval = ClosePrinterContextHandle( hPrinterRPC );
    }
    else
    {
        vLeaveSem();

        SetLastError( ERROR_INVALID_HANDLE );
    }

    return bRetval;
}


BOOL
ClosePrinterContextHandle(
    HANDLE hPrinterRPC
    )

/*++

Routine Description:

    Close a printer context handle.

Arguments:

    hPrinterRPC - RPC context handle to close.

Return Value:

    TRUE - Success
    FALSE - Failure; LastError set

--*/

{
    BOOL bReturnValue;
    DWORD Status;

    if( !hPrinterRPC ){
        return FALSE;
    }

    RpcTryExcept {

        if( Status = RpcClosePrinter( &hPrinterRPC )) {

            SetLastError( Status );

            bReturnValue = FALSE;

        } else {

            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        bReturnValue = FALSE;

    } RpcEndExcept

    //
    // If we failed for some reason, then RpcClosePrinter did not
    // zero out the context handle.  Destroy it here.
    //
    if( hPrinterRPC ){
        RpcSmDestroyClientContext( &hPrinterRPC );
    }

    return bReturnValue;
}



/********************************************************************

    Constructor and destructor of pSpool.

********************************************************************/

PSPOOL
AllocSpool(
    VOID
    )

/*++

Routine Description:

    Allocate a spool handle.  Client should set pSpool->hPrinter
    when it is acquired.

Arguments:

Return Value:

    pSpool - allocated handle.
    NULL - failed.

--*/

{
    PSPOOL pSpool = AllocSplMem(sizeof(SPOOL));

    if( pSpool ){

        InterlockedIncrement( &gcClientHandle );

        pSpool->signature = SP_SIGNATURE;
        pSpool->hFile = INVALID_HANDLE_VALUE;
        pSpool->hSpoolFile = INVALID_HANDLE_VALUE;

#ifdef DBG_TRACE_HANDLE
        {
            ULONG Hash;

            //
            // Add to linked list.
            //
            vEnterSem();
            pSpool->pNext = gpFirstSpool;
            gpFirstSpool = pSpool;
            vLeaveSem();

#if i386
            //
            // Capture backtrace.
            //
            RtlCaptureStackBackTrace( 1,
                                      COUNTOF( pSpool->apvBackTrace ),
                                      pSpool->apvBackTrace,
                                      &Hash );
#endif
        }
#endif
    }

    return pSpool;
}


VOID
FreeSpool(
    PSPOOL pSpool
    )
{
    if( !pSpool ){
        return;
    }

    InterlockedDecrement( &gcClientHandle );

    if (pSpool->pBuffer != NULL ) {
        if (!VirtualFree(pSpool->pBuffer, 0, MEM_RELEASE)) {
            DBGMSG(DBG_WARNING, ("ClosePrinter VirtualFree Failed %x\n",
                                 GetLastError()));
        }
        DBGMSG(DBG_TRACE, ("Closeprinter cWritePrinters %d cFlushBuffers %d\n",
                           pSpool->cWritePrinters, pSpool->cFlushBuffers));
    }

    FreeSplStr( pSpool->pszPrinter );
    FreeSplMem( pSpool->Default.pDevMode );
    FreeSplMem( pSpool->Default.pDatatype );
    FreeSplMem( pSpool->pDoceventFilter);

    CloseSpoolFileHandles( pSpool );

#ifdef DBG_TRACE_HANDLE
    {
        //
        // Free from linked list.
        //
        PSPOOL *ppSpool;

        vEnterSem();

        for( ppSpool = &gpFirstSpool; *ppSpool; ppSpool = &(*ppSpool)->pNext ){

            if( *ppSpool == pSpool ){
                break;
            }
        }

        if( *ppSpool ){
            *ppSpool = pSpool->pNext;
        } else {
            DBGMSG( DBG_WARN,
                    ( "pSpool %x not found on linked list\n", pSpool ));
        }
        vLeaveSem();
    }
#endif

    FreeSplMem( pSpool );
}


/********************************************************************

    Utility functions.

********************************************************************/


BOOL
RevalidateHandle(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Revalidates a pSpool with a new RPC handle.  This allows the spooler
    to be restarted yet allow the handle to remain valid.

    This should only be called when a call fails with ERROR_INVALID_HANDLE.
    We can only save simple state information (pDefaults) from OpenPrinter
    and ResetPrinter.  If a user spooling and the context handle is lost,
    there is no hope of recovering the spool file state, since the
    spooler probably died before it could flush its buffers.

    We should not encounter any infinite loops when the server goes down,
    since the initial call will timeout with an RPC rather than invalid
    handle code.

    Note: If the printer is renamed, the context handle remains valid,
    but revalidation will fail, since we store the old printer name.

Arguments:

    pSpool - Printer handle to revalidate.

Return Value:

    TRUE - Success
    FALSE - Failed.

--*/

{
    DWORD dwError;
    HANDLE hPrinter;

    //
    // Close the existing handle.  We can't shouldn't just destroy the client
    // context since an api may return ERROR_INVALID_HANDLE even though
    // RPC context handle is fine (a handle downstream went bad).
    //
    ClosePrinterRPC( pSpool, TRUE );

    //
    // Reopen the printer handle with current defaults.
    //
    dwError = OpenPrinterRPC( pSpool );

    if( dwError ){
        SetLastError( dwError );
        return FALSE;
    }

    return TRUE;
}

BOOL
UpdatePrinterDefaults(
    IN OUT PSPOOL pSpool,
    IN     LPCTSTR pszPrinter,  OPTIONAL
    IN     PPRINTER_DEFAULTS pDefault OPTIONAL
    )

/*++

Routine Description:

    Update the pSpool to the new defaults in pDefault, EXCEPT for
    pDefault->DesiredAccess.

    Since this attempts to read and update pSpool, we enter the
    critical section and revalidate the pSpool.

Arguments:

    pSpool - Spooler handle to update.

    pszPrinter - New printer name.

    pDefault - New defaults.

Return Value:

    TRUE - Success
    FALSE - Failure.

--*/

{
    BOOL bReturnValue = FALSE;

    vEnterSem();

    if( !UpdateString( pszPrinter, &pSpool->pszPrinter )){
        goto DoneExitSem;
    }

    if( pDefault ){

        //
        // Update the Datatype.
        //
        if( !UpdateString( pDefault->pDatatype, &pSpool->Default.pDatatype )){
            goto DoneExitSem;
        }

        //
        // Update the DevMode.
        //
        if( bValidDevModeW( pDefault->pDevMode )){

            DWORD dwSize;
            PDEVMODE pDevModeNew;

            dwSize = pDefault->pDevMode->dmSize +
                     pDefault->pDevMode->dmDriverExtra;

            pDevModeNew = AllocSplMem( dwSize );

            if( !pDevModeNew ){
                goto DoneExitSem;
            }

            CopyMemory( pDevModeNew, pDefault->pDevMode, dwSize );

            FreeSplMem( pSpool->Default.pDevMode );
            pSpool->Default.pDevMode = pDevModeNew;
        }
    }
    bReturnValue = TRUE;

DoneExitSem:

    vLeaveSem();
    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\init.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Init.c

Abstract:

    Holds initialization code for winspool.drv

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

CRITICAL_SECTION ClientSection;

// bLoadedBySpooler indicates if this instance of winspool.drv is loaded in the spooler
// process. This flag is used to avoid unnecessary RPC.

BOOL bLoadedBySpooler;

// The following function pointers hold the spooler's server side function pointers.
// This list includes most of the calls made inside the spooler except OpenPrinter and
// ClosePrinter. We cant extend RPC elimination to cover (Open/Close)Printer unless
// "ALL" spooler APIs use RPC elimination inside the spooler.

DWORD (*fpYReadPrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
DWORD (*fpYSplReadPrinter)(HANDLE, LPBYTE *, DWORD, BOOL);
DWORD (*fpYWritePrinter)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL);
DWORD (*fpYSeekPrinter)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD, BOOL, BOOL);
DWORD (*fpYGetPrinterDriver2)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD,
                              DWORD, DWORD, PDWORD, PDWORD, BOOL);
DWORD (*fpYGetPrinterDriverDirectory)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, BOOL);
VOID  (*fpYDriverUnloadComplete)(LPWSTR);
DWORD  (*fpYFlushPrinter)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL);
DWORD (*fpYEndDocPrinter)(HANDLE,BOOL);
DWORD (*fpYSetPort)(LPWSTR, LPWSTR, LPPORT_CONTAINER, BOOL);
DWORD (*fpYSetJob)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL);

VOID InitializeGlobalVariables()

/*++
Function Description -- Initializes bLoadedBySpooler and function pointers.

Parameters - NONE

Return Values - NONE
--*/

{
    TCHAR   szSysDir[MAX_PATH];
    LPTSTR  pszSpoolerName = NULL, pszModuleName = NULL, pszSysDir = (LPTSTR) szSysDir;
    BOOL    bAllocSysDir = FALSE;
    DWORD   dwNeeded, dwSize;
    HANDLE  hLib;

    // Preliminary initializations
    bLoadedBySpooler = FALSE;
    fpYReadPrinter = fpYWritePrinter = NULL;
    fpYSplReadPrinter = NULL;
    fpYSeekPrinter = NULL;
    fpYGetPrinterDriver2 = NULL;
    fpYGetPrinterDriverDirectory = NULL;
    fpYDriverUnloadComplete = NULL;
    fpYFlushPrinter = NULL;
    fpYEndDocPrinter = NULL;

    hSurrogateProcess = NULL;


    dwSize = MAX_PATH * sizeof(TCHAR);

    // Get system directory
    if (!(dwNeeded = GetSystemDirectory(pszSysDir, MAX_PATH))) {
        goto CleanUp;
    }

    if (dwNeeded > dwSize)  {

       if (pszSysDir = (LPTSTR) AllocSplMem(dwNeeded)) {

           bAllocSysDir = TRUE;
           if (!GetSystemDirectory(pszSysDir, dwNeeded / sizeof(TCHAR))) {
               goto CleanUp;
           }

       } else {
          goto CleanUp;
       }
    }

    dwSize = (_tcslen(pszSysDir) + 1 + _tcslen(TEXT("\\spoolsv.exe"))) * sizeof(TCHAR);

    if ((!(pszSpoolerName = (LPTSTR) AllocSplMem(dwSize))) ||
        (!(pszModuleName  = (LPTSTR) AllocSplMem(dwSize))))   {

         goto CleanUp;
    }

    // Get spooler name
    _tcscpy(pszSpoolerName, pszSysDir);
    _tcscat(pszSpoolerName, TEXT("\\spoolsv.exe"));

    // Get module name. GetModuleFileName truncates the string if it is bigger than
    // the allocated buffer. There shouldn't be an executable spoolsv.exe* in the
    // system directory, which could be mistaken for the spooler.
    if (!GetModuleFileName(NULL, pszModuleName, dwSize / sizeof(TCHAR))) {
        goto CleanUp;
    }

    if (!_tcsicmp(pszSpoolerName, pszModuleName)) {

       // winspool.drv has been loaded by the spooler
       bLoadedBySpooler = TRUE;
       if (hLib = LoadLibrary(pszSpoolerName)) {

          fpYReadPrinter               = (DWORD (*)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YReadPrinter");
          fpYSplReadPrinter            = (DWORD (*)(HANDLE, LPBYTE *, DWORD, BOOL))
                                             GetProcAddress(hLib, "YSplReadPrinter");
          fpYWritePrinter              = (DWORD (*)(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YWritePrinter");
          fpYSeekPrinter               = (DWORD (*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER,
                                                     DWORD, BOOL, BOOL))
                                             GetProcAddress(hLib, "YSeekPrinter");
          fpYGetPrinterDriver2         = (DWORD (*)(HANDLE, LPWSTR, DWORD, LPBYTE, DWORD,
                                                    LPDWORD, DWORD, DWORD, PDWORD, PDWORD, BOOL))
                                             GetProcAddress(hLib, "YGetPrinterDriver2");
          fpYGetPrinterDriverDirectory = (DWORD (*)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD,
                                                    LPDWORD, BOOL))
                                             GetProcAddress(hLib, "YGetPrinterDriverDirectory");
          fpYDriverUnloadComplete      = (VOID (*)(LPWSTR))
                                             GetProcAddress(hLib, "YDriverUnloadComplete");
          fpYFlushPrinter              = (DWORD (*)(HANDLE,LPVOID,DWORD,LPDWORD,DWORD,BOOL))
                                             GetProcAddress(hLib,"YFlushPrinter");
          fpYEndDocPrinter             = (DWORD (*)(HANDLE,BOOL))
                                             GetProcAddress(hLib,"YEndDocPrinter");
          fpYSetPort                   = (DWORD (*)(LPWSTR,LPWSTR,LPPORT_CONTAINER,BOOL))
                                             GetProcAddress(hLib,"YSetPort");
          fpYSetJob                    = (DWORD (*)(HANDLE, DWORD, LPJOB_CONTAINER, DWORD, BOOL))
                                             GetProcAddress(hLib,"YSetJob");



          // We can leave spoolsv.exe loaded since it is in the spooler process
       }
    }

CleanUp:

    if (pszSpoolerName) {
        FreeSplMem(pszSpoolerName);
    }

    if (pszModuleName) {
        FreeSplMem(pszModuleName);
    }

    if (bAllocSysDir) {
        FreeSplMem(pszSysDir);
    }

    return;
}


//
// This entry point is called on DLL initialisation.
// We need to know the module handle so we can load resources.
//

BOOL DllMain(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE)hmod);
        hInst = hmod;

        __try {

            if( !bSplLibInit(NULL) ) {
                return FALSE;
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            SetLastError(GetExceptionCode());
            return FALSE;
        }

        InitializeGlobalVariables();

        __try {

            InitializeCriticalSection(&ClientSection);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            SetLastError(GetExceptionCode());
            return FALSE;
        }

        __try {

            InitializeCriticalSection(&ListAccessSem);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            DeleteCriticalSection(&ClientSection);
            SetLastError(GetExceptionCode());
            return FALSE;
        }

        __try {

            InitializeCriticalSection(&ProcessHndlCS);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            DeleteCriticalSection(&ClientSection);
            DeleteCriticalSection(&ListAccessSem);
            SetLastError(GetExceptionCode());
            return FALSE;
        }


        break;

    case DLL_PROCESS_DETACH:

        vSplLibFree();

        DeleteCriticalSection( &ClientSection );
        DeleteCriticalSection( &ListAccessSem );
        DeleteCriticalSection( &ProcessHndlCS);

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\pfdlg.h ===
/*++  

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    pfdlg.h

Abstract:

    Print to file header

Author:

    Steve Kiraly (steveki) 5-May-1998

Environment:

    User Mode -Win32

Revision History:

--*/
#ifndef _PFDLG_H_
#define _PFDLG_H_


BOOL APIENTRY
PrintToFileDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
   );

BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    LPWSTR  *ppFileName
    );

BOOL
PrintToFileCommandOK(
    HWND hwnd
    );

BOOL
PrintToFileCommandCancel(
    HWND hwnd
    );

BOOL
PrintToFileHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\memory.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    memory.cxx

Abstract:

    Allocator class. We use this class in the printer persist code.
    The TPrnStream class uses this class through inheritance. 
    
    The reason why TPrnStream uses its own heap is that it is called
    by terminal services in the winlogon process. The heap protects
    our caller, cause in the worst case scenario we corrupt just our 
    own heap. Also, if an exception is raised in the TPrnStream methods,
    we don't leak, because the destructor frees the heap.
    
Author:

    Felix Maxa (amaxa) 31-Oct-2000

--*/

#include "precomp.h"
#pragma hdrstop
#include "memory.hxx"

/*++

Title:

    TAllocator::TAllocator

Routine Description:

    Constructor

Arguments:

    None.

Return Value:

    None.

--*/
TAllocator::
TAllocator(
    IN DWORD  Options,
    IN SIZE_T InitialSize
    ) : m_hHeap(NULL),
        m_Options(Options),
        m_InitialSize(InitialSize)
{
}

/*++

Title:

    TAllocator::~TAllocator

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    None.

--*/
TAllocator::
~TAllocator(
    VOID
    )
{
    if (m_hHeap) 
    {
        if (!HeapDestroy(m_hHeap))
        {
            DBGMSG(DBG_WARNING, ("TAllocator::~TAllocator Failed"
                                 "to destroy heap at 0x%x. Win32 error %u\n", m_hHeap, GetLastError()));
        }

        m_hHeap = NULL;
    }
}

/*++

Title:

    TAllocator::AllocMem

Routine Description:

    Allocates memory from a heap. The heap is created upon first
    call to this function.
    
Arguments:

    cbSize - number of bytes to allocate

Return Value:

    NULL - allocation failed
    valid pointer to memory allocated - allocation succeeded

--*/
PVOID
TAllocator::
AllocMem(
    IN SIZE_T CONST cbSize
    )
{
    LPVOID pMem = NULL;

    if (!m_hHeap) 
    {
        m_hHeap = HeapCreate(m_Options, m_InitialSize, 0);  

        if (!m_hHeap) 
        {
            DBGMSG(DBG_WARNING, ("TAllocator::AllocMem Failed to create heap. "
                                 "Win32 error %u\n", GetLastError()));
        }
    }
    
    if (m_hHeap) 
    {
        pMem = HeapAlloc(m_hHeap, m_Options, cbSize);

        if (!pMem) 
        {
            DBGMSG(DBG_WARNING, ("TAllocator::AllocMem Failed to allocated memory."
                                 " Win32 error %u\n", GetLastError()));
        }
    }
    
    return pMem;
}

/*++

Title:

    TAllocator::FreeMem

Routine Description:

    Frees a block of memory from the heap.

Arguments:

    pMem - pointer to block to free

Return Value:

    None.

--*/
VOID
TAllocator::
FreeMem(
    IN PVOID pMem
    )
{
    if (pMem && m_hHeap) 
    {
        if (!HeapFree(m_hHeap, m_Options, pMem))
        {
            DBGMSG(DBG_WARNING, ("TAllocator::FreeMem Failed to free block at 0x%x."
                                 " Win32 error %u\n", pMem, GetLastError()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\prnprst.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    PrnPrst.cxx

Abstract:

    TPrinterPersist member definitions.

    This class implements methods for storing , restoring printer settings into a file

    Also , implements read, write , seek methods to operate a file likewise a stream

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

/*++

Title:                  

    TPrinterPersist

Routine Description:    

    Initialise m_pPrnStream to NULL.
    TPrinterPersist functionality is implemented through this object methods call.
    m_pPrnStream is created when   BindPrinterAndFile is called. If this function fails, 
    any subsequent method call will fail too.

Arguments:  

    None

Return Value:  

    Nothing

--*/
TPrinterPersist::
TPrinterPersist()
{
    m_pPrnStream = NULL;
}

/*++

Title:                  

    ~TPrinterPersist

Routine Description:    

    destructor: if created , deletes PrnStream object

Arguments:  

    None

Return Value:  

    Nothing

--*/

TPrinterPersist::
~TPrinterPersist()
{
    if(m_pPrnStream)
    {
        delete m_pPrnStream;
    }
}

/*++

Title:                  

    BindPrinterAndFile

Routine Description:

    Create  a TPrnStream object and if succeeded , bind it to a printer and a file
                    
Arguments:

    pszPrinter  - printer to bind to
    pszFile     - file to bind to

Return Value:  

    BindPrinterAndFile could return E_OUTOFMEMORY if failed to allocate memory,
    an error code mapped to HRESULT with storage facility set if failed to open printer in TPrnStream::BindPrnStream
    or S_OK if suceeded

--*/
HRESULT
TPrinterPersist::
BindPrinterAndFile(
    IN LPCTSTR pszPrinter,
    IN LPCTSTR pszFile
    )
{
    TStatusB    bStatus;
    TStatusH    hr;

    // 
    //  Create a TPrnStream obj ant initialise it with printer name and file name
    //
    m_pPrnStream = new TPrnStream(pszPrinter, pszFile);

    bStatus DBGCHK = (m_pPrnStream != NULL);

    if(bStatus)
    {
        DBGMSG(DBG_TRACE , ("BindPrinterAndFile to : " TSTR " \n" , pszPrinter));
        //
        // calls TPrnStream bind method; it will open the printer with maximum access rights
        // and will create a TStream object that will open the file
        //
        hr DBGCHK = m_pPrnStream->BindPrnStream();

        //
        //  if failed to bind TPrnStream to printer and file , delete it!!!
        //
        if(FAILED(hr))
        {
            delete m_pPrnStream;

            m_pPrnStream = NULL;
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
    

}

/*++

Title:                  

    UnBindPrinterAndFile

Routine Description:

    Call UnBindPrnStream method of m_pPrnStream.After this function is called , any subsequent method call will fail.
    
Arguments:

    None

Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrinterPersist::
UnBindPrinterAndFile(
    )
{
    TStatusH    hr;

    DBGMSG(DBG_TRACE , ("UnBindPrinterAndFile!!! \n"));

    hr DBGNOCHK = E_FAIL;

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->UnBindPrnStream();
    }


    return hr;
}

/*++

Title:                  

    bGetPrinterAndFile

Routine Description:

    Query m_pPrnStream for printer and file it is binded

Arguments: 

    pszPrinter  -   outs printer name
    pszFile     -   outs file name

Return Value:  

    TRUE if m_pPrnStream is initialized 
    FALSE otherwise

--*/
BOOL
TPrinterPersist::   
bGetPrinterAndFile(
    OUT LPCTSTR& pszPrinter,
    OUT LPCTSTR& pszFile
    )
{
    TStatusB    bStatus;

    if(m_pPrnStream != NULL)
    {
        pszPrinter   = m_pPrnStream->GetPrinterName();

        pszFile      = m_pPrnStream->GetFileName();

        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        bStatus DBGCHK = FALSE;
    }

    return bStatus;

}
/*++

Title:                  

    Read

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Eventually , this function will be called through IStream interface
    Arguments the same as IStream::Read
                    
Arguments: 

    pv  -   The buffer that the bytes are read into
    cb  -   The offset in the stream to begin reading from.
    pcbRead -   The number of bytes to read

Return Value:

    S_OK if succeeded
    ReadFile Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Read(                                
    IN VOID * pv,      
    IN ULONG  cb,       
    IN ULONG * pcbRead 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Read(pv, cb, pcbRead);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
    
}
/*++

Title:                  

    Write

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Eventually , this function will be called through IStream interface
    Arguments the same as IStream::Write
                    
Arguments:  

    pv  -   The buffer to write from.
    cb  -   The offset in the array to begin writing from
    pcbRead -   The number of bytes to write

Return Value:

    S_OK if succeeded
    WriteFile Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Write(                            
    IN VOID     const* pv,  
    IN ULONG    cb,
    IN ULONG*   pcbWritten 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Write(pv, cb, pcbWritten);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
}

/*++

Title:                  

    Seek

Routine Description:

    Indirects call to PrnStream which , in turns , idirects it to TStream  
    Arguments the same as IStream::Seek
    Eventually , this function will be called through IStream interface
                    
Arguments: 

    dlibMove        -   The offset relative to dwOrigin
    dwOrigin        -   The origin of the offset
    plibNewPosition -   Pointer to value of the new seek pointer from the beginning of the stream  

Return Value:  

    S_OK if succeeded
    SetFilePointer Win32 error mapped to HRESULT(FACILITY_STORAGE) if failed

--*/
HRESULT
TPrinterPersist::
Seek(                                
    IN LARGE_INTEGER dlibMove,  
    IN DWORD dwOrigin,          
    IN ULARGE_INTEGER * plibNewPosition 
    )
{
    if(m_pPrnStream)
    {
        return m_pPrnStream->GetIStream()->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        return STG_E_NOMOREFILES;
    }
}


/*++

Title:                  

    bStorePrinterInfo

Routine Description:    

    Writes the printer settings into file.
    Depending on specified flags, call TPrnStream   methods to store printer data
    This function must be called after calling BindPrinterAndFile which bind the object to 
    a printer and to a file.For that fnct to succeed, current user must have PRINTER_READ rights
    on specified printer.

Arguments:  

    Flags       -   specifies what settings should be stored
    StoredFlags -   specifies what settings were actually stored

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrinterPersist::
StorePrinterInfo(
    IN  DWORD   Flags,
    OUT DWORD&  StoredFlags
    )
{
    TStatusH    hr;

    DBGMSG(DBG_TRACE , ("Store Printer Flag %x \n" , Flags));

    hr DBGNOCHK = E_FAIL;

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->StorePrinterInfo(Flags, StoredFlags);
    }


    DBGMSG( DBG_TRACE, ( "Store Completed :: %x \n" ,hr));


    return hr;

}


/*++

Title:                  

    RestorePrinterInfo

Routine Description:    

    Depending on specified flags, call TPrnStream   methods to restore printer data
    This function must be called after calling BindPrinterAndFile which bind the object to 
    a printer and to a file.For that fnct to succeed, current user has to have PRINTER_ALL_ACCESS rights.
    If he don't , BindPrinterAndFile will bind to printer with PRINTER_READ which will lead to 
    SetPrinter failure. 
    
Arguments:              

    Flags         -   specifies what settings should be restored
    RestoredFlags -   specifies what settings were actually restored

Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed


--*/
HRESULT
TPrinterPersist::
RestorePrinterInfo(
    IN DWORD    Flags,
    OUT DWORD&  RestoredFlags
    )
{
    TStatusH            hr;
    TStatusB            bStatus;
    
    hr DBGNOCHK = E_FAIL;



    RestoredFlags = 0;

    DBGMSG(DBG_TRACE , ("Restore Printer info %x \n" , Flags));

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->CheckPrinterNameIntegrity(Flags);

        if(SUCCEEDED(hr))
        {
            DBGMSG( DBG_TRACE, ( "CheckPrinterNameIntegrity OK!!! %x \n" , hr));

            hr DBGCHK = m_pPrnStream->RestorePrinterInfo(Flags, RestoredFlags);
        }

    }

    DBGMSG( DBG_TRACE, ( "RESTORE END!!! %x \n" , hr));
    return hr;

}

/*++

Title:                  

    SafeRestorePrinterInfo

Routine Description:    

    Before restoring ant flags, create a new temporary persistent object binded to also to printer which stores current printer settings. 
    If something fails at the restoring, we are able to roll back all the changes made and we will leave printer in the 
    initial state.
    A temporary file which holds initial printer settings are created by invoking StorePrinterInfo for temporary object.
    This file will be deleted by calling UnBindPrinterAndFile for temporary object.

Arguments:              

    Flags         -   specifies what settings should be restored
    
Return Value:
    
    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed


--*/
HRESULT
TPrinterPersist::
SafeRestorePrinterInfo(
    IN DWORD    Flags
    )
{
    LPTSTR  pszPrinterTemp;
    LPTSTR  pszFile;
    TString strFileTempPrefix(_T("Prst"));
    TCHAR   szTempFileName[MAX_PATH];
    TCHAR   szTempPath[MAX_PATH];


    TStatusH hr;
    TStatusH hrBkp;

    DWORD StoredFlags;
    DWORD RestoredFlags;

    //
    // initialize hr to Backup error; if something wrong happens when trying to build backup version of file,
    // fnct will return Back-up Error
    //
    hr  DBGNOCHK     = MakePrnPersistHResult(PRN_PERSIST_ERROR_BACKUP);

    hrBkp DBGNOCHK   = MakePrnPersistHResult(PRN_PERSIST_ERROR_BACKUP);

    //
    // Create temporary object for storing current settings
    // In case the main restoring fails , current settings can be restored
    //
    TPrinterPersist* pPrnPersistTemp = new TPrinterPersist;

    if(pPrnPersistTemp != NULL)
    {
        if(bGetPrinterAndFile(pszPrinterTemp, pszFile))
        {
            TStatus Status;
            //
            // create a temp file for saving current settings
            //
            Status DBGNOCHK = GetTempPathW(MAX_PATH, szTempPath); 
            if (Status > 0 && Status <= MAX_PATH) {
                GetTempFileName(szTempPath, strFileTempPrefix, 0, szTempFileName);
            }
            else {
                GetTempFileName(_T("."), strFileTempPrefix, 0, szTempFileName);
            }
            
            hrBkp DBGCHK = pPrnPersistTemp->BindPrinterAndFile(pszPrinterTemp, szTempFileName);

            if(SUCCEEDED(hrBkp))
            {
                hrBkp DBGCHK = pPrnPersistTemp->StorePrinterInfo(Flags, StoredFlags);

                if(SUCCEEDED(hrBkp))
                {
                    hr DBGCHK = RestorePrinterInfo(Flags, RestoredFlags);

                    if(FAILED(hr))
                    {
                        //
                        // if main restoring failed , try backup restoring with flags set to:
                        //      flags successfully restored
                        //      &
                        //      flags that were successfully stored in backup file
                        // fct will still return hr = reason for main restoring failure
                        //
                        // PRST_FORCE_NAME must be always set on force for a scenario like this:
                        // restore settings from file ( printer P1 stored) on top of printer P2 with f flag set
                        // restoring fails (printer P2 could become P1 at this point) and back-up is needed; 
                        // in back-up file , printer name is P2 . This means we have to force printer name from back-up file,
                        // in order to become P2 again
                        // If it's not the case then printer was renamed and the restoring failed,f flag is harmless
                        //
                        hrBkp DBGCHK = pPrnPersistTemp->RestorePrinterInfo((StoredFlags & RestoredFlags) | PRST_FORCE_NAME , RestoredFlags);

                        if(FAILED(hrBkp))
                        {
                            // if backup restoring failed also,
                            // set hr to FATAL Error
                            //
                            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_FATAL);
                        }

                    }

                }

            }

            pPrnPersistTemp->UnBindPrinterAndFile();

        }

        delete pPrnPersistTemp;
    }

    return hr;
}

/*++

Title:                  

    QueryPrinterInfo

Routine Description:    

    Read from 
                    
Arguments:              

    Flags       -   specifies what settings should be restored
    pPrstInfo   -   pointer to union that holds a pointer to read item

Return Value:

    S_OK if succeeded;
    ERROR_INVALID_PARAMETER maped to HRESULT if more than one flag specified;
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed;

--*/
HRESULT
TPrinterPersist::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag           Flag,
    OUT PersistentInfo                      *pPrstInfo
    )
{
    TStatusH            hr;
    TStatusB            bStatus;
    
    hr DBGNOCHK = E_FAIL;



    DBGMSG(DBG_TRACE , ("Restore Printer info %x \n" , Flag));

    //
    //  if BindPrinterAndFile wasn't called or failed , this funct will fail also
    //
    if(m_pPrnStream != NULL)
    {
        hr DBGCHK = m_pPrnStream->QueryPrinterInfo(Flag, pPrstInfo);
    
    }

    DBGMSG( DBG_TRACE, ( "QueryPrinterInfo END!!! %x \n" , hr));

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Albert Ting (AlbertT)  30-Nov-1997

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef MODULE
#define MODULE "SPLCLIENT:"
#define MODULE_DEBUG ClientDebug
#define LINK_SPLLIB
#endif

#define INC_OLE2

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <rpcasync.h>
#include "winspl.h"
#include <offsets.h>
#include <change.h>
#include <winddiui.h>
#include "wingdip.h"
#include "gdispool.h"
#include <winsprlp.h>

#include <wininet.h>
#include "shlobj.h"
#include "shlobjp.h"
#include "cstrings.h"
#include <tchar.h>
#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <dsrole.h>
#include <dsgetdc.h>
#include <wininet.h>
#include <activeds.h>
#include <ntdsapi.h>
#include <setupapi.h>
#include <splsetup.h>
#include <winsock2.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include <splcom.h>

#ifdef __cplusplus
#include <icm.h>
#include <winprtp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\prnstrm.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    Stream.cxx

Abstract:

    implements TPrnStream class methods

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

static
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

static
FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

/*++

Title:

    TPrnStream

Routine Description:

    Initialize class members.
    Initialise m_pIStream to NULL.
    TPrnStream Read/write/Seek functionality is implemented through this object methods call.
    m_pIStream is created when  BindPrnStream is called. If this function fails,
    any subsequent method call will fail too.

Arguments:

    None

Return Value:

    Nothing

--*/
TPrnStream::
TPrnStream(
    IN  LPCTSTR pszPrnName,
    IN  LPCTSTR pszFileName
    ) : m_pIStream(NULL),
        m_strFileName(pszFileName),
        m_strPrnName(pszPrnName),
        m_hPrinterHandle(INVALID_HANDLE_VALUE),
        m_bHeaderWritten(FALSE),
        m_cIndex(0),
        m_ResolveCase(0),
        m_pPrnBinItem(NULL),
        m_EnumColorProfiles(NULL),
        m_AssociateColorProfileWithDevice(NULL),
        m_DisassociateColorProfileFromDevice(NULL),
        m_pColorProfileLibrary(NULL)
{
    m_cPrnDataItems.QuadPart = 0;

    m_uliSeekPtr.QuadPart = 0;

}
/*++

Title:

    ~TPrnStream

Routine Description:

    Close printer if opened ; free TStream if created

Arguments:

    None

Return Value:

    Nothing

--*/
TPrnStream::
~TPrnStream(
    )
{
    if(m_hPrinterHandle != INVALID_HANDLE_VALUE)
    {
        ClosePrinter(m_hPrinterHandle);
    }

    if(m_pIStream)
    {
        delete m_pIStream;
    }


    if(m_pPrnBinItem)
    {
        FreeMem(m_pPrnBinItem);
    }

    if (m_pColorProfileLibrary)
    {
        delete m_pColorProfileLibrary;
    }
}


/*++

Title:

    BindPrnStream

Routine Description:

    Open Printer , bind prinyter handle to WalkPrinter and create an TStream
    WalkPrinter can take a printer name or printer handle at constructing time
    It has also a default constructor explicit defined ; Printer handle can be binded later

Arguments:

Return Value:

    S_OK if succeeded,
    E_OUTOFMEMORY if failed to alloc mem
    an error code maped to a storage hresult

--*/
HRESULT
TPrnStream::
BindPrnStream(
    )
{
    TStatusB    bStatus;
    TStatus     Status;
    HRESULT     hr;
    DWORD       dwAccess = 0;

    Status DBGCHK = sOpenPrinter(   m_strPrnName,
                    &dwAccess,
                    &m_hPrinterHandle );

    DBGMSG( DBG_TRACE, ( "Printer Name : %x "TSTR" File: "TSTR" \n" , m_hPrinterHandle , (LPCTSTR)m_strPrnName , (LPCTSTR)m_strFileName) );

    if(dwAccess == PRINTER_ALL_ACCESS)
    {
        DBGMSG( DBG_TRACE, ( "Printer ALL Access Granted!!!\n" ) );
    }
    else
    {
        DBGMSG( DBG_TRACE, ( "Printer READ Access Granted!!!\n" ) );
    }


    if(Status == 0)
    {
        BindToPrinter(m_hPrinterHandle);

        m_pIStream = new TStream(m_strFileName);

        bStatus DBGCHK = (m_pIStream != NULL);

        if(bStatus)
        {
            DBGMSG( DBG_TRACE, ( "BINDING SUCCEEDED!!!\n "));

            hr = S_OK;
        }
        else
        {
            m_pIStream = NULL;

            m_hPrinterHandle = INVALID_HANDLE_VALUE;

            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = TStream::MapWin32ErrorCodeToHRes(GetLastError());

    }

    if (SUCCEEDED(hr))
    {
        hr = InitalizeColorProfileLibrary();
    }

    return hr;

}

/*++

Title:

    UnBindPrnStream

Routine Description:

    Close printer if opened , removefile if created , delete

Arguments:

    None

Return Value:

    S_OK if succeeded,
    a Win32 Error (generated by DeleteFile) mapped to a HRESULT if failed

--*/
HRESULT
TPrnStream::
UnBindPrnStream(
    )
{
    TStatusH    hr;

    hr DBGNOCHK = S_OK;

    if(m_hPrinterHandle != INVALID_HANDLE_VALUE)
    {
        ClosePrinter(m_hPrinterHandle);
        m_hPrinterHandle = INVALID_HANDLE_VALUE;
    }

    if(m_pIStream)
    {
        hr DBGCHK = m_pIStream->DestroyFile();
    }

    return hr;
}

/*++

Title:

    SetEndOfPrnStream

Routine Description:

    Set the end of PrnStream; In the case when overwrite an existing file, EOF must be set in order to trubcate the file at
    the actual dimension of the info written

Arguments:

    None

Return Value:

    TRUE if succeeded,

--*/
BOOL
TPrnStream::
SetEndOfPrnStream(
    )
{
    return m_pIStream->bSetEndOfFile();
}

/*++

Title:

    CheckPrinterNameIntegrity

Routine Description:

    Read printer name from file and compare with name specified at binding
    If they are different , depending on how FORCE or RESOLVE flags are set the new name will be resolved or forced.
    If no name solving is specified , return error
    Func called at restoring time

Arguments:

    Flags   -   flags specified at restoring time ; should specify who printer name conflicts are handles

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
CheckPrinterNameIntegrity(
    IN DWORD    Flags
    )
{
    TStatusB            bStatus;
    TString             strStoredPrnName;
    TStatusH            hr;

    //
    // m_ResolveCase will indicate how to solve printer name conflicts
    // if one of <printer name resolving> flags are set, set m_ResolveCase
    //
    if(Flags & PRST_RESOLVE_NAME)
    {
        m_ResolveCase |= TPrnStream::kResolveName;
    }
    else if(Flags & PRST_FORCE_NAME)
    {
        m_ResolveCase |= TPrnStream::kForceName;
    }

    hr DBGCHK =  ReadPrnName(strStoredPrnName);

    if(SUCCEEDED(hr))
    {
        if(_tcsicmp( m_strPrnName, strStoredPrnName) != 0)
        {
            if(m_ResolveCase & TPrnStream::kResolveName)
            {
                DBGMSG(DBG_TRACE , ("RESOLVE for "TSTR"\n" , (LPCTSTR)m_strPrnName));

                hr DBGNOCHK = S_OK;
            }
            else if(m_ResolveCase & TPrnStream::kForceName)
            {
                DBGMSG(DBG_TRACE , ("FORCE to "TSTR"\n" , (LPCTSTR)strStoredPrnName));

                m_strPrnName.bUpdate(strStoredPrnName);

                hr DBGNOCHK = S_OK;
            }
            else
            {
                hr DBGNOCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_PRN_NAME_CONFLICT);
            }

        }

    }

    return hr;
}

/*++

Title:

    PortNameCase

Routine Description:

    Set m_ResolveCase to TPrnStream::kResolvePort if resolve port option is set

Arguments:

    Flags   -   this function is called with flags specified for RestorePrinterInfo at restoring time

Return Value:

    Nothing

--*/
VOID
TPrnStream::
PortNameCase(
    IN DWORD    Flags
    )
{
    if(Flags & PRST_RESOLVE_PORT)
    {
        m_ResolveCase |= TPrnStream::kResolvePort;
    }
}

/*++

Title:

    ShareNameCase

Routine Description:

    Set m_ResolveCase to TPrnStream::kGenerateShare if resolve port option is set

Arguments:

    Flags   -   this function is called with flags specified for RestorePrinterInfo at restoring time

Return Value:

    Nothing

--*/
VOID
TPrnStream::
ShareNameCase(
    IN DWORD    Flags
    )
{
    if(Flags & PRST_RESOLVE_SHARE)
    {
        m_ResolveCase |= TPrnStream::kGenerateShare;
    }
    else if(Flags & PRST_DONT_GENERATE_SHARE)
    {
        m_ResolveCase |= TPrnStream::kUntouchShare;
    }

}

/*++

Title:

    StorePrinterInfo

Routine Description:

    Define restoring function table and calls storing functions based on flag value

Arguments:

    flags   -   flags that specifies that functions should be called

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrinterInfo(
    IN  DWORD    Flags,
    OUT DWORD&   StoredFlags
    )
{

    TStatusH    hr;

    hr DBGNOCHK = S_OK;


    static PrstFunctEntry StoreFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::StorePrnInfo2},
    {PRST_PRINTER_INFO_7,               &TPrnStream::StorePrnInfo7},
    {PRST_COLOR_PROF,                   &TPrnStream::StoreColorProfiles},
    {PRST_PRINTER_DATA,                 &TPrnStream::StorePrnData},
    {PRST_PRINTER_SEC,                  &TPrnStream::StorePrnSecurity},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::StorePrnDevMode},
    {PRST_USER_DEVMODE,                 &TPrnStream::StoreUserDevMode},
    {0,                                 NULL}};


    hr DBGCHK = WriteHeader(Flags);

    //
    // initialize the flags that were successfully stored with 0
    //
    StoredFlags = 0;

    for(int idx = 0 ; StoreFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & StoreFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*StoreFunctTable[idx].pPrstFunc)();

            if(SUCCEEDED(hr))
            {
                StoredFlags |= StoreFunctTable[idx].iKeyWord;
            }
        }

    }

    if(SUCCEEDED(hr))
    {
        //
        // Truncate file; maybe the file was overwrited
        //
        SetEndOfPrnStream();
    }
    else
    {
        //
        //delete file if storing didn't succeed
        //
        UnBindPrnStream();
    }

    return hr;

}

/*++

Title:

    QueryPrinterInfo

Routine Description:

    query a file for stored settings

Arguments:

    Flags - specify what settings to query

    PrstInfo - Structure where read settings will be dumped

Return Value:

    S_OK if succeeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag      Flags,
    OUT PersistentInfo                  *pPrstInfo
    )
{
    TStatusH    hr;
    BOOL        bInsidePI2;


    static QueryFunctEntry QueryFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::ReadPrnInfo2},
    {PRST_PRINTER_INFO_7,               &TPrnStream::ReadPrnInfo7},
    {PRST_COLOR_PROF,                   &TPrnStream::ReadColorProfiles},
    {PRST_PRINTER_SEC,                  &TPrnStream::ReadPrnSecurity},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::ReadPrnInfo8},
    {0,                                 NULL}};

    //
    // delete in case QueryPrinterInfo was previously called
    // m_pPrnBinItem store a PrnBinInfo block when Query ;
    // it has to be deleted between to Querys and at destruction time
    //
    if(m_pPrnBinItem)
    {
        delete m_pPrnBinItem;
    }

    hr DBGNOCHK = S_OK;

    for(int idx = 0 ; QueryFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & QueryFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*QueryFunctTable[idx].pReadFunct)(&m_pPrnBinItem);

            if(SUCCEEDED(hr))
            {
                DBGMSG( DBG_TRACE, ( "QueryPrinterInfo: pReadFunct OK \n"));

                pPrstInfo->pi2 = reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(m_pPrnBinItem) + m_pPrnBinItem->pData);

            }
            else
            {
                DBGMSG( DBG_TRACE, ( "QueryPrinterInfo: pReadFunct FAILED \n"));
            }
        }

    }


    return hr;

}

/*++

Title:

    RestorePrinterInfo

Routine Description:

    Handle port name conflicts by calling PortNameCase before any restoring
    Define restoring function table and calls restoring functions based on flag value

Arguments:

    flags   -   flags that specifies that functions should be called

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrinterInfo(
    IN  DWORD       Flags,
    OUT DWORD&      RestoredFlags
    )
{

    TStatusH    hr;

    hr DBGNOCHK = S_OK;


    static PrstFunctEntry RestoreFunctTable [] = {
    {PRST_PRINTER_INFO_2,               &TPrnStream::RestorePrnInfo2},
    {PRST_COLOR_PROF,                   &TPrnStream::RestoreColorProfiles},
    {PRST_PRINTER_DEVMODE,              &TPrnStream::RestorePrnDevMode},
    {PRST_PRINTER_INFO_7,               &TPrnStream::RestorePrnInfo7},
    {PRST_PRINTER_DATA,                 &TPrnStream::RestorePrnData},
    {PRST_PRINTER_SEC,                  &TPrnStream::RestorePrnSecurity},
    {PRST_USER_DEVMODE,                 &TPrnStream::RestoreUserDevMode},
    {0,                                 NULL}};


    //
    // initialize the flags that were successfully stored with 0
    //
    RestoredFlags = 0;

    //
    // if  PRST_RESOLVE_PORT is set , update m_ResolveCase so RestorePrnInfo2 can act properly
    //
    PortNameCase(Flags);

    //
    // if  PRST_RESOLVE_SHARE is set , update m_ResolveCase so RestorePrnInfo2 can act properly
    //
    ShareNameCase(Flags);

    for(int idx = 0 ; RestoreFunctTable[idx].iKeyWord && SUCCEEDED(hr); idx++)
    {
        if(Flags & RestoreFunctTable[idx].iKeyWord)
        {
            hr DBGCHK = (this->*RestoreFunctTable[idx].pPrstFunc)();

            if(SUCCEEDED(hr))
            {
                RestoredFlags |= RestoreFunctTable[idx].iKeyWord;
            }

        }

    }


    return hr;

}
/*++

Title:

    bStorePrnInfo2

Routine Description:

    Build an item based on P_I_2 and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnInfo2(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_2    lpPrinterInfo2 = NULL;


    //
    // Get P_I_2
    //
    cbSize = 1;

    if(bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                    2,
                                    reinterpret_cast<PVOID*>(&lpPrinterInfo2),
                                    &cbSize))
    {
        DBGMSG( DBG_TRACE,  ("StorePrnInfo2 %d \n" , cbSize) );

        hr DBGCHK = WritePrnInfo2(lpPrinterInfo2, cbSize);

        FreeMem(lpPrinterInfo2);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PI2);
    }

    return hr;

}

/*++

Title:

    bRestorePrnInfo2

Routine Description:

    Apply P_I_2 settings read from stream  to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnInfo2(
    VOID
    )
{
    PrnBinInfo*         pSourcePI2 = NULL;
    TStatusH            hr;
    TStatusB            bStatus;
    PRINTER_INFO_2*     pDestinationPI2 = NULL;
    DWORD               cbSize = 0;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo2(&pSourcePI2);

    if(SUCCEEDED(hr))
    {
        cbSize = 1;

        bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                     2,
                                     reinterpret_cast<PVOID*>(&pDestinationPI2),
                                     &cbSize);

        if(bStatus)
        {
            LPTSTR* ppszStoredPrnName = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPrinterName
                                         );

            LPTSTR* ppShareName       = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pShareName
                                         );

            LPTSTR* ppPortName       = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPortName
                                         );

            LPTSTR* ppPrintProcessor = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->pPrintProcessor
                                         );

            LPDWORD pAttributes = &(reinterpret_cast<PRINTER_INFO_2*>(
                                         reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData)->Attributes
                                         );

            DBGMSG(DBG_TRACE , (" Stored Prn Name: "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

            //
            //  check against printer name
            //
            if( _tcsicmp( pDestinationPI2->pPrinterName, *ppszStoredPrnName ) != 0)
            {
                if(m_ResolveCase & kResolveName)
                {
                    // RESOLVE!!!
                    // if printer name differs from printer name stored into file ,
                    // update read structure with open printer
                    //
                    DBGMSG(DBG_TRACE , (" RESOLVE Printer : "TSTR" Share:"TSTR" old : "TSTR"\n" , *ppszStoredPrnName , *ppShareName , pDestinationPI2->pShareName));

                    *ppszStoredPrnName = pDestinationPI2->pPrinterName;


                }
                else if(m_ResolveCase & kForceName)
                {
                    // FORCE!!!
                    // if printer name differs from printer name stored into file ,
                    // let printer name and share name as they are in the stored file
                    //

                    DBGMSG(DBG_TRACE , (" FORCE Printer : "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

                }
                else
                {

                    //
                    // if printer name differs from printer name stored into file ,
                    // return error ; printer names are different but the flags are not used
                    //
                    hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);

                    goto End;
                }
            }

            //
            //  if resolve port option was set , port name from the printer configuration settings to be ignored in lieu of
            //  the port name that printer curently has
            //
            if(m_ResolveCase & kResolvePort)
            {
                *ppPortName = pDestinationPI2->pPortName;;
            }


            //
            // if the print processor from the printer configuration settings differs from the curent installed print processor
            // just ignore it
            //
            if( _tcsicmp( pDestinationPI2->pPrintProcessor, *ppPrintProcessor) != 0 )
            {
                *ppPrintProcessor = pDestinationPI2->pPrintProcessor;
            }

            if((reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData))->pDevMode)
            {
                (reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData))->pDevMode = NULL;

                DBGMSG(DBG_TRACE , (" Reset devmode to NULL!\n" ));
            }

            //
            // Set printer with read settings
            //
            bStatus DBGCHK = SetPrinter(m_hPrinter,
                             2,
                             reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData,
                             0);

            //
            // If SetPrinter failed with ERROR_INVALID_SHARENAME and a resolve share flag is set,
            // retry call SetPrinter with a new generated share name
            //
            if(!bStatus &&
               (m_ResolveCase & ( kUntouchShare | kGenerateShare )) &&
               GetLastError() == ERROR_INVALID_SHARENAME)
            {

                TString strShareName;
                TString strPrinterName( pDestinationPI2->pPrinterName );

                //
                // If already shared, use the current share name
                // Even if generating share flag is set, don't create a new share name
                // as long as the printer is shared. The whole point of this share name generation is
                // to allow the printer to be shared, but since it is , don't waist any time.
                //
                if( pDestinationPI2->Attributes & PRINTER_ATTRIBUTE_SHARED &&
                    pDestinationPI2->pShareName &&
                    pDestinationPI2->pShareName[0] )
                {
                    *ppShareName  = pDestinationPI2->pShareName;
                    *pAttributes |= PRINTER_ATTRIBUTE_SHARED;

                }
                else
                {
                    //
                    // Resolve share name by generating a new share name
                    //
                    if(m_ResolveCase & kGenerateShare)
                    {
                        if( VALID_OBJ( strPrinterName ) )
                        {
                            bStatus DBGCHK = bNewShareName(pDestinationPI2->pServerName, strPrinterName, strShareName);

                            *ppShareName  = (LPTSTR)(LPCTSTR)(strShareName);
                            *pAttributes |= PRINTER_ATTRIBUTE_SHARED;

                            //
                            // *ppShareName is NULL if bNewShareName fails
                            //
                            DBGMSG( DBG_TRACE, ( "Created share name for " TSTR " " TSTR "\n", (LPCTSTR)strPrinterName, (LPCTSTR)strShareName ) );
                        }

                    }

                    //
                    // Don't share it at all
                    //
                    if(m_ResolveCase & kUntouchShare)
                    {
                        *pAttributes &= ~PRINTER_ATTRIBUTE_SHARED;
                        *ppShareName  = NULL;
                    }

                }

                //
                // Set printer with read settings
                //
                bStatus DBGCHK = SetPrinter(m_hPrinter,
                                 2,
                                 reinterpret_cast<LPBYTE>(pSourcePI2) + pSourcePI2->pData,
                                 0);

                DBGMSG(DBG_TRACE , (" RESOLVE Printer : "TSTR" Share:"TSTR"\n" , *ppszStoredPrnName , *ppShareName));

            }
End:
            if(bStatus)
            {
                hr DBGNOCHK = S_OK;

                DBGMSG(DBG_TRACE , (" SetPrinter on level 2 succeeded!\n" ));
            }
            else
            {

             hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);

            }

            FreeMem(pSourcePI2);

            if(pDestinationPI2 != NULL)
            {
                FreeMem(pDestinationPI2);
            }

        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI2);
        }
    }


    return hr;
}

/*++

Title:

    bStorePrnInfo7

Routine Description:

    Build an item based on P_I_7 and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnInfo7(
    VOID
    )
{
    DWORD                               cbSize;
    TStatusH                        hr;
    TStatusB                        bStatus;
    LPPRINTER_INFO_7    lpPrinterInfo7 = NULL;

    //
    // Get P_I_7
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 7,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo7),
                                 &cbSize);

    if(bStatus)
    {
        //
        // remove DSPRINT_PENDING flags
        //
        lpPrinterInfo7->dwAction &= ~DSPRINT_PENDING;

        hr DBGCHK = WritePrnInfo7(lpPrinterInfo7, cbSize);

        FreeMem(lpPrinterInfo7);

    }
    else
    {
        if(GetLastError() == ERROR_INVALID_LEVEL)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PI7);
        }

    }

    return hr;
}

/*++

Title:

    RestorePrnInfo7

Routine Description:

    Apply P_I_7 settings read from stream  to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnInfo7(
    VOID
    )
{
    DWORD           cbSize;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;
    DWORD           LastError;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo7(&lpPrnBinItem);

    if(SUCCEEDED(hr) && lpPrnBinItem)
    {
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     7,
                                     reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData,
                                     0);

        LastError = GetLastError();
        if(LastError == ERROR_IO_PENDING ||
           LastError == ERROR_DS_UNAVAILABLE)
        {
            //
            // If the error is io  pending the spooler
            // will publish in the background therefore we will silently fail.
            // and
            // The server must be stand alone and/or DirectoryService is not available.
            // Just continue.
            //
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PI7);

        }

        FreeMem(lpPrnBinItem);
    }

    return hr;
}

/*++

Title:

    StorePrnSecurity

Routine Description:

    Build an item based on security descriptor and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR_GET_SEC error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnSecurity(
    VOID
    )
{
    DWORD           cbSize;
    TStatusH        hr;
    TStatusB        bStatus;
    PRINTER_INFO_2* lpPrinterInfo2 = NULL;


    //
    // Get P_I_2
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 2,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo2),
                                 &cbSize);
    if(bStatus)
    {
        hr DBGCHK = WritePrnSecurity(lpPrinterInfo2, cbSize);

        FreeMem(lpPrinterInfo2);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_SEC);
    }

    return hr;
}

/*++

Title:

    RestorePrnSecurity

Routine Description:

    Apply security descriptor read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/

HRESULT
TPrnStream::
RestorePrnSecurity(
    VOID
    )
{
    DWORD           cbSize;
    PRINTER_INFO_3  PrinterInfo3;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnSecurity(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        PrinterInfo3.pSecurityDescriptor =  reinterpret_cast<PSECURITY_DESCRIPTOR>(
                                            reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                            );
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     3,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo3),
                                     0);
        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_SEC);
        }

        FreeMem(lpPrnBinItem);

    }

    return hr;
}

/*++

Title:

    StoreUserDevMode

Routine Description:

    Build an item based on user dev mode and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StoreUserDevMode(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_9    lpPrinterInfo9 = NULL;

    //
    // Get P_I_9
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 9,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo9),
                                 &cbSize);
    if(bStatus)
    {
        //
        // call WritePrnInfo9 even if lpPrinterInfo9 is null ;
        // usually, when printer doesn't have a user mode attached ,is lpPrinterInfo9->pDevMode who is null
        // but still call it and check lpPrinterInfo9 == NULL on WritePrnInfo9, to act similar as lpPrinterInfo9->pDevMode == NULL
        //
        hr DBGCHK = WritePrnInfo9(lpPrinterInfo9, cbSize);

        FreeMem(lpPrinterInfo9);

    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_USR_DEVMODE);
    }

    return hr;
}
/*++

Title:

    RestoreUserDevMode

Routine Description:

    Apply user dev mode read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestoreUserDevMode(
    VOID
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    PRINTER_INFO_9  PrinterInfo9;
    TStatusH        hr;
    TStatusB        bStatus;
    DWORD           cbSize;


    hr DBGNOCHK = E_FAIL;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo9(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        if(lpPrnBinItem != NULL)
        {
            PrinterInfo9.pDevMode = reinterpret_cast<DEVMODE*>(
                                    reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                    );
        }
        else
        {
            //
            // User dev mode can be null if there are no Printer prefferences set at the time the file is created
            // We remove per user devmode by calling SetPrinter with pDevMode equal with NULL
            //
            DBGMSG(DBG_TRACE , ("NO USER DEVMODE STORED!!!\n"));

            PrinterInfo9.pDevMode = NULL;
        }

        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     9,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo9),
                                     0);

        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_USR_DEVMODE);
        }


        FreeMem(lpPrnBinItem);

    }

    return hr;
}




/*++

Title:

    StorePrnDevMode

Routine Description:

    Build an item based on printer dev mode and write it into the stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StorePrnDevMode(
    VOID
    )
{
    DWORD               cbSize;
    TStatusH            hr;
    TStatusB            bStatus;
    LPPRINTER_INFO_8    lpPrinterInfo8 = NULL;

    hr DBGNOCHK = E_FAIL;
    //
    // Get P_I_8
    //
    cbSize = 1;

    bStatus DBGCHK = bGetPrinter(m_hPrinter,
                                 8,
                                 reinterpret_cast<PVOID*>(&lpPrinterInfo8),
                                 &cbSize);
    if(bStatus)
    {
        bStatus DBGCHK = (lpPrinterInfo8->pDevMode != NULL);

        if(bStatus)
        {
            hr DBGCHK = WritePrnInfo8(lpPrinterInfo8, cbSize);
        }

        FreeMem(lpPrinterInfo8);

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_PRN_DEVMODE);
    }

    return hr;
}

/*++

Title:

    RestorePrnDevMode

Routine Description:

    Apply printer dev mode read from stream to binded printer

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnDevMode(
    VOID
    )
{
    DWORD           cbSize;
    PRINTER_INFO_8  PrinterInfo8;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus;
    BOOL            bInsidePI2;

    hr DBGNOCHK = E_FAIL;

    //
    // Reads settings stored in stream
    //
    hr DBGCHK = ReadPrnInfo8(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        PrinterInfo8.pDevMode = reinterpret_cast<DEVMODE*>(
                                reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData
                                );
        //
        // Set printer with read settings
        //
        bStatus DBGCHK = SetPrinter( m_hPrinter,
                                     8,
                                     reinterpret_cast<LPBYTE>(&PrinterInfo8),
                                     0);

        if(bStatus)
        {
            hr DBGNOCHK = S_OK;
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PRN_DEVMODE);
        }


        FreeMem(lpPrnBinItem);

    }

    return hr;
}

/*++

Title:

    StoreColorProfiles

Routine Description:

    strore a multi zero string with color profiles into stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
StoreColorProfiles(
    VOID
    )
{
    TStatusH                    hr;
    TStatusB                        bStatus;

    DWORD           cbSize;
    DWORD           dwProfiles;
    ENUMTYPE        EnumType;

    LPTSTR          mszProfileNames;

    ZeroMemory(&EnumType, sizeof(EnumType));

    EnumType.dwSize      = sizeof(EnumType);
    EnumType.dwVersion   = ENUM_TYPE_VERSION;
    EnumType.dwFields    = ET_DEVICENAME | ET_DEVICECLASS;
    EnumType.pDeviceName = static_cast<LPCTSTR>(m_strPrnName);
    EnumType.dwDeviceClass = CLASS_PRINTER;


    cbSize = 0;

    m_EnumColorProfiles(NULL, &EnumType, NULL, &cbSize, &dwProfiles);

    mszProfileNames = (LPTSTR)AllocMem(cbSize);

    bStatus DBGCHK = (mszProfileNames != NULL);

    if(bStatus)
    {

        bStatus DBGCHK = m_EnumColorProfiles( NULL,
                                            &EnumType,
                                            reinterpret_cast<LPBYTE>(mszProfileNames),
                                            &cbSize,
                                            &dwProfiles);
        if(bStatus)
        {
            hr DBGCHK = WriteColorProfiles(reinterpret_cast<LPBYTE>(mszProfileNames), cbSize);
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_COLOR_PRF);
        }


        FreeMem(mszProfileNames);
    }
    else
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_GET_COLOR_PRF);
    }


    return hr;
}

/*++

Title:

    DeleteColorProfiles

Routine Description:

    deletes all profiles associated with printer
    it is called on restoring color settings; needed because if a new color profile is added ,
    settings from file will be restored on top ( #bug 274657)
    it could work Ok without calling this function when P_I_2 is also restored, because there color profiles are "somehow" restored,
    but even so, success was depending on the order of calls,which is bogus

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
BOOL
TPrnStream::
DeleteColorProfiles(
    VOID
    )
{
    TStatusB    bStatus;

    DWORD           cbSize;
    DWORD           cbPrfSize;
    DWORD           dwProfiles;
    ENUMTYPE        EnumType;

    LPTSTR          mszProfileNames;

    ZeroMemory(&EnumType, sizeof(EnumType));

    EnumType.dwSize        = sizeof(EnumType);
    EnumType.dwVersion     = ENUM_TYPE_VERSION;
    EnumType.dwFields      = ET_DEVICENAME | ET_DEVICECLASS;
    EnumType.pDeviceName   = static_cast<LPCTSTR>(m_strPrnName);
    EnumType.dwDeviceClass = CLASS_PRINTER;


    cbSize = 0;

    m_EnumColorProfiles(NULL, &EnumType, NULL, &cbSize, &dwProfiles);

    mszProfileNames = (LPTSTR)AllocMem(cbSize);

    bStatus DBGCHK = (mszProfileNames != NULL);

    if(bStatus)
    {

        bStatus DBGCHK = m_EnumColorProfiles( NULL,
                                            &EnumType,
                                            reinterpret_cast<LPBYTE>(mszProfileNames),
                                            &cbSize,
                                            &dwProfiles);
        if(bStatus)
        {
            LPTSTR pszProfileName = mszProfileNames;

            for(bStatus DBGNOCHK = TRUE ,cbPrfSize = 0; (cbPrfSize < cbSize) && bStatus;)
            {

                //
                // skip last two zeros
                //
                if(_tcsclen(pszProfileName) > 0)
                {
                    DBGMSG( DBG_TRACE, ( "DisassociateColorProfileWithDevice  "TSTR" ::  " TSTR " \n" ,
                    static_cast<LPCTSTR>(m_strPrnName) , pszProfileName ));

                    bStatus DBGCHK = m_DisassociateColorProfileFromDevice(NULL, pszProfileName, m_strPrnName);
                }

                cbPrfSize += (_tcsclen(pszProfileName) + 2) * sizeof(TCHAR);

                pszProfileName = pszProfileName + _tcsclen(pszProfileName) + 1;

            }

        }


        FreeMem(mszProfileNames);
    }


    return bStatus;
}

/*++

Title:

    RestoreColorProfiles

Routine Description:

    Reads multi zero string from stream and for every sz calls AssociateColorProfileWithDevice

Arguments:

    NONE

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestoreColorProfiles(
    VOID
    )
{
    DWORD           cSize;
    DWORD           i;
    LPTSTR          pszProfileName;
    LPTSTR          aszProfileNames;
    PrnBinInfo*     lpPrnBinItem = NULL;
    TStatusH        hr;
    TStatusB        bStatus(DBG_WARN, ERROR_INSUFFICIENT_BUFFER);


    hr DBGCHK = ReadColorProfiles(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        //
        // first delete color profiles assoc with printer; fix for bug 274657
        //
        bStatus DBGCHK = DeleteColorProfiles();

        if(bStatus)
        {
            aszProfileNames = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData);

            cSize = lpPrnBinItem->cbData/sizeof(TCHAR);

            //
            // Traverse multisz string from tail to head starting with the first zero.
            // I relay on the fact that multisz is terminated by 2 zeros.
            // Default color profile is last color profile associated and we should preserve this setting.
            //
            for( bStatus DBGNOCHK = TRUE, i = 2; i <= cSize && bStatus; )
            {
                pszProfileName = aszProfileNames + cSize - i;

                if( *(pszProfileName - 1) == 0 || (i == cSize) )
                {
                    DBGMSG( DBG_TRACE, ( "AssociateColorProfileWithDevice  "TSTR" ::  " TSTR " \n" ,
                    static_cast<LPCTSTR>(m_strPrnName) , pszProfileName ));

                    bStatus DBGCHK = m_AssociateColorProfileWithDevice(NULL, pszProfileName, m_strPrnName);

                    hr DBGCHK = bStatus ? S_OK : MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_COLOR_PRF);

                }

                i++;

            }

        }

        FreeMem(lpPrnBinItem);
    }

    return hr;
}

/*++

Title:

    WritePrnData

Routine Description:

    Build an PrnBinInfo item from key and value and write it into stream, at current position

  steps:

        WriteHeader: if header is not wrriten into file , write it down
                Read from header number of items currently written
                Read from header where prn data items begins
                If no other items where written,get current position and after items storing, update header with start position
                Build an PrnBinInfo item and write it into stream, at current position
                Increase number of written items and Update header

Arguments:

    pKey            - key name ;

    pValueName      - key value ;

    cbValueName     - count bytes of pValueName

    dwType          - type

    pData           - actually data

    cbData          - count bytes of pData

Return Value:

    S_OK  if succeded


--*/
HRESULT
TPrnStream::
WritePrnData(
    IN  LPCTSTR pKey,
    IN  LPCTSTR pValueName,
    IN  DWORD   cbValueName,
    IN  DWORD   dwType,
    IN  LPBYTE  pData,
    IN  DWORD   cbData
    )
{
    ULARGE_INTEGER          culiPrnDataItems;
    ULARGE_INTEGER          uliCurrentPos;
    ULARGE_INTEGER          uliPrnDataRoot;
    TStatusB                bStatus;
    TStatusH                hr;

    bStatus DBGNOCHK = TRUE;

    //
    // Read from header number of items currently written
    //
    hr DBGCHK = ReadFromHeader(kcItems, &culiPrnDataItems);

    if(SUCCEEDED(hr))
    {
        //
        // Read from header where info begins in stream
        //
        hr DBGCHK = ReadFromHeader(kPrnDataRoot, &uliPrnDataRoot);

        if(SUCCEEDED(hr))
        {
            if(uliPrnDataRoot.QuadPart == 0)
            {
                // Get current seek position ; it will be stored in header
                //
                DBGMSG( DBG_TRACE, ( "TPrnStream::bWritePrnData:: First prn data item!\n " ));

                hr DBGCHK =  GetCurrentPosition(uliCurrentPos);

            }

            if(SUCCEEDED(hr))
            {
                //
                // Store item
                //
                hr DBGCHK = WriteItem(  pKey,
                                        pValueName,
                                        cbValueName,
                                        ktREG_TYPE + dwType,
                                        pData,
                                        cbData);
                if(SUCCEEDED(hr))
                {
                    //
                    // Updates number of items and start position in case that bWritePrnData succeded
                    // and it was the first prn data item written
                    //
                    culiPrnDataItems.QuadPart++;

                    hr DBGCHK = UpdateHeader(TPrnStream::kcItems, culiPrnDataItems);

                    if(SUCCEEDED(hr)  && uliPrnDataRoot.QuadPart == 0)
                    {
                        //
                        // Update header with position where item begins if it was the first prn data item written
                        //
                        hr DBGCHK = UpdateHeader(TPrnStream::kPrnDataRoot, uliCurrentPos);

                    }

                }

            }

        }

    }

    return hr;
}
/*++

Title:

    ReadNextPrnData

Routine Description:

    Read a printer data item from stream

Arguments:

    Param pointers will point inside of lpBuffer:

    pKey            - key name ;not null

        pValueName      - key value ;not  null

        cbValueName     - count bytes of pValueName

        dwType          - type

        pData           - actually data

        cbData          - count bytes of pData


        lpBuffer    -   a null ptr that will contain ptr to read item;
                    must be deallocated by the caller if function succeed

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadNextPrnData(
    OUT LPTSTR& lpszKey,
    OUT LPTSTR& lpszVal,
    OUT DWORD&  dwType,
    OUT LPBYTE& lpbData,
    OUT DWORD&  cbSize,
    OUT LPBYTE& lpBuffer    ORPHAN
    )
{
    TStatusH        hr;
    PrnBinInfo*     lpPrnBinItem = NULL;

    lpszKey = NULL;
    lpszVal = NULL;
    lpbData = NULL;
    lpBuffer = NULL;

    cbSize = 0;

    //
    // Initialization!!!
    // m_cIndex is current item for reading ; m_cPrnDataItems is  number of items in stream ( entry in header )
    // chesk to see if no items where read or if all itemes where read and m_cIndex passed the printers data area in stream
    //
    if((m_cPrnDataItems.QuadPart == 0) || (m_cIndex > m_cPrnDataItems.QuadPart))
    {
        //
        // Read from header number of printer data items in stream
        //
        hr DBGCHK = ReadFromHeader(kcItems, &m_cPrnDataItems);

        if(FAILED(hr))
        {
            goto End;
        }
        //
        // Read from header where info begins in stream
        // m_uliSeekPtr seek ptr will be always positioned where item begins
        //
        hr DBGCHK = ReadFromHeader(kPrnDataRoot, &m_uliSeekPtr);

        if(FAILED(hr))
        {
            goto End;
        }

        m_cIndex = 0;
    }

    if(m_cIndex == m_cPrnDataItems.QuadPart)
    {
        DBGMSG( DBG_TRACE, ( "bReadNextPrnData :: Reach end of prn data items \n" ));

        hr DBGNOCHK = STG_E_SEEKERROR;

        //
        // this way I indicate that I reached the end ;
        // next call will see that m_cIndex > m_cPrnDataItems.QuadPart and will do the same as if
        // I call this first time
        //
        m_cIndex++;

    }
    else
    {
        //
        // dwSeekPtr will be set to the position where next prn data item begins
        //
        hr DBGCHK = ReadItemFromPosition(m_uliSeekPtr, lpPrnBinItem);

        if(SUCCEEDED(hr))
        {
            m_cIndex++;

            lpszKey = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pKey);
            lpszVal = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pValue);
            lpbData = reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData;
            cbSize  = lpPrnBinItem->cbData;
            dwType  = lpPrnBinItem->dwType - ktREG_TYPE;

        }

    }


    End:

    if(FAILED(hr) && hr != STG_E_SEEKERROR)
    {
        //
        // build my own result ; it will override STG_ results
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PRNDATA);
    }

    return hr;
}

/*++

Title:

    WritePrnInfo2

Routine Description:

    Build an item based on P_I_2 and write it into the stream
    Convert P_I_2 into a flat buffer( LPTSTR -> offsets)
    Build a PrnBinInfo item and write it into stream

Arguments:

    lpPrinterInfo2  -   ptr to P_I_2

    cbPI2Size       - P_I_2 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo2(
    IN  PRINTER_INFO_2* lpPrinterInfo2,
    IN  DWORD           cbPI2Size
    )
{

    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusH        hr;
    TStatusB        bStatus;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo2 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Convert P_I_2 to flat buffer
            //
            lpPrinterInfo2->pSecurityDescriptor = 0;

            MarshallDownStructure(reinterpret_cast<LPBYTE>(lpPrinterInfo2),
                                  PrinterInfo2Fields,
                                  sizeof(PRINTER_INFO_2),
                                  RPC_CALL);

            //
            // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktPrnInfo2 ,reinterpret_cast<LPBYTE>(lpPrinterInfo2), cbPI2Size);

            if(SUCCEEDED(hr))
            {
                //
                // Update header entry with start position in stream
                //
                hr DBGCHK = UpdateHeader(kPrnInfo2, uliCurrentPos);

                //
                // Printer name entry in header will point inside PI2
                // if PI2 is not stored , printer name will be stored like an usual item
                //
                if(SUCCEEDED(hr))
                {
                    //uliCurrentPos.QuadPart += OFFSETOF(PRINTER_INFO_2, pPrinterName);

                    hr DBGCHK = UpdateHeader(kPrnName, uliCurrentPos);

                }

            }

        }

    }


    if(FAILED(hr))
    {
        //
        // build my own result
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI2);
    }

    return hr;
}


/*++

Title:

    WritePrnName

Routine Description:

    Build a PrnBinInfo item from printer name and write it into stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnName(
    VOID
    )
{

    ULARGE_INTEGER          uliCurrentPos;
    TStatusH                hr;

    hr DBGNOCHK = E_FAIL;


    //
    // Get item's start position
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
        //
        hr DBGCHK = WriteItem(  NULL,
                                NULL,
                                0,
                                ktPrnName ,
                                reinterpret_cast<LPBYTE>(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_strPrnName))),
                                (m_strPrnName.uLen() + 1) * sizeof(TCHAR));


        if(SUCCEEDED(hr))
        {
            hr DBGCHK = UpdateHeader(kPrnName, uliCurrentPos);
        }
    }

    if(FAILED(hr))
    {
        //
        // build my own result
        //
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI2);
    }

    return hr;
}


/*++

Title:

    ReadPrnInfo2

Routine Description:

    Reads the P_I_2 entry in stream ;

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo2(
    OUT PrnBinInfo**        lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;
    TStatusB        bStatus;


    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK = TRUE;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnInfo2, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

            if(SUCCEEDED(hr))
            {
                hr DBGCHK = MarshallUpItem(lpPrnBinItem);
            }
        }
        else
        {
            hr DBGCHK = E_FAIL;
        }
    }


    if(FAILED(hr))
    {
        if( lpPrnBinItem )
        {
            FreeMem(lpPrnBinItem);
        }

        *lppPrnBinItem = NULL;

        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PI7);
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    ReadPrnName

Routine Description:

    Reads the P_I_2 entry in stream; if not P_I_2 settings stored , reads PrnName entry

Arguments:

    strPrnName    -  printer name read from file

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadPrnName(
    OUT     TString&        strPrnName
    )
{
    PrnBinInfo*         lpPrnBinItem = NULL;
    TStatusH            hr;
    ULARGE_INTEGER      uliSeekPtr;
    LPTSTR              lpszPrnName;

    //
    // Reads PRINTER_INFO_2 settings stored in stream.
    // Printer Name is not stored if  PRINTER_INFO_2 are stored.
    //
    hr DBGCHK = ReadPrnInfo2(&lpPrnBinItem);

    if(SUCCEEDED(hr))
    {
        //
        // printer name points inside P_I_2
        //

        DBGMSG( DBG_TRACE, ( "PrnName inside P_I2 \n"));

        lpszPrnName = (reinterpret_cast<PRINTER_INFO_2*>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData)->pPrinterName);

        hr DBGCHK = strPrnName.bUpdate(lpszPrnName) ? S_OK : E_FAIL;

        DBGMSG( DBG_TRACE, ( "PrnName "TSTR" \n" , static_cast<LPCTSTR>(strPrnName)));

    }
    else
    {
        //
        // Reads the Header entry for Printer name.
        //
        hr DBGCHK = ReadFromHeader(kPrnName, &uliSeekPtr);

        if(SUCCEEDED(hr))
        {
            //
            // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
            //
            if(uliSeekPtr.QuadPart > 0)
            {
                //
                // Read an item from specified position
                //

                hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

                if(SUCCEEDED(hr))
                {
                    DBGMSG( DBG_TRACE, ( "ReadPrnName from %d %d \n" , uliSeekPtr.HighPart, uliSeekPtr.LowPart));

                    hr DBGCHK = strPrnName.bUpdate(reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData)) ?
                                S_OK : E_FAIL;

                    DBGMSG( DBG_TRACE, ( "PrnName "TSTR" \n" , static_cast<LPCTSTR>(strPrnName)));

                }
                else
                {
                    hr DBGCHK = E_FAIL;
                }

            }
            else
            {
                hr DBGCHK = E_FAIL;
            }

        }
    }

    if (lpPrnBinItem)
    {
        FreeMem(lpPrnBinItem);
    }

    return hr;
}


/*++

Title:

    WritePrnInfo7

Routine Description:

    Build an item based on P_I_7 and write it into the stream
    PRINTER_INFO_7.pszObjectGUID set on NULL because at restoring it has to be null -> no flat pointer conversion needed

Arguments:

    lpPrinterInfo7  -   ptr to P_I_7

    cbPI7Size       -   P_I_7 buff actual size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo7(
    IN  PRINTER_INFO_7* lpPrinterInfo7,
    IN  DWORD           cbPI7Size
    )
{

    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB        bStatus;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo7 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Convert P_I_7 to flat buffer
            //

            lpPrinterInfo7->pszObjectGUID = NULL;

            MarshallDownStructure(reinterpret_cast<LPBYTE>(lpPrinterInfo7),
                                  PrinterInfo7Fields,
                                  sizeof(PRINTER_INFO_7),
                                  RPC_CALL);

            //
            // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktPrnInfo7 ,reinterpret_cast<LPBYTE>(lpPrinterInfo7), cbPI7Size);

            //
            // Update header entry with start position in stream
            //
            if(SUCCEEDED(hr))
            {
                hr DBGCHK = UpdateHeader(kPrnInfo7, uliCurrentPos);
            }
        }
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PI7);
    }

    return hr;
}


/*++

Title:

    ReadPrnInfo7

Routine Description:

    Reads the P_I_7 entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo7(
    OUT  PrnBinInfo**   lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusB        bStatus;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;
    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnInfo7, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        // function will succeed
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //

            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

            if(SUCCEEDED(hr))
            {
                hr DBGCHK = MarshallUpItem(lpPrnBinItem);
            }
        }
        else
        {
            hr DBGCHK = E_FAIL;
        }
    }

    if(FAILED(hr))
    {
        *lppPrnBinItem = NULL;

        if( lpPrnBinItem )
        {
            FreeMem(lpPrnBinItem);
        }

        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PI7);
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnSecurity

Routine Description:

    Build an item based on SecurityDescriptor and write it into the stream

Arguments:

    lpPrinterInfo2  -   ptr to P_I_2

    cbPI2Size       - P_I_2 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed
--*/
HRESULT
TPrnStream::
WritePrnSecurity(
    IN  PRINTER_INFO_2* lpPrinterInfo2,
    IN  DWORD           cbPI2Size
    )
{
    DWORD           cbSize;
    DWORD           dwWritten;
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB    bStatus;
    TStatusH    hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo2 != NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            if(lpPrinterInfo2->pSecurityDescriptor != NULL)
            {
                cbSize = GetSecurityDescriptorLength(lpPrinterInfo2->pSecurityDescriptor);

                bStatus DBGCHK =( cbSize >= SECURITY_DESCRIPTOR_MIN_LENGTH);

                //
                // alloc mem for flat buffer
                //
                if(bStatus)
                {
                    //
                    // Writes flat buffer into stream (WriteItem builds PrnBinInfo)
                    //
                    hr DBGCHK = WriteItem(  NULL,
                                            NULL,
                                            0,
                                            ktSecurity ,
                                            reinterpret_cast<LPBYTE>(lpPrinterInfo2->pSecurityDescriptor),
                                            cbSize);

                    if(SUCCEEDED(hr))
                    {
                        //
                        // Update header entry with start position in stream
                        //
                        hr DBGCHK = UpdateHeader(kSecurity, uliCurrentPos);
                    }
                }
                else
                {
                    hr DBGCHK = E_FAIL;
                }

            }

        }

    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_SEC);
    }

    return hr;

}

/*++

Title:

    ReadPrnSecurity

Routine Description:

    Reads the Security entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnSecurity(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;


    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kSecurity, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        //
        // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
        //
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //

            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }
        else
        {
            hr DBGCHK = E_FAIL;
        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_SEC);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnInfo8

Routine Description:

    Call WriteDevMode to write devmode into stream

Arguments:

    lpPrinterInfo8  -   ptr to P_I_8

    cbSize          -   P_I_8 buffer actual size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo8(
    IN  PRINTER_INFO_8* lpPrinterInfo8,
    IN  DWORD           cbSize
    )
{
    TStatusB bStatus;
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo8 != NULL) && (lpPrinterInfo8->pDevMode != NULL);

    if(bStatus)
    {
        hr DBGCHK = WriteDevMode(   lpPrinterInfo8->pDevMode,
                                    lpPrinterInfo8->pDevMode->dmSize + lpPrinterInfo8->pDevMode->dmDriverExtra,
                                    kPrnDevMode);
    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PRN_DEVMODE);
    }

    return hr;
}

/*++

Title:

    ReadPrnInfo8

Routine Description:

    Reads the Printer Dev Mode entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

    bInsidePI2      -   TRUE if global dev mode was inside P_I_2 item

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo8(
    OUT PrnBinInfo**    lppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kPrnDevMode, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart == 0)
        {
            //
            // no dev mode stored
            //
            hr DBGCHK = E_FAIL;
        }
        else
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }

    }


    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_PRN_DEVMODE);

        *lppPrnBinItem = NULL;
    }
    else
    {
        *lppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WritePrnInfo9

Routine Description:

    Call WriteDevMode to write devmode into stream

Arguments:

    lpPrinterInfo9  -   ptr to P_I_9

    cbSize          -   P_I_9 buff size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WritePrnInfo9(
    IN  PRINTER_INFO_9* lpPrinterInfo9,
    IN  DWORD           cbSize
    )
{
    TStatusB bStatus;
    TStatusH hr;
    ULARGE_INTEGER  uliCurrentPos;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpPrinterInfo9 != NULL) && (lpPrinterInfo9->pDevMode != NULL);

    if(bStatus)
    {
        hr DBGCHK = WriteDevMode(   lpPrinterInfo9->pDevMode,
                                    lpPrinterInfo9->pDevMode->dmSize + lpPrinterInfo9->pDevMode->dmDriverExtra,
                                    kUserDevMode);

    }
    else
    {
        //
        // set entry in header to a dummy value to show that dev mode was null
        //

        DBGMSG(DBG_TRACE , ("WritePrnInfo9 NO USER DEVMODE\n"));

        //
        // fix for bug 273541
        // For the case when per user dev mode is null , update the header with a special value ,
        // to signal that per user dev mode was stored in file.
        //
        uliCurrentPos.HighPart = -1;
        uliCurrentPos.LowPart  = -1;

        hr DBGCHK = UpdateHeader(kUserDevMode, uliCurrentPos);
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_USR_DEVMODE);
    }

    return hr;
}

/*++

Title:

    ReadPrnInfo9

Routine Description:

    Reads the User Dev Mode entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadPrnInfo9(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem = NULL;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kUserDevMode, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart == 0)
        {
            //
            // no dev mode stored because no flags were specified
            //
            hr DBGCHK = E_FAIL;
        }
        else if(uliSeekPtr.LowPart == -1 && uliSeekPtr.HighPart == -1)
        {
            //
            // dev mode was null at the time it was stored ( no Printing Prefferences set )
            //
            hr DBGNOCHK = S_OK;

            *ppPrnBinItem = NULL;
        }
        else
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_USR_DEVMODE);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WriteColorProfiles

Routine Description:

    Build a PrnBinInfo item from a multi sz string that contains color profiles names

Arguments:

    lpProfiles  -   ptr to multi zero string

    cbSize       -  multi zero string size

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
WriteColorProfiles(
    IN LPBYTE   lpProfiles,
    IN DWORD    cbSize
    )
{
    ULARGE_INTEGER          uliCurrentPos;
    TStatusB                bStatus;
    TStatusH                hr;

    hr DBGNOCHK = E_FAIL;

    bStatus DBGCHK =  (lpProfiles !=  NULL);

    if(bStatus)
    {
        //
        // Get item's start position
        //
        hr DBGCHK = GetCurrentPosition(uliCurrentPos);

        if(SUCCEEDED(hr))
        {
            //
            // Writes profiles(MULTI_SZ) into stream (WriteItem builds PrnBinInfo)
            //
            hr DBGCHK = WriteItem(NULL, NULL, 0, ktColorProfile, lpProfiles, cbSize);

            //
            // Update header entry with start position in stream
            //
            if(SUCCEEDED(hr))
            {
                hr DBGCHK = UpdateHeader(kColorProfile, uliCurrentPos);
            }
        }
    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_COLOR_PRF);
    }

    return hr;
}

/*++

Title:

    ReadColorProfiles

Routine Description:

    Reads the color profile entry in stream

Arguments:

    lppPrnBinItem   -   pointer to  readed item; NULL if no settings stored ;

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
ReadColorProfiles(
    OUT PrnBinInfo**    ppPrnBinItem
    )
{
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kColorProfile, &uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        if(uliSeekPtr.QuadPart > 0)
        {
            //
            // Read an item from specified position
            //
            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        }
        else
        {
            hr DBGCHK = E_FAIL;
        }

    }

    if(FAILED(hr))
    {
        hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_READ_COLOR_PRF);

        *ppPrnBinItem = NULL;
    }
    else
    {
        *ppPrnBinItem = lpPrnBinItem;
    }

    return hr;
}

/*++

Title:

    WriteHeader

Routine Description:

    Write header at the begining of file ; the header is null initialized

    steps:

        Write header into the stream; this is the very first writing operation
        It reserves space at the beginning of stream for writing info about items inside the stream
        StorePrintreInfo function will call WriteHeader before any other writing operation
        If P_I_2 flag is NOT specified , write printre name as item ; if it is , printe name  will be stored with P_I_2

Arguments:

    Flags   -   flags specified at storing time ; needed for printer name handling

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteHeader(
    IN DWORD    Flags
    )
{
    PrnHeader               PrinterHeader;
    DWORD                   dwSize = 0;
    LARGE_INTEGER           liStart = {0};
    TStatusH                hr;
    TStatusB                bStatus;

    // Init hr with S_OK;if header is already written in stream, this will be the return value
    //
    hr DBGNOCHK = S_OK;

    //
    // m_bHeaderWritten indicates if header was written into file
    //
    if(!m_bHeaderWritten)
    {
        //
        // Output the header.  This basically reserves
        // space at the beginning of the stream to store
        // the item-count.
        //
        PrinterHeader.pPrnName.QuadPart      = 0;
        PrinterHeader.pPrnDataRoot.QuadPart  = 0;
        PrinterHeader.cItems.QuadPart        = 0;
        PrinterHeader.pUserDevMode.QuadPart  = 0;
        PrinterHeader.pPrnDevMode.QuadPart   = 0;
        PrinterHeader.pPrnInfo2.QuadPart     = 0;
        PrinterHeader.pPrnInfo7.QuadPart     = 0;
        PrinterHeader.pSecurity.QuadPart     = 0;
        PrinterHeader.pColorProfileSettings.QuadPart  = 0;

        //
        // Make sure our header is positioned at the beginning of the stream.
        //

        hr DBGCHK = m_pIStream->Seek( liStart, STREAM_SEEK_SET, NULL );

        //
        // Write the header
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Write((LPBYTE)&PrinterHeader, sizeof(PrnHeader), &dwSize);

            //
            // indicates if header was written into file
            //
            m_bHeaderWritten = TRUE;

            //
            //  write printer info into an entry if P_I_2 is not stored.
            // if it is , prn name in header will point inside P_I_2
            //
            if(SUCCEEDED(hr) && !(Flags & PRST_PRINTER_INFO_2))
            {
                hr DBGCHK = WritePrnName();
            }
        }

        DBGMSG( DBG_TRACE ,( "WriteHeader %x !!!\n" , hr));
    }

    return hr;
}

#if DBG
VOID
TPrnStream::
CheckHeader (
    IN  TPrnStream::EHeaderEntryType    eHeaderEntryType,
    IN  ULARGE_INTEGER                  uliInfo
    )
{

    TStatusH    hr;
    ULARGE_INTEGER  uliPtr;

    EHeaderEntryType HeaderEntries[] = { kPrnDataRoot,
                                         kcItems,
                                         kUserDevMode,
                                         kPrnDevMode,
                                         kPrnInfo2,
                                         kPrnInfo7,
                                         kSecurity,
                                         kColorProfile };

    for( DWORD i = 0; i < sizeof (HeaderEntries) / sizeof (DWORD); i++ )
    {
        hr DBGCHK = ReadFromHeader(HeaderEntries[i], &uliPtr);

        if (SUCCEEDED(hr)) {

            //
            // PI2 and Printer Name can point to the same location. Don't do this check!
            //
            if ( ! ( HeaderEntries[i] == kPrnInfo2 && eHeaderEntryType == kPrnName ) ||
                   ( HeaderEntries[i] == kPrnName  && eHeaderEntryType == kPrnInfo2) ) {

                if( (uliPtr.LowPart && uliPtr.LowPart == uliInfo.LowPart ) || (uliPtr.HighPart && uliPtr.HighPart == uliInfo.HighPart) ) {
                    DBGMSG( DBG_TRACE,("*******CheckHeader:  %d overwrites %d\n" , eHeaderEntryType , HeaderEntries[i]));
                }
            }
        }

    }


}

#endif

/*++

Title:

    UpdateHeader

Routine Description:

    Write Info at specified entry in header
    Current position in stream in not modified after this call

Arguments:

    eHeaderEntryType    -   Specify entry in header

    uliInfo             -   Can be a pointer inside stream or a number of items

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
UpdateHeader(
    IN  TPrnStream::EHeaderEntryType    eHeaderEntryType,
    IN  ULARGE_INTEGER                  uliInfo
    )
{
    DWORD           dwSize;
    ULARGE_INTEGER  uliCurrentPosition;
    ULARGE_INTEGER  uliLastCurrentPosition;
    LARGE_INTEGER   liStart;
    TStatusH        hr;

#if DBG
    CheckHeader(eHeaderEntryType, uliInfo);
#endif

    // Saves current position into stream
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPosition);

    if(SUCCEEDED(hr))
    {
        //
        // Position stream pointer into the header on the specified entry
        //
        liStart.LowPart  = eHeaderEntryType * sizeof(LARGE_INTEGER);
        liStart.HighPart = 0;

        hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

        DBGMSG( DBG_TRACE,("TPrnStream::UpdateHeader\n Update at %d with %d\n" , liStart.LowPart , uliInfo));

        //
        // Setup the header information.
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Write(reinterpret_cast<LPVOID>(&uliInfo), sizeof(LARGE_INTEGER), &dwSize);
        }

        //
        // Restore stream current pointer (even if writing failed)
        //
        liStart.QuadPart = uliCurrentPosition.QuadPart;

        hr DBGCHK = m_pIStream->Seek( liStart, STREAM_SEEK_SET, &uliLastCurrentPosition );

        SPLASSERT( uliCurrentPosition.LowPart == uliLastCurrentPosition.LowPart );
        SPLASSERT( uliCurrentPosition.HighPart == uliLastCurrentPosition.HighPart );


    }

    return hr;
}

/*++

Title:

    ReadFromHeader

Routine Description:

    Read Info from specified entry in header
    Current position in stream in not modified after this call

Arguments:

    eHeaderEntryType    -   Specify entry in header

    puliInfo            -   holds the value found in header at position kHeaderEntryType

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadFromHeader(
    IN  TPrnStream::EHeaderEntryType    kHeaderEntryType,
    OUT ULARGE_INTEGER*                 puliInfo
    )
{
    DWORD                   dwSize;
    ULARGE_INTEGER  uliEntryInfo;
    ULARGE_INTEGER  uliCurrentPos;
    LARGE_INTEGER   liStart;
    TStatusH                hr;

    DBGMSG( DBG_NONE, ( "Read Header!\n"));

    //
    // Save current pos
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // seek pointer has to point to kHeaderEntryType into IStream
        //
        liStart.LowPart  = kHeaderEntryType * sizeof(LARGE_INTEGER);
        liStart.HighPart = 0;

        hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

        //
        // Read from header entry a DWORD
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = m_pIStream->Read(&uliEntryInfo, sizeof(LARGE_INTEGER), &dwSize);

            if(SUCCEEDED(hr))
            {
                puliInfo->QuadPart = uliEntryInfo.QuadPart;
            }
            else
            {
                DBGMSG( DBG_TRACE, ( "Read Header! FAILED !!!\n"));
            }

            //
            // Restore stream current pointer (even if reading failed)
            //
            liStart.QuadPart = uliCurrentPos.QuadPart;

            hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );
        }
    }

    return hr;
}

/*++

Title:

    WriteDevMode

Routine Description:

    Build a PrnBinInfo item from ->DevMode and write it into stream

Arguments:

    lpDevMode  -   ptr to DEVMODE

    cbSize       - buff size

    eDevModeType    - type : user / printer

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteDevMode(
    IN  PDEVMODE            lpDevMode,
    IN  DWORD               cbSize,
    IN  EHeaderEntryType    eDevModeType
    )
{
    ULARGE_INTEGER  uliCurrentPos;
    TStatusB        bStatus;
    TStatusH        hr;

    //
    // Get item's start position
    //
    hr DBGCHK = GetCurrentPosition(uliCurrentPos);

    if(SUCCEEDED(hr))
    {
        //
        // Writes devmode into stream (WriteItem builds PrnBinInfo)
        //
        hr DBGCHK = WriteItem(  NULL,
                                NULL,
                                0,
                                ktDevMode,
                                reinterpret_cast<LPBYTE>(lpDevMode),
                                cbSize);

        //
        // Update header entry with start position in stream
        //
        if(SUCCEEDED(hr))
        {
            hr DBGCHK = UpdateHeader(eDevModeType, uliCurrentPos);
        }
    }

    return hr;
}

/*++

Title:

    AdjustItemSizeForWin64

Routine Description:

    The item will be reallocated on Win64.
    When the file is generated on Win32, the item's size must be adjusted
    so that the 64bit stucture will fit in.
    The design doesn't allow to differenciate between files generated on Win32
    and Win64, therefore the adjustment will be always performed for
    Win64 up marshalling .

Arguments:

    lpPrnBinItem -- reference to a pointer to the item to be adjusted.

Return Value:

    S_OK  if succeded
    A Win32 error code converted to HRESULT

--*/
HRESULT
TPrnStream::
AdjustItemSizeForWin64(
    IN  OUT PrnBinInfo   *&lpPrnBinItem,
    IN      FieldInfo    *pFieldInfo,
    IN      SIZE_T       cbSize,
        OUT SIZE_T       &cbDifference
    )
{
    TStatusB    bStatus;
    TStatusH    hr(DBG_WARN, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    SIZE_T      cbWin32Size = 0;
    SIZE_T      cbWin64Size = cbSize;
    PrnBinInfo  *lpNewPrnBinItem = NULL;

    switch (kPointerSize)
    {
        case kSpl32Ptr:
        {
            cbDifference = 0;

            hr DBGNOCHK = S_OK;

            break;
        }
        case kSpl64Ptr:
        {
            //
            // Adjust item only on Win64
            //
            lpNewPrnBinItem = NULL;

            bStatus DBGCHK = GetShrinkedSize(pFieldInfo, &cbWin32Size);

            if ( bStatus )
            {
                //
                // Calculate the quantity the item must grow with.
                // It it the difference between the PRINTER_INFO_n size on
                // Win64 and Win32.
                //
                cbDifference = cbWin64Size - cbWin32Size;

                //
                // Allocate a bufer that will hold the adjusted item.
                //
                lpNewPrnBinItem = (PrnBinInfo*)AllocMem(lpPrnBinItem->cbSize + (DWORD)cbDifference);

                bStatus DBGCHK = !!lpNewPrnBinItem;

                if ( bStatus )
                {
                    //
                    // Copy the old item's content in the new buffer.
                    //
                    CopyMemory( lpNewPrnBinItem, lpPrnBinItem, lpPrnBinItem->cbSize);

                    //
                    // This memory move will make room for Win64 PRINTER_INFO_n to grow
                    // without corrupting data.
                    // Source: the spot right after flatened Win32 structure, which will
                    // contain data for items generated on Win32.
                    // Destination: the spot righ after Win64 structure. PRINTER_INFO_n data
                    // comes after this spot on Win64.
                    //
                    MoveMemory( (LPBYTE)lpNewPrnBinItem + lpNewPrnBinItem->pData + cbWin64Size,
                                (LPBYTE)lpNewPrnBinItem + lpNewPrnBinItem->pData + cbWin32Size,
                                lpNewPrnBinItem->cbData - cbWin32Size);

                    //
                    // Adjust new item's size.
                    //
                    lpNewPrnBinItem->cbData += (DWORD)cbDifference;

                    //
                    // Free the memory for the old item.
                    //
                    FreeMem(lpPrnBinItem);

                    lpPrnBinItem = lpNewPrnBinItem;

                }
            }

            if(bStatus)
            {
                hr DBGNOCHK = S_OK;
            }
            else
            {
                hr DBGCHK = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }
        default:
        {
            //
            // Invalid pointer size; should not occur.
            //
            hr DBGCHK = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;
        }
    }


    return hr;
}

/*++

Title:

    MarshallUpItem

Routine Description:

    Convert a "flat" PRINTER_INFO_2 item to an "alive" item.
    Pointers inside PRINTER_INFO_2 data be converted to offsets before the item
    is persisted in the file. The format of the flatened item must be the same
    between Win64 and Win32,since the file will roam across TS servers.

Arguments:

    lpPrnBinItem -- reference to a pointer to the item to be converted;

Return Value:

    S_OK  if succeded
    A Win32 error code converted to HRESULT

--*/
HRESULT
TPrnStream::
MarshallUpItem (
    IN  OUT PrnBinInfo*& lpPrnBinItem
    )
{
    TStatusB    bStatus;
    TStatusH    hr(DBG_WARN, HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    SIZE_T      cbDifference = 0;
    SIZE_T      cbSize;
    FieldInfo   *pPrinterInfoFields;

    bStatus DBGCHK = !!lpPrnBinItem;

    if(bStatus)
    {
        switch (lpPrnBinItem->dwType)
        {
            case ktPrnInfo2:
            {
                cbSize = sizeof(PRINTER_INFO_2);
                pPrinterInfoFields = PrinterInfo2Fields;
                break;
            }
            case ktPrnInfo7:
            {
                cbSize = sizeof(PRINTER_INFO_7);
                pPrinterInfoFields = PrinterInfo7Fields;
                break;
            }
            default:
            {
                bStatus DBGCHK = FALSE;
                break;
            }
        }

        if(bStatus)
        {
            //
            // This item will be reallocated when marshalled on Win64.
            // On Win64, the item's size must be increased with
            // the difference between strcuture's size on Win64 and Win32.
            // The item could have been generated on Win32 and there is no room
            // left for the structure to expand.
            //
            hr DBGCHK = AdjustItemSizeForWin64(lpPrnBinItem, pPrinterInfoFields, cbSize, cbDifference);


            if(SUCCEEDED(hr))
            {
                bStatus DBGCHK = MarshallUpStructure((LPBYTE)lpPrnBinItem + lpPrnBinItem->pData,
                                                     pPrinterInfoFields,
                                                     cbSize,
                                                     RPC_CALL);
                if(bStatus)
                {
                    hr DBGNOCHK = S_OK;
                }
                else
                {
                    hr DBGCHK = HRESULT_FROM_WIN32(GetLastError());
                }

                //
                // If the item was adjusted, the pointers inside PRINTER_INFO_2 must be adjusted as well.
                // AdjustPointers cannot be executed before marshalling because the structure is still flat
                // as on Win32 and the pointers are not in their Win64 location.
                //
                if ( bStatus && cbDifference )
                {
                    AdjustPointers ( (LPBYTE)lpPrnBinItem + lpPrnBinItem->pData,
                                      pPrinterInfoFields,
                                      cbDifference);
                }
            }
        }
    }

    return hr;
}

/*++

Title:

    AlignSize

Routine Description:

    align a sice to DWORD size

Arguments:

    cbSize  -   size to align

Return Value:

    cbSize  - value to align

--*/
DWORD
TPrnStream::
AlignSize(
    IN  DWORD cbSize
    )
{
    return((cbSize)+3)&~3;
}

/*++

Title:

    StorePrnData

Routine Description:

    Writes into stream printer data;
    calls bInternalWalk that browse the registry key and to store the  printer(registry) settings
    WalkIn and WalkPost virtual methods of WalkPrinterData over-rided to store value data

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/

HRESULT
TPrnStream::
StorePrnData(
    VOID
    )
{
    TString     strNullKey(_T(""));
    DWORD       cItems = 0;
    TStatusB    bStatus;


    //
    //      Proceed bInternalWalk for NULL key
    //
    bStatus DBGCHK = strNullKey.bValid();

    if(bStatus)
    {
        cItems = 0;

        bStatus DBGCHK = bInternalWalk(strNullKey, &cItems);
    }

    return bStatus ? S_OK : MakePrnPersistHResult(PRN_PERSIST_ERROR_WRITE_PRNDATA);

}

/*++

Title:

    bRestorePrnData

Routine Description:

    Restore printer data from file;
    Call ReadNextPrnData until all items are browsed in stream

Arguments:

    None

Return Value:

    S_OK  if succeded
    PRN_PERSIST_ERROR error code mapped to HRESULT(FACILITY_ITF) if failed

--*/
HRESULT
TPrnStream::
RestorePrnData(
    VOID
    )
{
    LPTSTR      lpszKey;
    LPTSTR      lpszVal;
    DWORD       dwType;
    LPBYTE      lpbData;
    DWORD       cDataSize;
    LPBYTE      lpPrinterBinInfo;
    TStatusB    bStatus;
    TStatus     Status;
    TStatusH    hr(DBG_WARN, STG_E_SEEKERROR);



    bStatus DBGNOCHK = TRUE;

    while(bStatus)
    {
        hr DBGCHK = ReadNextPrnData(lpszKey, lpszVal, dwType, lpbData, cDataSize, lpPrinterBinInfo);

        DBGMSG( DBG_TRACE, ( "bReadNextPrnData :: key " TSTR " value " TSTR " \n" ,(LPCTSTR)lpszKey , (LPCTSTR)lpszVal ));

        bStatus DBGCHK = SUCCEEDED(hr);

        if(bStatus)
        {
            Status DBGCHK = SetPrinterDataExW(m_hPrinter,
                            lpszKey,
                            lpszVal,
                            dwType,
                            lpbData,
                            cDataSize);

            if(Status != ERROR_SUCCESS)
            {
                hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_RESTORE_PRNDATA);
            }

            FreeMem(lpPrinterBinInfo);

        }

        if(hr == STG_E_SEEKERROR)
        {
            //
            // End of Prn Data
            //
            hr DBGNOCHK = S_OK;
        }


    }

    return hr;
}
/*++

Title:

    bWalkPost

Routine Description:

    call bWriteKeyData : store key values into stream

Arguments:

    strKey   -   name of the key to walk
    lpcItems -   if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWalkPost (
    IN    TString& strKey,
    OUT   LPDWORD  lpcItems
    )
{
    DBGMSG( DBG_TRACE, ( "WALK POST :: " TSTR "\n" , (LPCTSTR)strKey ));

    return bWriteKeyData(strKey, lpcItems);
}

/*++

Title:

    bWalkIn

Routine Description:

    call bWriteKeyData : store key values into stream

Arguments:

    strKey   -   name of the key to walk
    lpcItems -   if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWalkIn (
    IN    TString& strKey,
    OUT   LPDWORD  lpcItems
    )
{
    DBGMSG( DBG_TRACE, ( "WALK IN :: " TSTR "\n" , (LPCTSTR)strKey ));

    return bWriteKeyData(strKey, lpcItems);
}

/*++

Title:

    WriteKeyData

Routine Description:

    Writes into stream all values for a given key name;
    calls EnumPrinterDataEx and browse PRINTER_ENUM_VALUES array

Arguments:

    strKey   -   name of the key to write
    lpcItems - if not null , outs number of items actually written

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWriteKeyData(
    IN  LPCTSTR lpszKey,
    OUT LPDWORD lpcItems    OPTIONAL
    )
{

    *lpcItems = 0;
    LPPRINTER_ENUM_VALUES   apevData;
    UINT                    idx;
    DWORD                   dwRet;
    DWORD                   cbSize;
    DWORD                   cbNeededSize;
    DWORD                   cItems = 0;
    TStatus                 Status(ERROR_MORE_DATA);
    TStatusB                bStatus;

    //
    // Only write data if we are given a valid-key.
    //
    if((lpszKey == NULL) || (*lpszKey == _T('\0')))
    {
        bStatus DBGNOCHK = TRUE;

        goto End;
    }

    //
    // Determine the size necessary to store the enumerated data.
    //
    cbSize = 0;

    Status DBGCHK = EnumPrinterDataEx(m_hPrinter, lpszKey, NULL, 0, &cbNeededSize, &cItems);

    //
    // Current key has no values
    //
    if(cbNeededSize == 0 && Status == ERROR_MORE_DATA)
    {
        bStatus DBGNOCHK = TRUE;

        goto End;
    }

    //
    // If current key has values, then proceed to enumerate and write the values into stream
    //
    if(cbNeededSize && (Status == ERROR_MORE_DATA))
    {
        if(apevData = (LPPRINTER_ENUM_VALUES)AllocMem(cbNeededSize)) //AllocBytes
        {
            //
            // Enumerate all values for the specified key.  This
            // returns an array of value-structs.
            //
            Status DBGCHK  = EnumPrinterDataExW( m_hPrinter,
                                                 lpszKey,
                                                 reinterpret_cast<LPBYTE>(apevData),
                                                 cbNeededSize,
                                                 &cbSize,
                                                 &cItems);

            bStatus DBGCHK = (Status == ERROR_SUCCESS) && (cbNeededSize == cbSize);

            //
            // Enumerate all data for the specified key and write to the stream.
            //
            // Write all the values for this key.
            //
            for(idx = 0; (idx < cItems) && bStatus; idx++)
            {
                bStatus DBGCHK = bWriteKeyValue(static_cast<LPCTSTR>(lpszKey), apevData + idx);
            }

            *lpcItems = bStatus ? cItems : 0;

            FreeMem(apevData);
        }

    }


    End:

    return bStatus;
}

/*++

Title:

    bWriteKeyValue

Routine Description:

    Writes into stream a value with it's data for a given key name
    (Write key/value name and PRINTER_ENUM_VALUES into stream)

Arguments:

    lpszKey - Key name

    lpPEV   - pointer to PRINTER_ENUM_VALUES assoc with key

Return Value:

    TRUE  if succeded

--*/
BOOL
TPrnStream::
bWriteKeyValue(
    IN  LPCTSTR                 lpszKey,
    IN  LPPRINTER_ENUM_VALUES   lpPEV
    )
{
    TStatusB        bStatus;
    TStatusH        hr;

    hr DBGCHK = WritePrnData(   lpszKey,
                                lpPEV->pValueName,
                                lpPEV->cbValueName,
                                lpPEV->dwType,
                                lpPEV->pData,
                                lpPEV->cbData);

    bStatus DBGCHK = SUCCEEDED(hr);

    return bStatus;
}

/*++

Title:

    WriteItem

Routine Description:

    Build a PrnBinInfo item and write it into stream, at current position

Arguments:

    pKey            - key name ; null for items other than printer data
    pValueName      - key value ; null for items other than printer data
    cbValueName     - count bytes of pValueName
    dwType          - type
    pData           - actually data
    cbData          - count bytes of pData

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
WriteItem(
    IN  LPCTSTR         pKey,
    IN  LPCTSTR         pValueName,
    IN  DWORD           cbValueName,
    IN  DWORD           dwType,
    IN  LPBYTE          pData,
    IN  DWORD           cbData
    )
{
    DWORD         cbKeySize;
    DWORD         cbKey;
    DWORD         cbName;
    DWORD         cbSize;
    DWORD         dwWritten;
    PrnBinInfo*   lppbi;
    TStatusH      hr;
    TStatusB      bStatus;


    // Calculate aligned sizes for the key-name and key-value strings.
    //

    DBGMSG( DBG_TRACE, ( "TPrnStream::WriteItem\n KEY: " TSTR "" , pKey ));
    DBGMSG( DBG_TRACE, ( "VALUE: " TSTR "\n" , pValueName ));

    cbKeySize = (pKey != NULL) ? (_tcslen(pKey) + 1) * sizeof(TCHAR) : 0;

    cbKey     = AlignSize(cbKeySize);

    cbName    = AlignSize(cbValueName);


    // Calculate size necessary to hold our PrnBinInfo information
    // which is written into stream.
    //
    cbSize = sizeof(PrnBinInfo) + cbKey + cbName + cbData;

    cbSize = AlignSize(cbSize);

    //
    // Allocate space for the structure.
    //
    lppbi = (PrnBinInfo*)AllocMem(cbSize);

    bStatus DBGCHK = (lppbi != NULL);

    if(bStatus)
    {
        //
        // Initialize the structure elements.  Since this information
        // is written to file, we must take care to convert the
        // pointers to byte-offsets.
        //
        lppbi->cbSize  = cbSize;
        lppbi->dwType  = dwType;
        lppbi->pKey    = sizeof(PrnBinInfo);
        lppbi->pValue  = lppbi->pKey + cbKey;
        lppbi->pData   = lppbi->pValue + cbName;
        lppbi->cbData  = cbData;

        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pKey  , pKey      , cbKeySize);
        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pValue, pValueName, cbValueName);
        CopyMemory(reinterpret_cast<LPBYTE>(lppbi) + lppbi->pData , pData     , cbData);

        hr DBGCHK = m_pIStream->Write(lppbi, lppbi->cbSize, &dwWritten);

        FreeMem(lppbi);
    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr ;
}


/*++

Title:

    ReadItem

Routine Description:

    Read an item from a current position in stream

Arguments:

    Param pointers will point inside of lpBuffer:

    pKey            - key name ; null for items other than printer data
    pValueName      - key value ; null for items other than printer data
    cbValueName     - count bytes of pValueName
    dwType          - type
    pData           - actually data
    cbData          - count bytes of pData
    lpBuffer        - a null ptr that will contain ptr to read item;
                      must be deallocated by the caller if function succeed

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadItem(
    OUT LPTSTR& lpszKey,
    OUT LPTSTR& lpszVal,
    OUT DWORD&  dwType,
    OUT LPBYTE& lpbData,
    OUT DWORD&  cbSize,
    OUT LPBYTE& lpBuffer
    )
{
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;
    PrnBinInfo*     lpPrnBinItem = NULL;


    lpszKey = NULL;
    lpszVal = NULL;
    lpbData = NULL;
    lpBuffer = NULL;

    hr DBGCHK = GetCurrentPosition(uliSeekPtr);

    if(SUCCEEDED(hr))
    {
        hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        if(SUCCEEDED(hr))
        {
            lpszKey = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pKey);
            lpszVal = reinterpret_cast<LPTSTR>(reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pValue);
            lpbData = reinterpret_cast<LPBYTE>(lpPrnBinItem) + lpPrnBinItem->pData;
            cbSize  = lpPrnBinItem->cbData;
            dwType  = lpPrnBinItem->dwType - ktREG_TYPE;

            lpBuffer = reinterpret_cast<LPBYTE>(lpPrnBinItem);

        }

    }
    else
    {
        hr DBGNOCHK = E_UNEXPECTED;
    }


    return hr;

}
/*++

Title:

    ReadItemFromPosition

Routine Description:

    Read an item from a given position in stream
    Set seek pointer at the begining of the item
        Read item's size
        Set seek pointer at the begining of the item
        Read item
        uliSeekPtr will contain the seek pointer value after item's reading


Arguments:

    uliSeekPtr   - in start of item ; outs current seek ptr

    lpPrnBinItem - ptr to read item

Return Value:

    S_OK  if succeded
    An error code from an API converted to HRESULT

--*/
HRESULT
TPrnStream::
ReadItemFromPosition(
    IN  OUT ULARGE_INTEGER&   uliSeekPtr,
        OUT PrnBinInfo   *&   pPrnBinItem
    )
{
    DWORD   cbReadedSize;
    DWORD   cbSize = 0;

    LARGE_INTEGER   liStart = {0};
    TStatusH        hr;

    pPrnBinItem = NULL;

    //
    // Position seek pointer to where the item begins
    //
    liStart.QuadPart  = uliSeekPtr.QuadPart;

    hr DBGCHK = m_pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

    if(SUCCEEDED(hr))
    {
        //
        // Read size of item
        //
        hr DBGCHK = m_pIStream->Read(&cbSize, sizeof(DWORD), &cbReadedSize);

        DBGMSG( DBG_TRACE,  ("TPrnStream::ReadItemFromPosition\n Read item's size %d\n" ,cbSize) );

        if(SUCCEEDED(hr))
        {
            //
            // Go for start position again
            //
            hr DBGCHK = m_pIStream->Seek( liStart , STREAM_SEEK_SET, NULL );

            if(SUCCEEDED(hr))
            {
                pPrnBinItem = (PrnBinInfo*)AllocMem(cbSize);

                hr DBGCHK = pPrnBinItem ? S_OK : E_OUTOFMEMORY;

                if(SUCCEEDED(hr))
                {
                    hr DBGCHK = m_pIStream->Read(reinterpret_cast<LPBYTE>(pPrnBinItem), cbSize, &cbReadedSize);

                    SUCCEEDED(hr) ? GetCurrentPosition(uliSeekPtr) : FreeMem(pPrnBinItem);
                }
            }
        }
    }

    return hr;
}

/*++

Title:

    GetCurrentPosition

Routine Description:

    Gets the current value of seek pointer into IStream

Arguments:

    uliCurrentPosition - outs current seek ptr

Return Value:

    TRUE  if succeded

--*/
HRESULT
TPrnStream::
GetCurrentPosition(
    OUT ULARGE_INTEGER& uliCurrentPosition
    )
{
    LARGE_INTEGER   liMove = {0};
    TStatusH  hr;

    uliCurrentPosition.QuadPart = 0;

    hr DBGCHK = m_pIStream->Seek( liMove , STREAM_SEEK_CUR, &uliCurrentPosition );

    return hr;

}

/*++

Title:

    GetItemSize

Routine Description:

    read item's size from stream

Arguments:

    kHeaderEntryType    -   specify entry in header associated with item

Return Value:

    item's size if succeeded or -1 if failed

--*/
DWORD
TPrnStream::
GetItemSize(
    IN  TPrnStream::EHeaderEntryType kHeaderEntryType
    )
{
    DWORD           cbItemSize;
    PrnBinInfo*     lpPrnBinItem;
    ULARGE_INTEGER  uliSeekPtr;
    TStatusH        hr;
    TStatusB        bStatus;

    cbItemSize = 0;

    //
    // Read from header where info begins in stream
    //
    hr DBGCHK = ReadFromHeader(kHeaderEntryType, &uliSeekPtr);

    //
    // if ReadFromHeader returns a S_OK and dwSeekPtr is zero, it means that nothing is stored
    //
    if(FAILED(hr))
    {
        cbItemSize = -1;
    }
    else
    {
        if(uliSeekPtr.QuadPart > 0)
            //
            // Read an item from specified position
            //

            hr DBGCHK = ReadItemFromPosition(uliSeekPtr, lpPrnBinItem);

        if(FAILED(hr))
        {
            cbItemSize = -1;
        }
        else
        {
            cbItemSize = lpPrnBinItem->cbSize;
        }

    }

    return cbItemSize;

}

/*++

Title:

    InitalizeColorProfileLibrary

Routine Description:

    Loads and gets the needed procedure address for the color profile related
    functions.  This library is explicitly loaded and un loaded to impove
    load performce for winspool.drv.  Note winspool.drv is a common dll loaded
    by many applications so loading less libraries is a good thing.

Arguments:

    None.

Return Value:

    An HRESULT

--*/
HRESULT
TPrnStream::
InitalizeColorProfileLibrary(
    VOID
    )
{
    HRESULT hRetval = E_FAIL;

    m_pColorProfileLibrary = new TLibrary(L"mscms.dll");

    hRetval = m_pColorProfileLibrary && m_pColorProfileLibrary->bValid() ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hRetval))
    {
        m_EnumColorProfiles                     = (pfnEnumColorProfilesW)m_pColorProfileLibrary->pfnGetProc("EnumColorProfilesW");
        m_AssociateColorProfileWithDevice       = (pfnAssociateColorProfileWithDeviceW)m_pColorProfileLibrary->pfnGetProc("AssociateColorProfileWithDeviceW");
        m_DisassociateColorProfileFromDevice    = (pfnDisassociateColorProfileFromDeviceW)m_pColorProfileLibrary->pfnGetProc("DisassociateColorProfileFromDeviceW");

        if (!m_EnumColorProfiles || !m_AssociateColorProfileWithDevice || !m_DisassociateColorProfileFromDevice)
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }

    return hRetval;
}

/*++

Routine Description:

    Opens printer for specified access.

Arguments:

    pszPrinter - Name of printer to open.  szNULL or NULL implies local server.

    pdwAccess - On entry, holds desired access (pointer to 0 indicates
        maximal access).  On successful exit, holds access granted.
        If the call fails, this value is undefined.

    phPrinter - Returns the open printer handle.  On failure, this value
        is set to NULL.

Return Value:

    STATUS - win32 error code or ERROR_SUCCESS if successful.

--*/
STATUS
TPrnStream::
sOpenPrinter(
    LPCTSTR pszPrinter,
    PDWORD pdwAccess,
    PHANDLE phPrinter
    )
{
    STATUS Status = ERROR_SUCCESS;

    TStatusB bOpen( DBG_WARN,
                    ERROR_ACCESS_DENIED,
                    RPC_S_SERVER_UNAVAILABLE,
                    ERROR_INVALID_PRINTER_NAME );
    bOpen DBGNOCHK = FALSE;

    static const DWORD adwAccessPrinter[] = {
        PRINTER_ALL_ACCESS,
        PRINTER_READ,
        READ_CONTROL,
        0,
    };

    static const DWORD adwAccessServer[] = {
        SERVER_ALL_ACCESS,
        SERVER_READ,
        0,
    };

    PRINTER_DEFAULTS Defaults;
    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;

    if( pszPrinter && !pszPrinter[0] ){

        //
        // szNull indicates local server also; change it to
        // NULL since OpenPrinter only likes NULL.
        //
        pszPrinter = NULL;
    }

    //
    // Now determine whether we are opening a server or a printer.
    // This is very messy.  Look for NULL or two beginning
    // backslashes and none thereafter to indicate a server.
    //
    PDWORD pdwAccessTypes;

    if( !pszPrinter ||
        ( pszPrinter[0] == TEXT( '\\' ) &&
          pszPrinter[1] == TEXT( '\\' ) &&
          !_tcschr( &pszPrinter[2], TEXT( '\\' )))){

        pdwAccessTypes = (PDWORD)adwAccessServer;
    } else {
        pdwAccessTypes = (PDWORD)adwAccessPrinter;
    }

    if( *pdwAccess ){

        Defaults.DesiredAccess = *pdwAccess;

        bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                    phPrinter,
                                    &Defaults );

        if( !bOpen ){
            Status = GetLastError();
        }
    } else {

        //
        // If no access is specified, then attempt to retrieve the
        // maximal access.
        //
        UINT i;

        for( i = 0; !bOpen && pdwAccessTypes[i]; ++i ){

            Defaults.DesiredAccess = pdwAccessTypes[i];

            bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                        phPrinter,
                                        &Defaults );

            if( bOpen ){

                //
                // Return the access requested by the successful OpenPrinter.
                // On failure, this value is 0 (*pdwAccess undefined).
                //
                *pdwAccess = pdwAccessTypes[i];
                break;
            }

            Status = GetLastError();

            if( ERROR_ACCESS_DENIED != Status )
                break;
        }
    }

    if( !bOpen ){
        SPLASSERT( Status );
        *phPrinter = NULL;
        return Status;
    }

    SPLASSERT( *phPrinter );

    return ERROR_SUCCESS;
}

/*++

Routine Description:

    Gets printer information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    dwLevel - PRINTER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

Return Value:

    TRUE = success, FALSE = fail.

--*/
BOOL
TPrnStream::
bGetPrinter(
    IN     HANDLE hPrinter,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer,
    IN OUT PDWORD pcbBuffer
    )
{
    DWORD cbNeeded;

    enum
    {
        kMaxPrinterInfo2             = 0x1000,
        kExtraPrinterBufferBytes     = 0x80
    };

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kMaxPrinterInfo2;
    }

Retry:

    SPLASSERT( *pcbBuffer < 0x100000 );

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            return FALSE;
        }
    }

    if( !GetPrinter( hPrinter,
                     dwLevel,
                     (PBYTE)*ppvBuffer,
                     *pcbBuffer,
                     &cbNeeded )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded + kExtraPrinterBufferBytes;
        SPLASSERT( *pcbBuffer < 0x100000 );

        goto Retry;
    }
    return TRUE;
}

BOOL
TPrnStream::
bNewShareName(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszBaseShareName,
    OUT TString &strShareName
    )
{
    BOOL bReturn = FALSE;

    if( lpszServer && lpszBaseShareName )
    {
        HRESULT hr = CoInitialize(NULL);
        BOOL bInitializedCOM = SUCCEEDED(hr);

        TCHAR szBuffer[255];
        IPrintUIServices *pPrintUI = NULL;

        if( SUCCEEDED(hr) &&
            SUCCEEDED(hr = CoCreateInstance(CLSID_PrintUIShellExtension, 0, CLSCTX_INPROC_SERVER,
                IID_IPrintUIServices, (void**)&pPrintUI)) &&
            pPrintUI &&
            SUCCEEDED(hr = pPrintUI->GenerateShareName(lpszServer, lpszBaseShareName, szBuffer, COUNTOF(szBuffer))) )
        {
            strShareName.bUpdate(szBuffer);
            bReturn = TRUE;
        }
        else
        {
            SetLastError(HRESULT_CODE(hr));
        }

        if( pPrintUI )
        {
            pPrintUI->Release();
        }

        if( bInitializedCOM )
        {
            CoUninitialize();
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\pfdlg.c ===
/*++  

Copyright (c) 1990-1995  Microsoft Corporation
All rights reserved

Module Name:

    pfdlg.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "pfdlg.h"

static const DWORD g_aHelpIDs[]=
{
    IDD_PF_EF_OUTPUTFILENAME, 8810218, // Print to File: "" (Edit)
    0, 0
};

/*
 *
 */
BOOL APIENTRY
PrintToFileDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return PrintToFileInitDialog(hwnd, (LPWSTR *)lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return PrintToFileCommandOK(hwnd);

        case IDCANCEL:
            return PrintToFileCommandCancel(hwnd);
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:    
        return PrintToFileHelp(hwnd, msg, wparam, lparam);
        break;
    }

    return FALSE;
}


/*
 *
 */
BOOL
PrintToFileInitDialog(
    HWND  hwnd,
    LPWSTR *ppFileName
)
{
    BringWindowToTop( hwnd );

    SetFocus(hwnd);

    SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)ppFileName );

    SendDlgItemMessage( hwnd, IDD_PF_EF_OUTPUTFILENAME, EM_LIMITTEXT, MAX_PATH-2, 0);

    return TRUE;
}


/*
 *
 */
BOOL
PrintToFileCommandOK(
    HWND hwnd
)
{
    WCHAR           pFileName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE          hFile;
    HANDLE          hFind;
    LPWSTR          *ppFileName;

    ppFileName = (LPWSTR *)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    GetDlgItemText( hwnd, IDD_PF_EF_OUTPUTFILENAME,
                    pFileName, MAX_PATH );

    hFind = FindFirstFile( pFileName, &FindData );

    /* If the file already exists, get the user to verify
     * before we overwrite it:
     */
    if( hFind != INVALID_HANDLE_VALUE )
    {
        FindClose( hFind );

        if( Message( hwnd, MB_OKCANCEL | MB_ICONEXCLAMATION, IDS_LOCALMONITOR,
                     IDS_OVERWRITE_EXISTING_FILE )
            != IDOK )
        {
            return TRUE;
        }
    }


    hFile = CreateFile( pFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );

    if( hFile != INVALID_HANDLE_VALUE )
    {
        LPWSTR pTempFileName;
        WCHAR szCurrentDir[MAX_PATH];
        WCHAR szQualifiedPath[MAX_PATH];
        LPWSTR pszIgnore;
        DWORD cchLen;

        CloseHandle(hFile);

        if (!GetCurrentDirectory(sizeof(szCurrentDir)/sizeof(szCurrentDir[0]),
                                 szCurrentDir))
            goto Fail;

        cchLen = SearchPath(szCurrentDir,
                            pFileName,
                            NULL,
                            sizeof(szQualifiedPath)/sizeof(szQualifiedPath[0]),
                            szQualifiedPath,
                            &pszIgnore);

        if (!cchLen)
            goto Fail;

        pTempFileName = LocalAlloc(LMEM_FIXED,
                                   (cchLen + 1) * sizeof(szQualifiedPath[0]));

        if (!pTempFileName)
            goto Fail;

        wcscpy(pTempFileName, szQualifiedPath);
        *ppFileName = pTempFileName;

        EndDialog( hwnd, TRUE );

    } else {

Fail:
        ReportFailure( hwnd, IDS_LOCALMONITOR, IDS_COULD_NOT_OPEN_FILE );
    }

    return TRUE;
}



/*
 *
 */
BOOL
PrintToFileCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, FALSE);
    return TRUE;
}


/*++

Routine Name:

    PrintToFileHelp

Routine Description:

    Handles context sensitive help.
    
Arguments:

    UINT        uMsg,        
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if message handled, otherwise FALSE.

--*/
BOOL
PrintToFileHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:       

        bStatus = WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                           szHelpFile, 
                           HELP_WM_HELP, 
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:    

        bStatus = WinHelp((HWND)wParam,
                           szHelpFile, 
                           HELP_CONTEXTMENU,  
                           (ULONG_PTR)g_aHelpIDs );
        break;

    } 
    
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return (LocalAlloc(0,NumBytes));
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=winspool

NTPROFILEINPUT=yes

TARGETNAME=winspool
TARGETPATH=$(PROJECT_ROOT)\lib
TARGETTYPE=DYNLINK
TARGETEXT=drv

PASS1_PUBLISH= \
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)}

# Warning: OLE32 cannot be loaded statically.
# (They must be delayloaded.)  Hydra will load winspool.drv
# into CSRSS, and OLE32 cannot be loaded into CSRSS.

TARGETLIBS=$(WINDOWS_LIB_PATH)\gdi32p.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\adsiid.lib \
           $(SDK_LIB_PATH)\activeds.lib \
           $(SDK_LIB_PATH)\netapi32.lib \
           $(SDK_LIB_PATH)\ntdsapi.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(SDK_LIB_PATH)\dnsapi.lib \
           $(SDK_LIB_PATH)\uuid.lib

LINKLIBS=..\..\perf\$(O)\perf.lib\
         $(PROJECT_ROOT)\lib\*\spllib.lib

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

USE_MSVCRT=1

INCLUDES=..\;\
         ..\..\idl;\
         ..\..\splwow64\idl;\
         ..\..\..\inc;\
         ..\..\..\..\inc;\
         ..\..\..\..\..\inc;\
         $(WINDOWS_INC_PATH);\
         $(SHELL_INC_PATH);\
         $(NET_INC_PATH);\
         $(DS_INC_PATH);

SOURCES= ..\prop.c       \
         ..\dsutil.cxx   \
         ..\init.c       \
         ..\winsplc.c    \
         ..\winspool.c   \
         ..\splwow64c.c  \
         ..\bind.c       \
         ..\midluser.c   \
         ..\data.c       \
         ..\winspla.c    \
         ..\util.c       \
         ..\pfdlg.c      \
         ..\change.c     \
         ..\splinit.c    \
         ..\clusspl.c    \
         ..\defprn.c     \
         ..\cstrings.c   \
         ..\handle.c     \
         ..\varconv.cxx  \
         ..\property.cxx \
         ..\pubprn.cxx   \
         ..\prnprst.cxx  \
         ..\prnstrm.cxx  \
         ..\splperst.cxx \
         ..\stream.cxx   \
         ..\wlkprn.cxx   \
         ..\memory.cxx   \
         ..\winspool.rc  \
         ..\drvsetup.c   \

UMTYPE=windows

UMLIBS=$(SDK_LIB_PATH)\winspool.lib \
       $(SDK_LIB_PATH)\gdi32.lib    \
       $(SDK_LIB_PATH)\netapi32.lib \
       $(O)\winspool.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -D_UNICODE \
          -DNO_STRICT -D_SPOOL32_ -DSPOOLKM -D_HYDRA_

DELAYLOAD=\
           ole32.dll;\
           oleaut32.dll;\
           activeds.dll;\
           netapi32.dll;\
           dnsapi.dll;\
           ntdsapi.dll

DLOAD_ERROR_HANDLER=kernel32

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\property.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    Adds properties to ds

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "varconv.hxx"
#include "property.hxx"
#include "client.h"


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr;
    VARIANT varInputData;

    hr = PackString2Variant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&varInputData);

    return hr;
}


HRESULT
put_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    DWORD *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDWORD2Variant(
            *pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}


HRESULT
put_Dispatch_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    IDispatch *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDispatch2Variant(
            pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}


HRESULT
get_Dispatch_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDispatchfromVariant(
            varOutputData,
            ppDispatch
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}




HRESULT
put_MULTISZ_Property(
    IADs    *pADsObject,
    BSTR    bstrPropertyName,
    BSTR    pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT var;
    VARIANT varInputData;
    BSTR    pStr;
    BSTR    *pStrArray;
    DWORD   i;
    BSTR    pMultiString;

    if (!pSrcStringProperty || !*pSrcStringProperty)
        pMultiString = L"";
    else
        pMultiString = pSrcStringProperty;

    VariantInit(&var);

    // Convert MULTI_SZ to string array (last element of array must be NULL)
    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        ;

    if (!(pStrArray = (BSTR *) AllocSplMem((i + 1)*sizeof(BSTR)))) {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        pStrArray[i] = pStr;
    pStrArray[i] = NULL;

    MakeVariantFromStringArray(pStrArray, &var);

    FreeSplMem(pStrArray);

    hr = PackVARIANTinVariant(
            var,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&var);
    VariantClear(&varInputData);

    return hr;
}

HRESULT
put_BOOL_Property(
    IADs *pADsObject,
    BSTR bstrPropertyName,
    BOOL *bSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BOOL    bVal;

    bVal = bSrcProperty ? *bSrcProperty : 0;

    hr = PackBOOL2Variant(
            bVal,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!bSrcProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:
    return hr;
}


HRESULT
get_UI1Array_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IID  *pIID
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UI1Array2IID(
            varOutputData,
            pIID
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}


HRESULT
get_BSTR_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

/*

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE *pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL *pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT *pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\splwow64c.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:
    splwow64c.c
    
Abstract:

    Stub file to allow splwow64_c.c to work with precompiled headers.

Author:
    Khaled Sedky 18 January 2000

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "splwow64_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\resource.h ===
/*++  

Copyright (c) 1990-1998  Microsoft Corporation
All rights reserved

Module Name:

    resource.h

Abstract:

    Resource ids header

Author:

    Steve Kiraly (steveki) 1-May-1998

Environment:

    User Mode -Win32

Revision History:

--*/

#define DLG_PRINTTOFILE                 100

#define IDD_PF_EF_OUTPUTFILENAME        201
#define IDD_PF_PB_HELP                  202

#define IDS_LOCALMONITOR                300
#define IDS_COULD_NOT_OPEN_FILE         301
#define IDS_OVERWRITE_EXISTING_FILE     302

#define IDS_DUPLICATE_PRINTQUEUE        400
#define IDS_DUPLICATE_PRINTQUEUE_TITLE  401
#define IDS_UNKNOWN_ERROR               402
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\splperst.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    splperst.cxx

Abstract:

    Implementation of spooler persisting code
    IPrnStream & IStream 

Author:

    Adina Trufinescu (AdinaTru) 4-Nov-1998

Revision History:

    Lazar Ivanov (LazarI) Jul-2000 - moved from printui.

--*/

#include "precomp.h"
#pragma hdrstop

#include "prnprst.hxx"

#include <initguid.h>
#include "winprtp.h"

////////////////////////////////////////
// class TPrnPersist
//
class TPrnPersist: public IPrnStream,
                   public IStream
{

public:
    TPrnPersist(
        VOID
        );

    ~TPrnPersist(
        VOID
        );

    /***********
     IUnknown
     ***********/

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    /***********
     IPrnStream
     ***********/

    STDMETHODIMP
    BindPrinterAndFile(
        IN LPCTSTR pszPrinter,
        LPCTSTR pszFile
        );

    STDMETHODIMP
    StorePrinterInfo(
        IN DWORD   Flag
        );

    STDMETHODIMP
    RestorePrinterInfo(
        IN DWORD   Flag
        );

    STDMETHODIMP
    QueryPrinterInfo(
        IN  PrinterPersistentQueryFlag      Flag,
        OUT PersistentInfo                  *pPrstInfo
        );

    /***********
     IStream
     ***********/

    HRESULT STDMETHODCALLTYPE 
    Read(                                // IMPLEMENTED
        VOID * pv,      
        ULONG cb,       
        ULONG * pcbRead 
        );

    HRESULT STDMETHODCALLTYPE 
    Write(                                //IMPLEMENTED
        VOID const* pv,  
        ULONG cb,
        ULONG * pcbWritten 
        );

    HRESULT STDMETHODCALLTYPE 
    Seek(                                //IMPLEMENTED
        LARGE_INTEGER dlibMove,  
        DWORD dwOrigin,          
        ULARGE_INTEGER * plibNewPosition 
        );

    HRESULT STDMETHODCALLTYPE 
    SetSize(
        ULARGE_INTEGER nSize     
        );

    HRESULT STDMETHODCALLTYPE 
    CopyTo(                                //NOT_IMPLEMENTED
        LPSTREAM pStrm,  
        ULARGE_INTEGER cb,          
        ULARGE_INTEGER * pcbRead,  
        ULARGE_INTEGER * pcbWritten 
        );

    HRESULT STDMETHODCALLTYPE 
    Commit(                                //NOT_IMPLEMENTED
        IN DWORD dwFlags   
        );

    HRESULT STDMETHODCALLTYPE 
    Revert(                                //NOT_IMPLEMENTED
        VOID
        );

    HRESULT STDMETHODCALLTYPE 
    LockRegion(                            //NOT_IMPLEMENTED
        ULARGE_INTEGER cbOffset, 
        ULARGE_INTEGER cbLength, 
        DWORD dwFlags            
        );

    HRESULT STDMETHODCALLTYPE 
    UnlockRegion(                        //NOT_IMPLEMENTED
        ULARGE_INTEGER cbOffset, 
        ULARGE_INTEGER cbLength, 
        DWORD dwFlags            
        );

    HRESULT STDMETHODCALLTYPE 
    Stat(                                //NOT_IMPLEMENTED
        STATSTG * pStatStg,     
        DWORD dwFlags 
        );

    HRESULT STDMETHODCALLTYPE 
    Clone(                                //NOT_IMPLEMENTED
        OUT LPSTREAM * ppStrm       
        );

private:
    
    LONG m_cRef;
    TPrinterPersist *_pPrnPersist;    
};

TPrnPersist::
TPrnPersist(
    VOID
    ): m_cRef(1), 
       _pPrnPersist(NULL)       
{    
}

TPrnPersist::
~TPrnPersist(
    VOID
    )
{
    if( _pPrnPersist )
    {
        delete _pPrnPersist;
    }    
}

/***********
 IUnknown
 ***********/
STDMETHODIMP TPrnPersist::QueryInterface(REFIID riid, void **ppv)
{
    // standard implementation
    if( !ppv )
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IPrnStream) )
    {
        *ppv = static_cast<IPrnStream*>(this);
    } 
    else if( IsEqualIID(riid, IID_IStream) )
    {
        *ppv = static_cast<IStream*>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) TPrnPersist::AddRef()
{
    // standard implementation
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) TPrnPersist::Release()
{
    // standard implementation
    ULONG cRefs = InterlockedDecrement(&m_cRef);
    if( 0 == cRefs )
    {
        delete this;
    }
    return cRefs;
}

/*++

Name:
    TPrnPersist::BindPrinterAndFile

Description:

    Creates a PrnStream object if it don't exists and bind it to a printer and a file

Arguments:

    printer name
    file name

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
BindPrinterAndFile(
    IN LPCTSTR pszPrinter,
    IN LPCTSTR pszFile
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the PrnStream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the BindPrinterAndFile method if the printer stream
    // object was create successfully.
    //
    if (_pPrnPersist != NULL)
    {

        DBGMSG(DBG_TRACE , ("TPrnPersist::BindPrinterAndFile \n"));

        hr = _pPrnPersist->BindPrinterAndFile(pszPrinter, pszFile);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    DBGMSG(DBG_TRACE , ("TPrnPersist::BindPrinterAndFile %x \n" , hr));
    return hr;

}

/*++

Name:
    TPrnPersist::StorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke StorePrinterInfo

Arguments:

    flags that specifies what settings to store

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
StorePrinterInfo(
    IN DWORD   Flag
    )
{
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    DWORD StoredFlags;

    //
    // Create the PrnStream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the stote info method if the printer stream
    // object was create successfully.
    //

    DBGMSG(DBG_TRACE , ("TPrnPersist::StorePrinterInfo Flag %x \n" , Flag));

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            //
            // Winlogon calls this function for TS. We need to catch any possbile exception,
            // otherwise we may cause BSOD.
            //
            __try 
            {
                hr DBGCHK = _pPrnPersist->StorePrinterInfo(Flag, StoredFlags);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::StorePrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::RestorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke RestorePrinterInfo

Arguments:

    flags that specifies what settings to restore

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
RestorePrinterInfo(
    IN DWORD   Flag
    )
{
    TStatusH hr;
    
    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the restore info  method if the printer stream
    // object was created successfully.
    //
    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            //
            // Winlogon calls this function on the machine where TS runs. If the file from which
            // we restore the settings is corrupted, we must protect us against AVs that can occur
            // while accessing bad data.
            //
            __try 
            {
                hr DBGCHK = _pPrnPersist->SafeRestorePrinterInfo(Flag);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::SafeRestorePrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::QueryPrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke QueryPrinterInfo

Arguments:

    flags that specifies what settings to query

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag   Flag,
    OUT PersistentInfo              *pPrstInfo
    )
{
    TStatusH hr;

    hr DBGNOCHK = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the query info method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            __try 
            {
                hr DBGCHK = _pPrnPersist->QueryPrinterInfo(Flag , pPrstInfo);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                DBGMSG(DBG_WARNING, ("TPrnPersist::QueryPrinterInfo exception %x\n", GetExceptionCode()));
                
                hr DBGCHK = E_FAIL;
            }
        }
        else
        {
            hr DBGCHK = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr DBGCHK = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TPrnPersist::Read

Description:

    Creates a PrnStream object if it don't exists and invoke Read

Arguments:

    pv  -   The buffer that the bytes are read into
    cb  -   The offset in the stream to begin reading from.
    pcbRead -   The number of bytes to read

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Read(
    VOID * pv,
    ULONG cb,
    ULONG * pcbRead
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the read method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Read(pv, cb, pcbRead);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

/*++

Name:
    TPrnPersist::Write

Description:

    Creates a PrnStream object if it don't exists and invoke Write

Arguments:

    pv  -   The buffer to write from.
    cb  -   The offset in the array to begin writing from
    pcbRead -   The number of bytes to write

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Write(
    VOID const* pv,
    ULONG cb,
    ULONG * pcbWritten
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the write method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Write(pv, cb, pcbWritten);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}


/*++

Name:
    TPrnPersist::Seek

Description:

    Creates a PrnStream object if it don't exists and invoke Seek

Arguments:

    dlibMove        -   The offset relative to dwOrigin
    dwOrigin        -   The origin of the offset
    plibNewPosition -   Pointer to value of the new seek pointer from the beginning of the stream

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TPrnPersist::
Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the Prnstream location object if this is the first call.
    //
    if (!_pPrnPersist)
    {
        _pPrnPersist = new TPrinterPersist;
    }

    //
    // Invoke the seek method if the printer stream
    // object was create successfully.
    //

    if(_pPrnPersist != NULL)
    {
        if (VALID_PTR(_pPrnPersist))
        {
            hr = _pPrnPersist->Seek(dlibMove, dwOrigin, plibNewPosition);
        }
        else
        {
            hr = MakePrnPersistHResult(PRN_PERSIST_ERROR_UNBOUND);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}

/*++

Name:
    TPrnPersist::SetSize

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
SetSize(
     ULARGE_INTEGER nSize
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::CopyTo

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
CopyTo(
    LPSTREAM pStrm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER * pcbRead,
    ULARGE_INTEGER * pcbWritten
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Commit

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Commit(
    IN DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Revert

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Revert(
    VOID
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::LockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
LockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::UnlockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
UnlockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Stat

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Stat(
    STATSTG * pStatStg,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TPrnPersist::Clone

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TPrnPersist::
Clone(
    LPSTREAM * ppStrm
    )
{
    return E_NOTIMPL;
}

#ifdef __cplusplus
extern "C" {
#endif

// forward declarations....
HRESULT TPrnPersist_CreateInstance(REFIID riid, void **ppv);
BOOL WebPnpEntry(LPCTSTR lpszCmdLine);
BOOL WebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName);

/*++

Name:
    TPrnPersist_CreateInstance

Description:

    creates an instance of TPrnPersist

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT TPrnPersist_CreateInstance(
    IN  REFIID riid, 
    OUT void **ppv
    )
{
    HRESULT hr = E_INVALIDARG;

    if( ppv )
    {
        *ppv = NULL;
        TPrnPersist *pObj = new TPrnPersist;

        if( pObj ) 
        {
            hr = pObj->QueryInterface( riid, ppv );
            pObj->Release( );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

/*++

Name:
    PrintUIWebPnpEntry

Description:

    wrapper around WebPnpEntry

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUIWebPnpEntry(
    LPCTSTR lpszCmdLine
    )
{
    return WebPnpEntry(lpszCmdLine) ? S_OK : E_FAIL;
}

/*++

Name:
    PrintUIWebPnpPostEntry

Description:

    wrapper around WebPnpPostEntry

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUIWebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName)
{
    return WebPnpPostEntry(fConnection, lpszBinFile, lpszPortName, lpszPrtName) ? S_OK : E_FAIL;
}

/*++

Name:
    PrintUICreateInstance

Description:

    wrapper around TPrnPersist_CreateInstance

Arguments:

Return Value:

    S_OK on sucsess or OLE error on failure.

--*/
HRESULT PrintUICreateInstance(REFIID riid, void **ppv)
{
    return TPrnPersist_CreateInstance(riid, ppv);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\prop.c ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    Prop.c

Abstract:

    Handles new entry points to document and device properties.

    Public Entrypoints:

        DocumentPropertySheets
        DevicePropertySheets

Author:

    Albert Ting (AlbertT) 25-Sept-1995
    Steve Kiraly (SteveKi) 02-Feb-1996

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "winddiui.h"

//
// UI user data structure definition.
//
typedef struct _UIUserData
{
    HANDLE  hModule;
    LPWSTR pszTitle;
} UIUserData;


BOOL
CreateUIUserData(
    IN OUT  UIUserData  **pData,
    IN      HANDLE      hPrinter
    )
/*++

Routine Description:

    This function creates the UI user data and loads the printer
    driver UI module.

Arguments:

    pData       pointer to where to return the pointer to the UI user data
    hPrinter    handle to the open printer

Return Value:

    TRUE the UI user data was alloceted, FALSE error occurred.

--*/
{
    SPLASSERT( pData );

    //
    // Allocate the UI user data.
    //
    *pData = AllocSplMem( sizeof( UIUserData ) );

    if( *pData )
    {
        //
        // The title is not allocated initaly.
        //
        (*pData)->pszTitle = NULL;

        //
        // Load the printer driver UI module.
        //
        (*pData)->hModule = LoadPrinterDriver( hPrinter );

        if( !(*pData)->hModule )
        {
            FreeSplMem( *pData );
            *pData = NULL;
        }
    }

    return !!*pData;
}

VOID
DestroyUIUserData(
    IN UIUserData **pData
    )
/*++

Routine Description:

    This function destroys the UI user data and unloads the printer
    driver UI module.

Arguments:

    pData       pointer to the UI user data

Return Value:

    Nothing.

--*/
{
    if( pData && *pData )
    {
        if( (*pData)->hModule )
        {
            RefCntUnloadDriver( (*pData)->hModule, TRUE );
            (*pData)->hModule = NULL;
        }

        if( (*pData)->pszTitle )
        {
            FreeSplMem( (*pData)->pszTitle );
            (*pData)->pszTitle = NULL;
        }

        FreeSplMem( *pData );

        *pData = NULL;
    }
}

VOID
CreatePrinterFriendlyName(
    IN UIUserData   *pData,
    IN LPCWSTR      pszName
    )
/*++

Routine Description:

    This function creates the printer friendly name and stores
    the new name in the UIUserData.

Arguments:

    pData       pointer to the UI user data
    pszName     pointer to the unfriendly printer name

Return Value:

    Nothing.  If the operation fails the unfriendly name is used.

--*/
{
    UINT        nSize   = 0;
    HINSTANCE   hModule = NULL;
    BOOL        bStatus = FALSE;

    //
    // Load printui, which knows how to format the friendly name.
    //
    hModule = LoadLibrary( szPrintUIDll );

    if( hModule )
    {
        typedef BOOL (*pfConstructPrinterFriendlyName)( LPCWSTR, LPWSTR, UINT * );

        pfConstructPrinterFriendlyName pfn;

        pfn = (pfConstructPrinterFriendlyName)GetProcAddress( hModule, szConstructPrinterFriendlyName );

        if( pfn )
        {
            //
            // Query for the friendly name size.
            //
            if( !pfn( pszName, NULL, &nSize ) && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Allocate the friendly name buffer.
                //
                pData->pszTitle = AllocSplMem( (nSize+1) * sizeof(WCHAR) );

                if( pData->pszTitle )
                {
                    //
                    // Get the printer friendly name.
                    //
                    bStatus = pfn( pszName, pData->pszTitle, &nSize );
                }
            }
        }

        //
        // Release the library.
        //
        FreeLibrary( hModule );
    }

    //
    // Something failed use the unfriendly name.
    //
    if( !bStatus )
    {
        FreeSplMem( pData->pszTitle );

        pData->pszTitle = AllocSplStr( pszName );
    }
}

BOOL
FixUpDEVMODEName(
    PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    This function fixed up the returned DEVMODE with friendly printer name
    in the dmDeviceName field (cut off at 31 character as CCHDEVICENAME)


Arguments:

    pDPHdr  - Pointer to the DOCUMENTPROPERTYHEADER structure


Return Value:

    TRUE if frendly name is copied, FALSE otherwise


Author:

    08-Jul-1996 Mon 13:36:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PPRINTER_INFO_2 pPI2 = NULL;
    DWORD           cbNeed = 0;
    DWORD           cbRet = 0;
    BOOL            bCopy = FALSE;


    if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))                         &&
        (!(pDPHdr->fMode & DM_NOPERMISSION))                            &&
        (pDPHdr->pdmOut)                                                &&
        (!GetPrinter(pDPHdr->hPrinter, 2, NULL, 0, &cbNeed))            &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                   &&
        (pPI2 = AllocSplMem(cbNeed))                                    &&
        (GetPrinter(pDPHdr->hPrinter, 2, (LPBYTE)pPI2, cbNeed, &cbRet)) &&
        (cbNeed == cbRet)) {

        wcsncpy(pDPHdr->pdmOut->dmDeviceName,
                pPI2->pPrinterName,
                CCHDEVICENAME - 1);

        pDPHdr->pdmOut->dmDeviceName[CCHDEVICENAME - 1] = L'\0';

        bCopy = TRUE;
    }

    if (pPI2) {

        FreeSplMem(pPI2);
    }

    return(bCopy);
}


LONG_PTR
DevicePropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    )
/*++

Routine Description:

    Adds the device specific printer pages.  This replaces
    PrinterProperties.

Arguments:

    pCPSUIInfo  - pointer to common ui info header.
    lParam      - user defined lparam, see compstui for details.
                  \nt\public\oak\inc\compstui.h

Return Value:

    Returns > 0 if success
    Returns <= 0 if failure

--*/

{
    PDEVICEPROPERTYHEADER       pDevPropHdr     = NULL;
    PPROPSHEETUI_INFO_HEADER    pCPSUIInfoHdr   = NULL;
    PSETRESULT_INFO             pSetResultInfo  = NULL;
    LONG_PTR                    lResult         = FALSE;
    HANDLE                      hModule         = NULL;
    INT_FARPROC                 pfn             = NULL;
    extern HANDLE hInst;

    DBGMSG( DBG_TRACE, ("DrvDevicePropertySheets\n") );

    //
    // Ony compstui requests, are acknowledged.
    //
    if (pCPSUIInfo) {

        if ((!(pDevPropHdr = (PDEVICEPROPERTYHEADER)pCPSUIInfo->lParamInit))    ||
            (pDevPropHdr->cbSize < sizeof(DEVICEPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        switch (pCPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_INIT\n") );

            //
            // Create the UI User data.
            //
            if( CreateUIUserData( &(UIUserData *)(pCPSUIInfo->UserData), pDevPropHdr->hPrinter ) ){

                if( ((UIUserData *)(pCPSUIInfo->UserData))->hModule ){

                    //
                    // Get the driver property sheet entry.
                    //
                    if ((pfn = (INT_FARPROC)GetProcAddress( ((UIUserData *)(pCPSUIInfo->UserData))->hModule, szDrvDevPropSheets))) {

                        //
                        // Before calling into the driver to add pages make sure the proper
                        // fusion activation context is set.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_SET_FUSION_CONTEXT,
                                                               (LPARAM)ACTCTX_EMPTY,
                                                               (LPARAM)0);
                        //
                        // Common ui will call the driver to add it's sheets.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_ADD_PFNPROPSHEETUI,
                                                               (LPARAM)pfn,
                                                               pCPSUIInfo->lParamInit );
                    }
                }
            }

            //
            // If something failed ensure we free the library
            // if it was loaded.
            //
            if( lResult <= 0 ){

                DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_INIT failed with %d\n", lResult ) );

                DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_GET_INFO_HEADER\n") );

            pCPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam;

            CreatePrinterFriendlyName( (UIUserData *)(pCPSUIInfo->UserData), pDevPropHdr->pszPrinterName );

            pCPSUIInfoHdr->pTitle     = ((UIUserData *)(pCPSUIInfo->UserData))->pszTitle;
            pCPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pCPSUIInfoHdr->hInst      = hInst;
            pCPSUIInfoHdr->IconID     = IDI_CPSUI_PRINTER;

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_SET_RESULT\n") );

            pSetResultInfo = (PSETRESULT_INFO)lParam;
            pCPSUIInfo->Result = pSetResultInfo->Result;
            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_DESTROY:

            DBGMSG( DBG_TRACE, ( "DrvDevicePropertySheets PROPSHEETUI_REASON_DESTROY\n") );

            DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );

            lResult = TRUE;

            break;
        }
    }

    return lResult;

}

LONG_PTR
DocumentPropertySheets(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    )
/*++

Routine Description:

    Adds the document property pages.  This replaces DocumentProperties
    and Advanced DocumentProperties.

Arguments:

    pCPSUIInfo  - pointer to common ui info header.
    lParam      - user defined lparam, see compstui for details.
                  \nt\public\oak\inc\compstui.h

Return Value:

    Returns > 0 if success
    Returns <= 0 if failure

--*/

{

    PDOCUMENTPROPERTYHEADER     pDocPropHdr     = NULL;
    PPROPSHEETUI_INFO_HEADER    pCPSUIInfoHdr   = NULL;
    PSETRESULT_INFO             pSetResultInfo  = NULL;
    LONG_PTR                    lResult         = FALSE;
    HANDLE                      hModule         = NULL;
    INT_FARPROC                 pfn             = NULL;
    extern HANDLE hInst;

    DBGMSG( DBG_TRACE, ("DrvDocumentPropertySheets\n") );

    //
    // Ony compstui requests, are acknowledged.
    //
    if (pCPSUIInfo) {

        if ((!(pDocPropHdr = (PDOCUMENTPROPERTYHEADER)pCPSUIInfo->lParamInit))    ||
            (pDocPropHdr->cbSize < sizeof(PDOCUMENTPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        switch (pCPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_INIT\n") );

            if (!(pDocPropHdr->fMode & DM_PROMPT)) {

                SetLastError(ERROR_INVALID_PARAMETER);
                return 0;
            }

            //
            // Create the UI User data.
            //
            if( CreateUIUserData( &(UIUserData *)(pCPSUIInfo->UserData), pDocPropHdr->hPrinter ) ){

                if( ((UIUserData *)(pCPSUIInfo->UserData))->hModule ){

                    if (pfn = (INT_FARPROC)GetProcAddress( ((UIUserData *)(pCPSUIInfo->UserData))->hModule, szDrvDocPropSheets)) {

                        //
                        // Before calling into the driver to add pages make sure the proper
                        // fusion activation context is set.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_SET_FUSION_CONTEXT,
                                                               (LPARAM)ACTCTX_EMPTY,
                                                               (LPARAM)0);
                        //
                        // Common ui will call the driver to add it's sheets.
                        //
                        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                               CPSFUNC_ADD_PFNPROPSHEETUI,
                                                               (LPARAM)pfn,
                                                               pCPSUIInfo->lParamInit );
                    }
                }
            }

            //
            // If something failed ensure we free the library
            // if it was loaded.
            //
            if( lResult <= 0 ){

                DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_INIT failed with %d\n", lResult ) );

                DestroyUIUserData( &(UIUserData *)(pCPSUIInfo->UserData) );
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_GET_INFO_HEADER\n") );

            pCPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam;

            CreatePrinterFriendlyName( (UIUserData *)(pCPSUIInfo->UserData), pDocPropHdr->pszPrinterName );

            pCPSUIInfoHdr->pTitle     = ((UIUserData *)(pCPSUIInfo->UserData))->pszTitle;
            pCPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pCPSUIInfoHdr->hInst      = hInst;
            pCPSUIInfoHdr->IconID     = IDI_CPSUI_PRINTER;

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_SET_RESULT\n") );

            pSetResultInfo = (PSETRESULT_INFO)lParam;

            if ((pCPSUIInfo->Result = pSetResultInfo->Result) > 0) {

                FixUpDEVMODEName(pDocPropHdr);
            }

            lResult = TRUE;

            break;

        case PROPSHEETUI_REASON_DESTROY:

            DBGMSG( DBG_TRACE, ( "DrvDocumentPropertySheets PROPSHEETUI_REASON_DESTROY\n") );

            DestroyUIUserData( &(UIUserData*)(pCPSUIInfo->UserData) );

            lResult = TRUE;

            break;
        }

    //
    // If a null pointer to common ui info header then
    // call the driver directly.
    //
    } else {

        lResult     = -1;

        if ((!(pDocPropHdr = (PDOCUMENTPROPERTYHEADER)lParam))    ||
            (pDocPropHdr->cbSize < sizeof(PDOCUMENTPROPERTYHEADER))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return lResult;
        }

        if (pDocPropHdr->fMode & DM_PROMPT) {

            SetLastError(ERROR_INVALID_PARAMETER);

        } else if ((hModule = LoadPrinterDriver(pDocPropHdr->hPrinter)) &&
                   (pfn = (INT_FARPROC)GetProcAddress(hModule, szDrvDocPropSheets))) {

            if ((lResult = (*pfn)(NULL, pDocPropHdr)) > 0) {

                FixUpDEVMODEName(pDocPropHdr);
            }

        } else {

            SetLastError(ERROR_INVALID_HANDLE);
        }

        if (hModule) {

            RefCntUnloadDriver(hModule, TRUE);
        }
    }

    return lResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\splinit.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    SplInit.c

Abstract:

    Initialize the spooler.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"

DWORD
TranslateExceptionCode(
    DWORD ExceptionCode);

BOOL
SpoolerInit(
    VOID)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR szDefaultPrinter[MAX_PATH * 2];
    HKEY hKeyPrinters;
    DWORD ReturnValue;

    //
    // Preserve the old device= string in case we can't initialize and
    // must defer.
    //
    if (!RegOpenKeyEx(HKEY_CURRENT_USER,
                      szPrinters,
                      0,
                      KEY_WRITE|KEY_READ,
                      &hKeyPrinters)) {

        //
        // Attempt to retrieve the current default written out.
        //

        if (GetProfileString(szWindows,
                             szDevice,
                             szNULL,
                             szDefaultPrinter,
                             COUNTOF(szDefaultPrinter))) {

            //
            // If it exists, save it away in case we start later when
            // the spooler hasn't started (which means we clear device=)
            // and then restart the spooler and login.
            //

            RegSetValueEx(hKeyPrinters,
                          szDeviceOld,
                          0,
                          REG_SZ,
                          (PBYTE)szDefaultPrinter,
                          (wcslen(szDefaultPrinter)+1) *
                            sizeof(szDefaultPrinter[0]));

        }

        RegCloseKey(hKeyPrinters);
    }

    //
    // Clear out [devices] and [printerports] device=
    //
    WriteProfileString(szDevices, NULL, NULL);
    WriteProfileString(szPrinterPorts, NULL, NULL);
    WriteProfileString(szWindows, szDevice, NULL);

    RpcTryExcept {

        if (ReturnValue = RpcSpoolerInit((LPWSTR)szNULL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(TranslateExceptionCode(RpcExceptionCode()));
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\pubprn.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Abstract:

    This module provides functionality for publishing printers

Author:

    Steve Wilson (NT) November 1997

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "client.h"

#define PPM_FACTOR  48

BOOL
PublishPrinterW(
    HWND    hwnd,
    PCWSTR  pszUNCName,
    PCWSTR  pszDN,
    PCWSTR  pszCN,
    PWSTR  *ppszDN,
    DWORD   dwAction
)
{
    PRINTER_DEFAULTS    Defaults;
    HANDLE              hPrinter = NULL;
    HANDLE              hServer = NULL;
    PWSTR               pszServerName = NULL;
    PWSTR               pszPrinterName = NULL;
    PPRINTER_INFO_2     pInfo2 = NULL;
    DWORD               dwRet = ERROR_SUCCESS;
    DWORD               dwType;
    DWORD               dwMajorVersion;
    DWORD               dwDsPresent;
    DWORD               cbNeeded;
    DWORD               dwLength;
    HRESULT             hr;
    WCHAR               szDNSMachineName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    WCHAR               szFullUNCName[MAX_UNC_PRINTER_NAME];
    WCHAR               szShortServerName[MAX_PATH+1];
    PWSTR               pszFullUNCName;
    PWSTR               pszShortServerName;
    PWSTR               pszFullServerName;

    if (InCSRProcess()) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    hr = CoInitialize(NULL);
    if (hr != S_OK && hr != S_FALSE) {
        SetLastError((DWORD)((HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : hr));
        return FALSE;
    }


    if (ppszDN)
        *ppszDN = NULL;

    // Get server name
    if (dwRet = UNC2Server(pszUNCName, &pszServerName))
        goto error;

    if(!OpenPrinter(pszServerName, &hServer, NULL)) {
        dwMajorVersion = 0;

    } else {
        dwRet = GetPrinterData( hServer,
                                SPLREG_MAJOR_VERSION,
                                &dwType,
                                (PBYTE) &dwMajorVersion,
                                sizeof dwMajorVersion,
                                &cbNeeded);
        if (dwRet != ERROR_SUCCESS) {
            dwMajorVersion = 0;
            dwRet = ERROR_SUCCESS;        // ignore errors and assume lowest version
        }

        if (dwMajorVersion >= WIN2000_SPOOLER_VERSION) {

            hr = MachineIsInMyForest(pszServerName);

            if (FAILED(hr)) {
                dwRet = HRESULT_CODE(hr);
                goto error;
            } else if(HRESULT_CODE(hr) == 1) {
                // Machine is in my forest and is NT5+
                dwRet = ERROR_INVALID_LEVEL;
                goto error;
            } else {
                // Downgrade the version for NT5+ printers published in a non-DS domain
                dwMajorVersion = WIN2000_SPOOLER_VERSION;
            }
        }
    }

    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;

    Defaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter((PWSTR) pszUNCName, &hPrinter, &Defaults)) {
        dwRet = GetLastError();
        goto error;
    }

    hr = GetPrinterInfo2(hPrinter, &pInfo2);
    if (FAILED(hr)) {
        dwRet = HRESULT_CODE(hr);
        goto error;
    }

    if (dwRet = UNC2Printer(pInfo2->pPrinterName, &pszPrinterName))
        goto error;


    if( dwMajorVersion >= WIN2000_SPOOLER_VERSION){
        if(dwRet = GetPrinterData(  hServer,
                                    SPLREG_DNS_MACHINE_NAME,
                                    &dwType,
                                    (PBYTE) szDNSMachineName,
                                    (INTERNET_MAX_HOST_NAME_LENGTH + 1) * sizeof(WCHAR),
                                    &cbNeeded) != ERROR_SUCCESS ) {
            goto error;
        }

        wsprintf( szFullUNCName, L"\\\\%s\\%s", szDNSMachineName, pszPrinterName );
        dwLength = MAX_PATH + 1;
        if (!DnsHostnameToComputerName(pszServerName,
                                       szShortServerName,
                                       &dwLength)) {
            dwRet = GetLastError();
            goto error;
        }

        pszFullUNCName = szFullUNCName;
        pszFullServerName = szDNSMachineName;
        pszShortServerName = szShortServerName+2;


    } else {

        pszFullUNCName = (PWSTR)pszUNCName;
        pszFullServerName = pszServerName+2;
        pszShortServerName = pszServerName+2;
    }



    // Verify PrintQueue doesn't already exist
    if (dwAction != PUBLISHPRINTER_IGNORE_DUPLICATES) {
        if(dwRet = PrintQueueExists(hwnd, hPrinter, pszFullUNCName, dwAction, (PWSTR) pszDN, (PWSTR *) ppszDN))
            goto error;
    }

    if (dwRet = PublishDownlevelPrinter(hPrinter,
                                        (PWSTR) pszDN,
                                        (PWSTR) pszCN,
                                        pszFullServerName,
                                        pszShortServerName,
                                        pszFullUNCName,
                                        pszPrinterName,
                                        dwMajorVersion,
                                        ppszDN))
        goto error;


error:

    if (hPrinter != NULL)
        ClosePrinter(hPrinter);

    if (hServer != NULL)
        ClosePrinter(hServer);

    if (pszServerName)
        FreeSplMem(pszServerName);

    if (pszPrinterName)
        FreeSplMem(pszPrinterName);

    FreeSplMem(pInfo2);

    if (dwRet != ERROR_SUCCESS) {
        SetLastError(dwRet);
        return FALSE;
    }


    CoUninitialize();

    return TRUE;
}


DWORD
PublishNT5Printer(
    HANDLE hPrinter,
    PWSTR  pszDN,
    PWSTR  pszCN,
    PWSTR  *ppszObjectDN
)
{
    PRINTER_INFO_7  Info7;
    DWORD           dwRet = ERROR_SUCCESS;
    BYTE            Data[(100 + sizeof(PRINTER_INFO_7))*sizeof(WCHAR)];    // GUIDs don't have well-defined size
    PPRINTER_INFO_7 pInfo7 = NULL;
    DWORD           cbNeeded;

    // Disable NT5+ publishing because it is inconsistent with SetPrinter.
    // Also, NT5 duplicate printer must be deleted via SetPrinter, not via DS.  If it is
    // deleted via DS then subsequent SetPrinter to publish will take a long time since
    // it discovers GUID no longer exists and spins background thread to delete & republish.
    // This, combined with replication delays, causes PublishNT5Printer to fail because getting
    // the ppszObjectDN because the object may not be published yet.
    return ERROR_INVALID_LEVEL;

    Info7.dwAction = DSPRINT_PUBLISH;

    if (!SetPrinter(hPrinter, 7, (PBYTE) &Info7, 0)) {
        dwRet = GetLastError();
        goto error;
    }

    if (!GetPrinter(hPrinter, 7, (PBYTE) Data, sizeof(Data), &cbNeeded)) {

        if ((dwRet = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
            goto error;

        if (!(pInfo7 = (PPRINTER_INFO_7) AllocSplMem(cbNeeded)))
            goto error;

        if (!GetPrinter(hPrinter, 7, (PBYTE) pInfo7, cbNeeded, &cbNeeded)) {
            dwRet = GetLastError();
            goto error;
        }
    } else {
        pInfo7 = (PPRINTER_INFO_7) Data;
    }

    if (!(dwRet = MovePrintQueue(pInfo7->pszObjectGUID, pszDN, pszCN)))
        goto error;

    if (dwRet = GetADsPathFromGUID(pInfo7->pszObjectGUID, ppszObjectDN))
        goto error;

error:

    if (pInfo7 && pInfo7 != (PPRINTER_INFO_7) Data)
        FreeSplMem(pInfo7);

    if (dwRet != ERROR_SUCCESS) {
        FreeGlobalStr(*ppszObjectDN);
    }

    return dwRet;
}

DWORD
PublishDownlevelPrinter(
    HANDLE  hPrinter,
    PWSTR   pszDN,
    PWSTR   pszCN,
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    PWSTR   *ppszObjectDN
)
{
    HRESULT         hr = S_OK;
    DWORD           dwRet = ERROR_SUCCESS;
    IADs            *pPrintQueue = NULL;
    IADsContainer   *pADsContainer = NULL;
    IDispatch       *pDispatch = NULL;
    PWSTR           pszCommonName = pszCN;
    BSTR            bstrADsPath = NULL;
    PWSTR           pszDNWithDC = NULL;


    if (ppszObjectDN)
        *ppszObjectDN = NULL;

    // If pszCN is not supplied, generate default common name
    if (!pszCommonName || !*pszCommonName) {
        dwRet = GetCommonName(hPrinter, &pszCommonName);
        if (dwRet != ERROR_SUCCESS) {
            hr = dw2hr(dwRet);
            BAIL_ON_FAILURE(hr);
        }
    }

    // Stick DC in DN
    if (!(pszDNWithDC = GetDNWithServer(pszDN))) {
        pszDNWithDC = pszDN;
    }


    // Get container
    hr = ADsGetObject(pszDNWithDC, IID_IADsContainer, (void **) &pADsContainer);
    BAIL_ON_FAILURE(hr);

    // Create printqueue
    hr = pADsContainer->Create(SPLDS_PRINTER_CLASS, pszCommonName, &pDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pDispatch->QueryInterface(IID_IADs, (void **) &pPrintQueue);
    BAIL_ON_FAILURE(hr);


    // Set properties
    hr = SetProperties( hPrinter,
                        pszServerName,
                        pszShortServerName,
                        pszUNCName,
                        pszPrinterName,
                        dwVersion,
                        pPrintQueue);
    BAIL_ON_FAILURE(hr);

    // Get ADsPath to printQueue
    if (ppszObjectDN) {
        hr = pPrintQueue->get_ADsPath(&bstrADsPath);
        BAIL_ON_FAILURE(hr);

        if (!(*ppszObjectDN = AllocGlobalStr(bstrADsPath))) {
            dwRet = GetLastError();
            hr = dw2hr(dwRet);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (pszDNWithDC != pszDN)
        FreeSplMem(pszDNWithDC);

    if (bstrADsPath)
        SysFreeString(bstrADsPath);

    if (pszCommonName != pszCN)
        FreeSplMem(pszCommonName);

    if (pADsContainer)
        pADsContainer->Release();

    if (pDispatch)
        pDispatch->Release();

    if (pPrintQueue)
        pPrintQueue->Release();

    if (FAILED(hr) && ppszObjectDN && *ppszObjectDN)
        FreeGlobalStr(*ppszObjectDN);


    return hr2dw(hr);
}


HRESULT
SetProperties(
    HANDLE  hPrinter,
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    IADs    *pPrintQueue
)
{
    HRESULT    hr;

    hr = SetMandatoryProperties(pszServerName,
                                pszShortServerName,
                                pszUNCName,
                                pszPrinterName,
                                dwVersion,
                                pPrintQueue);
    BAIL_ON_FAILURE(hr);

    SetSpoolerProperties(hPrinter, pPrintQueue, dwVersion);
    SetDriverProperties(hPrinter, pPrintQueue);


error:

    return hr;
}

HRESULT
SetMandatoryProperties(
    PWSTR   pszServerName,
    PWSTR   pszShortServerName,
    PWSTR   pszUNCName,
    PWSTR   pszPrinterName,
    DWORD   dwVersion,
    IADs    *pPrintQueue
)
{
    HRESULT         hr;

    // ServerName
    hr = put_BSTR_Property(pPrintQueue, SPLDS_SERVER_NAME, pszServerName);
    BAIL_ON_FAILURE(hr);

    // ShortServerName
    hr = put_BSTR_Property(pPrintQueue, SPLDS_SHORT_SERVER_NAME, pszShortServerName);
    BAIL_ON_FAILURE(hr);

    // UNC Name
    hr = put_BSTR_Property(pPrintQueue, SPLDS_UNC_NAME, pszUNCName);
    BAIL_ON_FAILURE(hr);

    // PrinterName
    hr = put_BSTR_Property(pPrintQueue, SPLDS_PRINTER_NAME, pszPrinterName);
    BAIL_ON_FAILURE(hr);

    // versionNumber
    hr = put_DWORD_Property(pPrintQueue, SPLDS_VERSION_NUMBER, &dwVersion);
    BAIL_ON_FAILURE(hr);

    hr = pPrintQueue->SetInfo();
    if (FAILED(hr))
        pPrintQueue->GetInfo();

error:

    return hr;
}



HRESULT
SetSpoolerProperties(
    HANDLE  hPrinter,
    IADs    *pPrintQueue,
    DWORD   dwVersion
)
{
    HRESULT         hr = S_OK;
    PPRINTER_INFO_2 pInfo2 = NULL;
    DWORD           cbNeeded;
    BYTE            Byte;
    PWSTR           psz;


    // Get PRINTER_INFO_2 properties
    if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, 0, &cbNeeded)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!(pInfo2 = (PPRINTER_INFO_2) AllocSplMem(cbNeeded))) {
            hr = dw2hr(GetLastError());
            goto error;
        }

        if (!GetPrinter(hPrinter, 2, (PBYTE) pInfo2, cbNeeded, &cbNeeded)) {
            hr = dw2hr(GetLastError());
            goto error;
        }
    }


    // Description
    hr = PublishDsData( pPrintQueue,
                        SPLDS_DESCRIPTION,
                        REG_SZ,
                        (PBYTE) pInfo2->pComment);

    // Driver-Name
    hr = PublishDsData( pPrintQueue,
                        SPLDS_DRIVER_NAME,
                        REG_SZ,
                        (PBYTE) pInfo2->pDriverName);

    // Location
    hr = PublishDsData( pPrintQueue,
                        SPLDS_LOCATION,
                        REG_SZ,
                        (PBYTE) pInfo2->pLocation);

    // portName (Port1,Port2,Port3)

    if (pInfo2->pPortName) {

        PWSTR pszPortName;

        // copy comma delimited strings to Multi-sz format
        pszPortName = DelimString2MultiSz(pInfo2->pPortName, L',');

        if (pszPortName) {
            hr = PublishDsData( pPrintQueue,
                                SPLDS_PORT_NAME,
                                REG_MULTI_SZ,
                                (PBYTE) pszPortName);

            FreeSplMem(pszPortName);
        }
    }

    // startTime
    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_START_TIME,
                        REG_DWORD,
                        (PBYTE) &pInfo2->StartTime);

    // endTime
    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_END_TIME,
                        REG_DWORD,
                        (PBYTE) &pInfo2->UntilTime);


    // keepPrintedJobs
    Byte = pInfo2->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ? 1 : 0;

    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_KEEP_PRINTED_JOBS,
                                    REG_BINARY,
                                (PBYTE) &Byte );

    // printSeparatorFile
    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_SEPARATOR_FILE,
                                        REG_SZ,
                        (PBYTE) pInfo2->pSepFile);

    // printShareName
    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_SHARE_NAME,
                        REG_SZ,
                        (PBYTE) pInfo2->pShareName);

    // printSpooling
    if (pInfo2->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
        psz = L"PrintDirect";
    } else if (pInfo2->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST) {
        psz = L"PrintAfterSpooled";
    } else {
        psz = L"PrintWhileSpooling";
    }

    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_SPOOLING,
                        REG_SZ,
                        (PBYTE) psz);


    // priority
    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRIORITY,
                        REG_DWORD,
                        (PBYTE) &pInfo2->Priority);


    //
    // Non-Info2 properties
    // URL - downlevel machines don't support http printers, so don't publish useless url
    //

    if (dwVersion >= WIN2000_SPOOLER_VERSION) {

        DWORD dwRet, dwType;
        PWSTR pszUrl = NULL;

        //
        // Get the url from the print server
        //
        dwRet = GetPrinterDataEx(   hPrinter,
                                    SPLDS_SPOOLER_KEY,
                                    SPLDS_URL,
                                    &dwType,
                                    (PBYTE) pszUrl,
                                    0,
                                    &cbNeeded);

        if (dwRet == ERROR_MORE_DATA) {
            if ((pszUrl = (PWSTR) AllocSplMem(cbNeeded))) {
                dwRet = GetPrinterDataEx(   hPrinter,
                                            SPLDS_SPOOLER_KEY,
                                            SPLDS_URL,
                                            &dwType,
                                            (PBYTE) pszUrl,
                                            cbNeeded,
                                            &cbNeeded);

                if (dwRet == ERROR_SUCCESS && dwType == REG_SZ) {
                    hr = PublishDsData( pPrintQueue,
                                        SPLDS_URL,
                                        REG_SZ,
                                        (PBYTE) pszUrl);
                }
                FreeSplMem(pszUrl);
            }
        }
    }

error:

    FreeSplMem(pInfo2);

    return hr;
}



HRESULT
SetDriverProperties(
    HANDLE   hPrinter,
    IADs    *pPrintQueue
)
{

    DWORD       i, cbBytes, dwCount;
    LPWSTR      pStr;
    DWORD       dwResult;
    LPWSTR      pOutput = NULL, pTemp = NULL, pTemp1 = NULL;
    DWORD       cOutputBytes, cTempBytes;
    POINTS      point;
    WCHAR       pBuf[100];
    BOOL        bInSplSem = TRUE;
    DWORD       dwTemp, dwPrintRate, dwPrintRateUnit, dwPrintPPM;
    HRESULT     hr = S_OK;
    PPRINTER_INFO_2 pInfo2 = NULL;
    PWSTR       pszUNCName;

    // Get UNCName
    hr = GetPrinterInfo2(hPrinter, &pInfo2);
    BAIL_ON_FAILURE(hr);

    if (!pInfo2) {
        hr = dw2hr(GetLastError());
        goto error;
    }

    pszUNCName = pInfo2->pPrinterName;


    // *** DeviceCapability properties ***


    pOutput = (PWSTR) AllocSplMem(cOutputBytes = 200);
    if (!pOutput) {
        hr = dw2hr(GetLastError());
        goto error;
    }

    pTemp = (PWSTR) AllocSplMem(cTempBytes = 200);
    if (!pTemp) {
        hr = dw2hr(GetLastError());
        goto error;
    }


    // printBinNames
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_BINNAMES,
                    24,
                    SPLDS_PRINT_BIN_NAMES);


    // printCollate (awaiting DC_COLLATE)
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_COLLATE,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_COLLATE,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }


    // printColor
    dwResult = DeviceCapabilities(  pszUNCName,
                                                    NULL,
                                    DC_COLORDEVICE,
                                    NULL,
                                    NULL);

    if (dwResult == GDI_ERROR) {

        // Try alternative method
        dwResult = ThisIsAColorPrinter(pszUNCName);
    }

    hr = PublishDsData( pPrintQueue,
                        SPLDS_PRINT_COLOR,
                        REG_BINARY,
                        (PBYTE) &dwResult);



    // printDuplexSupported
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_DUPLEX,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }


    // printStaplingSupported
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_STAPLE,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_STAPLING_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult);
    }


    // printMaxXExtent & printMaxYExtent

    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_MAXEXTENT,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

        dwTemp = (DWORD) point.y;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

    }



    // printMinXExtent & printMinYExtent

    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_MINEXTENT,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MIN_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

        dwTemp = (DWORD) point.y;
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MIN_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp);

    }


    // printMediaSupported
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_PAPERNAMES,
                    64,
                    SPLDS_PRINT_MEDIA_SUPPORTED);


    // printMediaReady
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_MEDIAREADY,
                    64,
                    SPLDS_PRINT_MEDIA_READY);


    // printNumberUp
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_NUP,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        // DS NUp is boolean
        dwResult = !!dwResult;

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }


    // printMemory
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTERMEM,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MEMORY,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }


    // printOrientationsSupported
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_ORIENTATION,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        if (dwResult == 90 || dwResult == 270) {
            wcscpy(pBuf, L"PORTRAIT");
            wcscpy(pStr = pBuf + wcslen(pBuf) + 1, L"LANDSCAPE");
        }
        else {
            wcscpy(pStr = pBuf, L"PORTRAIT");
        }
        pStr += wcslen(pStr) + 1;
        *pStr++ = L'\0';

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_ORIENTATIONS_SUPPORTED,
                            REG_MULTI_SZ,
                            (PBYTE) pBuf);
    }


    // printMaxResolutionSupported

    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_ENUMRESOLUTIONS,
                                    NULL,
                                    NULL);
    if (dwResult != GDI_ERROR) {

        if (cOutputBytes < dwResult*2*sizeof(DWORD)) {
            if(!(pTemp1 = (PWSTR) ReallocSplMem(pOutput, 0, cOutputBytes = dwResult*2*sizeof(DWORD))))
                goto error;
            pOutput = pTemp1;
        }

        dwResult = DeviceCapabilities(  pszUNCName,
                                        NULL,
                                        DC_ENUMRESOLUTIONS,
                                        pOutput,
                                        NULL);
        if (dwResult == GDI_ERROR)
            goto error;

        // Find the maximum resolution: we have dwResult*2 resolutions to check
        for(i = dwTemp = 0 ; i < dwResult*2 ; ++i) {
            if (((DWORD *) pOutput)[i] > dwTemp)
                dwTemp = ((DWORD *) pOutput)[i];
        }

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                            REG_DWORD,
                            (PBYTE) &dwTemp);
    }


    // printLanguage
    DevCapMultiSz(  pszUNCName,
                    pPrintQueue,
                    DC_PERSONALITY,
                    32,
                    SPLDS_PRINT_LANGUAGE);


    // printRate
    // NOTE: If PrintRate is 0, no value is published
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATE,
                                    NULL,
                                    NULL);

    dwPrintRate = dwResult ? dwResult : GDI_ERROR;
    if (dwPrintRate != GDI_ERROR) {

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_RATE,
                            REG_DWORD,
                            (PBYTE) &dwPrintRate);
    }



    // printRateUnit
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATEUNIT,
                                    NULL,
                                    NULL);

    dwPrintRateUnit = dwResult;
    if (dwPrintRateUnit != GDI_ERROR) {

        switch (dwPrintRateUnit) {
            case PRINTRATEUNIT_PPM:
                pStr = L"PagesPerMinute";
                break;

            case PRINTRATEUNIT_CPS:
                pStr = L"CharactersPerSecond";
                break;

            case PRINTRATEUNIT_LPM:
                pStr = L"LinesPerMinute";
                break;

            case PRINTRATEUNIT_IPM:
                pStr = L"InchesPerMinute";
                break;

            default:
                pStr = L"";
                break;
        }

        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_RATE_UNIT,
                            REG_SZ,
                            (PBYTE) pStr);
    }


    // printPagesPerMinute
    // DevCap returns 0 if there is no entry in GPD
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_PRINTRATEPPM,
                                    NULL,
                                    NULL);

    if (dwResult == GDI_ERROR)
        dwResult = 0;

    dwPrintPPM = dwResult;

    // If dwPrintPPM == 0, then calculate PPM from PrintRate
    if (dwPrintPPM == 0) {
        if (dwPrintRate == GDI_ERROR) {
            dwPrintPPM = GDI_ERROR;
        } else {
            switch (dwPrintRateUnit) {
                case PRINTRATEUNIT_PPM:
                    dwPrintPPM = dwPrintRate;
                    break;

                case PRINTRATEUNIT_CPS:
                case PRINTRATEUNIT_LPM:
                    dwPrintPPM = dwPrintRate/PPM_FACTOR;
                    if (dwPrintPPM == 0)
                        dwPrintPPM = 1;     // min PPM is 1
                    break;

                default:
                    dwPrintPPM = GDI_ERROR;
                    break;
            }
        }
    }

    if (dwPrintPPM != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_PRINT_PAGES_PER_MINUTE,
                            REG_DWORD,
                            (PBYTE) &dwPrintPPM);
    }


    // printDriverVersion
    dwResult = DeviceCapabilities(  pszUNCName,
                                    NULL,
                                    DC_VERSION,
                                    NULL,
                                    NULL);

    if (dwResult != GDI_ERROR) {
        hr = PublishDsData( pPrintQueue,
                            SPLDS_DRIVER_VERSION,
                            REG_DWORD,
                            (PBYTE) &dwResult);
    }




error:

    FreeSplMem(pInfo2);

    if (pOutput)
        FreeSplMem(pOutput);

    if (pTemp)
        FreeSplMem(pTemp);

    return hr;
}



HRESULT
PublishDsData(
    IADs   *pADs,
    PWSTR  pValue,
    DWORD  dwType,
    PBYTE  pData
)
{
    HRESULT hr;
    BOOL    bCreated = FALSE;

    switch (dwType) {
        case REG_SZ:
            hr = put_BSTR_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_MULTI_SZ:
            hr = put_MULTISZ_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_DWORD:
            hr = put_DWORD_Property(pADs, pValue, (DWORD *) pData);
            break;

        case REG_BINARY:
            hr = put_BOOL_Property(pADs, pValue, (BOOL *) pData);
            break;

        default:
            hr = dw2hr(ERROR_INVALID_PARAMETER);
    }
    BAIL_ON_FAILURE(hr);

    hr = pADs->SetInfo();
    if (FAILED(hr))
        pADs->GetInfo();

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\winsplc.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\stream.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    Stream.cxx

Abstract:

    implements TStream class methods

Author:

    Adina Trufinescu (AdinaTru)  4-Nov-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "stream.hxx"

/*++

Title:

    TStream

Routine Description:

    Initialize the TStream class; note the class is initaliy
    in an in valid state until a read or write occurs in which
    case the file handle is created and then the class becomes valid.

Arguments:

    None

Return Value:

    Nothing

--*/
TStream::
TStream(
    IN TString&   strFileName
    ) : m_strFileName(strFileName),
        m_hFileHandle(INVALID_HANDLE_VALUE),
        m_dwAccess(0),
        m_bCreated(FALSE)
{
    m_uliStreamSize.QuadPart = 0;
}

/*++

Title:

    ~TStream

Routine Description:

    Releases the stream file handle.

Arguments:

    None

Return Value:

    Nothing

--*/
TStream::
~TStream(
    VOID
    )
{
    if(m_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFileHandle);
    }
}

/*++

Title:

    bValid

Routine Description:

    check class member validity : file handle invalid

Arguments:

    None

Return Value:

    TRUE if class is in a valid state.

--*/
BOOL
TStream::
bValid(
    VOID
    )
{
    return (m_hFileHandle != INVALID_HANDLE_VALUE);
}

/*++

Title:

    Read

Routine Description:

    Reads cb bytes into pv , from current position of file.
    Number of actual reded bytes stored in pbcRead

Arguments:

Return Value:

    The error code from ReadFile API is converted to HRESULT

--*/
HRESULT
TStream::
Read(
    VOID    *pv,
    ULONG   cb,
    ULONG   *pcbRead
    )
{
    TStatusH hr;

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            hr DBGCHK = E_UNEXPECTED;

            goto End;
        }
    }

    if(bValid())
    {
        if(pv)
        {
            if(!ReadFile( m_hFileHandle,
                          reinterpret_cast<LPDWORD>(pv),
                          static_cast<DWORD>(cb),
                          reinterpret_cast<LPDWORD>(pcbRead),
                          NULL))
            {
                *pcbRead = 0;

                hr DBGCHK =  MapWin32ErrorCodeToHRes(GetLastError());

                goto End;

            }

            hr DBGCHK = ((*pcbRead) == cb) && (*pcbRead != 0 && cb != 0) ? S_OK : E_FAIL;

        }
        else
        {
            hr DBGCHK = STG_E_INVALIDPOINTER;
        }
    }

End:

    return hr;

}
/*++

Title:

    Write

Routine Description:

    Writes cb bytes from pv , at current position of file.
    Number of actual written bytes stored in pcbWritten

Arguments:

Return Value:

  The error code from WriteFile API is converted to HRESULT

--*/
HRESULT
TStream::
Write(
    VOID const* pv,
    ULONG cb,
    ULONG * pcbWritten
    )
{
    HRESULT hr = E_UNEXPECTED;

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            goto End;
        }
    }

    if(bValid())
    {
        if(pv)
        {
            if(!WriteFile(m_hFileHandle,
                          static_cast<LPCVOID>(pv),
                          static_cast<DWORD>(cb),
                          reinterpret_cast<LPDWORD>(pcbWritten),
                          NULL))
            {
                if (pcbWritten)
                {
                    *pcbWritten = 0;
                }

                hr = MapWin32ErrorCodeToHRes(GetLastError());
            }

            if (pcbWritten)
            {
                hr = (*pcbWritten == cb) ? S_OK : hr;
            }
            else
            {
                hr = STG_E_INVALIDPOINTER;
            }

            if(SUCCEEDED(hr))
            {
                DBGMSG( DBG_NONE, ( "TPrnStream::Write OK !!!\n" ));
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }

End:

    return hr;

}

/*++

Title:

    Seek

Routine Description:

    Set stream pointer

Arguments:

    dlibMove    -   Offset relative to dwOrigin
    dwOrigin    -   Specifies the origin for the offset
    plibNewPosition -   Pointer to location containing new seek

Return Value:

    The error code from SetFilePointer API is converted to HRESULT

--*/
HRESULT
TStream::
Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition
    )
{
    DWORD   dwMoveMethod;
    DWORD   dwCurrentFilePosition ;
    LONG    lDistanceToMoveHigh;

    TStatusB    bStatus;
    TStatusH    hr;
    DWORD       dwError;

    static const DWORD adwMoveMethode[] =
            {
                FILE_BEGIN,
                FILE_CURRENT,
                FILE_END,
            };

    dwMoveMethod = adwMoveMethode[dwOrigin];

    if(!bValid())
    {
        m_hFileHandle = PCreateFile(&m_dwAccess);

        if(!bValid())
        {
            hr DBGCHK = E_UNEXPECTED;

            goto End;
        }
    }


    lDistanceToMoveHigh     = dlibMove.HighPart;

    dwCurrentFilePosition   = SetFilePointer(   m_hFileHandle,
                                                static_cast<LONG>(dlibMove.LowPart),
                                                &lDistanceToMoveHigh,
                                                dwMoveMethod );

    DBGMSG( DBG_NONE, ( "Seek: Current pos: high %d low %d\n" ,lDistanceToMoveHigh, dwCurrentFilePosition) );

    if (dwCurrentFilePosition == 0xFFFFFFFF && (dwError = GetLastError()) != NO_ERROR )
    {
        hr DBGCHK = MapWin32ErrorCodeToHRes(dwError);
    }
    else
    {
        if(plibNewPosition)
        {
            plibNewPosition->HighPart = static_cast<DWORD>(lDistanceToMoveHigh);

            plibNewPosition->LowPart  = dwCurrentFilePosition;
        }

        hr DBGNOCHK = S_OK;
    }

End:

    return hr;
}


/*++

Title:

    PCreateFile

Routine Description:

    If file doesn't exists , create it with write / read access
    If file exists , try open it with read wrire access ; if fail , try to open with read

Arguments:

    pdwAccess    -   access rights if succeeded , 0 if failed

Return Value:

    The error code from SetFilePointer API is converted to HRESULT

--*/
HANDLE
TStream::
PCreateFile(
    OUT LPDWORD pdwAccess
    )
{
    HANDLE  hFileHandle;
    DWORD   dwAccess;

    *pdwAccess = 0;

    //
    // try to open an existing file with read/write access
    //
    dwAccess = GENERIC_WRITE | GENERIC_READ;

    hFileHandle = CreateFile( m_strFileName,
                              dwAccess,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if(hFileHandle == INVALID_HANDLE_VALUE)
    {
        //
        // if last error is access denied , try to open only with read access
        //
        if(GetLastError() == ERROR_ACCESS_DENIED)
        {
            dwAccess = GENERIC_READ;

            hFileHandle = CreateFile( m_strFileName,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
        }
        else if(GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            dwAccess = GENERIC_WRITE | GENERIC_READ;

            //
            // if last error was file don't exist , try to create it
            //
            hFileHandle = CreateFile( m_strFileName,
                                      dwAccess,
                                      0,
                                      NULL,
                                      OPEN_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

            m_bCreated = TRUE;

        }

    }


    if(hFileHandle != INVALID_HANDLE_VALUE)
    {
        *pdwAccess  = dwAccess;

        m_uliStreamSize.LowPart = GetFileSize(hFileHandle, &m_uliStreamSize.HighPart);
    }

    return hFileHandle;

}

/*++

Title:

    DestroyFile

Routine Description:

    If file handle is invalid , it means that file wasn't creaded - return TRUE
    If file handle is valid , close it and delete file

Arguments:

    None

Return Value:

    TRUE if succeeded

--*/
HRESULT
TStream::
DestroyFile(
    VOID
    )
{
    TStatusB    bStatus;

    bStatus DBGNOCHK = TRUE;

    if(m_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFileHandle);

        m_hFileHandle = INVALID_HANDLE_VALUE;

        bStatus DBGCHK = DeleteFile(m_strFileName);
    }

    return bStatus ? S_OK : MapWin32ErrorCodeToHRes(GetLastError());
}

/*++

Title:

    bSetEndOfFile

Routine Description:

    If file handle is valid , set end of file
    Needed it for truncating the file in case of overwritting
    Called at the end of every successfull storing

Arguments:

    None

Return Value:

    TRUE if succeeded

--*/
BOOL
TStream::
bSetEndOfFile(
    VOID
    )
{
    TStatusB    bStatus;

    bStatus DBGCHK = (m_hFileHandle != INVALID_HANDLE_VALUE);

    if(bStatus)
    {
        bStatus DBGCHK = SetEndOfFile(m_hFileHandle);
    }

    return bStatus;

}

/*++

Title:

    MapWin32ErrorCodeToHRes

Routine Description:

    maps file error codes to HRESULT errors

Arguments:

    Error value to convert

Return Value:

    Converted error value to an HRESULT

Last Error:

--*/
HRESULT
TStream::
MapWin32ErrorCodeToHRes(
    IN DWORD dwErrorCode
    )
{
    return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_STORAGE, dwErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\varconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  varconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    SWilson     Nov 1996
//----------------------------------------------------------------------------

#define INC_OLE2

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "pubprn.hxx"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"


HRESULT
PackString2Variant(
    LPCWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;
    WCHAR String[] = L"";
    LPCWSTR pStr;

    pStr = lpszData ? lpszData : (LPCWSTR) String;

    VariantInit(pvData);
    pvData->vt = VT_BSTR;

    bstrData = SysAllocString(pStr);

    if (!bstrData) {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_WIN32,
                            ERROR_OUTOFMEMORY);
    }

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    return ERROR_SUCCESS;
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = E_POINTER;

    if (pbstrDestString) 
    {
        if (varSrcData.vt != VT_BSTR) 
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }
        else
        {
            *pbstrDestString = SysAllocString(V_BSTR(&varSrcData) ? V_BSTR(&varSrcData) : L"");

            hr = *pbstrDestString ? S_OK : E_OUTOFMEMORY;
        }
    }
    
    return hr;
}


HRESULT
UnpackDispatchfromVariant(
    VARIANT varSrcData,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_DISPATCH(&varSrcData)) {
        *ppDispatch = NULL;
        return S_OK;
    }

    *ppDispatch = V_DISPATCH(&varSrcData);

    return hr;
}



HRESULT
PackDispatch2Variant(
    IDispatch *pDispatch,
    VARIANT *pvData
)
{
    if (!pvData)
        return E_FAIL;

    V_VT(pvData) = VT_DISPATCH;
    V_DISPATCH(pvData) = pDispatch;

    return S_OK;
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }


    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    return S_OK;
}

HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    pvData->vt = VT_BOOL;
    V_BOOL(pvData) = (BYTE) fData;

    return S_OK;
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT *pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    return VariantCopy( pvarInputData, &vaValue );
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i = 0;
    long j = 0;
    long nCount;

    if ( (bstrList != NULL) && (*bstrList != 0) ) {

        for (nCount = 0 ;  bstrList[nCount] ; ++nCount)
            ;

        if ( nCount == 1 ) {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            if (!(V_BSTR(pvVariant) = SysAllocString( bstrList[0]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            return hr;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = 0 ;  bstrList[i] ; ++i) {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (!(V_BSTR(&v) = SysAllocString(bstrList[i]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    } else {

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


HRESULT
PrintVariantArray(VARIANT var)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    if ( !( (V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is only one dimension in this array

    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is atleast one element in this array

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // We know that this is a valid single dimension array

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {
        VariantInit(&v);

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, &v);
        if ( FAILED(hr) )
            continue;

    }

    hr = S_OK;

error:

    return hr;
}




HRESULT
UI1Array2IID(
    VARIANT var,
    IID *pIID
)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    LONG i;
    HRESULT hr = S_OK;
    UCHAR pGUID[16];

    if ( !( (V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is only one dimension in this array

    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is at least one element in this array

    if ((V_ARRAY(&var))->rgsabound[0].cElements != 16) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // We know that this is a valid single dimension array

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, pGUID + i - dwSLBound);
        if ( FAILED(hr) )
            continue;

    }

    *pIID = *(IID *) pGUID;

    hr = S_OK;

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\winspla.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    winspla.c

Abstract:

    Ansi end to winspool.drv

Author:

Environment:

    User Mode -Win32

Revision History:

    amaxa July 2000 - Modified GetPrinterData(Ex)A and SetPrinterData(Ex)A to
                      have the same behavior like the unicode functions.

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "defprn.h"
#include "winsprlp.h"

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct {
    BOOL bOsVersionEx;
    union  {
        OSVERSIONINFOW   *pOsVersion;
        OSVERSIONINFOEXW *pOsVersionEx;
    } Unicode;
    union {
        OSVERSIONINFOA   *pOsVersion;
        OSVERSIONINFOEXA *pOsVersionEx;
    } Ansi;
} OSVERSIONWRAP;

WCHAR *szCurDevMode = L"Printers\\DevModes2";

/* Make sure we have a prototype (in winspool.h):
 */
BOOL
KickoffThread(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    INT_FARPROC pfn
);

LPWSTR
AllocateUnicodeStringWithSize(
    LPSTR  pPrinterName,
    DWORD  cbBytes          // total number of bytes in input MULTI_SZ, incl. NULLs
);

VOID
ValidatePaperFields(
    LPCWSTR    pUnicodeDeviceName,
    LPCWSTR    pUnicodePort,
    LPDEVMODEW pDevModeIn
);

#define NULL_TERMINATED 0

DWORD
UnicodeToAnsi(
    IN     LPBYTE  pUnicode,
    IN     DWORD   cchUnicode,
    IN OUT LPBYTE  pData,
    IN     DWORD   cbData,
    IN OUT DWORD  *pcbCopied OPTIONAL
    );

/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT AnsiToUnicodeString( LPSTR pAnsi, LPWSTR pUnicode, DWORD StringLength )
{
    INT iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_THREAD_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 *
 * Notes:
 *      With DBCS enabled, we will allocate twice the size of the
 *      buffer including the null terminator to take care of double
 *      byte character strings - KrishnaG
 *
 *      pUnicode is truncated to StringLength characters.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT
UnicodeToAnsiString(
    LPWSTR  pUnicode,
    LPSTR   pAnsi,
    DWORD   StringLength)
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;
    LPWSTR pAlignedUnicode = NULL;

    if ((ULONG_PTR)pUnicode != (((ULONG_PTR) (pUnicode) + (sizeof(WCHAR) - 1))&~(sizeof(WCHAR) - 1))) {

        //
        // Calculate the length of the unaligned string.
        //
        if(StringLength == NULL_TERMINATED) {

            for (StringLength = 0;
                 !( ((LPSTR)pUnicode)[StringLength]   == '\0' &&
                    ((LPSTR)pUnicode)[StringLength+1] == '\0' );
                 StringLength += 2)
                ;

            StringLength /= 2;

        } else {

            //
            // WideCharToMultiByte doesn't NULL terminate if we're copying
            // just part of the string, so terminate here.
            //
            ((LPSTR)(pUnicode + StringLength))[0] = '\0';
            ((LPSTR)(pUnicode + StringLength))[1] = '\0';
        }

        StringLength++;

        pAlignedUnicode = LocalAlloc(LPTR, StringLength * sizeof(WCHAR));

        if (pAlignedUnicode) {

            memcpy(pAlignedUnicode, pUnicode, StringLength * sizeof(WCHAR));
        }

    } else {

        pAlignedUnicode = pUnicode;

        if(StringLength == NULL_TERMINATED) {

            //
            // StringLength is just the
            // number of characters in the string
            //
            StringLength = wcslen(pAlignedUnicode);
        }

        //
        // WideCharToMultiByte doesn't NULL terminate if we're copying
        // just part of the string, so terminate here.
        //
        pAlignedUnicode[StringLength] = 0;

        StringLength++;
    }


    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //
    if( pAnsi == (LPSTR)pAlignedUnicode )
    {
        pTempBuf = LocalAlloc( LPTR, StringLength * 2 );
        pAnsi = pTempBuf;
    }

    if( pAnsi && pAlignedUnicode )
    {
        rc = WideCharToMultiByte( CP_THREAD_ACP,
                                  0,
                                  pAlignedUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength*2,
                                  NULL,
                                  NULL );
    }

    //
    // If pTempBuf is non-null, we must copy the resulting string
    // so that it looks as if we did it in place:
    //
    if( pTempBuf )
    {
        if( rc > 0 )
        {
            pAnsi = (LPSTR)pAlignedUnicode;
            strcpy( pAnsi, pTempBuf );
        }

        LocalFree( pTempBuf );
    }

    if (pAlignedUnicode != pUnicode) {

        LocalFree(pAlignedUnicode);
    }

    return rc;
}


void
ConvertUnicodeToAnsiStrings(
    LPBYTE  pStructure,
    LPDWORD pOffsets
)
{
    register DWORD       i=0;
    LPWSTR   pUnicode;
    LPSTR    pAnsi;

    while (pOffsets[i] != -1) {

        pUnicode = *(LPWSTR *)(pStructure+pOffsets[i]);
        pAnsi = (LPSTR)pUnicode;

        if (pUnicode) {
            UnicodeToAnsiString(pUnicode, pAnsi, NULL_TERMINATED);
        }

        i++;
   }
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
)
{
    LPWSTR  pUnicodeString;

    if (!pPrinterName)
        return NULL;

    pUnicodeString = LocalAlloc(LPTR, strlen(pPrinterName)*sizeof(WCHAR) +
                                      sizeof(WCHAR));

    if (pUnicodeString)
        AnsiToUnicodeString(pPrinterName, pUnicodeString, NULL_TERMINATED);

    return pUnicodeString;
}


LPWSTR
AllocateUnicodeStringWithSize(
    LPSTR  pData,
    DWORD  cbData
)
{
    LPWSTR  pUnicodeString = NULL;
    DWORD   iReturn;

    if (pData &&
        (pUnicodeString = LocalAlloc(LPTR, cbData*sizeof(WCHAR))))
    {
        iReturn = MultiByteToWideChar(CP_THREAD_ACP,
                                      MB_PRECOMPOSED,
                                      pData,
                                      cbData,
                                      pUnicodeString,
                                      cbData);

        if (iReturn != cbData)
        {
            LocalFree(pUnicodeString);

            pUnicodeString = NULL;
        }
    }

    return pUnicodeString;
}


LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
)
{
    if (!pUnicodeString)
        return NULL;

    return LocalFree(pUnicodeString);
}

LPBYTE
AllocateUnicodeStructure(
    LPBYTE  pAnsiStructure,
    DWORD   cbStruct,
    LPDWORD pOffsets
)
{
    DWORD   i, j;
    LPWSTR *ppUnicodeString;
    LPSTR  *ppAnsiString;
    LPBYTE  pUnicodeStructure;


    if (!pAnsiStructure) {
        return NULL;
    }
    pUnicodeStructure = LocalAlloc(LPTR, cbStruct);

    if (pUnicodeStructure) {

        memcpy(pUnicodeStructure, pAnsiStructure, cbStruct);

        for (i = 0 ; pOffsets[i] != -1 ; ++i) {

            ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[i]);
            ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[i]);

            *ppUnicodeString = AllocateUnicodeString(*ppAnsiString);

            if (*ppAnsiString && !*ppUnicodeString) {

                for( j = 0 ; j < i ; ++j) {
                    ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[j]);
                    FreeUnicodeString(*ppUnicodeString);
                }
                LocalFree(pUnicodeStructure);
                pUnicodeStructure = NULL;
                break;
            }
       }
    }

    return pUnicodeStructure;
}

DWORD
CopyOsVersionUnicodeToAnsi(
    IN OUT OSVERSIONWRAP Arg
    )

/*++

Routine Name:

    CopyOsVersionUnicodeToAnsi

Routine Description:

    Copies the contents of the UNICODE structure OSVERSIONINFO(EX) into the ANSI structure.

Arguments:

    An OSVERSIONWRAP structure

Return Value:

    Win32 error core

--*/

{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    OSVERSIONINFOEXW *pIn  = Arg.Unicode.pOsVersionEx;
    OSVERSIONINFOEXA *pOut = Arg.Ansi.pOsVersionEx;

    if (pIn && pOut)
    {
        dwError = ERROR_SUCCESS;

        pOut->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        pOut->dwMajorVersion      = pIn->dwMajorVersion;
        pOut->dwMinorVersion      = pIn->dwMinorVersion;
        pOut->dwBuildNumber       = pIn->dwBuildNumber;
        pOut->dwPlatformId        = pIn->dwPlatformId;

        //
        // Initialize the array of chars szCSDVersion to 0 so that we are consistent with
        // the return of the UNICODE versions of GetPrinterData(Ex).
        //
        memset(pOut->szCSDVersion, 0, COUNTOF(pOut->szCSDVersion));

        UnicodeToAnsiString(pIn->szCSDVersion, pOut->szCSDVersion, NULL_TERMINATED);

        //
        // Copy the rest of the Ex structure
        //
        if (Arg.bOsVersionEx)
        {
            pOut->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
            pOut->wServicePackMajor   = pIn->wServicePackMajor;
            pOut->wServicePackMinor   = pIn->wServicePackMinor;
            pOut->wSuiteMask          = pIn->wSuiteMask;
            pOut->wProductType        = pIn->wProductType;
            pOut->wReserved           = pIn->wReserved;
        }
    }

    return dwError;
}

DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax)

/*++

Routine Description:

    Returns the length of the Unicode string, EXCLUDING the NULL.  If the
    string (plus NULL) won't fit into the cchBufMax, then the string len is
    decreased.

Arguments:

Return Value:

--*/

{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax)

/*++

Routine Description:

    Returns the length of the Ansi string, EXCLUDING the NULL.  If the
    string (plus NULL) won't fit into the cchBufMax, then the string len is
    decreased.

Arguments:

Return Value:

--*/

{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}



/***************************** Function Header ******************************
 * AllocateUnicodeDevMode
 *      Allocate a UNICODE version of the DEVMODE structure, and optionally
 *      copy the contents of the ANSI version passed in.
 *
 * RETURNS:
 *      Address of newly allocated structure, 0 if storage not available.
 *
 * HISTORY:
 * 09:23 on 10-Aug-92 -by- Lindsay Harris [lindsayh]
 *      Made it usable.
 *
 * Originally "written" by DaveSn.
 *
 ***************************************************************************/

LPDEVMODEW
AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode
    )
{
    LPDEVMODEW  pUnicodeDevMode;
    LPBYTE      p1, p2;
    DWORD       dwSize;

    //
    // If the devmode is NULL, then return NULL -- KrishnaG
    //
    if ( !pANSIDevMode || !pANSIDevMode->dmSize ) {
        return NULL;
    }

    SPLASSERT( bValidDevModeA( pANSIDevMode ));

    //
    // Determine output structure size.  This has two components:  the
    // DEVMODEW structure size,  plus any private data area.  The latter
    // is only meaningful when a structure is passed in.
    //
    dwSize = pANSIDevMode->dmSize + pANSIDevMode->dmDriverExtra
                                  + sizeof(DEVMODEW) - sizeof(DEVMODEA);

    pUnicodeDevMode = (LPDEVMODEW) LocalAlloc(LPTR, dwSize);

    if( !pUnicodeDevMode ) {
        return NULL;                   /* This is bad news */
    }

    //
    // Copy dmDeviceName which is a string
    //
    if (pANSIDevMode->dmDeviceName)
    {
        AnsiToUnicodeString(pANSIDevMode->dmDeviceName,
                            pUnicodeDevMode->dmDeviceName,
                            ComputeMaxStrlenA(pANSIDevMode->dmDeviceName,
                                         sizeof pANSIDevMode->dmDeviceName));
    }

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pANSIDevMode + pANSIDevMode->dmSize >
                                    (LPBYTE) pANSIDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName);
        p2      = (LPBYTE) pANSIDevMode->dmFormName;


        CopyMemory((LPBYTE) pUnicodeDevMode->dmDeviceName +
                            sizeof(pUnicodeDevMode->dmDeviceName),
                   p1,
                   p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        if (pANSIDevMode->dmFormName)
        {
            AnsiToUnicodeString(pANSIDevMode->dmFormName,
                                pUnicodeDevMode->dmFormName,
                                ComputeMaxStrlenA(pANSIDevMode->dmFormName,
                                             sizeof pANSIDevMode->dmFormName));
        }

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pANSIDevMode->dmFormName +
                                sizeof(pANSIDevMode->dmFormName);
        p2      = (LPBYTE) pANSIDevMode + pANSIDevMode->dmSize
                                        + pANSIDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pUnicodeDevMode->dmFormName +
                                sizeof(pUnicodeDevMode->dmFormName),
                    p1,
                    p2 - p1);

        pUnicodeDevMode->dmSize = pANSIDevMode->dmSize + sizeof(DEVMODEW)
                                                       - sizeof(DEVMODEA);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1 = (LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName);
        p2 = (LPBYTE) pANSIDevMode + pANSIDevMode->dmSize + pANSIDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pUnicodeDevMode->dmDeviceName +
                            sizeof(pUnicodeDevMode->dmDeviceName),
                   p1,
                   p2-p1);

        pUnicodeDevMode->dmSize = pANSIDevMode->dmSize
                                        + sizeof(pUnicodeDevMode->dmDeviceName)
                                        - sizeof(pANSIDevMode->dmDeviceName);
    }

    SPLASSERT(pUnicodeDevMode->dmDriverExtra == pANSIDevMode->dmDriverExtra);


    return pUnicodeDevMode;
}

/************************** Function Header ******************************
 * CopyAnsiDevModeFromUnicodeDevMode
 *      Converts the UNICODE version of the DEVMODE to the ANSI version.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 * 09:57 on 10-Aug-92  -by-  Lindsay Harris [lindsayh]
 *      This one actually works!
 *
 * Originally dreamed up by DaveSn.
 *
 **************************************************************************/

void
CopyAnsiDevModeFromUnicodeDevMode(
    LPDEVMODEA  pANSIDevMode,              /* Filled in by us */
    LPDEVMODEW  pUnicodeDevMode            /* Source of data to fill above */
)
{
    LPBYTE  p1, p2, pExtra;
    WORD    dmSize, dmDriverExtra;

    //
    // NOTE:    THE TWO INPUT STRUCTURES MAY BE THE SAME.
    //
    dmSize          = pUnicodeDevMode->dmSize;
    dmDriverExtra   = pUnicodeDevMode->dmDriverExtra;
    pExtra          = (LPBYTE) pUnicodeDevMode + pUnicodeDevMode->dmSize;

    if (dmSize)
    {
        //
        // Copy dmDeviceName which is a string
        //
        UnicodeToAnsiString(pUnicodeDevMode->dmDeviceName,
                            pANSIDevMode->dmDeviceName,
                            ComputeMaxStrlenW(pUnicodeDevMode->dmDeviceName,
                                         sizeof pANSIDevMode->dmDeviceName));

        //
        // Does the devmode we got have a dmFormName? (Windows 3.1 had
        // DevMode of size 40 and did not have dmFormName)
        //
        if ( (LPBYTE)pUnicodeDevMode + dmSize >
                                        (LPBYTE) pUnicodeDevMode->dmFormName ) {

            //
            // Copy everything between dmDeviceName and dmFormName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmDeviceName +
                                        sizeof(pUnicodeDevMode->dmDeviceName);
            p2      = (LPBYTE) pUnicodeDevMode->dmFormName;

            MoveMemory((LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName),
                        p1,
                        p2 - p1);

            //
            // Copy dmFormName which is a string
            //
            UnicodeToAnsiString(pUnicodeDevMode->dmFormName,
                                pANSIDevMode->dmFormName,
                                ComputeMaxStrlenW(pUnicodeDevMode->dmFormName,
                                             sizeof pANSIDevMode->dmFormName));

            //
            // Copy everything after dmFormName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmFormName +
                                    sizeof(pUnicodeDevMode->dmFormName);
            p2      = (LPBYTE) pUnicodeDevMode + dmSize + dmDriverExtra;

            MoveMemory((LPBYTE) pANSIDevMode->dmFormName +
                                    sizeof(pANSIDevMode->dmFormName),
                        p1,
                        p2 - p1);


            pANSIDevMode->dmSize = dmSize + sizeof(DEVMODEA) - sizeof(DEVMODEW);
        } else {

            //
            // Copy everything after dmDeviceName
            //
            p1      = (LPBYTE) pUnicodeDevMode->dmDeviceName +
                                    sizeof(pUnicodeDevMode->dmDeviceName);
            p2      = (LPBYTE) pUnicodeDevMode + dmSize + dmDriverExtra;

            MoveMemory((LPBYTE) pANSIDevMode->dmDeviceName +
                                    sizeof(pANSIDevMode->dmDeviceName),
                       p1,
                       p2 - p1);


            pANSIDevMode->dmSize = dmSize + sizeof(pANSIDevMode->dmDeviceName)
                                          - sizeof(pUnicodeDevMode->dmDeviceName);
        }

        SPLASSERT(pANSIDevMode->dmDriverExtra == dmDriverExtra);
    }

    return;
}


BOOL
ConvertAnsiDevModeToUnicodeDevmode(
    PDEVMODEA   pAnsiDevMode,
    PDEVMODEW   pUnicodeDevMode,
    DWORD       dwUnicodeDevModeSize,
    PDWORD      pcbNeeded
    )
{
    PDEVMODEW   pDevModeW = NULL;
    BOOL        bRet = FALSE;

    if ( !pAnsiDevMode ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    SPLASSERT( bValidDevModeA( pAnsiDevMode ));

    pDevModeW = AllocateUnicodeDevMode(pAnsiDevMode);
    if ( !pDevModeW ) {

        goto Cleanup;
    }

    *pcbNeeded  = pDevModeW->dmSize + pDevModeW->dmDriverExtra;

    if ( *pcbNeeded > dwUnicodeDevModeSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    CopyMemory((LPBYTE)pUnicodeDevMode,
               (LPBYTE)pDevModeW,
               *pcbNeeded);

    bRet = TRUE;

Cleanup:

    if ( pDevModeW )
        LocalFree(pDevModeW);

    return bRet;
}


BOOL
ConvertUnicodeDevModeToAnsiDevmode(
    PDEVMODEW   pUnicodeDevMode,
    PDEVMODEA   pAnsiDevMode,
    DWORD       dwAnsiDevModeSize,
    PDWORD      pcbNeeded
    )
{
    LPBYTE      pDevMode = NULL;
    BOOL        bRet = FALSE;
    DWORD       dwSize;

    if ( !pUnicodeDevMode ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    dwSize      = pUnicodeDevMode->dmSize + pUnicodeDevMode->dmDriverExtra;

    pDevMode    = LocalAlloc(LPTR, dwSize);

    if ( !pDevMode ) {

        goto Cleanup;
    }

    CopyMemory(pDevMode,
               (LPBYTE)pUnicodeDevMode,
               dwSize);

    CopyAnsiDevModeFromUnicodeDevMode((PDEVMODEA) pDevMode,
                                      (PDEVMODEW) pDevMode);

    *pcbNeeded = ((PDEVMODEA)pDevMode)->dmSize + ((PDEVMODEA)pDevMode)->dmDriverExtra;

    if ( *pcbNeeded > dwAnsiDevModeSize ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    CopyMemory((LPBYTE)pAnsiDevMode,
               pDevMode,
               *pcbNeeded);

    bRet = TRUE;

Cleanup:
    if ( pDevMode )
        LocalFree(pDevMode);

    return bRet;
}


void
FreeUnicodeStructure(
    LPBYTE  pUnicodeStructure,
    LPDWORD pOffsets
)
{
    DWORD   i=0;

    if ( pUnicodeStructure == NULL ) {
        return;
    }

    if (pOffsets) {
        while (pOffsets[i] != -1) {

            FreeUnicodeString(*(LPWSTR *)(pUnicodeStructure+pOffsets[i]));
            i++;
        }
    }

    LocalFree( pUnicodeStructure );
}

BOOL
EnumPrintersA(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName;

    switch (Level) {

    case STRESSINFOLEVEL:
        pOffsets = PrinterInfoStressStrings;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 4:
        pOffsets = PrinterInfo4Strings;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 1:
        pOffsets = PrinterInfo1Strings;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(Name);
    if (Name && !pUnicodeName)
        return FALSE;

    ReturnValue = EnumPrintersW(Flags, pUnicodeName, Level, pPrinterEnum,
                                cbBuf, pcbNeeded, pcReturned);

    if (ReturnValue && pPrinterEnum) {

        DWORD   i=*pcReturned;

        while (i--) {


            ConvertUnicodeToAnsiStrings(pPrinterEnum, pOffsets);

            if ((Level == 2) && pPrinterEnum) {

                PRINTER_INFO_2 *pPrinterInfo2 = (PRINTER_INFO_2 *)pPrinterEnum;

                if (pPrinterInfo2->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode);
            }

            pPrinterEnum+=cbStruct;
        }
    }

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
OpenPrinterA(
    LPSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSA pDefault
    )
{
    BOOL ReturnValue = FALSE;
    LPWSTR pUnicodePrinterName = NULL;
    PRINTER_DEFAULTSW UnicodeDefaults={NULL, NULL, 0};

    pUnicodePrinterName = AllocateUnicodeString(pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    if (pDefault) {

        UnicodeDefaults.pDatatype = AllocateUnicodeString(pDefault->pDatatype);
        if (pDefault->pDatatype && !UnicodeDefaults.pDatatype)
            goto Cleanup;

        //
        // Milestones etc. 4.5 passes in a bogus devmode in pDefaults.
        // Be sure to validate here.
        //
        if( bValidDevModeA( pDefault->pDevMode )){

            UnicodeDefaults.pDevMode = AllocateUnicodeDevMode(
                                           pDefault->pDevMode );

            if( !UnicodeDefaults.pDevMode ){
                goto Cleanup;
            }
        }

        UnicodeDefaults.DesiredAccess = pDefault->DesiredAccess;
    }

    ReturnValue = OpenPrinterW(pUnicodePrinterName, phPrinter, &UnicodeDefaults);

    if (ReturnValue) {

        ((PSPOOL)*phPrinter)->Status |= SPOOL_STATUS_ANSI;
    }

Cleanup:

    if (UnicodeDefaults.pDevMode)
        LocalFree(UnicodeDefaults.pDevMode);

    FreeUnicodeString(UnicodeDefaults.pDatatype);
    FreeUnicodeString(pUnicodePrinterName);

    return ReturnValue;
}

BOOL
ResetPrinterA(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSA pDefault
)
{
    BOOL  ReturnValue = FALSE;
    PRINTER_DEFAULTSW UnicodeDefaults={NULL, NULL, 0};

    if (pDefault) {

        if (pDefault->pDatatype == (LPSTR)-1) {
            UnicodeDefaults.pDatatype = (LPWSTR)-1;
        } else {

            UnicodeDefaults.pDatatype = AllocateUnicodeString(pDefault->pDatatype);
            if (pDefault->pDatatype && !UnicodeDefaults.pDatatype)
                return FALSE;
        }

        if (pDefault->pDevMode == (LPDEVMODEA)-1) {
            UnicodeDefaults.pDevMode = (LPDEVMODEW)-1;
        } else {

            if( bValidDevModeA( pDefault->pDevMode )){

                UnicodeDefaults.pDevMode = AllocateUnicodeDevMode(
                                               pDefault->pDevMode );

                if( !UnicodeDefaults.pDevMode ){
                    goto Cleanup;
                }
            }
        }
    }

    ReturnValue = ResetPrinterW(hPrinter, &UnicodeDefaults);

    if (UnicodeDefaults.pDevMode &&
        (UnicodeDefaults.pDevMode != (LPDEVMODEW)-1)){

        LocalFree(UnicodeDefaults.pDevMode);
    }


Cleanup:

    if (UnicodeDefaults.pDatatype && (UnicodeDefaults.pDatatype != (LPWSTR)-1)) {
        FreeUnicodeString(UnicodeDefaults.pDatatype);
    }

    return ReturnValue;
}

BOOL
SetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue=FALSE;
    LPBYTE pUnicodeStructure=NULL;
    LPDEVMODEW pDevModeW = NULL;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 0:
        break;

    case 1:
        pOffsets = JobInfo1Strings;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        return SetJobW( hPrinter, JobId, Level, pJob, Command );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    if (Level) {
        pUnicodeStructure = AllocateUnicodeStructure(pJob, cbStruct, pOffsets);
        if (pJob && !pUnicodeStructure)
            return FALSE;
    }

    if ( Level == 2 && pUnicodeStructure && pJob ) {

        if( bValidDevModeA( ((LPJOB_INFO_2A)pJob)->pDevMode )){

            pDevModeW = AllocateUnicodeDevMode(((LPJOB_INFO_2A)pJob)->pDevMode);

            if( !pDevModeW ){
                ReturnValue = FALSE;
                goto Cleanup;
            }
            ((LPJOB_INFO_2W) pUnicodeStructure)->pDevMode = pDevModeW;
        }
    }

    ReturnValue = SetJobW(hPrinter, JobId, Level, pUnicodeStructure, Command);

    if ( pDevModeW ) {

        LocalFree(pDevModeW);
    }

Cleanup:
    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    return ReturnValue;
}

BOOL
GetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    case 3:
        return GetJobW( hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (GetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded)) {

        ConvertUnicodeToAnsiStrings(pJob, pOffsets);

        //
        // Convert the devmode in place for INFO_2.
        //
        if( Level == 2 ){

            PJOB_INFO_2A pJobInfo2 = (PJOB_INFO_2A)pJob;

            if( pJobInfo2->pDevMode ){
                CopyAnsiDevModeFromUnicodeDevMode(
                    (LPDEVMODEA)pJobInfo2->pDevMode,
                    (LPDEVMODEW)pJobInfo2->pDevMode);
            }
        }

        return TRUE;

    } else

        return FALSE;
}

BOOL
EnumJobsA(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        return EnumJobsW( hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded, pcReturned );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (EnumJobsW(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded,
                 pcReturned)) {

        i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pJob, pOffsets);

            //
            // Convert the devmode in place for INFO_2.
            //
            if( Level == 2 ){

                PJOB_INFO_2A pJobInfo2 = (PJOB_INFO_2A)pJob;

                if( pJobInfo2->pDevMode ){
                    CopyAnsiDevModeFromUnicodeDevMode(
                        (LPDEVMODEA)pJobInfo2->pDevMode,
                        (LPDEVMODEW)pJobInfo2->pDevMode);
                }
            }

            pJob += cbStruct;
        }

        return TRUE;

    } else

        return FALSE;
}

HANDLE
AddPrinterA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    HANDLE  hPrinter = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDEVMODEW pDevModeW = NULL;
    LPWSTR  pUnicodeName = NULL;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    if (!pPrinter) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
    if (pPrinter && !pUnicodeStructure)
        goto Cleanup;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    if ( pUnicodeStructure ) {

        if( bValidDevModeA( ((LPPRINTER_INFO_2A)pPrinter)->pDevMode )){
            pDevModeW = AllocateUnicodeDevMode(
                            ((LPPRINTER_INFO_2A)pPrinter)->pDevMode);

            if( !pDevModeW ){
                goto Cleanup;
            }
        }

        ((LPPRINTER_INFO_2W)pUnicodeStructure)->pDevMode =  pDevModeW;

        hPrinter = AddPrinterW(pUnicodeName, Level, pUnicodeStructure);
    }

Cleanup:

    FreeUnicodeString( pUnicodeName );

    if ( pDevModeW ) {

        LocalFree(pDevModeW);
    }

    FreeUnicodeStructure( pUnicodeStructure, pOffsets );

    return hPrinter;
}

BOOL
AddPrinterConnectionA(
    LPSTR   pName
)
{
    BOOL    rc;
    LPWSTR  pUnicodeName;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        return FALSE;

    rc = AddPrinterConnectionW(pUnicodeName);

    FreeUnicodeString(pUnicodeName);

    return rc;
}

BOOL
DeletePrinterConnectionA(
    LPSTR   pName
)
{
    BOOL    rc;
    LPWSTR  pUnicodeName;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        return FALSE;

    rc = DeletePrinterConnectionW(pUnicodeName);

    FreeUnicodeString(pUnicodeName);

    return rc;
}

BOOL
SetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPBYTE  pUnicodeStructure;         /* Unicode version of input data */
    DWORD   cbStruct;                  /* Size of the output structure */
    DWORD  *pOffsets;                  /* -1 terminated list of addresses */
    DWORD   ReturnValue=FALSE;

    //
    // For APP compat. Win9x handled this
    //
    if (eProtectHandle(hPrinter, FALSE))
    {
        return FALSE;
    }

    switch (Level) {

    case 0:
        //
        // This could be 2 cases. STRESSINFOLEVEL, or the real 0 level.
        // If Command is 0 then it is STRESSINFOLEVEL, else real 0 level
        //
        if ( !Command ) {

            pOffsets = PrinterInfoStressStrings;
            cbStruct = sizeof( PRINTER_INFO_STRESS );
        }
        break;

    case 1:
        pOffsets = PrinterInfo1Strings;
        cbStruct = sizeof( PRINTER_INFO_1 );
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        cbStruct = sizeof( PRINTER_INFO_2 );
        break;

    case 3:
        pOffsets = PrinterInfo3Strings;
        cbStruct = sizeof( PRINTER_INFO_3 );
        break;

    case 4:
        pOffsets = PrinterInfo4Strings;
        cbStruct = sizeof( PRINTER_INFO_4 );
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        cbStruct = sizeof( PRINTER_INFO_5 );
        break;

    case 6:
        break;

    case 7:
        pOffsets = PrinterInfo7Strings;
        cbStruct = sizeof( PRINTER_INFO_7 );
        break;

    case 8:
        pOffsets = PrinterInfo8Strings;
        cbStruct = sizeof( PRINTER_INFO_8 );
        break;

    case 9:
        pOffsets = PrinterInfo9Strings;
        cbStruct = sizeof( PRINTER_INFO_9 );
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        goto Done;
    }

     //
     //    The structure needs to have its CONTENTS converted from
     //  ANSI to Unicode.  The above switch() statement filled in
     //  the two important pieces of information needed to accomplish
     //  this goal.  First is the size of the structure, second is
     //  a list of the offset within the structure to UNICODE
     //  string pointers.  The AllocateUnicodeStructure() call will
     //  allocate a wide version of the structure, copy its contents
     //  and convert the strings to Unicode as it goes.  That leaves
     //  us to deal with any other pieces needing conversion.
     //

    //
    // If Level == 0 and Command != 0 then pPrinter is a DWORD
    //
    if ( Level == 6 || (!Level && Command) ) {

        if ( Level == 6 || Command == PRINTER_CONTROL_SET_STATUS )
            pUnicodeStructure = pPrinter;
        else
            pUnicodeStructure = NULL;

    } else {

        pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
        if (pPrinter && !pUnicodeStructure)
        {
            goto Done;
        }
    }

#define pPrinterInfo2W  ((LPPRINTER_INFO_2W)pUnicodeStructure)
#define pPrinterInfo2A  ((LPPRINTER_INFO_2A)pPrinter)

    //  The Level 2 structure has a DEVMODE struct in it: convert now

    if ( Level == 2  &&
         pPrinterInfo2A &&
         pPrinterInfo2A->pDevMode ) {

        if( bValidDevModeA( pPrinterInfo2A->pDevMode )){
            pPrinterInfo2W->pDevMode = AllocateUnicodeDevMode(
                                           pPrinterInfo2A->pDevMode );

            if( !pPrinterInfo2W->pDevMode)
            {
                FreeUnicodeStructure(pUnicodeStructure, pOffsets);
                goto Done;
            }
        }
    }

#define pPrinterInfo8W  ((LPPRINTER_INFO_8W)pUnicodeStructure)
#define pPrinterInfo8A  ((LPPRINTER_INFO_8A)pPrinter)

    if (( Level == 8 || Level == 9 ) &&
         pPrinterInfo8A &&
         pPrinterInfo8A->pDevMode ) {

        if( bValidDevModeA( pPrinterInfo8A->pDevMode )){
            pPrinterInfo8W->pDevMode = AllocateUnicodeDevMode(
                                           pPrinterInfo8A->pDevMode );

            if( !pPrinterInfo8W->pDevMode)
            {
                FreeUnicodeStructure(pUnicodeStructure, pOffsets);
                goto Done;
            }
        }
    }

    ReturnValue = SetPrinterW( hPrinter, Level, pUnicodeStructure, Command );


    //  Free the DEVMODE we allocated (if we did!), then the
    //  the Unicode structure and its contents.


    if (Level == 2 &&
        pPrinterInfo2W &&
        pPrinterInfo2W->pDevMode ) {

        LocalFree( pPrinterInfo2W->pDevMode );
    }

    if ((Level == 8 || Level == 9) &&
        pUnicodeStructure &&
        pPrinterInfo8W->pDevMode ) {

        LocalFree( pPrinterInfo8W->pDevMode );
    }

    //
    // STRESS_INFO and Levels 1-5
    //
    if ( Level != 6 && (Level || !Command) )
        FreeUnicodeStructure( pUnicodeStructure, pOffsets );

#undef pPrinterInfo2W
#undef pPrinterInfo2A

Done:

    vUnprotectHandle(hPrinter);

    return ReturnValue;
}

BOOL
GetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;

    switch (Level) {

        case STRESSINFOLEVEL:
            pOffsets = PrinterInfoStressOffsets;
            break;

        case 1:
            pOffsets = PrinterInfo1Strings;
            break;

        case 2:
            pOffsets = PrinterInfo2Strings;
            break;

        case 3:
            pOffsets = PrinterInfo3Strings;
            break;

        case 4:
            pOffsets = PrinterInfo4Strings;
            break;

        case 5:
            pOffsets = PrinterInfo5Strings;
            break;

        case 6:
            pOffsets = PrinterInfo6Strings;
            break;

        case 7:
            pOffsets = PrinterInfo7Strings;
            break;

        case 8:
            pOffsets = PrinterInfo8Strings;
            break;

        case 9:
            pOffsets = PrinterInfo9Strings;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    if (GetPrinter(hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

        if (pPrinter) {

            ConvertUnicodeToAnsiStrings(pPrinter, pOffsets);

            if ((Level == 2) && pPrinter) {

                PRINTER_INFO_2 *pPrinterInfo2 = (PRINTER_INFO_2 *)pPrinter;

                if (pPrinterInfo2->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode);
            }

            if ((Level == 8 || Level == 9) && pPrinter) {

                PRINTER_INFO_8 *pPrinterInfo8 = (PRINTER_INFO_8 *)pPrinter;

                if (pPrinterInfo8->pDevMode)
                    CopyAnsiDevModeFromUnicodeDevMode(
                                        (LPDEVMODEA)pPrinterInfo8->pDevMode,
                                        (LPDEVMODEW)pPrinterInfo8->pDevMode);
            }
        }

        return TRUE;
    }

    return FALSE;
}

//
// Conversion in place
//
BOOL
UnicodeToAnsiMultiSz(
    LPWSTR pUnicodeDependentFiles
    )
{
    LPWSTR  pAlignedUnicodeStr = NULL;
    LPWSTR  pUnicodeStr;
    DWORD   StringLength, rc;
    DWORD   Index;
    BOOL    bReturn = FALSE;


    if (!(pUnicodeDependentFiles) || !*pUnicodeDependentFiles) {

        bReturn = TRUE;

    } else {

        if ((ULONG_PTR)pUnicodeDependentFiles != (((ULONG_PTR) (pUnicodeDependentFiles) + (sizeof(WCHAR) - 1))&~(sizeof(WCHAR) - 1))) {

            //
            // Calculate the length of the unaligned multisz string
            //
            for (StringLength = 0;
                 !( ((LPSTR)pUnicodeDependentFiles)[StringLength]     == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 1] == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 2] == '\0' &&
                    ((LPSTR)pUnicodeDependentFiles)[StringLength + 3] == '\0' );
                StringLength += 2)
                ;

            StringLength /= 2;

            //
            // Include NULL terminator for last string and NULL terminator for MULTI SZ
            //
            StringLength +=2;

        } else {

            //
            // The string is WCHAR aligned.
            //
            pUnicodeStr = pUnicodeDependentFiles;

            while ( *pUnicodeStr ) {

                pUnicodeStr += wcslen(pUnicodeStr) + 1;
            }

            StringLength = (DWORD) (pUnicodeStr - pUnicodeDependentFiles + 1);
        }

        //
        // Since WideCharToMultiByte doesn't do in place conversion,
        // duplicate the pUnicodeDependentFiles regardless if it is aligned or not.
        //
        if (pAlignedUnicodeStr = LocalAlloc(LPTR, StringLength * sizeof(char) * 2)) {

            memcpy( pAlignedUnicodeStr, pUnicodeDependentFiles, StringLength * sizeof(char)* 2);

            rc = WideCharToMultiByte(CP_THREAD_ACP,
                                     0,
                                     pAlignedUnicodeStr,
                                     StringLength,
                                     (LPSTR)pUnicodeDependentFiles,
                                     StringLength * 2,
                                     NULL, NULL );

            LocalFree( pAlignedUnicodeStr );

            bReturn = rc > 0;
        }

    }

    return bReturn;
}

BOOL
AnsiToUnicodeMultiSz(
    LPSTR   pAnsiDependentFiles,
    LPWSTR *pUnicodeDependentFiles
    )
{
    LPWSTR  pUnicodeStr;
    LPSTR   pAnsiStr;
    DWORD   len, rc;

    if ( ! (pAnsiStr = pAnsiDependentFiles) || !*pAnsiStr ) {
        *pUnicodeDependentFiles = NULL;
        return TRUE;
    }

    while ( *pAnsiStr )
            pAnsiStr += strlen(pAnsiStr) + 1;
    len = (DWORD) (pAnsiStr - pAnsiDependentFiles + 1);

    if ( !(*pUnicodeDependentFiles = LocalAlloc(LPTR, len * sizeof(WCHAR))) ) {

        return FALSE;
    }

    AnsiToUnicodeString(pAnsiDependentFiles, *pUnicodeDependentFiles, len-1);

    return TRUE;
}

BOOL
AddPrinterDriverExA(
    LPSTR   pName,
    DWORD   Level,
    PBYTE   pPrinter,
    DWORD   dwFileCopyFlags
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    switch (Level) {

    case 2:
        pOffsets = DriverInfo2Strings;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!pPrinter) {

        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pPrinter, cbStruct, pOffsets);
    if (pPrinter && !pUnicodeStructure)
        goto Error;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Error;


    //
    // Handle dependent files which is upto \0\0
    //
    if ( ( Level == 3 || Level == 4 || Level ==6 ) &&
         !AnsiToUnicodeMultiSz(
                (LPSTR) ((PDRIVER_INFO_3A)pPrinter)->pDependentFiles,
                &(((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles)) ) {

            goto Error;
    }

    //
    // Handle pszzPreviousNames which is upto \0\0
    //
    if ( ( Level == 4 || Level == 6 ) &&
         !AnsiToUnicodeMultiSz(
                (LPSTR) ((PDRIVER_INFO_4A)pPrinter)->pszzPreviousNames,
                &(((PDRIVER_INFO_4W)pUnicodeStructure)->pszzPreviousNames)) ) {

            goto Error;
    }

    ReturnValue = AddPrinterDriverExW(pUnicodeName, Level, pUnicodeStructure,dwFileCopyFlags);

    if ( ( Level == 3 || Level == 4 || Level == 6)   &&
         ((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles ) {

            LocalFree(((PDRIVER_INFO_3W)pUnicodeStructure)->pDependentFiles);
    }

    if ( (Level == 4 || Level == 6 )&&
         (((PDRIVER_INFO_4)pUnicodeStructure)->pszzPreviousNames) )
        LocalFree(((PDRIVER_INFO_4)pUnicodeStructure)->pszzPreviousNames);

Error:

    FreeUnicodeStructure( pUnicodeStructure, pOffsets );

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}


BOOL
AddPrinterDriverA(
    LPSTR   pName,
    DWORD   Level,
    PBYTE   pPrinter
)
{
    return AddPrinterDriverExA(pName, Level, pPrinter, APD_COPY_NEW_FILES);
}

BOOL
EnumPrinterDriversA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Strings;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pOffsets = DriverInfo2Strings;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pOffsets = DriverInfo5Strings;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = EnumPrinterDriversW(pUnicodeName, pUnicodeEnvironment,
                                          Level, pDriverInfo, cbBuf,
                                          pcbNeeded, pcReturned)) {
        if (pDriverInfo) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pDriverInfo, pOffsets);

                if ( ( Level == 3 || Level == 4 || Level == 6)   &&
                     !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_3) pDriverInfo)->pDependentFiles) )
                    ReturnValue = FALSE;

                if ( ( Level == 4 || Level == 6 )   &&
                     !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_4) pDriverInfo)->pszzPreviousNames) )
                    ReturnValue = FALSE;

                pDriverInfo+=cbStruct;
            }
        }

    }

Cleanup:

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
GetPrinterDriverA(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;
    LPWSTR  pUnicodeEnvironment = NULL;
    BOOL    ReturnValue;

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Strings;
        break;

    case 2:
        pOffsets = DriverInfo2Strings;
        break;

    case 3:
        pOffsets = DriverInfo3Strings;
        break;

    case 4:
        pOffsets = DriverInfo4Strings;
        break;

    case 5:
        pOffsets = DriverInfo5Strings;
        break;

    case 6:
        pOffsets = DriverInfo6Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        return FALSE;

    if (ReturnValue = GetPrinterDriverW(hPrinter, pUnicodeEnvironment, Level,
                                        pDriverInfo, cbBuf, pcbNeeded)) {
        if (pDriverInfo) {

            ConvertUnicodeToAnsiStrings(pDriverInfo, pOffsets);

            if ( ( Level == 3 || Level == 4 || Level == 6)   &&
                 !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles) ) {

                  ReturnValue = FALSE;
            }

            if ( ( Level == 4 || Level == 6 ) &&
                 !UnicodeToAnsiMultiSz(
                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames) ) {

                  ReturnValue = FALSE;
            }
        }
    }

    // If called to get the size of buffer it will return the size of a W structure and strings
    // rather than the A version.  also see enum
    // This cannot cause any harm since we are only allocating more memory than we need.

    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
GetPrinterDriverDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pDriverDirectoryW = NULL;
    BOOL    ReturnValue = FALSE;
    DWORD   Offsets[]={0,(DWORD)-1};

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = GetPrinterDriverDirectoryW(pUnicodeName,
                                                 pUnicodeEnvironment, Level,
                                                 pDriverDirectory,
                                                 cbBuf, pcbNeeded)) {

        if (pDriverDirectory) {

            UnicodeToAnsiString((LPWSTR)pDriverDirectory, pDriverDirectory, NULL_TERMINATED);

        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}


BOOL
DeletePrinterDriverExA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName,
   DWORD    dwDeleteFlag,
   DWORD    dwVersionNum
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeDriverName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeDriverName = AllocateUnicodeString(pDriverName);
    if (pDriverName && !pUnicodeDriverName)
        goto Cleanup;

    rc = DeletePrinterDriverExW(pUnicodeName,
                               pUnicodeEnvironment,
                               pUnicodeDriverName,
                               dwDeleteFlag,
                               dwVersionNum);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeDriverName);

    return rc;
}


BOOL
DeletePrinterDriverA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeDriverName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeDriverName = AllocateUnicodeString(pDriverName);
    if (pDriverName && !pUnicodeDriverName)
        goto Cleanup;

    rc = DeletePrinterDriverW(pUnicodeName,
                              pUnicodeEnvironment,
                              pUnicodeDriverName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeDriverName);

    return rc;
}


BOOL
AddPerMachineConnectionA(
    LPCSTR    pServer,
    LPCSTR    pPrinterName,
    LPCSTR    pPrintServer,
    LPCSTR    pProvider
)
{

    LPWSTR  pUnicodeServer = NULL;
    LPWSTR  pUnicodePrinterName = NULL;
    LPWSTR  pUnicodePrintServer = NULL;
    LPWSTR  pUnicodeProvider = NULL;
    BOOL    rc = FALSE;

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    pUnicodePrinterName = AllocateUnicodeString((LPSTR)pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    pUnicodePrintServer = AllocateUnicodeString((LPSTR)pPrintServer);
    if (pPrintServer && !pUnicodePrintServer)
        goto Cleanup;

    pUnicodeProvider = AllocateUnicodeString((LPSTR)pProvider);
    if (pProvider && !pUnicodeProvider)
        goto Cleanup;


    rc = AddPerMachineConnectionW((LPCWSTR) pUnicodeServer,
                                  (LPCWSTR) pUnicodePrinterName,
                                  (LPCWSTR) pUnicodePrintServer,
                                  (LPCWSTR) pUnicodeProvider);

Cleanup:
    FreeUnicodeString(pUnicodeServer);

    FreeUnicodeString(pUnicodePrinterName);

    FreeUnicodeString(pUnicodePrintServer);

    FreeUnicodeString(pUnicodeProvider);

    return rc;
}

BOOL
DeletePerMachineConnectionA(
    LPCSTR    pServer,
    LPCSTR    pPrinterName
)
{

    LPWSTR  pUnicodeServer = NULL;
    LPWSTR  pUnicodePrinterName = NULL;
    BOOL    rc = FALSE;

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    pUnicodePrinterName = AllocateUnicodeString((LPSTR)pPrinterName);
    if (pPrinterName && !pUnicodePrinterName)
        goto Cleanup;

    rc = DeletePerMachineConnectionW((LPCWSTR) pUnicodeServer,
                                     (LPCWSTR) pUnicodePrinterName);

Cleanup:
    FreeUnicodeString(pUnicodeServer);

    FreeUnicodeString(pUnicodePrinterName);

    return rc;
}

BOOL
EnumPerMachineConnectionsA(
    LPCSTR  pServer,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct,index;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeServer = NULL;

    pOffsets = PrinterInfo4Strings;
    cbStruct = sizeof(PRINTER_INFO_4);

    pUnicodeServer = AllocateUnicodeString((LPSTR)pServer);
    if (pServer && !pUnicodeServer)
        goto Cleanup;

    ReturnValue = EnumPerMachineConnectionsW((LPCWSTR) pUnicodeServer,
                                             pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcReturned);

    if (ReturnValue && pPrinterEnum) {
        index=*pcReturned;
        while (index--) {
            ConvertUnicodeToAnsiStrings(pPrinterEnum, pOffsets);
            pPrinterEnum+=cbStruct;
        }
    }

Cleanup:
    FreeUnicodeString(pUnicodeServer);
    return ReturnValue;
}

BOOL
AddPrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPathName,
    LPSTR   pPrintProcessorName
)
{
    BOOL    ReturnValue=FALSE;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePathName = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;

    if (!pPathName || !*pPathName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePathName = AllocateUnicodeString(pPathName);
    if (pPathName && !pUnicodePathName)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;


    if (pUnicodePathName && pUnicodePrintProcessorName) {

        ReturnValue = AddPrintProcessorW(pUnicodeName, pUnicodeEnvironment,
                                         pUnicodePathName,
                                         pUnicodePrintProcessorName);
    }


Cleanup:
    FreeUnicodeString(pUnicodeName);
    FreeUnicodeString(pUnicodeEnvironment);
    FreeUnicodeString(pUnicodePathName);
    FreeUnicodeString(pUnicodePrintProcessorName);

    return ReturnValue;
}

BOOL
EnumPrintProcessorsA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    switch (Level) {

    case 1:
        pOffsets = PrintProcessorInfo1Strings;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    if (ReturnValue = EnumPrintProcessorsW(pUnicodeName,
                                           pUnicodeEnvironment, Level,
                                           pPrintProcessorInfo, cbBuf,
                                           pcbNeeded, pcReturned)) {
        if (pPrintProcessorInfo) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pPrintProcessorInfo, pOffsets);

                pPrintProcessorInfo+=cbStruct;
            }
        }

    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
GetPrintProcessorDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL    ReturnValue = FALSE;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    ReturnValue = GetPrintProcessorDirectoryW(pUnicodeName,
                                              pUnicodeEnvironment,
                                              Level,
                                              pPrintProcessorInfo,
                                              cbBuf, pcbNeeded);

    if (ReturnValue && pPrintProcessorInfo) {
                UnicodeToAnsiString((LPWSTR)pPrintProcessorInfo,
                                        (LPSTR)pPrintProcessorInfo,
                                        NULL_TERMINATED);
    }

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    return ReturnValue;
}

BOOL
EnumPrintProcessorDatatypesA(
    LPSTR   pName,
    LPSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatype,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;

    switch (Level) {

    case 1:
        pOffsets = DatatypeInfo1Strings;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;

    if (ReturnValue = EnumPrintProcessorDatatypesW(pUnicodeName,
                                                   pUnicodePrintProcessorName,
                                                   Level,
                                                   pDatatype,
                                                   cbBuf,
                                                   pcbNeeded,
                                                   pcReturned)) {
        if (pDatatype) {

            DWORD   i=*pcReturned;

            while (i--) {

                ConvertUnicodeToAnsiStrings(pDatatype, pOffsets);

                pDatatype += cbStruct;
            }
        }

    }

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePrintProcessorName);

    return ReturnValue;
}

DWORD
StartDocPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL    ReturnValue = FALSE;
    LPBYTE  pUnicodeStructure = NULL;
    DWORD   cbStruct;

    // level 2 is supported on win95 and not on NT
    switch (Level) {
    case 1:
        cbStruct = sizeof(DOC_INFO_1A);
        break;
    case 3:
        cbStruct = sizeof(DOC_INFO_3A);
        break;
    default:
        // invalid level
        SetLastError(ERROR_INVALID_LEVEL);
        goto Cleanup;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pDocInfo, cbStruct, DocInfo1Offsets);
    if (pDocInfo && !pUnicodeStructure)
        goto Cleanup;

    ReturnValue = StartDocPrinterW(hPrinter, Level, pUnicodeStructure);

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, DocInfo1Offsets);

    return ReturnValue;
}

BOOL
AddJobA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL ReturnValue;

    if( Level == 2 || Level == 3 ){

        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    if (ReturnValue = AddJobW(hPrinter, Level, pData,
                              cbBuf, pcbNeeded))

        ConvertUnicodeToAnsiStrings(pData, AddJobStrings);

    return ReturnValue;
}

DWORD
GetPrinterDataA(
   HANDLE   hPrinter,
   LPSTR    pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue       = ERROR_SUCCESS;
    DWORD   ReturnType        = 0;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeValueName = AllocateUnicodeString(pValueName);

    //
    // pUnicodeValueName will be NULL if the caller passed NULL for pValueName. The
    // invalid situation is when pValueName is non NULL and pUnicodeValueName is NULL
    //
    if (pUnicodeValueName || !pValueName)
    {
        if (!pType)
        {
            pType = (PDWORD)&ReturnType;
        }

        if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSION))
        {
            //
            // The caller wants OSVersion
            //
            OSVERSIONINFOW osw = {0};

            ReturnValue = GetPrinterDataW(hPrinter,
                                          pUnicodeValueName,
                                          pType,
                                          (PBYTE)&osw,
                                          nSize >= sizeof(OSVERSIONINFOA) ? sizeof(osw) : nSize,
                                          pcbNeeded);

            if (ReturnValue == ERROR_SUCCESS && pData)
            {
                OSVERSIONWRAP wrap = {0};

                wrap.bOsVersionEx       = FALSE;
                wrap.Unicode.pOsVersion = &osw;
                wrap.Ansi.pOsVersion    = (OSVERSIONINFOA *)pData;

                ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
            }

            //
            // Set correct number of bytes required/returned
            //
            if (pcbNeeded)
            {
                *pcbNeeded = sizeof(OSVERSIONINFOA);
            }
        }
        else if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSIONEX))
        {
            //
            // The caller wants OSVersionEx
            //
            OSVERSIONINFOEXW osexw = {0};

            ReturnValue = GetPrinterDataW(hPrinter,
                                          pUnicodeValueName,
                                          pType,
                                          (PBYTE)&osexw,
                                          nSize >= sizeof(OSVERSIONINFOEXA) ? sizeof(osexw) : nSize,
                                          pcbNeeded);

            if (ReturnValue == ERROR_SUCCESS && pData)
            {
                OSVERSIONWRAP wrap = {0};

                wrap.bOsVersionEx         = TRUE;
                wrap.Unicode.pOsVersionEx = &osexw;
                wrap.Ansi.pOsVersionEx    = (OSVERSIONINFOEXA *)pData;

                ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
            }

            //
            // Set correct number of bytes required/returned
            //
            if (pcbNeeded)
            {
                *pcbNeeded = sizeof(OSVERSIONINFOEXA);
            }
        }
        else
        {
            ReturnValue  = GetPrinterDataW(hPrinter, pUnicodeValueName, pType, pData, nSize, pcbNeeded);

            //
            // Special case string values
            //
            if ((ReturnValue == ERROR_MORE_DATA || ReturnValue == ERROR_SUCCESS) &&
                (*pType == REG_MULTI_SZ || *pType == REG_SZ || *pType == REG_EXPAND_SZ))
            {
                if (ReturnValue==ERROR_SUCCESS)
                {
                    //
                    // The buffer passed in by the caller was large enough. We only need to
                    // convert from UNICODE to ANSI. It can happen that a UNICODE char will
                    // be represented on 3 ansi chars, so we cannot assume that if a buffer
                    // is large enough for a unicode string, it can also accomodate the converted
                    // ansi string.
                    //
                    ReturnValue = UnicodeToAnsi(NULL,
                                                0,
                                                pData,
                                                *pcbNeeded,
                                                pcbNeeded);
                }
                else
                {
                    BYTE *pBuf = NULL;

                    if (pBuf = LocalAlloc(LPTR, *pcbNeeded))
                    {
                        if ((ReturnValue = GetPrinterDataW(hPrinter,
                                                           pUnicodeValueName,
                                                           pType,
                                                           pBuf,
                                                           *pcbNeeded,
                                                           pcbNeeded)) == ERROR_SUCCESS)
                        {
                            ReturnValue = UnicodeToAnsi(pBuf,
                                                        *pcbNeeded / sizeof(WCHAR),
                                                        pData,
                                                        nSize,
                                                        pcbNeeded);
                        }

                        LocalFree(pBuf);
                    }
                    else
                    {
                        ReturnValue = GetLastError();
                    }
                }
            }
        }
    }

    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}

DWORD
GetPrinterDataExA(
   HANDLE   hPrinter,
   LPCSTR   pKeyName,
   LPCSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue       = ERROR_SUCCESS;
    DWORD   ReturnType        = 0;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeKeyName   = NULL;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    if (!pType) {
        pType = (PDWORD) &ReturnType;
    }

    if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSION))
    {
        //
        // The caller wants OSVersion
        //
        OSVERSIONINFOW osw = {0};

        ReturnValue = GetPrinterDataExW(hPrinter,
                                        (LPCWSTR)pUnicodeKeyName,
                                        (LPCWSTR)pUnicodeValueName,
                                        pType,
                                        (PBYTE)&osw,
                                        nSize >= sizeof(OSVERSIONINFOA) ? sizeof(osw) : nSize,
                                        pcbNeeded);

        if (ReturnValue == ERROR_SUCCESS && pData)
        {
            OSVERSIONWRAP wrap = {0};

            wrap.bOsVersionEx       = FALSE;
            wrap.Unicode.pOsVersion = &osw;
            wrap.Ansi.pOsVersion    = (OSVERSIONINFOA *)pData;

            ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
        }

        //
        // Set correct number of bytes required/returned
        //
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(OSVERSIONINFOA);
        }
    }
    else if (pUnicodeValueName && !_wcsicmp(pUnicodeValueName, SPLREG_OS_VERSIONEX))
    {
        //
        // The caller wants OSVersionEx
        //
        OSVERSIONINFOEXW osexw = {0};

        ReturnValue = GetPrinterDataExW(hPrinter,
                                        (LPCWSTR)pUnicodeKeyName,
                                        (LPCWSTR)pUnicodeValueName,
                                        pType,
                                        (PBYTE)&osexw,
                                        nSize >= sizeof(OSVERSIONINFOEXA) ? sizeof(osexw) : nSize,
                                        pcbNeeded);

        if (ReturnValue == ERROR_SUCCESS && pData)
        {
            OSVERSIONWRAP wrap = {0};

            wrap.bOsVersionEx         = TRUE;
            wrap.Unicode.pOsVersionEx = &osexw;
            wrap.Ansi.pOsVersionEx    = (OSVERSIONINFOEXA *)pData;

            ReturnValue = CopyOsVersionUnicodeToAnsi(wrap);
        }

        //
        // Set correct number of bytes required/returned
        //
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(OSVERSIONINFOEXA);
        }
    }
    else
    {
        ReturnValue  = GetPrinterDataExW(hPrinter,
                                         (LPCWSTR)pUnicodeKeyName,
                                         (LPCWSTR)pUnicodeValueName,
                                         pType,
                                         pData,
                                         nSize,
                                         pcbNeeded);

        //
        // Special case string values
        //
        if ((ReturnValue == ERROR_MORE_DATA || ReturnValue == ERROR_SUCCESS) &&
            (*pType == REG_MULTI_SZ || *pType == REG_SZ || *pType == REG_EXPAND_SZ))
        {
            if (ReturnValue==ERROR_SUCCESS)
            {
                //
                // The buffer passed in by the caller was large enough. We only need to
                // convert from UNICODE to ANSI. It can happen that a UNICODE char will
                // be represented on 3 ansi chars, so we cannot assume that if a buffer
                // is large enough for a unicode string, it can also accomodate the converted
                // ansi string.
                //
                ReturnValue = UnicodeToAnsi(NULL,
                                            0,
                                            pData,
                                            *pcbNeeded,
                                            pcbNeeded);
            }
            else
            {
                BYTE *pBuf = NULL;

                if (pBuf = LocalAlloc(LPTR, *pcbNeeded))
                {
                    if ((ReturnValue = GetPrinterDataExW(hPrinter,
                                                         (LPCWSTR)pUnicodeKeyName,
                                                         (LPCWSTR)pUnicodeValueName,
                                                         pType,
                                                         pBuf,
                                                         *pcbNeeded,
                                                         pcbNeeded)) == ERROR_SUCCESS)
                    {
                        ReturnValue = UnicodeToAnsi(pBuf,
                                                    *pcbNeeded / sizeof(WCHAR),
                                                    pData,
                                                    nSize,
                                                    pcbNeeded);
                    }

                    LocalFree(pBuf);
                }
                else
                {
                    ReturnValue = GetLastError();
                }
            }
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeKeyName);
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
EnumPrinterDataA(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPSTR   pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of pValueName
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of pData
    LPDWORD pcbData         // address for size of data buffer
)
{
    DWORD   ReturnValue = 0;
    DWORD   i;


    ReturnValue =  EnumPrinterDataW(hPrinter,
                                    dwIndex,
                                    (LPWSTR) pValueName,
                                    cbValueName,
                                    pcbValueName,
                                    pType,
                                    pData,
                                    cbData,
                                    pcbData);

    if (ReturnValue == ERROR_SUCCESS && (cbValueName || cbData))
    {
        if (pData && pType &&
            (*pType==REG_SZ ||
             *pType==REG_MULTI_SZ ||
             *pType==REG_EXPAND_SZ))
        {
            //
            // For this API we will require a buffer size that can accomodate UNICODE strings
            // We do not want UnicodeToAnsi to update the number of bytes needed to store
            // the string converted to ansi.
            //
            UnicodeToAnsi(NULL, 0, pData, *pcbData, NULL);
        }

        UnicodeToAnsiString((LPWSTR) pValueName, (LPSTR) pValueName, NULL_TERMINATED);
    }

    return ReturnValue;
}

DWORD
EnumPrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    DWORD   ReturnValue = 0;
    DWORD   i;
    PPRINTER_ENUM_VALUES pEnumValue;
    LPWSTR  pUnicodeKeyName = NULL;


    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;


    ReturnValue =  EnumPrinterDataExW(hPrinter,
                                      (LPCWSTR) pUnicodeKeyName,
                                      pEnumValues,
                                      cbEnumValues,
                                      pcbEnumValues,
                                      pnEnumValues);

    if (ReturnValue == ERROR_SUCCESS) {

        pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;

        for(i = 0 ; i < *pnEnumValues ; ++i, ++pEnumValue) {

            if (pEnumValue->cbValueName) {
                UnicodeToAnsiString((LPWSTR) pEnumValue->pValueName,
                                    (LPSTR) pEnumValue->pValueName,
                                    NULL_TERMINATED);
            }

            if (pEnumValue->pData &&
                (pEnumValue->dwType == REG_SZ ||
                 pEnumValue->dwType == REG_MULTI_SZ ||
                 pEnumValue->dwType == REG_EXPAND_SZ)) {

                //
                // For this API we will require a buffer size that can accomodate UNICODE strings
                // We do not want UnicodeToAnsi to update the number of bytes needed to store
                // the string converted to ansi.
                //
                UnicodeToAnsi(NULL,
                              0,
                              pEnumValue->pData,
                              pEnumValue->cbData,
                              NULL);
            }
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
EnumPrinterKeyA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPSTR   pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of pValueName
    LPDWORD pcbSubkey       // address for size of value buffer
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;


    ReturnValue =  EnumPrinterKeyW( hPrinter,
                                    (LPCWSTR) pUnicodeKeyName,
                                    (LPWSTR) pSubkey,
                                    cbSubkey,
                                    pcbSubkey);

    if (ReturnValue == ERROR_SUCCESS && cbSubkey)
    {
        ReturnValue = UnicodeToAnsi(NULL,
                                    0,
                                    pSubkey,
                                    *pcbSubkey,
                                    pcbSubkey);
    }
    else if (ReturnValue == ERROR_MORE_DATA)
    {
        BYTE *pBuf = NULL;

        if (pBuf = LocalAlloc(LPTR, *pcbSubkey))
        {
            if ((ReturnValue = EnumPrinterKeyW(hPrinter,
                                               (LPCWSTR)pUnicodeKeyName,
                                               (LPWSTR)pBuf,
                                               *pcbSubkey,
                                               pcbSubkey)) == ERROR_SUCCESS)
            {
                ReturnValue = UnicodeToAnsi(pBuf,
                                            *pcbSubkey / sizeof(WCHAR),
                                            pSubkey,
                                            cbSubkey,
                                            pcbSubkey);
            }

            LocalFree(pBuf);
        }
        else
        {
            ReturnValue = GetLastError();
        }
    }

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
DeletePrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeValueName = AllocateUnicodeString(pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;


    ReturnValue =  DeletePrinterDataW(hPrinter, (LPWSTR) pUnicodeValueName);

Cleanup:
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
DeletePrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPCSTR  pValueName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;
    LPWSTR  pUnicodeValueName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    ReturnValue =  DeletePrinterDataExW(hPrinter, (LPCWSTR) pUnicodeKeyName, (LPCWSTR) pUnicodeValueName);

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
DeletePrinterKeyA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    ReturnValue =  DeletePrinterKeyW(hPrinter, (LPCWSTR) pUnicodeKeyName);

Cleanup:
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}


DWORD
SetPrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeData = NULL;
    DWORD   cbDataString;
    DWORD   i;

    pUnicodeValueName = AllocateUnicodeString(pValueName);

    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    if (Type == REG_SZ || Type == REG_EXPAND_SZ || Type == REG_MULTI_SZ)
    {
        //
        // No matter if reg_sz or multi_sz, we want to mimic the registry APIs
        // in behavior. This means we will not check strings for null termination.
        // We will set as many bytes as specified by cbData
        //
        pUnicodeData = AllocateUnicodeStringWithSize(pData, cbData);

        if (pUnicodeData)
        {
            cbData *= sizeof(WCHAR);
            ReturnValue = SetPrinterDataW(hPrinter, pUnicodeValueName, Type, (LPBYTE) pUnicodeData, cbData);
            FreeUnicodeString(pUnicodeData);
        }
        else
        {
            ReturnValue = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        ReturnValue = SetPrinterDataW(hPrinter, pUnicodeValueName, Type, pData, cbData);
    }

Cleanup:
    FreeUnicodeString(pUnicodeValueName);

    return ReturnValue;
}


DWORD
SetPrinterDataExA(
    HANDLE  hPrinter,
    LPCSTR  pKeyName,
    LPCSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    LPWSTR  pUnicodeKeyName = NULL;
    LPWSTR  pUnicodeValueName = NULL;
    LPWSTR  pUnicodeData = NULL;
    DWORD   cbDataString;
    DWORD   i;

    pUnicodeKeyName = AllocateUnicodeString((LPSTR) pKeyName);
    if (pKeyName && !pUnicodeKeyName)
        goto Cleanup;

    pUnicodeValueName = AllocateUnicodeString((LPSTR) pValueName);
    if (pValueName && !pUnicodeValueName)
        goto Cleanup;

    if (Type == REG_SZ || Type == REG_EXPAND_SZ || Type == REG_MULTI_SZ)
    {
        //
        // No matter if reg_sz or multi_sz, we want to mimic the registry APIs
        // in behavior. This means we will not check strings for null termination.
        // We will set as many bytes as specified by cbData
        //
        pUnicodeData = AllocateUnicodeStringWithSize(pData, cbData);

        if (pUnicodeData)
        {
            cbData *= sizeof(WCHAR);
            ReturnValue = SetPrinterDataExW(hPrinter,
                                            (LPCWSTR) pUnicodeKeyName,
                                            (LPCWSTR) pUnicodeValueName,
                                            Type,
                                            (LPBYTE) pUnicodeData,
                                            cbData);
            FreeUnicodeString(pUnicodeData);
        }
        else
        {
            ReturnValue = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        ReturnValue = SetPrinterDataExW(hPrinter,
                                        (LPCWSTR) pUnicodeKeyName,
                                        (LPCWSTR) pUnicodeValueName,
                                        Type,
                                        pData,
                                        cbData);
    }

Cleanup:
    FreeUnicodeString(pUnicodeValueName);
    FreeUnicodeString(pUnicodeKeyName);

    return ReturnValue;
}



/**************************** Function Header *******************************
 * DocumentPropertiesA
 *      The ANSI version of the DocumentProperties function.  Basically
 *      converts the input parameters to UNICODE versions and calls
 *      the DocumentPropertiesW function.
 *
 * CAVEATS:  PRESUMES THAT IF pDevModeOutput IS SUPPLIED,  IT HAS THE SIZE
 *      OF THE UNICODE VERSION.  THIS WILL USUALLY HAPPEN IF THE CALLER
 *      FIRST CALLS TO FIND THE SIZE REQUIRED>
 *
 * RETURNS:
 *      Somesort of LONG.
 *
 * HISTORY:
 *  10:12 on 11-Aug-92   -by-   Lindsay Harris  [lindsayh]
 *      Changed to call DocumentPropertiesW
 *
 * Created by DaveSn
 *
 ****************************************************************************/

LONG
DocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput,
    DWORD   fMode
)
{
    LPWSTR  pUnicodeDeviceName = NULL;
    LPDEVMODEW pUnicodeDevModeInput = NULL;
    LPDEVMODEW pUnicodeDevModeOutput = NULL;
    LONG    ReturnValue = -1;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        goto Cleanup;

    ReturnValue = DocumentPropertiesW(hWnd, hPrinter, pUnicodeDeviceName,
                                      NULL, NULL, 0);

    if (ReturnValue > 0) {

        if (fMode) {

            if (pUnicodeDevModeOutput = LocalAlloc(LMEM_FIXED, ReturnValue)) {

                //
                // Only convert the input buffer if one is specified
                // and fMode indicates it's valid.  WinNT 3.51 used
                // pDevModeInput regardless of DM_IN_BUFFER, but this
                // broke Borland Delphi for win95 + Corel Flow for win95.
                //
                if( pDevModeInput && ( fMode & DM_IN_BUFFER )){

                    //
                    // If the devmode is invalid, then don't pass one in.
                    // This fixes MS Imager32 (which passes dmSize == 0) and
                    // Milestones etc. 4.5.
                    //
                    // Note: this assumes that pDevModeOutput is still the
                    // correct size!
                    //
                    if( !bValidDevModeA( pDevModeInput )){

                        fMode &= ~DM_IN_BUFFER;

                    } else {

                        pUnicodeDevModeInput = AllocateUnicodeDevMode(
                                                   pDevModeInput );

                        if( !pUnicodeDevModeInput ){
                            ReturnValue = -1;
                            goto Cleanup;
                        }
                    }
                }

                ReturnValue = DocumentPropertiesW(hWnd, hPrinter,
                                                  pUnicodeDeviceName,
                                                  pUnicodeDevModeOutput,
                                                  pUnicodeDevModeInput, fMode );

                //
                // The printer driver has filled in the DEVMODEW
                // structure - if one was passed in.  Now convert it
                // back to a DEVMODEA structure.
                //
                if (pDevModeOutput && (ReturnValue == IDOK)) {
                    CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput,
                                                      pUnicodeDevModeOutput);
                }

            } else

                ReturnValue = -1;

        } else

            ReturnValue-=sizeof(DEVMODEW)-sizeof(DEVMODEA);
    }

Cleanup:

    if (pUnicodeDevModeInput)
        LocalFree(pUnicodeDevModeInput);

    if (pUnicodeDevModeOutput)
        LocalFree(pUnicodeDevModeOutput);

    FreeUnicodeString(pUnicodeDeviceName);

    return ReturnValue;
}

BOOL
WriteCurDevModeToRegistry(
    LPWSTR      pPrinterName,
    LPDEVMODEW  pDevMode
    )
{
    DWORD Status;
    HKEY hDevMode;

    SPLASSERT(pDevMode);

    Status = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szCurDevMode,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hDevMode,
                            NULL);

    if ( Status == ERROR_SUCCESS ) {

        Status = RegSetValueExW(hDevMode,
                                pPrinterName,
                                0,
                                REG_BINARY,
                                (LPBYTE)pDevMode,
                                pDevMode->dmSize + pDevMode->dmDriverExtra);

        RegCloseKey(hDevMode);
    }

    return Status == ERROR_SUCCESS;
}

BOOL
DeleteCurDevModeFromRegistry(
    PWSTR pPrinterName
)
{
    DWORD Status;
    HKEY hDevModeKey;

    Status = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szCurDevMode,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hDevModeKey,
                            NULL);

    if ( Status == ERROR_SUCCESS ) {
        Status = RegDeleteValue(hDevModeKey, pPrinterName);
        RegCloseKey(hDevModeKey);
    }

    return Status == ERROR_SUCCESS;
}


// MLAWRENC - This code now checks to see that the DEVMODE in the registry matches that of
// the driver. If it does not, then 1. The driver has been migrated. 2. The user has been
// using an incompatible driver. In this case, the per user DEVMODE settings are overwritten
// with those obtained from the driver.

LPDEVMODEW
AllocateCurDevMode(
    HANDLE  hPrinter,
    LPWSTR  pDeviceName,
    LONG cbDevMode
    )
{
    LPDEVMODEW  pRegDevMode  = NULL;
    LPDEVMODEW  pRealDevMode = NULL;
    LPDEVMODEW  pRetDevMode  = NULL;
    BOOL        bUpdateReg   = FALSE;
    HANDLE      hKeyDevMode  = INVALID_HANDLE_VALUE;
    DWORD       dwStatus, dwType;
    LONG        lDocStatus;

    dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER,
                               szCurDevMode,
                               0,
                               NULL,
                               0,
                               KEY_READ,
                               NULL,
                               &hKeyDevMode,
                               NULL);

    if( dwStatus != ERROR_SUCCESS )
        goto Cleanup;

    pRegDevMode  = (PDEVMODEW)LocalAlloc(LMEM_FIXED, cbDevMode);
    pRealDevMode = (PDEVMODEW)LocalAlloc(LMEM_FIXED, cbDevMode);
    // This cbDevMode is obtained via a call to DocumentPropertiesW, thus it is
    // correct (unless race condition).

    if( pRegDevMode == NULL || pRealDevMode == NULL)
        goto Cleanup;

    lDocStatus = DocumentPropertiesW( NULL,
                                      hPrinter,
                                      pDeviceName,
                                      pRealDevMode,
                                      NULL,
                                      DM_COPY );

    dwStatus = RegQueryValueExW(hKeyDevMode,
                                pDeviceName,
                                0,
                                &dwType,
                                (LPBYTE)pRegDevMode,
                                &cbDevMode);

    bUpdateReg = (dwStatus != ERROR_SUCCESS || dwType != REG_BINARY)
                        && lDocStatus == IDOK;

    if (dwStatus == ERROR_SUCCESS && lDocStatus == IDOK && !bUpdateReg) {
        // Check to see that our DEVMODE structures are compatible
        bUpdateReg = pRealDevMode->dmSize          != pRegDevMode->dmSize        ||
                     pRealDevMode->dmDriverExtra   != pRegDevMode->dmDriverExtra ||
                     pRealDevMode->dmSpecVersion   != pRegDevMode->dmSpecVersion ||
                     pRealDevMode->dmDriverVersion != pRegDevMode->dmDriverVersion;

        if (!bUpdateReg)
            pRetDevMode = pRegDevMode;
    }

    if (bUpdateReg) {
        // The Registry is out of date, The read from the Document properties must have
        // succeded

        if (!WriteCurDevModeToRegistry(pDeviceName, pRealDevMode) )
            goto Cleanup;
        else
            pRetDevMode = pRealDevMode;
    }

Cleanup:
    if (pRegDevMode != pRetDevMode && pRegDevMode != NULL)
        LocalFree(pRegDevMode);

    if (pRealDevMode != pRetDevMode && pRealDevMode != NULL)
        LocalFree(pRealDevMode);

    if (hKeyDevMode != INVALID_HANDLE_VALUE)
        RegCloseKey( hKeyDevMode );

    return pRetDevMode;
}


VOID
MergeDevMode(
    LPDEVMODEW  pDMOut,
    LPDEVMODEW  pDMIn
    )
{

    //
    //    Simply check each bit in the dmFields entry.  If set, then copy
    //  the input data to the output data.
    //

    if ( pDMIn->dmFields & DM_ORIENTATION ) {

        pDMOut->dmOrientation = pDMIn->dmOrientation;
        pDMOut->dmFields |= DM_ORIENTATION;
    }

    if( (pDMIn->dmFields & (DM_FORMNAME | DM_PAPERSIZE)) ||
        (pDMIn->dmFields & (DM_PAPERLENGTH | DM_PAPERWIDTH)) ==
                              (DM_PAPERLENGTH | DM_PAPERWIDTH) )
    {
        /*   Value user fields,  so use them.  And delete ALL ours! */
        pDMOut->dmFields &= ~(DM_FORMNAME | DM_PAPERSIZE | DM_PAPERLENGTH | DM_PAPERWIDTH);

        if( pDMIn->dmFields & DM_PAPERSIZE )
        {
            pDMOut->dmPaperSize = pDMIn->dmPaperSize;
            pDMOut->dmFields |= DM_PAPERSIZE;
        }

        if( pDMIn->dmFields & DM_PAPERLENGTH )
        {
            pDMOut->dmPaperLength = pDMIn->dmPaperLength;
            pDMOut->dmFields |= DM_PAPERLENGTH;
        }

        if( pDMIn->dmFields & DM_PAPERWIDTH )
        {
            pDMOut->dmPaperWidth = pDMIn->dmPaperWidth;
            pDMOut->dmFields |= DM_PAPERWIDTH;
        }

        if( pDMIn->dmFields & DM_FORMNAME )
        {
            CopyMemory( pDMOut->dmFormName, pDMIn->dmFormName,
                                          sizeof( pDMOut->dmFormName ) );
            pDMOut->dmFields |= DM_FORMNAME;
        }

    }

    if( pDMIn->dmFields & DM_SCALE ) {

        pDMOut->dmScale = pDMIn->dmScale;
        pDMOut->dmFields |= DM_SCALE;
    }

    if ( pDMIn->dmFields & DM_COPIES ) {

        pDMOut->dmCopies = pDMIn->dmCopies;
        pDMOut->dmFields |= DM_COPIES;
    }

    if ( pDMIn->dmFields & DM_DEFAULTSOURCE ) {

        pDMOut->dmDefaultSource = pDMIn->dmDefaultSource;
        pDMOut->dmFields |= DM_DEFAULTSOURCE;
    }

    if ( pDMIn->dmFields & DM_PRINTQUALITY ) {

        pDMOut->dmPrintQuality = pDMIn->dmPrintQuality;
        pDMOut->dmFields |= DM_PRINTQUALITY;
    }

    if ( pDMIn->dmFields & DM_COLOR ) {

        pDMOut->dmColor = pDMIn->dmColor;
        pDMOut->dmFields |= DM_COLOR;
    }

    if ( pDMIn->dmFields & DM_DUPLEX ) {

        pDMOut->dmDuplex = pDMIn->dmDuplex;
        pDMOut->dmFields |= DM_DUPLEX;
    }

    if ( pDMIn->dmFields & DM_YRESOLUTION ) {

        /*
         *   Note that DM_YRESOLUTION implies there is data in dmPrintQuality.
         *  This latter field is used to specify the desired X resolution,
         *  which is only required for dot matrix printers.
         */
        pDMOut->dmYResolution = pDMIn->dmYResolution;
        pDMOut->dmPrintQuality = pDMIn->dmPrintQuality;
        pDMOut->dmFields |= DM_YRESOLUTION;
    }

    if ( pDMIn->dmFields & DM_TTOPTION ) {

        pDMOut->dmTTOption = pDMIn->dmTTOption;
        pDMOut->dmFields |= DM_TTOPTION;
    }

    if ( pDMIn->dmFields & DM_COLLATE ) {

         pDMOut->dmCollate = pDMIn->dmCollate;
         pDMOut->dmFields |= DM_COLLATE;
    }

    if ( pDMIn->dmFields & DM_ICMMETHOD ) {

        pDMOut->dmICMMethod = pDMIn->dmICMMethod;
        pDMOut->dmFields   |= DM_ICMMETHOD;
    }

    if ( pDMIn->dmFields & DM_ICMINTENT ) {

        pDMOut->dmICMIntent = pDMIn->dmICMIntent;
        pDMOut->dmFields   |= DM_ICMINTENT;
    }

    if ( pDMIn->dmFields & DM_MEDIATYPE ) {

        pDMOut->dmMediaType = pDMIn->dmMediaType;
        pDMOut->dmFields   |= DM_MEDIATYPE;
    }

    if ( pDMIn->dmFields & DM_DITHERTYPE ) {

        pDMOut->dmDitherType = pDMIn->dmDitherType;
        pDMOut->dmFields   |= DM_DITHERTYPE;
    }

}


LONG
ExtDeviceMode(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeOutput,
    LPSTR       pDeviceName,
    LPSTR       pPort,
    LPDEVMODEA  pDevModeInput,
    LPSTR       pProfile,
    DWORD       fMode
   )
{
    HANDLE  hPrinter = NULL;
    LONG    cbDevMode;
    DWORD   NewfMode;
    LPDEVMODEW pNewDevModeIn = NULL;
    LPDEVMODEW pNewDevModeOut = NULL, pTempDevMode = NULL;
    LONG    ReturnValue = -1;
    PRINTER_DEFAULTSW   PrinterDefaults={NULL, NULL, PRINTER_READ};
    LPWSTR  pUnicodeDeviceName;
    LPWSTR  pUnicodePort;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        return ReturnValue;

    pUnicodePort = AllocateUnicodeString(pPort);
    if (pPort && !pUnicodePort) {
        FreeUnicodeString(pUnicodeDeviceName);
        return ReturnValue;
    }

    if (OpenPrinterW(pUnicodeDeviceName, &hPrinter, &PrinterDefaults)) {

        cbDevMode = DocumentPropertiesW(hWnd, hPrinter, pUnicodeDeviceName,
                                        NULL, NULL, 0);

        if (!fMode || cbDevMode <= 0) {
            ClosePrinter(hPrinter);
            FreeUnicodeString(pUnicodeDeviceName);
            FreeUnicodeString(pUnicodePort);
            if (!fMode)
                cbDevMode -= sizeof(DEVMODEW) - sizeof(DEVMODEA);
            return cbDevMode;
        }

        pNewDevModeOut = (PDEVMODEW)LocalAlloc( LMEM_FIXED, cbDevMode );

        if( !pNewDevModeOut ){

            ClosePrinter(hPrinter);
            FreeUnicodeString(pUnicodeDeviceName);
            FreeUnicodeString(pUnicodePort);

            return -1;
        }

        //
        // If our flags specify an input DevMode, and we have
        // an input devmode, use it.
        //
        if(( fMode & DM_IN_BUFFER ) && pDevModeInput ){

            //
            // App may specify one or two fields in dmFields and expect us
            // to merge it with the global 16-bit devmode
            //
            pNewDevModeIn = AllocateCurDevMode(hPrinter,
                                               pUnicodeDeviceName,
                                               cbDevMode);

            pTempDevMode = AllocateUnicodeDevMode(pDevModeInput);

            //
            // correct any bogus field settings for the papersize stuff
            //
            ValidatePaperFields(pUnicodeDeviceName,
                                pUnicodePort,
                                pTempDevMode);

            if ( !pNewDevModeIn || !pTempDevMode ) {

                if ( pNewDevModeIn )
                    LocalFree(pNewDevModeIn);

                if ( pTempDevMode )
                    LocalFree(pTempDevMode);

                ClosePrinter(hPrinter);
                FreeUnicodeString(pUnicodeDeviceName);
                FreeUnicodeString(pUnicodePort);
                return -1;
            }

            //
            // Some apps will just set the public fields they want to be changed
            // from global devmode, so we need to merge input devmode with global
            // devmode
            //
            MergeDevMode(pNewDevModeIn, pTempDevMode);

            //
            // Copy input devmode's private section if present else send the
            // the private section from global devmode
            //
            if ( pTempDevMode->dmDriverExtra &&
                 pTempDevMode->dmDriverExtra == pNewDevModeIn->dmDriverExtra ) {

                    CopyMemory((LPBYTE)pNewDevModeIn + pNewDevModeIn->dmSize,
                               (LPBYTE)pTempDevMode + pTempDevMode->dmSize,
                               pTempDevMode->dmDriverExtra);
            }

            LocalFree(pTempDevMode);
            pTempDevMode = NULL;
        } else {

            //
            // Get the win16 global devmode.
            //
            pNewDevModeIn = AllocateCurDevMode( hPrinter,
                                                pUnicodeDeviceName,
                                                cbDevMode );

            if (!pNewDevModeIn) {
                ClosePrinter(hPrinter);
                FreeUnicodeString(pUnicodeDeviceName);
                FreeUnicodeString(pUnicodePort);
                return -1;
            }
            fMode |= DM_IN_BUFFER;
        }

        NewfMode = fMode;

        //
        // If DM_UPDATE is set, turn on DM_COPY so that we can update
        // the win16 devmode.
        //
        if (fMode & DM_UPDATE)
            NewfMode |= DM_COPY;

        ReturnValue = DocumentPropertiesW(hWnd,
                                          hPrinter,
                                          pUnicodeDeviceName,
                                          pNewDevModeOut,
                                          pNewDevModeIn,
                                          NewfMode);

        if ( ReturnValue == IDOK &&
             (fMode & DM_UPDATE) ) {

            if ( WriteCurDevModeToRegistry(pUnicodeDeviceName,
                                           pNewDevModeOut) ) {


                SendNotifyMessageW(HWND_BROADCAST,
                                   WM_DEVMODECHANGE,
                                   0,
                                   (LPARAM)pUnicodeDeviceName);
            } else {

                ReturnValue = -1;
            }
        }

        if (pNewDevModeIn)
            LocalFree(pNewDevModeIn);

        if ((ReturnValue == IDOK) && (fMode & DM_COPY) && pDevModeOutput)
            CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput, pNewDevModeOut);

        if (pNewDevModeOut)
            LocalFree(pNewDevModeOut);

        ClosePrinter(hPrinter);
    }

    FreeUnicodeString(pUnicodeDeviceName);
    FreeUnicodeString(pUnicodePort);

    return ReturnValue;
}

void
DeviceMode(
    HWND    hWnd,
    HANDLE  hModule,
    LPSTR   pDevice,
    LPSTR   pPort
)
{
    HANDLE  hPrinter, hDevMode;
    DWORD   cbDevMode;
    LPDEVMODEW   pNewDevMode, pDevMode=NULL;
    PRINTER_DEFAULTSW PrinterDefaults={NULL, NULL, PRINTER_READ};
    DWORD   Status, Type, cb;
    LPWSTR  pUnicodeDevice;

    pUnicodeDevice = AllocateUnicodeString(pDevice);
    if (pDevice && !pUnicodeDevice)
        return;

    if (OpenPrinterW(pUnicodeDevice, &hPrinter, &PrinterDefaults)) {

        Status = RegCreateKeyExW(HKEY_CURRENT_USER, szCurDevMode,
                                 0, NULL, 0, KEY_WRITE | KEY_READ,
                                 NULL, &hDevMode, NULL);

        if (Status == ERROR_SUCCESS) {

            Status = RegQueryValueExW(hDevMode, pUnicodeDevice, 0, &Type,
                                      NULL, &cb);

            if (Status == ERROR_SUCCESS) {

                pDevMode = LocalAlloc(LMEM_FIXED, cb);

                if (pDevMode) {

                    Status = RegQueryValueExW(hDevMode, pUnicodeDevice, 0,
                                              &Type, (LPBYTE)pDevMode, &cb);

                    if (Status != ERROR_SUCCESS) {
                        LocalFree(pDevMode);
                        pDevMode = NULL;
                    }
                } else {
                    goto Cleanup;
                }
            }

            cbDevMode = DocumentPropertiesW(hWnd, hPrinter,
                                           pUnicodeDevice, NULL,
                                           pDevMode, 0);
            if (cbDevMode > 0) {

                if (pNewDevMode = (PDEVMODEW)LocalAlloc(LMEM_FIXED,
                                                      cbDevMode)) {

                    if (DocumentPropertiesW(hWnd,
                                            hPrinter, pUnicodeDevice,
                                            pNewDevMode,
                                            pDevMode,
                                            DM_COPY | DM_PROMPT | DM_MODIFY)
                                                        == IDOK) {

                        Status = RegSetValueExW(hDevMode,
                                               pUnicodeDevice, 0,
                                               REG_BINARY,
                                               (LPBYTE)pNewDevMode,
                                               pNewDevMode->dmSize +
                                               pNewDevMode->dmDriverExtra);

                        if (Status == ERROR_SUCCESS) {
                            // Whew, we made it, simply fall out
                        }
                    }
                    LocalFree(pNewDevMode);
                }
            }

            if (pDevMode)
                LocalFree(pDevMode);

            RegCloseKey(hDevMode);
        }

        ClosePrinter(hPrinter);
    }

Cleanup:
    FreeUnicodeString(pUnicodeDevice);

    return;
}

LONG
AdvancedDocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput
)
{
    LONG    ReturnValue = FALSE;
    LPWSTR  pUnicodeDeviceName = NULL;
    LPDEVMODEW pUnicodeDevModeInput = NULL;
    LPDEVMODEW pUnicodeDevModeOutput = NULL;

    LONG cbOutput = 0;

    pUnicodeDeviceName = AllocateUnicodeString(pDeviceName);
    if (pDeviceName && !pUnicodeDeviceName)
        goto Cleanup;

    if( bValidDevModeA( pDevModeInput )){
        pUnicodeDevModeInput = AllocateUnicodeDevMode(pDevModeInput);
        if( !pUnicodeDevModeInput ){
            goto Cleanup;
        }

        //
        // The output DevMode must be at least as big as the input
        // DevMode.
        //
        cbOutput = pDevModeInput->dmSize +
                   pDevModeInput->dmDriverExtra +
                   sizeof(DEVMODEW) - sizeof(DEVMODEA);
    }

    if( pDevModeOutput ){

        if( !cbOutput ){

            //
            // We don't know the output size of the devmode, so make
            // call DocumentPropertiesW to find out.
            //
            cbOutput = DocumentPropertiesW( hWnd,
                                            hPrinter,
                                            pUnicodeDeviceName,
                                            NULL,
                                            NULL,
                                            0 );
            if( cbOutput <= 0 ){
                goto Cleanup;
            }
        }

        pUnicodeDevModeOutput = (PDEVMODEW)LocalAlloc( LPTR, cbOutput );
        if( !pUnicodeDevModeOutput ){
            goto Cleanup;
        }
    }

    ReturnValue = AdvancedDocumentPropertiesW(hWnd, hPrinter,
                                              pUnicodeDeviceName,
                                              pUnicodeDevModeOutput,
                                              pUnicodeDevModeInput );

    if( pDevModeOutput && (ReturnValue > 0) ){
        CopyAnsiDevModeFromUnicodeDevMode(pDevModeOutput,
                                          pUnicodeDevModeOutput);
    }

    if ( !pDevModeOutput && ReturnValue > 0 )
        ReturnValue -= sizeof(DEVMODEW) - sizeof(DEVMODEA);

Cleanup:
    if (pUnicodeDevModeOutput)
        LocalFree(pUnicodeDevModeOutput);

    if (pUnicodeDevModeInput)
        LocalFree(pUnicodeDevModeInput);

    FreeUnicodeString(pUnicodeDeviceName);

    return ReturnValue;
}

LONG
AdvancedSetupDialog(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeInput,
    LPDEVMODEA  pDevModeOutput
)
{
    HANDLE  hPrinter;
    LONG    ReturnValue = -1;

    if (OpenPrinterA(pDevModeInput->dmDeviceName, &hPrinter, NULL)) {
        ReturnValue = AdvancedDocumentPropertiesA(hWnd, hPrinter,
                                                 pDevModeInput->dmDeviceName,
                                                 pDevModeOutput,
                                                 pDevModeInput);
        ClosePrinter(hPrinter);
    }

    return ReturnValue;
}

BOOL
AddFormA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    LPBYTE pUnicodeForm;

    pUnicodeForm = AllocateUnicodeStructure(pForm, sizeof(FORM_INFO_1A), FormInfo1Strings);
    if (pForm && !pUnicodeForm)
        return FALSE;

    ReturnValue = AddFormW(hPrinter, Level, pUnicodeForm);

    FreeUnicodeStructure(pUnicodeForm, FormInfo1Offsets);

    return ReturnValue;
}

BOOL
DeleteFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName
)
{
    BOOL  ReturnValue;
    LPWSTR  pUnicodeFormName;

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        return FALSE;

    ReturnValue = DeleteFormW(hPrinter, pUnicodeFormName);

    FreeUnicodeString(pUnicodeFormName);

    return ReturnValue;
}

BOOL
GetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeFormName;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        return FALSE;

    ReturnValue = GetFormW(hPrinter, pUnicodeFormName, Level, pForm,
                           cbBuf, pcbNeeded);

    if (ReturnValue && pForm)

        ConvertUnicodeToAnsiStrings(pForm, pOffsets);

    FreeUnicodeString(pUnicodeFormName);

    return ReturnValue;
}

BOOL
SetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue = FALSE;
    LPWSTR  pUnicodeFormName = NULL;
    LPBYTE  pUnicodeForm = NULL;

    pUnicodeFormName = AllocateUnicodeString(pFormName);
    if (pFormName && !pUnicodeFormName)
        goto Cleanup;

    pUnicodeForm = AllocateUnicodeStructure(pForm, sizeof(FORM_INFO_1A), FormInfo1Strings);
    if (pForm && !pUnicodeForm)
        goto Cleanup;

    ReturnValue = SetFormW(hPrinter, pUnicodeFormName, Level, pUnicodeForm);

Cleanup:

    FreeUnicodeString(pUnicodeFormName);

    FreeUnicodeStructure(pUnicodeForm, FormInfo1Offsets);

    return ReturnValue;
}

BOOL
EnumFormsA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    ReturnValue = EnumFormsW(hPrinter, Level, pForm, cbBuf,
                             pcbNeeded, pcReturned);

    if (ReturnValue && pForm) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pForm, pOffsets);

            pForm+=cbStruct;
        }

    }

    return ReturnValue;
}

BOOL
EnumPortsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;

    switch (Level) {

    case 1:
        pOffsets = PortInfo1Strings;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pOffsets = PortInfo2Strings;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    ReturnValue = EnumPortsW(pUnicodeName, Level, pPort, cbBuf,
                             pcbNeeded, pcReturned);

    if (ReturnValue && pPort) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pPort, pOffsets);

            pPort+=cbStruct;
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
EnumMonitorsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    LPWSTR  pUnicodeName = NULL;

    switch (Level) {

    case 1:
        pOffsets = MonitorInfo1Strings;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pOffsets = MonitorInfo2Strings;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    ReturnValue = EnumMonitorsW(pUnicodeName, Level, pMonitor, cbBuf,
                                          pcbNeeded, pcReturned);

    if (ReturnValue && pMonitor) {

        DWORD   i=*pcReturned;

        while (i--) {

            ConvertUnicodeToAnsiStrings(pMonitor, pOffsets);

            pMonitor+=cbStruct;
        }
    }

Cleanup:

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
AddPortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pMonitorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeMonitorName = NULL;
    DWORD   ReturnValue = FALSE;


    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeMonitorName = AllocateUnicodeString(pMonitorName);
    if (pMonitorName && !pUnicodeMonitorName)
        goto Cleanup;

    ReturnValue = AddPortW( pUnicodeName, hWnd, pUnicodeMonitorName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeMonitorName);

    return ReturnValue;
}

BOOL
ConfigurePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePortName = NULL;
    DWORD   ReturnValue = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePortName = AllocateUnicodeString(pPortName);
    if (pPortName && !pUnicodePortName)
        goto Cleanup;

    ReturnValue = ConfigurePortW( pUnicodeName, hWnd, pUnicodePortName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePortName);

    return ReturnValue;
}

BOOL
DeletePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodePortName = NULL;
    DWORD   ReturnValue = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodePortName = AllocateUnicodeString(pPortName);
    if (pPortName && !pUnicodePortName)
        goto Cleanup;

    ReturnValue = DeletePortW( pUnicodeName, hWnd, pUnicodePortName );

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodePortName);

    return ReturnValue;
}

DWORD
PrinterMessageBoxA(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPSTR   pText,
    LPSTR   pCaption,
    DWORD   dwType
)
{
    DWORD   ReturnValue=FALSE;
    LPWSTR  pTextW = NULL;
    LPWSTR  pCaptionW = NULL;

    pTextW = AllocateUnicodeString(pText);
    if (pText && !pTextW)
        goto Cleanup;

    pCaptionW = AllocateUnicodeString(pCaption);
    if (pCaption && !pCaptionW)
        goto Cleanup;

    ReturnValue = PrinterMessageBoxW(hPrinter, Error, hWnd, pTextW,
                                     pCaptionW, dwType);

Cleanup:
    FreeUnicodeString(pTextW);
    FreeUnicodeString(pCaptionW);

    return ReturnValue;
}

int
DeviceCapabilitiesA(
    LPCSTR  pDevice,
    LPCSTR  pPort,
    WORD    fwCapability,
    LPSTR   pOutput,
    CONST DEVMODEA *pDevMode
)
{
    LPWSTR  pDeviceW = NULL;
    LPWSTR  pPortW = NULL;
    LPWSTR  pOutputW = NULL;
    LPWSTR  pKeepW = NULL;
    LPDEVMODEW  pDevModeW = NULL;
    DWORD   c, Size;
    int cb = 0;
    int rc = GDI_ERROR;

    pDeviceW = AllocateUnicodeString((LPSTR)pDevice);
    if (pDevice && !pDeviceW)
        goto Cleanup;

    pPortW = AllocateUnicodeString((LPSTR)pPort);
    if (pPort && !pPortW)
        goto Cleanup;

    if( bValidDevModeA( pDevMode )){
        pDevModeW = AllocateUnicodeDevMode((LPDEVMODEA)pDevMode);
        if( !pDevModeW ){
            goto Cleanup;
        }
    }

    switch (fwCapability) {

        // These will require Unicode to Ansi conversion

    case DC_BINNAMES:
    case DC_FILEDEPENDENCIES:
    case DC_PAPERNAMES:
    case DC_PERSONALITY:
    case DC_MEDIAREADY:
    case DC_MEDIATYPENAMES:

        if (pOutput) {

            cb = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                     NULL, pDevModeW);
            if (cb >= 0) {

                switch (fwCapability) {

                case DC_BINNAMES:
                    cb *= 48;
                    break;

                case DC_PERSONALITY:
                    cb *= 64;
                    break;

                case DC_FILEDEPENDENCIES:
                case DC_PAPERNAMES:
                case DC_MEDIAREADY:
                case DC_MEDIATYPENAMES:
                    cb *= 128;
                    break;

                }

                pOutputW = pKeepW = LocalAlloc(LPTR, cb);

                if (pKeepW) {

                    c = rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                                 pOutputW, pDevModeW);

                    switch (fwCapability) {

                    case DC_BINNAMES:
                        Size = 24;
                        break;

                    case DC_PERSONALITY:
                        Size = 32;
                        break;

                    case DC_FILEDEPENDENCIES:
                    case DC_PAPERNAMES:
                    case DC_MEDIAREADY:
                    case DC_MEDIATYPENAMES:
                        Size = 64;
                        break;
                    }

                    for (; c; c--) {

                        UnicodeToAnsiString(pOutputW, pOutput, NULL_TERMINATED);

                        pOutputW += Size;
                        pOutput += Size;
                    }

                    LocalFree(pKeepW);
                }
            }

        } else {

            rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability,
                                     NULL, pDevModeW);

        }

        break;

    default:
        rc = DeviceCapabilitiesW(pDeviceW, pPortW, fwCapability, (LPWSTR)pOutput, pDevModeW);

        //
        // If the call to find size of public portion of devmode and
        // it was succesful adjust the size for UNICODE->ANSI conversion
        //
        if ( fwCapability == DC_SIZE && rc > 0 ) {

            rc -= sizeof(DEVMODEW) - sizeof(DEVMODEA);
        }
    }


Cleanup:

    FreeUnicodeString(pDeviceW);
    FreeUnicodeString(pPortW);
    if (pDevModeW)
        LocalFree(pDevModeW);

    return  rc;
}

BOOL
AddMonitorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    switch (Level) {

    case 2:
        pOffsets = MonitorInfo2Strings;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pMonitorInfo, cbStruct, pOffsets);
    if (pMonitorInfo && !pUnicodeStructure)
        goto Cleanup;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    if (pUnicodeStructure) {

        ReturnValue = AddMonitorW(pUnicodeName, Level, pUnicodeStructure);
    }

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
DeleteMonitorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pMonitorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodeMonitorName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodeMonitorName = AllocateUnicodeString(pMonitorName);
    if (pMonitorName && !pUnicodeMonitorName)
        goto Cleanup;

    rc = DeleteMonitorW(pUnicodeName,
                        pUnicodeEnvironment,
                        pUnicodeMonitorName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodeMonitorName);

    return rc;
}

BOOL
DeletePrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProcessorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePrintProcessorName = NULL;
    BOOL    rc = FALSE;

    if (!pPrintProcessorName || !*pPrintProcessorName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePrintProcessorName = AllocateUnicodeString(pPrintProcessorName);
    if (pPrintProcessorName && !pUnicodePrintProcessorName)
        goto Cleanup;

    rc = DeletePrintProcessorW(pUnicodeName,
                               pUnicodeEnvironment,
                               pUnicodePrintProcessorName);


Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodePrintProcessorName);

    return rc;
}

BOOL
AddPrintProvidorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pProvidorInfo
)
{
    BOOL    ReturnValue=FALSE;
    DWORD   cbStruct;
    LPWSTR  pUnicodeName = NULL;
    LPBYTE  pUnicodeStructure = NULL;
    LPDWORD pOffsets;

    if (!pProvidorInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pOffsets = ProvidorInfo1Strings;
        cbStruct = sizeof(PROVIDOR_INFO_1);
        break;

    case 2:
        pOffsets = ProvidorInfo2Strings;
        cbStruct = sizeof(PROVIDOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    pUnicodeStructure = AllocateUnicodeStructure(pProvidorInfo, cbStruct, pOffsets);
    if (!pProvidorInfo || !pUnicodeStructure)
        goto CleanUp;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto CleanUp;

    if ((Level == 2) &&
        !AnsiToUnicodeMultiSz((LPSTR) ((PPROVIDOR_INFO_2A) pProvidorInfo)->pOrder,
                              &(((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder))) {

        goto CleanUp;
    }

    if (pUnicodeStructure) {

        ReturnValue = AddPrintProvidorW(pUnicodeName, Level,
                                        pUnicodeStructure);
    }

    if ((Level == 2) &&
        ((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder) {

        LocalFree(((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder);
        ((PPROVIDOR_INFO_2W) pUnicodeStructure)->pOrder = NULL;
    }

CleanUp:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);

    FreeUnicodeString(pUnicodeName);

    return ReturnValue;
}

BOOL
DeletePrintProvidorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProvidorName
)
{
    LPWSTR  pUnicodeName = NULL;
    LPWSTR  pUnicodeEnvironment = NULL;
    LPWSTR  pUnicodePrintProvidorName = NULL;
    BOOL    rc = FALSE;

    pUnicodeName = AllocateUnicodeString(pName);
    if (pName && !pUnicodeName)
        goto Cleanup;

    pUnicodeEnvironment = AllocateUnicodeString(pEnvironment);
    if (pEnvironment && !pUnicodeEnvironment)
        goto Cleanup;

    pUnicodePrintProvidorName = AllocateUnicodeString(pPrintProvidorName);
    if (pPrintProvidorName && !pUnicodePrintProvidorName)
        goto Cleanup;

    rc = DeletePrintProvidorW(pUnicodeName,
                              pUnicodeEnvironment,
                              pUnicodePrintProvidorName);

Cleanup:
    FreeUnicodeString(pUnicodeName);

    FreeUnicodeString(pUnicodeEnvironment);

    FreeUnicodeString(pUnicodePrintProvidorName);

    return rc;
}


BOOL
AddPortExA(
    IN LPSTR  pName, OPTIONAL
    IN DWORD  Level,
    IN LPBYTE pBuffer,
    IN LPSTR  pMonitorName
    )
{
    PPORT_INFO_1A pPortInfo1;
    PPORT_INFO_FFA pPortInfoFF;

    LPWSTR pNameW = NULL;
    LPWSTR pMonitorNameW = NULL;
    LPWSTR pPortNameW = NULL;

    PORT_INFO_1W PortInfo1;
    PORT_INFO_FFW PortInfoFF;

    DWORD LastError = ERROR_SUCCESS;
    BOOL bReturnValue = FALSE;

    //
    // Initialize variables that will be freed in error cases.
    //
    pNameW = AllocateUnicodeString( pName);
    if (pName && !pNameW) {
        LastError = GetLastError();
        goto Done;
    }

    pPortNameW = NULL;

    pMonitorNameW = AllocateUnicodeString( pMonitorName);
    if (pMonitorName && !pMonitorNameW) {
        LastError = GetLastError();
        goto Done;
    }

    if( !pBuffer || !pMonitorName ){
        LastError = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    // Catch out of memory conditions.
    //
    if( !pMonitorNameW || ( pName && !pNameW )){
        LastError = GetLastError();
        goto Done;
    }

    switch( Level ){
    case (DWORD)-1:

        pPortInfoFF = (PPORT_INFO_FFA)pBuffer;

        if( !pPortInfoFF->pName || !pPortInfoFF->pName[0] ){
            LastError = ERROR_INVALID_PARAMETER;
            goto Done;
        }

        pPortNameW = PortInfoFF.pName = AllocateUnicodeString( pPortInfoFF->pName);

        if( !pPortNameW ){
            LastError = GetLastError();
            goto Done;
        }

        PortInfoFF.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortInfoFF.pMonitorData = pPortInfoFF->pMonitorData;

        bReturnValue = AddPortExW( pNameW,
                                   Level,
                                   (LPBYTE)&PortInfoFF,
                                   pMonitorNameW );

        if( !bReturnValue ){
            LastError = GetLastError();
        }
        break;

    case 1:

        pPortInfo1 = (PPORT_INFO_1A)pBuffer;

        if( !pPortInfo1->pName || !pPortInfo1->pName[0] ){
            LastError = ERROR_INVALID_PARAMETER;
            goto Done;
        }

        pPortNameW = PortInfo1.pName = AllocateUnicodeString( pPortInfo1->pName);

        if( !pPortNameW ){
            LastError = GetLastError();
            goto Done;
        }

        bReturnValue = AddPortExW( pNameW,
                                   Level,
                                   (LPBYTE)&PortInfo1,
                                   pMonitorNameW );

        if( !bReturnValue ){
            LastError = GetLastError();
        }
        break;

    default:
        LastError = ERROR_INVALID_LEVEL;
        break;
    }

Done:

    FreeUnicodeString( pNameW );
    FreeUnicodeString( pPortNameW );
    FreeUnicodeString( pMonitorNameW );

    if( !bReturnValue ){

        SetLastError( LastError );
        return FALSE;
    }
    return TRUE;
}



LPSTR
StartDocDlgA(
    HANDLE hPrinter,
    DOCINFOA *pDocInfo
    )
{
    DOCINFOW DocInfoW;
    LPSTR lpszAnsiOutput = NULL;
    LPSTR lpszAnsiString = NULL;
    LPWSTR lpszUnicodeString = NULL;
    DWORD  dwLen = 0;

    if (!pDocInfo) {
        DBGMSG(DBG_WARNING, ("StartDocDlgA: Null pDocInfo passed in\n"));
        return NULL;
    }
    memset(&DocInfoW, 0, sizeof(DOCINFOW));
    if (pDocInfo->lpszDocName) {
        DocInfoW.lpszDocName = (LPCWSTR)AllocateUnicodeString ((LPSTR)pDocInfo->lpszDocName);
        if (pDocInfo->lpszDocName && !DocInfoW.lpszDocName)
            return NULL;
    }
    if (pDocInfo->lpszOutput) {
        DocInfoW.lpszOutput = (LPCWSTR)AllocateUnicodeString((LPSTR)pDocInfo->lpszOutput);
        if (pDocInfo->lpszOutput && !DocInfoW.lpszOutput) {
            FreeUnicodeString((LPWSTR) DocInfoW.lpszDocName);
            return NULL;
        }
    }

    lpszUnicodeString = StartDocDlgW(hPrinter, &DocInfoW);

    if (lpszUnicodeString == (LPWSTR)-1) {
        lpszAnsiString = (LPSTR)-1;
    } else if (lpszUnicodeString == (LPWSTR)-2) {
         lpszAnsiString = (LPSTR)-2;
    } else if (lpszUnicodeString){
        dwLen = wcslen(lpszUnicodeString);
        if (lpszAnsiString = LocalAlloc(LPTR, dwLen+1)){
            UnicodeToAnsiString(lpszUnicodeString, lpszAnsiString, dwLen);
            LocalFree(lpszUnicodeString);
        } else {
            DBGMSG(DBG_WARNING, ("StartDocDlgA: LocalAlloc failed returning NULL\n"));
        }
    }

    if (DocInfoW.lpszDocName ) {
        FreeUnicodeString((LPWSTR)DocInfoW.lpszDocName);
    }

    if (DocInfoW.lpszOutput) {

        //
        // we might have changed the DocInfoW.lpszOutput as well
        // for pooled printing; so reconstruct pDocInfo->lpszOutput
        //
        dwLen = wcslen(DocInfoW.lpszOutput);
        UnicodeToAnsiString((LPWSTR)DocInfoW.lpszOutput, (LPSTR)pDocInfo->lpszOutput, dwLen);

        FreeUnicodeString((LPWSTR)DocInfoW.lpszOutput);
    }

    return lpszAnsiString;
}


BOOL
SetPortA(
    LPSTR       pszName,
    LPSTR       pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPorts
    )
{
    LPBYTE      pUnicodeStructure = NULL;
    DWORD       cbStruct;
    PDWORD      pOffsets = NULL;
    LPWSTR      pszUnicodeName = NULL;
    LPWSTR      pszUnicodePortName = NULL;
    BOOL        bRet = FALSE;


    switch (dwLevel) {

        case 3:
            pOffsets = PortInfo3Offsets;
            cbStruct = sizeof(PORT_INFO_3);
            break;

        default:
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
    }

    pszUnicodeName = AllocateUnicodeString(pszName);
    if (pszName && !pszUnicodeName)
        goto Cleanup;

    pszUnicodePortName  = AllocateUnicodeString(pszPortName);
    if (pszPortName && !pszUnicodePortName)
        goto Cleanup;

    pUnicodeStructure = AllocateUnicodeStructure(pPorts, cbStruct, pOffsets);
    if (pPorts && !pUnicodeStructure)
        goto Cleanup;

    bRet = SetPortW(pszUnicodeName, pszUnicodePortName, dwLevel, pUnicodeStructure);

Cleanup:

    FreeUnicodeStructure(pUnicodeStructure, pOffsets);
    FreeUnicodeString(pszUnicodePortName);
    FreeUnicodeString(pszUnicodeName);

    return bRet;
}

BOOL
bValidDevModeA(
    const DEVMODEA *pDevModeA
    )

/*++

Routine Description:

    Check whether a devmode is valid to be RPC'd across to the spooler.

Arguments:

    pDevMode - DevMode to check.

Return Value:

    TRUE - Devmode can be RPC'd to spooler.
    FALSE - Invalid Devmode.

--*/

{
    if( !pDevModeA ){
        return FALSE;
    }

    if( pDevModeA->dmSize < MIN_DEVMODE_SIZEA ){

        //
        // The only valid case is if pDevModeA is NULL.  If it's
        // not NULL, then a bad devmode was passed in and the
        // app should fix it's code.
        //
        SPLASSERT( pDevModeA->dmSize >= MIN_DEVMODE_SIZEA );
        return FALSE;
    }

    return TRUE;
}

/********************************************************************

    Ansi version entry points for the default printer api set.

********************************************************************/
BOOL
GetDefaultPrinterA(
    IN LPSTR    pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval             = TRUE;
    LPWSTR  pszUnicodeBuffer    = NULL;
    LPDWORD pcchUnicodeBuffer   = pcchBuffer;

    if( pszBuffer && pcchBuffer && *pcchBuffer )
    {
        pszUnicodeBuffer = LocalAlloc( LMEM_FIXED, *pcchBuffer * sizeof( WCHAR ) );

        bRetval = pszUnicodeBuffer ? TRUE : FALSE;
    }

    if( bRetval )
    {
        bRetval = GetDefaultPrinterW( pszUnicodeBuffer, pcchUnicodeBuffer );

        if( bRetval && pszUnicodeBuffer )
        {
            bRetval = UnicodeToAnsiString( pszUnicodeBuffer, pszBuffer, 0 ) > 0;
        }
    }

    if( pszUnicodeBuffer )
    {
        LocalFree( pszUnicodeBuffer );
    }

    return bRetval;
}

BOOL
SetDefaultPrinterA(
    IN LPCSTR pszPrinter
    )
{
    BOOL    bRetval     = TRUE;
    LPWSTR  pszUnicode  = NULL;

    if( pszPrinter )
    {
        pszUnicode = AllocateUnicodeString( (PSTR) pszPrinter );

        bRetval = pszUnicode ? TRUE : FALSE;
    }

    if( bRetval )
    {
        bRetval = SetDefaultPrinterW( pszUnicode );
    }

    if( pszUnicode )
    {
        FreeUnicodeString( pszUnicode );
    }

    return bRetval;
}


BOOL
PublishPrinterA(
    HWND   hwnd,
    PCSTR  pszUNCName,
    PCSTR  pszDN,
    PCSTR  pszCN,
    PSTR   *ppszDN,
    DWORD  dwAction
)
{
    PWSTR       pszUnicodeUNCName = NULL;
    PWSTR       pszUnicodeDN = NULL;
    PWSTR       pszUnicodeCN = NULL;
    BOOL        bRet = FALSE;

    pszUnicodeUNCName = AllocateUnicodeString((PSTR) pszUNCName);
    if (pszUNCName && !pszUnicodeUNCName)
        goto error;

    pszUnicodeDN = AllocateUnicodeString((PSTR) pszDN);
    if (pszDN && !pszUnicodeDN)
        goto error;

    pszUnicodeCN = AllocateUnicodeString((PSTR) pszCN);
    if (pszCN && !pszUnicodeCN)
        goto error;

    bRet = PublishPrinterW( hwnd,
                            pszUnicodeUNCName,
                            pszUnicodeDN,
                            pszUnicodeCN,
                            (PWSTR *) ppszDN,
                            dwAction);

    if (ppszDN && *ppszDN) {
        if (!UnicodeToAnsiString((PWSTR) *ppszDN, *ppszDN, NULL_TERMINATED))
            bRet = FALSE;
    }


error:

    FreeUnicodeString(pszUnicodeUNCName);
    FreeUnicodeString(pszUnicodeDN);
    FreeUnicodeString(pszUnicodeCN);

    return bRet;
}



VOID
ValidatePaperFields(
    LPCWSTR    pUnicodeDeviceName,
    LPCWSTR    pUnicodePort,
    LPDEVMODEW pDevModeIn
)
{
    POINTS ptMinSize, ptMaxSize;


    if(!pUnicodeDeviceName    ||
       !pUnicodeDeviceName[0] ||
       !pUnicodePort          ||
       !pUnicodePort[0]       ||
       !pDevModeIn)                 {
            return;
    }

    //
    // this logic was swiped from the MergeDevMode() code for the Win3.1 UNIDRV
    //

    // According to UNIDRV, dmPaperSize must be set to DMPAPER_USER if custom
    // paper sizes are going to be taken seriously.
    if((pDevModeIn->dmPaperSize == DMPAPER_USER)   &&
       (pDevModeIn->dmFields    &  DM_PAPERWIDTH)  &&
       (pDevModeIn->dmFields    &  DM_PAPERLENGTH)) {

        pDevModeIn->dmFields |= (DM_PAPERLENGTH | DM_PAPERLENGTH);

        // get the minimum size this printer supports
        if(DeviceCapabilitiesW(pUnicodeDeviceName,
                               pUnicodePort,
                               DC_MINEXTENT,
                               (PWSTR) &ptMinSize,
                               NULL) == -1) {
            return;  // => no changes
        }

        if(DeviceCapabilitiesW(pUnicodeDeviceName,
                               pUnicodePort,
                               DC_MAXEXTENT,
                               (PWSTR) &ptMaxSize,
                               NULL) == -1) {
            return;  // => no changes
        }

        // force the custom paper size to fit the machine's capabilities
        if(pDevModeIn->dmPaperWidth < ptMinSize.x)
            pDevModeIn->dmPaperWidth = ptMinSize.x;
        else if(pDevModeIn->dmPaperWidth > ptMaxSize.x)
            pDevModeIn->dmPaperWidth = ptMaxSize.x;

        if(pDevModeIn->dmPaperLength < ptMinSize.y)
            pDevModeIn->dmPaperLength = ptMinSize.y;
        else if(pDevModeIn->dmPaperLength > ptMaxSize.y)
            pDevModeIn->dmPaperLength = ptMaxSize.y;

    }

    // else if they don't have it right, turn these guys off so they don't
    // get merged into the default devmode later.
    else {
        pDevModeIn->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH);
        pDevModeIn->dmPaperWidth  = 0;
        pDevModeIn->dmPaperLength = 0;
    }
}

DWORD
UnicodeToAnsi(
    IN     LPBYTE  pUnicode,
    IN     DWORD   cchUnicode,
    IN OUT LPBYTE  pData,
    IN     DWORD   cbData,
    IN OUT DWORD  *pcbCopied OPTIONAL
    )
/*++

Routine Name:

    UnicodeToAnsi

Routine Description:

    Converts the content of a buffer from unicode to ansi. There is no assumption about
    NULL terminator. If pUnicode is not NULL, then it must be WCHAR aligned and cchUnicode
    indicates the number of WCHARs in the buffer that will be converted to ansi. If pUnicode
    is NULL, then the function converts in place the contents of pData from Unicode to Ansi.

Arguments:

    pUnicode   - buffer aligned to WCHAR that contains a unicode string
    cchUnicode - number of WCHARs in pUnicode buffer
    pData      - buffer that will hold the converted string
    cbData     - sizeo in bytes of the buffer pDa
    pcbCopied  - number of bytes copied to pData or needed to accomodate the converted string

Return Value:

    None.

--*/
{
    DWORD cReturn  = cbData;
    DWORD cbCopied = 0;
    DWORD Error    = ERROR_INVALID_PARAMETER;

    //
    // If the size of both input buffer is 0, then we do not do anything and return success.
    // Otherwise, the caller must give us either valid pData or a valid pUnicode that is
    // WCHAR aligned
    //
    if (!cbData && !cchUnicode)
    {
        Error = ERROR_SUCCESS;
    }
    else if (pData || pUnicode && !((ULONG_PTR)pUnicode % sizeof(WCHAR)))
    {
        LPWSTR pAligned = (LPWSTR)pUnicode;

        Error = ERROR_SUCCESS;

        if (!pAligned)
        {
            //
            // We convert contents of pData from unicode to ansi
            //
            if (pAligned = LocalAlloc(LPTR, cbData))
            {
                memcpy(pAligned, pData, cbData);

                cchUnicode = cbData / sizeof(WCHAR);
            }
            else
            {
                Error = GetLastError();
            }
        }

        //
        // Convert data to ansi or find out how many bytes are
        // necessary to accomodate the string
        //
        if (Error == ERROR_SUCCESS)
        {
            cbCopied = WideCharToMultiByte(CP_THREAD_ACP,
                                           0,
                                           pAligned,
                                           cchUnicode,
                                           pData,
                                           cbData,
                                           NULL,
                                           NULL);

            //
            // WideCharToMultiByte tells us how many bytes we need
            //
            if (!cbCopied)
            {
                Error = ERROR_MORE_DATA;

                cbCopied = WideCharToMultiByte(CP_THREAD_ACP,
                                               0,
                                               pAligned,
                                               cchUnicode,
                                               pData,
                                               0,
                                               NULL,
                                               NULL);
            }
            else if (!cbData)
            {
                Error = ERROR_MORE_DATA;
            }

            if (pAligned != (LPWSTR)pUnicode)
            {
                LocalFree(pAligned);
            }
        }
    }

    if (pcbCopied)
    {
        *pcbCopied = cbCopied;
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\spoolss\client\winspool.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    Winspool.c

Abstract:

    Bulk of winspool.drv code

Author:

Environment:

    User Mode -Win32

Revision History:
    mattfe  april 14 94     added caching to writeprinter
    mattfe  jan 95          Add SetAllocFailCount api

    13-Jun-1996 Thu 15:07:16 updated  -by-  Daniel Chou (danielc)
        Make PrinterProperties call PrinterPropertySheets and
             DocumentProperties call DocumentPropertySheets

    SWilson Dec 1996 - added GetPrinterDataEx, SetPrinterDataEx, EnumPrinterDataEx,
                             EnumPrinterKey, DeletePrinterDataEx, and DeletePrinterKey

    khaleds Feb 2000 - Added DocumentPropertiesThunk,
                             AddPortWThunk,
                             CongigurePortWThunk,
                             DeleteProtWThunk,
                             DeviceCapabilitesWThunk,
                             PrinterPropertiesWThunk,
                             DocmentEvenThunk,
                             SpoolerPrinterEventThunk
                       Renamed the above native functions from xx to xxNative

   Khaleds Mar 2000 - Added SendRecvBidiData
   Khaleds Mar 2001 - Fix for WritePrinter
   LazarI - Oct-30-2000 added GetCurrentThreadLastPopup & fixed StartDocDlgW

--*/

#include "precomp.h"
#pragma hdrstop

#include "client.h"
#include "winsprlp.h"
#include "pfdlg.h"
#include "splwow64.h"
#include "drvsetup.h"

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

HANDLE           hInst = NULL;
CRITICAL_SECTION ProcessHndlCS;
HANDLE           hSurrogateProcess;
WndHndlList*     GWndHndlList=NULL;

LPWSTR szEnvironment     = LOCAL_ENVIRONMENT;
LPWSTR szIA64Environment = L"Windows IA64";

HANDLE hShell32 = INVALID_HANDLE_VALUE;

// pointer to the start of the list containing the driver file handles
PDRVLIBNODE   pStartDrvLib = NULL;

CRITICAL_SECTION  ListAccessSem;

DWORD gcClientICHandle = 0;

#define DM_MATCH( dm, sp )  (