e
                    break;
                }

                *pch = chNBSP;
                IFC( GetEditor()->InsertMaximumText( pch, 1, pLeft ) );
                IFC( pMarkupServices->Remove( pLeft, pDeletionPoint ) );
            }
            break;

        case CONTEXT_TYPE_None:
            goto Cleanup;

        }

        // Catch up to the moving pointer
        IFC( pLeft->MoveToPointer( pDeletionPoint ) );
        
    }

Cleanup:
    ReleaseInterface( pLeft );
    ReleaseInterface( pRight );
    ReleaseInterface( pDeletionPoint );
    ReleaseInterface( pPreElement );
    RRETURN ( hr );
}

BOOL    
CDeleteCommand::IsMergeNeeded( IMarkupPointer * pStart, IMarkupPointer * pEnd )
{
    SP_IMarkupPointer   spPointer;
    CEditPointer        epAdjustedStart(GetEditor());
    CEditPointer        epAdjustedEnd(GetEditor());
    BOOL                fRightOrEqual = FALSE;
    BOOL                fMerger = FALSE;
    int                 iWherePointer;
    HRESULT             hr;
    DWORD               dwBreaks;
    DWORD               dwFound;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveToPointer( pStart ) );
    IFC( OldCompare( spPointer, pEnd, & iWherePointer ) );

    switch (iWherePointer)
    {
    case LEFT:
        //
        // We should not have pEnd to the left of pStart
        // otherwise we'll go to a loopus infinitus later
        //
        Assert( iWherePointer == RIGHT );
        goto Cleanup;

    case SAME:
        goto Cleanup;

    }

    //
    // Include phrase elements on the start so we don't miss block breaks
    //
    IFC( epAdjustedStart->MoveToPointer(spPointer) );
    IFC( epAdjustedStart.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( epAdjustedStart.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( spPointer->MoveToPointer(epAdjustedStart) );
 
    //
    // Omit phrase elements so we don't pick up block break characters between them.
    // For example: {epPointer}<<Block Break>></SPAN></B>{pEnd}.  We only want to 
    // pick up block breaks that span block elements
    //
    IFC( epAdjustedEnd->MoveToPointer(pEnd) );
    IFC( epAdjustedEnd.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( epAdjustedEnd.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );

    //
    // Walk pStart towards pEnd looking for block breaks. If a block break is 
    // crossed, merge is necessary.
    //

    for ( ; ; )
    {
        IFC( spPointer->IsRightOfOrEqualTo( epAdjustedEnd, & fRightOrEqual ) );
        if ( fRightOrEqual )
        {
            // We're done, no merger here
            break;            
        }       

        IFC( QueryBreaks(spPointer, & dwBreaks) ); 
        if ( dwBreaks & DISPLAY_BREAK_Block )
        {
            // We have a merger
            fMerger = TRUE;
            break;
        }        

        IFC( spPointer->Right( TRUE , NULL, NULL, NULL, NULL ) );
    }

Cleanup:
    return fMerger;
}


HRESULT 
CDeleteCommand::MergeDeletion( IMarkupPointer * pStart, IMarkupPointer * pEnd, BOOL fAdjustPointers )
{
    HRESULT             hr = S_OK;
    CEditPointer        ePointerStart( GetEditor() );
    CEditPointer        ePointerEnd  ( GetEditor() );
    IObjectIdentity * pIObj1 = NULL;
    IObjectIdentity * pIObj2 = NULL;
    IHTMLElement    * pHTMLElement1 = NULL;
    IHTMLElement    * pHTMLElement2 = NULL;
    DWORD             dwBreak;
    CBlockPointer       bp(GetEditor());
    
    if (! IsMergeNeeded( pStart, pEnd ) )
    {
        goto Cleanup;
    }

    // 
    // Before merging check whether we should delete an empty block,
    // rather than doing the full blown merge.
    //

    if ( fAdjustPointers )
    {
        IFC( ePointerStart.MoveToPointer( pStart ) );
        IGNORE_HR( ePointerStart.Scan(  LEFT,
                        BREAK_CONDITION_Block |
                        BREAK_CONDITION_Site |
                        BREAK_CONDITION_Control |
                        BREAK_CONDITION_Text |
                        BREAK_CONDITION_NoScopeSite |
                        BREAK_CONDITION_NoScopeBlock |
                        BREAK_CONDITION_BlockPhrase,
                        &dwBreak, & pHTMLElement1 ) );
    
        if ( ePointerStart.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) )
        {
            BOOL fEqual;

            IFC( ePointerEnd.MoveToPointer(pEnd) );

            IFC( ePointerStart.IsEqualTo(ePointerEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEqual) );

            if (fEqual)
            {
                IGNORE_HR( ePointerEnd.Scan(  RIGHT,
                                BREAK_CONDITION_Block |
                                BREAK_CONDITION_Site |
                                BREAK_CONDITION_Control |
                                BREAK_CONDITION_Text |
                                BREAK_CONDITION_NoScopeSite |
                                BREAK_CONDITION_NoScopeBlock |
                                BREAK_CONDITION_BlockPhrase,
                                &dwBreak, & pHTMLElement2 ) );

                if ( ePointerEnd.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) )
                {
                    IFC( pHTMLElement1->QueryInterface( IID_IObjectIdentity, (void **) & pIObj1 ));
                    IFC( pHTMLElement2->QueryInterface(IID_IObjectIdentity,  (void **) & pIObj2 ));
                    if ( pIObj1->IsEqualObject( pIObj2 ) == S_OK )
                    {
                        // Remove the block
                        IFC( 
                            GetMarkupServices()->Remove( (IMarkupPointer *) ePointerStart, 
                                                         (IMarkupPointer *) ePointerEnd ) );
                        goto Cleanup;
                    }   
                }
            }
        }
    }

    //
    // We may need to merge list containers.  Check for this case here.
    //

    IFC( bp.MoveTo(pStart, RIGHT) );
    if (bp.IsLeafNode())
    {
        IFC( bp.MoveToParent() );
    }

    if (bp.GetType() == NT_ListItem)
    {
        IFC( bp.MoveToParent() );
    }

    //
    // Do the merge
    //
    IFC( MergeBlock( pStart ) );

    //
    // Merge list containers.
    //

    if (bp.GetType() == NT_ListContainer)
    {
        IFC( bp.MergeListContainers(RIGHT) );
    }

Cleanup:
    ReleaseInterface( pHTMLElement1 );
    ReleaseInterface( pHTMLElement2 );
    ReleaseInterface( pIObj1 );
    ReleaseInterface( pIObj2 );
    return ( hr );
}


//+====================================================================================
//
// Method: AdjustOutOfBlock
//
// Synopsis: Move the given pointer out of a block while skipping any empty phrase elements.
//           This helper function is called by Delete when it is determined that a entire
//           block was selected for deletion. 
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::AdjustOutOfBlock ( IMarkupPointer * pStart, BOOL * pfDidAdjust )
{
    HRESULT             hr = S_OK;
    DWORD               dwBreakCondition;
    long                cch;
    CEditPointer        pointerStart ( GetEditor() );
    DWORD               dwBreakFor = BREAK_CONDITION_Block       | BREAK_CONDITION_EnterAnchor  | 
                                     BREAK_CONDITION_Text        | BREAK_CONDITION_Control      | 
                                     BREAK_CONDITION_NoScopeSite | BREAK_CONDITION_NoScopeBlock |
                                     BREAK_CONDITION_Site ;

    IFC( pointerStart->MoveToPointer( pStart ) );
    
    *pfDidAdjust = FALSE;

    IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, & dwBreakCondition  ) );

    if ( pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock ) )
    {
        *pfDidAdjust = TRUE;
        //
        // Here we also skip any phrase elements around the block we just exited
        //
        IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, & dwBreakCondition  ) );
        if (! pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
        {
            cch = 1;
            IFC( pointerStart.Move( RIGHT, TRUE, NULL, NULL, &cch, NULL ) );
        }
        //
        // Set pStart to pointerStart and we're done
        //
        IFC( pStart->MoveToPointer( pointerStart ) );
    }

Cleanup:
    RRETURN( hr );
}


//+====================================================================================
//
// Method: AdjustPointersForDeletion
//
// Synopsis: Move the given pointers out for a delete operation. This adjust stops at
//           blocks, and layouts, but will skip over "other" tags (ie character formatting).
//           This function also detects when an entire block is selected and adjusts the
//           left edge out of the block element to fully delete the block. 
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::AdjustPointersForDeletion ( IMarkupPointer* pStart, 
                                            IMarkupPointer* pEnd )
{
    HRESULT         hr = S_OK;
    DWORD           dwBreakCondition;
    long            cch;
    CEditPointer    pointerStart ( GetEditor() );
    CEditPointer    pointerEnd( GetEditor() );
    BOOL            fLeftFoundBlock;
    DWORD           dwBreakFor =    BREAK_CONDITION_EnterAnchor | BREAK_CONDITION_NoScopeBlock  |
                                    BREAK_CONDITION_Text        | BREAK_CONDITION_Control       |
                                    BREAK_CONDITION_Block       | BREAK_CONDITION_NoScopeSite   |
                                    BREAK_CONDITION_Site        | BREAK_CONDITION_Glyph         |
                                    BREAK_CONDITION_NoScope;
    // Position our edit pointers
    IFC( pointerStart.MoveToPointer( pStart ) );
    IFC( pointerEnd.MoveToPointer( pEnd ) );

    //
    // Scan left to skip phrase elements
    //
    IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, &dwBreakCondition ) );

    fLeftFoundBlock = pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock );
    
    if (! pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
    {
        // We went too far, move back once
        cch = 1;
        IFC( pointerStart.Move( RIGHT, TRUE, NULL, NULL, &cch, NULL ) );
    }

    // Update our start position
    IFC( pStart->MoveToPointer( pointerStart ) );
    
    //
    // Scan right.  If we hit exit a block, and our start pointer exited a block,
    // then we want to preserve the formatting of the end block being deleted.
    //
    IGNORE_HR( pointerEnd.Scan( RIGHT, dwBreakFor, &dwBreakCondition ) );

    if( pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock ) && fLeftFoundBlock )
    {
        //
        // Save off this position, in case of failure
        //
        IFC( pointerStart.MoveToPointer( pointerEnd ) );

        // 
        // Reposition our end pointer at our original point, and look
        // for an exit phrase to indicate block level formatting
        //
        IFC( pointerEnd.MoveToPointer( pEnd ) );
        IFC( pointerEnd.Scan( RIGHT, dwBreakFor | BREAK_CONDITION_ExitPhrase, &dwBreakCondition ) );

        if( pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitPhrase ) )
        {
            // Reposition just inside the phrase element
            IFC( pointerEnd.Scan(LEFT, BREAK_CONDITION_EnterPhrase, &dwBreakCondition) );
        }
        else
        {
            // We didn't find an exit phrase, we will return to our position
            // we saved before we looked for a phrase element.
            IFC( pointerEnd->MoveToPointer( pointerStart ) );

            // We went too far, move back once
            cch = 1;
            IFC( pointerEnd.Move( LEFT, TRUE, NULL, NULL, &cch, NULL ) );
        }
    }
    else if (! pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
    {
        // We went too far, move back once
        cch = 1;
        IFC( pointerEnd.Move( LEFT, TRUE, NULL, NULL, &cch, NULL ) );
    }
    

    // Position our end pointer
    IFC( pEnd->MoveToPointer( pointerEnd ) );

Cleanup:
    RRETURN( hr );
}


//+====================================================================================
//
// Method: RemoveBlockIfNecessary
//
// When the left pointer is positioned at the beginning of a block and the right pointer 
// is after the end of the block, the entire block is to be deleted. Here we are detecting
// this case by walking left to right: if we enter a block before hitting the right
// pointer we bail, since this routine is being called after a call to Remove. 
// Otherwise we remove the block if we exit the scope of a block and hit the righthand pointer.
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::RemoveBlockIfNecessary( IMarkupPointer * pStart, IMarkupPointer * pEnd )
{
    IMarkupServices   * pMarkupServices  = GetMarkupServices();
    SP_IMarkupPointer   spPointer;
    MARKUP_CONTEXT_TYPE context;
    IHTMLElement *      pHTMLElement = NULL;            
    BOOL                fResult;
    HRESULT             hr = S_OK;
    BOOL                fExitedBlock = FALSE;
    BOOL                fDone = FALSE;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ) );    
    IFC( spPointer->MoveToPointer( pStart ) );

    while (! fDone)
    {
        ClearInterface( & pHTMLElement );
        IFC( spPointer->Right( TRUE, & context, & pHTMLElement, NULL, NULL ) );
        
        switch( context )        
        {
        case CONTEXT_TYPE_EnterScope:
            // If we entered a block, we're done
            IGNORE_HR(IsBlockOrLayoutOrScrollable(pHTMLElement, &fDone));
            break;

        case  CONTEXT_TYPE_ExitScope:
            // Track whether we have exited a block 
            if (! fExitedBlock)
            {
                IGNORE_HR(IsBlockOrLayoutOrScrollable(pHTMLElement, &fExitedBlock));
            }
            break;

        case CONTEXT_TYPE_None:
            fDone = TRUE;
            break;

        }

        if ( fDone )
            break;

        IFC( spPointer->IsRightOfOrEqualTo( pEnd, & fResult ) );
        if ( fResult )
        {
            if ( fExitedBlock )
            {
                //
                // We've reached the right end and have already exited a block
                // so move pStart out of the block
                //
                IFC( AdjustOutOfBlock( pStart, & fResult ) );
                if (! fResult)
                {
                    // Done
                    break;
                }
            
                //
                // Ask MarkupServices to remove the segment
                //
                IFC( pMarkupServices->Remove( pStart, pEnd ) );      
            }
            // We're done
            break;
        }       
    }

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


HRESULT 
CDeleteCommand::RemoveEmptyListContainers(IMarkupPointer * pPointer)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    CBlockPointer       bpCurrent(GetEditor());

    IFR( pPointer->CurrentScope( &spElement ) );

    if( spElement )
    {
        IFR( bpCurrent.MoveTo(spElement) );

        if (bpCurrent.GetType() == NT_ListContainer)
        {
            SP_IMarkupPointer   spStart;
            SP_IMarkupPointer   spEnd;
            BOOL                fDone = FALSE;
            BOOL                fEqual;
            
            IFR( GetEditor()->CreateMarkupPointer(&spStart) );
            IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

            do
            {
                // If the list container is not empty, we're done
                IFR( bpCurrent.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );    
                IFR( bpCurrent.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd ) );    

                IFR( spStart->IsEqualTo(spEnd, &fEqual) );
                if (!fEqual)
                    break;
           
                // Remove list container and move to parent
                IFR( bpCurrent.GetElement(&spElement) );
            
                IFR( bpCurrent.MoveToParent() );
                fDone = (hr == S_FALSE); // done if no parent

                IFR( GetMarkupServices()->RemoveElement(spElement) );        
            }
            while (bpCurrent.GetType() == NT_ListContainer && !fDone);
        }
    }
    
    return S_OK;
}


//+====================================================================================
//
// Method: InflateBlock
//
// Synopsis: Sets the break on empty flag for a block element
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::InflateBlock( IMarkupPointer * pPointer )
{
    HRESULT         hr = S_OK;
    BOOL            fLayout;
    ELEMENT_TAG_ID  etagId;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spBlockElement;
    IMarkupServices * pMarkupServices = GetMarkupServices();

    IFR( pPointer->CurrentScope(&spElement) );

    if ( spElement )
    {
        IFR( GetEditor()->FindBlockElement( spElement, & spBlockElement ) );

        IFR( IsBlockOrLayoutOrScrollable(spElement, NULL, &fLayout) );
        if ( !fLayout )
        {
            IFR( pMarkupServices->GetElementTagId( spElement, &etagId ) );
            if ( !IsListContainer( etagId ) && etagId != TAGID_LI )
            {
                SP_IHTMLElement3 spElement3;
                IFR( spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFR( spElement3->put_inflateBlock( VARIANT_TRUE ) );
            }
        }
    }

    RRETURN( hr );
}


//+====================================================================================
//
// Method: Delete
//
// Synopsis: Given two MarkupPointers - delete everything between them
//
//------------------------------------------------------------------------------------

HRESULT 
CDeleteCommand::Delete ( IMarkupPointer* pStart, 
                         IMarkupPointer* pEnd,
                         BOOL fAdjustPointers /* = FALSE */ )
{
    HRESULT             hr = S_OK;
    int                 wherePointer = SAME;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    BOOL                fResult;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    CEditPointer        epStart(GetEditor());
    CEditPointer        epEnd(GetEditor());
    DWORD               dwFound;
    ELEMENT_TAG_ID      tagId;
    BOOL                fEqual;
    BOOL                fOkayForDeletion = TRUE;
    SP_IHTMLElement     spElement;

    //  Check for atomic deletions
    IFC( AdjustPointersForAtomicDeletion(pStart, pEnd, &fOkayForDeletion) );
    if (!fOkayForDeletion)
        goto Cleanup;

    //
    // First adjust the pointers out to skip phrase elements
    //
    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    if ( wherePointer == SAME )
        goto Cleanup;

    if ( fAdjustPointers )
    {
        if ( wherePointer == RIGHT )
        {
            IFC( AdjustPointersForDeletion( pStart, pEnd ) );
        }
        else
        {
            IFC( AdjustPointersForDeletion( pEnd, pStart ) );
        }
    }

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );
    
    if ( wherePointer == SAME )
        goto Cleanup;

    //
    // Ask MarkupServices to remove the segment
    //
    if ( wherePointer == RIGHT )
    {
        BOOL fCanRemove;

        //
        // Markup services will generate empty undo units, so make sure
        // we actually have something to remove.
        //
        IFC( CanRemove(pStart, pEnd, &fCanRemove) ); 
        if (fCanRemove)
        {
            IFC( pMarkupServices->Remove( pStart, pEnd ) );      
        }
    }
    else
    {
        BOOL fCanRemove;

        //
        // Markup services will generate empty undo units, so make sure
        // we actually have something to remove.
        //
        IFC( CanRemove(pEnd, pStart, &fCanRemove) ); 
        if (fCanRemove)
        {
            IFC( pMarkupServices->Remove( pEnd, pStart ) );
        }
    }

    //
    // Any elements left after the remove that have glyphs should be removed
    //
    IFC( DeleteGlyphElements(pStart, pEnd) );

    if (fAdjustPointers)
    {
        //
        // Detect if the entire block should be deleted, and if so delete the block
        //
        IFC( pStart->IsEqualTo( pEnd, & fResult ) ); // If equal we have nothing to do...
        if (! fResult)
        {
            if ( wherePointer == RIGHT )
            {
                IFC( RemoveBlockIfNecessary( pStart, pEnd ) );
            }
            else
            {
                IFC( RemoveBlockIfNecessary( pEnd, pStart ) );
            }
        }
    }

    //
    // Find the block elements for pStart and pEnd and set the
    // break on empty flag on them. 
    //
    IFC( InflateBlock( pStart ) );
    IFC( InflateBlock( pEnd ) );

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );
    switch ( wherePointer )
    {
        case RIGHT:
            IFC( MergeDeletion( pStart, pEnd, fAdjustPointers ));  
            break;
        case LEFT:
            IFC( MergeDeletion( pEnd, pStart, fAdjustPointers ));
            break;
    }

    //
    // If pStart or pEnd are within empty list containers, remove the list containers as well
    //
    IFC( RemoveEmptyListContainers( pStart ) );
    IFC( RemoveEmptyListContainers( pEnd ) );

    //
    // Remove double bullets if present
    //

    IFC( pStart->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }
    
    //
    // We don't want to delete all block elements in the body if we can avoid it.  Note, we only handle the
    // case where all content was deleted, i.e., pStart is equal to pEnd.
    //

    IFC( epStart->MoveToPointer(pStart) );
    IFC( epEnd->MoveToPointer(pEnd) );

    IFC( epStart.IsEqualTo(epEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEqual) );

    if (fEqual)
    {
        //
        // Check for exit body on the left
        //

        IFC( epStart.Scan(LEFT, BREAK_CONDITION_Content, &dwFound, NULL, &tagId) );
        if (epStart.CheckFlag(dwFound, BREAK_CONDITION_ExitSite) && tagId == TAGID_BODY)
        {
            //
            // Check for exit body on the right
            //

            IFC( epEnd.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound, NULL, &tagId) );
            if (epEnd.CheckFlag(dwFound, BREAK_CONDITION_ExitSite) && tagId == TAGID_BODY)
            {
                ELEMENT_TAG_ID  tagIdDefault;            
                SP_IHTMLElement spElement;

                //
                // Adjust for insertion
                //
                IFC( epStart.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
                IFC( epEnd.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

                //
                // Insert element
                //

                IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )              
                IFC( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );

                IFC( InsertElement(GetMarkupServices(), spElement, epStart, epEnd) );
            }
        }
    }


    // Finally, launder spaces
    IFC( LaunderSpaces( pStart, pEnd ) );

    // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(GetEditor()->GetSelectionManager());
        selCounter.SelectionChanged();
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  CDeleteCommand::IsValidOnControl
//
//----------------------------------------------------------------------------

BOOL CDeleteCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount ) );

    //
    // For compat we only allow multiple selection if the bit is set.
    //
    if(GetCommandTarget() == NULL) return FALSE;
    bResult = (iSegmentCount == 1) || 
              ( GetCommandTarget()->IsMultipleSelection() 
#ifdef FORMSMODE
                || GetEditor()->GetSelectionManager()->IsInFormsSelectionMode()
#endif
              ) ;

Cleanup:
    return bResult;
}

//+---------------------------------------------------------------------------
//
//  CDeleteCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::PrivateExec( 
                    DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn,
                    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IDisplayPointer      spDispCaret;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    IHTMLCaret             *pCaret = NULL;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
    BOOL                    fEmpty = FALSE;
    
    //
    // Do the prep work
    //
    IFC( GetSegmentList( &spSegmentList ));   
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    
    // Create some markup pointers
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );
            
    if ( eSelectionType != SELECTION_TYPE_Caret )
    {
        //
        // Delete the segments
        //        
        if (fEmpty == FALSE)
        {       
            //
            // Begin the undo unit
            //
            IFC( undoUnit.Begin(IDS_EDUNDOTEXTDELETE) );        

            if (eSelectionType == SELECTION_TYPE_Control)
            {
                IFC (GetEditor()->RemoveElementSegments(spSegmentList));
            }
            else 
            {
                // Create an iterator
                IFC( spSegmentList->CreateIterator( &spIter ) );
            
                while( spIter->IsDone() == S_FALSE)
                {
                    // Get the current segment, and advance the iterator right away, 
                    // since we might blow away our segment in the delete call.
                    IFC( spIter->Current(&spSegment) );
                    IFC( spIter->Advance() );

                    IFC( spSegment->GetPointers( spStart, spEnd ) );

                    //
                    // This is an icky place to handle control-delete. I can't really think of
                    // another - short of having the delete command talk to the tracker.
                    //
                    if ( _cmdId == IDM_DELETEWORD && 
                         eSelectionType == SELECTION_TYPE_Text  )
                    {
                        // they're performing a control delete.
                        // Instead of using the start and end - the end is the word end from the start.
                        //
                        DWORD dwBreak = 0;
                    
                        CEditPointer blockScan( GetEditor());
                        blockScan.MoveToPointer( spEnd );
                        blockScan.Scan( RIGHT,
                                        BREAK_CONDITION_Block |
                                        BREAK_CONDITION_Site |
                                        BREAK_CONDITION_Control |
                                        BREAK_CONDITION_Text ,
                                        &dwBreak );

                        if ( blockScan.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                        {
                            //
                            // We use moveUnit instead of MoveWord - as MoveWord is only good to move
                            // to word beginnings. We want to do just like Word does - and really move
                            // to the word end.
                            //
                            IFC( spEnd->MoveToPointer( spStart ));
                            IFC( spEnd->MoveUnit(MOVEUNIT_NEXTWORDEND ));
                        }
                    }
                
                    //
                    // Cannot delete or cut unless the range is in the same flow layout
                    //
                    if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
                    {                 
                        IFC( Delete( spStart, spEnd, TRUE ) );
                    }
                }

                // ExitTree clears for siteselected elements, other cases handle here
                if ( !GetCommandTarget()->IsRange())
                {
                    GetEditor()->GetSelectionManager()->EmptySelection();
                }
            }
            {
                //
                // We want to set caret direction in any case
                //
                SP_IHTMLCaret   spCaret;
                IFC( GetDisplayServices()->GetCaret(&spCaret) );
                IFC( spCaret->SetCaretDirection(CARET_DIRECTION_BACKWARD) );
            }
        }
    }
    else
    {
        CSpringLoader     * psl = GetSpringLoader();
        MARKUP_CONTEXT_TYPE mctContext;
        long                cch = 2;
        BOOL                fCacheFontForLastChar = TRUE;
        SP_IDisplayPointer  spDispPointer;

        Assert(eSelectionType == SELECTION_TYPE_Caret);

        //
        // Handle delete at caret
        //
        IFC( undoUnit.Begin(IDS_EDUNDOTEXTDELETE) );        

        IFC( GetDisplayServices()->GetCaret( & pCaret ));
        IFC( pCaret->MoveMarkupPointerToCaret( spStart));

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( pCaret->MoveDisplayPointerToCaret(spDispCaret) );
        
        // Reset springloader.
        Assert(psl);
        psl->Reset();

        // Decide if springloader needs to preserve formatting of last character in block.
        fCacheFontForLastChar = _cmdId != IDM_DELETE
                             || S_OK != THR(spStart->Right(FALSE, &mctContext, NULL, &cch, NULL))
                             || mctContext != CONTEXT_TYPE_Text
                             || cch != 2;
        if (fCacheFontForLastChar)
        {
            IFC( psl->SpringLoad(spStart, SL_TRY_COMPOSE_SETTINGS) );
        }

        IFC( DeleteCharacter( spStart, FALSE, _cmdId == IDM_DELETEWORD,
                              GetEditor()->GetSelectionManager()->GetStartEditContext() ) );

        //
        // Set the caret to pStart
        // Note that this is the code path for forward delete only, backspace
        // is handled in HandleKeyDown()       
        CCaretTracker * pCaretTracker = (CCaretTracker *)GetEditor()->GetSelectionManager()->GetActiveTracker();
        Assert( pCaretTracker );       
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( spDispPointer->MoveToMarkupPointer(spStart, spDispCaret) );

        IFC( pCaretTracker->PositionCaretAt( spDispPointer, CARET_DIRECTION_BACKWARD, POSCARETOPT_None, ADJPTROPT_None ) );

        // If we didn't delete last character, we need to forget formatting by resetting springloader.
        if (   fCacheFontForLastChar
            && S_OK != psl->CanSpringLoadComposeSettings(spStart, NULL, FALSE, TRUE))
        {
            psl->Reset();
        }
    }

    GetEditor()->GetSelectionManager()->SetHaveTypedSinceLastUrlDetect(TRUE);

Cleanup:   
    ReleaseInterface( pCaret );
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CDeleteCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );   
    VARIANT_BOOL            fEditable;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement3        spElement3;

    // 
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    //
    // Get Segment list and selection type
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ));

    //
    // If no segments found we're done
    //
    if( fEmpty )
    {
        goto Cleanup;
    }

    //
    // Get the segments and check to see if we're editable
    //

    if ( !GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
        if (!spElement) 
            goto Cleanup;

        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isContentEditable(&fEditable));

        if (! fEditable)
            goto Cleanup;
    } 
    else if (eSelectionType == SELECTION_TYPE_Control)
    {
        if (!IsValidOnControl())
            goto Cleanup; // disable
    }   

    //
    // Cannot delete or cut unless the range is in the same flow layout
    //
    IFC( spSegmentList->CreateIterator(&spIter) );
    Assert(S_FALSE == spIter->IsDone());

    IFC( spIter->Current(&spSegment) );
    IFC( spSegment->GetPointers(edStart, edEnd) );
    if (!(GetEditor()->PointersInSameFlowLayout(edStart, edEnd, NULL)) )
    {
        goto Cleanup;
    }

    pCmd->cmdf = MSOCMDSTATE_UP;
 
Cleanup:
    RRETURN(hr);
}





//+------------------------------------------------------------------------------------
//
// Method: DeleteCharacter
//
// Synopsis: Delete one character or a NOSCOPE element in fLeftBound direction
//           used by backspace and delete.
//
// General Algorithm:
//      Peek fLeftBound, if context is:
//      - TEXT: call MoveUnit() if we have not crossed a block element
//      - NOSCOPE: move passed it and we're done
//      - NONE: we're done
//      - else move and continue to Peek fLeftBound
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::DeleteCharacter( 
                 IMarkupPointer* pPointer, 
                 BOOL fLeftBound, 
                 BOOL fWordMode,
                 IMarkupPointer* pBoundary )
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    Direction           dir = fLeftBound ? LEFT : RIGHT;
    DWORD               dwOmitPhrase;
    DWORD               dwFound;
    SP_IHTMLElement     spElement;
    TCHAR               ch;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    CEditPointer        epLeft(GetEditor());
    CEditPointer        epRight(GetEditor());
    CEditPointer        epTest(GetEditor());
    BOOL                fContained;
    BOOL                fEmptyBlock;
    DWORD               dwPhrase;

    //
    // Look for content to delete
    //
    
    IFC( ep->MoveToPointer(pPointer) );

    dwOmitPhrase = BREAK_CONDITION_OMIT_PHRASE & (~BREAK_CONDITION_Anchor);
    dwPhrase = BREAK_CONDITION_ANYTHING - dwOmitPhrase;

    IFC( ep.Scan(dir, dwOmitPhrase | BREAK_CONDITION_Glyph, &dwFound, &spElement, NULL, &ch) );

    //
    // We only do glyph deletion if the element is not a block or layout element.
    //
    
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph))
    {
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block) || ep.CheckFlag(dwFound, BREAK_CONDITION_Site))
        {
            dwFound &= ~BREAK_CONDITION_Glyph;
        }           
    }

    //
    // Handle backspace/delete special cases
    //

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
    {        
        if (fWordMode)
        {
            CEditPointer        epNextWord(GetEditor());
            DWORD               dwScanOptions = SCAN_OPTION_None;
            BOOL                fSkipWhitespace = FALSE;
            
            //
            // Find the next word
            //
            
            IFC( epNextWord->MoveToPointer(pPointer) );
            IFC( epNextWord->MoveUnit(fLeftBound ? MOVEUNIT_PREVWORDBEGIN : MOVEUNIT_NEXTWORDEND) );

            //
            // If at a word boundary, we want to remove the whitespace
            // as well. (word 2k behavior)
            //
            // For example:
            //
            //  word0 {caret}word1 word2 --> DELETE --> word0 {caret}word2
            //  word0 w{caret}ord1 word2 --> DELETE --> word0 w{caret} word2            
            //
            //  word0 word1{caret} word2 --> BKSP   --> word0{caret} word2
            //  word0 word{caret}1 word2 --> BKSP   --> word0  {caret}1 word2
            //  

            IFC( epTest->MoveToPointer(pPointer) );

            if (fLeftBound)
            {
                IFC( epTest->MoveUnit(MOVEUNIT_PREVWORDEND) );
                IFC( epTest->MoveUnit(MOVEUNIT_NEXTWORDEND) );
            }
            else
            {
                IFC( epTest->MoveUnit(MOVEUNIT_NEXTWORDBEGIN) );
                IFC( epTest->MoveUnit(MOVEUNIT_PREVWORDBEGIN) );
            }

            IFC( epTest.IsEqualTo(pPointer, dwPhrase, &fSkipWhitespace) )

            if (fSkipWhitespace)
            {
                //
                //  #110445
                //  word0 word1{caret}<Boundary> -->BKSP --> word0 {caret}
                //
                //
                if (fLeftBound)
                {
                    Assert(LEFT == dir);
                    epTest.Scan(RIGHT, dwOmitPhrase, &dwFound);
                    if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
                    {
                        fSkipWhitespace = FALSE;
                    }
                }
                
                if (fSkipWhitespace)
                {
                    dwScanOptions |= SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP;

                    IFC( epNextWord.Scan(dir, dwOmitPhrase, &dwFound, NULL, NULL, NULL, dwScanOptions) );
                    IFC( epNextWord.Scan(Reverse(dir), dwOmitPhrase, &dwFound, NULL, NULL, NULL, dwScanOptions) );
                }
            }
            
            //
            // Clip to interesting content
            //

            IFC( ep.SetBoundaryForDirection(dir, epNextWord) );
            IFC( ep.Scan(dir, dwOmitPhrase - BREAK_CONDITION_Text, &dwFound) );
            if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            {
                IFC( ep.Scan(Reverse(dir), dwOmitPhrase - BREAK_CONDITION_Text, &dwFound) );
            }
        }
        else
        {
            //
            // NOTE (cthrash) For IE5.1, we've elected to leave the symantic of
            // MOVEUNIT_PREVCHAR/MOVEUNIT_NEXTCHAR unchanged, i.e. the method will
            // continue to move the markup pointer by one TCHAR.  This means that we
            // have the possibility of splitting a high/low surrogate pair.  It is up
            // to the consumer of these methods to prevent an improper splitting of
            // surrogates.
            //

            if (fLeftBound)
            {
                if (IsLowSurrogateChar(ch))
                {
                    LONG                cch = 1;
                    MARKUP_CONTEXT_TYPE context;
                    
                    IFC( ep->Left(FALSE, &context, NULL, &cch, &ch) );

                    Assert(context != CONTEXT_TYPE_Text || cch == 1);
                    
                    if (context == CONTEXT_TYPE_Text && IsHighSurrogateChar(ch))
                    {
                        Assert( cch==1 );
                        IFC( ep->Left(TRUE, NULL, NULL, &cch, NULL) );
                    }
                }
            }
            else
            {
                IFC( ep->MoveToPointer(pPointer) );
                IFC( ep->MoveUnit(MOVEUNIT_NEXTCLUSTEREND) );

                //
                // Cling to text since moveunit leaves us in some random location
                //
                IFC( ep.Scan(LEFT, dwOmitPhrase, &dwFound) );
                IFC( ep.Scan(RIGHT, dwOmitPhrase, &dwFound) );
            }
        }
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterSite))
    {
        Assert(spElement != NULL);

        //
        // Remove the entire site
        //
        
        IFC( ep->MoveAdjacentToElement(spElement, fLeftBound ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitSite))
    {
        goto Cleanup; // Nothing to delete        
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block))
    {
        //
        // Group all block elements up to the next block break
        //

        IFC( FindContentAfterBlock(dir, ep) );

        //
        // Reset the spring loader since crossing block boundaries can but us in a different
        // kind of block element.
        //
        // For example: <P>foo<P><H1>{caret}bar</H1>
        //
        {
            CSpringLoader *psl = GetSpringLoader();

            if (psl)
                psl->Reset();
        }
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph))
    {
        Assert(spElement != NULL);

        //
        // Just remove the glyph element
        //
        IFC( GetMarkupServices()->RemoveElement(spElement) );
        goto Cleanup;        
    }
    
    //
    // Omit phrase on the left so that we handle empty line formatting properly
    // 

    IFC( epLeft->MoveToPointer((dir == LEFT) ? ep : pPointer) );
    IFC( epLeft.Scan(LEFT, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Phrase) );
    IFC( epLeft.Scan(RIGHT, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Phrase) );    

    //
    // Do the delete
    //

    if (dir == LEFT)
    {
        IFC( Delete(epLeft, pPointer, FALSE /* fAdjust */) );
    }
    else
    {
        IFC( Delete(epLeft, ep, FALSE /* fAdjust */) );
    }

    //
    // Clean up phrase elements 
    //

    IFC( epRight->MoveToPointer(fLeftBound ? pPointer : ep) );
    if (dir == RIGHT)
    {
        IFC( ep->MoveToPointer(pPointer) );    
    }

    IFC( ep.SetBoundaryForDirection(RIGHT, epRight) );

    //
    // Expand right and left boundaries to include all phrase elements
    //

    dwOmitPhrase |= BREAK_CONDITION_Glyph;

    IFC( epRight.Scan(RIGHT, dwOmitPhrase, &dwFound) );
    fEmptyBlock = epRight.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site);

    IFC( epRight.Scan(LEFT, dwOmitPhrase, &dwFound) );

    IFC( ep.Scan(LEFT, dwOmitPhrase, &dwFound) );
    Assert(!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));
    fEmptyBlock = fEmptyBlock && ep.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site);

    IFC( ep.Scan(RIGHT, dwOmitPhrase, &dwFound) );
    Assert(!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));

    //
    // Remove phrase elements
    //

    IFC( epLeft->MoveToPointer(ep) );

    //
    // We shouldn't remove empty line formatting
    //
    if (!fEmptyBlock)
    {
        do
        {
            IFC( ep.Scan(RIGHT, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor, &dwFound, &spElement) );

            if (ep.CheckFlag(dwFound, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor))
            {
                if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterPhrase | BREAK_CONDITION_EnterAnchor))
                {
                    IFC( epTest->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    IFC( epTest->IsLeftOfOrEqualTo(epRight, &fContained) );
                }
                else
                {
                    IFC( epTest->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    IFC( epTest->IsRightOfOrEqualTo(epLeft, &fContained) );
                }

                if (fContained)
                {
                    IFC( GetMarkupServices()->RemoveElement(spElement) );
                }
            }
            
        }
        while (!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));
    }

    //
    // Update the passed in pointer
    //

    IFC( pPointer->MoveToPointer(fLeftBound ? epLeft : epRight) );


Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   MergeBlock
//
//  Synopsis:   Does a block merge.  The content after the give block element
//              is merged with that block elements content.
//
//-----------------------------------------------------------------------------

HRESULT
CDeleteCommand::MergeBlock(IMarkupPointer *pPointerMerge)
{
    HRESULT             hr = S_OK;
    IMarkupContainer    *pMarkup = NULL;
    IHTMLElement        *pElementContainer = NULL;
    IHTMLElement        *pElementFlow = NULL;
    IMarkupPointer      *pPointer = NULL;
    IMarkupPointer      *p = NULL;
    IMarkupPointer      *p2 = NULL;
    IMarkupPointer      *pPointerStart = NULL;
    IMarkupPointer      *pPointerFinish = NULL;
    IMarkupPointer      *pPointerEnd = NULL;
    IHTMLElement        *pElementBlockMerge = NULL;
    IHTMLElement        *pElement = NULL;
    IHTMLElement        *pElement2 = NULL;
    BOOL                fFoundContent;
    IHTMLElement        *pElementBlockContent = NULL;
    int                 i;
    CStackPtrAry < IHTMLElement *, 4 > aryMergeLeftElems ( Mt( Mem ) );
    CStackPtrAry < IHTMLElement *, 4 > aryMergeRightElems ( Mt( Mem ) );
    CStackPtrAry < INT_PTR, 4 > aryMergeRightElemsRemove ( Mt( Mem ) );
    IObjectIdentity     *pElementContainerIdent = NULL;
    IObjectIdentity     *pIdent = NULL;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    
    IFC( GetEditor()->CreateMarkupPointer(&p) );
    IFC( GetEditor()->CreateMarkupPointer(&p2) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerEnd) );

#if DBG==1
    BOOL fDbgIsPositioned;
    
    Assert( pPointerMerge->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
#endif    

    IFC( pPointerMerge->GetContainer(&pMarkup) );

    //
    // The merge must be contained to certain elements.  For example, a TD
    // cannot be merged with stuff after it.
    //
    // Text sites are the limiting factor here.  Locate the element which
    // will contain the merge.  
    //

    IFC( pPointerMerge->CurrentScope(&pElement) );
    if (!pElement)
        goto Cleanup;
    
    IFC( GetFlowLayoutElement(pElement, &pElementContainer) );    
    if (!pElementContainer)
        goto Cleanup;

    IFC( pElementContainer->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pElementContainerIdent) );

    //
    // Locate the block element the merge pointer is currently in.  This
    // is the block element which will subsume the content to its right.
    //

    IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElementBlockMerge) );
    if (!pElementBlockMerge)
        goto Cleanup;

    //
    // Check that we have meaningful context to merge into.  For example, if we have
    // <P>foo</P>{Merge Block}<P>bar</P>, the merge will basically result in removing
    // the <P> and no visual difference.
    //

    IFC( ep->MoveToPointer(pPointerMerge) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( ep->MoveToPointer(pPointerMerge) );
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

        if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
        {
            // Merge won't do anything useful
            goto Cleanup;
        }
    }

    //
    // Search right looking for real content.  The result of this will
    // be the element under which this content exists.
    //

    IFC( pPointer->MoveToPointer(pPointerMerge) );
    fFoundContent = FALSE;    

    //
    // For exit glyph, the block break is positioned differently, so the standard
    // algorithm will not work.  So we special case it.
    //
    // no glyph: <P>{block break}</P><P>{block break}</P>
    //    glyph: <P></P>{block break}<P></P>
    //

    IFC( ep->MoveToPointer(pPointer) )
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content | BREAK_CONDITION_Glyph, &dwFound) );

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph)
        && ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock))
    {
        IFC( FindContentAfterBlock(RIGHT, ep) );
        IFC( pPointer->MoveToPointer(ep) );

        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
        
        fFoundContent = !ep.CheckFlag(dwFound, BREAK_CONDITION_ExitSite | BREAK_CONDITION_Error | BREAK_CONDITION_Boundary);
     
        if (fFoundContent)
        {
            SP_IHTMLElement spElement;

            //
            // Initialize vars needed below
            //

            IFC( pPointer->CurrentScope(&spElement) );
            Assert(spElement != NULL);

            IFC( SearchBranchForBlockElement(pMarkup, spElement, pElementContainer, &pElementBlockContent) );
            Assert(pElementBlockContent);
        }
    }
    else
    {
        for (;;)
        {
            DWORD dwBreaks;
            MARKUP_CONTEXT_TYPE ct;

            //
            // Make sure we are still under the influence of the container
            //

            ClearInterface(&pElement);        
            IFC( pPointer->CurrentScope(&pElement) );
            if (!pElement)
                break;

            ClearInterface(&pElementFlow);
            IFC( GetFlowLayoutElement(pElement, &pElementFlow) );    

            if (!pElementFlow)
                break;

            if (pElementContainerIdent->IsEqualObject(pElementFlow) != S_OK)
                break;

            //
            // Get the current block element
            //

            ClearInterface(&pElementBlockContent);
            IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElementBlockContent) );
            if (!pElementBlockContent)
                break;

            //
            // Get the current break
            //

            IFC( QueryBreaks(pPointer, &dwBreaks) );

            if (dwBreaks)
            {
                ClearInterface(&pIdent);
                IFC( pElementBlockContent->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
                
                if (pIdent->IsEqualObject(pElementBlockMerge) != S_OK)
                {
                    fFoundContent = TRUE;
                    break;
                }
            }
            //
            // See if there is content to the right
            //

            ClearInterface(&pElement);
            IFC( pPointer->Right(TRUE, & ct, &pElement, NULL, NULL) );

            if (ct == CONTEXT_TYPE_None)
                break;

            //
            //
            //

            if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
            {
                fFoundContent = TRUE;
                break;
            }
            else if (ct == CONTEXT_TYPE_EnterScope)
            {
                BOOL fBlock, fLayout;

                if (IsAccessDivHack(pElement))
                    break;
                
                //
                // If we find layout+block element, we can't merge anyway, so just
                // break and treat it as no content.
                //

                IFC( IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout) );
                
                if (fBlock && fLayout)
                    break;

                //
                // Embedded elements are considered as content
                //

                if (IsEmbeddedElement(pElement))
                {
                    fFoundContent = TRUE;
                
                    IFC( pPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

                    break;
                }

            }
        }
    }


    if (!fFoundContent)
        goto Cleanup;

    //
    // Now, locate the extent of this content under this element
    //

    IFC( pPointerEnd->MoveToPointer(pPointer) );

    for (;;)
    {
        DWORD dwBreaks;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        ClearInterface(&pElement);        
        IFC( pPointer->CurrentScope(&pElement) );
        if (!pElement)
            break;

        ClearInterface(&pElementFlow);
        IFC( GetFlowLayoutElement(pElement, &pElementFlow) );    

        if (!pElementFlow)
            break;

        if (pElementContainerIdent->IsEqualObject(pElementFlow) != S_OK)
            break;

        //
        // Get the current block element
        //
        
        ClearInterface(&pElement2);        
        IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElement2) );
        if (!pElement2)
            break;
        ReplaceInterface(&pElement, pElement2);        
            
        ClearInterface(&pIdent);
        IFC( pElementBlockContent->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
        
        if (pIdent->IsEqualObject(pElement) != S_OK)
            break;

        //
        // Get the current break
        //

        IFC( QueryBreaks(pPointer, &dwBreaks) );

        if (dwBreaks)
        {
            IFC( pPointerEnd->MoveToPointer(pPointer) );
        }

        //
        // See if there is content to the right
        //

        ClearInterface(&pElement);
        IFC( pPointer->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            IFC( pPointerEnd->MoveToPointer(pPointer) );
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack(pElement))
                break;

            if (IsEmbeddedElement(pElement))
            {
                IFC( pPointerEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
                IFC( pPointer->MoveToPointer(pPointerEnd) );
            }
        }
        else if (ct == CONTEXT_TYPE_ExitScope)
        {
            if (!IsBlockElement(pElement) && !IsLayoutElement(pElement))
            {
                IFC( pPointerEnd->MoveToPointer(pPointer) );
            }
        }
    }

    //
    // Locate all the elements which will subsume content
    //

    ClearInterface(&pElement);
    IFC( pPointerMerge->CurrentScope(&pElement) );
    
    while (pElement)
    {        
        if (pElementContainerIdent->IsEqualObject(pElement) == S_OK)
            break;

        if (IsElementBlockInContext(pElementContainer, pElement))
        {
            pElement->AddRef();
            IFC( aryMergeLeftElems.Append(pElement) );
        }
        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    //
    // Locate all the elements which will loose content
    //

    ClearInterface(&pElement);
    IFC( pPointerEnd->CurrentScope(&pElement) );

    while (pElement)
    {        
        BOOL fHasContentLeftover;
        
        if (pElementContainerIdent->IsEqualObject(pElement) == S_OK)
            break;
    
        ClearInterface(&pIdent);
        IFC( pElementBlockMerge->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
        
        if (pIdent->IsEqualObject(pElement) == S_OK)
            break;
                    
        if (!IsElementBlockInContext(pElementContainer, pElement))
        {
            IFC( ParentElement(GetMarkupServices(), &pElement) );
            continue;
        }

        fHasContentLeftover = FALSE;
        
        IFC( p->MoveToPointer(pPointerEnd) );

        ClearInterface(&pIdent);
        IFC( pElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
            
        for ( ; ; )
        {
            MARKUP_CONTEXT_TYPE ct;
            
            ClearInterface(&pElement2);
            IFC( p->Right(TRUE, & ct, & pElement2, NULL, NULL) );

            if (ct == CONTEXT_TYPE_ExitScope && pIdent->IsEqualObject(pElement2) == S_OK)
                break;

            if (ct == CONTEXT_TYPE_Text)
            {
                fHasContentLeftover = TRUE;
                break;
            }
        }
        
        IFC( aryMergeRightElemsRemove.Append(!fHasContentLeftover) );
        pElement->AddRef();
        IFC( aryMergeRightElems.Append(pElement) );

        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    //
    // Now, move the end of the left elements to subsume the content
    //

    IFC( pPointerEnd->SetGravity(POINTER_GRAVITY_Right) );

    for ( i = 0 ; i < aryMergeLeftElems.Size() ; i++ )
    {
        BOOL            fRightOfOrEqualTo;
        IHTMLElement    *pElem = aryMergeLeftElems[i];

        //
        // Make sure we don't move an end tag to the left.
        //

        IFC( p2->MoveAdjacentToElement(pElem, ELEM_ADJ_BeforeEnd) );
        IFC( p2->IsRightOfOrEqualTo(pPointerEnd, &fRightOfOrEqualTo) );

        if (fRightOfOrEqualTo)
            continue;
        
        IFC( pPointerStart->MoveAdjacentToElement(pElem, ELEM_ADJ_BeforeBegin) );

        IFC( GetMarkupServices()->RemoveElement(pElem) );
        IFC( GetMarkupServices()->InsertElement(pElem, pPointerStart, pPointerEnd) );
    }

    // Release Elements
    for (i = 0; i < aryMergeLeftElems.Size(); i++ )
    {
        aryMergeLeftElems[i]->Release();
        aryMergeLeftElems[i] = NULL;        
    }

    //
    // Move the begin of the right elements to loose the content
    //

    IFC( pPointerEnd->SetGravity(POINTER_GRAVITY_Left) );

    for ( i = 0 ; i < aryMergeRightElems.Size() ; i++ )
    {
        IHTMLElement    *pElem = aryMergeRightElems[i];
        BOOL            fLeftOf;
            
        IFC( p2->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterBegin) );
        IFC( p2->IsLeftOfOrEqualTo(pPointerMerge, &fLeftOf) );
        if (fLeftOf)
            continue;
        
        IFC( pPointerFinish->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd) );
        IFC( GetMarkupServices()->RemoveElement(pElem) );

        if (!aryMergeRightElemsRemove[i])
        {
            IMarkupPointer *p0 = pPointerEnd, *p1 = pPointerFinish;

            IFC( EnsureLogicalOrder(p0, p1) );
            IFC( GetMarkupServices()->InsertElement(pElem, p0, p1) );
        };
    }

    // Release elements
    for (i = 0; i < aryMergeRightElems.Size(); i++)
    {
        aryMergeRightElems[i]->Release();
        aryMergeRightElems[i] = NULL;
    }
    
    //
    // THe content which was "moved" may have \r or multiple spaces which are
    // not legal under the new context.  Sanitize this range.
    //
    
    IFC( SanitizeRange(pPointerMerge, pPointerEnd ) );

Cleanup:
    ReleaseInterface(pMarkup);
    ReleaseInterface(pElementContainer);
    ReleaseInterface(pElementFlow);
    ReleaseInterface(pPointer);
    ReleaseInterface(pPointerEnd);
    ReleaseInterface(pElementBlockMerge);
    ReleaseInterface(pElement);
    ReleaseInterface(pElement2);
    ReleaseInterface(pElementBlockContent);
    ReleaseInterface(pElementContainerIdent);
    ReleaseInterface(p);
    ReleaseInterface(p2);
    ReleaseInterface(pPointerStart);
    ReleaseInterface(pPointerFinish);
    ReleaseInterface(pIdent);
    
    RRETURN( hr );
}



//+----------------------------------------------------------------------------
//
//  Member:     GetFlowLayoutElement
//
//  Synopsis:   Searches the given branch for the first flow layout element,
//
//-----------------------------------------------------------------------------
HRESULT
CDeleteCommand::GetFlowLayoutElement(IHTMLElement *pElement, IHTMLElement **ppElementFlow)
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = pElement;

    Assert(pElement && ppElementFlow);

    pElemCurrent->AddRef();
    
    *ppElementFlow = NULL;
    do
    {
        if (IsLayoutElement(pElemCurrent))
        {
            *ppElementFlow = pElemCurrent;
            pElemCurrent->AddRef();
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );        
    }
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForBlockElement
//
//  Synopsis:   Searches the given branch for the first block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

HRESULT 
CDeleteCommand::SearchBranchForBlockElement 
(
    IMarkupContainer    *pMarkupContainer,
    IHTMLElement        *pElemStartHere,
    IHTMLElement        *pElemContext,
    IHTMLElement        **ppBlockElement)
{
    HRESULT         hr;
    IHTMLElement    *pElement = NULL;
    IHTMLElement    *pElemCurrent = NULL;
    IObjectIdentity *pIdent = NULL;

    Assert(pMarkupContainer && pElemStartHere && ppBlockElement);

    *ppBlockElement = NULL;
    
    if (!pElemContext)
    {
        IFC( GetElementClient(pMarkupContainer, &pElement) );
        if (pElement == NULL)
            goto Cleanup;

        pElemContext = pElement; // weak ref
    }

    IFC( pElemContext->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );

    ReplaceInterface(&pElemCurrent, pElemStartHere);
    do
    {        
        if (IsElementBlockInContext(pElemContext, pElemCurrent))
        {
            *ppBlockElement = pElemCurrent;
            pElemCurrent->AddRef();
            goto Cleanup;
        }

        if (pIdent->IsEqualObject(pElemCurrent) == S_OK)
            break;

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    while (pElemCurrent);
    
Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pIdent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsEmbeddedElement
//
//  Synopsis:   Intrinsic control and tables are special elements that we must
//              "jump over" while doing a block merge.
//
//-----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsEmbeddedElement(IHTMLElement *pElement)
{
    HRESULT           hr = S_OK;
    BOOL              fResult = FALSE;
    ELEMENT_TAG_ID    tagId;

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    switch (tagId)
    {
    case TAGID_BUTTON:
    case TAGID_TEXTAREA:
    case TAGID_INPUT:
    case TAGID_FIELDSET:
    case TAGID_LEGEND:
    case TAGID_MARQUEE:
    case TAGID_SELECT:
    case TAGID_TABLE:        
        fResult = TRUE;
        break;

    default:
        fResult = IsLayoutElement(pElement);
    }

Cleanup:
    return fResult;
}

//+----------------------------------------------------------------------------
//
//  Member:     ConvertShouldCrLf
//
//-----------------------------------------------------------------------------

HRESULT 
CDeleteCommand::ConvertShouldCrLf ( 
    IMarkupPointer *pmp, 
    BOOL &fShouldConvert )
{
    HRESULT         hr;
    IHTMLElement    *pElemCurrent = NULL;
    IHTMLElement3   *pElement3 = NULL;
    IObjectIdentity *pIdent = NULL;
    ELEMENT_TAG_ID  tagId;
    VARIANT_BOOL    fHTML;
    
    fShouldConvert = FALSE;

    Assert(pmp);

    IFC( pmp->CurrentScope(&pElemCurrent) );

    while (pElemCurrent)
    {        
        if (GetEditor()->IsContainer(pElemCurrent))
        {
            ClearInterface(&pElement3);
            IFC( pElemCurrent->QueryInterface(IID_IHTMLElement3, (LPVOID*)&pElement3) );
            IFC( pElement3->get_canHaveHTML(&fHTML) );
            fShouldConvert = BOOL_FROM_VARIANT_BOOL(fHTML);
            
            goto Cleanup;            
        }

        if (IsLiteral(pElemCurrent))
        {
            fShouldConvert = FALSE;
            goto Cleanup;
        }

        //
        // Special case for PRE because it is not marked as literal
        //

        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );
        if (tagId == TAGID_PRE)
        {
            fShouldConvert = FALSE;
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    
Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pElement3);
    ReleaseInterface(pIdent);
    RRETURN(hr);
}

HRESULT
CDeleteCommand::LaunderEdge (IMarkupPointer *pmp)
{
    HRESULT                hr = S_OK;
    IMarkupPointer         *pmpOther = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pmpOther) );

    IFC( pmpOther->MoveToPointer(pmp) );
    IFC( GetEditor()->LaunderSpaces(pmp, pmpOther) );

Cleanup:
    ReleaseInterface(pmpOther);
    
    RRETURN( hr );
}

HRESULT
CDeleteCommand::SanitizeCrLf (IMarkupPointer* pmp, long &cchAfter)
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *mp2 = NULL;
    IHTMLElement        *pElementNew = NULL;
    TCHAR               ch1, ch2;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fShouldConvert;
    long                cch;

    //
    // cchAfter is the numner of characters this member deals with after the
    // passed in pointer.
    //

    cchAfter = 0;

    //
    // First, determine the combination of CR/LF chars here
    //

    IFC( GetEditor()->CreateMarkupPointer(&mp2) );
    IFC( mp2->MoveToPointer(pmp) );

    IFC( mp2->Left(TRUE, &ct, NULL, &(cch=1), &ch1) );

    Assert( ct == CONTEXT_TYPE_Text && cch == 1 );
    Assert( ch1 == _T('\r') || ch1 == _T('\n') );

    IFC( pmp->Right(FALSE, &ct, NULL, &(cch=1), &ch2) );

    if (ct != CONTEXT_TYPE_Text || cch != 1)
        ch2 = 0;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
    {
        IFC( pmp->Right(TRUE, NULL, NULL, &(cch=1), NULL) );

        cchAfter++;
    }

    //
    // Now, the text between mp2 and pmp comprises a single line break.
    // Replace it with some marup if needed.
    //

    IFC( ConvertShouldCrLf(pmp, fShouldConvert) );

    if (fShouldConvert)
    {
        //
        // Remove the Cr/LF and insert a BR
        //

        IFC( GetMarkupServices()->Remove(mp2, pmp) );
        IFC( GetMarkupServices()->CreateElement(TAGID_BR, NULL, &pElementNew) );
        IFC( GetMarkupServices()->InsertElement(pElementNew, pmp, NULL) );
    }
    
Cleanup:

    ReleaseInterface(pElementNew);
    ReleaseInterface(mp2);

    RRETURN( hr );
}

HRESULT
CDeleteCommand::SanitizeRange (IMarkupPointer *pmpStart, IMarkupPointer *pmpFinish)
{
    HRESULT        hr = S_OK;
    IMarkupPointer *pmp = NULL;
    IMarkupPointer *pmpCRLF = NULL;
    IMarkupPointer *pmpBeforeSpace = NULL;
    IMarkupPointer *pmpAfterSpace = NULL;
    TCHAR *        pchBuff = NULL;
    long           cchBuff = 0;
    BOOL           fLeftOf;
    BOOL           fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( GetEditor()->CreateMarkupPointer(&pmp) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpCRLF) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpBeforeSpace) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpAfterSpace) );

    IFC( pmp->MoveToPointer(pmpStart) );

    IGNORE_HR( pmp->SetGravity(POINTER_GRAVITY_Right) );

// move the start and finish out to catch adjacent space...
// --> instead, use launder spaces to deal with spaces at the edges of block element

    for (;;)
    {
        MARKUP_CONTEXT_TYPE ct;
        long                cch = cchBuff;
        long                ich;
        TCHAR *             pch;

        IFC( pmp->IsLeftOf(pmpFinish, &fLeftOf) );
        if (!fLeftOf)
            break;

        //
        // It is quite possible to process text AFTER pmpFinish.  This
        // should not be a problem, but if it is, I should add a feature
        // to the There member to stop at a give pointer.  THis may be difficult
        // in that unembedded pointers will have to be searched!
        //

        IFC( pmp->Right(TRUE, &ct, NULL, &cch, pchBuff) );

        if (ct != CONTEXT_TYPE_Text)
            continue;

        //
        // See if we were not able to get the entire run of text into the buffer
        //

        if (cch == cchBuff)
        {
            long cchMore = -1;
            
            IFC( pmp->Right(TRUE, &ct, NULL, &cchMore, NULL) );

            //
            // In order to know if we got all the text, we try to get one more
            // char than we know is there.
            //

            Assert( cchBuff <= cch + cchMore );

            delete pchBuff;

            pchBuff = new TCHAR [ cch + cchMore + 1 ];

            if (!pchBuff)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchBuff = cch + cchMore + 1;

            //
            // Now, move the pointer back and attempt to get the text again.
            //

            cchMore += cch;

            IFC( pmp->Left(TRUE, NULL, NULL, & cchMore, NULL) );

            continue;
        }

        //
        // Now, examine the buffer for CR/LF or adjacent spaces
        //

        for ( ich = 0, pch = pchBuff ; ich < cch ; ich++, pch++ )
        {
            TCHAR ch = *pch;
            
            if (ch == _T('\r') || ch == _T('\n'))
            {
                long cchMoveBack, cchAfter;

                IFC( pmpCRLF->MoveToPointer(pmp) );

                cchMoveBack = cch - ich - 1;

                IFC( pmpCRLF->Left(TRUE, NULL, NULL, & cchMoveBack, NULL) );                
                IFC( SanitizeCrLf(pmpCRLF, cchAfter) );

                ich += cchAfter;
                pch += cchAfter;
            }
            else if (ch == _T(' ') && ich + 1 < cch && *(pch + 1) == _T(' '))
            {
                BOOL fShouldConvert;
                
                IFC( ConvertShouldCrLf(pmp, fShouldConvert) );
                if (fShouldConvert)
                {
                    long           cchMoveBack;
                    TCHAR          cpSpace;

                    IFC( pmpAfterSpace->MoveToPointer(pmp) );

                    cchMoveBack = cch - ich - 1;

                    IFC( pmpAfterSpace->Left(TRUE, NULL, NULL, &cchMoveBack, NULL) );
                    IFC( pmpBeforeSpace->MoveToPointer(pmpAfterSpace) );

                    cchMoveBack = 1;

                    IFC( pmpBeforeSpace->Left(TRUE, NULL, NULL, & cchMoveBack, NULL) );

                    IFC( GetMarkupServices()->Remove(pmpBeforeSpace, pmpAfterSpace) );

                    cpSpace = WCH_NBSP;

                    IFC( GetMarkupServices()->InsertText(&cpSpace, 1, pmpBeforeSpace) );
                }
            }
        }
    }

    IFC( LaunderEdge(pmpStart) );
    IFC( LaunderEdge(pmpFinish) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    ReleaseInterface(pmp);
    ReleaseInterface(pmpCRLF);
    ReleaseInterface(pmpBeforeSpace);
    ReleaseInterface(pmpAfterSpace);
    delete[] pchBuff;

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   IsAccessDivHack
//
//  Synopsis:   Avoid merging the access magic div
//
//-----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsAccessDivHack(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BSTR            bstrClass = NULL;
    BOOL            fResult = FALSE;

    if (!pElement)
        return FALSE;
    
    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    if (tagId != TAGID_DIV)
        return FALSE;

    IFC( pElement->get_className(&bstrClass) );
    if (!bstrClass)
        return FALSE;

    if (!StrCmpC(bstrClass, _T("MicrosoftAccessBanner")))
    {
        fResult = TRUE;
        goto Cleanup;
    }
    
    if (!StrCmpC(bstrClass, _T("MSOShowDesignGrid")))
    {
        fResult = TRUE;
        goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrClass);
    return fResult;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsLiteral
//
//    Synopsis:   Return whether the element is literal.
//
//    TODO: replace with public object model [ashrafm]
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsLiteral(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    Assert(pElement);

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    switch (tagId)
    {
        case TAGID_COMMENT:
        case TAGID_PLAINTEXT:
        case TAGID_SCRIPT:
        case TAGID_STYLE:
        case TAGID_TEXTAREA:
	case TAGID_INPUT:
        case TAGID_TITLE:
        case TAGID_XMP:
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsBlockElement
//
//    Synopsis:   Return whether the element is a block element.
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsBlockElement(IHTMLElement *pElement)
{
    HRESULT             hr;
    BOOL                fResult = FALSE;
    IHTMLCurrentStyle   *pCurStyle = NULL;
    IHTMLElement2       *pElement2 = NULL;
    BSTR                bstrDisplay = NULL;

    Assert(pElement);

    IFC( pElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElement2) );

    IFC( pElement2->get_currentStyle(&pCurStyle) );
    if (!pCurStyle)
        goto Cleanup;

    IFC(pCurStyle->get_display(&bstrDisplay));

    fResult = !_tcscmp(bstrDisplay, _T("block"));

Cleanup:
    ReleaseInterface(pCurStyle);
    ReleaseInterface(pElement2);
    SysFreeString(bstrDisplay);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsLayoutElement
//
//    Synopsis:   Return whether the element should have layout.
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsLayoutElement(IHTMLElement *pElement)
{
    HRESULT             hr;
    VARIANT_BOOL        fResult = VB_FALSE;
    IHTMLCurrentStyle   *pCurStyle = NULL;
    IHTMLCurrentStyle2  *pCurStyle2 = NULL;
    IHTMLElement2       *pElement2 = NULL;

    IFC( pElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElement2) );

    IFC( pElement2->get_currentStyle(&pCurStyle) );
    if (!pCurStyle)
        goto Cleanup;

    IFC( pCurStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&pCurStyle2) );
    IFC( pCurStyle2->get_hasLayout(&fResult) );

Cleanup:
    ReleaseInterface(pCurStyle);
    ReleaseInterface(pCurStyle2);
    ReleaseInterface(pElement2);

    return fResult ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsElementBlockInContext
//
//    Synopsis:    Return whether the element is a block in the current context
//                In general: Elements, if marked, are blocks and sites are not.
//                The exception is CFlowLayouts which are blocks when considered
//                from within themselves and are not when considered
//                from within their parent
//
//    Arguments:
//                [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsElementBlockInContext(IHTMLElement *pElemContext, IHTMLElement *pElement)
{
    HRESULT             hr;
    BOOL                fRet = FALSE;
    IObjectIdentity     *pIdent = NULL;
    BOOL                fContainer;
    BOOL                fBlockElement;

    IFC( pElemContext->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
    if (pIdent->IsEqualObject(pElement) == S_OK)
    {
        fRet = TRUE;
        goto Cleanup;
    }

    fContainer = GetEditor()->IsContainer(pElement);
    fBlockElement = IsBlockElement(pElement);
    if (!fContainer && !fBlockElement)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (!IsLayoutElement(pElement))
    {
        fRet = TRUE;
        goto Cleanup;
    }

    fRet = !fContainer;

    // TODO: talk to OM team about this method. [ashrafm]
    
Cleanup:
    ReleaseInterface(pIdent);
    
    return fRet;
}

HRESULT
CDeleteCommand::GetElementClient(
    IMarkupContainer    *pMarkupContainer,
    IHTMLElement        **ppElement)
{
    HRESULT             hr;
    IHTMLDocument2      *pDoc = NULL;
    IHTMLElement        *pElementClient = NULL;
    IMarkupContainer2   *pMarkupContainer2 = NULL;
    ELEMENT_TAG_ID      tagId;

    Assert(pMarkupContainer && ppElement);
    *ppElement = NULL;

    IFC( pMarkupContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );

    IFC( pDoc->get_body(&pElementClient) );
    if (!pElementClient)
        goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId(pElementClient, &tagId) );   
    if (tagId == TAGID_BODY || tagId == TAGID_FRAMESET)
    {
        *ppElement = pElementClient;
        (*ppElement)->AddRef();
        goto Cleanup;
    }

    IFC( pMarkupContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&pMarkupContainer2) );    
    IFC( pMarkupContainer2->GetMasterElement(ppElement) );    

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pElementClient);
    ReleaseInterface(pMarkupContainer2);
    
    RRETURN(hr);   
}


//+----------------------------------------------------------------------------
//
//  Functions:  EnsureLogicalOrder 
//
//  Synopsis:   Ensure logical order
//
//-----------------------------------------------------------------------------
HRESULT
CDeleteCommand::EnsureLogicalOrder(IMarkupPointer* & pStart, IMarkupPointer* & pFinish )
{
    HRESULT     hr;
    BOOL        fRightOf;
    
    Assert( pStart && pFinish );

    IFC( pStart->IsRightOf(pFinish, &fRightOf) );

    if (fRightOf)
    {
        IMarkupPointer * pTemp = pStart;
        pStart = pFinish;
        pFinish = pTemp;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::QueryBreaks
//
//  Synopsis:   Ensure logical order
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::QueryBreaks(IMarkupPointer *pStart, DWORD *pdwBreaks)
{
    HRESULT            hr;
    SP_IDisplayPointer spDispPointer;

    Assert(pdwBreaks);

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispPointer->QueryBreaks(pdwBreaks) );

    if (!(*pdwBreaks))
    {
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        IFC( spDispPointer->QueryBreaks(pdwBreaks) );
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::DeleteGlyphElements
//
//  Synopsis:   Remove all elements with glyphs between pStart and pEnd
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::DeleteGlyphElements(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT         hr;
    CEditPointer    ep(GetEditor());
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    
    IFC( ep->MoveToPointer(pStart) );
    IFC( ep.SetBoundaryForDirection(RIGHT, pEnd) );

    for (;;)
    {
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Glyph, &dwFound, &spElement) );
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;

        if (!IsBlockElement(spElement) && !IsLayoutElement(spElement))
        {
            IFC( GetMarkupServices()->RemoveElement(spElement) );
        }
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::CanRemove
//
//  Synopsis:   Will markup services do anything here?  This
//              method is primarily used to avoid generating empty
//              undo units.
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::CanRemove(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL *pfCanRemove)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer, spEdge;
    MARKUP_CONTEXT_TYPE context;
    SP_IHTMLElement     spElement;
    BOOL                fDone;

    Assert(pfCanRemove);

    *pfCanRemove = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spEdge) );

    IFC( spPointer->MoveToPointer(pStart) );

    //
    // Markup services will fail to remove any content iff the range is
    // empty and contains only scoped elements that are not entirely contained.
    //

    for (;;)
    {
        IFC( spPointer->IsRightOfOrEqualTo(pEnd, &fDone) );
        if (fDone)
            goto Cleanup;

        IFC( spPointer->Right(TRUE, &context, &spElement, NULL, NULL) );

        switch (context)
        {
            case CONTEXT_TYPE_None:
                goto Cleanup; // done

            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                *pfCanRemove = TRUE;
                goto Cleanup;
                
            case CONTEXT_TYPE_EnterScope:
                IFC( spEdge->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                IFC( spEdge->IsLeftOfOrEqualTo(pEnd, pfCanRemove) );
                if (*pfCanRemove)
                    goto Cleanup;
                break;

            case CONTEXT_TYPE_ExitScope:
                break; // don't need to check this, enterscope will get it

            default:
                AssertSz(0, "missing case");
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CDeleteCommand::AdjustPointersForAtomicDeletion(IMarkupPointer *pStart,
                                                IMarkupPointer *pEnd,
                                                BOOL *pfOkayForDeletion)
{
    HRESULT             hr;
    int                 wherePointer = SAME;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spAtomicElement;
    BOOL                fStartAdjustedForAtomic = FALSE;
    BOOL                fEndAdjustedForAtomic = FALSE;

    Assert(pStart);
    Assert(pEnd);
    Assert(pfOkayForDeletion);
    *pfOkayForDeletion = TRUE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( spStart->MoveToPointer(pStart) );

    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( spEnd->MoveToPointer(pEnd) );

    //  Adjust for atomic objects.

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    if (wherePointer == SAME)
    {
        IFC( pStart->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            IFC( spStart->MoveAdjacentToElement(spAtomicElement, ELEM_ADJ_BeforeBegin) );
            fStartAdjustedForAtomic = TRUE;

            IFC( spEnd->MoveAdjacentToElement(spAtomicElement, ELEM_ADJ_AfterEnd) );
            fEndAdjustedForAtomic = TRUE;
        }
    }
    else
    {
        IFC( pStart->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtBeforeEndOrAfterBegin = FALSE;
            BOOL                fStartPositioned = FALSE;

            //  Bug 101996: Two atomic elements are positioned next to each other.  If the cursor is positioned
            //  in between them and delete is pressed or we do a DeleteCharacter, both atomic elements will be
            //  deleted.  So, we need to see if the start pointer is at either the BeforeEnd or AfterBegin
            //  positions, depending on direction, of an atomic element.  If so, we need to position it at either
            //  the AfterEnd or BeforeBegin position depending on direction.  Otherwise the start pointer will
            //  be positioned at the beginning of the first atomic element.

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spAtomicElement ,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterBegin ) );
            
            IFC( spTestPointer->IsEqualTo(spStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( spStart->MoveAdjacentToElement( spAtomicElement,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                fStartPositioned = TRUE;
            }

            if (!fStartPositioned)
            {
                IFC( spStart->MoveAdjacentToElement( spAtomicElement ,
                                                    wherePointer ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
            }

            fStartAdjustedForAtomic = TRUE;
        }
        
        IFC( pEnd->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtAfterBeginOrBeforeEnd = FALSE;
            BOOL                fEndPositioned = FALSE;

            //  Bug 102000: Two atomic elements are positioned next to each other.  If the first atomic element
            //  is selected and a user types something, both atomic elements will be deleted.  So, we need to
            //  do a similar check as above to see if the end pointer is at the AfterBegin or BeforeEnd position.

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spAtomicElement ,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );
            
            IFC( spTestPointer->IsEqualTo(spEnd, &fAtAfterBeginOrBeforeEnd) );
            if (fAtAfterBeginOrBeforeEnd)
            {
                IFC( spEnd->MoveAdjacentToElement( spAtomicElement ,
                                                  wherePointer ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
                fEndPositioned = TRUE;
            }

            if (!fEndPositioned)
            {
                IFC( spEnd->MoveAdjacentToElement( spAtomicElement ,
                                                  wherePointer ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));
            }

            fEndAdjustedForAtomic = TRUE;
        }
    }

    if ( fStartAdjustedForAtomic || fEndAdjustedForAtomic )
    {
        if ( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            if (fStartAdjustedForAtomic)
            {
                IFC( pStart->MoveToPointer(spStart) );
            }
            if (fEndAdjustedForAtomic)
            {
                IFC( pEnd->MoveToPointer(spEnd) );
            }
        }
        else
        {
            *pfOkayForDeletion = FALSE;
        }
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::FindContentAfterBlock
//
//  Synopsis:   Move a markup pointer to the first content after the block
// 
//-----------------------------------------------------------------------------


HRESULT
CDeleteCommand::FindContentAfterBlock(Direction dir, IMarkupPointer *pPointer)
{
    HRESULT         hr;
    DWORD           dwBreaks;
    DWORD           dwFound;
    DWORD           dwPhrase;
    CEditPointer    epNext(GetEditor());
    
    dwPhrase = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content - BREAK_CONDITION_Glyph;

    IFC( epNext->MoveToPointer(pPointer) );

    for (;;)
    {
        IFC( epNext.Scan(dir, BREAK_CONDITION_ANYTHING, &dwFound) );

        //
        // Check for site or non-block
        //
        
        if (epNext.CheckFlag(dwFound, BREAK_CONDITION_Site)
            || epNext.CheckFlag(dwFound, BREAK_CONDITION_NoScopeSite)
            || !epNext.CheckFlag(dwFound, BREAK_CONDITION_Block | dwPhrase) )
        {
            break; // we're done
        }

        //
        // Commit
        //

        IFC( pPointer->MoveToPointer(epNext) );

        //
        // Check for block break
        //

        IFC( QueryBreaks(pPointer, &dwBreaks) ); 
        if ( dwBreaks & DISPLAY_BREAK_Block || dwBreaks & DISPLAY_BREAK_Break)
        {
            // 
            // Cling to the block element on the left so merge deletion works
            //
            if (epNext.CheckFlag(dwFound, dwPhrase))
            {
                IFC( epNext.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
                IFC( epNext.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

                IFC( pPointer->MoveToPointer(epNext) );
            }
            break;                             
        }
    }        

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\dlgcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CDialogCommand, EditCommand, "CDialogCommand")

//
// s_dlgInfo[] table provides the required mapping between IDM's for supported dialogs
// and their corresponding resource id as well as undo text.
//

static const struct DialogInfo
{
    UINT    idm;
    UINT    idsUndoText;
    TCHAR * szidr;
}
s_dlgInfo[] =
{
    {IDM_REPLACE,       IDS_EDUNDOGENERICTEXT,   IDR_REPLACEDIALOG},
    {IDM_PARAGRAPH,     IDS_EDUNDOGENERICTEXT,   IDR_FORPARDIALOG},
    {IDM_FONT,          IDS_EDUNDOGENERICTEXT,   IDR_FORCHARDIALOG},
    {IDM_IMAGE,         IDS_EDUNDONEWCTRL,       IDR_INSIMAGEDIALOG},
    {IDM_HYPERLINK,     IDS_EDUNDOGENERICTEXT,   IDR_EDLINKDIALOG}
    // Not implemented in IE40
    //{IDM_GOTO,          0,                     IDR_GOBOOKDIALOG},
    //{IDM_BOOKMARK,      IDS_UNDOGENERICTEXT,   IDR_EDBOOKDIALOG},
};

//
// Forward references
//

HRESULT LoadProcedure(DYNPROC *pdynproc);

void DeinitDynamicLibraries();

//+---------------------------------------------------------------------------
//
//  CDialogCommand Constructor
//
//----------------------------------------------------------------------------

CDialogCommand::CDialogCommand(DWORD cmdId, CHTMLEditor * ped ) : CCommand( cmdId, ped )
{
}


//+---------------------------------------------------------------------------
//
//  CDialogCommand Destructor
//
//----------------------------------------------------------------------------

CDialogCommand::~CDialogCommand()
{
}

//+---------------------------------------------------------------------------
//
//  CDialogCommand Exec
//
//----------------------------------------------------------------------------

HRESULT 
CDialogCommand::PrivateExec( DWORD nCmdexecopt,
                  VARIANTARG * pvarargIn,
                  VARIANTARG * pvarargOut )
{
    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    HWND            myHWND;
    IDispatch  *    pDisp = NULL;
    VARIANT         varDoc; 
    VARIANT         varReturn;
    OLECMD          cmd;
    SP_IOleWindow   spOleWindow;

    Assert( nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER || pvarargIn == NULL);

    hr = THR( PrivateQueryStatus(&cmd, NULL) );
    if (hr)
        goto Cleanup;

    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    hr = GetEditor()->GetDoc()->QueryInterface( IID_IDispatch, (void**) &pDisp );
    if (hr)                                                       
        goto Cleanup;

    VariantInit(&varDoc);
    V_VT(&varDoc) = VT_DISPATCH;
    V_DISPATCH(&varDoc) = pDisp;

    hr = THR(GetEditor()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if( hr )
        goto Cleanup;
    hr = THR(spOleWindow->GetWindow(&myHWND));
    if( hr )
        goto Cleanup;

    //
    // Note that cmdId's for dialogs have been negated.
    // Here we're un-negating them so that ShowEditDialog can find the proper resource.
    //
    hr = THR( ShowEditDialog( ~_cmdId, &varDoc, myHWND, &varReturn, GetEditor()->GetMarkupServices() ));
    
Cleanup:
    ReleaseInterface(pDisp);
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CDialogCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT 
CDialogCommand::PrivateQueryStatus( 
	OLECMD rgCmds[],
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    SELECTION_TYPE          eSelectionType;

    rgCmds->cmdf = MSOCMDSTATE_UP; // up by default
    
    //
    // If hyperlink, allow on a control.  Otherwise, return disabled for a control.
    //
    
    if ((~_cmdId) == IDM_HYPERLINK)
        return S_OK;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType(&eSelectionType) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if (eSelectionType == SELECTION_TYPE_Control)    
    {
        if ( (~_cmdId) != IDM_IMAGE )
        {
            rgCmds->cmdf = MSOCMDSTATE_DISABLED;
        }
        else if( !fEmpty )
        {
            ELEMENT_TAG_ID  eTag;
            SP_IHTMLElement spElement;

            IFC( spSegmentList->CreateIterator( &spIter ) );
            IFC( spIter->Current(&spSegment) );

            IFC( GetSegmentElement( spSegment, &spElement) );

            if (! spElement)
                goto Cleanup;

            IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
            if ( eTag != TAGID_IMG )
            {
                rgCmds->cmdf = MSOCMDSTATE_DISABLED;
            }
        }
    }

    if (((~_cmdId) == IDM_FONT) && !CanAcceptHTML(spSegmentList))
    {
        rgCmds->cmdf = MSOCMDSTATE_DISABLED;      
    }

Cleanup:    
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   CreateResourceMoniker
//
//  Synopsis:   Creates a new moniker based off a resource file & rid
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDialogCommand::CreateResourceMoniker(
    HINSTANCE hInst,
    TCHAR *pchRID,
    IMoniker **ppmk)
{
    HRESULT         hr = S_OK;
    TCHAR           ach[pdlUrlLen];
    HINSTANCE       hinstDll;	//DLL containing the Pluggable UI html for dialog boxes

    IFC( GetEditResourceLibrary (&hinstDll) );

    _tcscpy(ach, _T("res://"));

    if (!GetModuleFileName(
            hinstDll,
            ach + _tcslen(ach),
            pdlUrlLen - (_tcslen(ach) + _tcslen(pchRID) + 2)))  //2: one is for the null terminator, one is for '/'
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(ach, _T('/'));
        if (p)
    {
            int iLen = _tcslen(++p);
            memmove(ach + 6, p, sizeof(TCHAR) * iLen);
            ach[6 + iLen] = _T('\0');
    }
    }
#endif

    _tcscat(ach, _T("/"));
    _tcscat(ach, pchRID);

    hr = THR(CreateURLMoniker(NULL, ach, ppmk));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ShowEditDialog
//
//  Synopsis:   Given an IDM, brings up the corresponding dialog using
//              the C API ShowHTMLDialog()
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

DYNLIB g_dynlibMSHTML = { NULL, NULL, "MSHTML.DLL" };

DYNPROC s_dynprocShowHTMLDialog = { NULL, &g_dynlibMSHTML, "ShowHTMLDialog" };

HRESULT
CDialogCommand::ShowEditDialog(UINT idm, VARIANT * pvarExecArgIn, 
                               HWND hwndParent, VARIANT * pvarArgReturn, 
                               IMarkupServices * pMarkupServices)
{
    HRESULT             hr = S_OK;
    int                 i;
    HINSTANCE           hinst = NULL;
    IMoniker *          pMoniker = NULL;
    SHOWHTMLDIALOGFN *  pfnShowHTMLDialog;
    CEdUndoHelper           undoUnit( GetEditor() );

    // find resource id string
    for (i = 0; i < ARRAY_SIZE(s_dlgInfo); ++i)
    {
        if (idm == s_dlgInfo[i].idm)
            break;
    }
    Assert(i < ARRAY_SIZE(s_dlgInfo));

    // Load the C API procedure from Mshtml.dll
    hr = THR(LoadProcedure(&s_dynprocShowHTMLDialog));
    if (!OK(hr))
        goto Cleanup;

    hinst = s_dynprocShowHTMLDialog.pdynlib->hinst;
    if (!hinst)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Make the resource moniker
    hr = THR(CreateResourceMoniker(
            hinst,
            s_dlgInfo[i].szidr,
            &pMoniker));
    if (hr)
        goto Cleanup;

    // Begin the undo unit
    hr = THR( undoUnit.Begin( s_dlgInfo[i].idsUndoText ) );
    if (hr)
        goto Cleanup;

    // bring up the dialog
    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)(s_dynprocShowHTMLDialog.pfn);
    hr = (*pfnShowHTMLDialog)(hwndParent, pMoniker, pvarExecArgIn, NULL, pvarArgReturn);
    if (hr)
        goto Cleanup;

Cleanup:
    DeinitDynamicLibraries();
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\edcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_SELMAN_HXX_
#define _X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

MtDefine(EditCommand, Edit, "Commands")
MtDefine(CCommand, EditCommand, "CCommand")
MtDefine(CCommandTable, EditCommand, "CCommandTable")

DeclareTag(tagEdCmd, "Edit", "Command Routing")


//
// CCommandTable
//

CCommandTable::CCommandTable(unsigned short iInitSize)
{
    _rootNode = NULL;
}

CCommandTable::~CCommandTable()
{
    // TODO - Make this non-recursive
    // We want to delete all the pointers in the command table
    _rootNode->Passivate();

}


void CCommand::Passivate()
{
    if( _leftNode )
        _leftNode->Passivate();

    if( _rightNode )
        _rightNode->Passivate();

    delete this;
}    


CCommand::CCommand( 
    DWORD                     cmdId, 
    CHTMLEditor *             pEd )
{
    _pEd = pEd;
    _cmdId = cmdId;
    _leftNode = NULL;
    _rightNode = NULL;

}

CHTMLEditor * 
CCommand::GetEditor()
{ 
    return _pEd;
}

IHTMLDocument2* 
CCommand::GetDoc() 
{ 
    return _pEd->GetDoc(); 
}

IMarkupServices2* 
CCommand::GetMarkupServices() 
{ 
    return _pEd->GetMarkupServices();
}

IDisplayServices* 
CCommand::GetDisplayServices() 
{ 
    return _pEd->GetDisplayServices();
}

BOOL
CCommand::IsSelectionActive()
{
    HRESULT         hr;
    SP_ISegmentList spSegmentList;
    SELECTION_TYPE  eSelectionType;
    BOOL            fEmpty = FALSE;
    
    // If the selection is still active, do nothing for the command
    //

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType(&eSelectionType) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if( (eSelectionType == SELECTION_TYPE_Text) && (fEmpty == FALSE) )
    {
        CSelectionManager *pSelMan = GetEditor()->GetSelectionManager();        
        if (pSelMan->GetActiveTracker() && pSelMan->GetSelectionType() == SELECTION_TYPE_Text)
        {
            CSelectTracker *pSelectTracker = DYNCAST(CSelectTracker, pSelMan->GetActiveTracker());

            if (!pSelectTracker->IsPassive() && ! pSelectTracker->IsWaitingForMouseUp() )
                return TRUE; // done
        }
    }

Cleanup:
    return FALSE;
}    

CMshtmlEd* 
CCommand::GetCommandTarget()
{
    return GetEditor()->TopCommandTarget();
}

HRESULT 
CCommand::Exec( 
    DWORD                    nCmdexecopt,
    VARIANTARG *             pvarargIn,
    VARIANTARG *             pvarargOut,
    CMshtmlEd *              pTarget  )
{
    HRESULT           hr, hrResult;
    BOOL              fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(pvarargOut == NULL);

    IFC( GetEditor()->PushCommandTarget(pTarget) );

    hrResult = THR( PrivateExec( nCmdexecopt, pvarargIn, pvarargOut ));
    
    IFC( GetEditor()->PopCommandTarget( WHEN_DBG(pTarget) ) );

    hr = hrResult;
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN( hr );
}    

HRESULT 
CCommand::QueryStatus( 
    OLECMD                     rgCmds[],
    OLECMDTEXT *             pcmdtext,
    CMshtmlEd *              pTarget  )
{
    HRESULT hr = S_OK;
    HRESULT hrResult = S_OK;

    IFC( GetEditor()->PushCommandTarget(pTarget) );

    //
    // Put any command that we want to enable in 
    // IME COMPOSITION mode here. 
    // For now, simply disable most edit CMD here.      
    // [zhenbinx]
    //
    switch (rgCmds[0].cmdID)
    {
        case IDM_IME_ENABLE_RECONVERSION:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_FONTNAME:
        case IDM_FONTSIZE:
            //
            // Put the Cmds we want to enable here
            //
            break;
            
        default:
            if (GetEditor() && GetEditor()->GetSelectionManager())
            {
                if (GetEditor()->GetSelectionManager()->IsIMEComposition())
                {
                    TraceTag((tagEdCmd, "DISABLED cmd %d due to IME composition", rgCmds[0].cmdID));
                    rgCmds[0].cmdf = MSOCMDSTATE_DISABLED;
                    goto Finished;
                }
            }
            break;
    }
    hrResult = THR( PrivateQueryStatus( rgCmds, pcmdtext ));

Finished:
    IFC( GetEditor()->PopCommandTarget( WHEN_DBG(pTarget) ) );

    hr = hrResult;
    
Cleanup:
    RRETURN( hr );
}    
 

HRESULT
CCommand::GetSegmentList( ISegmentList ** ppSegmentList ) 
{ 
    HRESULT hr = E_UNEXPECTED;
    AssertSz( GetCommandTarget() != NULL , "Attempt to get the segment list without a valid command target." );
    if( GetCommandTarget() == NULL )
        goto Cleanup;
        
    hr = THR( GetCommandTarget()->GetSegmentList( ppSegmentList ));

Cleanup:
    RRETURN( hr );
}

BOOL
CCommand::SegmentListContainsPassword( ISegmentList *pISegmentList )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );
    BOOL                    fPassword = FALSE;
    BOOL                    fEmpty = FALSE;

    Assert(pISegmentList);
    IFC( pISegmentList->IsEmpty( &fEmpty ) );
    
    if (!fEmpty)
    {
        IFC( pISegmentList->CreateIterator(&spIter) );
        Assert(S_FALSE == spIter->IsDone());

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current(&spSegment) );
            IFC( spIter->Advance() );
        
            IFC( spSegment->GetPointers(edStart, edEnd) );
            IFC( edStart->CurrentScope(&spElement) );

            if (spElement == NULL)
                continue;
                
            IFC( GetEditor()->IsPassword(spElement, &fPassword) );
            if (fPassword)
                break;
        }
    }

Cleanup:
    return fPassword;
}

CSpringLoader*
CCommand::GetSpringLoader() 
{ 
    AssertSz( GetCommandTarget() != NULL , "Attempt to get the spring loader without a valid command target." );
    if( GetCommandTarget() == NULL )
        return NULL;

    return GetCommandTarget()->GetSpringLoader();
}

BOOL
CCommand::CanSplitBlock( IMarkupServices *pMarkupServices , IHTMLElement* pElement )
{
    ELEMENT_TAG_ID curTag = TAGID_NULL;

    THR( pMarkupServices->GetElementTagId( pElement, &curTag  ));

    //
    // TODO: make sure this is a complete list [ashrafm]
    //
    
    switch( curTag )
    {
        case TAGID_P:
        case TAGID_DIV:
        case TAGID_LI:
        case TAGID_BLOCKQUOTE:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_HR:
        case TAGID_CENTER:
        case TAGID_PRE:
        case TAGID_ADDRESS:
            return true;

        default:
            return false;
    }
}


CCommand::~CCommand()
{
}


//+==========================================================================
//  CCommandTable::Add
//
//  Add an entry to the command table.
//
//---------------------------------------------------------------------------

VOID
CCommandTable::Add( CCommand* pCommandEntry )
{
    CCommand* pInsertNode = NULL;

    if ( _rootNode == NULL )
        _rootNode = pCommandEntry;
    else
    {
        Verify(!FindEntry( pCommandEntry->GetCommandId() , &pInsertNode));
        Assert( pInsertNode );

        if ( pInsertNode->GetCommandId() > pCommandEntry->GetCommandId() )
            pInsertNode->SetLeft( pCommandEntry );
        else
            pInsertNode->SetRight( pCommandEntry );
    }

}

//+==========================================================================
//  CCommandTable::Get
//
//  Get the Contents of a Node with the given key entry - or null if none exists
//
//---------------------------------------------------------------------------

CCommand*
CCommandTable::Get(DWORD entryKey )
{
    CCommand* pFoundNode = NULL;

    if (  FindEntry( entryKey, &pFoundNode ) )
    {
        Assert( pFoundNode );
        return pFoundNode ;
    }
    else
    {
        return NULL;
    }
}

//+==========================================================================
//  CCommandTable::FindEntry
//
//  Find a given key entry.
//
//  RESULT:
//      1  - we found an entry with the given key. pFoundNode points to it
//      0  - didn't find an entry. pFoundNode points to the last node in the tree
//           where we were. You can test pFoundNode for where to insert the next node.
//
//---------------------------------------------------------------------------

short
CCommandTable::FindEntry(DWORD entryKey, CCommand** ppFoundNode )
{
    CCommand *pCommandEntry = _rootNode;
    short result = 0;

    while ( pCommandEntry != NULL)
    {
        if ( pCommandEntry->GetCommandId() == entryKey)
        {
            result = 1;
            *ppFoundNode = pCommandEntry;
            break;
        }
        else
        {
            *ppFoundNode = pCommandEntry;

            if ( pCommandEntry->GetCommandId() > entryKey )
            {
                pCommandEntry = pCommandEntry->GetLeft();
            }
            else
                pCommandEntry = pCommandEntry->GetRight();
        }
    }

    return result;
}

#if DBG == 1
VOID
CCommand::DumpTree( IUnknown* pUnknown)
{
    IOleCommandTarget  *  pHost = NULL;
    Assert( pUnknown );
    GUID theGUID = CGID_MSHTML;
    IGNORE_HR( pUnknown->QueryInterface( IID_IOleCommandTarget,  (void**)& pHost ) ) ;
    IGNORE_HR( pHost->Exec( &theGUID , IDM_DEBUG_DUMPTREE, 0, NULL, NULL  ));

    ReleaseInterface( pHost );

}

#endif

//+---------------------------------------------------------------------------
//
//  CCommand::GetSegmentElement
//
//----------------------------------------------------------------------------
HRESULT CCommand::GetSegmentElement(IMarkupServices *pMarkupServices, 
                                    IMarkupPointer  *pStart, 
                                    IMarkupPointer  *pEnd, 
                                    IHTMLElement    **ppElement,
                                    BOOL            fOuter)
{
    HRESULT             hr = E_FAIL;
    MARKUP_CONTEXT_TYPE context, contextGoal;
    IHTMLElement        *pElementRHS = NULL;
    IObjectIdentity     *pObjectIdent = NULL;    

    *ppElement = NULL;
    
    //
    // Is there an element right at this position?  If so,
    // return it.  Otherwise, fail.
    //
    
    //
    // Find the left side element
    //

    if (fOuter)
    {
        if (FAILED(THR( pStart->Left( FALSE, &context, ppElement, NULL, NULL ))))
            goto Cleanup;
            
        contextGoal = CONTEXT_TYPE_ExitScope;
    }
    else
    {
        if (FAILED(THR(pStart->Right( FALSE, &context, ppElement, NULL, NULL ))))
            goto Cleanup;
            
        contextGoal = CONTEXT_TYPE_EnterScope;
    }
        
    if (context != contextGoal && (context != CONTEXT_TYPE_NoScope || !(*ppElement)))
        goto Cleanup; // fail

    //
    // Check to see if the right side is a div element
    //

    if (fOuter)
    {
        if (FAILED(THR(pEnd->Right( FALSE, &context, &pElementRHS, NULL, NULL ))))
            goto Cleanup;
    }
    else
    {
        if (FAILED(THR(pEnd->Left(FALSE, &context, &pElementRHS, NULL, NULL))))
            goto Cleanup;
    }

    if (context != contextGoal && (context != CONTEXT_TYPE_NoScope || !(*ppElement)))
        goto Cleanup; // fail

    //
    // Check if the elements are the same
    //

    if (FAILED(THR(pElementRHS->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pObjectIdent))))
        goto Cleanup; // fail

    hr = THR(pObjectIdent->IsEqualObject(*ppElement));

Cleanup:
    if (FAILED(hr))
        ClearInterface(ppElement);

    ReleaseInterface(pElementRHS);
    ReleaseInterface(pObjectIdent);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:       SplitInfluenceElement
//
//  Synopsis:     Given an IHTMLElement* that influences a pair of pointers - adjust the element's
//                influence - so it no longer influences the range
//
//                Various Remove and Insert Operations will be involved here.
//
//  ppElementNew - if passed in a Pointer to a New Element, and a New Element is created
//                  this returns the new element that's been created.
//----------------------------------------------------------------------------
HRESULT
CCommand::SplitInfluenceElement(
                    IMarkupServices * pMarkupServices,
                    IMarkupPointer* pStart,
                    IMarkupPointer* pEnd,
                    IHTMLElement* pElement,
                    elemInfluence inElemInfluence,
                    IHTMLElement** ppElementNew )
{
    IMarkupPointer *pStartPointer = NULL ;
    IMarkupPointer *pEndPointer = NULL ;
    IHTMLElement *pNewElement = NULL;
    HRESULT hr = S_OK;
    BOOL    bEqual = FALSE;

    switch ( inElemInfluence )
    {
        case elemInfluenceWithin:
        {
            hr = pMarkupServices->RemoveElement( pElement );
        }
        break;

        case elemInfluenceCompleteContain:
        {
            hr = GetEditor()->CreateMarkupPointer( & pStartPointer   );
            if (!hr) hr = pStartPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin );
            if (!hr) hr = pStartPointer->SetGravity(POINTER_GRAVITY_Right);
            if (!hr) hr = GetEditor()->CreateMarkupPointer( & pEndPointer );
            if (!hr) hr = pEndPointer->SetGravity(POINTER_GRAVITY_Left);
            if (!hr) hr = pEndPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd );
            if (hr) goto Cleanup;

            hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pStartPointer->IsEqualTo(pStart, &bEqual));
            if (hr) goto Cleanup;
            
            if (!bEqual)
            {
                hr = InsertElement(pMarkupServices, pElement, pStartPointer, pStart );
                if (hr) goto Cleanup;
            }

            hr = THR(pEndPointer->IsEqualTo(pEnd, &bEqual));
            if (hr) goto Cleanup;
            
            if (!bEqual)
            {
                hr = pMarkupServices->CloneElement( pElement, &pNewElement );
                if (!hr) hr = InsertElement(pMarkupServices, pNewElement, pEnd , pEndPointer );
            }

            if ( ppElementNew )
            {
                *ppElementNew = pNewElement;
            }
        }
        break;

        case elemInfluenceOverlapWithin:
        {
            hr = GetEditor()->CreateMarkupPointer( & pEndPointer   );
            if (!hr) hr = pEndPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd );
            if (hr) goto Cleanup;

            if (!hr) hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pEndPointer->IsEqualTo(pEnd, &bEqual));
            if (hr) goto Cleanup;

            if (!bEqual)
            {
                hr = InsertElement(pMarkupServices, pElement, pEnd, pEndPointer );
            }

        }
        break;

        case elemInfluenceOverlapOutside:
        {
            hr = GetEditor()->CreateMarkupPointer( & pStartPointer   );
            if (!hr) hr = pStartPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin );
            if (hr) goto Cleanup;

            hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pStart->IsEqualTo(pStartPointer, &bEqual));
            if (hr) goto Cleanup;

            if (!bEqual)
            {
                if ( ! hr ) hr = InsertElement(pMarkupServices, pElement, pStartPointer, pStart );
                if (hr) goto Cleanup;
            }
        }
        break;
    }

Cleanup:
    ReleaseInterface( pStartPointer );
    ReleaseInterface( pEndPointer );
    if ( ! ppElementNew ) ReleaseInterface( pNewElement );

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:       GetElementInfluenceOverPointers
//
//  Synopsis:     Given an IHTMLElement* determine how that tag Influences
//                the pair of tree pointers.
//
//                See header file EdTree.hxx for description of different
//                values of tagInfluence
//
//----------------------------------------------------------------------------

// TODO: be careful about contextually equal pointers here [ashrafm]

elemInfluence
CCommand::GetElementInfluenceOverPointers( IMarkupServices* pMarkupServices, IMarkupPointer* pStart, IMarkupPointer * pEnd, IHTMLElement* pInfluenceElement )
{
    elemInfluence theInfluence = elemInfluenceNone ;
    int iStartStart, iStartEnd, iEndStart, iEndEnd;
    iStartStart = iStartEnd = iEndStart = iEndEnd = 0;
    IMarkupPointer *pStartInfluence = NULL ;
    IMarkupPointer *pEndInfluence = NULL ;

    GetEditor()->CreateMarkupPointer( & pStartInfluence );
    GetEditor()->CreateMarkupPointer( & pEndInfluence );
    Assert( pStartInfluence && pEndInfluence );
    pStartInfluence->MoveAdjacentToElement( pInfluenceElement, ELEM_ADJ_BeforeBegin );
    pEndInfluence->MoveAdjacentToElement( pInfluenceElement, ELEM_ADJ_AfterEnd );

    OldCompare( pStart, pStartInfluence, &iStartStart);
    OldCompare( pEnd, pEndInfluence, & iEndEnd);

    if ( iStartStart == RIGHT ) // Start is to Right of Start of Range
    {
        if ( iEndEnd == LEFT ) // End is to Left of End of Range
            theInfluence = elemInfluenceWithin;
        else
        {
            // End is Inside Range - where is the Start ?

            OldCompare( pEnd, pStartInfluence, & iStartEnd );
            if ( iStartEnd == LEFT ) // Start is Inside Range, End is Outside
            {
                theInfluence = elemInfluenceOverlapWithin;
            }
            else
                theInfluence = elemInfluenceNone; // completely outside range
        }
    }
    else // Start is to Left of Range.
    {
        if ( iEndEnd == RIGHT ) // End is Outside
            theInfluence = elemInfluenceCompleteContain;
        else
        {
            // Start is Outside Range - where does End Start
            OldCompare( pStart, pEndInfluence, &iEndStart );
            if ( iEndStart == RIGHT )
            {
                // End is to Right of Start
                theInfluence = elemInfluenceOverlapOutside;
            }
            else
                theInfluence = elemInfluenceNone;
        }
    }

    ReleaseInterface( pStartInfluence );
    ReleaseInterface( pEndInfluence );

    return theInfluence;
}


//=========================================================================
// CCommand: GetSegmentPointers
//
// Synopsis: Get start/end pointers for a specified segment
//-------------------------------------------------------------------------

HRESULT CCommand::GetFirstSegmentPointers(ISegmentList    *pSegmentList,
                                          IMarkupPointer  **ppStart,
                                          IMarkupPointer  **ppEnd)
{
    HRESULT                 hr;
    IMarkupPointer          *pStart = NULL;
    IMarkupPointer          *pEnd = NULL;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    
    // We need these guys so either use the users pointers or local ones
    if (ppStart == NULL)
        ppStart = &pStart;

    if (ppEnd == NULL)
        ppEnd = &pEnd;

    // Move pointers to segment
    IFC(GetEditor()->CreateMarkupPointer(ppStart));
    IFC(GetEditor()->CreateMarkupPointer(ppEnd));

    // Create the iterator, and retrieve the first segment.  This will
    // fail if no first segment exists
    IFC( pSegmentList->CreateIterator( &spIter ) );
    IFC( spIter->Current( &spSegment ) )
    
    IFC( spSegment->GetPointers( *ppStart, *ppEnd ));

Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    RRETURN(hr);
}

//=========================================================================
//
// CCommand: ClingToText
//
//-------------------------------------------------------------------------
HRESULT
CCommand::ClingToText(IMarkupPointer *pMarkupPointer, Direction direction, IMarkupPointer *pLimit, 
                      BOOL fSkipExitScopes /* = FALSE */, BOOL fIgnoreWhiteSpace /* = FALSE */)
{
    HRESULT             hr;
    CEditPointer        epPosition(GetEditor(), pMarkupPointer);
    DWORD               dwSearch, dwFound;
    DWORD               dwSearchReverse;
    DWORD               dwScanOptions = SCAN_OPTION_SkipControls;

    if (fIgnoreWhiteSpace)
        dwScanOptions |= SCAN_OPTION_SkipWhitespace;

    Assert(direction == LEFT || direction == RIGHT);

    // Set boundary on the edit pointer
    if (pLimit)
    {
        if (direction == LEFT)
            IFR( epPosition.SetBoundary(pLimit, NULL) )        
        else
            IFR( epPosition.SetBoundary(NULL, pLimit) );            
    }

    // Do cling to text
    dwSearch = BREAK_CONDITION_Text           |
               BREAK_CONDITION_NoScopeSite    |
               BREAK_CONDITION_NoScopeBlock   |
               BREAK_CONDITION_ExitSite       | 
               (fSkipExitScopes ? 0 : BREAK_CONDITION_ExitBlock)     |
               BREAK_CONDITION_Control;

    IFR( epPosition.Scan(direction, dwSearch, &dwFound, NULL, NULL, NULL, dwScanOptions) );
    
    if (!epPosition.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
    {
        dwSearchReverse = BREAK_CONDITION_Text           |
                          BREAK_CONDITION_NoScopeSite    |
                          BREAK_CONDITION_NoScopeBlock   |
                          BREAK_CONDITION_EnterSite      | 
                          (fSkipExitScopes ? 0: BREAK_CONDITION_EnterBlock)     |
                          BREAK_CONDITION_Control;

        // move back before break condition
        IFR( epPosition.Scan(Reverse(direction), dwSearchReverse, &dwFound, NULL, NULL, NULL, dwScanOptions) );     }

    // Return pMarkupPointer
    IFR( pMarkupPointer->MoveToPointer(epPosition) );

    return S_OK;
}

//=========================================================================
//
// CCommand: Move
//
//-------------------------------------------------------------------------

HRESULT 
CCommand::Move(
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    HRESULT                 hr;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;
    SP_IMarkupPointer       spPointer;
    ELEMENT_TAG_ID          tagId;
    BOOL                    fSite;

    Assert(direction == LEFT || direction == RIGHT);

    if (!fMove)
    {
        IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFR( spPointer->MoveToPointer(pMarkupPointer) );
        
        pMarkupPointer = spPointer; // weak ref 
    }
    
    for (;;)
    {
        if (direction == LEFT)
            IFC( pMarkupPointer->Left( TRUE, &context, &spElement, NULL, NULL ) )
        else
            IFC( pMarkupPointer->Right( TRUE, &context, &spElement, NULL, NULL ) );

        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                if (IsIntrinsic(GetMarkupServices(), spElement))
                {
                    if (direction == LEFT)
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) )
                    else
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ) ); 
                }
                // fall through
                           
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_None:
                goto Cleanup; // done;
                break;  

            case CONTEXT_TYPE_NoScope:                
                IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fSite));
                if (!fSite)
                {
                    // We don't want to move past BRs - bug69300.
                    ELEMENT_TAG_ID tagIdElement;

                    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagIdElement) );
                    if (tagIdElement == TAGID_BR)
                        goto Cleanup;

                    continue;
                }
                    
                goto Cleanup; // done;
                break;  
                            
            default:
                AssertSz(0, "CBaseCharCommand: Unsupported context");
                hr = E_FAIL; // CONTEXT_TYPE_None
                goto Cleanup;
        }
    }
    
Cleanup:
    if (ppElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppElement = spElement;
            if (*ppElement)
                (*ppElement)->AddRef();
        }
        else
        {
            *ppElement = NULL;
        }
    }
        
    if (pContext)
    {
        *pContext = (SUCCEEDED(hr)) ? context : CONTEXT_TYPE_None;
    }    

    RRETURN(hr);
}

//=========================================================================
//
// CCommand: MoveBack
//
//-------------------------------------------------------------------------

HRESULT 
CCommand::MoveBack(
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    if (direction == RIGHT)
    {
        RRETURN(Move(pMarkupPointer, LEFT, fMove, pContext, ppElement));
    }
    else
    {
        Assert(direction == LEFT);
        RRETURN(Move(pMarkupPointer, RIGHT, fMove, pContext, ppElement));
    }
}

//=========================================================================
// CCommand: GetActiveElemSegment
//
// Synopsis: Gets the segment for the active element
//-------------------------------------------------------------------------
HRESULT 
CCommand::GetActiveElemSegment( IMarkupServices *pMarkupServices,
                                IMarkupPointer  **ppStart,
                                IMarkupPointer  **ppEnd)
{
    HRESULT        hr;
    IHTMLElement   *pElement = NULL;
    IMarkupPointer *pStart = NULL;
    IMarkupPointer *pEnd = NULL;
    VARIANT_BOOL    fScoped;    
    IHTMLDocument2* pDoc = GetDoc();
    SP_IHTMLElement2 spElement2;
    
#if 0
    hr = THR(pMarkupServices->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pMarkupServices->QueryInterface(IID_IHTMLViewServices, (LPVOID *)&pVS));
    if (FAILED(hr))
        goto Cleanup;    
#endif //0
    
    hr = THR( pDoc->get_activeElement(&pElement));
    if (FAILED(hr) || !pElement)
        goto Cleanup;

    //
    // If a No-Scope is Active - don't position pointers inside.
    //
    IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC( spElement2->get_canHaveChildren( &fScoped ));
    if ( !fScoped )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = GetEditor()->CreateMarkupPointer(&pStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetEditor()->CreateMarkupPointer(&pEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    if (FAILED(hr))
        goto Cleanup;
        
    hr = THR(pEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ));

Cleanup:
    if (SUCCEEDED(hr))
    {
        if (ppStart)
        {
            *ppStart = pStart;
            if (pStart)
                pStart->AddRef();
        }
        if (ppEnd)
        {
            *ppEnd = pEnd;
            if (pEnd)
                pEnd->AddRef();
        }
    }
#if 0
    ReleaseInterface(pDoc);
    ReleaseInterface(pVS);
#endif // 0    
    ReleaseInterface(pElement);
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    
    RRETURN(hr);

}

//=========================================================================
// CCommand: GetLeftAdjacentTagId
//
// Synopsis: Moves the markup pointer to an element tag with the specified
//           TAGID.  However, the pointer is not advanced past any text.
//
// Returns:  S_OK if found
//           S_FALSE if not found
//
//-------------------------------------------------------------------------
HRESULT
CCommand::GetLeftAdjacentTagId(  IMarkupServices *pMarkupServices,
                                 IMarkupPointer  *pMarkupPointer,
                                 ELEMENT_TAG_ID  tagIdTarget,
                                 IMarkupPointer  **ppLeft,
                                 IHTMLElement    **ppElement,
                                 MARKUP_CONTEXT_TYPE *pContext)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagIdCurrent;
    IMarkupPointer      *pCurrent = NULL;
    IHTMLElement        *pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    //
    // Check to the left
    //

    hr = THR(CopyMarkupPointer(GetEditor(), pMarkupPointer, &pCurrent));
    if (FAILED(hr))
        goto Cleanup;

    for (;;) {
        hr = THR( pCurrent->Left( TRUE, &context, &pElement, NULL, NULL));
        if (FAILED(hr))
            break; // not found

        // TODO: maybe we can be more agressive and handle EnterScope as well [ashrafm]
        if (context != CONTEXT_TYPE_ExitScope)
            break; // not found

        hr = THR(pMarkupServices->GetElementTagId(pElement, &tagIdCurrent));
        if (FAILED(hr))
            goto Cleanup;

        if (tagIdCurrent == tagIdTarget)
        {
            // found tagid
            if (ppElement)
            {
                *ppElement = pElement;
                pElement->AddRef();
            }
            if (ppLeft)
            {
                 *ppLeft = pCurrent;
                 pCurrent->AddRef();
            }
            if (pContext)
                *pContext = context;

            goto Cleanup;
        }
        ClearInterface(&pElement);
    }

    hr = S_FALSE; // not found
    if (ppElement)
        *ppElement = NULL;

    if (ppLeft)
        *ppLeft = NULL;

Cleanup:
    ReleaseInterface(pCurrent);
    ReleaseInterface(pElement);

    RRETURN1(hr, S_FALSE);
}

//=========================================================================
// CCommand: GetRightAdjacentTagId
//
// Synopsis: Moves the markup pointer to an element tag with the specified
//           TAGID.  However, the pointer is not advanced past any text.
//
// Returns:  S_OK if found
//           S_FALSE if not found
//
//-------------------------------------------------------------------------
HRESULT
CCommand::GetRightAdjacentTagId( 
    IMarkupServices *pMarkupServices,
    IMarkupPointer  *pMarkupPointer,
    ELEMENT_TAG_ID  tagIdTarget,
    IMarkupPointer  **ppLeft,
    IHTMLElement    **ppElement,
    MARKUP_CONTEXT_TYPE *pContext )
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagIdCurrent;
    IMarkupPointer      *pCurrent = NULL;
    IHTMLElement        *pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    //
    // Check to the left
    //

    hr = THR(CopyMarkupPointer(GetEditor(), pMarkupPointer, &pCurrent));
    if (FAILED(hr))
        goto Cleanup;

    for (;;) {
        hr = THR( pCurrent->Right(TRUE, &context, &pElement, NULL, NULL));
        if (FAILED(hr))
            break; // not found

        // TODO: maybe we can be more agressive and handle EnterScope as well [ashrafm]
        if (context != CONTEXT_TYPE_ExitScope)
            break; // not found

        hr = THR(pMarkupServices->GetElementTagId(pElement, &tagIdCurrent));
        if (FAILED(hr))
            goto Cleanup;

        if (tagIdCurrent == tagIdTarget)
        {
            // found tagid
            if (ppElement)
            {
                *ppElement = pElement;
                pElement->AddRef();
            }
            if (ppLeft)
            {
                 *ppLeft = pCurrent;
                 pCurrent->AddRef();
            }
            if (pContext)
                *pContext = context;

            goto Cleanup;
        }
        ClearInterface(&pElement);
    }

    hr = S_FALSE; // not found
    if (ppElement)
        *ppElement = NULL;

    if (ppLeft)
        *ppLeft = NULL;

Cleanup:
    ReleaseInterface(pCurrent);
    ReleaseInterface(pElement);

    RRETURN1(hr, S_FALSE);
}

HRESULT CCommand::SplitElement(  IMarkupServices *pMarkupServices,
                                 IHTMLElement    *pElement,
                                 IMarkupPointer  *pTagStart,
                                 IMarkupPointer  *pSegmentEnd,
                                 IMarkupPointer  *pTagEnd,
                                 IHTMLElement    **ppNewElement )
{
    HRESULT      hr;
    IHTMLElement *pNewElement = NULL;
    
#if DBG==1  // make sure we don't split the body
    ELEMENT_TAG_ID tagId;
    INT            iPosition;
    
    hr = pMarkupServices->GetElementTagId(pElement, &tagId);
    Assert(hr == S_OK && tagId != TAGID_BODY);

    // Make sure the order of pTagStart, pSegmentEnd, and pTagEnd is right
    hr = OldCompare( pTagStart, pSegmentEnd, &iPosition);
    Assert(hr == S_OK && iPosition != LEFT);
    
    hr = OldCompare( pSegmentEnd, pTagEnd, &iPosition);
    Assert(hr == S_OK && iPosition != LEFT);       
#endif    

    hr = THR( pSegmentEnd->SetGravity( POINTER_GRAVITY_Right ));
    if ( FAILED(hr))
        goto Cleanup;
    hr = THR( pTagEnd->SetGravity( POINTER_GRAVITY_Right ));
    if ( FAILED(hr))
        goto Cleanup;      
    //
    // Move element to first part of range
    //
    hr = THR(pMarkupServices->RemoveElement(pElement));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(InsertElement(pMarkupServices, pElement, pTagStart, pSegmentEnd));
    if (FAILED(hr))
        goto Cleanup;

    //
    // Clone element for the rest of the range
    //

    IFC( pMarkupServices->CloneElement( pElement, &pNewElement ) );

    IFC( pSegmentEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFC( InsertElement(pMarkupServices, pNewElement, pSegmentEnd, pTagEnd) );
    

Cleanup:
    if (ppNewElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppNewElement = pNewElement;
            pNewElement->AddRef();
        }
        else
        {
            *ppNewElement = NULL;
        }
    }

    ReleaseInterface(pNewElement);
    RRETURN(hr);
}

HRESULT 
CCommand::InsertBlockElement(IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    SELECTION_TYPE      selectionType;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    SP_IDisplayPointer  spDispPointer;
    
    //
    // Get the selection type
    //
    
    IFR( GetSegmentList(&spSegmentList) ); 
    IFR( spSegmentList->GetType(&selectionType) );
#if DBG
    BOOL                fEmpty = FALSE;

    IFR( spSegmentList->IsEmpty(&fEmpty) );
    Assert( fEmpty == FALSE);
#endif    

    //
    // If we are a caret selection, make sure any new block elements inserted
    // at the caret position leave the caret inside
    //

    if (selectionType == SELECTION_TYPE_Caret)
    {        
        IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFR( GetDisplayServices()->GetCaret(&spCaret) );
        IFR( spCaret->MoveMarkupPointerToCaret(spPointer) );

        // Save display gravity to spDispPointer
        IFR( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFR( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
        
        IFR( EdUtil::InsertBlockElement(GetMarkupServices(), pElement, pStart, pEnd, spPointer) );

        IFR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFR( spCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE ));
    }
    else
    {
        IFR( GetEditor()->InsertElement(pElement, pStart, pEnd) );
    }

    RRETURN(hr);
}

HRESULT 
CCommand::CreateAndInsert(ELEMENT_TAG_ID tagId, IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT         hr;
    SP_IHTMLElement  spElement;

    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
    IFR( InsertBlockElement(spElement, pStart, pEnd) );

    if (ppElement)
    {
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }

    RRETURN(hr);    
}

HRESULT 
CCommand::CommonQueryStatus( 
        OLECMD *       pCmd,
        OLECMDTEXT *   pcmdtext )
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    SELECTION_TYPE      eSelectionType;
    BOOL                fEmpty = FALSE;
    
    pCmd->cmdf = MSOCMDSTATE_UP; // up by default
    
    IFR( GetSegmentList( &spSegmentList ));

    
    //
    // If there is no segment count, return up
    //
    IFR( spSegmentList->IsEmpty( &fEmpty ) );
    IFR( spSegmentList->GetType( &eSelectionType ) );
    
    if( fEmpty ) /// nothing to do
    {
        // enable by default
        if (eSelectionType == SELECTION_TYPE_None)        
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        
        return S_OK;
    }

    if (!CanAcceptHTML(spSegmentList))
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;
    }

    return S_FALSE; // not done
}

HRESULT 
CCommand::CommonPrivateExec( 
        DWORD                    nCmdexecopt,
        VARIANTARG *             pvarargIn,
        VARIANTARG *             pvarargOut )
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    BOOL                fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
        return S_OK;
    
    if (!CanAcceptHTML(spSegmentList))
    {
        if (pvarargOut)
        {
            return S_FALSE; // not handled
        }
        return E_FAIL;
    }

    return S_FALSE; // not done
}


BOOL 
CCommand::CanAcceptHTML(ISegmentList *pSegmentList)
{
    HRESULT                 hr;
    BOOL                    bResult = FALSE;
    SP_IHTMLElement         spFlowElement;
    SP_IHTMLElement3        spElement3;
    SP_IMarkupPointer       spStart;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    
    IFC( pSegmentList->GetType(&eSelectionType) );
    IFC( pSegmentList->IsEmpty( &fEmpty ) );

    switch (eSelectionType)
    {
        case SELECTION_TYPE_Control:
            bResult = IsValidOnControl();
            break;
            
        case SELECTION_TYPE_Caret:
        case SELECTION_TYPE_Text:
            // If the command target is a range, we don't want to call CanContextAcceptHTML
            // because this gives us the result for the current selection, which may not 
            // be our range. Instead, we need to ask the flow element, so we fall through.
            // (bug 95423 - krisma)
            if ( !GetCommandTarget()->IsRange() )
            {
                bResult = GetEditor()->GetSelectionManager()->CanContextAcceptHTML();    
                break;
            }
            // fall through

        default:
            if( !fEmpty )
            {
                IFC( GetFirstSegmentPointers(pSegmentList, &spStart, NULL) );
                IFC( GetEditor()->GetFlowElement(spStart, &spFlowElement) );
                if ( spFlowElement )
                {
                    VARIANT_BOOL fHTML = VARIANT_FALSE;
                    IFC(spFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
                    IFC(spElement3->get_canHaveHTML(&fHTML));
                    bResult = !!fHTML;
                }
            }                
    }

Cleanup:
    return bResult;
}

HRESULT 
CCommand::GetSegmentElement(ISegment *pISegment, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IElementSegment      spElemSegment;
    SP_IMarkupPointer       spLeft, spRight;
    
    Assert( ppElement && pISegment );

    *ppElement = NULL;    

    // Create some markup pointers
    IFC( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&spRight) );

    // Try to move to an element
    IFC( pISegment->GetPointers( spLeft, spRight ) );

    IFC( spLeft->Right( FALSE, NULL, ppElement, NULL, NULL ) );

    Assert(*ppElement);
Cleanup:
    return S_OK;
}

HRESULT 
CCommand::AdjustSegment(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT         hr;    
    SP_ISegmentList spSegmentList;
    SELECTION_TYPE  eSelectionType;
    BOOL            fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    if (spSegmentList == NULL)
        return S_FALSE;
        
    IFR( spSegmentList->GetType( &eSelectionType ) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( !fEmpty && eSelectionType == SELECTION_TYPE_Text)
    {    
        CEditPointer epTest(GetEditor());
        DWORD        dwFound;

        //
        // If we have:              {selection start}...</p><p>{selection end} ...
        // we want to adjust to:    {selection start}...</p>{selection end}<p> ...
        // so that the edit commands don't apply to unselected lines
        //

        IFR( epTest->MoveToPointer(pEnd) );
        IFR( epTest.SetBoundary(pStart, NULL) );
        
        IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );        
        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            return S_OK;

        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock))
            IFR( pEnd->MoveToPointer(epTest) );
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       EdUtil::ExpandToWord
//
//  Synopsis:     Expands empty selection to word if inside text.
//
//----------------------------------------------------------------------------

HRESULT
CCommand::ExpandToWord(IMarkupServices * pMarkupServices, IMarkupPointer * pmpStart, IMarkupPointer * pmpEnd)
{
    SP_IMarkupPointer spmpPosition, spmpStart, spmpEnd;
    INT               iPosition;
    BOOL              fEqual, fExpand = FALSE;
    HRESULT           hr;
    CEditPointer      ep(GetEditor());
    DWORD             dwFound;

    Assert(pMarkupServices && pmpStart && pmpEnd);

    //
    // Markup pointers have to be at the same position in order for us to expand to a word.
    //

    hr = THR(pmpStart->IsEqualTo(pmpEnd, &fEqual));
    if (hr || !fEqual)
        goto Cleanup;

    //
    // Make sure we are contained in text before trying word expansion.
    // We need to do this because MoveUnit fails at document boundaries.
    //

    IFC( ep->MoveToPointer(pmpStart) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
        goto Cleanup;

    IFC( ep->MoveToPointer(pmpStart) );
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
        goto Cleanup;

    //
    // We have a collapsed selection (caret).  Now lets see
    // if we are inside a word of text.
    //

    IFC(CopyMarkupPointer(GetEditor(), pmpStart, &spmpStart));
    IFC(CopyMarkupPointer(GetEditor(), pmpEnd, &spmpEnd));
    IFC(CopyMarkupPointer(GetEditor(), pmpStart, &spmpPosition));
    IFC(spmpEnd->MoveUnit(MOVEUNIT_NEXTWORDEND));
    IFC(spmpStart->MoveToPointer(spmpEnd));
    IFC(spmpStart->MoveUnit(MOVEUNIT_PREVWORDBEGIN));
    IFC(OldCompare( spmpStart, spmpPosition, &iPosition));

    if (iPosition != RIGHT)
        goto Cleanup;

    IFC(OldCompare( spmpPosition, spmpEnd, &iPosition));

    if (iPosition != RIGHT)
        goto Cleanup;

    {
        MARKUP_CONTEXT_TYPE mctContext;
        // TODO: Due to a bug in MoveUnit(MOVEUNIT_NEXTWORDEND) we have to check
        // whether we ended up at the end of the markup.  Try removing this
        // once bug 37129 is fixed.
        IFC( spmpEnd->Right( FALSE, &mctContext, NULL, NULL, NULL));
        if (mctContext == CONTEXT_TYPE_None)
            goto Cleanup;
    }

    fExpand = TRUE;

Cleanup:

    if (hr || !fExpand)
        hr = S_FALSE;
    else
    {
        pmpStart->MoveToPointer(spmpStart);
        pmpEnd->MoveToPointer(spmpEnd);
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Method:       CCommand::AdjustPointersForAtomic
//
//  Synopsis:     Adjust pointers for atomic selection.
//
//----------------------------------------------------------------------------

HRESULT
CCommand::AdjustPointersForAtomic( IMarkupPointer *pStart, IMarkupPointer *pEnd )
{
    HRESULT hr = S_OK;
    
    IFC( GetEditor()->GetSelectionManager()->AdjustPointersForAtomic(pStart, pEnd) );
    
Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Method:       CCommand::RemoveDoubleBullets
//
//  Synopsis:     In general, if we have <LI><OL><LI>, we'll get a double
//                bullet.  We need to avoid generating these, so this method
//                will remove the double bullet.
//
//----------------------------------------------------------------------------
HRESULT 
CCommand::RemoveDoubleBullets(IHTMLElement *pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;
    CEditPointer        epLIStart(GetEditor());
    CEditPointer        epLIEnd(GetEditor());
    BOOL                fMoveLI = FALSE;
    SP_IHTMLElement     spElement;
    BOOL                fEmpty;
    DWORD               dwFound;
    ELEMENT_TAG_ID      tagId;
    CBlockPointer       bp(GetEditor());
    SP_IHTMLElement     spLIElement;

    //
    // Are we a double bullet?
    //
    
    IFC( bp.MoveTo(pElement) );
    if (bp.GetType() == NT_ListContainer)
    {
        IFC( bp.MoveToParent() );
    }    
    if( bp.GetType() != NT_ListItem )
    {
        goto Cleanup; // not a double bullet             
    }      

    //
    // Get the element
    //

    IFC( bp.GetElement(&spLIElement) );

    //
    // Remove the double bullet
    //

    IFC( epLIStart->MoveAdjacentToElement(spLIElement, ELEM_ADJ_AfterBegin) );

    for (;;)
    {
        //
        // See if we have an list container followed by the open LI
        //
    
        IFC( epLIStart.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound, &spElement, &tagId) );

        if (epLIStart.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock) && IsListContainer(tagId))
        {
            fMoveLI = TRUE;
            IFC( epLIStart->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) ); 
        }
        else
        {
            if (fMoveLI)
            {
                IFC( epLIStart.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
            }
            break;
        }
    }

    //
    // Remove the LI and re-insert it in the correct position
    //

    if (!fMoveLI)
        goto Cleanup; // we're done

    IFC( epLIEnd->MoveAdjacentToElement(spLIElement, ELEM_ADJ_BeforeEnd) );
    IFC( GetMarkupServices()->RemoveElement(spLIElement) );

    //
    // Only re-insert if there is content
    //

    IFC( epLIStart.IsEqualTo(epLIEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEmpty) );
    if (!fEmpty)
    {
        IFC( GetMarkupServices()->InsertElement(spLIElement, epLIStart, epLIEnd) );        
    }    

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\edadorn.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H
#include "resource.h"    
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef _X_PAINTER_H_
#define _X_PAINTER_H_
#include "painter.h"
#endif


DeclareTag(tagAdornerHitTest, "Adorner", "Adorner Hit Test")
DeclareTag(tagAdornerShowResize, "Adorner", "Display Adorner Resize Info ")
DeclareTag(tagAdornerShowAdjustment, "Adorner", "Display Adorner Adjust Info ")
DeclareTag(tagAdornerResizeRed, "Adorner", "Draw Resize Feedback in Red")
using namespace EdUtil;

extern HINSTANCE           g_hInstance ;

template < class T > void swap ( T & a, T & b ) { T t = a; a = b; b = t; }

MtDefine( CGrabHandleAdorner, Utilities , "CGrabHandleAdorner" )
MtDefine( CActiveControlAdorner, Utilities , "CGrabHandleAdorner" )
MtDefine( CCursor, Utilities , "CCursor" )

//
// Constants
//

const int FEEDBACK_SIZE = 1;
    
int g_iGrabHandleWidth = 7;
int g_iGrabHandleHeight = 7;
BOOL g_fCalculatedGrabHandleSize = FALSE;

static const ADORNER_HTI seHitHandles[] =
{
    ADORNER_HTI_TOPLEFTHANDLE ,
    ADORNER_HTI_TOPHANDLE ,
    ADORNER_HTI_TOPRIGHTHANDLE,    
    ADORNER_HTI_LEFTHANDLE,  
    ADORNER_HTI_RIGHTHANDLE,  
    ADORNER_HTI_BOTTOMLEFTHANDLE, 
    ADORNER_HTI_BOTTOMHANDLE,      
    ADORNER_HTI_BOTTOMRIGHTHANDLE 
};


static const USHORT sHandleAdjust[] =
{
    CT_ADJ_TOP | CT_ADJ_LEFT,       //  GRAB_TOPLEFTHANDLE
    CT_ADJ_TOP,                     //  GRAB_TOPHANDLE
    CT_ADJ_TOP | CT_ADJ_RIGHT,      //  GRAB_TOPRIGHTHANDLE    
    CT_ADJ_LEFT,                    //  GRAB_LEFTHANDLE
    CT_ADJ_RIGHT,                   //  GRAB_RIGHTHANDLE    
    CT_ADJ_BOTTOM | CT_ADJ_LEFT,    //  GRAB_BOTTOMLEFTHANDLE
    CT_ADJ_BOTTOM,                  //  GRAB_BOTTOMHANDLE
    CT_ADJ_BOTTOM | CT_ADJ_RIGHT   //  GRAB_BOTTOMRIGHTHANDLE
};

static const LPCTSTR sHandleCursor[] =
{
    IDC_SIZENWSE,
    IDC_SIZENS,
    IDC_SIZENESW,
    IDC_SIZEWE,
    IDC_SIZEWE,
    IDC_SIZENESW,
    IDC_SIZENS,
    IDC_SIZENWSE,
    IDC_ARROW,
    IDC_SIZEALL,
    IDC_CROSS
};

CEditAdorner::CEditAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc )
{
    ReplaceInterface( &_pIDoc ,  pIDoc );
    IGNORE_HR( pIElement->QueryInterface( IID_IHTMLElement, (void**) & _pIElement ));
    
    _lCookie = 0 ;
    _cRef = 0;
    _ctOnPositionSet = 0;
    _pBehaviorSite = NULL;
    _pPaintSite = NULL;
}  

VOID 
CEditAdorner::SetManager( CSelectionManager * pManager )
{
    _pManager = pManager;

    if (!g_fCalculatedGrabHandleSize)
    {
        POINT	pt = {g_iGrabHandleWidth, g_iGrabHandleHeight};

        _pManager->GetEditor()->DeviceFromDocPixels(&pt);
        g_iGrabHandleWidth = pt.x;
        g_iGrabHandleHeight = pt.y;

        g_fCalculatedGrabHandleSize = TRUE;
    }
}

VOID
CEditAdorner::NotifyManager()
{
    if ( _fNotifyManagerOnPositionSet && _pManager )
    {
        _pManager->AdornerPositionSet(); 
        _fNotifyManagerOnPositionSet = FALSE; // only notify once
    }
}

CEditAdorner::~CEditAdorner()
{
    ReleaseInterface(_pPaintSite);
    ReleaseInterface(_pBehaviorSite);
    ReleaseInterface( _pIElement );
    ReleaseInterface( _pIDoc );
}

BOOL
CEditAdorner::IsAdornedElementPositioned()
{
    return ( IsElementPositioned( _pIElement ) );
}

// --------------------------------------------------
// IUnknown Interface
// --------------------------------------------------

STDMETHODIMP_(ULONG)
CEditAdorner::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CEditAdorner::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CEditAdorner::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( (IElementBehavior *)this , IUnknown )
        QI_INHERITS( this, IElementBehavior)
        QI_INHERITS( this, IHTMLPainter)
        QI_INHERITS( this, IHTMLPainterEventInfo)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

CMshtmlEd* 
CEditAdorner::GetCommandTarget()
{ 
    Assert (_pManager); 
    return _pManager->GetCommandTarget(); 
}

//
// IElementBehavior::Init
//
STDMETHODIMP
CEditAdorner::Init(IElementBehaviorSite *pBehaviorSite)
{
    HRESULT hr = S_OK;
    ClearInterface(&_pBehaviorSite);
    _pBehaviorSite = pBehaviorSite;

    if (_pBehaviorSite)
    {
        _pBehaviorSite->AddRef();

        IFC(_pBehaviorSite->QueryInterface(IID_IHTMLPaintSite, (LPVOID *)&_pPaintSite))
    }

Cleanup:
    if (hr)
    {
        ClearInterface(&_pBehaviorSite);
        ClearInterface(&_pPaintSite);
    }
    RRETURN(hr);
}

STDMETHODIMP
CEditAdorner::Detach()
{
    Assert(_pBehaviorSite);

    ClearInterface(&_pBehaviorSite);
    ClearInterface(&_pPaintSite);

    return S_OK;
}

STDMETHODIMP
CEditAdorner::Notify(long lEvent, VARIANT *pVar)
{
    return S_OK;
}

//+====================================================================================
//
// Method: AttachToElement
//
// Synopsis: Add this Adorner inside of Trident.
//
//------------------------------------------------------------------------------------


HRESULT
CEditAdorner::CreateAdorner()
{
    HRESULT hr = S_OK;

    Assert(_pIElement);

    IHTMLElement2 *pIElement2 = 0;

    IFC(_pIElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pIElement2));

    Assert(pIElement2);
    VARIANT v;

    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = (IUnknown *)(IElementBehavior *)this;

    IFC(pIElement2->addBehavior(L"", &v, &_lCookie));

Cleanup:
    ReleaseInterface(pIElement2);
    RRETURN( hr );
}

//+====================================================================================
//
// Method:DestroyAdorner
//
// Synopsis: Destroy's the Adorner inside of trident that we are attached to.
//
//------------------------------------------------------------------------------------

HRESULT
CEditAdorner::DestroyAdorner()
{
    HRESULT hr = S_OK;
    IHTMLElement2 *pIElement2 = NULL;    

    if ( _lCookie )
    {
        Assert(_pIElement);
        IFC (_pIElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pIElement2));

        Assert(pIElement2);

        VARIANT_BOOL fResultDontCare;
        pIElement2->removeBehavior(_lCookie, &fResultDontCare);
        _lCookie = 0;
    }
    
Cleanup:
    ReleaseInterface(pIElement2);
    RRETURN ( hr );

}

//+====================================================================================
//
// Method:InvalidateAdorner
//
// Synopsis: Call Invalidate Adorner on the Adorner inside of Trident.
//
//------------------------------------------------------------------------------------

HRESULT
CEditAdorner::InvalidateAdorner()
{
    HRESULT hr = S_OK;
    
    if ( _lCookie )
    {
        Assert(_pPaintSite);

        hr = _pPaintSite->InvalidateRect(NULL);
    }

    RRETURN(hr);
}

//--------------------------------------------------------------------------------
//
// CBorderAdorner
//
//--------------------------------------------------------------------------------
CBorderAdorner::CBorderAdorner( IHTMLElement* pIElement, IHTMLDocument2 * pIDoc )
    : CEditAdorner( pIElement, pIDoc )
{

}

CBorderAdorner::~CBorderAdorner()
{

}

STDMETHODIMP
CBorderAdorner::OnResize(SIZE sizeIn)
{
    SIZE    size = sizeIn;

    _pManager->GetEditor()->DocPixelsFromDevice(&size);
    SetRect(&_rcBounds, 0, 0, size.cx, size.cy);

    _rcControl = _rcBounds;

    InflateRect(&_rcControl, -g_iGrabHandleWidth, -g_iGrabHandleHeight);

    return S_OK;
}

STDMETHODIMP
CBorderAdorner::GetPainterInfo(HTML_PAINTER_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(pInfo));
    pInfo->lFlags = HTMLPAINTER_NOPHYSICALCLIP | HTMLPAINTER_TRANSPARENT | HTMLPAINTER_HITTEST | HTMLPAINTER_NOSAVEDC | HTMLPAINTER_SUPPORTS_XFORM ;
    pInfo->lZOrder = HTMLPAINT_ZORDER_WINDOW_TOP;

    // (michaelw) (chandras keeps changing things here)
    // Even though grab handles might be disabled by the command target,
    // we inflat our rect.  This is because we don't get notification
    // of changes to the flag so we can't invalidate our state on the
    // display tree.
    //
    // The fix (if you care) is to make the code changing the flag
    // notify the interested parties (ie this code) but it probably
    // isn't worth the effort.

    //
    // marka - not worth the effort to make the above changes - leave for now !
    //
    SetRect(&pInfo->rcExpand, g_iGrabHandleWidth, g_iGrabHandleHeight, g_iGrabHandleWidth, g_iGrabHandleHeight);

    return S_OK;
}

//--------------------------------------------------------------------------------
//
// CGrabHandleAdorner
//
//--------------------------------------------------------------------------------

STDMETHODIMP
CGrabHandleAdorner::HitTestPoint(POINT ptLocalIn, BOOL *pbHit, LONG *plPartID)
{
    POINT   ptLocal = ptLocalIn;

    _pManager->GetEditor()->DocPixelsFromDevice(&ptLocal);

    *pbHit = FALSE;
    *plPartID = ADORNER_HTI_NONE;

    TraceTag((tagAdornerHitTest, "HitTestPoint: ptLocal: %d %d  _rcBounds: %d %d %d %d  _rcControl: %d %d %d %d", 
                                 ptLocal.x, ptLocal.y, _rcBounds.left, _rcBounds.top, _rcBounds.right, _rcBounds.bottom, 
                                _rcControl.left, _rcControl.top, _rcControl.right, _rcControl.bottom));
    
    if (PtInRect(&_rcBounds, ptLocal))
    {
        if (!PtInRect(&_rcControl, ptLocal))
        {
            SetLocked();
            if (!_fLocked)
            {                
                *pbHit = TRUE;
                if ( ! IsInResizeHandle(ptLocal, (ADORNER_HTI *)plPartID))
                {
                    Verify( IsInMoveArea( ptLocal, (ADORNER_HTI *)plPartID ));
                }
            }
        }
    }
    return S_OK;
}


CGrabHandleAdorner::CGrabHandleAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked )
    : CBorderAdorner( pIElement , pIDoc )
{
    _resizeAdorner = -1;
    _hbrFeedback = NULL;
    _hbrHatch = NULL;

    _currentCursor = ADORNER_HTI_NONE;
    _fIsPositioned = IsAdornedElementPositioned();
    _fLocked = fLocked;
    _fDrawAdorner = TRUE;    
    _fPositionChange = FALSE;
}

CGrabHandleAdorner::~CGrabHandleAdorner()
{
    if ( _hbrFeedback )
        ::DeleteObject( _hbrFeedback );
    
    if ( _hbrHatch )
        ::DeleteObject( _hbrHatch );
}

STDMETHODIMP
CGrabHandleAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    SetLocked();

    CEditXform edXForm;
    
    if ( (lDrawFlags & HTMLPAINT_DRAW_USE_XFORM ) != 0 )
    { 
        HTML_PAINT_DRAW_INFO drawInfo;
        
        IGNORE_HR( _pPaintSite->GetDrawInfo( HTMLPAINT_DRAWINFO_XFORM , & drawInfo ) );
        
        edXForm.InitXform( & ( drawInfo.xform ));
    }
    
    DrawGrabBorders( & edXForm , hdc, &rcBounds, FALSE);
    DrawGrabHandles( & edXForm , hdc, &rcBounds);
    
    return S_OK;
}

//+====================================================================================
//
// Method: SetDrawAdorner
//
// Synopsis: Set the _fDrawAdorner bit - to control whether the adorner should be drawn or not
//
//------------------------------------------------------------------------------------

VOID
CGrabHandleAdorner::SetDrawAdorner( BOOL fDrawAdorner )
{
    BOOL fCurrentDrawAdorner = ENSURE_BOOL( _fDrawAdorner);

    _fDrawAdorner = fDrawAdorner;
    
    if ( fCurrentDrawAdorner != ENSURE_BOOL( _fDrawAdorner))
    {
        InvalidateAdorner();
    }
}

HRESULT
CGrabHandleAdorner::SetLocked()
{
    HRESULT hr = S_OK;
    BOOL fLocked = FALSE;
    
    hr = THR( _pManager->GetEditor()->IsElementLocked( _pIElement, & fLocked ));

    _fLocked = fLocked;
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetGrabRect
//
//  Synopsis:   Compute grab rect for a given area.
//
//  Notes:      These diagrams show the output grab rect for handles and
//              borders.
//
//              -----   -----   -----               -------------
//              |   |   |   |   |   |               |           |
//              | TL|   | T |   |TR |               |     T     |
//              ----|-----------|----           ----|-----------|----
//                  |           |               |   |           |   |
//              ----| Input     |----           |   | Input     |   |
//              |   |           |   |           |   |           |   |
//              |  L|   RECT    |R  |           |  L|   RECT    |R  |
//              ----|           |----           |   |           |   |
//                  |           |               |   |           |   |
//              ----|-----------|----           ----|-----------|----
//              | BL|   | B |   |BR |               |     B     |
//              |   |   |   |   |   |               |           |
//              -----   -----   -----               -------------
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::GetGrabRect(ADORNER_HTI htc, RECT * prcOut, RECT * prcIn /* = NULL */)
{
    if (prcIn == NULL)
        prcIn = &_rcBounds;

    switch (htc)
    {
        case ADORNER_HTI_TOPLEFTHANDLE:
        case ADORNER_HTI_LEFTHANDLE:
        case ADORNER_HTI_BOTTOMLEFTHANDLE:

            prcOut->left = prcIn->left ;
            prcOut->right = prcIn->left + g_iGrabHandleWidth ;
            break;

        case ADORNER_HTI_TOPHANDLE:
        case ADORNER_HTI_BOTTOMHANDLE:

            prcOut->left = ((prcIn->left + prcIn->right) - g_iGrabHandleWidth ) / 2;
            prcOut->right = prcOut->left + g_iGrabHandleWidth  ;
            break;

        case ADORNER_HTI_TOPRIGHTHANDLE:
        case ADORNER_HTI_RIGHTHANDLE:
        case ADORNER_HTI_BOTTOMRIGHTHANDLE:

            prcOut->left = prcIn->right - g_iGrabHandleWidth  ;
            prcOut->right = prcIn->right ;
            break;

        default:
            Assert(FALSE && "Unsupported GRAB_ value in GetGrabRect");
            return;
    }

    switch (htc)
    {
        case ADORNER_HTI_TOPLEFTHANDLE:
        case ADORNER_HTI_TOPHANDLE:
        case ADORNER_HTI_TOPRIGHTHANDLE:

            prcOut->top = prcIn->top ;
            prcOut->bottom = prcIn->top + g_iGrabHandleHeight   ;
            break;

        case ADORNER_HTI_LEFTHANDLE:
        case ADORNER_HTI_RIGHTHANDLE:

            prcOut->top = ((prcIn->top + prcIn->bottom) - g_iGrabHandleHeight ) / 2;
            prcOut->bottom = prcOut->top + g_iGrabHandleHeight ;
            break;

        case ADORNER_HTI_BOTTOMLEFTHANDLE:
        case ADORNER_HTI_BOTTOMHANDLE:
        case ADORNER_HTI_BOTTOMRIGHTHANDLE:

            prcOut->top = prcIn->bottom - g_iGrabHandleHeight ;
            prcOut->bottom = prcIn->bottom;
            break;

        default:
            Assert(FALSE && "Unsupported ADORNER_HTI_ value in GetHandleRegion");
            return;
    }

    if (prcOut->left > prcOut->right)
    {
        swap(prcOut->left, prcOut->right);
    }

    if (prcOut->top > prcOut->bottom)
    {
        swap(prcOut->top, prcOut->bottom);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   PatBltRectH & PatBltRectV
//
//  Synopsis:   PatBlts the top/bottom and left/right.
//
//-------------------------------------------------------------------------
void
CGrabHandleAdorner::PatBltRectH(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    int trueLeft = 0 ;
    int trueWidth = 0 ;
    
    //
    // Don't do general clipping. Assume that Oneside of pExcludeRect is equivalent
    // This is true once you're resizing with a grab handle.
    //
    if ( pExcludeRect && 
         pExcludeRect->top == prc->top && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->right < prc->right )
        {
            trueLeft = pExcludeRect->right;
            trueWidth = abs( prc->right - trueLeft );
        }
        else
            trueWidth = 0; // Nothing to draw - we are completely contained
    }
    else if ( pExcludeRect &&
              pExcludeRect->top == prc->top  &&
              pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->left > prc->left )
        {    
            trueLeft = prc->left;
            trueWidth = abs( pExcludeRect->right - trueLeft );
        }
        else
            trueWidth = 0;
    }
    else 
    {
        trueLeft = prc->left;
        trueWidth = prc->right - prc->left;
    }

    if ( trueWidth > 0 )
    {
        PatBlt(
                hdc,
                trueLeft,
                prc->top,
                trueWidth ,
                cThick,
                dwRop);
    }

    if ( pExcludeRect && 
         pExcludeRect->bottom == prc->bottom && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->right < prc->right )
        {
            trueLeft = pExcludeRect->right;
            trueWidth = abs ( prc->right - trueLeft );
        }
        else
            trueWidth = 0;
    }
    else if ( 
        pExcludeRect &&
        pExcludeRect->bottom == prc->bottom &&
        pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->left > prc->left )
        {    
            trueLeft = prc->left;
            trueWidth = pExcludeRect->left - trueLeft;
        }
        else
            trueWidth = 0;
    }
    else 
    {
        trueLeft = prc->left;
        trueWidth = prc->right - prc->left;
    }

    if ( trueWidth > 0 )
    {
        PatBlt(
                hdc,
                trueLeft,
                prc->bottom - cThick,
                trueWidth ,
                cThick,
                dwRop);
    }            
}

void
CGrabHandleAdorner::PatBltRectV(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    int trueTop = 0 ;
    int trueHeight = 0 ;
    
    //
    // Don't do general clipping. Assume that Oneside of pExcludeRect is equivalent
    // This is true once you're resizing with a grab handle.
    //
    if ( pExcludeRect &&
         pExcludeRect->top == prc->top && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->bottom < prc->bottom )
        {
            trueTop = pExcludeRect->bottom;
            trueHeight = prc->bottom - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else if ( pExcludeRect && 
              pExcludeRect->bottom == prc->bottom && 
              pExcludeRect->left == prc->left )
    {        
        if ( pExcludeRect->top > prc->top )
        {
            trueTop = prc->top;
            trueHeight = pExcludeRect->top - prc->top ;
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else 
    {
        trueTop = prc->top;
        trueHeight = prc->bottom - prc->top;
    }
   
    if ( trueHeight > 0 )
    {
        PatBlt(
                hdc,
                prc->left,
                trueTop + cThick,
                cThick,
                trueHeight - (2 * cThick),
                dwRop);
    }

    if ( pExcludeRect && 
         pExcludeRect->top == prc->top && 
         pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->bottom < prc->bottom )
        {
            trueTop = pExcludeRect->bottom;
            trueHeight = prc->bottom - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else if ( pExcludeRect && 
              pExcludeRect->bottom == prc->bottom && 
              pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->top > prc->top )
        {
            trueTop = prc->top;
            trueHeight = pExcludeRect->top - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }

    }
    else 
    {
        trueTop = prc->top;
        trueHeight = prc->bottom - prc->top;
    }

    if ( trueHeight > 0 )
    {
        PatBlt(
                hdc,
                prc->right - cThick,
                trueTop + cThick,
                cThick,
                trueHeight - (2 * cThick),
                dwRop);
    }            
}

void
CGrabHandleAdorner::PatBltRect(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    PatBltRectH(hdc, prc, pExcludeRect, cThick, dwRop);

    PatBltRectV(hdc, prc, pExcludeRect, cThick, dwRop);
}

LPCTSTR
CGrabHandleAdorner::GetResizeHandleCursorId(ADORNER_HTI inAdorner)
{
    return sHandleCursor[ inAdorner ];
}

BOOL 
CGrabHandleAdorner::IsInResizeHandle(CEditEvent *pEvent)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInResizeHandle(LocalFromGlobal(ptGlobal));
}

BOOL 
CGrabHandleAdorner::IsInResizeHandle(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    int     i;
    RECT    rc;

    // Reject trivial miss
    if (!PtInRect(&_rcBounds, ptLocal))
        return FALSE;

    SetLocked();
    if ( _fLocked)
        return FALSE;

    rc.left = rc.top = rc.bottom = rc.right = 0;    // to appease LINT

    for (i = 0; i < ARRAY_SIZE(seHitHandles); ++i)
    {
        GetGrabRect( seHitHandles[i], &rc);
        if (PtInRect(&rc, ptLocal))
        {
            _resizeAdorner = (char)i;
            if ( pGrabAdorner )
                *pGrabAdorner = seHitHandles[i]; // make use of ordering of ENUM

            TraceTag(( tagAdornerHitTest , "IsInResizeHandle: Point:%d,%d Hit:%d rc: left:%d top:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
                    TRUE , rc.left, rc.top, rc.bottom, rc.right )); 
                    
            return TRUE;
        }            
    }
    TraceTag(( tagAdornerHitTest , "Did Not Hit Resizehandle: Point:%d,%d Hit:%d rc: left:%d top:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
            FALSE , rc.left, rc.top, rc.bottom, rc.right )); 
    return FALSE ;
}

BOOL 
CGrabHandleAdorner::IsInMoveArea(CEditEvent *pEvent)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInMoveArea(LocalFromGlobal(ptGlobal));
}

BOOL 
CGrabHandleAdorner::IsInMoveArea(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    BOOL fInBounds = FALSE;

    SetLocked();
    
    if ( _fLocked )
        return FALSE;
        
    if ( ( PtInRect(&_rcBounds , ptLocal)) && 
         (!PtInRect(&_rcControl, ptLocal) ) )
    {
        fInBounds = TRUE;
        if ( pGrabAdorner )
        {
            //
            // Find out what part of the border we are in.
            //
            if ( ptLocal.y >= _rcBounds.top && 
                 ptLocal.y <= _rcBounds.top + g_iGrabHandleHeight )
            {
                *pGrabAdorner = ADORNER_HTI_TOPBORDER;
            }
            else  if ( ptLocal.y >= _rcBounds.bottom - g_iGrabHandleHeight &&
                       ptLocal.y <= _rcBounds.bottom )
            {
                *pGrabAdorner = ADORNER_HTI_BOTTOMBORDER;
            }
            else if ( ptLocal.x >= _rcBounds.left &&
                      ptLocal.x <= _rcBounds.left + g_iGrabHandleWidth )
            {
                *pGrabAdorner = ADORNER_HTI_LEFTBORDER;
            }
            else
            {
                Assert( ptLocal.x <= _rcBounds.right &&
                       ptLocal.x >= _rcBounds.right - g_iGrabHandleWidth );

                *pGrabAdorner = ADORNER_HTI_RIGHTBORDER;                
            }
        }        
    }
    
    TraceTag(( tagAdornerHitTest , "Point:%d,%d InMoveArea:%d _rcBounds: top:%d left:%d, bottom:%d, right:%d _rcControl: top:%d left:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
            fInBounds, _rcBounds.top, _rcBounds.left, _rcBounds.bottom, _rcBounds.right, 
            _rcControl.left, _rcControl.top, _rcControl.bottom, _rcControl.right ));
            
    return fInBounds;        
}

BOOL 
CGrabHandleAdorner::IsInAdornerGlobal( POINT ptGlobal )
{
    POINT ptContainer = LocalFromGlobal(ptGlobal);

    return ( PtInRect(&_rcBounds, ptContainer) );
}

VOID 
CGrabHandleAdorner::BeginResize(POINT ptGlobal, USHORT adj )
{
    //
    // Check to see if the point is within the last call to IsInResizeHandle
    // if it isn't update IsInResizeHandle.
    //

    POINT ptLocal = LocalFromGlobal(ptGlobal);
    _resizeAdorner = -1;

    _ptRectOffset.x = 0;
    _ptRectOffset.y = 0;
    
    IsInResizeHandle(ptLocal);
    
    if ( _resizeAdorner != - 1)
    {
        RECT    rc;
        GetGrabRect( seHitHandles[_resizeAdorner], &rc, & _rcBounds );
        if (! PtInRect(&rc, ptLocal))
            IsInResizeHandle( ptLocal);

         _adj = sHandleAdjust[ _resizeAdorner ];
    }
    else if ( adj != CT_ADJ_NONE )
    {
        _adj = adj;
    }

    Assert( _resizeAdorner != -1 || adj != CT_ADJ_NONE );
    
    //
    // Do the stuff to set up a drag.
    //

    _fFeedbackVis = FALSE;   
    _fDrawNew = TRUE;

    TransformRectLocal2Global(&_rcControl, &_rcFirst);
    
    POINT   ptBeginPosition;
    Assert(_pIElement);
    EdUtil::GetOffsetTopLeft(_pIElement, &ptBeginPosition);
    _ptRectOffset.x = ptBeginPosition.x - _rcFirst.left;
    _ptRectOffset.y = ptBeginPosition.y - _rcFirst.top;
    OffsetRect(&_rcFirst, _ptRectOffset.x, _ptRectOffset.y);

    _ptFirst = ptGlobal;
    
    TraceTag((tagAdornerShowResize,"BeginResize. _rcFirst: left:%ld, top:%ld, right:%ld, bottom:%ld", 
                                    _rcFirst.left,
                                    _rcFirst.top,
                                    _rcFirst.right,
                                    _rcFirst.bottom ));     
    
    TraceTag((tagAdornerShowResize,"BeginResize. _ptFirst: x:%ld, y:%ld\n", 
                                    _ptFirst.x,
                                    _ptFirst.y ));                                     
}

VOID 
CGrabHandleAdorner::EndResize(POINT ptGlobal, RECT * pNewSize )
{    
    RECT rcLocal ;

    _fDrawNew = FALSE;
    DuringResize(ptGlobal, TRUE );

    TransformRectGlobal2Local(&_rc, &rcLocal);

    _ptRectOffset.x = 0;
    _ptRectOffset.y = 0;
    
    pNewSize->left   = _rc.left ;
    pNewSize->top    = _rc.top  ;
    pNewSize->right  = pNewSize->left + (rcLocal.right  - rcLocal.left);
    pNewSize->bottom = pNewSize->top  + (rcLocal.bottom - rcLocal.top);
}

VOID 
CGrabHandleAdorner::DuringResize(POINT ptGlobal, BOOL fForceRedraw )
{
    RECT    newRC ;
    POINT   ptChange;

    RectFromPoint(&newRC, ptGlobal);

    ptChange.x = ptGlobal.x - _ptFirst.x;
    ptChange.y = ptGlobal.y - _ptFirst.y;
    AdjustForCenterAlignment(_pIElement, &newRC, ptChange);

    TraceTag((tagAdornerShowResize, "DuringResize: ptLocal: %d, %d  _ptFirst: %d %d  _rcFirst (global): %d %d %d %d  pNewSize (global): %d %d %d %d",
                                    ptGlobal.x, ptGlobal.y, _ptFirst.x, _ptFirst.y,
                                    _rcFirst.left, _rcFirst.top, _rcFirst.right, _rcFirst.bottom,
                                    newRC.left, newRC.top, newRC.right, newRC.bottom));

    if (   ( newRC.left   != _rc.left   ||
             newRC.top    != _rc.top    ||
             newRC.right  != _rc.right  ||
             newRC.bottom != _rc.bottom ) 
           ||
            fForceRedraw )
    {
        if ( _fFeedbackVis )
        {
            DrawFeedbackRect( & _rc);
        }
        if ( _fDrawNew )
        {
            DrawFeedbackRect( & newRC);
            _fFeedbackVis = TRUE;
        }            
        _rc = newRC;
    }
}


HRESULT
CGrabHandleAdorner::AdjustForCenterAlignment( IHTMLElement *pElement, RECT *rcSize, const POINT ptChange )
{
    HRESULT         hr = S_OK;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;
    BSTR            bstrAlign;
    BOOL            fNeedToAdjust = TRUE;
    BOOL            fVertical = FALSE;

    Assert(rcSize);
    Assert(_pIElement);

    if (!rcSize || !pElement)
    {
        goto Cleanup;
    }

    IFC( _pManager->GetMarkupServices()->GetElementTagId(pElement, & eTag ));

    if (eTag == TAGID_HR)
    {
        SP_IHTMLHRElement   spHRElement;

        if ( pElement->QueryInterface(IID_IHTMLHRElement, (void **)&spHRElement) == S_OK &&
             spHRElement && spHRElement->get_align(&bstrAlign) == S_OK &&
             bstrAlign)
        {
            //  HRs are center aligned by default.
            if ( StrCmpIC(bstrAlign, _T("center")) == 0 )
            {
                IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
                if (fVertical)
                    goto Cleanup;
    
                if (_adj & CT_ADJ_LEFT)
                {
                    rcSize->right -= ptChange.x;
                }
                else if (_adj & CT_ADJ_RIGHT)
                {
                    rcSize->left -= ptChange.x;
                }
            }
            fNeedToAdjust = FALSE;
        }
    }
    else if (eTag == TAGID_TABLE)
    {
        SP_IHTMLTable       spTableElement;

        if ( pElement->QueryInterface(IID_IHTMLTable, (void **)&spTableElement) == S_OK &&
             spTableElement && spTableElement->get_align(&bstrAlign) == S_OK &&
             bstrAlign)
        {
            if ( StrCmpIC(bstrAlign, _T("center")) == 0 )
            {
                IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
                if (fVertical)
                    goto Cleanup;
    
                //  We have a centered table.  We will adjust the rect for
                //  center alignment.
                if (_adj & CT_ADJ_LEFT)
                {
                    rcSize->right -= ptChange.x;
                }
                else if (_adj & CT_ADJ_RIGHT)
                {
                    rcSize->left -= ptChange.x;
                }
            }
            fNeedToAdjust = FALSE;
        }
    }
    
    if (fNeedToAdjust)
    {
        IFC( GetBlockContainerAlignment( _pManager->GetMarkupServices(), pElement, &bstrAlign) );

        if ( (eTag == TAGID_HR && !bstrAlign) || bstrAlign && StrCmpIC(bstrAlign, _T("center")) == 0 )
        {
            IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
            if (fVertical)
                goto Cleanup;

            //  We have a centered DIV or P.  We will adjust the rect for
            //  center alignment.
            if (_adj & CT_ADJ_LEFT)
            {
                rcSize->right -= ptChange.x;
            }
            else if (_adj & CT_ADJ_RIGHT)
            {
                rcSize->left -= ptChange.x;
            }
            fNeedToAdjust = FALSE;
        }
    }

Cleanup:
    RRETURN( hr );
}

VOID 
CGrabHandleAdorner::DuringLiveResize( POINT dPt, RECT* pNewSize)
{
    POINT pt;
    RECT  rcLocal ;

    pt.x = dPt.x + _ptFirst.x;
    pt.y = dPt.y + _ptFirst.y;

    RectFromPoint(&_rcFirst, pt);
    AdjustForCenterAlignment(_pIElement, &_rcFirst, dPt);

    _ptFirst = pt;

    TransformRectGlobal2Local(&_rcFirst, &rcLocal);
    
    _rc = _rcFirst ;

    pNewSize->left   = _rcFirst.left ;
    pNewSize->top    = _rcFirst.top  ;
    pNewSize->right  = pNewSize->left + (rcLocal.right  - rcLocal.left);
    pNewSize->bottom = pNewSize->top  + (rcLocal.bottom - rcLocal.top);

        
    TraceTag((tagAdornerShowResize, "DuringLiveResize: dPt: %d %d  pt: %d, %d  _ptFirst: %d %d  _rcFirst (local): %d %d %d %d  pNewSize (global): %d %d %d %d",
                                    dPt.x, dPt.y, pt.x, pt.y, _ptFirst.x, _ptFirst.y,
                                    _rcFirst.left, _rcFirst.top, _rcFirst.right, _rcFirst.bottom,
                                    pNewSize->left, pNewSize->top, pNewSize->right, pNewSize->bottom));
}

VOID
CGrabHandleAdorner::DrawFeedbackRect( RECT* prcLocal)
{
    //
    // Get and release the DC every time. The office assistants like to blow it away.
    //
    HWND          hwnd = NULL;
    HDC           hdc;
    SP_IOleWindow spOleWindow;

    RECT rcGlobal;
    RECT rcControlGlobal;
    
    TransformRectLocal2Global(&_rcControl, &rcControlGlobal);
#if 0
    TransformRectLocal2Global(prcLocal, &rcGlobal);
#else
    rcGlobal = *prcLocal;
#endif

    OffsetRect(&rcGlobal, -_ptRectOffset.x, -_ptRectOffset.y);

    TraceTag((tagAdornerShowResize,"Adorner:%ld DrawFeedbackRect: left:%ld, top:%ld, right:%ld, bottom:%ld", 
                                this,
                                rcGlobal.left,
                                rcGlobal.top,
                                rcGlobal.right,
                                rcGlobal.bottom ));
                                
    IGNORE_HR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &hwnd ));
    hdc = GetDCEx( hwnd, 0 , DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE);
    
    HBRUSH hbr = GetFeedbackBrush();
    SelectObject( hdc, hbr);

    _pManager->GetEditor()->DeviceFromDocPixels(&rcGlobal);
    _pManager->GetEditor()->DeviceFromDocPixels(&rcControlGlobal);

#if DBG == 1
    if ( IsTagEnabled(tagAdornerResizeRed) )
    {
        PatBltRect( hdc, &rcGlobal, & rcControlGlobal, FEEDBACKRECTSIZE, PATCOPY );
    }
    else
#endif    
    PatBltRect( hdc, &rcGlobal, & rcControlGlobal, FEEDBACKRECTSIZE, PATINVERT);

    _pManager->GetEditor()->DocPixelsFromDevice(&rcGlobal);
    _pManager->GetEditor()->DocPixelsFromDevice(&rcControlGlobal);


    if (hdc)
    {
        ReleaseDC(hwnd, hdc );
    }
}

HBRUSH 
CGrabHandleAdorner::GetFeedbackBrush()
{
    HBITMAP hbmp;
    
    if ( ! _hbrFeedback )
    {
#if DBG == 1
        COLORREF cr;
        if ( IsTagEnabled(tagAdornerResizeRed ))
        {
            cr = RGB(0xFF,0x00,0x00);
            _hbrFeedback = ::CreateSolidBrush(cr );
        }
        else
        {
#endif    
            // Load the bitmap resouce.
            hbmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDR_FEEDBACKRECTBMP));
            if (!hbmp)
                goto Cleanup;

            // Turn the bitmap into a brush.
            _hbrFeedback = CreatePatternBrush(hbmp);

            DeleteObject(hbmp);
#if DBG ==1
        }
#endif
    }

Cleanup:
    return _hbrFeedback;
}

HBRUSH 
CGrabHandleAdorner::GetHatchBrush()
{
    HBITMAP hbmp;

    if ( ! _hbrHatch )
    {
        // Load the bitmap resouce.
        hbmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDR_HATCHBMP));
        if (!hbmp)
            goto Cleanup;

        // Turn the bitmap into a brush.
        _hbrHatch = CreatePatternBrush(hbmp);

        DeleteObject(hbmp);
    }
Cleanup:
    return _hbrHatch;
}

//+------------------------------------------------------------------------
//
//  Member:     DrawGrabHandles
//
//  Synopsis:   Draws grab handles around the given rect.
//
//-------------------------------------------------------------------------

void
CGrabHandleAdorner::DrawGrabHandles(CEditXform* pXform , HDC hdc, RECT *prc )
{
    Assert( pXform );
    
    if (!_fLocked)
    {
        HBRUSH      hbr;
        HPEN        hpen;
        int         i;

        // Get proper brush and pen to render primary or secondary selection
        if ( _fDrawAdorner )
        {
            hbr = (HBRUSH) GetStockObject(_fPrimary ? WHITE_BRUSH : BLACK_BRUSH);
            hpen = (HPEN) GetStockObject(_fPrimary ? BLACK_PEN : WHITE_PEN);
        }
        else
        {
            hbr = (HBRUSH) GetStockObject( LTGRAY_BRUSH );
            hpen = (HPEN) GetStockObject( WHITE_PEN );
        }
        Assert(hbr && hpen);

        // Load the brush and pen into the DC.
        hbr = (HBRUSH) SelectObject(hdc, hbr);
        hpen = (HPEN) SelectObject(hdc, hpen);

        // Draw each grab handle.
        for (i = 0; i < ARRAY_SIZE(seHitHandles); ++i)
        {
            RECT    rc;

            // Get the grab rect for this handle.
            GetGrabRect( seHitHandles[i] , &rc, prc );

            // xform the rect.            
            pXform->TransformRect( & rc );
            
            // Draw it.
            Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }

        // Restore the old brush and pen.
        SelectObject(hdc, hbr);
        SelectObject(hdc, hpen);

    }
}


//+------------------------------------------------------------------------
//
//  Member:     CGrabHandleBorders::DrawGrabBorders
//
//  Synopsis:   Draws grab borders around the givin rect.
//
//
//-------------------------------------------------------------------------
void
CGrabHandleAdorner::DrawGrabBorders(CEditXform* pXform , HDC hdc, RECT *prc, BOOL fHatch)
{
    HBRUSH      hbrOld = NULL;
    HBRUSH      hbr;
    POINT       pt ;
    
    GetViewportOrgEx (hdc, &pt) ;


    SetTextColor(hdc, RGB(0, 0, 0));
    SetBkColor(hdc, RGB(255, 255, 255));
    
    //
    // Xform the rect where we really want to draw.
    //
    Assert( pXform );
    RECT borderRect;
    borderRect = *prc;
    pXform->TransformRect( & borderRect );
    
    //
    // In the code below, before each select of a brush into the dc, we do
    // an UnrealizeObject followed by a SetBrushOrgEx.  This assures that
    // the brush pattern is properly aligned in that face of scrolling,
    // resizing or dragging the form containing the "bordered" object.
    //
    if (  _fLocked )
    {
        // For a locked elemnet - we just draw a rectangle around it.


        //InflateRect(&rc, -g_iGrabHandleWidth / 2, -g_iGrabHandleHeight / 2);

        hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(WHITE_BRUSH));
        if (!hbrOld)
            goto Cleanup;

        PatBltRectH(hdc, &borderRect, NULL, g_iGrabHandleWidth / 2, PATCOPY);
        PatBltRectV(hdc, &borderRect, NULL, g_iGrabHandleHeight / 2, PATCOPY);
        HPEN hpenOld;
        hpenOld = (HPEN) SelectObject(hdc, GetStockObject(BLACK_PEN));
        if (!hpenOld)
            goto Cleanup;

        MoveToEx(hdc, borderRect.left, borderRect.top, (GDIPOINT *)NULL);
        LineTo(hdc, borderRect.left, borderRect.bottom - 1);
        LineTo(hdc, borderRect.right - 1, borderRect.bottom - 1);
        LineTo(hdc, borderRect.right - 1, borderRect.top);
        LineTo(hdc, borderRect.left, borderRect.top);
        
        if (hpenOld)
            SelectObject(hdc, hpenOld);
    }
    
    if (fHatch)
    {
        hbr = GetHatchBrush();
        if (!hbr)
            goto Cleanup;

        // Brush alignment code.
#ifndef WINCE
        // not supported on WINCE
        UnrealizeObject(hbr);
#endif
        SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(borderRect.left,8),
                           POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(borderRect.top,8), NULL);

        hbrOld = (HBRUSH) SelectObject(hdc, hbr);
        if ( ! hbrOld )
            goto Cleanup;
        //
        // Work out height of border
        //
        RECT rcBorder ;
        SetRect(&rcBorder ,0,0,g_iGrabHandleWidth,g_iGrabHandleHeight) ;
        pXform->TransformRect( &rcBorder);
        int borderSize = rcBorder.bottom -rcBorder.top ;
              
        PatBltRect(hdc, & borderRect, NULL, borderSize, PATCOPY );        
    }


//
// marka - we used to draw a border around positioned elements, access and VID
// have now said they don't want this anymore.
//
#ifdef NEVER    
    else
    {
        if (  _fIsPositioned )
        {
            // For a site with position=absolute, draw an extra rectangle around it when selected
            HPEN hpenOld;

            //InflateRect(&rc, -g_iGrabHandleWidth / 2, -g_iGrabHandleHeight / 2);

            hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(WHITE_BRUSH));
            if (!hbrOld)
                goto Cleanup;

            PatBltRectH(hdc, &rc, g_iGrabHandleWidth / 2, PATCOPY);
            PatBltRectV(hdc, &rc, g_iGrabHandleHeight / 2, PATCOPY);

            hpenOld = (HPEN) SelectObject(hdc, GetStockObject(BLACK_PEN));
            if (!hpenOld)
                goto Cleanup;

            MoveToEx(hdc, rc.left, rc.top, (GDIPOINT *)NULL);
            LineTo(hdc, rc.left, rc.bottom - 1);
            LineTo(hdc, rc.right - 1, rc.bottom - 1);
            LineTo(hdc, rc.right - 1, rc.top);
            LineTo(hdc, rc.left, rc.top);

            if (hpenOld)
                SelectObject(hdc, hpenOld);
         }
    }
#endif

Cleanup:
    if (hbrOld)
        SelectObject(hdc, hbrOld);
}

STDMETHODIMP
CGrabHandleAdorner::SetCursor(LONG lPartID)
{
    HRESULT hr = S_FALSE;
    ADORNER_HTI eAdorner = (ADORNER_HTI)lPartID;
    LPCTSTR idc;

    switch (eAdorner)
    {
    case ADORNER_HTI_TOPBORDER:
    case ADORNER_HTI_LEFTBORDER:
    case ADORNER_HTI_BOTTOMBORDER:
    case ADORNER_HTI_RIGHTBORDER:
        idc = IDC_SIZEALL;
        break;
    case ADORNER_HTI_BOTTOMRIGHTHANDLE:
    case ADORNER_HTI_TOPLEFTHANDLE:
        idc = IDC_SIZENWSE;
        break;
    case ADORNER_HTI_BOTTOMLEFTHANDLE:
    case ADORNER_HTI_TOPRIGHTHANDLE:
        idc = IDC_SIZENESW;
        break;
    case ADORNER_HTI_TOPHANDLE:
    case ADORNER_HTI_BOTTOMHANDLE:
        idc = IDC_SIZENS;
        break;
    case ADORNER_HTI_LEFTHANDLE:
    case ADORNER_HTI_RIGHTHANDLE:
        idc = IDC_SIZEWE;
        break;
    case ADORNER_HTI_NONE:
        return S_FALSE;
    default:
        AssertSz(0, "Unexpected ADORNER_HTI");
        return S_FALSE;
    }

    HCURSOR hcursor = LoadCursorA(NULL, (char *)idc);

    Assert(hcursor);
    if (hcursor)
    {
        ::SetCursor(hcursor);
        return S_OK;
    }
    
    hr = GetLastError();
    RRETURN(hr);
}


static struct
{
    ADORNER_HTI eHTI;
    TCHAR *     pszName;
}
s_GrabHandleAdornerPartTable[] = 
    {
        { ADORNER_HTI_TOPBORDER,            _T("topborder") },
        { ADORNER_HTI_RIGHTBORDER,          _T("rightborder") },
        { ADORNER_HTI_BOTTOMBORDER,         _T("bottomborder") },
        { ADORNER_HTI_LEFTBORDER,           _T("leftborder") },
        { ADORNER_HTI_TOPLEFTHANDLE,        _T("handleTopLeft") },
        { ADORNER_HTI_TOPHANDLE,            _T("handleTop") },
        { ADORNER_HTI_TOPRIGHTHANDLE,       _T("handleTopRight") },
        { ADORNER_HTI_RIGHTHANDLE,          _T("handleRight") },
        { ADORNER_HTI_BOTTOMRIGHTHANDLE,    _T("handleBottomRight") },
        { ADORNER_HTI_BOTTOMHANDLE,         _T("handleBottom") },
        { ADORNER_HTI_BOTTOMLEFTHANDLE,     _T("handleBottomLeft") },
        { ADORNER_HTI_LEFTHANDLE,           _T("handleLeft") },
    };

STDMETHODIMP
CGrabHandleAdorner::StringFromPartID(LONG lPartID, BSTR *pbstrPart)
{
    HRESULT hr = E_FAIL;
    ADORNER_HTI eAdorner = (ADORNER_HTI)lPartID;

    for (int k=0; k<ARRAY_SIZE(s_GrabHandleAdornerPartTable); ++k)
    {
        if (s_GrabHandleAdornerPartTable[k].eHTI == eAdorner)
        {
            hr = THR(EdUtil::FormsAllocString( s_GrabHandleAdornerPartTable[k].pszName, pbstrPart ));
            break;
        }
    }

    RRETURN(hr);
}

CActiveControlAdorner::CActiveControlAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked )
                        : CGrabHandleAdorner( pIElement , pIDoc, fLocked)
{
    _fPrimary = TRUE;
}

CActiveControlAdorner::~CActiveControlAdorner()
{
}

void
CActiveControlAdorner::GetGrabRect(ADORNER_HTI htc, RECT * prcOut, RECT * prcIn /* = NULL */)
{
    Assert(!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles() ) );

    CGrabHandleAdorner::GetGrabRect(htc, prcOut, prcIn);
}

BOOL 
CActiveControlAdorner::IsInMoveArea(POINT ptLocal,  ADORNER_HTI *pGrabAdorner /*=NULL*/ )
{
    if (_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()) 
        return FALSE;
    
    return (CGrabHandleAdorner::IsInMoveArea(ptLocal, pGrabAdorner ));        
}

BOOL 
CActiveControlAdorner::IsInResizeHandle(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    if (_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()) 
        return FALSE;

    return (CGrabHandleAdorner::IsInResizeHandle(ptLocal, pGrabAdorner));
}

void
CActiveControlAdorner::DrawGrabHandles(CEditXform* pXform , HDC hdc, RECT *prc )
{
    if ( !(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()))
    {
        CGrabHandleAdorner::DrawGrabHandles(pXform, hdc, prc );
    }
}

HRESULT
CActiveControlAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    HRESULT hr = S_OK;
    
    if (!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()))
    {
        CEditXform edXForm;
    
        if ( (lDrawFlags & HTMLPAINT_DRAW_USE_XFORM ) != 0 )
        { 
            HTML_PAINT_DRAW_INFO drawInfo;
        
            IGNORE_HR( _pPaintSite->GetDrawInfo( HTMLPAINT_DRAWINFO_XFORM , & drawInfo ) );
        
            edXForm.InitXform( & (drawInfo.xform ));
        }

        DrawGrabBorders( & edXForm, hdc, &rcBounds, TRUE );
        DrawGrabHandles( & edXForm, hdc, &rcBounds);       
    }
    
    RRETURN(hr);   
}

void
CActiveControlAdorner::CalcRect(RECT * prc, POINT pt)
{
    Assert(!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()));

    CGrabHandleAdorner::CalcRect(prc, pt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGrabHandleAdorner::CalcRect
//
//  Synopsis:   Calculates the rect used for sizing or selection
//
//  Arguments:  [prc] -- Place to put new rect.
//              [pt]  -- Physical point which is the new second coordinate of
//                         the rectangle.
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::CalcRect(RECT * prc, POINT pt)
{
    RectFromPoint(prc, pt);

    //
    // Adjust the rect to be the rect of the element being resized.
    //
    InflateRect(prc, -g_iGrabHandleWidth, -g_iGrabHandleHeight);
}

//+---------------------------------------------------------------------------
//
//  Member:     CursorTracker::RectFromPoint
//
//  Synopsis:   Calculates the rect used for sizing or selection
//
//  Arguments:  [prc] -- Place to put new rect.
//              [pt]  -- Physical point which is the new second coordinate of
//                         the rectangle.
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::RectFromPoint(RECT * prc, POINT pt)
{
    //
    // Calc how far we've moved from the point where the tracker started.
    //
    int     dx = pt.x - _ptFirst.x;
    int     dy = pt.y - _ptFirst.y;

    //
    // Return the rect we started with.
    //
    *prc = _rcFirst;

    //
    // Adjust the returned rect based on how far we've moved and which edge
    // is being adjusted.
    //
    if (_adj & CT_ADJ_LEFT)
    {   
        prc->left   += dx;
        
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Left adjusted by:%ld. left:%ld", dx, prc->left));
#endif
    }        

    if (_adj & CT_ADJ_TOP)
    {
        prc->top    += dy;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Top adjusted by:%ld. top:%ld", dy, prc->top));
#endif        
    } 
    
    if (_adj & CT_ADJ_RIGHT)
    {
        prc->right  += dx;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Right adjusted by:%ld. right:%ld", dx, prc->right));
#endif 
    }        

    if (_adj & CT_ADJ_BOTTOM)       
    {
        prc->bottom += dy;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Bottom adjusted by:%ld. bototm:%ld", dy, prc->bottom));
#endif        
    }        
    //
    // Fix the left and right edges if they have become swapped.  This
    // occurs if the left edge has been moved right of the right edge,
    // or vice versa.
    //
    if (prc->right < prc->left)
    {
         if (_adj & CT_ADJ_LEFT)
             prc->left  = prc->right ;
         else
             prc->right = prc->left  ;
    }

    //
    // Same as above but with the top and bottom.
    //
    if (prc->bottom < prc->top)
    {
         if (_adj & CT_ADJ_TOP)
             prc->top    = prc->bottom ;
         else
             prc->bottom = prc->top ;
    }
}

BOOL
CGrabHandleAdorner::IsEditable()
{
    return TRUE;
}

BOOL
CSelectedControlAdorner::IsEditable()
{
    return FALSE;
}

CSelectedControlAdorner::CSelectedControlAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked)
        : CGrabHandleAdorner( pIElement , pIDoc, fLocked)
{

}

CSelectedControlAdorner::~CSelectedControlAdorner()
{

}

HRESULT
CSelectedControlAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    HRESULT hr = S_OK;

    DWORD       dwRop;
    HBRUSH      hbrOld = NULL;
    HBRUSH      hbr;
    POINT       pt ;
    VARIANT     var;

    if (GetCommandTarget()->IsDisableEditFocusHandles())
        goto Cleanup;

    //
    // Check the background color of the doc.
    //

    VariantInit(&var);
    _pIDoc->get_bgColor( & var );
    if (V_VT(&var) == VT_BSTR
        && (V_BSTR(&var) != NULL)
        && (StrCmpW(_T("#FFFFFF"), V_BSTR(&var)) == 0))
    {
        dwRop = DST_PAT_NOT_OR;
    }
    else
    {
        dwRop = DST_PAT_AND;
    }
    VariantClear(&var);
    
    GetViewportOrgEx (hdc, &pt) ;


    SetTextColor(hdc, RGB(0, 0, 0));
    SetBkColor(hdc, RGB(255, 255, 255));

    //
    // In the code below, before each select of a brush into the dc, we do
    // an UnrealizeObject followed by a SetBrushOrgEx.  This assures that
    // the brush pattern is properly aligned in that face of scrolling,
    // resizing or dragging the form containing the "bordered" object.
    //

    hbr = GetHatchBrush();
    if (!hbr)
        goto Cleanup;

    // Brush alignment code.
#ifndef WINCE
    // not supported on WINCE
    UnrealizeObject(hbr);
#endif
    SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(rcBounds.left,8),
                       POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(rcBounds.top,8), NULL);

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);
    if (!hbrOld)
        goto Cleanup;

    PatBltRect(hdc, &rcBounds, NULL, 4, dwRop);
    
Cleanup:
    if (hbrOld)
        SelectObject(hdc, hbrOld);

    RRETURN ( hr );        
}

void 
CGrabHandleAdorner::GetControlRect(RECT* prc)
{
    TransformRectLocal2Global(&_rcControl, prc);
}


VOID
CGrabHandleAdorner::SetPrimary(BOOL bIsPrimary)
{
    if (ENSURE_BOOL(_fPrimary) != bIsPrimary)
    {
        // Set the new value
        _fPrimary = bIsPrimary;

        // Redraw
        InvalidateAdorner();
    }
}

ELEMENT_CORNER
CGrabHandleAdorner::GetElementCorner()
{
    ELEMENT_CORNER eHandle = ELEMENT_CORNER_NONE;

    if (_adj & CT_ADJ_LEFT)
    {
        eHandle = (_adj & CT_ADJ_TOP)    ? ELEMENT_CORNER_TOPLEFT    : 
                  (_adj & CT_ADJ_BOTTOM) ? ELEMENT_CORNER_BOTTOMLEFT :
                                           ELEMENT_CORNER_LEFT ;
    }
    else if (_adj & CT_ADJ_RIGHT)
    {
        eHandle = (_adj & CT_ADJ_TOP)    ? ELEMENT_CORNER_TOPRIGHT :
                  (_adj & CT_ADJ_BOTTOM) ? ELEMENT_CORNER_BOTTOMRIGHT : 
                                           ELEMENT_CORNER_RIGHT;
    }
    else if (_adj & CT_ADJ_TOP)
    {
        eHandle = ELEMENT_CORNER_TOP ;
    }
    else if (_adj & CT_ADJ_BOTTOM)
    {
        eHandle = ELEMENT_CORNER_BOTTOM ;
    }
    
    return eHandle ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed


// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
// DECLARE_ORDINAL_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
// DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
// DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
// DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
// DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
// DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
// DECLARE_PROCNAME_MAP(utildll)
// DECLARE_PROCNAME_MAP(uxtheme)
// DECLARE_PROCNAME_MAP(version)
// DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
//     DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
//     DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
//     DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
//     DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
//     DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
//     DLDENTRYP(utildll)
//     DLDENTRYP(uxtheme)
//     DLDENTRYP(version)
//     DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#else
#pragma warning( disable : 4206 )
#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\edtrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_IMG_H_
#define _X_IMG_H_
#include "img.h"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_SELSERV_H_
#define X_SELSERV_H_
#include "selserv.hxx"
#endif

using namespace EdUtil;

ExternTag( tagSelectionTrackerState );

MtDefine( CEditTracker, Utilities , "CEditTracker" )
DeclareTag(tagEdKeyNav, "Edit", "Key Navigation Event for Editing")

static BOOL DontBackspace( ELEMENT_TAG_ID eTagId );

static char s_achWindows[] = "windows";             //  Localization: Do not localize

static SIZE                     gSizeDragMin;                   // the Size of a Minimum Drag.
int                             g_iDragDelay;                   // The Drag Delay

//+====================================================================================
//
// Method: CEditTracker
//
// Synopsis: Base Constructor for Trackers.
//
//------------------------------------------------------------------------------------


CEditTracker::CEditTracker(
            CSelectionManager* pManager )
{
    _pManager = pManager;
    _eType = TRACKER_TYPE_None;
    _hwndDoc = NULL;
    _ulRef = 1;
    _pSelServ = NULL;
    _fDontAdjustForAtomic = FALSE;
    _fEditContextUpdatedForAtomic = FALSE;

    _fShiftCapture         = FALSE;
    _fShiftLeftCapture     = FALSE;

    _ptVirtualCaret.InitPosition();
}

//+====================================================================================
//
// Method: Release
//
// Synopsis: COM-Like release code for tracker
//
//------------------------------------------------------------------------------------

ULONG
CEditTracker::Release()
{
    if ( 0 == --_ulRef )
    {
        delete this;
        return 0;
    }
    return _ulRef;
}

BOOL
CEditTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    return FALSE;
}

Direction 
CEditTracker::GetPointerDirection(CARET_MOVE_UNIT moveDir)
{
    switch (moveDir)
    {
        case CARET_MOVE_BACKWARD:
        case CARET_MOVE_PREVIOUSLINE:
        case CARET_MOVE_WORDBACKWARD:
        case CARET_MOVE_PAGEUP:
        case CARET_MOVE_VIEWSTART:
        case CARET_MOVE_LINESTART:
        case CARET_MOVE_DOCSTART:
        case CARET_MOVE_BLOCKSTART:
        case CARET_MOVE_ATOMICSTART:
            return LEFT;

        case CARET_MOVE_FORWARD:
        case CARET_MOVE_NEXTLINE:
        case CARET_MOVE_WORDFORWARD:
        case CARET_MOVE_PAGEDOWN:
        case CARET_MOVE_VIEWEND:
        case CARET_MOVE_LINEEND:
        case CARET_MOVE_DOCEND:
        case CARET_MOVE_NEXTBLOCK:
        case CARET_MOVE_ATOMICEND:
            return RIGHT;                
    }
    
    AssertSz(0, "CEditTracker::GetPointerDirection unhandled case");
    return LEFT;
}


BOOL
CEditTracker::IsPointerInSelection(IDisplayPointer  *pDispPointer,  
                                   POINT            *pptGlobal, 
                                   IHTMLElement     *pIElementOver)
{
    return FALSE;
}


//+====================================================================================
//
// Method: ~CEditTracker
//
// Synopsis: Destructor for Tracker
//
//------------------------------------------------------------------------------------


CEditTracker::~CEditTracker()
{
    if( _pSelServ )
    {
        _pSelServ->Release();
        _pSelServ = NULL;
    }
}


//+====================================================================================
//
// Method: CEditTracker::GetSpringLoader
//
// Synopsis: Accessor for springloader
//
//------------------------------------------------------------------------------------

CSpringLoader *
CEditTracker::GetSpringLoader()
{
    CSpringLoader * psl = NULL;
    CHTMLEditor   * pEditor;

    if (!_pManager)
        goto Cleanup;

    pEditor = _pManager->GetEditor();

    if (!pEditor)
        goto Cleanup;

    psl = pEditor->GetPrimarySpringLoader();

Cleanup:
    return psl;
}

VOID
CEditTracker::OnEditFocusChanged()
{
    // do nothing.
}

HRESULT 
CEditTracker::MustDelayBackspaceSpringLoad(
                       CSpringLoader *psl, 
                       IMarkupPointer *pPointer, 
                       BOOL *pbDelaySpringLoad)
{
    HRESULT         hr;
    ED_PTR( epTest ) ; 
    DWORD   dwFound;
    
    Assert(psl && pPointer && pbDelaySpringLoad);

    *pbDelaySpringLoad = FALSE;

    // Make sure we don't spring load near an anchor boundary.  If we are at an anchor
    // boundary, spring load after the delete.
    //
    IFR( epTest->MoveToPointer(pPointer) );

    IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // check pre-delete boundary
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Text))
        IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // check post-delete boundary

    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Anchor))
        *pbDelaySpringLoad = TRUE;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CEditTracker::GetMousePoint
//
//  Synopsis:   Get the x,y of the mouse by looking at the global cursor Pos.
//
//----------------------------------------------------------------------------
void
CEditTracker::GetMousePoint(POINT *ppt, BOOL fDoScreenToClient /* = TRUE */)
{
    HRESULT hr = S_OK;
    
    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED( hr ) , "GetWindow In CSelectTracker Failed" );
    }
    
    GetCursorPos(ppt);
    if ( fDoScreenToClient )
    {
        ScreenToClient( _hwndDoc, ppt);
    }        
    GetEditor()->DocPixelsFromDevice(ppt);
}

//+====================================================================================
//
// Method: Is MessageInWindow
//
// Synopsis: See if a given message is in a window. Assumed that the messages' pt has
//           already been converted to Screen Coords.
//
//------------------------------------------------------------------------------------

BOOL 
CEditTracker::IsEventInWindow( CEditEvent* pEvent )
{
    POINT globalPt;
    HRESULT hr ;
    
    IFC( pEvent->GetPoint( & globalPt ));
    
    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED(hr) , "GetWindow In CSelectTracker Failed" );
    }

    GetEditor()->ClientToScreen( _hwndDoc , & globalPt );
Cleanup:
    return ( IsInWindow( globalPt ));
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectionManager::GetMousePoint
//
//  Synopsis:   Check to see if the GLOBAL point is in the window.
//
//----------------------------------------------------------------------------
BOOL
CEditTracker::IsInWindow(POINT pt , BOOL fClientToScreen /* = FALSE*/ )
{
    HRESULT hr = S_OK;

    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED(hr) , "GetWindow In CSelectTracker Failed" );
    }

    return GetEditor()->IsInWindow(_hwndDoc, pt, fClientToScreen );

}

//+---------------------------------------------------------------------------
//
//  Member:     CEditTracker::GetLocation
//
//----------------------------------------------------------------------------
HRESULT 
CEditTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    AssertSz(0, "GetLocation not implemented for tracker");
    return E_NOTIMPL;
}




//+====================================================================================
//
// Method: ConstrainPointer
//
// Synopsis: Check to see that the caret is in the edit context of the manager.
//           IF it isn't position appropriately.
//          If the caret has gone before the Start, postion at start of context
//          If the caret has gone after the end, position at end of context
//
//------------------------------------------------------------------------------------


HRESULT
CEditTracker::ConstrainPointer( IMarkupPointer* pPointer, BOOL fDirection)
{
    HRESULT hr = S_OK;
    IMarkupPointer* pPointerLimit = NULL;
    BOOL fAfterStart = FALSE;
    BOOL fBeforeEnd = FALSE;
        
    Assert(pPointer);

    if ( ! _pManager->IsInEditContext( pPointer ))
    {
        hr = THR( _pManager->IsAfterStart( pPointer, &fAfterStart ));
        if ( ( hr == CTL_E_INCOMPATIBLEPOINTERS ) || !fAfterStart )
        {
            if ( hr == CTL_E_INCOMPATIBLEPOINTERS )
            {
                //
                // Assume we're in a different tree. Based on the direction - we move
                // to the appropriate limit.
                // 
                if ( !fDirection ) // earlier in story
                {
                    pPointerLimit = _pManager->GetStartEditContext();
                }
                else
                {
                    pPointerLimit = _pManager->GetEndEditContext();
                }
            }
            else
            {            
                pPointerLimit = _pManager->GetStartEditContext();
            }        
            hr = THR( pPointer->MoveToPointer( pPointerLimit));
            goto Cleanup;
        }

        hr = THR( _pManager->IsBeforeEnd( pPointer, &fBeforeEnd ));
        if (( hr == CTL_E_INCOMPATIBLEPOINTERS ) || !fBeforeEnd )
        {
            if ( hr == CTL_E_INCOMPATIBLEPOINTERS )
            {
                //
                // Assume we're in a different tree. Based on the direction - we move
                // to the appropriate limit.
                // 
                if ( ! fDirection ) // earlier in story
                {
                    pPointerLimit = _pManager->GetStartEditContext();
                }
                else
                {
                    pPointerLimit = _pManager->GetEndEditContext();
                }
            }
            else
            {            
                pPointerLimit = _pManager->GetEndEditContext(); 
            }   
            hr = THR( pPointer->MoveToPointer( pPointerLimit));             
        }            
    }
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: AdjsutForDeletion
//
// Synopsis: The Flow Layout we're in has been deleted
//
//  Return - TRUE - if we want to EmptySelection after we've been called
//           FALSE - if we don't want the manager to do anything.
//------------------------------------------------------------------------------------

BOOL
CEditTracker::AdjustForDeletion(IDisplayPointer * pDispPointer )
{
    return TRUE;
}


//+====================================================================================
//
//  Method: MovePointer
//
//  Synopsis: Moves the pointer like it were a caret - by the amount given for Caret 
//  Navigation
//
//
//------------------------------------------------------------------------------------

//
// HACKHACK: CARET_MOVE_UINT is treated as Logical move unit in order to support
//          vertical layout.
//
//          Although we used logical (content) coordinate system, the passed in parameter
//          plXPosForMove is actually in GLOBAL coordinate system in order to keep the 
//          callers happy. The editor actually caches mouse / keyboard position in global 
//          coordinate system. 
//          
//          If we strong typing editor's coordinate system in the future, we can 
//          we can explicit type this as GLOBALCOORDPOINT
//
//
//
HRESULT
CEditTracker::MovePointer(
    CARET_MOVE_UNIT     inMove, 
    IDisplayPointer     *pDispPointer,
    POINT               *ptgXYPosForMove,
    Direction           *peMvDir,
    BOOL                fIgnoreElementBoundaries /* =FALSE */)
{
    SP_IHTMLElement spContentElement;
    SP_IHTMLElement spElement;
    SP_IMarkupPointer   spPointer;
    SP_IHTMLElement spIFlowElement;
    

    HRESULT hr = S_OK;
    Direction eMvDir = LEFT;
    Direction eBlockAdj = SAME;
    
    DISPLAY_MOVEUNIT        edispMove;
    BOOL                    fVertical = FALSE;
    SP_IDisplayPointer      spOrigDispPointer;

    DWORD	dwAdjustOptions = ADJPTROPT_None;

    //
    // Save Current Display Pointer
    //
    Assert( pDispPointer );
    IFC( GetDisplayServices()->CreateDisplayPointer(&spOrigDispPointer) );
    IFC( spOrigDispPointer->MoveToPointer(pDispPointer) );
    //
    //
    
    Assert(GetEditor()->ShouldIgnoreGlyphs() == FALSE);

    if (peMvDir)
        *peMvDir = eMvDir; // init for error case

    POINT pt;
    pt.x = 0;
    pt.y = 0;

    IFC( _pManager->GetEditableElement( &spElement ));
    IFC( _pManager->GetEditableContent( &spContentElement ));
    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    eMvDir = LEFT;
    
    switch( inMove )
    {
        case CARET_MOVE_FORWARD:
            eMvDir = RIGHT;
            // fall through
            
        case CARET_MOVE_BACKWARD:            
        {   
            IFC( GetEditor()->MoveCharacter(pDispPointer, eMvDir) );
            break;
        }
        
        case CARET_MOVE_WORDFORWARD:
            eMvDir = RIGHT;
            // fall through

        case CARET_MOVE_WORDBACKWARD:
        {
            IFC( _pManager->GetEditor()->MoveWord(pDispPointer, eMvDir));            
            break;
        }

        case CARET_MOVE_PREVIOUSLINE:            
        case CARET_MOVE_NEXTLINE:

            IFC( pDispPointer->GetFlowElement(&spIFlowElement) );
            Assert(spIFlowElement != NULL);
            IFC( MshtmledUtil::IsElementInVerticalLayout(spIFlowElement, &fVertical) );
            //
            //
            //
            IFC( GetLocation(&pt, TRUE) );    // initialize pt to global coordinate
            if (fVertical)                    // y position is what we need to have
            {
                if (CARET_XPOS_UNDEFINED == ptgXYPosForMove->y)
                {
                    ptgXYPosForMove->y = pt.y; // update the suggested y position 
                }
                else
                {
                    pt.y = ptgXYPosForMove->y; // use the suggested y position
                }
            }
            else                            // keep x position 
            {
                if (CARET_XPOS_UNDEFINED == ptgXYPosForMove->x)
                {
                    ptgXYPosForMove->x = pt.x; // update the suggested x position
                }
                else
                {
                    pt.x = ptgXYPosForMove->x; // use the suggested x position
                }
            }
            //
            // MoveUnit now accepts logical coordinate only
            //
            IFC( GetDisplayServices()->TransformPoint(&pt, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT, spIFlowElement) );

            if (CARET_MOVE_PREVIOUSLINE == inMove)
            {
                eMvDir    = LEFT;
                edispMove = DISPLAY_MOVEUNIT_PreviousLine;
            }
            else    // CARET_MOVE_NEXTLINE
            {
                eMvDir    = RIGHT;
                edispMove = DISPLAY_MOVEUNIT_NextLine;
            }

            IFC( pDispPointer->MoveUnit(edispMove, pt.x) );
            break;

        case CARET_MOVE_LINESTART:            
            IFC( GetLocation( &pt, FALSE ));
            IFC( pDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, pt.x) );
            eMvDir = LEFT;            
            break;

        case CARET_MOVE_LINEEND:
            IFC( GetLocation( &pt, FALSE ));
            IFC( pDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, pt.x) );
            eMvDir = RIGHT;
            break;

        case CARET_MOVE_VIEWEND:
            eMvDir = RIGHT;
            // fall through
            
        case CARET_MOVE_VIEWSTART:
        {
            // Get the bounding rect of the edit context, offset by several pixels, and do
            // a global hit test.

            POINT ptGlobal;
            RECT rcGlobalClient;

            IFC( pDispPointer->GetFlowElement(&spIFlowElement) );
            if (spIFlowElement == NULL)
            {
                Assert(FALSE);
                goto Cleanup;
            }
            IFC( MshtmledUtil::IsElementInVerticalLayout(spIFlowElement, &fVertical) );
          
            IFC( GetEditor()->GetClientRect( spElement, & rcGlobalClient ));

            if( inMove == CARET_MOVE_VIEWSTART )
            {
                dwAdjustOptions |= ADJPTROPT_EnterTables;
                if (fVertical)
                {
                    ptGlobal.x = rcGlobalClient.right - 1;
                    ptGlobal.y = rcGlobalClient.top + 1;
                }
                else
                {
                    ptGlobal.x = rcGlobalClient.left+1;
                    ptGlobal.y = rcGlobalClient.top+1;
                }
            }
            else
            {
                if (fVertical)
                {
                    ptGlobal.x = rcGlobalClient.left+1;
                    ptGlobal.y = rcGlobalClient.bottom-1;
                }
                else
                {
                    ptGlobal.x = rcGlobalClient.right-1;
                    ptGlobal.y = rcGlobalClient.bottom-1;
                }
            }

            IFC( pDispPointer->MoveToPoint(ptGlobal, COORD_SYSTEM_GLOBAL, NULL, 0, NULL));
            break;
        }

        case CARET_MOVE_PAGEUP:
        case CARET_MOVE_PAGEDOWN:
        {
            SP_IHTMLElement spScroller;
            SP_IHTMLElement2 spScroller2;
            POINT ptCaretLocation;
            POINT ptScrollDelta;
            RECT  windowRect;

            //
            // Review-2000/07/24-zhenbinx: It is okay to do lazy 
            // HWND if we are sure that hwnd will be initialized
            // before it is used. This happens if we goto CanScroll 
            // without getting hwnd -- since there is a branch under
            // CanScroll that uses hwnd. In reality, we will never 
            // be wrong since if we jump too early, ScrollDelta will
            // be 0 so we don't scroll at all, which means hwnd is 
            // not going to be used. 
            //
            // So assigning NULL to hwnd is okay in this case. 
            //
            HWND hwnd = NULL; // keep compiler happy
            POINT ptWindow;
            SP_IOleWindow spOleWindow;
            SP_IMarkupPointer spPointer;
            
            BOOL              fNoScrollerBlockLayout = FALSE;
            SP_IHTMLElement2  spElement2;
            RECT              rectBlock;
            POINT             ptTopLeft;
            POINT             ptBottomRight;
            
            LONG lScrollLeft = 0;
            LONG lScrollTop = 0;

            ptScrollDelta.x = 0;
            ptScrollDelta.y = 0;
            ptCaretLocation.x = 0;
            ptCaretLocation.y = 0;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( pDispPointer->PositionMarkupPointer(spPointer) );

            //
            // We try to get the appropriate scroller
            //
            {
                if (fIgnoreElementBoundaries)
                {
                    IFC(GetScrollingElement(GetMarkupServices(), spPointer, NULL, &spScroller));
                }
                else
                {
                    IFC(GetScrollingElement(GetMarkupServices(), spPointer, spElement, &spScroller));
                }
                    
                if( spScroller == NULL )
                {
                    Assert (!fIgnoreElementBoundaries);     // if ignore element boundary
                                                            // there must be a scroller!!!
                    // HACKHACK:
                    // If this is a block element however is not scrollable 
                    // its layout size might be bigger than current view port
                    // so we want to scroll it *as if* there is no element boundary
                    // (zhenbinx)
                    //
                    //
                    BOOL    fBlock, fLayout, fScroller;
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout, &fScroller));
                    Assert (!fScroller);
                    fNoScrollerBlockLayout = (fBlock && fLayout && !fScroller);
                    if (fNoScrollerBlockLayout)
                    {
                        IFC( GetScrollingElement(GetMarkupServices(), spPointer, NULL, &spScroller) );
                    }

                    if (spScroller == NULL)     
                    {
                        //
                        // NoScroller NotBlock Layout e.g. Inline Input Field
                        //
                        //
                        goto CantScroll;    // we are done
                    }
                }
                IFC( spScroller->QueryInterface( IID_IHTMLElement2, (void **) &spScroller2 ));
                Assert (!(spScroller2 == NULL) );
            }
            //
            // We want to bound the destination point to reasonable
            // and visible position
            //
            {
                //
                // 1) Get the visible window
                //
                IFC( GetSelectionManager()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
                IFC( spOleWindow->GetWindow(&hwnd) );
                GetEditor()->GetWindowRect( hwnd, &windowRect );

                //
                // 2) See if a scrolling is necessary
                //
                IFC( spElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
                Assert(!(spElement2 == NULL));
                IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );

                if (fNoScrollerBlockLayout && !ShouldScrollIntoView(hwnd, &rectBlock, &windowRect, inMove) )
                {
                    goto CantScroll;
                }
                
                //
                // 3) Get me the caret's position in global coord's
                //
                IFC( GetLocation( &ptCaretLocation, TRUE )); 
                ptWindow = ptCaretLocation;
                GetEditor()->ClientToScreen( hwnd, &ptWindow );

                //
                // 4) Make sure target caret position is visible
                //
                if( ptWindow.x < windowRect.left )
                    ptCaretLocation.x = ptCaretLocation.x + ( windowRect.left - ptWindow.x ) + 5;

                if( ptWindow.x > windowRect.right )
                    ptCaretLocation.x = ptCaretLocation.x - ( ptWindow.x - windowRect.right ) - 5;

                if( ptWindow.y < windowRect.top )
                    ptCaretLocation.y = ptCaretLocation.y + ( windowRect.top - ptWindow.y ) + 5;

                if( ptWindow.y > windowRect.bottom )
                    ptCaretLocation.y = ptCaretLocation.y - ( ptWindow.y - windowRect.bottom ) - 5;
            }
            
            //
            // Do scrolling and compute the scrolling delta
            //
            {
                IFC( spScroller2->get_scrollLeft( & ptScrollDelta.x ));
                IFC( spScroller2->get_scrollTop( & ptScrollDelta.y ));

                CVariant var;
                V_VT( &var ) = VT_BSTR;

                if( inMove == CARET_MOVE_PAGEDOWN )
                {
                    V_BSTR( &var ) = SysAllocString(_T("pageDown"));
                }
                else
                {                
                    V_BSTR( &var ) = SysAllocString(_T("pageUp"));
                }

                hr = THR( spScroller2->doScroll( var ));
                
                if( FAILED( hr ))
                    goto Cleanup;
                
                IFC( spScroller2->get_scrollLeft( & lScrollLeft ));
                IFC( spScroller2->get_scrollTop( & lScrollTop ));
                ptScrollDelta.x -= lScrollLeft;
                ptScrollDelta.y -= lScrollTop;
            }

CantScroll:
            // Did we scroll a visible amount? If not, just move to the top or bottom of the element
            if( abs( ptScrollDelta.x ) < 7 && abs( ptScrollDelta.y ) < 7 )
            {   
                // like other keynav - default to bol if unknown

                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

                // we didn't scroll anywhere, go to the start or end of the current editable element
                if( inMove == CARET_MOVE_PAGEDOWN )
                {
                    if (fNoScrollerBlockLayout || spScroller == NULL)
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ) );
                    }
                    else
                    {
                        IFC( spPointer->MoveAdjacentToElement( spScroller, ELEM_ADJ_BeforeEnd ));
                    }
                    IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                }
                else
                {
                    if (fNoScrollerBlockLayout || spScroller == NULL)
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ) );
                    }
                    else
                    {
                        IFC( spPointer->MoveAdjacentToElement( spScroller, ELEM_ADJ_AfterBegin ));
                    }
                    IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                }
            }
            else
            {   
                // we scrolled. figure out what element we hit. if we hit an image or control that isn't
                // our edit context, we want to move adjacent to that element's start or end. if we 
                // didn't, we want to to a global hit test at our adjusted caret location to relocate
                // the pointer.
                
                SP_IHTMLElement spElementAtCaret;
                BOOL fSameElement = FALSE;
                IObjectIdentity * pIdent;
                ELEMENT_TAG_ID eTagId;

                if (fNoScrollerBlockLayout)
                {
                    //
                    // Bound the hit testing to be inside block
                    //
                    // Get the bounding client rect again since it might have been 
                    // changed due to scrolling
                    //
                    Assert (!(spElement2 == NULL));
                    IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );
                    ptTopLeft.x     = rectBlock.left;
                    ptTopLeft.y     = rectBlock.top;
                    ptBottomRight.x = rectBlock.right;
                    ptBottomRight.y = rectBlock.bottom;
                    GetEditor()->ClientToScreen(hwnd, &ptTopLeft);
                    GetEditor()->ClientToScreen(hwnd, &ptBottomRight);
                    
                    ptWindow = ptCaretLocation;
                    GetEditor()->ClientToScreen(hwnd, &ptWindow);
                    if (ptWindow.y < ptTopLeft.y)
                        ptCaretLocation.y = ptCaretLocation.y + (ptTopLeft.y - ptWindow.y) + 5;
                    if (ptWindow.y > ptBottomRight.y)
                        ptCaretLocation.y = ptCaretLocation.y - (ptWindow.y - ptBottomRight.y) - 5;
                }

                IFC(GetSelectionManager()->GetDoc()->elementFromPoint(ptCaretLocation.x, ptCaretLocation.y, &spElementAtCaret));
                BOOL fShouldHitTest = TRUE;

                if (spElementAtCaret)
                {
                    IFC( spElementAtCaret->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent));      
                    fSameElement = ( pIdent->IsEqualObject ( spScroller ) == S_OK );
                    pIdent->Release();
                    IFC( GetMarkupServices()->GetElementTagId( spElementAtCaret, &eTagId ));
                
                    if( ! fSameElement && ( IsIntrinsic( GetMarkupServices(), spElementAtCaret ) || ( eTagId == TAGID_IMG )))
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElementAtCaret, inMove == CARET_MOVE_PAGEDOWN ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));
                        IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                        fShouldHitTest = FALSE;
                    }
                }

                if (fShouldHitTest)
                {
                    Assert (!(spElement == NULL)); // note: this is the edit context element
                    if (fIgnoreElementBoundaries && !fNoScrollerBlockLayout)
                    {
                        IFC( pDispPointer->MoveToPoint(ptCaretLocation, COORD_SYSTEM_GLOBAL, NULL, 0, NULL) );
                    }
                    else
                    {
                        IFC( pDispPointer->MoveToPoint(ptCaretLocation, COORD_SYSTEM_GLOBAL, spElement, 0, NULL) );
                    }
                }
            }
            
            break;
        }
        
        case CARET_MOVE_DOCSTART:
        case CARET_MOVE_DOCEND:
            {
                ELEMENT_ADJACENCY   elemAdj;
                DISPLAY_GRAVITY     dispGravity;

                if (CARET_MOVE_DOCSTART == inMove)
                {
                    elemAdj     = ELEM_ADJ_AfterBegin;
                    dispGravity = DISPLAY_GRAVITY_NextLine;
                    eMvDir      = LEFT;
                }
                else
                {
                    elemAdj     = ELEM_ADJ_BeforeEnd;
                    dispGravity = DISPLAY_GRAVITY_NextLine;
                    eMvDir      = RIGHT;
                }

                //
                // Move to target position
                //
                IFC( spPointer->MoveAdjacentToElement( spContentElement , elemAdj));
                IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                IFC( pDispPointer->SetDisplayGravity(dispGravity) );
                dwAdjustOptions |= ADJPTROPT_EnterTables;
                break;
            }
        
        case CARET_MOVE_BLOCKSTART:            
        {
            ED_PTR(epPos);
            //
            // In case we are already on that start of a block
            // we need to move up one block. 
            // 
       		IGNORE_HR( MovePointer(CARET_MOVE_BACKWARD, pDispPointer, ptgXYPosForMove, peMvDir) );

            IFC( epPos.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()) );
            IFC( pDispPointer->PositionMarkupPointer(epPos) );
            IFC( MshtmledUtil::MoveMarkupPointerToBlockLimit(GetEditor(), LEFT, epPos, ELEM_ADJ_AfterBegin) );
            IFC( pDispPointer->MoveToMarkupPointer(epPos, NULL) );
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

            eMvDir = LEFT;
            break;
        }
        
        case CARET_MOVE_NEXTBLOCK:
        {
            ED_PTR(ePos);
			//
			// Always move to end of block
			//
            IFC( ePos.SetBoundary(_pManager->GetStartEditContext(), _pManager->GetEndEditContext()) );
            IFC( pDispPointer->PositionMarkupPointer(ePos) );
            IFC( MshtmledUtil::MoveMarkupPointerToBlockLimit(GetEditor(), RIGHT, ePos, ELEM_ADJ_BeforeEnd) );
            IFC( pDispPointer->MoveToMarkupPointer(ePos, NULL) );
			//
			// Try to move one character to next block
			//
            IGNORE_HR( MovePointer(CARET_MOVE_FORWARD, pDispPointer, ptgXYPosForMove, peMvDir) );
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

            eMvDir = RIGHT;
            break;
        }            

        case CARET_MOVE_ATOMICSTART:
        {
            SP_IHTMLElement spAtomicElement;

            IFC( GetCurrentScope(pDispPointer, &spAtomicElement) );
            IFC (AdjustForAtomic(pDispPointer, spAtomicElement, TRUE, ptgXYPosForMove, NULL,
                                    TRUE, SELECTION_TYPE_Caret) );
            eMvDir = LEFT;
            break;
        }

        case CARET_MOVE_ATOMICEND:
        {
            SP_IHTMLElement spAtomicElement;

            IFC( GetCurrentScope(pDispPointer, &spAtomicElement) );
            IFC (AdjustForAtomic(pDispPointer, spAtomicElement, FALSE, ptgXYPosForMove, NULL,
                                    TRUE, SELECTION_TYPE_Caret) );
            eMvDir = RIGHT;
            break;
        }
    }

    {
        //
        // check to see if the movement is valid/possible, 
        // i.e. -- if it moves to an editable element
        // otherwise reverse back to the original position
        //
        Assert( _pManager );
        if (!_pManager->IsInEditContext(pDispPointer))
        {
            IFC( pDispPointer->MoveToPointer(spOrigDispPointer) );
            goto Cleanup;
        }
    }
    
    // Properly constrain the pointer
    {
        BOOL fAtLogicalBOL = FALSE;
            
        if( eBlockAdj == SAME )
        {
            IGNORE_HR( pDispPointer->IsAtBOL(&fAtLogicalBOL) );
            eBlockAdj = fAtLogicalBOL ? RIGHT : LEFT;
        }

        //
        // Check to see if we have moved into a different site selectable object.
        // If this happens - we jump over the site
        //
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        if (GetEditor()->IsInDifferentEditableSite(spPointer) )
        {
            SP_IHTMLElement spFlow;
            CEditPointer    epTest(GetEditor());
            DWORD           dwSearch = BREAK_CONDITION_Content|BREAK_CONDITION_Glyph;
            DWORD           dwFound;

            IFC( pDispPointer->GetFlowElement(&spFlow));
            
            if (GetPointerDirection( inMove ) == RIGHT)
            {
                IFC( spPointer->MoveAdjacentToElement( spFlow, ELEM_ADJ_AfterEnd));
                IFC( epTest->MoveToPointer(spPointer) );
                IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_Glyph) &&
                    CheckFlag(dwFound, BREAK_CONDITION_Block) &&
                    CheckFlag(dwFound, BREAK_CONDITION_EnterSite)
                    )
                {
                    //
                    // we have a glyph here - so we don't want to exit this line
                    // prematurelly
                    //
                    pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine);
                }
            }
            else
            {
                IFC( spPointer->MoveAdjacentToElement( spFlow, ELEM_ADJ_BeforeBegin));
                IFC( epTest->MoveToPointer(spPointer) );
                IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_Glyph) &&
                    CheckFlag(dwFound, BREAK_CONDITION_Block) &&
                    CheckFlag(dwFound, BREAK_CONDITION_EnterSite)
                    )
                {
                    //
                    // we have a glyph here - so we don't want to exit this line
                    // prematurelly
                    //
                    pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine);
                }
            }
            IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        }

        //
        // HACKHACK (johnbed)
        // Now the pointer is in the right place. Problem: fNotAtBOL may be wrong if the line is empty.
        // Easy check: if fNotAtBOL == TRUE, make sure there isn't a block phrase to the left of us. <BR>
        // and \r are never swallowed, and being to the right of one of them with fNotAtBOL==TRUE will 
        // make us render in a bad place.
        // 
        // The right fix is to create a line-aware CEditPointer subclass that encapsulates moving in
        // a line aware way and to use these pointers instead of raw markup pointers.
        //

        IFC( ConstrainPointer(pDispPointer, 
                               ( GetPointerDirection( inMove ) == RIGHT ))); // don't rely on AdjPointer for this.

        fAtLogicalBOL = FALSE;
        IFC( pDispPointer->IsAtBOL(&fAtLogicalBOL) );

        IFC( AdjustPointerForInsert( pDispPointer , eBlockAdj, fAtLogicalBOL ? RIGHT : LEFT, dwAdjustOptions) );

        {
            //
            // HACKHACK: #108352
            // By now, we could have adjusted the pointer to an 
            // ambigious position from an unambigious poisition
            // So it is obvious that the BR check should have 
            // been here. 
            //
            IFC( pDispPointer->IsAtBOL(&fAtLogicalBOL) );
        }
        
        if( !fAtLogicalBOL)
        {
            ED_PTR( epScan ); 
            DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor; // anchors are just phrase elements to me here
            DWORD dwFound = BREAK_CONDITION_None;
            
            IFC( pDispPointer->PositionMarkupPointer(epScan) );

            IFC( epScan.Scan( LEFT, dwSearch, &dwFound ));

            if( CheckFlag( dwFound, BREAK_CONDITION_NoScopeBlock ) )
            {
                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            }
        }
    }
            
Cleanup:
    if (peMvDir)
        *peMvDir = eMvDir; 

    RRETURN( hr );
}

HRESULT
CEditTracker::AdjustPointerForInsert( 
    IDisplayPointer  * pDispWhereIThinkIAm, 
    Direction        inBlockcDir, 
    Direction        inTextDir, 
    DWORD            dwOptions /* = NULL */ )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spLeftEdge;
    SP_IMarkupPointer spRightEdge;    
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spLeftEdge ));
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spRightEdge ));
    IFC( _pManager->MovePointersToContext( spLeftEdge, spRightEdge ));
    IFC( _pManager->GetEditor()->AdjustPointer( pDispWhereIThinkIAm, inBlockcDir, inTextDir, spLeftEdge, spRightEdge, dwOptions ));

Cleanup:
    RRETURN( hr );
}


HRESULT
CEditTracker::TakeCapture()
{
    TraceTag(( tagSelectionTrackerState, "TakingCapture"));    

    RRETURN( _pManager->GetEditor()->TakeCapture( this ));
}

HRESULT 
CEditTracker::ReleaseCapture(BOOL fReleaseCapture /*=TRUE*/ )
{
    TraceTag(( tagSelectionTrackerState, "ReleasingCapture"));    

    RRETURN( _pManager->GetEditor()->ReleaseCapture( this , fReleaseCapture ));
}


//+====================================================================================
//
// Method: InitMetrics
//
// Synopsis: Iniitalize any static vars for the SelectionManager
//
//------------------------------------------------------------------------------------

VOID
CEditTracker::InitMetrics()
{
#ifdef WIN16
    // (Stevepro) Isn't there an ini file setting for this in win16 that is used
    //         for ole drag-drop?
    //
    // Width and height, in pixels, of a rectangle centered on a drag point
    // to allow for limited movement of the mouse pointer before a drag operation
    // begins. This allows the user to click and release the mouse button easily
    // without unintentionally starting a drag operation
    //
    gSizeDragMin.cx = 3;
    gSizeDragMin.cy = 3;
#else
    gSizeDragMin.cx = GetSystemMetrics(SM_CXDRAG);
    gSizeDragMin.cy = GetSystemMetrics(SM_CYDRAG);
    g_iDragDelay = GetProfileIntA(s_achWindows, "DragDelay", 20);
#endif
}

int 
CEditTracker::GetMinDragSizeX()
{
    return gSizeDragMin.cx;
}

int 
CEditTracker::GetMinDragSizeY()
{
    return gSizeDragMin.cy;
}
    
int 
CEditTracker::GetDragDelay()
{
    return g_iDragDelay;
}

//+====================================================================================
//
// Method: ConstrainPointer
//
// Synopsis: Check to see that the caret is in the edit context of the manager.
//           IF it isn't position appropriately.
//          If the caret has gone before the Start, postion at start of context
//          If the caret has gone after the end, position at end of context
//
//------------------------------------------------------------------------------------


HRESULT
CEditTracker::ConstrainPointer( IDisplayPointer* pDispPointer, BOOL fDirection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );
    
    IFC( ConstrainPointer(spPointer, fDirection) );

    IFC( pDispPointer->MoveToMarkupPointer(spPointer, pDispPointer) );

Cleanup:
    RRETURN(hr);
}    

VOID
CEditTracker::SetupSelectionServices( )
{
    if( _pSelServ )
    {
        _pSelServ->Release();
    }
    
    _pSelServ = GetEditor()->GetSelectionServices();
    _pSelServ->AddRef();
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Moved the pos tracker definition/implementation from cartracker to postracker
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CPosTracker::CPosTracker()
{
    _fFrozen = FALSE;
    _cp = -1;
    _pContainer = NULL;
    _lContainerVersion = -1;    
    InitPosition();
}

VOID 
CPosTracker::InitPosition()
{
    if (!_fFrozen)
    {
        _lContainerVersion = -1; 
        _ptPos.x = CARET_XPOS_UNDEFINED;
        _ptPos.y = CARET_YPOS_UNDEFINED;
    }
}


BOOL 
CPosTracker::FreezePosition(BOOL fFrozen)
{
    BOOL  fRet = _fFrozen;
    _fFrozen = fFrozen;
    return fRet;
}


CPosTracker::~CPosTracker()
{
    ClearInterface(&_pContainer);    
}

HRESULT 
CPosTracker::UpdatePosition(IMarkupPointer *pPointer, POINT ptPos)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;
    SP_IMarkupPointer2      spPointer2;

    if (_fFrozen)
    {
        goto Cleanup;
    }
    
    _lContainerVersion = -1; 
    
    if (!pPointer || ((ptPos.x == CARET_XPOS_UNDEFINED) && (ptPos.y == CARET_YPOS_UNDEFINED)))
            goto Cleanup;

    //
    // Get IMarkupPointer2 and IMarkupContainer2
    // 
    
    IFC( pPointer->GetContainer(&spContainer) );
    if (!spContainer)
        goto Cleanup;
    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
    
    //
    // Update the caret position
    //

    IFC( spPointer2->GetMarkupPosition(&_cp) );
    ReplaceInterface(&_pContainer, (IMarkupContainer *)spContainer2);
    _lContainerVersion = spContainer2->GetVersionNumber();
    _ptPos = ptPos;

Cleanup:
    RRETURN(hr);        
}

HRESULT 
CPosTracker::GetPosition(IMarkupPointer *pPointer, POINT *ptPos)
{
    HRESULT                 hr = S_OK;
    SP_IUnknown             spUnk1, spUnk2;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;
    SP_IMarkupPointer2      spPointer2;
    LONG                    cp;

    Assert(pPointer);
    Assert(ptPos);
    
    ptPos->x = CARET_XPOS_UNDEFINED;
    ptPos->y = CARET_YPOS_UNDEFINED;

    //
    // Check for valid position
    //
    
    if (_lContainerVersion < 0 || _cp < 0 || !_pContainer)
        goto Cleanup;

    //
    // Check that the cp's are equal
    //

    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
    IFC( spPointer2->GetMarkupPosition(&cp) );
    
    if (_cp != cp)
        goto Cleanup; // cp's not equal
        
    //
    // Check that the containers are equal
    //
    
    IFC( pPointer->GetContainer(&spContainer) );
    if (!spContainer)
        goto Cleanup;
    
    IFC( spContainer->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk1) );
    IFC( _pContainer->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk2) );

    if (spUnk1 != spUnk2)
        goto Cleanup; // containers not equal

    
    //
    // Check that the container versions are the same
    //

    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    if (spContainer2->GetVersionNumber() != _lContainerVersion)
        goto Cleanup;

    //
    // Ok to return real x position
    //

    *ptPos = _ptPos;

Cleanup:
    RRETURN(hr);
};

HRESULT
CEditTracker::GetCurrentScope(IDisplayPointer *pDisp, IHTMLElement **pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spMarkup;
    
    IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
    IFC( pDisp->PositionMarkupPointer(spMarkup) );
    IFC( spMarkup->CurrentScope(pElement) );

Cleanup:

    RRETURN ( hr );
}

HRESULT
CEditTracker::AdjustForAtomic(
                IDisplayPointer* pDisp,
                IHTMLElement* pElement,
                BOOL fStartOfSelection, 
                POINT* ppt,
                BOOL* pfDidSelection,
                BOOL fDirection,
                SELECTION_TYPE eSelectionType,
                IMarkupPointer** ppStartPointer /*=NULL*/,
                IMarkupPointer** ppEndPointer /*=NULL*/)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartPointer;
    SP_IMarkupPointer   spEndPointer;
    SP_IHTMLElement     spElement = pElement;
    SP_IHTMLElement     spAtomicElement;
    BOOL                fHasAtomicParentElement = FALSE;
    BOOL                fEditContextWasUpdated = FALSE;
    BOOL                fReentrantAdjustForAtomic = FALSE;
    
    if (pfDidSelection)
        *pfDidSelection = FALSE;

    //  If reentrency detected, back out.
    if (_fDontAdjustForAtomic)
    {
        fReentrantAdjustForAtomic = TRUE;
        goto Cleanup;
    }
    
    _fDontAdjustForAtomic = TRUE;
    
    //  Find the atomic selected element
    Assert(spElement != NULL);
    IFC( _pManager->FindAtomicElement(spElement, &spAtomicElement) );
    if (spAtomicElement)
    {
        ReplaceInterface(&spElement, (IHTMLElement *)spAtomicElement);
        fHasAtomicParentElement = TRUE;
    }

    //  Set our start and end markup pointers adjacent to our selected element
    IFC( GetEditor()->CreateMarkupPointer( & spStartPointer ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndPointer ));
    IFC( spStartPointer->MoveAdjacentToElement( spElement ,
                                              fDirection ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
    IFC( spEndPointer->MoveAdjacentToElement( spElement ,
                                              fDirection ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));

    //  If we have an atomic parent element, we may need to adjust the edit context.
    if (fHasAtomicParentElement && !_fEditContextUpdatedForAtomic)
    {
        SP_IHTMLElement     spAtomicScope;
        SP_IDisplayPointer  spAtomicDispPointer;

        //  Make sure that the current edit context includes the selection.

        //  We need to get the scope of the display start pointer since our
        //  display pointers are outside of the scope of the atomic element.
        IFC( GetDisplayServices()->CreateDisplayPointer(&spAtomicDispPointer) );
        IGNORE_HR( spAtomicDispPointer->MoveToMarkupPointer(spStartPointer, NULL) );
        IFC( GetCurrentScope( spAtomicDispPointer, &spAtomicScope) );   

        //  Set the scope to the scope of our start pointer so that we can
        //  ensure that our display pointers are contained within the context.
        _pManager->UpdateEditContextFromElement(spAtomicScope,
                                                fDirection ? spStartPointer : spEndPointer,
                                                fDirection ? spEndPointer : spStartPointer,
                                                &fEditContextWasUpdated);

        //  If the edit context was updated, we need to update the selection
        //  which will create a new sel tracker.  So, if we do this we will
        //  need to make sure our calling functions don't change anything
        //  with the old sel tracker since it will be invalid.

        if (fEditContextWasUpdated)
        {
            //  Reset the selection and tracker state.
            IFC( _pManager->Select(spStartPointer, spEndPointer, eSelectionType) );
            if (pfDidSelection)
                *pfDidSelection = TRUE;
        }
        
        //  Set our flag so that we don't attempt to update the context again for this selection.
        _fEditContextUpdatedForAtomic = TRUE;        
    }

    if (!fEditContextWasUpdated)
    {
        //  Move the display pointer to the appropriate markup pointer
        if ( fStartOfSelection )
        {
            IGNORE_HR( pDisp->MoveToMarkupPointer( spStartPointer, NULL ));                                                                      
        }
        else
        {
            IGNORE_HR( pDisp->MoveToMarkupPointer( spEndPointer, NULL ));                                                                      
        }
    }
    
    if (ppStartPointer)
    {
        ReplaceInterface(ppStartPointer, (IMarkupPointer *)spStartPointer);
    }

    if (ppEndPointer)
    {
        ReplaceInterface(ppEndPointer, (IMarkupPointer *)spEndPointer);
    }

Cleanup:

    if (!fReentrantAdjustForAtomic)
        _fDontAdjustForAtomic = FALSE;

    RRETURN( hr );

}


HRESULT 
CEditTracker::HandleDirectionalKeys(
                    CEditEvent *pEvent
                    )
{
    HRESULT             hr = S_FALSE;
    IHTMLElement        *pIEditElement = NULL;
    SP_IHTMLElement2    spElement2;
    LONG                keyCode;

    Assert( pEvent );
    //
    // Bidirectional is enabled in Bidi systems
    // and Win2k+ without Bidi locale installed
    //
    IGNORE_HR( pEvent->GetKeyCode(&keyCode) );
    switch (pEvent->GetType())
    {
    case EVT_KEYDOWN:
        {
            BOOL fShiftLeft;
            if (VK_SHIFT == keyCode && pEvent->IsControlKeyDown() )
            {
                IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetShiftLeft(&fShiftLeft) ); // capture left shift state
                _fShiftLeftCapture = fShiftLeft;
                _fShiftCapture     = TRUE;
            }
            else
            {
                _fShiftCapture  = FALSE;
            } 
        }
        break;
        
    case EVT_KEYUP:
        {
            if (_fShiftCapture) 
            {
                if ( 
                    ((VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode) && pEvent->IsControlKeyDown())  ||
                    ((VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode) && pEvent->IsShiftKeyDown())
                   )
                {
                    //
                    // Just set it. We don't care if Bidi is enabled.
                    //
                    if (_pManager->IsContextEditable())
                    {
                        if (EdUtil::IsBidiEnabled())
                        {
                            long eHTMLDir = _fShiftLeftCapture ? htmlDirLeftToRight : htmlDirRightToLeft;
                            IFC( _pManager->GetEditableElement(&pIEditElement) );
                            IFC( pIEditElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
                            switch (eHTMLDir)
                            {
                                case htmlDirRightToLeft:
                                    IFC( spElement2->put_dir( L"rtl" ) );
                                    break;
                                case htmlDirLeftToRight:
                                    IFC( spElement2->put_dir( L"ltr" ) );
                                    break;
                                default:
                                    AssertSz(0, "Unexpected block direction");
                            }
                            hr = S_OK;
                        }
                    }
                }
                _fShiftCapture     = FALSE;
            }
        }
    };
    
Cleanup:
    ReleaseInterface( pIEditElement );
    return hr;    
}

BOOL
CEditTracker::ShouldScrollIntoView( HWND hwnd,
                                    const RECT *rectBlock,
                                    const RECT *windowRect,
                                    CARET_MOVE_UNIT inMove/*=CARET_MOVE_NONE*/)
{
    POINT               ptTopLeft;
    POINT               ptBottomRight;
    BOOL                fShouldScroll = TRUE;
    
    //
    // Don't scroll if it is in block and the block element is already visible
    //
    //
    ptTopLeft.x     = rectBlock->left;
    ptTopLeft.y     = rectBlock->top;
    ptBottomRight.x = rectBlock->right;
    ptBottomRight.y = rectBlock->bottom;
    GetEditor()->ClientToScreen(hwnd, &ptTopLeft);
    GetEditor()->ClientToScreen(hwnd, &ptBottomRight);
    switch (inMove)
    {
    // TODO: need to consider Adorner instead of using 5 pixel here!
    case CARET_MOVE_PAGEUP:
        if (ptTopLeft.y > windowRect->top + 7)
        {
            TraceTag((tagEdKeyNav, "PgUp in block with visible top, don't scroll"));
            fShouldScroll = FALSE;
        }
        break;
    case CARET_MOVE_PAGEDOWN:
        if (ptBottomRight.y < windowRect->bottom - 7)
        {
            TraceTag((tagEdKeyNav, "PgDown in block with visible bottom, don't scroll"));
            fShouldScroll = FALSE;
        }
        break;
    case CARET_MOVE_NONE:
        fShouldScroll = ((ptTopLeft.y <= windowRect->top + 7) || (ptBottomRight.y >= windowRect->bottom - 7));
        break;
    }
     
    return fShouldScroll;
}

//+---------------------------------------------------------------------
//
// Method: WeOwnsSelectionServices
//
// Synopsis: Do we own the things in selection services ? If not it's 
//           considered bad to do things like change trackers etc.
//
//+---------------------------------------------------------------------

HRESULT
CEditTracker::WeOwnSelectionServices()
{
    HRESULT hr;
    SP_IUnknown spUnk;
    SP_ISelectionServicesListener spListener;
    
    IFC( GetSelectionServices()->GetSelectionServicesListener( & spListener ));
    if ( spListener )
    {
        IFC( spListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
       
        hr = (IUnknown*) spUnk == (IUnknown*)_pManager  ? S_OK : S_FALSE ;
    }
    else
        hr = E_FAIL ;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CEditTracker::AdjustOutOfAtomicElement(IDisplayPointer *pDispPointer, IHTMLElement *pAtomicElement, int iDirectionForAtomicAdjustment)
{
    HRESULT             hr;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    SP_IMarkupPointer   spTestPointer;
    BOOL                fResult = FALSE;
    int                 iEdge = 0;

    WHEN_DBG( Assert(_pManager->CheckAtomic(pAtomicElement) == S_OK) );

    //  See if the caret was positioned at the inside edge of the atomic element.  It's most
    //  likely at the beforeend position.  If it is in the inside edge, then reposition the
    //  caret outside of the element on that side.

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( spTestPointer->MoveAdjacentToElement( pAtomicElement, ELEM_ADJ_BeforeEnd) );
    IFC( spPointer->IsEqualTo(spTestPointer, &fResult) );

    if (fResult)
    {
        iEdge = RIGHT;
    }
    else
    {
        IFC( spTestPointer->MoveAdjacentToElement( pAtomicElement, ELEM_ADJ_AfterBegin) );
        IFC( spPointer->IsEqualTo(spTestPointer, &fResult) );
        if (fResult)
            iEdge = LEFT;
    }

    if (iEdge)
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), pDispPointer, pAtomicElement, FALSE, iEdge) );
    }
    else if (iDirectionForAtomicAdjustment)
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), pDispPointer, pAtomicElement, FALSE, iDirectionForAtomicAdjustment) );
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\dlghelpr.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  Class:      CHtmlDlgHelper
//
//  Contents:   DlgHelpr OC which gets embedded in design time dialogs
//
//  History:    12-Mar-98   raminh  Created
//----------------------------------------------------------------------------
#ifndef _DLGHELPR_H_
#define _DLGHELPR_H_

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H
#include "resource.h"    
#endif

MtExtern(CHtmlDlgHelper)
MtExtern(CHtmlDlgSafeHelper)

#define SetErrorInfo( x )   x

MtExtern(CFontNameOptions)
MtExtern(CFontNameOptions_aryFontNames_pv)

#define _hxx_
#include "mshtmext.hdl"

EXTERN_C const IID LIBID_MSHTML;

class ATL_NO_VTABLE CFontNameOptions : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CFontNameOptions, &IID_IHtmlFontNamesCollection>,
    public IDispatchImpl<IHtmlFontNamesCollection, &IID_IHtmlFontNamesCollection, &LIBID_OPTSHOLDLib>
{
public:
    CFontNameOptions()  { }
    ~CFontNameOptions();
    
    DECLARE_REGISTRY_RESOURCEID(IDR_FONTSOPTION)
    DECLARE_NOT_AGGREGATABLE(CFontNameOptions)

    BEGIN_COM_MAP(CFontNameOptions) 
        COM_INTERFACE_ENTRY(IHtmlFontNamesCollection)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    // IHtmlFontNamesCollection
	STDMETHOD(get_length)(/*[retval, out]*/ long * p);
	STDMETHOD(item)(/*[in]*/ long index, /*[retval, out]*/ BSTR* pBstr);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CFontNameOptions));

    // helper and builder functions
    HRESULT   AddName (TCHAR * strFontNamee);
    void      SetSize(long lSize) { _aryFontNames.SetSize(lSize); };

private:
    DECLARE_CDataAry(CAryFontNames, CStr, Mt(Mem), Mt(CFontNameOptions_aryFontNames_pv))
    CAryFontNames _aryFontNames;
};


class ATL_NO_VTABLE CHtmlDlgHelper :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHtmlDlgHelper,&CLSID_HtmlDlgHelper>,
    public CComControl<CHtmlDlgHelper>,
    public IDispatchImpl<IHtmlDlgHelper, &IID_IHtmlDlgHelper, &LIBID_OPTSHOLDLib>,
    public IOleControlImpl<CHtmlDlgHelper>,
    public IOleObjectImpl<CHtmlDlgHelper>,
    public IOleInPlaceActiveObjectImpl<CHtmlDlgHelper>,
    public IOleInPlaceObjectWindowlessImpl<CHtmlDlgHelper>,
    public ISupportErrorInfo
{
public:
    CHtmlDlgHelper()
    {
    	Assert(_pFontNameObj == NULL); // zero based allocator
    }

    ~CHtmlDlgHelper()
    {
    	ReleaseInterface(_pFontNameObj);
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_HTMLDLGHELPER)

    BEGIN_COM_MAP(CHtmlDlgHelper) 
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHtmlDlgHelper)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP()

    BEGIN_MSG_MAP(CHtmlDlgHelper)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    END_MSG_MAP()

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IHtmlDlgHelper
    STDMETHOD(get_fonts)(/*[retval, out]*/ IHtmlFontNamesCollection* * p);
    STDMETHOD(getCharset)(/*[in]*/ BSTR fontName,/*[retval, out]*/ long* charset);
    STDMETHOD(choosecolordlg)(/*[optional, in]*/ VARIANT initColor,/*[retval, out]*/ long* rgbColor);
    STDMETHOD(savefiledlg)(/*[optional, in]*/ VARIANT initFile,/*[optional, in]*/ VARIANT initDir,/*[optional, in]*/ VARIANT filter,/*[optional, in]*/ VARIANT title,/*[retval, out]*/ BSTR* pathName);
    STDMETHOD(openfiledlg)(/*[optional, in]*/ VARIANT initFile,/*[optional, in]*/ VARIANT initDir,/*[optional, in]*/ VARIANT filter,/*[optional, in]*/ VARIANT title,/*[retval, out]*/ BSTR* pathName);
    STDMETHOD(get_document)(/*[out, retval]*/ LPDISPATCH *pVal);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmlDlgHelper));

private:
    VOID        EnsureWrappersLoaded();	

    HRESULT     OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, 
                                 VARIANTARG filter, VARIANTARG title, 
                                 BSTR *pathName, BOOL fSaveFile, HWND hwndInPlace);

    CComObject<CFontNameOptions> * _pFontNameObj;   // pointer to font name object
};


//+---------------------------------------------------------------------------
//
//  CFontNames Class -- A collection of font names
//
//----------------------------------------------------------------------------

class ATL_NO_VTABLE CFontNames : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IFontNames, &IID_IFontNames, &LIBID_MSHTML, 4, 0>
{
public:

    CFontNames()
    {
    	_bInitialized = FALSE;
    	_lCount = 0;
    	_paryFontNames = NULL;
    }

    ~CFontNames();
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFontNames)
        COM_INTERFACE_ENTRY(IFontNames)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

public:
    //
    // IFontNames Interface
    //
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppEnum);
    STDMETHOD(get_Count)(long *plCount);
    STDMETHOD(Item)(VARIANT *pvarIndex, BSTR *pbstrFontNames);

    //
    // Initialization
    //
    HRESULT Init( CFontNameOptions *pFontNameObj );

    //
    // Accessors
    //
    long        GetCount(void)                  { Assert(IsInitialized()); return _lCount; }
    void        SetCount(long lCount)           { _lCount = lCount; }

    BOOL        IsInitialized(void)             { return _bInitialized; }
    void        SetInitialized(BOOL bInit)      { _bInitialized = bInit; }
    
private:

    BOOL        _bInitialized;              // Have we been successfully initialized?
    long        _lCount;                    // Number of font names
    CComVariant *_paryFontNames;         	// Array of font names
};


class ATL_NO_VTABLE CHtmlDlgSafeHelper : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHtmlDlgSafeHelper, &CLSID_HtmlDlgSafeHelper>,
    public CComControl<CHtmlDlgSafeHelper>,
    public IDispatchImpl<IHtmlDlgSafeHelper, &IID_IHtmlDlgSafeHelper, &LIBID_MSHTML, 4, 0>,
    public IOleControlImpl<CHtmlDlgSafeHelper>,
    public IOleObjectImpl<CHtmlDlgSafeHelper>,
    public IOleInPlaceActiveObjectImpl<CHtmlDlgSafeHelper>,
    public IOleInPlaceObjectWindowlessImpl<CHtmlDlgSafeHelper>,
    public IObjectSafetyImpl<CHtmlDlgSafeHelper>
{
public:
    CHtmlDlgSafeHelper()
    {
    	Assert(_pFontNameObj == NULL); // zero based allocator
        VariantInit(&_varBlockFormats);
        V_VT(&_varBlockFormats) = VT_NULL;
    }

    ~CHtmlDlgSafeHelper();

    DECLARE_REGISTRY_RESOURCEID(IDR_HTMLDLGSAFEHELPER)
    DECLARE_NOT_AGGREGATABLE(CHtmlDlgSafeHelper)

    BEGIN_COM_MAP(CHtmlDlgSafeHelper) 
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHtmlDlgSafeHelper)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    BEGIN_MSG_MAP(CHtmlDlgSafeHelper)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    END_MSG_MAP()

    // IHtmlDlgSafeHelper
    STDMETHOD(get_Fonts)(/*[retval, out]*/ LPDISPATCH *pcol);
    STDMETHOD(getCharset)(/*[in]*/ BSTR fontName,/*[retval, out]*/ VARIANT* charset);
    STDMETHOD(choosecolordlg)(/*[optional, in]*/ VARIANT initColor,/*[retval, out]*/ VARIANT* rgbColor);
    STDMETHOD(get_BlockFormats)(/*[retval, out]*/ LPDISPATCH *pcol);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmlDlgSafeHelper));

private:
    VOID        EnsureWrappersLoaded();	

    CComObject<CFontNameOptions> * _pFontNameObj;   // pointer to font name object
    VARIANT                        _varBlockFormats;    // contains a safearray of block formats
};

#endif //_DLGHELPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\dlghelpr.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       DLGHELPR.CXX
//
//  Contents:   DlgHelpr OC which gets embedded in design time dialogs
//
//  Classes:    CHtmlDlgHelper
//
//  History:    12-Mar-98   raminh  Created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_DLGHELPR_H_
#define X_DLGHELPR_H_
#include "dlghelpr.h"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

MtDefine(CHtmlDlgHelper, Utilities, "CHtmlDlgHelper")
MtDefine(CHtmlDlgSafeHelper, Utilities, "CHtmlDlgSafeHelper")

// Global variable used for retaining the save path
TCHAR       g_achSavePath[MAX_PATH + 1];

MtDefine(CFontNameOptions, Utilities, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHtmlFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHtmlFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Function:   get_document   
//
//  Synopsis:   Fetches the dialogs' document object, corresponds to document
//              property on the OC
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::get_document(LPDISPATCH * pVal)
{
    HRESULT hr;
    IHTMLDocument2 * pDoc = NULL;

    if (m_spClientSite)
    {
        hr = m_spClientSite->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc);
        *pVal = pDoc;
    }
    else
        *pVal = NULL;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   openfiledlg   
//
//  Synopsis:   Brings up the file open dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::openfiledlg(VARIANT initFile, VARIANT initDir, VARIANT filter, VARIANT title, BSTR * pathName)
{
    HWND            hwndDlg = NULL;
    HRESULT         hr = S_FALSE;

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hwndDlg );
    hr = THR(OpenSaveFileDlg( initFile, initDir, filter, title, pathName, FALSE, hwndDlg));
Cleanup:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Function:   savefiledlg   
//
//  Synopsis:   Brings up the file save dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::savefiledlg(VARIANT initFile, VARIANT initDir, VARIANT filter, VARIANT title, BSTR * pathName)
{
    HWND            hwndDlg = NULL;
    HRESULT         hr = S_FALSE;

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hwndDlg );
    hr = THR(OpenSaveFileDlg( initFile, initDir, filter, title, pathName, FALSE, hwndDlg));
Cleanup:
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   choosecolordlg   
//
//  Synopsis:   Brings up the color picker dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::choosecolordlg(VARIANT initColor, long * rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult = 0; 
    VARIANTARG      varArgTmp;

    hr = THR ( VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hWndInPlace );

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = hWndInPlace;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    EnsureWrappersLoaded();
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    //RRETURN(SetErrorInfo( hr ));
    RRETURN( hr );
#endif // WINCE}
}


//+------------------------------------------------------------------------
//
//  Function:   InterfaceSupportsErrorInfo   
//
//  Synopsis:   Rich error support per ATL
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IHtmlDlgHelper,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//+----------------------------------------------------------------
//
//  Function : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//             returns the selected filename
//
//+----------------------------------------------------------------
#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
CHtmlDlgHelper::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile, HWND hwndInPlace)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH + 1];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    bstrFile = SysAllocStringLen(NULL, MAX_PATH);
    if (bstrFile == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;
    }

    if (pvarInitFile)
    {
        _tcsncpy(bstrFile, V_BSTR(pvarInitFile), MAX_PATH);
        bstrFile[MAX_PATH + 1] = _T('\0');
    }
    else
    {
        *bstrFile = _T('\0');
    }

    Assert(hwndInPlace);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndInPlace;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;      // file name buffer
    ofn.nMaxFile        = MAX_PATH + 1;  // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    
    while (*pstrExt)
        pstrExt++;

    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }

            pSearch += _tcslen(pSearch);
            
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    _tcscpy(achPath, g_achSavePath);
    ofn.lpstrInitialDir = *achPath ? achPath : NULL;

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        SysFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:
    *pathName = bstrFile;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetCharacterSet
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
GetCharacterSet(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = ::GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ::ReleaseDC(NULL, hdc);
    }
    RRETURN( SetErrorInfo( hr ) );
}


//+------------------------------------------------------------------------
//
//  Function:   getCharset
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
CHtmlDlgHelper::getCharset(BSTR fontName, long * charset)
{
    RRETURN( GetCharacterSet(fontName, charset) );
}

//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
CHtmlDlgHelper::get_fonts(IHtmlFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;

    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CComObject<CFontNameOptions>;
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pFontNameObj->AddRef();
        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        m_spInPlaceSite->GetWindow(&hWndInPlace);

        hdc = ::GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ::ReleaseDC(hWndInPlace, hdc);
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHtmlFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

VOID            
CHtmlDlgHelper::EnsureWrappersLoaded()
{
    static fLoaded = FALSE;

    if (!fLoaded)
    {
        InitUnicodeWrappers();
        fLoaded = TRUE;
    }
}


CHtmlDlgSafeHelper::~CHtmlDlgSafeHelper()
{
    //  Destroy our internal font object
    ReleaseInterface(_pFontNameObj);

    //  Destroy our internal block formats object
    if (V_VT(&_varBlockFormats) != VT_NULL)
    {
        // This better be a safearray
        Assert(V_VT(&_varBlockFormats) == VT_ARRAY);
        SafeArrayDestroy(V_ARRAY(&_varBlockFormats));
    }
    VariantClear(&_varBlockFormats);
}

//+------------------------------------------------------------------------
//
//  Function:   choosecolordlg   
//
//  Synopsis:   Brings up the color picker dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgSafeHelper::choosecolordlg(VARIANT initColor, VARIANT* rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    DWORD           dwResult = 0; 
    IOleWindow      *pWindow = NULL;
    CColorValue     ccolor(&initColor);

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hWndInPlace );

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = hWndInPlace;
    structCC.lpCustColors    = aCColors;
    
    if (ccolor.IsDefined())
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = ccolor.GetOleColor();
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    EnsureWrappersLoaded();
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:
    if (hr == S_OK)
    {
        V_VT(rgbColor) = VT_I4;
        V_I4(rgbColor) = dwResult;
        EdUtil::ConvertOLEColorToRGB(rgbColor);
    }

    ReleaseInterface(pWindow);

    RRETURN( hr );
#endif // WINCE}
}

//+------------------------------------------------------------------------
//
//  Function:   getCharset
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
CHtmlDlgSafeHelper::getCharset(BSTR fontName, VARIANT* charset)
{
    HRESULT     hr = S_OK;
    long        lCharset;

    hr = GetCharacterSet(fontName, &lCharset);

    if (hr == S_OK)
    {
        V_VT(charset) = VT_I4;
        V_I4(charset) = lCharset;
    }

    RRETURN( hr );
}

//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
CHtmlDlgSafeHelper::get_Fonts(LPDISPATCH *pcol)
{
    HRESULT             hr = S_OK;
    HWND                hWndInPlace;
    HDC                 hdc;
    LOGFONT             lf;

    CComObject<CFontNames> *pIFontNames;

    Assert(pcol);

    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CComObject<CFontNameOptions>;
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pFontNameObj->AddRef();
        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        m_spInPlaceSite->GetWindow(&hWndInPlace);

        hdc = ::GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ::ReleaseDC(hWndInPlace, hdc);
        }
    }

    // Create an instance of our class
    IFC( CComObject<CFontNames>::CreateInstance(&pIFontNames) );

    // Initialize the class with the font names
    IFC( pIFontNames->Init( _pFontNameObj ) );

    // Retrieve the correct interface, and return it
    IFC( pIFontNames->QueryInterface(IID_IDispatch, (void **)pcol) );

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

VOID            
CHtmlDlgSafeHelper::EnsureWrappersLoaded()
{
    static fLoaded = FALSE;

    // TODO: protect with a critical section

    if (!fLoaded)
    {
        InitUnicodeWrappers();
        fLoaded = TRUE;
    }
}

HRESULT
CHtmlDlgSafeHelper::get_BlockFormats(LPDISPATCH *pcol)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget   *pCommandTarget = NULL;
    IOleClientSite      *pClientSite = NULL;
    IOleContainer       *pContainer = NULL;

    CComObject<CBlockFormats> *pIBlockFormats = NULL;

    Assert(pcol);

    if (V_VT(&_varBlockFormats) == VT_NULL)
    {
        // Find our IOleCommandTarget so that we can call the GetBlockFormats command
        // on the editor
        hr = m_spInPlaceSite->QueryInterface(IID_IOleClientSite, (void **)&pClientSite);
        if (hr == S_OK && pClientSite)
            hr = pClientSite->GetContainer(&pContainer);
        if (hr == S_OK && pContainer)
            hr = pContainer->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

        if ( hr == S_OK && pCommandTarget)
        {
            // Get the block formats
            hr = THR( pCommandTarget->Exec(
                    (GUID *)&CGID_MSHTML,
                    IDM_GETBLOCKFMTS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    &_varBlockFormats));
        }
    }
    
    if (OK(hr) && V_ARRAY(&_varBlockFormats) != NULL)
    {
        // Create an instance of our class
        IFC( CComObject<CBlockFormats>::CreateInstance(&pIBlockFormats) );

        // Initialize the class with the block formats
        IFC( pIBlockFormats->Init( V_ARRAY(&_varBlockFormats) ) );

        // Retrieve the correct interface, and return it
        IFC( pIBlockFormats->QueryInterface(IID_IDispatch, (void **)pcol) );
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pContainer);
    ReleaseInterface(pClientSite);

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::~CFontNames
//
//  Synopsis:   Clean up our array
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//--------------------------------------------------------------------------
CFontNames::~CFontNames()
{
    for (int i = _lCount-1; i >= 0; i--)
    {
        VariantClear(&_paryFontNames[i]);
    }
    if( _paryFontNames )
        delete [] _paryFontNames;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::get__NewEnum
//
//  Synopsis:   Returns an enumerator object which can be used to enumerate
//              over the font names.  Allows VBScript and JScript
//              clients to enumerate the contents using the for each statement
//              and the Enumerator object respectively.
//
//  Arguments:  ppEnum = OUTPUT - pointer to enumerator object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::get__NewEnum(/*[out, retval]*/ LPUNKNOWN *ppEnum)
{
    HRESULT     hr;

    if(ppEnum == NULL)
      return E_POINTER;
      
    *ppEnum = NULL;

    // Use the STL CComEnum class to implement our enumerator.  We are going 
    // to be enumerating and copying variants
    typedef CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > EnumVar;
    CComObject<EnumVar>  *pEnum;

    // Create our enumerator
    IFC( CComObject<EnumVar>::CreateInstance(&pEnum) );
      
    // Initialize the enumerator with this data, AtlFlagCopy is used
    // to make a copy of the data with _Copy<VARIANT>::copy().  Note that
    // the second parameter is a pointer to the next item AFTER the last
    // item in our array.
    IFC( pEnum->Init(&_paryFontNames[0], &_paryFontNames[GetCount()], NULL, AtlFlagCopy) );

    // An IUnknown pointer is required so use QueryInterface() which also
    // calls AddRef().
    IFC( pEnum->QueryInterface(IID_IUnknown, (void **)ppEnum) );

Cleanup:
       
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::get_Count
//
//  Synopsis:   Returns the number of font names
//
//  Arguments:  plCount = OUTPUT - pointer to count
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::get_Count(/*[out, retval]*/ long *plCount)
{
    if( plCount == NULL )
        return E_POINTER;

    Assert( IsInitialized() );

    *plCount = GetCount();
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::Item
//
//  Synopsis:   Returns the specific font name requested.  We only support
//              retrieval by integer based index.
//
//  Arguments:  pvarIndex = Index to retrieve
//              pbstrFontName = OUTPUT - pointer to BSTR for font name
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::Item(/*[in]*/ VARIANT *pvarIndex, /*[out, retval]*/ BSTR *pbstrFontName)
{
    if( (pbstrFontName == NULL) || (pvarIndex == NULL) )
        return E_POINTER;
        
    Assert( IsInitialized() );

    // VB6 will pass an VT_I2, but I also allow VT_I4 too
    if( (V_VT( pvarIndex ) == VT_I2) || (V_VT(pvarIndex) == VT_I4) )
    {
        int nIndex;

        // VB Arrays are 1 based
        nIndex = (V_VT(pvarIndex) == VT_I2) ? V_I2(pvarIndex) - 1 : V_I4(pvarIndex) - 1;

        // Check that a valid index is passed 
        if( (nIndex >= GetCount()) || (nIndex < 0) )
            return E_INVALIDARG;

        *pbstrFontName = SysAllocString(V_BSTR(&_paryFontNames[nIndex]));
    }

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::Init
//
//  Synopsis:   Initializes the block formats collection.  Takes an
//              array of font names and creates a collection.
//
//  Arguments:  pFontNameObj = our font names
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::Init( CFontNameOptions *pFontNameObj )
{
    HRESULT hr = S_OK;
    LONG    lCount = 0;
    LONG    lIndex = 0;
    LONG    lActualIndex = 0;
    BSTR    bstrFontName;
    

    Assert(pFontNameObj);

    // Find out how many fonts we have in the array
    IFC( pFontNameObj->get_length(&lCount) );
    Assert(lCount);
    
    // If array is not empty we'll need to create our internal array
    if (lCount)
    {
        // Create our array and store this data
        _paryFontNames = new CComVariant[ lCount ];
        if( !_paryFontNames )
            goto Error;

        for( lIndex = 0; lIndex < lCount; lIndex++ )
        {
            if (pFontNameObj->item(lIndex, &bstrFontName) == S_OK)
            {
                V_VT(&_paryFontNames[lActualIndex]) = VT_BSTR;
                V_BSTR(&_paryFontNames[lActualIndex++]) = bstrFontName;
            }
        }
        Assert(lCount == lActualIndex);
    }
    _lCount = lActualIndex;
    
    SetInitialized(TRUE);

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\edundo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       edundo.cxx
//
//  Contents:   Undo unit batching implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "slist.hxx"
#endif

#ifndef _X_SLOAD_HXX_
#define _X_SLOAD_HXX_
#include "sload.hxx"
#endif


#include <initguid.h>
DEFINE_GUID(CLSID_CSelectionUndoUnit,   0x3050f7f8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 
0xaa, 0x00, 0xbd, 0xce, 0x0b);

MtDefine(CBatchParentUndoUnit, Undo, "CBatchParentUndoUnit")
MtDefine(CBatchParentUndoUnitProxy, Undo, "CBatchParentUndoUnitProxy")
MtDefine(CUndoUnitAry_pv, Undo, "CUndoUnitAry::_pv")
MtDefine(CParentUndo, Undo, "CParentUndo");
MtDefine(CSelectionUndoUnit, Undo, "CSelectionUndoUnit")
MtDefine(CDeferredSelectionUndoUnit, Undo, "CDeferredSelectionUndoUnit")

DeclareTag(tagUndoSelEd, "Undo", "Selection ( Mshtmled  ) Undo ");


//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::CParentUndoBase, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CParentUndoBase::CParentUndoBase()
{
   _ulRefs = 1; 
    Assert(_pPUUOpen == NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::~CParentUndoBase, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CParentUndoBase::~CParentUndoBase()
{
    ReleaseInterface(_pPUUOpen);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::QueryInterface, public
//
//  Synopsis:   Implements QueryInterface 
//
//----------------------------------------------------------------------------

HRESULT
CParentUndoBase::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown
        || iid == IID_IOleUndoUnit
        || iid == IID_IOleParentUndoUnit)
    {
        *ppv = (IOleParentUndoUnit *)this;
    }
    
    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Open, public
//
//  Synopsis:   Adds a parent undo unit, and leaves it open. All further
//              calls to the parent undo methods are forwarded to the object
//              until it is closed.
//
//  Arguments:  [pPUU] -- Object to add and leave open.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Open(IOleParentUndoUnit *pPUU)
{
    if (!pPUU)
        RRETURN(E_INVALIDARG);

    if (_pPUUOpen)
        RRETURN(_pPUUOpen->Open(pPUU));

    ReplaceInterface(&_pPUUOpen, pPUU);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    HRESULT hr;
    
    if (!_pPUUOpen)
        return S_FALSE;

    IFR( _pPUUOpen->Close(pPUU, fCommit) );
    if (hr == S_OK)
        return S_OK; 
    
    Assert(hr == S_FALSE);
    
    if (_pPUUOpen != pPUU)
        RRETURN(E_INVALIDARG);
    
    //
    // TODO:  Before we nuke this interface, 
    // we should add it to our undo stack, and
    // then we can return S_OK indicating we
    // have processed this Close. For now, 
    // we return S_FALSE and the rest will be
    // finished by the derived class. 
    // 
    // HACKHACK: Derived class HAS TO override
    // this hacking and return S_OK after adding
    // the unit to undo stack. Even if the child
    // class does not want to do anything, it 
    // still has to override the return value
    // so that we return S_OK.
    //
    // [zhenbinx]
    //

    ClearInterface(&_pPUUOpen);
    
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::FindUnit, public
//
//  Synopsis:   Not implemented
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::FindUnit(IOleUndoUnit *pUU)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetParentState, public
//
//  Synopsis:   Returns state of open parent undo unit.  If there is no parent 
//              undo unit, returns 0.  
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetParentState(DWORD * pdwState)
{
    if (!pdwState)
        RRETURN(E_INVALIDARG);

    *pdwState = 0;

    if (_pPUUOpen)
        return _pPUUOpen->GetParentState(pdwState);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Do, public
//
//  Synopsis:   Not implemented
//
//  Arguments:  [pUndoManager] -- Undo manager
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Do(IOleUndoManager *pUndoManager)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetDescription, public
//
//  Synopsis:   Not implemented
//
//  Arguments:  [pbstr] -- output param
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetDescription(BSTR *pbstr)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetUnitType, public
//
//  Synopsis:   Returns a null undo unit.
//
//  Arguments:  [pclsid] -- Place to put CLSID (caller allocated).
//              [plID]   -- Place to put identifier.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetUnitType(CLSID *pclsid, LONG *plID)
{
    // TODO: should we have a unit type? [ashrafm]
    *pclsid = CLSID_NULL;
    *plID   = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::OnNextAdd, public
//
//  Synopsis:   Called when new undo unit added.  Currently, does nothing.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::OnNextAdd(void)
{
    if (_pPUUOpen)
    {
        IGNORE_HR(_pPUUOpen->OnNextAdd());
    }
    return S_OK; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Add, public
//
//  Synopsis:   Not implemented in CParentUndoBase
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CParentUndoBase::Add(IOleUndoUnit * pUU)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::CBatchParentUndoUnit, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnit::CBatchParentUndoUnit(CHTMLEditor *pEd, UINT uiStringID)
{
    _uiStringID = uiStringID;
    _pEd        = pEd;
    _fTopUnit   = TRUE;   
    _fEmpty     = TRUE;
    
    Assert(_pEd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::CBatchParentUndoUnit, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnit::~CBatchParentUndoUnit(void)
{

    for (int i = 0; i < _aryUndoUnits.Size(); ++i)
        ReleaseInterface(_aryUndoUnits[i]);

}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::FindChild, public
//
//  Synopsis:   Searches the children in a given stack for a undo unit.
//
//  Arguments:  [aryUnit] -- Array to look in
//              [pUU]     -- Unit to look for
//
//  Returns:    The index of the element in [aryUnit] that contains [pUU].
//
//----------------------------------------------------------------------------
int
CBatchParentUndoUnit::FindChild(CUndoUnitAry &aryUnit, IOleUndoUnit *pUU)
{
    IOleParentUndoUnit * pPUU;
    IOleUndoUnit **      ppUA;
    HRESULT              hr     = S_FALSE;
    int                  i;

    for (i = aryUnit.Size(), ppUA = aryUnit;
         i;
         i--, ppUA++)
    {
        if ((*ppUA)->QueryInterface(IID_IOleParentUndoUnit, (LPVOID*)&pPUU) == S_OK)
        {
            hr = pPUU->FindUnit(pUU);

            ReleaseInterface(pPUU);
        }

        if (hr == S_OK)
            break;
    }

    if (i == 0)
        i = -1;
    else
        i = ppUA - (IOleUndoUnit **)aryUnit;

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::FindUnit, public
//
//  Synopsis:   Indicates if the given unit is in our undo stack or the stack
//              of one of our children. Doesn't check the current open object.
//
//  Arguments:  [pUU] -- Unit to find
//
//  Returns:    TRUE if we found it.
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::FindUnit(IOleUndoUnit *pUU)
{
    int i;

    if (!pUU)
        RRETURN(E_INVALIDARG);

    i = _aryUndoUnits.Find(pUU);
    if (i != -1)
        return S_OK;

    i = FindChild(_aryUndoUnits, pUU);
    if (i != -1)
        return S_OK;

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::DoTo, protected
//
//  Synopsis:   Helper method that calls do on an array of objects
//
//  Arguments:  [pUM]         -- Pointer to undo manager to pass to units
//              [paryUnit]    -- Undo or Redo stack
//              [pUU]         -- Object to undo or redo to.
//              [fDoRollback] -- If TRUE, rollback will be attempted on an
//                               error. Noone but the undo manager should
//                               pass TRUE for this.
//
//  Returns:    HRESULT
//
//  Notes:      Parent units can use the _fUnitSucceeded flag to determine
//              whether or not they should commit the unit they put on the
//              opposite stack.  If _fUnitSucceeded is TRUE after calling
//              this function, then the unit should commit itself.  If
//              FALSE, the unit does not have to commit itself.  In either
//              case any error code returned by this function should be
//              propagated to the caller.
//
//----------------------------------------------------------------------------
HRESULT
CBatchParentUndoUnit::DoTo(IOleUndoManager *            pUM,
                     CUndoUnitAry *               paryUnit,
                     IOleUndoUnit *               pUU)
{
    IOleUndoUnit **         ppUA;
    CUndoUnitAry            aryCopy;
    int                     iUnit;
    HRESULT                 hr;

    _fUnitSucceeded = FALSE;

    if (_pPUUOpen)
        RRETURN(E_UNEXPECTED);

    Assert(paryUnit);

    if (paryUnit->Size() == 0)
        return S_OK;

    hr = THR(aryCopy.Copy(*paryUnit, FALSE));
    if (hr)
        RRETURN(hr);

    if (pUU)
    {
        iUnit = aryCopy.Find(pUU);
        if (iUnit == -1)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        iUnit = aryCopy.Size() - 1;
        pUU = aryCopy[iUnit];
    }

    //
    // Delete the units from the original array before we call Do() on those
    // units in case they do something naughty like call DiscardFrom which
    // would Release them.
    //
    paryUnit->DeleteMultiple(iUnit, paryUnit->Size() - 1);

    //
    // Make sure the copy of the array has only the units in it we're
    // processing.
    //
    if (iUnit > 0)
    {
        aryCopy.DeleteMultiple(0, iUnit - 1);
    }

    for(ppUA = &aryCopy.Item(aryCopy.Size() - 1);
        ; // Infinite
        ppUA--)
    {
        hr = THR((*ppUA)->Do(pUM));
        if (hr)
            goto Cleanup;

        _fUnitSucceeded = TRUE;

        if (*ppUA == pUU)
            break;
    }

    Assert(!_pPUUOpen);

Cleanup:
    if (hr == E_ABORT)
    {
        hr = E_FAIL;
    }

    aryCopy.ReleaseAll();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Do, public
//
//  Synopsis:   Calls undo on our contained undo object.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT        hr    = S_OK;

    if (_aryUndoUnits.Size() == 0)
        return S_OK;
        
    hr = THR( _pEd->GetSelectionManager()->DeferSelection(TRUE) );
    Assert(!hr);
    
    //
    // Disable batching
    //
    _fTopUnit = FALSE;   

    //
    // Put ourself on the undo manager's Redo stack.
    //
    if (pUndoManager)
        IFC( pUndoManager->Open(this) );

    //
    // Call Do() on all the units. This call makes a copy of the array and
    // removes the units from _aryUndoUnits before making any calls to Do().
    //

    hr = THR(DoTo(pUndoManager, &_aryUndoUnits, _aryUndoUnits[0]));

    //
    // _fUnitSucceeded will be TRUE after calling DoTo only if at least
    // one of our contained units was successful. In this case we need to
    // commit ourselves, even if an error occurred.
    //

    if (pUndoManager)
    {
        HRESULT hr2;
        BOOL    fCommit = TRUE;

        //
        // If we are empty or none of our contained units succeeded then do
        // not commit ourselves.
        //
        if (!_fUnitSucceeded || (_aryUndoUnits.Size() == 0))
        {
            fCommit = FALSE;
        }

        hr2 = THR(pUndoManager->Close(this, fCommit));
        //
        // Preserve the HRESULT from the call to DoTo() if it failed.
        //
        if (!hr && FAILED(hr2))
        {
            hr = hr2;
        }
    }

Cleanup:
    //
    // If selection fails, let the user undo.  
    //
    IGNORE_HR(_pEd->GetSelectionManager()->DeferSelection(FALSE));
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::GetDescription, public
//
//  Synopsis:   Gets the description for this undo unit.
//
//  Arguments:  [pbstr] -- Place to put description
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::GetDescription(BSTR *pbstr)
{
    TCHAR   *pchUndoTitle;

    if (!pbstr)
        RRETURN(E_INVALIDARG);

    *pbstr = NULL;        

    pchUndoTitle = _pEd->GetCachedString(_uiStringID);
    if (!pchUndoTitle)
        RRETURN(E_FAIL);

    *pbstr = SysAllocString(pchUndoTitle);
    if (*pbstr == NULL)
        RRETURN(E_OUTOFMEMORY);

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::OnNextAdd, public
//
//  Synopsis:   Called when new undo unit is added.  Currently, sets _fTopUnit.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::OnNextAdd(void)
{
    if (_pPUUOpen)
    {
        IGNORE_HR(_pPUUOpen->OnNextAdd());
    }
    else
    {
        _fTopUnit = FALSE;    
    }
    return S_OK; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::GetTopUndoUnit, protected
//
//  Synopsis:   Returns the undo unit at the top of the stack.
//
//----------------------------------------------------------------------------
IOleUndoUnit *
CBatchParentUndoUnit::GetTopUndoUnit()
{
    int c = _aryUndoUnits.Size();

    if (c > 0)
        return _aryUndoUnits[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::AddUnit, protected
//
//  Synopsis:   Adds a new unit to the appropriate stack, no questions asked.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnit::AddUnit(IOleUndoUnit *pUU)
{
    HRESULT             hr;
    CSelectionUndoUnit  *pSelectionUndoUnit;

    if (_aryUndoUnits.Size() > 0)
    {
        IOleUndoUnit *pUUTop = GetTopUndoUnit();

        if (pUUTop)
            pUUTop->OnNextAdd();
    }

    IFC( _aryUndoUnits.Append(pUU) );
    pUU->AddRef();

    //
    // CSelectionUndoUnit is a discardable undo unit
    //

    if (FAILED(pUU->QueryInterface(CLSID_CSelectionUndoUnit, (LPVOID *)&pSelectionUndoUnit)))
    {
        _fEmpty = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Add, public
//
//  Synopsis:   Adds an undo unit to the stack directly. Doesn't leave it
//              open.
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::Add(IOleUndoUnit * pUU)
{
    HRESULT hr;

    if (!pUU)
        RRETURN(E_INVALIDARG);

    if (_pPUUOpen)
        RRETURN(_pPUUOpen->Add(pUU));

    hr = AddUnit(pUU);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    HRESULT               hr;
    SP_IOleParentUndoUnit spPUU = _pPUUOpen;        

    IFR( CParentUndoBase::Close(pPUU, fCommit) );

    //
    // TODO: See comment in CParentUndoUnit::Close
    // 
    // Finish up what the parent class left.
    // We should move this functionality up
    // to the parent class. For now, just 
    // leave it here.
    //
    if (fCommit && spPUU && hr == S_FALSE)
    {
        IFR( AddUnit(spPUU) );
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::IsEmpty, public
//
//  Synopsis:   Is the parent undo unit empty?
//
//  Returns:    TRUE iff parent undo unit is empty
//
//----------------------------------------------------------------------------

BOOL 
CBatchParentUndoUnit::IsEmpty()
{
   return _fEmpty;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::CBatchParentUndoUnitProxy, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnitProxy::CBatchParentUndoUnitProxy(CBatchParentUndoUnit *pBatchPUU)
{
    Assert(pBatchPUU);
    _pBatchPUU = pBatchPUU;
    if (pBatchPUU)
        pBatchPUU->AddRef();
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::~CBatchParentUndoUnitProxy, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnitProxy::~CBatchParentUndoUnitProxy()
{
    ReleaseInterface(_pBatchPUU);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::Add, protected
//
//  Synopsis:   Adds a new unit to the main batch undo unit.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnitProxy::Add(IOleUndoUnit * pUU)
{
    RRETURN(_pBatchPUU->Add(pUU));
}



//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::Close Override Parent
//
//  Synopsis:   Closes an open undo unit. We do not add anything to undo stack
//              since this is a proxy unit. Simply call CParentUndoBase::Close
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//  Note:       There is a hacking inside CParentUndoBase::Close. We need to 
//              override that hacking. 
//      
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnitProxy::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{

    HRESULT               hr;
    SP_IOleParentUndoUnit spPUU = _pPUUOpen;        

    IFR( CParentUndoBase::Close(pPUU, fCommit) );

    //
    // HACKHACK: 
    // when _pPUUOpen and hr == S_FALSE. Our child 
    // unit indeed was closed and we are done. So 
    // we need to return S_OK. However the parent 
    // class returned S_FALSE due to a hacking.So 
    // we need to override this behavior. [zhenbinx]
    //
    // 
    if (spPUU && hr == S_FALSE)
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);

}


//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::IsEmpty, public
//
//  Synopsis:   Is the parent undo unit empty?
//
//  Returns:    TRUE iff parent undo unit is empty
//
//----------------------------------------------------------------------------

BOOL 
CBatchParentUndoUnitProxy::IsEmpty()
{
    // The undo unit proxy is used for getting undo units and inserting
    // it into the active batch undo unit.  Consequently, the proxy
    // parent undo is always empty and we should never commit it to the
    // undo stack.

    return TRUE;
}



CSelectionUndo::CSelectionUndo(CEditorDoc* pEd )
    : CUndoHelper( pEd  )
{
    TraceTag((tagUndoSelEd, "CSelectionUndo::CreateAndSubmit"));

    CreateAndSubmit( );
}

HRESULT 
CSelectionUndo::CreateUnit( IOleUndoUnit** ppUU)
{
    HRESULT                 hr = S_OK;
    CSelectionUndoUnit      *pUU;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eType;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    LONG                    mpStart, mpEnd;
    SP_IHTMLElement         spActiveElement;
    SP_IMarkupContainer     spContainer;
    CHTMLEditor             *pEditor = DYNCAST( CHTMLEditor, _pEd);
    BOOL                    fEmpty = FALSE;
    int                     iSegmentCount = 0;

    pUU = new CSelectionUndoUnit( _pEd );

    if (pUU)    
    {
        IFC( GetSegmentList( & spSegmentList ));
        IFC( spSegmentList->GetType( &eType ));
        IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );

        if( !fEmpty && (eType != SELECTION_TYPE_None) )
        {
            IFC( pEditor->CreateMarkupPointer( & spStart ));
            IFC( pEditor->CreateMarkupPointer( & spEnd ));

            IFC( GetDoc()->get_activeElement( & spActiveElement ));

            IFC( spSegmentList->CreateIterator( &spIter ) );

            if ( iSegmentCount == 1 )
            {            
                IFC( spIter->Current(&spSegment ) );
                IFC( spSegment->GetPointers(spStart, spEnd ));

                IFC( spStart->GetContainer( & spContainer));
                IFC( pEditor->GetMarkupPosition( spStart, & mpStart ));
                IFC( pEditor->GetMarkupPosition( spEnd, & mpEnd ));

                pUU->SetData( spActiveElement, mpStart, mpEnd, spContainer, eType );
            }
            else
            {
                int i = 0;
                
                IFC( pUU->InitSetData( spActiveElement, iSegmentCount, eType ) );

                while( spIter->IsDone() == S_FALSE )
                {
                    IFC( spIter->Current(&spSegment) );
                    IFC( spSegment->GetPointers(spStart, spEnd ));
                
                    IFC( pEditor->GetMarkupPosition( spStart, & mpStart ));
                    IFC( pEditor->GetMarkupPosition( spEnd, & mpEnd ));
                    IFC( spStart->GetContainer( & spContainer));

                    pUU->SetDataSegment( i++, mpStart, mpEnd , spContainer );

                    IFC( spIter->Advance() );
                }               
            }
        }            
        else
        {
            pUU->SetData( NULL , -1, -1, NULL, SELECTION_TYPE_None );
        }
    
        Assert( ppUU );
        
        *ppUU = pUU;
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionUndo::GetSegmentList(ISegmentList** ppSegmentList)
{
    SP_ISelectionServices   spSelServ;
    HRESULT                 hr;

    Assert( ppSegmentList );
    
    IFC( _pEd->GetSelectionServices(&spSelServ) );
    IFC( spSelServ->QueryInterface( IID_ISegmentList, (void**)ppSegmentList) );

Cleanup:    
    RRETURN( hr );    
}

HRESULT
CSelectionUndo::GetSegmentCount(ISegmentList *pISegmentList, int *piCount )
{
    HRESULT                 hr;
    SP_ISegmentListIterator spIter;
    int                     nSize = 0;
    
    Assert( pISegmentList && piCount );

    IFC( pISegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        nSize++;
        IFC( spIter->Advance() );
    }

    *piCount = nSize;

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// CSelectionUndoUnit
//
//---------------------------------------------------------------------------


CSelectionUndoUnit::CSelectionUndoUnit(CEditorDoc* pEditor)
    : CUndoUnitBase( pEditor )
{
    TraceTag((tagUndoSelEd, "CSelectionUndoUnit:: ctor this:%ld", this ));

    _eSelType = SELECTION_TYPE_None;
}

CSelectionUndoUnit::~CSelectionUndoUnit()
{ 
    ReleaseInterface( _pIActiveElement ); 

    if ( _ctSegments == 1 )
    {
        ReleaseInterface( _pIContainer );
    }
    else
    {
        for( int i = 0; i < _ctSegments; i ++ )
        {
            ReleaseInterface( _ppIContainer[i]);
        }
    
        delete [] _pmpStart;
        delete [] _pmpEnd;
        delete [] _ppIContainer;
    }        
}

void    
CSelectionUndoUnit::SetData( 
                            IHTMLElement* pIElement ,  
                            long mpStart, 
                            long mpEnd, 
                            IMarkupContainer* pIContainer ,                            
                            SELECTION_TYPE eSelType )
{ 
    Assert( !_pIActiveElement );
    Assert( !_pIContainer );
    Assert( _pEd );

    ReplaceInterface( & _pIActiveElement, pIElement );
    ReplaceInterface( & _pIContainer, pIContainer );
    
    _mpStart = mpStart;
    _mpEnd = mpEnd;
    _eSelType = eSelType;
    _ctSegments = 1;

    TraceTag((tagUndoSelEd, "CSelectionUndoUnit. Set Data this:%ld type:%d ctSegments:%ld start:%ld end:%ld",
                this, _eSelType, _ctSegments, _mpStart, _mpEnd ));

}

HRESULT 
CSelectionUndoUnit::QueryInterface(REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iid == CLSID_CSelectionUndoUnit)
    {
        *ppv = (LPVOID *)this;
    }
    else
    {
        hr = THR(CUndoUnitBase::QueryInterface(iid, ppv));
    }

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: InitSetData
//
// Synopsis: Set the Invariant part of a CSelectionUndoUnit. Only to be used for Multiple-Selection
//
//------------------------------------------------------------------------------------



HRESULT    
CSelectionUndoUnit::InitSetData( IHTMLElement* pIActiveElement ,
                                 int ctSegments,
                                 SELECTION_TYPE eSelType)
{
    HRESULT hr = S_OK;

    Assert( !_pIActiveElement );
    Assert( ctSegments > 1 );
    
    ReplaceInterface( & _pIActiveElement, pIActiveElement );

    _eSelType = eSelType;
    _ctSegments = ctSegments;

    _pmpStart = new long[_ctSegments];
    if (_pmpStart == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _pmpEnd = new long[_ctSegments];
    if (_pmpEnd == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _ppIContainer = new IMarkupContainer* [_ctSegments];
    if (_ppIContainer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ::ZeroMemory( _ppIContainer, sizeof( IMarkupContainer* ) * _ctSegments );
    
    TraceTag((tagUndoSelEd, "CSelectionUndoUnit. Init SetData this:%ld type:%d ctSegments:%d",
                this, _eSelType, _ctSegments ));


Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: SetDataSegment
//
// Synopsis: Set Selection info for a given segment. Only to be used for multiple selection
//
//------------------------------------------------------------------------------------

void    
CSelectionUndoUnit::SetDataSegment( int iSegmentIndex,
                                    long mpStart, 
                                    long mpEnd,
                                    IMarkupContainer * pIMarkupContainer )
{
    Assert( iSegmentIndex < _ctSegments );
    Assert( _eSelType != SELECTION_TYPE_None );
    Assert( _ctSegments > 1 );
    Assert( ! _ppIContainer[iSegmentIndex]);
    
    _pmpStart[iSegmentIndex] = mpStart;
    _pmpEnd[iSegmentIndex] = mpEnd;

    _ppIContainer[iSegmentIndex] = pIMarkupContainer;
    (_ppIContainer[iSegmentIndex])->AddRef();
}
                            
HRESULT
CSelectionUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IMarkupPointer2 spStart2;
    SP_IMarkupPointer2 spEnd2;

    TraceTag((tagUndoSelEd, "CSelectionUndoUnit::PrivateDo. this:%ld", this ));

    CHTMLEditor     *pEditor = DYNCAST( CHTMLEditor, _pEd );
    CSpringLoader   *psl     = pEditor->GetPrimarySpringLoader();

    if (psl)
        psl->Reset();    
    
    if ( _eSelType != SELECTION_TYPE_None )
    {                                
        Assert( _pIActiveElement );

        IFC( pEditor->MakeCurrent( _pIActiveElement ));

        IFC( pEditor->CreateMarkupPointer( & spStart ));
        IFC( pEditor->CreateMarkupPointer( & spEnd ));

        //
        // Do some work to position some MarkupPointers where we were
        //
        
        if ( _ctSegments == 1 )
        {    
            IFC( pEditor->MoveToMarkupPosition( spStart, _pIContainer, _mpStart ));
            IFC( pEditor->MoveToMarkupPosition( spEnd, _pIContainer, _mpEnd ));
            
            //
            // Select the MarkupPointers
            //
            hr = THR( pEditor->SelectRangeInternal( spStart, spEnd, _eSelType, TRUE ));
            
            TraceTag(( tagUndoSelEd, "Selection restored to this:%ld type:%d start:%ld end:%ld", 
                    this, _eSelType, _mpStart, _mpEnd ));
        }
        else
        {
        
            CSegmentList segmentList;

            IFC( segmentList.SetSelectionType( _eSelType ));
            SP_IHTMLElement     spElement;
            SP_IElementSegment  spSegment;
            
            for ( int i = 0; i < _ctSegments; i ++ )
            {
                IFC( pEditor->MoveToMarkupPosition( spStart, _ppIContainer[i], _pmpStart[i] ));

                IFC( spStart->Right( TRUE, NULL, & spElement, NULL, NULL ));
                
                IFC( segmentList.AddElementSegment( spElement, &spSegment ));

                TraceTag(( tagUndoSelEd, "Multiple Selection restored to this:%ld type:%d start:%ld end:%ld", 
                        this, _eSelType, _pmpStart[i], _pmpEnd[i] ));

            }                

            SP_ISegmentList spSegList;
            IFC( segmentList.QueryInterface( IID_ISegmentList, (void**) & spSegList ));

            IFC( pEditor->Select( spSegList ));            
        }
    }
    else
    {
        //
        // Whack any Selection that we may have 
        // (as we had nothing when the undo unit was created )
        //
        pEditor->DestroyAllSelection();
    }

    //
    //Create a Deferred Selection Undo
    //
    {   
        CDeferredSelectionUndo DeferUndo( _pEd );
    }
    
Cleanup:

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CDeferredSelectionUndo
//
//---------------------------------------------------------------------------


HRESULT
CDeferredSelectionUndo::CreateUnit(IOleUndoUnit** ppUU )
{
    HRESULT hr = S_OK;
    
    CDeferredSelectionUndoUnit * pUU;

    pUU = new CDeferredSelectionUndoUnit( _pEd );
    if ( ! pUU )
    {
        hr = E_OUTOFMEMORY;
    }

    Assert( ppUU );
    *ppUU = pUU ;
    
    return ( hr );
}


CDeferredSelectionUndo::CDeferredSelectionUndo(CEditorDoc* pEd )
    : CUndoHelper( pEd )
{
    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit::CreateAndSubmit"));

    CreateAndSubmit();    
}

//---------------------------------------------------------------------------
//
// CDeferredSelectionUndoUnit
//
//---------------------------------------------------------------------------

CDeferredSelectionUndoUnit::CDeferredSelectionUndoUnit(CEditorDoc* pEd)
    : CUndoUnitBase( pEd )
{
    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit ctor: this:%ld", this ));
}

HRESULT
CDeferredSelectionUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;

    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit::PrivateDo. this:%ld About to create a CSelectionUndo", this ));

    SP_ISelectionServicesListener spListener;
    
    CHTMLEditor             *pEditor = DYNCAST( CHTMLEditor, _pEd);
    
    if ( SUCCEEDED( pEditor->GetISelectionServices()->GetSelectionServicesListener( & spListener )))
    {
        IFC( spListener->BeginSelectionUndo());
    }
    
Cleanup:    
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CUndoManagerHelper::CUndoManagerHelper, public
//
//  Synopsis:   ctor 
//
//----------------------------------------------------------------------------
CUndoManagerHelper::CUndoManagerHelper(CHTMLEditor *pEd)
{
    Assert(pEd);
    
    _pEd = pEd;
    _lOpenParentUndoUnits = 0;
    _pPUU = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::BeginUndoUnit, public
//
//  Synopsis:   Starts a parent undo unit for an editing operation if we don't 
//              already have one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CUndoManagerHelper::BeginUndoUnit(UINT uiStringId, CBatchParentUndoUnit *pBatchPUU /* = NULL */)
{
    HRESULT             hr = S_OK;
    SP_IOleUndoManager  spUndoMgr;
    
    //
    // If we already have a parent undo unit, just increment the nesting count
    //

    if (_lOpenParentUndoUnits)
    {
        Assert(_pPUU);
        _lOpenParentUndoUnits++;
        goto Cleanup;
    }
    Assert(_pPUU == NULL);

    if (pBatchPUU)
    {
        // We create a proxy undo unit to listen in on all modifications
        // to the undo stack.  The proxy will then reinsert undo units
        // into the topmost pBatchPUU

        _pPUU = new CBatchParentUndoUnitProxy(pBatchPUU);
    }
    else
    {
        //
        // Generate a default parent undo unit
        //
        _pPUU = new CBatchParentUndoUnit(_pEd, uiStringId);
    }
    
    if (!_pPUU)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Open the parent undo unit
    //
    IFC( _pEd->GetUndoManager( & spUndoMgr ));
    IFC( spUndoMgr->Open(_pPUU) )
    _lOpenParentUndoUnits++;
    
    //
    // Add the seleciton undo unit
    //
    
    if ( _pEd->GetSelectionServices()->GetUndoListener())
    {
        IGNORE_HR(_pEd->GetSelectionServices()->GetUndoListener()->BeginSelectionUndo());
    }          

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::EndUndoUnit, public
//
//  Synopsis:   Ends the current parent undo unit.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CUndoManagerHelper::EndUndoUnit()
{
    HRESULT hr = S_OK;

    //
    // We need to make sure that we will not get interrupted by pending tasks
    // which may try to modify undo state
    //

    IGNORE_HR( _pEd->GetSelectionManager()->DoPendingTasks() );

    //
    // Sanity check
    //

    Assert(_lOpenParentUndoUnits >= 0);
	
    //
    // If we have not opened a parent undo unit, we have nothing to close
    //
    
    if (_lOpenParentUndoUnits == 0)
        goto Cleanup;

    //
    // Decrement the number of open parent undo units.  Note that we only generate
    // a real parent undo unit for the topmost one on the stack.  The rest
    // are just counted with _lOpenParentUndoUnits.  So, we only close the undo unit
    // when our count goes to 0.
    //

    _lOpenParentUndoUnits--;

    if (_lOpenParentUndoUnits == 0) 
    {
        BOOL fCommit;

        Assert(_pPUU);

        //
        // We don't commit empty undo units
        //
        
        fCommit= !_pPUU->IsEmpty();

        //
        // Generate the end selection undo
        //

        // #111204
        // Proxy always return TRUE for IsEmpty(). This makes
        // EndSelectionUndo being skipped over in batching
        // typing case.
        //
        if ( _pEd->GetSelectionServices()->GetUndoListener() && 
                (fCommit || _pPUU->IsProxy())
             )
        {
            IGNORE_HR(_pEd->GetSelectionServices()->GetUndoListener()->EndSelectionUndo());
        }

        //
        // Close the parent undo unit
        //
        SP_IOleUndoManager spUndoMgr;        
        IGNORE_HR( _pEd->GetUndoManager( & spUndoMgr ));
        IGNORE_HR( spUndoMgr->Close(_pPUU, fCommit /* fCommit */) );
        
        //
        // If we get an undo event that does not go through the batch undo typing proxy, 
        // we need to terminate batch typing.
        //
        
        if (!_pPUU->IsProxy() && !fCommit)
        {
            IGNORE_HR( _pEd->GetSelectionManager()->TerminateTypingBatch() );
        }

        _pPUU->Release();
        _pPUU = NULL;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\formcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_FORMCMD_HXX_
#define X_FORMCMD_HXX_
#include "formcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

//
// Externs
//
MtDefine(CMultipleSelectionCommand, EditCommand, "CMultipleSelectionCommand");
MtDefine(C2DPositionModeCommand, EditCommand, "C2DPositionModeCommand");
MtDefine(C1DElementCommand, EditCommand, "C1DElementCommand");
MtDefine(C2DElementCommand, EditCommand, "C2DElementCommand");
MtDefine(CAbsolutePositionCommand, EditCommand, "CAbsolutePositionCommand");
MtDefine(CLiveResizeCommand, EditCommand, "CLiveResizeCommand");
MtDefine(CDisalbeEditFocusHandlesCommand, EditCommand, "CDisalbeEditFocusHandlesCommand");
MtDefine(CAtomicSelectionCommand, EditCommand, "CAtomicSelectionCommand");


using namespace EdUtil;

////////////////////////////////////////////////////////////////////////////////
// CMultipleSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CMultipleSelectionCommand::PrivateExec( 
                            DWORD        nCmdexecopt,
                            VARIANTARG * pvarargIn,
                            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetMultipleSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetMultipleSelection( ! GetCommandTarget()->IsMultipleSelection());
    }        
    return S_OK;
}

HRESULT 
CMultipleSelectionCommand::PrivateQueryStatus( 
     OLECMD     * pcmd,
     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsMultipleSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
// C2DPositionModeCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C2DPositionModeCommand::PrivateExec( 
                            DWORD        nCmdexecopt,
                            VARIANTARG * pvarargIn,
                            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->Set2DPositionMode( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->Set2DPositionMode( !GetCommandTarget()->Is2DPositioned());
    }        
        
    return S_OK ;
}

HRESULT 
C2DPositionModeCommand::PrivateQueryStatus( OLECMD * pcmd, OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->Is2DPositioned() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// C1DElementCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C1DElementCommand::PrivateExec(DWORD nCmdexecopt, VARIANTARG * pvarargIn,VARIANTARG * pvarargOut )
{    
    if (pvarargOut && SUCCEEDED(VariantChangeType(pvarargOut, pvarargOut, 0, VT_BOOL)))
    {
        HRESULT                 hr = S_OK ;
        SELECTION_TYPE          eSelectionType;
        SP_ISegmentList         spSegmentList;
        SP_IHTMLElement         spElement;
        SP_ISegmentListIterator spIter;
        SP_ISegment             spSegment;       
 
        IFR ( GetSegmentList(&spSegmentList) );
        IFR ( spSegmentList->GetType(&eSelectionType) );

        if( eSelectionType == SELECTION_TYPE_Control)
        {
            BOOL fNet1D = TRUE;

            IFR( spSegmentList->CreateIterator( &spIter ) );
            
            while( spIter->IsDone() == S_FALSE )
            {
                BOOL b2D = FALSE;
            
                IFR( spIter->Current(&spSegment) );
                IFR( GetSegmentElement(spSegment, &spElement) );
                IFC( Is2DElement(spElement , &b2D));
                
                if (b2D)
                    fNet1D = FALSE;

                IFR( spIter->Advance() );                    
            }
            V_VT  (pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fNet1D);
        }    
    }

Cleanup:
    return S_OK ;
}

HRESULT 
C1DElementCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;

    pCmd->cmdf = MSOCMDSTATE_DISABLED ;

    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNet1D = TRUE;

        IFR( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
        
            IFR( spIter->Current(&spSegment) );
            IFR( GetSegmentElement(spSegment, &spElement) );
            IFC( Is2DElement(spElement , &b2D));
            
            if (b2D)
                fNet1D = FALSE;

            IFR( spIter->Advance() );                    
        }

        pCmd->cmdf = (fNet1D ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP );   
    }

Cleanup:
    return (S_OK);
}


///////////////////////////////////////////////////////////////////////////////
// C2DElementCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C2DElementCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut )
{
   if (pvarargOut && SUCCEEDED(VariantChangeType(pvarargOut, pvarargOut, 0, VT_BOOL)))
   {
        HRESULT                 hr = S_OK ;
        SELECTION_TYPE          eSelectionType;
        SP_ISegmentList         spSegmentList;
        SP_ISegmentListIterator spIter;
        SP_ISegment             spSegment;       
        SP_IHTMLElement         spElement;

        IFR ( GetSegmentList(&spSegmentList) );
        IFR ( spSegmentList->GetType(&eSelectionType) );

        if( eSelectionType == SELECTION_TYPE_Control)
        {
            BOOL fNet2D = TRUE;

            IFR( spSegmentList->CreateIterator( &spIter ) );
            
            while( spIter->IsDone() == S_FALSE )
            {
                BOOL b2D = FALSE;
            
                IFR( spIter->Current(&spSegment) );
                IFR( GetSegmentElement(spSegment, &spElement) );
                IFC( Is2DElement(spElement , &b2D));
                
                if (!b2D)
                    fNet2D = FALSE;

                IFR( spIter->Advance() );                    
            }
            V_VT  (pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fNet2D);
        }    
   }

Cleanup:
   return S_OK ;
}

HRESULT 
C2DElementCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;

    pCmd->cmdf = MSOCMDSTATE_DISABLED ;

    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNet2D = TRUE;

        IFR( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
       
            IFR( spIter->Current(&spSegment) );
            IFR( GetSegmentElement(spSegment, &spElement) );
            IFC( Is2DElement(spElement , &b2D));
            
            if (!b2D)
                fNet2D = FALSE;

            IFR( spIter->Advance() );                    
        }

        pCmd->cmdf = (fNet2D ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP );   
    }

Cleanup:
    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////////
// CAbsolutePositionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CAbsolutePositionCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;
    CEdUndoHelper           undoPositioning(GetEditor());
    
    
    IFC (GetSegmentList(&spSegmentList));
    IFC ( spSegmentList->GetType(&eSelectionType)) ;

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        IFC( spSegmentList->CreateIterator( &spIter ) );
    
        IFC( undoPositioning.Begin(IDS_EDUNDOPROPCHANGE) );
            
        while( spIter->IsDone() == S_FALSE )
        {        
            IFC( spIter->Current(&spSegment) );
            IFC (GetSegmentElement(spSegment, &spElement));
            
            if ( pvarargIn && pvarargIn->vt == VT_BOOL )
            {
                IFC (MakeAbsolutePosition(spElement, ENSURE_BOOL(pvarargIn->bVal)));
            }
            else
            {
               BOOL b2D = FALSE;       
               IFC (Is2DElement(spElement , &b2D));
               IFC (MakeAbsolutePosition(spElement , !b2D));
            }

            IFC( spIter->Advance() );
        }
        IFC( GetEditor()->GetSelectionManager()->OnLayoutChange());
    }

Cleanup:
    return (S_OK);
}

HRESULT 
CAbsolutePositionCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;
    
    pCmd->cmdf = MSOCMDSTATE_DISABLED ;
    
    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType( &eSelectionType ) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNetAbsPos = TRUE;

        IFC( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
        
            IFC( spIter->Current(&spSegment) );
            IFR (GetSegmentElement(spSegment, &spElement) );
            IFC (Is2DElement(spElement , &b2D));
            if (!b2D)
                fNetAbsPos = FALSE;

            IFC( spIter->Advance() );
        }
        pCmd->cmdf = (fNetAbsPos ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP) ;  
    }
            
Cleanup:
    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////////
// CLiveResizeCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CLiveResizeCommand::PrivateExec( 
        DWORD        nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetLiveResize( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetLiveResize( ! GetCommandTarget()->IsLiveResize());
    }        
        
    return S_OK;
}

HRESULT 
CLiveResizeCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsLiveResize() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CDisalbeEditFocusHandlesCommand
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CDisalbeEditFocusHandlesCommand::PrivateExec( 
            DWORD        nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetDisableEditFocusHandles( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetDisableEditFocusHandles( ! GetCommandTarget()->IsDisableEditFocusHandles());        
    }                

    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;

    IGNORE_HR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &myHwnd ));

    ::RedrawWindow( myHwnd ,NULL,NULL,RDW_UPDATENOW);
    
    return S_OK ;
}

HRESULT 
CDisalbeEditFocusHandlesCommand::PrivateQueryStatus( OLECMD * pcmd, OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsDisableEditFocusHandles() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CAtomicSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CAtomicSelectionCommand::PrivateExec( 
    DWORD        nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetAtomicSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetAtomicSelection( ! GetCommandTarget()->IsAtomicSelection());
    }
    
    return S_OK ;
}

HRESULT 
CAtomicSelectionCommand::PrivateQueryStatus( 
     OLECMD     * pcmd,
     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsAtomicSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\edutil.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDUTIL.CXX
//
//  Contents:   Utility functions for CMsHtmled
//
//  History:    15-Jan-98   raminh  Created
//
//  Notes:      This file contains some utility functions from Trident,
//              such as LoadLibrary, which have been modified to eliminate
//              dependencies. In addition, it provides the implementation
//              for editing commands such as InsertObject etc.
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_EDEVENT_HXX_
#define X_EDEVENT_HXX_
#include "edevent.hxx"
#endif 

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

DYNLIB      g_dynlibSHDOCVW = { NULL, NULL, "SHDOCVW.DLL" }; // This line is required for linking with wrappers.lib

LCID        g_lcidUserDefault = 0;                           // Required for linking with formsary.obj

#if DBG == 1 && !defined(WIN16)
//
// Global vars for use by the DYNCAST macro
//
char g_achDynCastMsg[200];
char *g_pszDynMsg = "Invalid Static Cast -- Attempt to cast object "
                    "of type %s to type %s.";
char *g_pszDynMsg2 = "Dynamic Cast Attempted ---  "
                     "Attempt to cast between two base classes of %s. "
                     "The cast was to class %s from some other base class "
                     "pointer. This cast will not succeed in a retail build.";
#endif

static DYNLIB * s_pdynlibHead; // List used by LoadProcedure and DeiIntDynamic libraries

//
// Forward references
//
int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);

HRESULT GetLastWin32Error();

void DeinitDynamicLibraries();

HRESULT DoInsertObjectUI (HWND hwnd, DWORD * pdwResult, LPTSTR * pstrResult);

HRESULT CreateHtmlFromIDM (UINT cmd, LPTSTR pstrParam, LPTSTR pstrHtml);

//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
//
//  Function:   edNlstrlenW
//
//  Synopsis:   This function takes a string and count the characters (WCHAR)
//              contained in that string until either NULL termination is
//              encountered or cchLimit is reached.
//
//  Returns:    Number of characters in pstrIn
//
//-------------------------------------------------------------------------
LONG
edNlstrlenW(LPWSTR pstrIn, LONG cchLimit )
{
    Assert(pstrIn);
    Assert(cchLimit >= 0);
    
    LONG cchCount = 0;
    while (*pstrIn && cchLimit)
    {
        cchCount ++;
        cchLimit --;
        ++pstrIn;
    }
    
    return cchCount;
}


//+------------------------------------------------------------------------
//
//  Function:   edWsprintf
//
//  Synopsis:   This function is a replacement for a simple version of sprintf.
//              Since using Format() links in a lot of extra code and since
//              wsprintf does not work under Win95, this simple alternative
//              is being used.
//
//  Returns:    Number of characters written to pstrOut
//
//-------------------------------------------------------------------------

int
edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam)
{
    TCHAR   *  pstrPercentS;
    ULONG      cLength;

    if (!pstrFormat)
        goto Cleanup;

    pstrPercentS = _tcsstr( pstrFormat, _T( "%s" ) );
    if (!pstrPercentS)
    {
        _tcscpy( pstrOut, pstrFormat );
    }
    else
    {
        if (!pstrParam)
            goto Cleanup;

        cLength = PTR_DIFF( pstrPercentS, pstrFormat );
        _tcsncpy( pstrOut, pstrFormat, cLength );
        pstrOut[ cLength ] = _T( '\0' );
        ++pstrPercentS; ++pstrPercentS; // Increment pstrPercentS passed "%s"
        _tcscat( pstrOut, pstrParam );
        _tcscat( pstrOut, pstrPercentS );
    }
    return _tcslen(pstrOut);
Cleanup:
    return 0;
}
//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error from misc.cxx
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
#ifdef WIN16
    return E_FAIL;
#else
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   LoadProcedure
//
//  Synopsis:   Load library and get address of procedure.
//
//              Declare DYNLIB and DYNPROC globals describing the procedure.
//              Note that several DYNPROC structures can point to a single
//              DYNLIB structure.
//
//                  DYNLIB g_dynlibOLEDLG = { NULL, "OLEDLG.DLL" };
//                  DYNPROC g_dynprocOleUIInsertObjectA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };
//                  DYNPROC g_dynprocOleUIPasteSpecialA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIPasteSpecialA" };
//
//              Call LoadProcedure to load the library and get the procedure
//              address.  LoadProcedure returns immediatly if the procedure
//              has already been loaded.
//
//                  hr = LoadProcedure(&g_dynprocOLEUIInsertObjectA);
//                  if (hr)
//                      goto Error;
//
//                  uiResult = (*(UINT (__stdcall *)(LPOLEUIINSERTOBJECTA))
//                      g_dynprocOLEUIInsertObjectA.pfn)(&ouiio);
//
//              Release the library at shutdown.
//
//                  void DllProcessDetach()
//                  {
//                      DeinitDynamicLibraries();
//                  }
//
//  Arguments:  pdynproc  Descrition of library and procedure to load.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
LoadProcedure(DYNPROC *pdynproc)
{
    HINSTANCE   hinst;
    DYNLIB *    pdynlib = pdynproc->pdynlib;
    DWORD       dwError;

    if (pdynproc->pfn && pdynlib->hinst)
        return S_OK;

    if (!pdynlib->hinst)
    {
        // Try to load the library using the normal mechanism.

        hinst = LoadLibraryA(pdynlib->achName);

#ifdef WINCE
        if (!hinst)
        {
            goto Error;
        }
#endif // WINCE
#ifdef WIN16
        if ( (UINT) hinst < 32 )
        {
            // jumping to error won't work,
            // since GetLastError is currently always 0.
            //goto Error;
            // instead, return a bogus (but non-zero) error code.
            // (What should we return? I got 0x7e on one test.)
            // --mblain27feb97
            RRETURN(hinst ? (DWORD) hinst : (DWORD) ~0);
        }
#endif // WIN16
#if !defined(WIN16) && !defined(WINCE)
        // If that failed because the module was not be found,
        // then try to find the module in the directory we were
        // loaded from.

        dwError = GetLastError();
        if (!hinst)
        {
            goto Error;
        }
#endif // !defined(WIN16) && !defined(WINCE)

        // Link into list for DeinitDynamicLibraries

        {
            if (pdynlib->hinst)
                FreeLibrary(hinst);
            else
            {
                pdynlib->hinst = hinst;
                pdynlib->pdynlibNext = s_pdynlibHead;
                s_pdynlibHead = pdynlib;
            }
        }
    }

    pdynproc->pfn = GetProcAddress(pdynlib->hinst, pdynproc->achName);
    if (!pdynproc->pfn)
    {
        goto Error;
    }

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}



//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibraries
//
//  Synopsis:   Undoes the work of LoadProcedure.
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibraries()
{
    DYNLIB * pdynlib;

    for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
    }
    s_pdynlibHead = NULL;
}

//
// EnumElements() and EnumVARIANT() are methods of CImplAry class that are
// implemented in cenum.cxx. MshtmlEd does not currently use these methods
// hence the stubs below are provided to avoid linking code unnecessarily.
// If these methods are ever used, MshtmlEd shall link with cenum.cxx.
//
//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//----------------------------------------------------------------------------
HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumVARIANT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}


//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}

Direction 
Reverse( Direction iDir )
{
    if( iDir == LEFT )
        return RIGHT;
    else if (iDir == RIGHT)
        return LEFT;
    else
        return iDir;
}


//+===================================================================================
// Method:      MoveWord
//
// Synopsis:    Moves the pointer to the previous or next word. This method takes into
//              account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//+===================================================================================

HRESULT 
CHTMLEditor::MoveWord(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir)
{
    HRESULT hr = S_OK;
    
    if( eDir == LEFT )
        hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVWORDBEGIN ));
    else
        hr = THR( MoveUnit( pDispPointer,eDir, MOVEUNIT_NEXTWORDBEGIN ));

    RRETURN( hr );
}


//+===================================================================================
// Method:      MoveCharacter
//
// Synopsis:    Moves the pointer to the previous or next character. This method takes
//              into account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//+===================================================================================

HRESULT 
CHTMLEditor::MoveCharacter(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir)
{
    HRESULT hr = S_OK;
    BOOL fNearText = FALSE;
    CEditPointer tLooker(this);
    DWORD dwBreak = BREAK_CONDITION_OMIT_PHRASE-BREAK_CONDITION_Anchor;
    DWORD dwFound = BREAK_CONDITION_None;
    IFC( pDispPointer->PositionMarkupPointer(tLooker) );
    IFC( tLooker.Scan( eDir, dwBreak, &dwFound ));

    fNearText =  CheckFlag( dwFound, BREAK_CONDITION_Text );
    
    if( eDir == LEFT )
    {
        if( fNearText )
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVCLUSTERBEGIN ));
        }
        else
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVCLUSTEREND ));
        }
    }
    else
    {
        if( fNearText )
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_NEXTCLUSTEREND ));
        }
        else
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_NEXTCLUSTERBEGIN ));
        }
    }
Cleanup:
    RRETURN( hr );
}


//+===================================================================================
// Method:      MoveUnit
//
// Synopsis:    Moves the pointer to the previous or next character. This method takes
//              into account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//
//
//
//+===================================================================================

HRESULT 
CHTMLEditor::MoveUnit(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir,
    MOVEUNIT_ACTION         eUnit )
{
    HRESULT hr = S_OK;
    BOOL fBeyondThisLine;
    BOOL fAtEdgeOfLine;
    BOOL fThereIsAnotherLine = FALSE;
    BOOL fBeyondNextLine = FALSE;
    BOOL fLineBreakDueToTextWrapping = FALSE;
    BOOL fHackedLineBreak = FALSE;
    DWORD dwBreak = BREAK_CONDITION_Site | BREAK_CONDITION_NoScopeSite | BREAK_CONDITION_Control;
    DWORD dwFound = BREAK_CONDITION_None;
    SP_IHTMLElement spSite;
    CEditPointer epDestination(this);
    CEditPointer epBoundary(this);
    CEditPointer epNextLine(this);
    CEditPointer epWalker(this);
    SP_IDisplayPointer spDispPointer;

    IFC( pDispPointer->PositionMarkupPointer(epDestination) );
    IFC( pDispPointer->PositionMarkupPointer(epNextLine) );
    IFC( pDispPointer->PositionMarkupPointer(epWalker) );
    IFC( pDispPointer->PositionMarkupPointer(epBoundary) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    IFC( epDestination->MoveUnit( eUnit ));

    if( eDir == LEFT )
    {
        DWORD dwIgnore = BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor | BREAK_CONDITION_NoLayoutSpan;
        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        IFC( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
        IFC( spDispPointer->PositionMarkupPointer(epBoundary) );

        fLineBreakDueToTextWrapping = TRUE;

        hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_PreviousLine, -1) );
        if (SUCCEEDED(hr))
        {
            hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
            if (SUCCEEDED(hr))
            {
                fThereIsAnotherLine = TRUE;
                IFC( spDispPointer->PositionMarkupPointer(epNextLine) );
                IFC( AdjustOut(epNextLine, RIGHT) );
                {
                    // 
                    // HACKHACK: To fix bug #98353, we need to make sure epNextLine 
                    // does not go beyond this line. AdjustOut is very buggy but 
                    // we don't want to make a big modification as of now. So we do
                    // a little hacking here.   [zhenbinx]
                    //
                    SP_IDisplayPointer  spDispAdjusted;
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                    if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epNextLine, spDispPointer))
                    {
                        CEditPointer  epScan(this);
                        DWORD         dwScanFound;

                        epScan->MoveToPointer(epNextLine);
                        epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epNextLine->MoveToPointer(epScan);
                    }
                }
                IFC( epDestination->IsLeftOf( epNextLine, &fBeyondNextLine ));
            }
        }

        //
        // HACKHACK: When glyph is turned on, we use the non-adjusted line start instead
        // of adjusted line start for epBoundary. So we need to handle it specially.
        //
        if (!_fIgnoreGlyphs)
        {
            DWORD           dwLBSearch = BREAK_CONDITION_Content;
            DWORD           dwLBFound;
            CEditPointer    epLBScan(this);
            IFC( epLBScan->MoveToPointer(epBoundary) );
            IFC( epLBScan.Scan(LEFT, dwLBSearch, &dwLBFound) );
            if (               
                (CheckFlag(dwLBFound, BREAK_CONDITION_EnterBlock) && CheckFlag(dwLBFound, BREAK_CONDITION_EnterSite))
               )
            {
                //
                // HACKHACK: 
                // since we use non-adjusted line start. We need 
                // to hack this to FALSE. 
                // 
                fLineBreakDueToTextWrapping = FALSE;
                fHackedLineBreak = TRUE;
            }
        }

        if (!fHackedLineBreak)
        {
            // If the current line start and previous line end are the same point 
            // in the markup, we are breaking the line due to wrapping
            IFC( epNextLine->IsEqualTo( epBoundary, &fLineBreakDueToTextWrapping ));
        }
        IFC( epDestination->IsLeftOf( epBoundary, &fBeyondThisLine ));
        IFC( epWalker.IsLeftOfOrEqualTo( epBoundary, dwIgnore, &fAtEdgeOfLine ));
        if (!_fIgnoreGlyphs)
        {
            //
            // IEV6-6553-2000/08/08/-zhenbinx 
            // some positions are not valid even if glyph is turned on. 
            // This is because the caret is considered to be "valid
            // for input". To maintain this assumption, Some glyphs
            // should be ingored since inserting text into such position
            // would have resulted in incorrect HTML.
            // We should have a better glyph story in the future.
            //
            SP_IHTMLElement spIElem;
            ELEMENT_TAG_ID  eTag;

            IFC( CurrentScopeOrMaster(epWalker, &spIElem) );
            IFC( GetMarkupServices()->GetElementTagId(spIElem, & eTag) );
            if (EdUtil::IsListItem(eTag))  // add more invalid positions here...
            {
                //
                // In theory, this could have skipped over too much 
                // however LI is not surround by any element in normal cases
                //
                DWORD dwAdjustedIgnore = dwIgnore|BREAK_CONDITION_Glyph|BREAK_CONDITION_Block;
                IFC( epWalker.IsLeftOfOrEqualTo(epBoundary, dwAdjustedIgnore, &fAtEdgeOfLine) );
            }
        }
    }
    else
    {
        DWORD dwIgnore = BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor | BREAK_CONDITION_NoScope | BREAK_CONDITION_NoLayoutSpan;
        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        IFC( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
        IFC( spDispPointer->PositionMarkupPointer(epBoundary) );

        fLineBreakDueToTextWrapping = TRUE;

        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_NextLine, -1) );
        if (SUCCEEDED(hr))
        {
            hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
            if (SUCCEEDED(hr))
            {
                fThereIsAnotherLine = TRUE;
                IFC( spDispPointer->PositionMarkupPointer(epNextLine) );
                IFC( AdjustOut(epNextLine, LEFT) );
                {
                    // 
                    // HACKHACK: To fix bug #108383, we need to make sure epNextLine 
                    // does not go beyond this line. AdjustOut is very buggy but 
                    // we don't want to make a big modification as of now. So we do
                    // a little hacking here.   [zhenbinx]
                    //
                    SP_IDisplayPointer  spDispAdjusted;
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                    if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epNextLine, spDispPointer))
                    {
                        CEditPointer  epScan(this);
                        DWORD         dwScanFound;

                        epScan->MoveToPointer(epNextLine);
                        epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epNextLine->MoveToPointer(epScan);
                    }
                }
                IFC( epDestination->IsRightOf( epNextLine, &fBeyondNextLine ));
            }
        }

        //
        // HACKHACK: When glyph is turned on, we use the non-adjusted line end instead
        // of adjusted line end for epBoundary. So we need to handle it specially.
        //
        if (!_fIgnoreGlyphs)
        {
            DWORD           dwLBSearch = BREAK_CONDITION_Content;
            DWORD           dwLBFound;
            CEditPointer    epLBScan(this);
            IFC( epLBScan->MoveToPointer(epBoundary) );
            IFC( epLBScan.Scan(RIGHT, dwLBSearch, &dwLBFound) );
            if (                
                (CheckFlag(dwLBFound, BREAK_CONDITION_EnterBlock) && CheckFlag(dwLBFound, BREAK_CONDITION_EnterSite))
               )
            {   
                //
                // HACKHACK: 
                // We have a block and a glyph right before it
                // since we use non-adjusted line end. We need 
                // to hack this to FALSE. 
                // 
                fLineBreakDueToTextWrapping = FALSE;
                fHackedLineBreak = TRUE;
            }
        }

        if (!fHackedLineBreak)
        {
            // If the current line END and next line START are the same point 
            // in the markup, we are breaking the line due to wrapping
            IFC( epNextLine->IsEqualTo( epBoundary, &fLineBreakDueToTextWrapping )); 
        }
        IFC( epDestination->IsRightOf( epBoundary, &fBeyondThisLine ));
        IFC( epWalker.IsRightOfOrEqualTo( epBoundary, dwIgnore, &fAtEdgeOfLine ));
    }

    //
    // If I'm not at the edge of the line, my destination is the edge of the line.
    //
    
    if( ! fAtEdgeOfLine && fBeyondThisLine )
    {
        IFC( epDestination->MoveToPointer( epBoundary ));
    }

    //
    // If I am at the edge of the line and there is another line, and my destination
    // is beyond that line - my destination is that line.
    //

    if( fAtEdgeOfLine && fBeyondThisLine && fBeyondNextLine && ! fLineBreakDueToTextWrapping )
    {
        // we are at the edge of the line and our destination is beyond the next line boundary
        // so move our destination to that line boundary.
        IFC( epDestination->MoveToPointer( epNextLine ));
    }

    //
    // Scan towards my destination. If I hit a site boundary, move to the other
    // side of it and be done. Otherwise, move to the next line.
    //
    
    IFC( epWalker.SetBoundaryForDirection( eDir, epDestination ));
    hr = THR( epWalker.Scan( eDir, dwBreak, &dwFound, &spSite ));

    if( CheckFlag( dwFound, BREAK_CONDITION_NoScopeSite ) ||
        CheckFlag( dwFound, BREAK_CONDITION_EnterControl ))
    {
        IFC( epWalker->MoveAdjacentToElement( spSite , eDir == LEFT ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
        goto CalcBOL;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_ExitControl ))
    {
        // do not move at all
        goto Cleanup;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_Site ))
    {
        ELEMENT_TAG_ID tagId;

        IFC( GetMarkupServices()->GetElementTagId(spSite, &tagId) );
        if (tagId == TAGID_BODY)
            goto Cleanup; // don't exit the body

        IFC( EnterTables(epWalker, eDir) );
        // move wherever scan put us...
        if( eDir == LEFT )
        {
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );            
        }
        else
        {
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );            
        }

        goto Done;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_Boundary ))
    {
        // No site transitions between here and our destination.

        if( fBeyondThisLine && fAtEdgeOfLine && ! fLineBreakDueToTextWrapping )
        {

            // If our destination pointer is on another line than our start pointer...
            IFC( spDispPointer->MoveToPointer(pDispPointer) );
            if( eDir == LEFT )
            {
                hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_PreviousLine, -1) );
                if (SUCCEEDED(hr))
                {
                    hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
                    if (SUCCEEDED(hr))
                    {
                        IFC( spDispPointer->PositionMarkupPointer(epWalker) );
                        IFC( AdjustOut(epWalker, RIGHT) );
                        {
                            // 
                            // HACKHACK: To fix bug #98353, we need to make sure epNextLine 
                            // does not go beyond this line. AdjustOut is very buggy but 
                            // we don't want to make a big modification as of now. So we do
                            // a little hacking here.   [zhenbinx]
                            //
                            SP_IDisplayPointer  spDispAdjusted;
                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                            if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epWalker, spDispPointer) )
                            {
                                CEditPointer  epScan(this);
                                DWORD         dwScanFound;

                                epScan->MoveToPointer(epWalker);
                                epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epWalker->MoveToPointer(epScan);
                            }
                        }
                        IFC( EnterTables(epWalker, LEFT) );
                        IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );
                        {
                            //
                            // HACKHACK:
                            //
                            // We might just moved into an empty line!!! 
                            // Consider the case of "\r\rA" where we are moving 
                            // from between '\r' and 'A' to between two '\r's, 
                            //
                            // In this case CurrentLineEnd will be before the 2nd 
                            // 'r' !!! (this is our current design)!!!!!!!!!!
                            //
                            // We are moving into an ambigious position at an 
                            // empty line. Do not set display gravity to PreviousLine 
                            // in this case! Note in this case fLineBreakDueToTextWrapping 
                            // is set to FALSE
                            //
                            // [zhenbinx]                            
                            //
                            CEditPointer    epScan(this);
                            DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
                            DWORD dwScanFound  = BREAK_CONDITION_None;
                            WCHAR wch;
            
                            IFC( pDispPointer->PositionMarkupPointer(epScan) );
                            IFC( epScan.Scan(RIGHT, dwSearch, &dwScanFound, NULL, NULL, &wch) );

                            if (CheckFlag(dwScanFound, BREAK_CONDITION_NoScopeBlock) && wch == L'\r')
                            {
                                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                            }
                            else
                            {
                                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                            }
                        }
                    }
                }
            }
            else
            {
                hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_NextLine, -1) );
                if (SUCCEEDED(hr))
                {
                    hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
                    if (SUCCEEDED(hr))
                    {
                        IFC( spDispPointer->PositionMarkupPointer(epWalker) );
                        IFC( AdjustOut(epWalker, LEFT) );
                        {
                            // 
                            // HACKHACK: To fix bug #108383, we need to make sure epNextLine 
                            // does not go beyond this line. AdjustOut is very buggy but 
                            // we don't want to make a big modification as of now. So we do
                            // a little hacking here.   [zhenbinx]
                            //
                            SP_IDisplayPointer  spDispAdjusted;
                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                            if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epWalker, spDispPointer) )
                            {
                                CEditPointer  epScan(this);
                                DWORD         dwScanFound;

                                epScan->MoveToPointer(epWalker);
                                epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epWalker->MoveToPointer(epScan);
                            }
                        }
                        IFC( EnterTables(epWalker, RIGHT) );
                        IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );
                        IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                   }
                }
            }
            goto Cleanup;
        }
        else
        {
            // We started and ended on same line with no little stops along the way - move to destination...
            
            IFC( epWalker->MoveToPointer( epDestination ));
        }
    }
    else
    {
        // we hit some sort of error, go to cleanup
        hr = E_FAIL;
        goto Cleanup;
    }

CalcBOL:

    //
    // Fix up fNotAtBOL - if the cp we are at is between lines, we should
    // always be at the beginning of the line. One exception - if we are to the 
    // left of a layout, we should render on the previous line. If we are to the
    // right of a layout, we should render on the next line.
    //

    {
        CEditPointer tPointer( this );
        BOOL fAtNextLineFuzzy = FALSE;
        DWORD dwScanBreak = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor;
        DWORD dwScanFound = BREAK_CONDITION_None;
        IFC( tPointer.MoveToPointer( epWalker ));
        IFC( tPointer.Scan( RIGHT, dwScanBreak, &dwScanFound ));

        if( fThereIsAnotherLine )
            IFC( tPointer.IsEqualTo( epNextLine, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor, & fAtNextLineFuzzy ));

        if( ! CheckFlag( dwScanFound, BREAK_CONDITION_Site ) &&
            ! fAtNextLineFuzzy )
        {
            // No site to the right of me and I'm not right next to the next line, 
            // render at the bol.
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        }
        else
        {
            // there was a site to my right - render at the end of the line
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
    }

Done:
    IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );

Cleanup:
    
    RRETURN( hr );

}


//
// General markup services helpers
//

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::CSegmentListIter
//  Synopsis:   ctor
//-----------------------------------------------------------------------------

CSegmentListIter::CSegmentListIter()
{
    _pLeft = _pRight = NULL;
    _pSegmentList    = NULL;
    _pIter = NULL;
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::CSegmentListIter
//  Synopsis:   dtor
//-----------------------------------------------------------------------------

CSegmentListIter::~CSegmentListIter()
{
    ReleaseInterface(_pLeft);
    ReleaseInterface(_pRight);
    ReleaseInterface(_pSegmentList);
    ReleaseInterface(_pIter);
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::Init
//  Synopsis:   init method
//-----------------------------------------------------------------------------
HRESULT CSegmentListIter::Init(CEditorDoc *pEditorDoc, ISegmentList *pSegmentList)
{
    HRESULT hr;

    //
    // Set up pointers
    //
    ReleaseInterface(_pLeft);
    ReleaseInterface(_pRight);
    ReleaseInterface(_pSegmentList);
    ReleaseInterface(_pIter);
    
    IFC( pSegmentList->CreateIterator(&_pIter) );
    
    hr = THR(CreateMarkupPointer2(pEditorDoc, &_pLeft));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(CreateMarkupPointer2(pEditorDoc, &_pRight));
    if (FAILED(hr))
        goto Cleanup;

    // Cache segment list
    _pSegmentList = pSegmentList;
    _pSegmentList->AddRef();

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::Next
//  Synopsis:   Move pointers to next segment.
//              Returns S_FALSE if last segment
//-----------------------------------------------------------------------------

HRESULT CSegmentListIter::Next(IMarkupPointer **ppLeft, IMarkupPointer **ppRight)
{
    SP_ISegment spSegment;
    HRESULT     hr;

    //
    // Advance to next segment
    //
    if( _pIter->IsDone() == S_FALSE )
    {
        IFC( _pIter->Current(&spSegment) );

        IFC( spSegment->GetPointers( _pLeft, _pRight ) );
        *ppLeft = _pLeft;
        *ppRight = _pRight;

        IFC( _pIter->Advance() );
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Add
//  Synopsis:   Add an element to the break container
//-----------------------------------------------------------------------------
VOID CBreakContainer::Set(ELEMENT_TAG_ID tagId, Mask mask)
{
    if (mask & BreakOnStart)
        bitFieldStart.Set(tagId);
    else
        bitFieldStart.Clear(tagId);

    if (mask & BreakOnEnd)
        bitFieldEnd.Set(tagId);
    else
        bitFieldEnd.Clear(tagId);
}

//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Test
//  Synopsis:   Tests an element in the break container
//-----------------------------------------------------------------------------
VOID CBreakContainer::Clear(ELEMENT_TAG_ID tagId, Mask mask)
{
    if (mask & BreakOnStart)
        bitFieldStart.Clear(tagId);

    if (mask & BreakOnEnd)
        bitFieldEnd.Clear(tagId);
}

//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Clear
//  Synopsis:   Clears an element in the break container
//-----------------------------------------------------------------------------
BOOL CBreakContainer::Test(ELEMENT_TAG_ID tagId, Mask mask)
{
    BOOL bResult = FALSE;

    switch (mask)
    {
    case BreakOnStart:
        bResult = bitFieldStart.Test(tagId);
        break;

    case BreakOnEnd:
        bResult = bitFieldEnd.Test(tagId);
        break;

    case BreakOnBoth:
        bResult = bitFieldStart.Test(tagId) && bitFieldEnd.Test(tagId) ;
        break;
    }

    return bResult;
}

#if DBG==1
void
AssertPositioned(IMarkupPointer *pPointer)
{
    HRESULT hr;
    BOOL    fIsPositioned;

    hr = pPointer->IsPositioned(&fIsPositioned);
    Assert(hr == S_OK);
    Assert(fIsPositioned);
}
#endif


HRESULT 
MshtmledUtil::GetEditResourceLibrary(
    HINSTANCE   *hResourceLibrary)
{    
    if (!g_hEditLibInstance)
    {
        g_hEditLibInstance = MLLoadLibrary(_T("mshtmler.dll"), g_hInstance, ML_CROSSCODEPAGE);
    }
    *hResourceLibrary = g_hEditLibInstance;

    if (!g_hEditLibInstance)
        return E_FAIL; // TODO: can we convert GetLastError() to an HRESULT?

    return S_OK;
}

//+---------------------------------------------------------------------------+
//
//           
// Currently only deal with writing-mode: tb-rl
//
//  styleWritingMode
//      styleWritingModeLrtb
//      styleWritingModeTbrl
//      styleWritingModeNotSet
//
//
//+---------------------------------------------------------------------------+
HRESULT
MshtmledUtil::IsElementInVerticalLayout(IHTMLElement *pElement,
                                         BOOL *fRet
                                         )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement2        spElem2;
    SP_IHTMLCurrentStyle    spStyle;
    SP_IHTMLCurrentStyle2   spStyle2;
    BSTR                    bstrWritingMode=NULL;

    Assert( pElement );
    Assert( fRet );
    
    IFC( pElement->QueryInterface(IID_IHTMLElement2, reinterpret_cast<LPVOID *>(&spElem2)) );
    IFC( spElem2->get_currentStyle(&spStyle) );

    if (!spStyle) 
        goto Cleanup;

    IFC( spStyle->QueryInterface(IID_IHTMLCurrentStyle2, reinterpret_cast<LPVOID *>(&spStyle2)) );
    IFC( spStyle2->get_writingMode(&bstrWritingMode) );
    //
    // TODO: Should not hard-code strings however cannot find a way around!
    //
    *fRet = bstrWritingMode && !_tcscmp(bstrWritingMode, _T("tb-rl"));


Cleanup:
    ::SysFreeString(bstrWritingMode);
    RRETURN(hr);
}


//
// Synoposis:   This function moves the markuppointer according to editing rules. 
//              It manipulates the markup pointer according to the visual box tree
//
//
HRESULT 
MshtmledUtil::MoveMarkupPointerToBlockLimit(
            CHTMLEditor        *pEditor,
            Direction          direction,       // LEFT -- START of BLOCK   RIGHT -- END of BLOCK
            IMarkupPointer     *pMarkupPointer,
            ELEMENT_ADJACENCY  elemAdj
            )
{
    Assert( pEditor );
    Assert( pMarkupPointer );

    
    HRESULT             hr = S_OK;
    CBlockPointer       bpStBlock(pEditor);
    CBlockPointer       bpEndBlock(pEditor);
    CBlockPointer       bpWkBlock(pEditor);
    BOOL                fEmpty;

    IFC( bpStBlock.MoveTo(pMarkupPointer, direction) );
    IFC( bpStBlock.IsEmpty(&fEmpty) );
    if (!fEmpty) 
    {
        IFC( bpStBlock.MoveToFirstNodeInBlock() );              
    }

    if (LEFT == direction)
    {
        IFC( bpStBlock.MovePointerTo(pMarkupPointer, elemAdj) );
        goto Cleanup;
    }

    // 
    // Fall through -- RIGHT == direction
    //
    IFC( bpWkBlock.MoveTo(&bpStBlock) );
    if (!fEmpty)
    {
        IFC( bpWkBlock.MoveToLastNodeInBlock() );
    }

    IFC( bpEndBlock.MoveTo(&bpWkBlock) );

	if (ELEM_ADJ_AfterEnd == elemAdj)
	{
	    if (S_FALSE == bpEndBlock.MoveToSibling(RIGHT))
	    {
	        if (bpEndBlock.IsLeafNode())
	        {
	            IFC( bpEndBlock.MoveToParent() );
	        }
	    }
	    IFC( bpEndBlock.MovePointerTo(pMarkupPointer, ELEM_ADJ_AfterEnd) );
    }
    else
    {
    	Assert( ELEM_ADJ_BeforeEnd == elemAdj );
        IFC( bpEndBlock.MovePointerTo(pMarkupPointer, ELEM_ADJ_BeforeEnd) );
    }

Cleanup:
    RRETURN(hr);
}


//
// CEdUndoHelper helper
//

CEdUndoHelper::CEdUndoHelper(CHTMLEditor *pEd) 
{
    _pEd= pEd; 
    _fOpen = FALSE;
}

CEdUndoHelper::~CEdUndoHelper() 
{
    if (_fOpen)
        IGNORE_HR(_pEd->GetUndoManagerHelper()->EndUndoUnit());
}

HRESULT 
CEdUndoHelper::Begin(UINT uiStringId, CBatchParentUndoUnit *pBatchPUU)
{
    HRESULT hr;

    Assert(!_fOpen);

    hr = THR(_pEd->GetUndoManagerHelper()->BeginUndoUnit(uiStringId, pBatchPUU));

    _fOpen = SUCCEEDED(hr);

    RRETURN(hr);
}

//
// CStringCache
//

CStringCache::CStringCache(UINT uiStart, UINT uiEnd)
{
    _uiStart = uiStart;
    _uiEnd = uiEnd;
    _pCache = new CacheEntry[_uiEnd - _uiStart + 1];
    
    if (_pCache)
    {
        for (UINT i = 0; i < (_uiEnd - _uiStart + 1); i++)
        {
            _pCache[i].pchString = NULL;
        }
    }
}

CStringCache::~CStringCache()
{
    for (UINT i = 0; i < (_uiEnd - _uiStart + 1); i++)
    {
        delete [] _pCache[i].pchString;
    }
    delete [] _pCache;
}

TCHAR *
CStringCache::GetString(UINT uiStringId)
{
    HRESULT     hr;
    CacheEntry  *pEntry;
    HINSTANCE   hinstEditResDLL;
    INT         iResult;
    const int   iBufferSize = 1024;
    
    Assert(_pCache);
    if (!_pCache || uiStringId < _uiStart || uiStringId > _uiEnd)
        return NULL; // error

    pEntry = &_pCache[uiStringId - _uiStart];    
    
    if (pEntry->pchString == NULL)
    {
        TCHAR pchBuffer[iBufferSize];
        
        IFC( MshtmledUtil::GetEditResourceLibrary(&hinstEditResDLL) );
        pchBuffer[iBufferSize-1] = 0;  // so we are always 0 terminated
        iResult = LoadString( hinstEditResDLL, uiStringId, pchBuffer, ARRAY_SIZE(pchBuffer)-1 );
        if (!iResult)
            goto Cleanup;

        pEntry->pchString = new TCHAR[_tcslen(pchBuffer)+1];
        if (pEntry->pchString)
            StrCpy(pEntry->pchString, pchBuffer);         
    }

    return pEntry->pchString;

Cleanup:
    return NULL;
}


        
#if DBG==1
//
// Debugging aid - this little hack lets us look at the CElement from inside the debugger.
//

#include <initguid.h>
DEFINE_GUID(CLSID_CElement,   0x3050f233, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEBUG_HELPER CElement *_(IHTMLElement *pIElement)
{
    CElement *pElement = NULL;

    pIElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement);
    
    return pElement;
}

//
// Helpers to dump the tree
//

DEBUG_HELPER VOID
dt(IUnknown* pUnknown)
{
    IOleCommandTarget *pCmdTarget = NULL;
    IMarkupPointer    *pMarkupPointer = NULL;

    if (SUCCEEDED(pUnknown->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
    {
        IGNORE_HR(pCmdTarget->Exec( &CGID_MSHTML, IDM_DEBUG_DUMPTREE, 0, NULL, NULL));
        ReleaseInterface(pCmdTarget);
    }
    else if (SUCCEEDED(pUnknown->QueryInterface(IID_IMarkupPointer, (LPVOID *)&pMarkupPointer)))
    {
        IMarkupContainer *pContainer = NULL;
        
        if (SUCCEEDED(pMarkupPointer->GetContainer(&pContainer)))
        {
            dt(pContainer);
            ReleaseInterface(pContainer);
        }
        ReleaseInterface(pMarkupPointer);
    }

}

DEBUG_HELPER VOID
dt(SP_IMarkupPointer &spPointer)
{
    dt(spPointer.p);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\imedesgn.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Imedesgn.CXX
//
// Contents:    Implementation of CIMEManager class
//
// Purpose:     The CIMEManager class implements the IHTMLEditDesigner interface.
//              It is designed to handle all of the IME functionality for the
//              editor.
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_IMEDESGN_H_
#define X_IMEDESGN_H_
#include "imedesgn.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

using namespace EdUtil;

ExternTag(tagEdIME);

//-----------------------------------------------------------------------------
//
//  Function:   CIMEManager::CIMEManager
//
//  Synopsis:   Creates the IME manager
//
//-----------------------------------------------------------------------------
CIMEManager::CIMEManager(void)
{
    _cRef = 1;
}

HRESULT
CIMEManager::PreHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_FALSE;
}

HRESULT
CIMEManager::PostHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT hr;

    CHTMLEditEvent evt( GetEditor());
    IFC( evt.Init( pIObj , inDispId ));
    hr = THR( HandleEvent( &evt ));

Cleanup:
    return( hr );

}

HRESULT
CIMEManager::PostEditorEventNotify( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_OK;
}

HRESULT
CIMEManager::TranslateAccelerator( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_FALSE;
}
//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::HandleMessage
//
//  Synopsis:   This method is responsible for handling any messages from the
//              editor which are interesting to the CIMEManager.
//
//  Arguments:  pMessage = SelectionMessage indicating incoming message
//
//  Returns:    HRESULT indicating whether the message was handled or not
//
//--------------------------------------------------------------------------
#ifndef IMR_DOCUMENTFEED
#define IMR_DOCUMENTFEED    0x0007
#endif
HRESULT
CIMEManager::HandleEvent( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG_PTR wParam;
    Assert( pEvent != NULL );


    switch (pEvent->GetType())
    {
        case EVT_IME_REQUEST:
            IGNORE_HR( DYNCAST(CHTMLEditEvent, pEvent)->GetIMERequest(&wParam) );
            if( ( wParam == IMR_RECONVERTSTRING) ||
                ( wParam == IMR_CONFIRMRECONVERTSTRING)
                /* ||( wParam == IMR_DOCUMENTFEED )*/
              )
            {
                Assert( wParam != IMR_DOCUMENTFEED );
                hr = HandleIMEReconversion(pEvent);
            }
            break;

        case EVT_IME_RECONVERSION:          // application initiated IME reconversion
            hr = HandleIMEReconversion(pEvent);
            break;

       default:
            hr = S_FALSE;
    }

    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::Init
//
//  Synopsis:   Initializes the designer.
//
//  Arguments:  pEd = Pointer to main editor class
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CIMEManager::Init(
    CHTMLEditor *pEd)
{
    HRESULT hr = E_INVALIDARG;

    Assert( pEd );

    if( pEd )
    {
        hr = S_OK;
        _pEd = pEd;
    }

    RRETURN( hr );
}


//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::HandleIMEReconversion
//
//  Synopsis:   Actually does the hard work of handling the IME reconversion
//              Retrieves any selected text, and fills out the RECONVERTSTRING
//              structure required by the IME.
//
//  Arguments:  pMessage = Selection message which generated WM_IMEREQUEST
//
//  Returns:    HRESULT.
//--------------------------------------------------------------------------
/*
@Devnote:
    There different level of reconversion support. The RECONVERSIONSTRING
    structure can store the entire stentence point to the string that will
    be reconverted by dwStartOffset and dwLen. If dwStratOffset is at the
    beginning of the buffer (after the structure) and dwLen is the length
    of the string, the entire string is reconverted by the IME.

    Simple Reconversion:
    The simplest reconversion is when the target string and the composition
    string are the same as the entire string. In this case, dwCompStrOffset
    and dwTargetStrOffset are zero, and dwStrLen, dwCompStrLen, and
    dwTargetStrLen are the same value. An IME will provide the composition
    string of the entire string that is supplied in the structure, and will
    set the target clause by its conversion result.

    Normal Reconversion:
    For an efficient conversion result, the application should provide the
    RECONVERSIONSTRING structure with the information string. In this case,
    the composition string is not the entire string, but is identical to
    the target string. An IME can convert the composition string by
    referencing the entire string and then setting the target clause by its
    conversion result.

    Enhanced Reconversion:
    Applications can set a target string that is different from the
    composition string. The target string (or part of the target string) is
    then included in a target clause in high priority by the IME. The target
    string in the RECONVERSIONSTRING structure must be part of the composition
    string. When the application does not want to change the user's focus
    during the reconversion, the target string should be specified. The IME
    can then reference it.

    (zhenbinx)
*/
HRESULT
CIMEManager::HandleIMEReconversion(
                CEditEvent * pEvent
                )
{
    HRESULT         hr = S_OK;
    long            cch = 0;
    UINT            uiKeyboardCodePage = 0;
    TCHAR           ach[MAX_RECONVERSION_SIZE];
    BOOL            fIsUnicode;
    HIMC            hIMC = NULL;
    LONG_PTR        wParam;
    LONG_PTR        lParam;
    HWND            myHwnd;

    long            cbReconvert;
    long            cbStringSize;
    RECONVERTSTRING *lpRCS = NULL;
    LPSTR           lpReconvertBuf;

    //
    // IME reconversion is disabled by default.
    //
    //
    if (!GetEditor()->IsIMEReconversionEnabled() || !GetEditor()->IsContextEditable())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (GetEditor()->GetSelectionManager()->IsIMEComposition())
    {
        hr = S_FALSE;
        goto Cleanup;
    }


    IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetIMERequest(&wParam));
    IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetIMERequestData(&lParam));

    //
    // Check for UNICODE/Ansi flags
    //
    IFC( GetEditor()->GetHwnd(&myHwnd ));
    if (NULL == myHwnd)
        goto Cleanup;
    fIsUnicode = IsWindowUnicode( myHwnd );

    //
    // Look for lParam as possible RECONVERTSTRING
    //
    if (EVT_IME_REQUEST == pEvent->GetType())
    {
        TraceTag((tagEdIME, "EVT_IME_REQUEST"));
        lpRCS   = (RECONVERTSTRING *)(lParam);
        if (IMR_CONFIRMRECONVERTSTRING == wParam)
        {
            //
            // IME is asking for confirmation. Return TRUE/FALSE to IME
            //
            VARIANT v;
            BOOL    fRet;

            TraceTag((tagEdIME, "EVT_IME_REQUEST with IMR_CONFIRMRECONVERTSTRING"));

            Assert (lpRCS);
            WHEN_DBG( DumpReconvertString(lpRCS) );
            fRet = CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, fIsUnicode);
            WHEN_DBG( DumpReconvertString(lpRCS) );

            VariantInit(&v);
            V_VT(&v)   = VT_BOOL;
            V_BOOL(&v) = fRet ? VARIANT_TRUE : VARIANT_FALSE;
            IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetEventObject()->put_returnValue(v) );
            VariantClear(&v);
            goto Cleanup;
        }
    }

    //
    // Check to see if there was a selection
    //
    if (!SUCCEEDED(THR( RetrieveSelectedText(MAX_RECONVERSION_SIZE, &cch, ach))))
        goto Cleanup;

    if (cch)
    {
        //
        // Get the length of our string
        //
        if (fIsUnicode)
        {
            cbStringSize = cch * sizeof(WCHAR);
        }
        else
        {
            uiKeyboardCodePage = GetKeyboardCodePage();
            cbStringSize       = WideCharToMultiByte( uiKeyboardCodePage, 0, ach, cch, NULL, 0, NULL, NULL);
        }
        cbReconvert = cbStringSize + sizeof(RECONVERTSTRING) + 2;
    }
    else
    {
        cbStringSize = 0;
        cbReconvert  = 0;
    }

    //
    // Application initiated reconversion. Allocate the reconversion buffer
    //
    if (EVT_IME_RECONVERSION == pEvent->GetType())
    {
        lpRCS       = reinterpret_cast<RECONVERTSTRING *>(new BYTE[cbReconvert]);
        if (!lpRCS)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memset(lpRCS, 0, cbReconvert);
    }

    if (EVT_IME_REQUEST == pEvent->GetType() 
        && wParam == IMR_RECONVERTSTRING)
    {
        // IEV6 bug 29552 - SetCandidateWindowPosition 
        hIMC = ImmGetContext(myHwnd);
        if (hIMC)
        {
            CANDIDATEFORM   cdCandForm;
            POINT ptCaret;
            RECT rc;
            long lLineHeight;

            if (SUCCEEDED(GetCompositionPos(&ptCaret, &rc, &lLineHeight)) )
            {
                memset(&cdCandForm, 0, sizeof(CANDIDATEFORM));

                cdCandForm.dwIndex = 0;
                cdCandForm.dwStyle  = CFS_CANDIDATEPOS;
                if (GetEditor()->GetSelectionManager()->KeyboardCodePage() == 932 /*JAPAN_CP*/)
                {
                    cdCandForm.dwStyle  = CFS_EXCLUDE;

                    cdCandForm.rcArea.left  =  ptCaret.x;
                    cdCandForm.rcArea.right =  cdCandForm.rcArea.left + 2;
                    cdCandForm.rcArea.top  =  ptCaret.y - lLineHeight;
                    ptCaret.y += 4;
                    cdCandForm.rcArea.bottom = ptCaret.y;
                }
                cdCandForm.ptCurrentPos = ptCaret;
                
                TraceTag((tagEdIME, "IME_REQUEST::IMR_RECONVERTSTRING ImmSetCandidateWindow [%d]-[%d] excl [%d]-[%d][%d]-[%d]",
                    cdCandForm.ptCurrentPos.x, cdCandForm.ptCurrentPos.y,
                    cdCandForm.rcArea.left, cdCandForm.rcArea.top,
                    cdCandForm.rcArea.right, cdCandForm.rcArea.bottom));
                Verify( ImmSetCandidateWindow(hIMC, &cdCandForm) );
            }
            ImmReleaseContext(myHwnd, hIMC);
        }
    }

    if (lpRCS)
    {
        //
        // Populate the RECONVERTSTRING structure
        // We're doing a simple reconversion
        //
        lpRCS->dwSize           = cbReconvert;
        lpRCS->dwStrOffset      = sizeof(RECONVERTSTRING);
        lpRCS->dwStrLen         = fIsUnicode ? cch : cbStringSize;    // TCHAR or byte counts depending on fUnicode

        lpRCS->dwCompStrOffset  = 0;        // byte counts
        lpRCS->dwCompStrLen     = lpRCS->dwStrLen;

        lpRCS->dwTargetStrOffset= lpRCS->dwCompStrOffset;
        lpRCS->dwTargetStrLen   = lpRCS->dwCompStrLen;

        WHEN_DBG( DumpReconvertString(lpRCS) );
        //
        // Setup the composition string
        //
        lpReconvertBuf = reinterpret_cast<LPSTR>(lpRCS) + sizeof(RECONVERTSTRING);
        if (cbStringSize)
        {
            if (fIsUnicode)
            {
                memcpy(lpReconvertBuf, ach, cch * sizeof(WCHAR));
            }
            else
            {
                WideCharToMultiByte(uiKeyboardCodePage, 0, ach, cch, lpReconvertBuf, cbStringSize, NULL, NULL);
            }
        }
        *(lpReconvertBuf + cbStringSize)     = '\0';
        *(lpReconvertBuf + cbStringSize + 1) = '\0';


        if (EVT_IME_RECONVERSION == pEvent->GetType())
        {
            //
            // Call ImmSetCompositionString to begin the reconversion
            //
            hIMC = ImmGetContext(myHwnd);
            if (hIMC)
            {
                DWORD   imeProperties = ImmGetProperty(GetKeyboardLayout(0), IGP_SETCOMPSTR);
                if ((imeProperties&(SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
                    ==   (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD)
                     )
                {
                    if (fIsUnicode)
                    {
                        if (ImmSetCompositionStringW( hIMC, SCS_QUERYRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0 ))
                        {
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                            //
                            // Need to Adjust Selection Accordingly
                            //
                            CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, TRUE);
                            ImmSetCompositionStringW( hIMC, SCS_SETRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0);
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                        }
                    }
                    else
                    {
                        if (ImmSetCompositionStringA( hIMC, SCS_QUERYRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0 ))
                        {
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                            //
                            // Need to Adjust Selection Accordingly
                            //
                            CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, FALSE);
                            ImmSetCompositionStringA( hIMC, SCS_SETRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0);
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                        }
                    }
                    ImmReleaseContext(myHwnd, hIMC);
                } // imeProperties
            } // hIMC
            if (lpRCS)
            {
                delete [] (reinterpret_cast<BYTE *>(lpRCS));
            }
       } // EVT_IME_RECONVERSION == pEvent->GetType()
       else
       {
            goto ReturnSize;
       }
    } // lpRCS ! = NULL
    else
    {
        Assert( EVT_IME_REQUEST == pEvent->GetType() );
        Assert( IMR_RECONVERTSTRING == wParam );
        Assert( NULL == lpRCS );
        TraceTag((tagEdIME, "EVT_IME_REQUEST with IMR_RECONVERTSTRING and NULL lParam"));

ReturnSize:
        // return the size for IME to allocate the buffer
        VARIANT v;
        VariantInit(&v);
        V_VT(&v) = VT_I4;
        V_I4(&v) = cbReconvert;
        IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetEventObject()->put_returnValue(v) );
        VariantClear(&v);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::RetrieveSelectedText
//
//  Synopsis:   Retrieves the text which has been selected in the editor for
//              reconversion
//
//  Arguments:  cchMax = IN - indicates number of chars to grab
//              pcch = OUT - number of characters grabbed
//              pch = OUT - buffer containing chars
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CIMEManager::RetrieveSelectedText(
    LONG cchMax,
    LONG * pcch,
    TCHAR * pch )
{
    HRESULT                 hr = S_OK;
    DWORD                   dwSearch = BREAK_CONDITION_Text | BREAK_CONDITION_Block;
    DWORD                   dwFound = BREAK_CONDITION_None;
    const TCHAR             *pchStart = pch;
    const TCHAR             *pchEnd = pch + cchMax;
    SP_IMarkupPointer       spStart, spEnd;
    SELECTION_TYPE          eType;
    CEditPointer            epPointer( _pEd );
    SP_ISegmentList         spSegmentList;
    SP_ISegment             spSegment;
    SP_ISegmentListIterator spIter;
    BOOL                    fEmpty = FALSE;
    BOOL                    fLeftOfEnd;

    Assert( cchMax > 0 );
    Assert( pcch && pch );

    IFC( GetEditor()->GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );
    IFC( spSegmentList->GetType( &eType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    // Make sure we have a valid selection
    if( (fEmpty == FALSE) && (eType == SELECTION_TYPE_Text ) )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spStart) );
        IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

        IFC( spSegmentList->CreateIterator(&spIter ) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spStart, spEnd) );

        // PointersInSameFlowLayout found in Edutil namespace.  It would be
        // nice to get this as a separate utility package.
        if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            IFC( epPointer->MoveToPointer( spStart ) );
            IFC( epPointer.SetBoundary( _pEd->GetSelectionManager()->GetStartEditContext() ,
                                        _pEd->GetSelectionManager()->GetEndEditContext() ));
            IFC( epPointer.Constrain() );

            //
            // Scoot begin pointer to the beginning of the non-white text
            //

            IFC( epPointer.Scan( RIGHT, dwSearch, &dwFound, NULL, NULL, NULL,
                                    SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP ) );

            if ( !epPointer.CheckFlag(dwFound, BREAK_CONDITION_Text) )
                goto Cleanup;

            dwFound = BREAK_CONDITION_None;
            IFC( epPointer.Scan( LEFT, dwSearch, &dwFound ) );

            IFC( spStart->MoveToPointer( epPointer ) );

            //
            // Scoop up the text
            //
            fLeftOfEnd = FALSE;
            while (pch < pchEnd)
            {

                dwFound = BREAK_CONDITION_None;

                IFC( epPointer.Scan( RIGHT, dwSearch, &dwFound, NULL, NULL, pch ) );

                if( epPointer.CheckFlag(dwFound, BREAK_CONDITION_Block) )
                {
                    IFC( epPointer.Scan( LEFT, BREAK_CONDITION_Block, &dwFound, NULL, NULL, NULL) );
                    break;
                }
                else if( !epPointer.CheckFlag( dwFound, BREAK_CONDITION_Text) )
                {
                    break;
                }

                // NOTE (cthrash) WCH_NBSP is not native to any Far East codepage.
                // Here we simply convert to space, thus prevent the IME from getting confused.

                if (*pch == WCH_NBSP)
                {
                    *pch = L' ';
                }

                pch++;

                IFC( epPointer->IsLeftOf( spEnd, &fLeftOfEnd ));

                if (!fLeftOfEnd)
                    break;
            }


            //
            // If current selection has more text than maximum reconversion
            // we don't even want to do reconversion (or maybe we should
            // emit an error message like word does
            //
            if (pch >= pchEnd)      // we reached maximum allowed selection
            {
                if (fLeftOfEnd)     // there are more in the selection
                {
                        pch = const_cast<TCHAR *>(pchStart);
                    goto Cleanup;
                }
            }

            // Re-highlight the text
            IFC( spEnd->MoveToPointer(epPointer) );
            IFC( GetEditor()->SelectRange(spStart, spEnd, SELECTION_TYPE_Text ) );
            {
                SP_IHTMLCaret spCaret;
                SP_IDisplayPointer spDispPos;
                SP_IDisplayPointer spDispCtx;
                
                // now position caret to the end of this range
                IFC( GetEditor()->GetDisplayServices()->GetCaret( & spCaret ));
                IFC( GetEditor()->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
                IFC( GetEditor()->GetDisplayServices()->CreateDisplayPointer(&spDispCtx) );
                IFC( spCaret->MoveDisplayPointerToCaret(spDispCtx) );
                IFC( spDispPos->MoveToMarkupPointer(spEnd, spDispCtx) );
                IFC( spCaret->MoveCaretToPointer( spDispPos, TRUE, CARET_DIRECTION_SAME) );
            }
        }
    }

Cleanup:
    *pcch = pch - pchStart;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::CheckIMEChange
//
//  Synopsis:   Verify if IME wants to re-adjust the selection
//
//  Arguments:
//
//  Returns:
//              TRUE
//                  -- allow IME to change the selection
//              FALSE
//                  -- don't change the selection, use the original
//                     composition string
//
//--------------------------------------------------------------------------
BOOL
CIMEManager::CheckIMEChange(
                RECONVERTSTRING *lpRCS,
                IMarkupPointer  *pContextStart,
                IMarkupPointer  *pContextEnd,
                IMarkupPointer  *pCompositionStart,
                IMarkupPointer  *pCompositionEnd,
                BOOL            fUnicode
                )
{
   lpRCS;
   pContextStart;
   pContextEnd;
   pCompositionStart;
   pCompositionEnd;
   fUnicode;

   return FALSE;    // do not allow selection change
}


//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CIMEManager::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CIMEManager::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CIMEManager::QueryInterface(
    REFIID  iid,
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown || iid == IID_IHTMLEditDesigner)
    {
        *ppvObj = (IHTMLEditDesigner *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  funtion:    CIMEManager::GetCompositionPos( POINT * ppt, RECT * prc )
//
//  synopsis:   Determine the position for composition windows, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CIMEManager::GetCompositionPos(
    POINT * ppt,
    RECT * prc,
    long * plLineHeight )
{
    HWND hwnd;
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IHTMLCaret spCaret;
    SP_IOleWindow spOleWindow;
    SP_IDisplayPointer spDispPos;
    SP_IMarkupPointer spInsertionPoint;
    SP_ILineInfo spLineInfo;
    LONG lTextDescent;

    Assert(_pEd);
    IFC( _pEd->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
    Assert(ppt && prc && plLineHeight);

    //
    // We get the line dimensions at the position of the caret. I realize we could
    // get some of the data from the caret, but we have to call through this way
    // anyway to get the descent and line height.
    //
    IFC( _pEd->GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( spDispPos ));
    IFC( spDispPos->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_x(&ppt->x) );
    IFC( spLineInfo->get_baseLine(&ppt->y) );
    IFC( spLineInfo->get_textDescent(&lTextDescent) );
    ppt->y += lTextDescent;
    IFC( spLineInfo->get_textHeight(plLineHeight) );

    // Transform it to global coord.
    IFC( spDispPos->GetFlowElement( &spElement ));
    if ( ! spElement )
    {
        IFC( GetEditor()->GetSelectionManager()->GetEditableElement( & spElement ));
    }
    IFC( GetEditor()->GetDisplayServices()->TransformPoint( ppt, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spElement ));

    // tranlsate the unit
    GetEditor()->DeviceFromDocPixels(ppt);

    IFC( GetEditor()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
    IFC(spOleWindow->GetWindow(&hwnd));
    ::GetClientRect(hwnd, prc);

Cleanup:
    RRETURN(hr);    
}



//////////////////////////////////////////////////////////////////////////
//
//  Debugger helper
//
//////////////////////////////////////////////////////////////////////////
WHEN_DBG(void CIMEManager::DumpReconvertString(RECONVERTSTRING *pRev)                       )
WHEN_DBG({                                                                                  )
WHEN_DBG(        TraceTag((tagEdIME, "dwSize             = %d", pRev->dwSize) );            )
WHEN_DBG(        TraceTag((tagEdIME, "dwVersion          = %d", pRev->dwVersion) );         )
WHEN_DBG(        TraceTag((tagEdIME, "dwStrLen           = %d", pRev->dwStrLen) );          )
WHEN_DBG(        TraceTag((tagEdIME, "dwStrOffset        = %d", pRev->dwStrOffset) );       )
WHEN_DBG(        TraceTag((tagEdIME, "dwCompStrOffset    = %d", pRev->dwCompStrOffset) );   )
WHEN_DBG(        TraceTag((tagEdIME, "dwCompStrLen       = %d", pRev->dwCompStrLen) );      )
WHEN_DBG(        TraceTag((tagEdIME, "dwTargetStrLen     = %d", pRev->dwTargetStrLen) );    )
WHEN_DBG(        TraceTag((tagEdIME, "dwTargetStrOffset  = %d", pRev->dwTargetStrOffset) ); )
WHEN_DBG(}                                                                                  )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\ime.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module ime.cpp -- support for Win95 IME API |
 *
 *      Most everything to do with FE composition string editing passes
 *      through here.
 *
 *  Authors: <nl>
 *      Jon Matousek <nl>
 *      Hon Wah Chan <nl>
 *      Justin Voskuhl <nl>
 *
 *  History: <nl>
 *      10/18/1995      jonmat  Cleaned up level 2 code and converted it into
 *                              a class hierarchy supporting level 3.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_IME /*{*/

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "OptsHold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMANK_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_EDUNDO_HXX_
#define _X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X__IME_HXX_
#define X__IME_HXX_
#include "ime.hxx"
#endif


#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

DeclareTag(tagEdIME, "Edit", "IME execution")
DeclareTag(tagEdIMEAttr, "Edit", "IME Attributes in CompositionString")
MtDefine(CIme, Dialogs, "CIme")
MtDefine( CIme_arySegments_pv, Utilities, "CIME Attribute Segments" )    


#if DBG == 1
static const LPCTSTR strImeIP = _T( "    ** IME IP");
static const LPCTSTR strImeUncommittedStart = _T( "    ** IME Uncommitted Start");
static const LPCTSTR strImeUncommittedEnd = _T( "    ** IME Uncommitted End");
#endif


// default caret width
#define DXCARET 1

BOOL forceLevel2 = FALSE;

#if DBG==1
static const LPCTSTR strImeHighlightStart = _T( "    ** IME Highlight Start");
static const LPCTSTR strImeHighlightEnd = _T( "    ** IME Highlight End");
#endif

#define _TODO(x)

//
// LPARAM helpers
//

inline BOOL HaveCompositionString(LONG lparam) { return ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR))); }
inline BOOL CleanupCompositionString(LONG lparam) { return ( 0 == lparam ); }
inline BOOL HaveResultString(LONG lparam) { return (0 != (lparam & GCS_RESULTSTR)); }

//+--------------------------------------------------------------------------
//
//  method:     IsIMEComposition
//
//  returns:    BOOLEAN - Return TRUE if we have a IME object on the textsite.
//              If argument is FALSE, only return TRUE if the IME object is
//              not of class CIme_Protected.
//
//---------------------------------------------------------------------------

BOOL
CSelectionManager::IsIMEComposition( BOOL fProtectedOK /* = TRUE */ )
{
    return (_pIme != NULL && (fProtectedOK || !_pIme->IsProtected()));
};

//+--------------------------------------------------------------------------
//
//  method:     UpdateIMEPosition
//
//  purpose:    This method should be called to update the IME insertion
//              pointer as well as notifying the main IME window that the 
//              position of our caret has changed.
//
//  returns:    HRESULT - FAILED(hr) if there was a failure attempting to 
//              move the IME position
//
//---------------------------------------------------------------------------
HRESULT CSelectionManager::UpdateIMEPosition( void )
{
    HRESULT hr = S_OK;
    
    Assert( _pIme != NULL );

    if( !_pIme->_fInsertInProgress )
    {
        hr = _pIme->UpdateInsertionPoint();

        if( SUCCEEDED(hr) )
        {
            _pIme->SetCompositionForm();
        }
    }

    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  method:     ImmGetContext
//
//  returns:    Get the IMM context associated with the document window
//
//---------------------------------------------------------------------------

HIMC
CSelectionManager::ImmGetContext(void)
{
    HWND hwnd = NULL;
    HRESULT hr;
    SP_IOleWindow spOleWindow;
    hr = THR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (!hr)
        hr = THR(spOleWindow->GetWindow(&hwnd));

    Assert( hwnd );
    return OK(hr) ? ::ImmGetContext( hwnd ) : NULL;
}

//+--------------------------------------------------------------------------
//
//  method:     ImmReleaseContext
//
//  returns:    Release the IMM context associated with the document window
//
//---------------------------------------------------------------------------

void
CSelectionManager::ImmReleaseContext( HIMC himc )
{
    HWND hwnd = NULL;
    HRESULT hr;
    SP_IOleWindow spOleWindow;
    hr = THR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (!hr)
        hr = THR(spOleWindow->GetWindow(&hwnd));

    Assert( hwnd );
    if (OK(hr))
    {
        ::ImmReleaseContext( hwnd, himc );
    }
}


//+--------------------------------------------------------------------------
//
//  method:     SetCaretVisible
//
//---------------------------------------------------------------------------

HRESULT
CIme::SetCaretVisible( BOOL fVisible )
{
    HRESULT hr;

    TraceTag((tagEdIME, "CIme::SetCaretVisible: fVisible [%d]", fVisible) );

    if (_fCaretVisible != fVisible)
    {
        hr = THR(SetCaretVisible( _pManager->GetDoc(), _fCaretVisible = fVisible ));
    }
    else
    {
        hr = S_OK;
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  HRESULT StartCompositionGlue( BOOL fIsProtected, TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Initiates an IME composition string edit.
//  @comm
//      Called from the message loop to handle EVT_IME_STARTCOMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//
//  @devnote
//      We decide if we are going to do a level 2 or level 3 IME
//      composition string edit. Currently, the only reason to
//      create a level 2 IME is if the IME has a special UI, or it is
//      a "near caret" IME, such as the ones found in PRC and Taiwan.
//      Near caret simply means that a very small window opens up
//      near the caret, but not on or at the caret.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::StartCompositionGlue(
    BOOL fIsProtected,
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    CSelectTracker * pSelectTracker = NULL;
    CCaretTracker *pCaretTracker = NULL;

    // note that in some locales (PRC), we may still be in composition mode
    // when a new start composition call comes in.  Just reset our state
    // and go on.

    _codepageKeyboard = GetKeyboardCodePage();
    _fIgnoreImeCharMsg = FALSE;

    if ( !IsIMEComposition() )
    {
        if( _pActiveTracker )
        {
            switch (_pActiveTracker->GetTrackerType())
            {
                case TRACKER_TYPE_Selection:
                    pSelectTracker = DYNCAST( CSelectTracker, _pActiveTracker );

                    if (!pSelectTracker->EndPointsInSameFlowLayout())
                    {
                        fIsProtected = TRUE;
                    }

                    break;

                case TRACKER_TYPE_Control:
                    fIsProtected = TRUE;
                    break;

                case TRACKER_TYPE_Caret:
                    pCaretTracker = DYNCAST( CCaretTracker, _pActiveTracker );
                    Assert(pCaretTracker);

                    IFC( pCaretTracker->TerminateTypingBatch() );
                    break;
            }
        }            
        
        if ( fIsProtected )
        {
            // protect or read-only, need to ignore all ime input

            _pIme = new CIme_Protected(this);
        }
        else
        {
            // if a special UI, or IME is "near caret", then drop into lev. 2 mode.
            DWORD imeProperties = ImmGetProperty( GetKeyboardLayout(0), IGP_PROPERTY );

            if (    0 != ( imeProperties & IME_PROP_SPECIAL_UI )
                 || 0 == ( imeProperties & IME_PROP_AT_CARET )
                 || forceLevel2 )
            {
                _pIme = new CIme_Lev2( this );     // level 2 IME.
            }
            else
            {
                _pIme = new CIme_Lev3( this );     // level 3 IME->TrueInline.
            }
        }

        if(_pIme == NULL)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            IFC( _pIme->Init() );
        }
    }

    if ( IsIMEComposition() )                    // make the method call.
    {
        if (pEvent)
        {
            if (pSelectTracker || _pIme->_fHanjaMode)
            {
                _pIme->_fHanjaMode = FALSE;
                if (!fIsProtected)
                {
                    
                    // $- Why was this HR dropped
                    IGNORE_HR( DeleteRebubble( pEvent ) );

                    //
                    // We had a selection and deleted it. We need to 
                    // commit the undo unit created by the IME, and then re-open 
                    // another one after the selection is deleted so that the 
                    // previous selection can be restored even if the IME composition
                    // is canceled.
                    //
                    Assert( _pCaretTracker );
                    IFC( _pCaretTracker->TerminateTypingBatch() );
                    IFC( _pIme->CloseUndoUnit(TRUE) );
                    IFC( _pIme->OpenUndoUnit() );
                }
            }
            else if (!fIsProtected && (!_pActiveTracker || _pActiveTracker->GetTrackerType() != TRACKER_TYPE_Caret))
            {
                hr = THR( PositionCaret( pEvent ));
            }
        }
        //
        // Do NOT Move this line up!
        // In case of DeleteRebubble,
        // we need the hr vaule from
        // StartComposition instead
        // of from the above!
        //
        // [zhenbinx]
        //
        hr = _pIme->StartComposition(); 
    }

Cleanup:

    RRETURN1(hr,  S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT CompositionStringGlue( const LPARAM lparam, TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Handle all intermediary and final composition strings.
//
//  @comm
//      Called from the message loop to handle EVT_IME_COMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//      We may be called independently of a EVT_IME_STARTCOMPOSITION
//      message, in which case we return S_FALSE to allow the
//      DefWindowProc to return EVT_IME_CHAR messages.
//
//  @devnote
//      Side Effect: the _ime object may be deleted if composition
//      string processing is finished.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::CompositionStringGlue(
    const LPARAM lparam,
    CEditEvent* pEvent)
{
    HRESULT hr;

    _fIgnoreImeCharMsg = FALSE;

    // Retrieve the codepage for the current thread
    _codepageKeyboard = GetKeyboardCodePage();
    
    if ( IsIMEComposition() )
    {        
        _pIme->_compMessageRefCount++;            // For proper deletion.

        hr = _pIme->CompositionString(lparam, pEvent );

        _pIme->_compMessageRefCount--;            // For proper deletion.

        Assert ( _pIme->_compMessageRefCount >= 0);

        CheckDestroyIME(pEvent);         // Finished processing?
    }
    else  
    {
        //
        // Review-2000/07/24-zhenbinx:  We would need to know if IME message
        // if fired on editable element. Now that Trident disables IME if 
        // an non-editable element becomes current, we will not need to 
        // test against editability
        //
    
        //
        // Handle a 'naked' EVT_IME_COMPOSITION message.  Naked implies
        // that this IME message came *after* the EVT_IME_ENDCOMPOSITION
        // message.
        //
    
        hr = S_FALSE;

        // even when not in composition mode, we may receive a result string.

        if ( pEvent && _pActiveTracker)
        {
            if (_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection)
            {
                CSelectTracker * pSelectTracker = DYNCAST( CSelectTracker, _pActiveTracker );

                if (pSelectTracker->EndPointsInSameFlowLayout())
                {
                    IFC( DeleteRebubble( pEvent ));
                }
            }
            else if (_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret)
            {
                CImeDummy ime( this );

                IFC( ime.Init() );
                _fIgnoreImeCharMsg = TRUE; // Ignore the next EVT_IME_CHAR message
                
                hr = THR( ime.CheckInsertResultString( lparam ) );
                IFC( ime.Deinit() );
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT EndCompositionGlue( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Composition string processing is about to end.
//
//  @comm
//      Called from the message loop to handle EVT_IME_ENDCOMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//
//  @devnote
//      The only time we have to handle EVT_IME_ENDCOMPOSITION is when the
//      user changes input method during typing.  For such case, we will get
//      a EVT_IME_ENDCOMPOSITION message without getting a EVT_IME_COMPOSITION
//      message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
//      with GCS_RESULTSTR to let CompositionString to get rid of the string.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::EndCompositionGlue( CEditEvent* pEvent )
{
    if ( IsIMEComposition() )
    {
        // set this flag. If we are still in composition mode, then
        // let the CompositionStringGlue() to destroy the ime object.
        _pIme->_fDestroy = TRUE;

        // remove any remaining composition string.
        CompositionStringGlue( GCS_COMPSTR, pEvent );

        // finished with IME, destroy it.
        CheckDestroyIME( pEvent );
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  void CheckDestroyIME ( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Check for IME and see detroy if it needs it..
//
//-----------------------------------------------------------------------------

void
CSelectionManager::CheckDestroyIME(CEditEvent* pEvent )
{
    if ( IsIMEComposition() && _pIme->_fDestroy )
    {
        if ( 0 == _pIme->_compMessageRefCount )
        {
            _pIme->Deinit();
            delete _pIme;
            _pIme = NULL;

            // If the Caret tracker is currently active, then 
            // reposition the caret tracker so that a caret is displayed 
            // when we go away.
            if( pEvent && _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret )
            {
                IGNORE_HR( PositionCaret( pEvent ) );
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  void PostIMECharGlue()
//
//  @func
//      Called after processing a single EVT_IME_CHAR in order to
//      update the position of the IME's composition window. This
//      is glue code to call the CIME virtual equivalent.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::PostIMECharGlue(  )
{
    if ( IsIMEComposition() )
    {
        _pIme->PostIMEChar();
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  void CompositionFullGlue( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Current IME Composition window is full.
//
//  @comm
//      Called from the message loop to handle EVT_IME_COMPOSITIONFULL.
//      This message applied to Level 2 only.  We will use the default
//      IME Composition window.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::CompositionFullGlue( )
{
    if ( IsIMEComposition() )
    {
        HIMC hIMC = ImmGetContext();

        if ( hIMC )
        {
            COMPOSITIONFORM cf;

            // no room for text input in the current level 2 IME window,
            // fall back to use the default IME window for input.

            cf.dwStyle = CFS_DEFAULT;
            ImmSetCompositionWindow( hIMC, &cf );  // Set composition window.
            ImmReleaseContext( hIMC );             // Done with IME context.
        }
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  function:   CSelectionManager::ClearHighlightSegments()
//
//-----------------------------------------------------------------------------

HRESULT
CIme::ClearHighlightSegments()
{
    IHighlightSegment   **ppSegment;
    int                 i;
    HRESULT             hr = S_OK;

    for( i = _arySegments.Size(), ppSegment = _arySegments;
         i > 0;
         i--, ppSegment++)
    {
        IFC( _pManager->GetEditor()->GetHighlightServices()->RemoveSegment( *ppSegment ) );
    }

    _arySegments.ReleaseAll();

Cleanup:    
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  function:   CSelectionManager::AddHighlightSegment()
//
//  synopsis:   Is index even used? flast?  Documentation on this function?
//
//-----------------------------------------------------------------------------
HRESULT
CIme::AddHighlightSegment(LONG              ichMin,
                          LONG              ichMost,
                          IHTMLRenderStyle *pIRenderStyle )
{
    HRESULT             hr;
    CEditPointer        epStart(_pManager->GetEditor());
    CEditPointer        epEnd(_pManager->GetEditor());
    DWORD               dwSearch = BREAK_CONDITION_Text;
    DWORD               dwFound;
    int                 ich;
    IHighlightSegment   *pISegment = NULL;
    SP_IDisplayPointer  spDispStart;
    SP_IDisplayPointer  spDispEnd;
 
    Assert( ichMost >= ichMin );

    // Move to the start pointer
    IFC( epStart->MoveToPointer( _pmpStartUncommitted ) );

    // Scan thru the string, finding the start position
    for (ich = 0; ich < ichMin; ich++)
    {
        IFC( epStart.Scan(RIGHT, dwSearch, &dwFound) );

        if (!epStart.CheckFlag(dwFound, dwSearch))
            break;
    }

    // Find the end position
    IFC( epEnd->MoveToPointer( epStart ) );
    for (; ich < ichMost; ich++)
    {
        IFC( epStart.Scan(RIGHT, dwSearch, &dwFound) );

        if (!epStart.CheckFlag(dwFound, dwSearch))
            break;
    }        

    // Add our segment
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispStart->MoveToMarkupPointer(epStart, NULL) );
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispEnd->MoveToMarkupPointer(epEnd, NULL) );
    
    IFC( _pManager->GetEditor()->GetHighlightServices()->AddSegment( spDispStart, spDispEnd, pIRenderStyle, &pISegment ) );
    IFC( _arySegments.Append(pISegment) );

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  INT CIme::GetCompositionStringInfo( CCaretTracker * pCT, DWORD dwIndex,
//            WCHAR * achCompStr, INT cchMax, BYTE * pbAttrib, INT cbAttrib
//            LONG * pcchAttrib )
//
//  @mfunc
//      For EVT_IME_COMPOSITION string processing to get the requested
//      composition string, by type, and convert it to Unicode.
//
//  @devnote
//      We must use ImmGetCompositionStringA because W is not supported
//      on Win95.
//
//  @rdesc
//      INT-cch of the Unicode composition string. In error cases, return 0
//      Out param in UniCompStr.
//
//-----------------------------------------------------------------------------

INT
CIme::GetCompositionStringInfo(
    DWORD dwIndex,      // @parm The type of composition string.
    WCHAR *pchCompStr,  // @parm Out param, unicode result string.
    INT cchMax,         // @parm The cch for the Out param.
    BYTE *pbAttrib,     // @parm Out param, If attribute info is needed.
    INT cbMax,          // @parm The cb of the attribute info.
    LONG *pichCursor,   // @parm Out param, returns the CP of cusor.
    LONG *pcchAttrib )  // @parm how many attributes returned.
{
    BYTE abCompStr[256];
    INT cbCompStr, cchCompStr;
    HIMC hIMC = ImmGetContext();

    if (hIMC)
    {
        const BOOL fIsOnNT = _pManager->IsOnNT();
        
        Assert ( pchCompStr );
        Assert(cchMax > 0);

        AssertSz(    dwIndex == GCS_COMPREADSTR
                  || dwIndex == GCS_COMPSTR
                  || dwIndex == GCS_RESULTREADSTR
                  || dwIndex == GCS_RESULTSTR,
                  "String function expected" );

        if ( pichCursor )                                 // Init cursor out param.
           *pichCursor = -1;
        if ( pcchAttrib )
           *pcchAttrib = 0;
                                                        // Get composition string.
        if (fIsOnNT)
        {
            cbCompStr = ImmGetCompositionStringW( hIMC, dwIndex, pchCompStr, ( cchMax - 1 ) * sizeof(WCHAR) );
            cchCompStr = (cbCompStr > 0) ? (cbCompStr/sizeof(TCHAR)) : 0;
            pchCompStr[(cchCompStr < cchMax) ? cchCompStr : (cchMax - 1)] = 0;
        }
        else
        {
            cbCompStr = ImmGetCompositionStringA( hIMC, dwIndex, abCompStr, sizeof(abCompStr) - 1 );

            if (cbCompStr > 0 && *abCompStr)              // If valid data.
            {
                Assert ( (cbCompStr >> 1) < (cchMax - 1) ); // Convert to Unicode.
                cchCompStr = MultiByteToWideChar( _pManager->KeyboardCodePage(), 0,
                                                  (CHAR *) abCompStr, cbCompStr,
                                                  pchCompStr, cchMax );
                pchCompStr[(cchCompStr < cchMax) ? cchCompStr : (cchMax - 1)] = 0;
            }
            else
            {
                cchCompStr = 0;
                pchCompStr[0] = 0;
            }
        }

        if ( cchCompStr > 0 && *pchCompStr )            // If valid data.
        {
            if ( pbAttrib || pichCursor )               // Need cursor or attribs?
            {
                INT ichCursor=0, cchAttrib;

                if (fIsOnNT)
                {
                    ichCursor = ImmGetCompositionStringW( hIMC, GCS_CURSORPOS, NULL, 0 );
                    cchAttrib = ImmGetCompositionStringW( hIMC, GCS_COMPATTR, pbAttrib, cbMax );
                }
                else
                {
                    INT ib, ich;
                    INT ibCursor, ibMax, cbAttrib;
                    BYTE abAttribLocal[256];
                    BYTE * pbAttribPtr = pbAttrib;

                    ibCursor = ImmGetCompositionStringA( hIMC, GCS_CURSORPOS, NULL, 0 );
                    cbAttrib = ImmGetCompositionStringA( hIMC, GCS_COMPATTR, abAttribLocal, 255 );

                                                        // MultiToWide conversion.
                    ibMax = max( ibCursor, cbAttrib );
                    if ( NULL == pbAttrib ) cbMax = cbAttrib;

                    for (ib = 0, ich = 0; ib <= ibMax && ich < cbMax; ib++, ich++ )
                    {
                        if ( ibCursor == ib )           // Cursor from DBCS.
                            ichCursor = ich;

                        if ( IsDBCSLeadByteEx( KeyboardCodePage(), abCompStr[ib] ) )
                            ib++;

                        if ( pbAttribPtr && ib < cbAttrib )  // Attrib from DBCS.
                            *pbAttribPtr++ = abAttribLocal[ib];
                    }

                    cchAttrib = ich - 1;
                }

                if ( ichCursor >= 0 && pichCursor )     // If client needs cursor
                    *pichCursor = ichCursor;            //  or cchAttrib.
                if ( cchAttrib >= 0 && pcchAttrib )
                    *pcchAttrib = cchAttrib;
            }
        }
        else
        {
            if ( pichCursor )
                *pichCursor = 0;
            cchCompStr = 0;
        }

        ImmReleaseContext(hIMC);
    }
    else
    {
        cchCompStr = 0;
        pchCompStr[0] = 0;
    }

    return cchCompStr;
}

//+----------------------------------------------------------------------------
//  void CIme::SetCompositionFont ( BOOL *pfUnderLineMode )
//
//  @mfunc
//      Important for level 2 IME so that the composition window
//      has the correct font. The lfw to lfa copy is due to the fact that
//      Win95 does not support the W)ide call.
//      It is also important for both level 2 and level 3 IME so that
//      the candidate list window has the proper. font.
//
//-----------------------------------------------------------------------------

void /* static */
CIme::SetCompositionFont (
    BOOL     *pfUnderLineMode)  // @parm the original char Underline mode
{
    // Todo: (cthrash) We don't support this currently.  Didn't in IE4 either.

    pfUnderLineMode = FALSE;
}

//+----------------------------------------------------------------------------
//
//  funtion:    CIme::GetCompositionPos( POINT * ppt, RECT * prc )
//
//  synopsis:   Determine the position for composition windows, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CIme::GetCompositionPos(
    POINT * ppt,
    RECT * prc,
    long * plLineHeight )
{
    HWND hwnd;
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IHTMLCaret spCaret;
    SP_IOleWindow spOleWindow;
    SP_IDisplayPointer spDispPos;
    SP_IMarkupPointer spInsertionPoint;
    SP_ILineInfo spLineInfo;
    LONG lTextDescent;
    
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
    
    Assert(ppt && prc && plLineHeight);

    //
    // We get the line dimensions at the position of the caret. I realize we could
    // get some of the data from the caret, but we have to call through this way
    // anyway to get the descent and line height.
    //

    IFC( GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( spDispPos ));
    IFC( spDispPos->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_x(&ppt->x) );
    
    IFC( spLineInfo->get_baseLine(&ppt->y) );
    IFC( spLineInfo->get_textDescent(&lTextDescent) );
    ppt->y += lTextDescent;

    IFC( spLineInfo->get_textHeight(plLineHeight) );

    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spInsertionPoint) );
    IFC( _pDispInsertionPoint->PositionMarkupPointer(spInsertionPoint) );
    IFC( _pDispInsertionPoint->GetFlowElement( &spElement ));
    if ( ! spElement )
    {
        IFC( _pManager->GetEditableElement( & spElement ));
    }

    IFC( GetDisplayServices()->TransformPoint( ppt, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spElement ));
    IFC(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    IFC(spOleWindow->GetWindow(&hwnd));

    ::GetClientRect(hwnd, prc);
    _pManager->GetEditor()->DeviceFromDocPixels(ppt);

Cleanup:
    RRETURN(hr);    
}


//+----------------------------------------------------------------------------
//  Method:     HRESULT CIme::UpdateInsertionPoint()
//
//  Purpose:    This method should be called to update the IME insertion 
//              position.
//
//  Returns:    HRESULT - FAILED(hr) if there was a failure attempting to 
//              move the IME position
//
//-----------------------------------------------------------------------------

HRESULT
CIme::UpdateInsertionPoint()
{
    HRESULT hr = S_OK;
    SP_IHTMLCaret spCaret;

    // Get the current caret position
    IFC( _pManager->GetDisplayServices()->GetCaret( &spCaret ) );

    // Adjust the IME markup pointers
    IFC( spCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );
    IFC( AdjustUncommittedRangeAroundInsertionPoint() );

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  void CIme::SetCompositionForm ()
//
//  @mfunc
//      Important for level 2 IME so that the composition window
//      is positioned correctly.
//
//  @comm
//      We go through a lot of work to get the correct height. This requires
//      getting information from the font cache and the selection.
//
//-----------------------------------------------------------------------------

void
CIme::SetCompositionForm()
{
    if ( IME_LEVEL_2 == GetIMELevel() )
    {
        HIMC hIMC = ImmGetContext();                // Get host's IME context.

        if ( hIMC )
        {
            COMPOSITIONFORM cf;
            long lLineHeight;
            HRESULT hr = THR( GetCompositionPos( &cf.ptCurrentPos, &cf.rcArea, &lLineHeight ) );

            if (OK(hr))
            {

                // Bounding rect for the IME (lev 2) composition window, causing
                //  composition text to be wrapped within it.
                cf.dwStyle = CFS_POINT + CFS_FORCE_POSITION;

                // Make sure the starting point is not
                // outside the rcArea.  This happens when
                // there is no text on the current line and the user
                // has selected a large font size.

                if (cf.ptCurrentPos.y < cf.rcArea.top)
                    cf.ptCurrentPos.y = cf.rcArea.top;
                else if (cf.ptCurrentPos.y > cf.rcArea.bottom)
                    cf.ptCurrentPos.y = cf.rcArea.bottom;

                if (cf.ptCurrentPos.x < cf.rcArea.left)
                    cf.ptCurrentPos.x = cf.rcArea.left;
                else if (cf.ptCurrentPos.x > cf.rcArea.right)
                    cf.ptCurrentPos.x = cf.rcArea.right;

                ImmSetCompositionWindow( hIMC, &cf );  // Set composition window.
            }

            ImmReleaseContext( hIMC );             // Done with IME context.
        }
    }
}



//+----------------------------------------------------------------------------
//
//  CIme::TerminateIMEComposition ( TerminateMode mode )
//
//  @mfunc  Terminate the IME Composition mode using CPS_COMPLETE
//  @comm   The IME will generate EVT_IME_COMPOSITION with the result string
//
//
//-----------------------------------------------------------------------------

void
CIme::TerminateIMEComposition(
    DWORD dwMode,
    CEditEvent* pEvent)
{
    TraceTag((tagEdIME, "CIme::TerminateIMEComposition:"));

    DWORD dwTerminateMethod = CPS_COMPLETE;

    if (    IME_LEVEL_2 == GetIMELevel()                // force cancel for near-caret IME
         || dwMode == TERMINATE_FORCECANCEL             // caller wants force cancel
         || _pManager->IsImeCancelComplete() )          // Client wants force cancel
    {
        dwTerminateMethod = CPS_CANCEL;
    }

    HIMC hIMC = ImmGetContext();

    // force the IME to terminate the current session
    if (hIMC)
    {
        _compMessageRefCount++; // primitive addref

        BOOL retCode = ImmNotifyIME( hIMC, NI_COMPOSITIONSTR, dwTerminateMethod, 0 );

        if ( !retCode && !_pManager->IsImeCancelComplete() )
        {
            // CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
            // CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)

            retCode = ImmNotifyIME( hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
        }

        Assert ( retCode );

        ImmReleaseContext( hIMC );

        _compMessageRefCount--; // primitive release

        _pManager->CheckDestroyIME(pEvent);
    }
    else
    {
        // for some reason, we didn't have a context, yet we thought we were still in IME
        // compostition mode.  Just force a shutdown here.

        _pManager->EndCompositionGlue( pEvent);
    }
}


//+----------------------------------------------------------------------------
//
//  CIme::CIme
//
//-----------------------------------------------------------------------------

CIme::CIme( CSelectionManager * pManager ) :  _pManager(pManager)
{
    _pBatchPUU = NULL;
}

CIme::~CIme()
{
    TraceTag((tagEdIME, "CIme::~CIme"));
}

//+----------------------------------------------------------------------------
//
//  CIme_Lev2::CIme_Lev2()
//
//  @mfunc
//      CIme_Lev2 Constructor/Destructor.
//
//  @comm
//      Needed to make sure _iFormatSave was handled properly.
//
//-----------------------------------------------------------------------------

CIme_Lev2::CIme_Lev2( CSelectionManager * pManager ) : CIme( pManager )     // @parm the containing text edit.
{
    LONG    iFormat = 0;

    SetIMECaretWidth( DXCARET );           // setup initial caret width
    _iFormatSave = iFormat;

    // hold notification unless client has set IMF_IMEALWAYSSENDNOTIFY via EM_SETLANGOPTIONS msg
    _fHoldNotify = !pManager->IsImeAlwaysNotify();
}

CIme_Lev2::~CIme_Lev2()
{
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::StartComposition()
//
//  @mfunc
//      Begin IME Level 2 composition string processing.
//
//  @comm
//      Set the font, and location of the composition window which includes
//      a bounding rect and the start position of the cursor. Also, reset
//      the candidate window to allow the IME to set its position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------


HRESULT
CIme_Lev2::StartComposition( )
{
    TraceTag((tagEdIME, "CIme_Lev2::StartComposition:"));

    _imeLevel = IME_LEVEL_2;

    SetCompositionFont(&_fUnderLineMode);     // Set font, & comp window.
    SetCompositionForm( );

    return S_FALSE;           // Allow DefWindowProc processing.
}                                                   

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::CompositionString( LPARAM lparam )
//
//  @mfunc
//      Handle Level 2 EVT_IME_COMPOSITION messages.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing.
//
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//          The Host needs to mask out the lparam before calling DefWindowProc to
//          prevent unnessary EVT_IME_CHAR messages.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev2::CompositionString (
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    TraceTag((tagEdIME, "CIme_Lev2::CompositionString: HaveResultString [%d]", HaveResultString(lparam) ));

    _fIgnoreIMEChar = FALSE;

    if ( HaveResultString(lparam) )
    {
        CheckInsertResultString( lparam );
        SetCompositionForm( );                   // Move Composition window.

        _fHoldNotify = FALSE;                       // OK notify client for change

    #if DUNNO /*{*/
        // In case our host is not turning off the ResultString bit
        // we need to ignore EVT_IME_CHAR or else we will get the same
        // DBC again.
        if ( !ts.fInOurHost() )
            _fIgnoreIMEChar = TRUE;
    #else
        _fIgnoreIMEChar = TRUE;
    #endif /*}*/
    }

    // Always return S_FALSE so the DefWindowProc will handle the rest.
    // Host has to mask out the ResultString bit to avoid EVT_IME_CHAR coming in.
    return S_FALSE;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme::CheckInsertResultString ( const LPARAM lparam )
//
//  @mfunc
//      handle inserting of GCS_RESULTSTR text, the final composed text.
//
//  @comm
//      When the final composition string arrives we grab it and set it into the text.
//
//  @devnote
//      A GCS_RESULTSTR message can arrive and the IME will *still* be in
//      composition string mode. This occurs because the IME's internal
//      buffers overflowed and it needs to convert the beginning of the buffer
//      to clear out some room. When this happens we need to insert the
//      converted text as normal, but remain in composition processing mode.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//
//-----------------------------------------------------------------------------


HRESULT
CIme::CheckInsertResultString (
    const LPARAM lparam )
{
    HRESULT hr = S_OK;
    CCaretTracker * pCaretTracker = NULL;

    TraceTag((tagEdIME, "CIme::CheckInsertResultString: CleanupCompositionString [%d] HaveResultString [%d]", CleanupCompositionString(lparam), HaveResultString(lparam) ));

    if ( CleanupCompositionString(lparam) || HaveResultString(lparam) )      // If result string..
    {
        LONG    cch;                    // Count of final result string
        WCHAR   achCompStr[256];        // Characters for result string

        if (S_OK != GetCaretTracker( &pCaretTracker ))
            goto Cleanup;

        
        // Get result string.
        cch = (LONG)GetCompositionStringInfo( GCS_RESULTSTR,
                                              achCompStr, ARRAY_SIZE(achCompStr),
                                              NULL, 0, NULL, NULL );


        if (( achCompStr[0] == 32) && (cch == 1))
        {
            //
            // What is this?  Just a quick test with the 
            // Korean and Japanese IMEs shows this is worthless.  We
            // are in a Unicode enviroment, checking for space
            // like this is completely worthless.  Look into 
            // removing
            //
            AssertSz(FALSE, "We should never be here");
            hr = THR( pCaretTracker->HandleSpace( achCompStr[0] ));            
        }
        else
        {
            // Make sure we don't exceed the maximum allowed for edit box.
#if TODO /*{*/
            LONG cchMax = psel->GetCommonContainer()->HasFlowLayout()->GetMaxLength()    // total
                          - ts.GetContentMarkup()->GetTextLength()                       // already occupied
                          + psel->GetCch();                                              // about to be deleted
#else
            LONG cchMax = MAXLONG;
#endif /*}*/
            cch = min( cch, cchMax );

            //
            // Perform a URL auto-detection ( we have a result, which may contain
            // one or more spaces )
            //
            if( HaveResultString(lparam) )
            {
                IGNORE_HR( pCaretTracker->UrlAutodetectCurrentWord(NULL) );
            }

            IFC( ReplaceRange(achCompStr, cch, TRUE, -1, TRUE) );

#if TODO /*{*/
            // (cthrash) necessary?
            if (cch)
            {
                psel->LaunderSpaces( psel->GetCpMin(), cch );
            }
#endif /*}*/
            // If we didn't accept anything, let the caller know to
            // terminate the composition.  We can't directly terminate here
            // as we may end up in a recursive call to our caller.
            hr = (cch == cchMax) ? S_FALSE : S_OK;
        }

        // We have had a successful composition.  Set fResultOccurred to 
        // TRUE so that the caret will be repositioned on the next composition.
        _fResultOccurred = TRUE;        

        // Close out the current undo sequence (saving the undo unit only if we
        // had a result string ).  Open another undo unit for any further compositions.
        IFC( CloseUndoUnit( HaveResultString(lparam) ) );
        IFC( OpenUndoUnit() );
    }

Cleanup:

    if (pCaretTracker)
        pCaretTracker->Release();

    RRETURN1(hr,S_FALSE);
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::IMENotify( const WPARAM wparam, const LPARAM lparam )
//
//  @mfunc
//      Handle Level 2 EVT_IME_NOTIFY messages.
//
//  @comm
//      Currently we are only interested in knowing when to reset
//      the candidate window's position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::NotifyGlue(
    const WPARAM wparam,
    const LPARAM lparam)
{
    HRESULT hr = S_FALSE;
    
    if (IsIMEComposition())
    {
        hr = THR(_pIme->IMENotify(wparam,lparam));
    }

    RRETURN1(hr,S_FALSE);
}
                             
HRESULT
CIme_Lev2::IMENotify(
    const WPARAM wparam,
    const LPARAM lparam )
{
    TraceTag((tagEdIME, "CIme_Lev2::IMENotify: wparam [%x]", wparam));

    return S_FALSE;    // Allow DefWindowProc processing
}


//+----------------------------------------------------------------------------
//  void CIme_Lev2::PostIMEChar()
//
//  @mfunc
//      Called after processing a single EVT_IME_CHAR in order to
//      update the position of the IME's composition window.
//
//
//-----------------------------------------------------------------------------

void
CIme_Lev2::PostIMEChar()
{
    TraceTag((tagEdIME, "CIme_Lev2::PostIMEChar:"));

    SetCompositionForm();                       // Move Composition window.
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev3::StartComposition()
//
//  @mfunc
//      Begin IME Level 3 composition string processing.
//
//  @comm
//      For rudimentary processing, remember the start and
//      length of the selection. Set the font in case the
//      candidate window actually uses this information.
//
//  @rdesc
//      This is a rudimentary solution for remembering were
//      the composition is in the text. There needs to be work
//      to replace this with a composition "range".
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev3::StartComposition()
{
    TraceTag((tagEdIME, "CIme_Lev3::StartComposition:"));

    _imeLevel = IME_LEVEL_3;

    DWORD dwConversion, dwSentence;

    HIMC hIMC = ImmGetContext();

    if ( hIMC )                                     // Set _fKorean flag.
    {                                               //  for block cursor.
        if ( ImmGetConversionStatus( hIMC, &dwConversion, &dwSentence ) )
        {
            // NOTE:- the following is set for all FE system during IME input,
            // so we also need to check keyboard codepage as well.

            if ( dwConversion & IME_CMODE_HANGEUL )
            {
                _fKorean = (_KOREAN_CP == KeyboardCodePage());
            }
        }

        ImmReleaseContext( hIMC );             // Done with IME context.
    }

    SetCompositionFont( &_fUnderLineMode );

    // 
    //  If there were selections, it should have been processed by
    //  CSelectioManager::StartCompositionGlue. There is no need
    //  to remove selection here. 
    //  [zhenbinx]
    //
    
    return S_OK;                                    // No DefWindowProc
}                                                   //  processing.

//+----------------------------------------------------------------------------
//
//  HRESULT CIme_Lev3::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle Level 3 EVT_IME_COMPOSITION messages.
//
//  @comm
//      Display all of the intermediary composition text as well as the final
//      reading.
//
//  @devnote
//      This is a rudimentary solution for replacing text in the backing store.
//      Work is left to do with the undo list, underlining, and hiliting with
//      colors and the selection.
//
//  @devnote
//      A GCS_RESULTSTR message can arrive and the IME will *still* be in
//      composition string mode. This occurs because the IME's internal
//      buffers overflowed and it needs to convert the beginning of the buffer
//      to clear out some room. When this happens we need to insert the
//      converted text as normal, but remain in composition processing mode.
//
//      Another reason, GCS_RESULTSTR can occur while in composition mode
//      for Korean because there is only 1 correct choice and no additional
//      user intervention is necessary, meaning that the converted string can
//      be sent as the result before composition mode is finished.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

IHTMLRenderStyle *CIme::HighlightTypeFromAttr( BYTE a )
{
    IHTMLRenderStyle *pIRenderStyle=NULL;
    CRenderStyle *pRenderStyle = NULL;
    VARIANT vtColorValue;
    IHTMLDocument4 *pDoc=NULL;
    HRESULT hr;

    pDoc = _pManager->GetEditor()->GetDoc4();
    IFC( pDoc->createRenderStyle(NULL, &pIRenderStyle) );
    hr = pIRenderStyle->QueryInterface(CLSID_HTMLRenderStyle, (void **)&pRenderStyle);
    if (hr == S_OK)
        pRenderStyle->_fSendNotification = FALSE;

    switch( a )
    {
        case 0: // ATTR_INPUT
        case 2: // ATTR_CONVERTED
        case 4: // ATTR_ERROR
            pIRenderStyle->put_defaultTextSelection(SysAllocString(_T("false")));
            pIRenderStyle->put_textUnderlineStyle(SysAllocString(_T("dotted")));
            pIRenderStyle->put_textDecoration(SysAllocString(_T("underline")));
            VariantInit(& vtColorValue );
            V_VT( & vtColorValue ) = VT_BSTR;
            V_BSTR( & vtColorValue ) = SysAllocString(_T("transparent"));
            pIRenderStyle->put_textBackgroundColor(vtColorValue);
            VariantClear( & vtColorValue );
            VariantInit(& vtColorValue );
            V_VT( & vtColorValue ) = VT_BSTR;
            V_BSTR( & vtColorValue ) = SysAllocString(_T("transparent"));
            pIRenderStyle->put_textColor(vtColorValue);
            VariantClear( & vtColorValue );
            break;

        case 1: // ATTR_TARGET_CONVERTED
        case 3: // ATTR_TARGET_NOTCONVERTED
        case 5: // Hangul IME mode
        default: // default
            // Nothing needs to be done, default takes care of everything
            break;

    }

Cleanup:
    ReleaseInterface(pDoc);

    return pIRenderStyle;
}

HRESULT
CIme_Lev3::CompositionString(
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    BOOL        fTerminateWhenDone = FALSE;
    HRESULT     hr = S_OK;
    IHTMLRenderStyle* pIHTMLRenderStyle=NULL;
    IHTMLDocument4* pDoc=NULL;
    IHTMLRenderStyle* pIRenderStyle = NULL; 
#if DBG==1
    static BOOL fNoRecurse = FALSE;

    Assert ( !fNoRecurse );
    fNoRecurse = TRUE;
#endif

    TraceTag((tagEdIME, "CIme_Lev3::CompositionString: CleanupComposition [%d] HaveResult [%d] HaveComposition [%d]", CleanupCompositionString(lparam), HaveResultString(lparam), HaveCompositionString(lparam) ));

    // Check if we have a result string
    if (  CleanupCompositionString(lparam) || HaveResultString(lparam)  )
    {
        SetCaretVisible(FALSE);

        // $TODO - We need to hide the current selection, and then show it
        // ShowSelection(FALSE);

        IFC( CheckInsertResultString( lparam ) );
        if( hr == S_FALSE )
        {
            fTerminateWhenDone = TRUE;
        }

        // ShowSelection(TRUE);
        SetCaretVisible(TRUE);

        // We had a result, we will now take notifications
        _fHoldNotify = FALSE;
    }

    // Do we have a composition?
    if ( HaveCompositionString(lparam) )
    {
        LONG        cchCompStr = 0;     // Length of the new composition string
        WCHAR       achCompStr[256];    // String
        BYTE        abAttrib[256];      // Attributes
        LONG        ichCursor;          // Position of the cursor
        LONG        cchAttrib = 0;      // Number of attributes
        BOOL        fShowCaret;         // Should we show the caret?
        // Get new intermediate composition string, attribs, and caret.
        cchCompStr = GetCompositionStringInfo( GCS_COMPSTR,
                                               achCompStr, ARRAY_SIZE(achCompStr),
                                               abAttrib, ARRAY_SIZE(abAttrib),
                                               &ichCursor, &cchAttrib );

        // When there is no old text or new text, just show the caret
        // This is the case when client used TerminateIMEComposition with
        // CPS_CANCEL option.

        if ( /*!cchOld &&*/ !cchCompStr )
        {
            SetCaretVisible(TRUE);
            ReplaceRange(NULL, 0, TRUE, 0);
        }
        else
        {
            // Determine whether we need to hide the caret
            //   1. Never show caret for korean
            //   2. Show the caret if we are at the end of composition string (ichCursor == cchAttrib)
            //   3. Show the caret if the cursor position is at an input position in the string
            fShowCaret = !_fKorean && 
                          (ichCursor == cchAttrib || ( ( ichCursor && abAttrib[ichCursor - 1] == ATTR_INPUT ) ||
                                                         abAttrib[ichCursor] == ATTR_INPUT ) );

            if (_fKorean)
            {
                ichCursor = 1;
            }
            
            // 
            // IGNORE_HR is not good here. However we have no better failure recovery
            // scheme, use this.   [zhenbinx]
            //
            //
            IGNORE_HR( ReplaceRange( achCompStr, cchCompStr, fShowCaret, ichCursor, FALSE) );
            
            if ( ichCursor > 0 )
            {
                ichCursor = min(cchCompStr, ichCursor);
            }

            if ( cchCompStr && cchCompStr <= cchAttrib && !_fKorean )     // no Korean style needed
            {
                // NB (cthrash)
                //
                // Each character in IME string has an attribute.  They can
                // be one of the following:
                //
                // 0 - ATTR_INPUT                   dotted underline
                // 1 - ATTR_TARGET_CONVERTED        inverted text, no underline
                // 2 - ATTR_CONVERTED               dotted underline
                // 3 - ATTR_TARGET_NOTCONVERTED     solid underline
                // 4 - ATTR_ERROR                   ???
                //
                // The right column is how the text is rendered in the standard
                // Japanese Windows Edit Widget.
                //

                BYTE abCur;
                int  ichMin = 0;
                int  ichMost;

                //
                // Add the segments
                //

                IFC( (ClearHighlightSegments()) )

                abCur = abAttrib[0];

                for (ichMost = 1; ichMost < cchCompStr; ichMost++)
                {
                    if (abAttrib[ichMost] == abCur)
                        continue;
                    pIRenderStyle = HighlightTypeFromAttr(abCur); 
                    AddHighlightSegment( ichMin, ichMost, pIRenderStyle );
                    ReleaseInterface( pIRenderStyle );
                    ichMin = ichMost;

                    abCur = abAttrib[ichMost];
                }

                if (ichMin != ichMost)
                {
                    pIRenderStyle = HighlightTypeFromAttr(abCur); 
                    AddHighlightSegment( ichMin, ichMost, pIRenderStyle );
                    ReleaseInterface( pIRenderStyle );
                }

                if (IsTagEnabled(tagEdIMEAttr))
                {
                    LONG        i;
                    static BYTE hex[17] = "0123456789ABCDEF";

                    for(i = 0; i < cchCompStr; i++)
                    {
                        abAttrib[i] = hex[abAttrib[i] & 15];
                    }

                    abAttrib[min(255L,i)] = '\0';
                    TraceTag((tagEdIMEAttr, "attrib %s", abAttrib));
                }
            }

            _TODO(ichCursor += _prgUncommitted->GetCpMin();)// Set cursor and scroll.

            if ( _fKorean && cchCompStr )
            {
                // Set the cursor (although invisible) to *after* the
                // character, so as to force a scroll. (cthrash)

                /* HIGHLIGHT_TYPE_ImeHangul */
                pDoc = _pManager->GetEditor()->GetDoc4();
                IFC( pDoc->createRenderStyle(NULL, &pIHTMLRenderStyle) );
                IFC( AddHighlightSegment( 0, cchCompStr, pIHTMLRenderStyle ) );
            }

            // make sure we have set the call manager text changed flag.  This
            // flag may be cleared when calling SetCharFormat
            //ts.GetPed()->GetCallMgr()->SetChangeEvent(CN_TEXTCHANGED);

            // setup composition window for Chinese in-caret IME
            if ( !_fKorean )
            {
                IMENotify( IMN_OPENCANDIDATE, 0x01 );
            }
        }

        // don't notify client for changes only when there is composition string available
        if ( cchCompStr && !_pManager->IsImeAlwaysNotify() )
        {
            _fHoldNotify = TRUE;
        }

    }

#if DBG==1 /*{*/
    fNoRecurse = FALSE;
#endif /*}*/

    if (fTerminateWhenDone)
    {
        TerminateIMEComposition( TERMINATE_FORCECANCEL, pEvent );
    }

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pIHTMLRenderStyle);

    RRETURN(hr);                                    // No DefWindowProc
}                                                   //  processing.

//+----------------------------------------------------------------------------
//
//  BOOL CIme_Lev3::SetCompositionStyle ( CCharFormat &CF, UINT attribute )
//
//  @mfunc
//      Set up a composition clause's character formmatting.
//
//  @comm
//      If we loaded Office's IMEShare.dll, then we ask it what the formatting
//      should be, otherwise we use our own, hardwired default formatting.
//
//  @devnote
//      Note the use of pointers to functions when dealing with IMEShare funcs.
//      This is because we dynamically load the IMEShare.dll.
//
//  @rdesc
//      BOOL - This is because CFU_INVERT is treated like a selection by
//          the renderer, and we need to know the the min invertMin and
//          the max invertMost to know if the rendered line should be treated
//          as if there are selections to be drawn.
//
//-----------------------------------------------------------------------------

BOOL
CIme_Lev3::SetCompositionStyle (
    CCharFormat &CF,
    UINT attribute )
{
    BOOL            fInvertStyleUsed = FALSE;
#if 0 /*{*/

    CF._fUnderline = FALSE;
    CF._bUnderlineType = 0;

#if IMESHARE /*{*/
    const IMESTYLE  *pIMEStyle;
    UINT            ulID;

    COLORREF        color;
#endif /*}*/

#if IMESHARE /*{*/
    // load ImeShare if it has not been done
    if ( !fLoadIMEShareProcs )
    {
        InitNLSProcTable( LOAD_IMESHARE );
        fLoadIMEShareProcs = TRUE;
    }

    if ( fHaveIMEShareProcs )
    {
        pIMEStyle = pPIMEStyleFromAttr( attribute );
        if ( NULL == pIMEStyle )
            goto defaultStyle;

        CF._fBold = FALSE;
        CF._fItalic = FALSE;

        if ( pFBoldIMEStyle ( pIMEStyle ) )
            CF._fBold = TRUE;

        if ( pFItalicIMEStyle ( pIMEStyle ) )
            CF._fItalic = TRUE;

        if ( pFUlIMEStyle ( pIMEStyle ) )
        {
            CF._fUnderline = TRUE;
            CF._bUnderlineType = CFU_UNDERLINE;

            ulID = pIdUlIMEStyle ( pIMEStyle );
            if ( UINTIMEBOGUS != ulID )
            {
                if ( IMESTY_UL_DOTTED == ulID )
                    CF._bUnderlineType = CFU_UNDERLINEDOTTED;
            }
        }

        color = pRGBFromIMEColorStyle( pPColorStyleTextFromIMEStyle ( pIMEStyle ));
        if ( UINTIMEBOGUS != color )
        {
            CF._ccvTextColor.SetValue( color, FALSE );
        }

        color = pRGBFromIMEColorStyle( pPColorStyleBackFromIMEStyle ( pIMEStyle ));
        if ( UINTIMEBOGUS != color )
        {
            //CF.dwEffects &= ~CFE_AUTOBACKCOLOR;
            CF._ccvrBackColor.SetValue( color, FALSE );

            fInvertStyleUsed = TRUE;
        }
    }
    else // default styles when no IMEShare.dll exist.
#endif //IMESHARE/*}*/
    {
#if IMESHARE /*{*/
defaultStyle:
#endif /*}*/
        switch ( attribute )
        {                                       // Apply underline style.
            case ATTR_INPUT:
            case ATTR_CONVERTED:
                CF._fUnderline = TRUE;
                CF._bUnderlineType = CFU_UNDERLINEDOTTED;
                break;
            case ATTR_TARGET_NOTCONVERTED:
                CF._fUnderline = TRUE;
                CF._bUnderlineType = CFU_UNDERLINE;
                break;
            case ATTR_TARGET_CONVERTED:         // Target *is* selection.
            {
                CF._ccvTextColor.SetSysColor(COLOR_HIGHLIGHTTEXT);

                fInvertStyleUsed = TRUE;
            }
            break;
        }
    }
#endif /*}*/
    return fInvertStyleUsed;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev3::IMENotify( const WPARAM wparam, const LPARAM lparam )
//
//  @mfunc
//      Handle Level 3 EVT_IME_NOTIFY messages.
//
//  @comm
//      Currently we are only interested in knowing when to update
//      the n window's position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev3::IMENotify(
    const WPARAM wparam,
    const LPARAM lparam )
{
    TraceTag((tagEdIME, "CIme_Lev3::IMENotify: wparam [%x]", wparam));

    if ( IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam  )
    {
        Assert ( 0 != lparam );

        HIMC hIMC = ImmGetContext();                // Get host's IME context.

        if (hIMC)
        {
            CANDIDATEFORM   cdCandForm;
            INT             index;

            // Convert bitID to INDEX because of API.

            for (index = 0; index < 32; index++ )
            {
                if ( 0 != ((1 << index) & lparam) )
                    break;
            }
            Assert ( ((1 << index) & lparam) == lparam );    // Only 1 set?
            Assert ( index < 32 );

            if ( IMN_OPENCANDIDATE == wparam && !_fKorean )  // Set candidate to caret.
            {
                POINT ptCaret;
                RECT rc;
                long lLineHeight;
                HRESULT hr = THR(GetCompositionPos(&ptCaret, &rc, &lLineHeight));

                if (OK(hr))
                {
                    ptCaret.x = max(0L, ptCaret.x);
                    ptCaret.y = max(0L, ptCaret.y);

                    cdCandForm.dwStyle = CFS_CANDIDATEPOS;

                    if (KeyboardCodePage() == _JAPAN_CP)
                    {
                        // Change style to CFS_EXCLUDE, this is to
                        // prevent the candidate window from covering
                        // the current selection.

                        cdCandForm.dwStyle = CFS_EXCLUDE;
                        cdCandForm.rcArea.left = ptCaret.x;                 

                        // FUTURE: for verticle text, need to adjust
                        // the rcArea to include the character width.

                        cdCandForm.rcArea.right =
                            cdCandForm.rcArea.left + 2;
                        cdCandForm.rcArea.top = ptCaret.y - lLineHeight;
                        ptCaret.y += 4;
                        cdCandForm.rcArea.bottom = ptCaret.y;
                    }
                    else
                    {
                        ptCaret.y += 4;
                    }

                    // Most IMEs will have only 1, #0, candidate window. However, some IMEs
                    //  may want to have a window organized alphabetically, by stroke, and
                    //  by radical.

                    cdCandForm.dwIndex = index;                         
                    cdCandForm.ptCurrentPos = ptCaret;
                    ImmSetCandidateWindow(hIMC, &cdCandForm);
                }
            }
            else                                    // Reset back to CFS_DEFAULT.
            {
                if (   ImmGetCandidateWindow(hIMC, index, &cdCandForm)
                    && CFS_DEFAULT != cdCandForm.dwStyle )
                {
                    cdCandForm.dwStyle = CFS_DEFAULT;
                    ImmSetCandidateWindow(hIMC, &cdCandForm);
                }
            }

            ImmReleaseContext( hIMC );         // Done with IME context.
        }
    }

    return S_FALSE;                                 // Allow DefWindowProc
}                                                   //  processing.


//+----------------------------------------------------------------------------
//
//  HRESULT StartHangeulToHanja()
//
//  @func
//      Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
//  @comm
//      Called from the message loop to handle VK_KANJI_KEY.
//
//  @devnote
//      We decide if we need to do a conversion by checking:
//      - the Fonot is a Korean font,
//      - the character is a valid SBC or DBC,
//      - ImmEscape accepts the character and bring up a candidate window
//
//  @rdesc
//      BOOL - FALSE for no conversion. TRUE if OK.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::StartHangeulToHanja(
    IMarkupPointer * pPointer /*= NULL */,
    CEditEvent* pEvent )
{
    int                 iResult = 0;
    char                abHangeul[3] = {0, 0, 0};
    WCHAR               achHangeul[2] = { 0, 0 };
    HRESULT             hr;
    long                cch = 1;
    const BOOL          fIsOnNT = CSelectionManager::IsOnNT();
    DWORD               dwBreakCondition;
    IHTMLDocument4      *pDoc=NULL;
    IHTMLRenderStyle    *pIHTMLRenderStyle=NULL;

    CEditPointer pEditPosition( GetEditor(), NULL );

    //
    // get the current character
    //

    if (pPointer)
    {
        IFC( pEditPosition->MoveToPointer( pPointer ) );
    }
    else
    {
        SP_IHTMLCaret  spCaret;

        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->MoveMarkupPointerToCaret( pEditPosition ));
    }

    IFC( pEditPosition.Scan(    RIGHT, 
                               BREAK_CONDITION_EnterBlock | BREAK_CONDITION_Text, 
                                &dwBreakCondition, 
                                NULL, 
                                NULL,
                                &achHangeul[0],
                                SCAN_OPTION_None ) );

    if (   cch == 1
        && (   fIsOnNT
            || WideCharToMultiByte(_KOREAN_CP, 0, achHangeul, 1, abHangeul, 2, NULL, NULL) > 0
           )
       )
    {
        HIMC hIMC = ImmGetContext();

        if (hIMC)
        {
            HKL hKL = GetKeyboardLayout(0);

            iResult = fIsOnNT
                      ? ImmEscapeW(hKL, hIMC, IME_ESC_HANJA_MODE, achHangeul)
                      : ImmEscapeA(hKL, hIMC, IME_ESC_HANJA_MODE, abHangeul);

            ImmReleaseContext(hIMC);

            if (iResult)
            {
                if ( pEvent
                    && (   !_pActiveTracker
                        || _pActiveTracker->GetTrackerType() != TRACKER_TYPE_Caret))
                {
                    if (pPointer)
                    {
                        SP_IDisplayPointer spDispPointer;

                        //  
                        // We need not care about BOL here since this only serves as a
                        // re-routing point to reset Tracker to CaretTracker. Once the 
                        // even is re-rounted to this function, it will go through 
                        // the else CIme_HangeulToHanja part. And the caret is going
                        // to be moved one step forward (that is -- re-positioned) so
                        // BOL becomes irrelevant.      [zhenbinx]
                        //
                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        IFC( spDispPointer->MoveToMarkupPointer(pPointer, NULL) );

                        IFC( PositionCaret( spDispPointer, pEvent ));
                    }
                    else
                    {
                        // (cthrash) This is wrong, but we shouldn't get here.

                        AssertSz(0, "We're not supposed to be here.");

                        IFC( PositionCaret( pEvent ));
                    }
                }
                else
                {
                    _pIme = new CIme_HangeulToHanja( this, 0 );
                    
                    if ( _pIme && IsIMEComposition() )
                    {
                        SP_IDisplayPointer spDispPointer;
                        SP_IMarkupPointer   spPointer;

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        
                        IFC( _pIme->Init() );

                        // 
                        // We need to 'select' the character.
                        //
                        IFC( _pIme->AdjustUncommittedRangeAroundInsertionPoint() );

                        // Move to the end of the character to select
                        IFC( spDispPointer->MoveToPointer(_pIme->_pDispInsertionPoint) );
                        IFC( GetEditor()->MoveCharacter(spDispPointer, RIGHT) );
                        IFC( spDispPointer->PositionMarkupPointer(_pIme->_pmpEndUncommitted) );

                        
                        // Select, and highlight, the Hangeul character
                        IFC( GetEditor()->CreateMarkupPointer( &spPointer ) );
                        IFC( _pIme->_pDispInsertionPoint->PositionMarkupPointer( spPointer ) );
                        IFC( _pIme->_pManager->Select(spPointer, pEditPosition, SELECTION_TYPE_Text ) );
                        /* HIGHLIGHT_TYPE_ImeHangul */
                        pDoc = GetEditor()->GetDoc4();
                        pDoc->createRenderStyle(NULL, &pIHTMLRenderStyle);
                        IFC( _pIme->AddHighlightSegment( 0, 1, pIHTMLRenderStyle) );

                        //
                        // The new KOREAN IMEs (2002) send IME_START_COMPOSITION
                        // after hanja mode is initiated. 
                        // 
                        _pIme->_fHanjaMode = TRUE;
                        IFC( _pIme->StartComposition() );
                        
                    }
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pIHTMLRenderStyle);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  CIme_Lev3::CIme_Lev3()
//
//  @mfunc
//      CIme_Lev3 Constructor.
//
//-----------------------------------------------------------------------------

CIme_Lev3::CIme_Lev3( CSelectionManager * pManager ) : CIme_Lev2( pManager )
{
    TraceTag((tagEdIME, "CIme_Lev3::CIme_Lev3"));
    
}

//+----------------------------------------------------------------------------
//  CIme_HangeulToHanja::CIme_HangeulToHanja()
//
//  @mfunc
//      CIme_HangeulToHanja Constructor.
//
//  @comm
//      Needed to save Hangeul character width for Block caret
//
//-----------------------------------------------------------------------------

CIme_HangeulToHanja::CIme_HangeulToHanja( CSelectionManager * pManager, LONG xWidth )
    : CIme_Lev3( pManager )
{
    // Set _fResultOccured to FALSE for the Korean HangeulToHanja conversion.
    // The conversion works by replacing the currently selected character.  If
    // we moved the insertion position, the selection would not be 'replaced'
    // when we got our final composition string.
    _fResultOccurred = FALSE;
    _xWidth = xWidth;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_HangeulToHanja::StartComposition()
//
//  @mfunc
//      Begin CIme_HangeulToHanja composition string processing.
//
//  @comm
//      Call Level3::StartComposition.  Then setup the Korean block
//      caret for the Hanguel character.
//
//  @rdesc
//      Need to adjust _ichStart and _cchCompStr to make the Hanguel character
//      "become" a composition character.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_HangeulToHanja::StartComposition( )
{
    HRESULT hr = S_OK;

    hr = CIme_Lev3::StartComposition();

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_HangeulToHanja::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle CIme_HangeulToHanja EVT_IME_COMPOSITION messages.
//
//  @comm
//      call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
//      then setup the format for the next Composition message.
//
//  @devnote
//      When the next Composition message comes in and that we are no longer in IME,
//      the new character will use the format as set here.
//
//
//
//-----------------------------------------------------------------------------

HRESULT
CIme_HangeulToHanja::CompositionString(
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    CIme_Lev3::CompositionString( lparam, pEvent );
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  HRESULT CIme_Protected::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle CIme_Protected EVT_IME_COMPOSITION messages.
//
//  @comm
//      Just throw away the restlt string since we are
//  in read-only or protected mode
//
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Protected::CompositionString (
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    HRESULT hr;

    if ( CleanupCompositionString(lparam) || HaveResultString(lparam) )
    {
        INT   cch;
        WCHAR achCompStr[256];

        cch = GetCompositionStringInfo( GCS_RESULTSTR,
                                        achCompStr, ARRAY_SIZE(achCompStr),
                                        NULL, 0, NULL, NULL);

        // we should have one or 0 characters to throw away

        Assert ( cch <= 1 );

        hr = S_OK;                                  // Don't want EVT_IME_CHARs.
    }
    else
    {
        // terminate composition to force a end composition message

        TerminateIMEComposition( TERMINATE_NORMAL, pEvent );
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT IgnoreIMEInput ( HWND hwnd, DWORD lParam  )
//
//  @func
//      Ignore IME character input
//  @comm
//      Called to handle EVT_KEYDOWN with VK_PROCESSKEY during
//      protected or read-only mode.
//
//  @devnote
//      This is to ignore the IME character.  By translating
//      message with result from ImmGetVirtualKey, we
//      will not receive START_COMPOSITION message.  However,
//      if the host has already called TranslateMessage, then,
//      we will let START_COMPOSITION message to come in and
//      let IME_PROTECTED class to do the work.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT IgnoreIMEInput(
    HWND    hwnd,               // @parm parent window handle
    DWORD   dwFlags)            // @parm lparam of EVT_KEYDOWN msg
{
    HRESULT     hr = S_FALSE;
    MSG         msg;

    Assert ( hwnd );
    if (VK_PROCESSKEY != (msg.wParam  = ImmGetVirtualKey( hwnd )))
    {
        // if ImmGetVirtualKey is still returning VK_PROCESSKEY
        // That means the host has already called TranslateMessage.
        // In such case, we will let START_COMPOSITION message
        // to come in and let IME_PROTECTED class to do the work
        msg.hwnd = hwnd;
        msg.message = EVT_KEYDOWN;
        msg.lParam  = dwFlags;
        if (::TranslateMessage ( &msg ))
            hr = S_OK;
    }

    return hr;
}

HRESULT
CIme::GetCaretTracker( CCaretTracker **ppCaretTracker )
{
    HRESULT hr;

    if (   _pManager->_pActiveTracker
        && _pManager->_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret)
    {
        *ppCaretTracker = DYNCAST(CCaretTracker, _pManager->_pActiveTracker);
        (*ppCaretTracker)->AddRef();
        
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr,S_FALSE);
}

//+----------------------------------------------------------------------------
//  Method:     OpenUndoUnit()
//
//  Purpose:    This method opens another parent undo unit for the IME.  The
//              undo unit will remain open until CloseUndoUnit is called.
//
//  Returns:    HRESULT indicating success
//-----------------------------------------------------------------------------
HRESULT
CIme::OpenUndoUnit(void)
{
    HRESULT hr = S_OK;

    SP_IOleUndoManager spUndoMgr;
    Assert( !_pBatchPUU );
    
     // Create our undo unit.  The batch undo unit is used to group all of the 
    // intermediate composition steps into one parent unit, that can be undone
    // at the same time.  This also allows for canceling the undo unit, in the
    // case that the user cancels the composition string.
     _pBatchPUU = new CBatchParentUndoUnit(_pManager->GetEditor(), IDS_EDUNDOTYPING);

    if( !_pBatchPUU )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagEdIME, "OpenUndoUnit %p", _pBatchPUU));
    IFC( _pManager->GetEditor()->GetUndoManager(&spUndoMgr));
    IFC(  spUndoMgr->Open(_pBatchPUU) );

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//  Method:     CloseUndoUnit()
//
//  Purpose:    This method closes the IME undo unit, using the parameter to
//              determine whether or not to throw away the undo unit.
//
//  Arguments:  fSave = INPUT - Should we save the undo unit?
//
//  Returns:    HRESULT indicating success
//-----------------------------------------------------------------------------
HRESULT
CIme::CloseUndoUnit(BOOL fSave)
{
    HRESULT hr = S_OK;
    SP_IOleUndoManager spUndoMgr;
    Assert( _pBatchPUU );
    TraceTag((tagEdIME, "CloseUndoUnit %p with %s", _pBatchPUU, fSave?"Save":"Discard"));

    IFC( _pManager->GetEditor()->GetUndoManager(&spUndoMgr));
    IFC( spUndoMgr->Close(_pBatchPUU, fSave) );
    ClearInterface(&_pBatchPUU);

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionManager::TerminateIMEComposition(
    DWORD dwMode,
    CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    

    if (IsIMEComposition())
    {
        IFC( EnsureEditContext());
    
        _pIme->TerminateIMEComposition( dwMode, pEvent );

        if ( ! pEvent )
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }            
    }
Cleanup:

    RRETURN1(hr,S_FALSE);
}

DWORD CSelectionManager::s_dwPlatformId = DWORD(-1);

void
CSelectionManager::CheckVersion()
{
#ifndef WINCE
    OSVERSIONINFOA ovi;
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));
#else //WINCE
    OSVERSIONINFO ovi;
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    Verify(GetVersionEx(&ovi));
#endif //WINCE

    s_dwPlatformId = ovi.dwPlatformId;
}



HRESULT
CIme::Init()
{
    HRESULT             hr;
    IHTMLDocument2      *pIDocument = _pManager->GetDoc();
    IMarkupServices     *pMarkupServices = NULL;
    IHTMLCaret          *pCaret = NULL;

    extern CODEPAGE     GetKeyboardCodePage();

    // Set the result occured  to true.  This flag is used to determine when the
    // insertion position (for the IME) needs to be moved back to the caret.  When
    // fResultOccurred is TRUE, the insertion position is repositioned.
    _fResultOccurred = TRUE;
    _fInsertInProgress = FALSE;

    if( _pManager->GetActiveTracker() && 
        _pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Caret )
    {
        CCaretTracker *pCaretTracker = DYNCAST( CCaretTracker, _pManager->GetActiveTracker() );
        Assert(pCaretTracker);

        IFC( pCaretTracker->TerminateTypingBatch() );
    }            

    // Open our initial undo unit
    IFC( OpenUndoUnit() );
    
    // Retrieve our required interfaces
    IFC( pIDocument->QueryInterface(IID_IMarkupServices, (void**)&pMarkupServices) );

    // The InsertionPoint is the point in the current markup where the
    // IME composition will be placed.  Whenever a result string is
    // retrieved, we update this insertion point
    IFC( GetDisplayServices()->CreateDisplayPointer( &_pDispInsertionPoint  ) );
    WHEN_DBG( _pManager->SetDebugName( _pDispInsertionPoint, strImeIP ) );

    // Uncommitted start is the beginning of the uncommitted composition
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &_pmpStartUncommitted ) );
    WHEN_DBG( _pManager->SetDebugName( _pmpStartUncommitted, strImeUncommittedStart ) );

    // Uncommitted end is the end of the uncommitted composition
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &_pmpEndUncommitted ) );
    WHEN_DBG( _pManager->SetDebugName( _pmpEndUncommitted, strImeUncommittedEnd ) );

    // Position our insertion pointer at the caret.
    IFC( GetDisplayServices()->GetCaret( &pCaret ) );
    IFC( pCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );
    IFC( _pDispInsertionPoint->SetPointerGravity( POINTER_GRAVITY_Left ) );
   
Cleanup:

    ReleaseInterface( pCaret );
    ReleaseInterface( pMarkupServices ) ;

    RRETURN(hr);
}

HRESULT
CIme::Deinit()
{
    HRESULT hr = S_OK;
    
    IFC( ClearHighlightSegments() );

    // Terminate the undo unit.  We want to throw away any unfinished compositions
    IFC( CloseUndoUnit(FALSE) );
    
    ClearInterface( &_pDispInsertionPoint );
    ClearInterface( &_pmpStartUncommitted );
    ClearInterface( &_pmpEndUncommitted );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionManager::HandleImeEvent(
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG_PTR lParam;
    LONG_PTR wParam;

    switch (pEvent->GetType() )
    {
        case EVT_IME_STARTCOMPOSITION:   // IME input is being kicked off
            hr = THR(StartCompositionGlue( FALSE, pEvent));
            break;

        case EVT_IME_COMPOSITION:        // State of user's input has changed   
            IFC( DYNCAST(CHTMLEditEvent,pEvent)->GetCompositionChange( & lParam ));
            hr = THR(CompositionStringGlue( (LPARAM) lParam, pEvent ));
            break;

        case EVT_IME_ENDCOMPOSITION:     // User has OK'd IME conversions
            hr = THR(EndCompositionGlue(pEvent ));
            break;

        case EVT_IME_NOTIFY:             // Candidate window state change info, etc.
            IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetNotifyCommand( & wParam));
            IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetNotifyData( & lParam ));
            hr = THR(NotifyGlue( (WPARAM) wParam, (LPARAM) lParam ));
            break;

        case EVT_IME_COMPOSITIONFULL:    // Level 2 comp string about to overflow.
            hr = THR(CompositionFullGlue());
            break;

        case EVT_IME_CHAR:               // 2 byte character, usually FE.
            if (IsIMEComposition())
            {
                hr = _pIme->IgnoreIMECharMsg() ? S_OK : S_FALSE;
            }
            else
            {
                hr = _fIgnoreImeCharMsg ? S_OK : S_FALSE;
            }
            break;

        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
            //
            // Sometimes (with old Korean IMEs), the IME will not send
            // a WM_IME_ENDCOMPOSITION message with a lbutton down.. so if
            // we intercept one of these, and we have an active IME
            // composition, then we definitely need to terminate the IME
            // composition
            //
            // Todo: -we do not support IME mouse operation at present
            //          time. Looking for it in next version [zhenbinx]
            //
            IGNORE_HR( TerminateIMEComposition(TERMINATE_NORMAL) );
            break;

        case EVT_KEYPRESS:
            //
            // Some IME such as Simplified Chinese QuanPin allow WM_CHAR
            // to be sent while in IME composition mode. This will cause
            // our undo mechanism to fail since IME Undo is based strickly
            // on the order of StartComposition-Composition-EndComposition.
            // So we need to terminate IME composition if we get a char
            //
            IGNORE_HR( TerminateIMEComposition(TERMINATE_NORMAL) );
            break;
            
        case EVT_KEYDOWN:
            if (IsIMEComposition())
            {
                //
                // During IME composition, there are some key
                // events we should not handle. Also, there are
                // other key events we need to handle by 
                // terminating the IME composition first. 
                //
                //
                LONG keyCode ;
                IGNORE_HR( pEvent->GetKeyCode(&keyCode ) );    
                switch (keyCode)
                {
                    case VK_BACK:
                    case VK_INSERT:
                    case VK_HOME:
                    case VK_END:
                    case VK_PRIOR:
                    case VK_NEXT:
                    case VK_DELETE:
                    case VK_RETURN:
                        //
                        // Instead of tear off IME composition
                        // we disable these keystrokes in IME
                        // composition mode
                        //
                        hr = S_OK;
                        break;
                        
                    case VK_UP:
                    case VK_DOWN:
                    case VK_LEFT:
                    case VK_RIGHT:
                    default:
                        break;
                }
            }
            break;
            
        default:
            break;

    }
Cleanup:

    RRETURN1(hr,S_FALSE);
}

HRESULT
CIme::SetCaretVisible( IHTMLDocument2* pIDoc, BOOL fVisible )
{
    HRESULT hr = S_OK ;
    SP_IHTMLCaret spc;

    IFC( GetDisplayServices()->GetCaret( &spc ));

    if( fVisible )
        hr = spc->Show( FALSE );
    else
        hr = spc->Hide();

Cleanup:
    RRETURN( hr );
}

HRESULT
CIme::ReplaceRange(
    TCHAR * pch,
    LONG cch,
    BOOL fShowCaret /* = TRUE */,
    LONG ichCaret   /* = -1 */,
    BOOL fMoveIP    /* = FALSE */,
    BOOL fOverwrite /* = FALSE */ )
{
    IMarkupServices * pTreeServices = NULL;
    IHTMLCaret * pCaret = NULL;
    BOOL fPositioned;
    HRESULT hr = S_FALSE;
    CEdUndoHelper undoUnit(_pManager->GetEditor());
    CCaretTracker * pCaretTracker = NULL;
    
    if (!OK(GetCaretTracker( &pCaretTracker ) ))
        goto Cleanup;

    if (! pCaretTracker)
        goto Cleanup;

    IFC( ClearHighlightSegments() );
    
    hr = THR( _pManager->GetDoc()->QueryInterface( IID_IMarkupServices, (void**) & pTreeServices));
    if (hr)
        goto Cleanup;


    // Reposition the insertion pointers, if necessary
    if( HasResultOccurred() )
    {
        IFC( UpdateInsertionPoint() );
    }

    // We have had one more replacement
    _fResultOccurred = FALSE;

    //
    // First nuke the old range, if we have one.
    //

    hr = THR( _pmpStartUncommitted->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;

    //
    // 
    //
    if (fPositioned || cch)
    {
        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );
    }

    if (fPositioned)
    {
        //
        // Memorize the formatting just before we nuke the old range.
        //

        CSpringLoader * psl = GetSpringLoader();
        if (psl)
        {
            IGNORE_HR(psl->SpringLoad(_pmpStartUncommitted));
        }

        //
        // Now remove.
        //

        hr = THR( pTreeServices->Remove( _pmpStartUncommitted, _pmpEndUncommitted ) );
        if (hr)
            goto Cleanup;
    }

    //
    // Now add the new text
    //

    hr = THR( GetDisplayServices()->GetCaret( &pCaret ));
    if (hr)
        goto Cleanup;

    if (cch)
    {
        // This places the caret *before* the IP

        IFC( pCaret->MoveCaretToPointer( _pDispInsertionPoint, TRUE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE));

        IFC( AdjustUncommittedRangeAroundInsertionPoint() );
        
        // In goes the text.  Call through CCaretTracker
        _fInsertInProgress = TRUE;
        IFC( pCaretTracker->InsertText( pch, cch, pCaret, fOverwrite ) );
        _fInsertInProgress = FALSE;

        IFC( ClingUncommittedRangeToText() );

        if (fMoveIP)
        {
            IFC( pCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );

            IFC( AdjustUncommittedRangeAroundInsertionPoint() );

            pCaretTracker->SetCaretShouldBeVisible( TRUE );
        }
        else if (ichCaret != -1)
        {
            AssertSz( ichCaret >= 0 && ichCaret <= cch,
                      "IME caret should be within the text.");
            
            if (ichCaret < cch)
            {
                CEditPointer epForCaret( _pManager->GetEditor()); 
                DWORD dwSearch = BREAK_CONDITION_Text;
                DWORD dwFound;
                SP_IDisplayPointer spDispForCaret;

                IFC( _pDispInsertionPoint->PositionMarkupPointer(epForCaret) );

                while (ichCaret--)
                {
                    hr = THR( epForCaret.Scan(RIGHT, dwSearch, &dwFound) );
                    if (hr)
                        goto Cleanup;

                    if (!epForCaret.CheckFlag(dwFound, dwSearch))
                        break;
                }

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispForCaret) );
                IFC( spDispForCaret->MoveToMarkupPointer(epForCaret, _pDispInsertionPoint) );

                IFC( pCaret->MoveCaretToPointer( spDispForCaret, TRUE, CARET_DIRECTION_INDETERMINATE ));

                // Todo: (cthrash) Ideally, we want to ensure the whole of the
                // currently converted range to show.  This would require some
                // trickly logic to keep the display from shifting annoyingly.
                // So for now, we only ensure the beginning of it is showing.
                
                IFC( spDispForCaret->ScrollIntoView() );
            }
            else
            {
                SP_IDisplayPointer spDispEndUncommitted;
                
                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndUncommitted) );
                IFC( spDispEndUncommitted->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( spDispEndUncommitted->MoveToMarkupPointer(_pmpEndUncommitted, NULL) );
                IFC( spDispEndUncommitted->ScrollIntoView() );
            }

            pCaretTracker->SetCaretShouldBeVisible( fShowCaret );
        }
    }
    else
    {
        SP_IDisplayPointer spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( pCaret->MoveDisplayPointerToCaret(spDispCaret) );
        IFC( spDispCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        IFC( pCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
    }

Cleanup:

    if (pCaretTracker)
        pCaretTracker->Release();

    ReleaseInterface( pCaret );
    ReleaseInterface( pTreeServices );

    RRETURN1(hr, S_FALSE);
}

HRESULT
CIme::AdjustUncommittedRangeAroundInsertionPoint()
{
    HRESULT hr;
    
    // This places the pointer *before* the IP

    IFC( _pDispInsertionPoint->PositionMarkupPointer(_pmpStartUncommitted) );

    IFC( _pmpStartUncommitted->SetGravity( POINTER_GRAVITY_Left) );

    // This places the pointer *after* the IP (and therefore *after* the caret.)

    IFC( _pDispInsertionPoint->PositionMarkupPointer(_pmpEndUncommitted) );

    IFC( _pmpEndUncommitted->SetGravity( POINTER_GRAVITY_Right) );

Cleanup:

    RRETURN(hr);
}

HRESULT
CIme::ClingUncommittedRangeToText()
{
    HRESULT         hr;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD           dwFound;
    CEditPointer epTest( _pManager->GetEditor() ); 
    

    // Cling to text on the left
    
    IFR( epTest->MoveToPointer(_pmpStartUncommitted) );
    IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) )
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
    {
        IFR( epTest.Scan(LEFT, dwSearch, &dwFound) ); // restore position
        IFR( _pmpStartUncommitted->MoveToPointer(epTest) );
    }

    // Cling to text on the right
    IFR( epTest->MoveToPointer(_pmpEndUncommitted) );
    IFR( epTest.Scan(LEFT, dwSearch, &dwFound) );
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
    {
        IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) ); // restore position
        IFR( _pmpEndUncommitted->MoveToPointer(epTest) );
    }

    return S_OK;    
}


#endif /*}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\htmled.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       htmled.cxx
//
//  Contents:   Implementation of IHTMLEditor interface inisde of mshtmled.dll
//
//  Classes:    CHTMLEditor
//
//  History:    07-21-98 - johnbed - created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_PASTECMD_HXX_
#define _X_PASTECMD_HXX_
#include "pastecmd.hxx"
#endif

#ifndef _X_COPYCMD_HXX_
#define _X_COPYCMD_HXX_
#include "copycmd.hxx"
#endif

#ifndef _X_CUTCMD_HXX_
#define _X_CUTCMD_HXX_
#include "cutcmd.hxx"
#endif

#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_SELCMD_HXX_
#define _X_SELCMD_HXX_
#include "selcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef X_FORMCMD_HXX_
#define X_FORMCMD_HXX_
#include "formcmd.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_DIMM_HXX_
#define X_DIMM_HXX_
#include "dimm.h"
#endif

#ifndef _X_INPUTTXT_H_ // For IHTMLInputElement
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_IMEDESGN_HXX_
#define _X_IMEDESGN_HXX_
#include "imedesgn.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef _X_RTFTOHTM_H_
#define _X_RTFTOHTM_H_
#include "rtftohtm.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_FRMSITE_H_
#define _X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#define SID_SHTMLEditHost     IID_IHTMLEditHost

DeclareTag(tagIE50Paste, "Edit", "IE50 compatible paste")

#if DBG == 1
#define HTMLED_PTR( name ) CEditPointer name( this, NULL, _T(#name) )
#else
#define HTMLED_PTR( name ) CEditPointer name( this, NULL )
#endif

using namespace EdUtil;

class CSpringLoader;

MtDefine(CHTMLEditor, Utilities, "HTML Editor")
MtDefine(CHTMLEditor_pComposeSettings, CHTMLEditor, "CHTMLEditor::_pComposeSettings")
MtDefine(CHTMLEditor_aryDesigners_pv, CHTMLEditor, "CHTMLEditor::_aryDesigners::_pv");
MtDefine(CHTMLEditor_aryActiveCmdTargets_pv, CHTMLEditor, "CHTMLEditor::_aryEditInfo::_pv");
MtDefine(CHTMLEditor_aryCmdTargetStack_pv, CHTMLEditor, "CHTMLEditor::_aryCmdTargetStack::_pv");

DeclareTag(tagEditingTrackExecFailures, "Edit", "Track exec failures")
DeclareTag(tagEditingExecRouting, "Edit", "Track Editing Exec Routing")
DeclareTag(tagEditingKeyProcessing, "Edit", "Track Key Event for Editing")
DeclareTag(tagEditingInterface, "Edit", "Track Editing Inteface calls")

extern "C" const IID IID_IHTMLEditorViewManager;
extern "C" const IID SID_SHTMLEditorViewManager;
extern BOOL g_fInVid;

#ifndef NO_IME
extern CRITICAL_SECTION g_csActiveIMM ; 
extern int g_cRefActiveIMM ;  
extern IActiveIMMApp * g_pActiveIMM;
#endif

extern BOOL g_fInPhotoSuiteIII;
extern "C" const IID IID_IHTMLDialog;

extern HRESULT
ConvertPointerToInternal(CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal);

extern HRESULT
OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi );

HRESULT
CHTMLEditor::OldDispCompare(IDisplayPointer* pDisp1, IDisplayPointer* pDisp2, int * pi )
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pi);

    IFC( pDisp1->IsEqualTo(pDisp2, &fResult) );
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }
    
    IFC( pDisp1->IsLeftOf(pDisp2, &fResult)  );

    *pi = fResult ? -1 : 1;

Cleanup:
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor Constructor, Destructor and Initialization
//////////////////////////////////////////////////////////////////////////////////

CHTMLEditor::CHTMLEditor() : _aryDesigners(Mt(CHTMLEditor_aryDesigners_pv)), 
                            _aryActiveCmdTargets(Mt(CHTMLEditor_aryActiveCmdTargets_pv)),
                            _aryCmdTargetStack(Mt(CHTMLEditor_aryCmdTargetStack_pv))
{
    Assert( _pDoc == NULL );
    Assert( _pUnkDoc == NULL );
    Assert( _pUnkContainer == NULL );
    Assert( _pMarkupServices == NULL );
    Assert( _pDisplayServices == NULL );
    Assert( _pComposeSettings == NULL);
    Assert( _pSelMan == NULL );
    Assert( _fGotActiveIMM == FALSE ) ;
    Assert( _pStringCache == NULL );    
    Assert( _pISelectionServices == NULL );
    Assert( _pIHTMLEditHost == NULL );
    Assert( _pIHTMLEditHost2 == NULL );
    Assert( _pActiveCommandTarget == NULL );
    Assert( _pDispOnDblClkTimer == NULL );
    Assert( _pCaptureHandler == NULL );
    Assert( _dwEventCacheCounter == NULL );
}

CHTMLEditor::~CHTMLEditor()
{   
    Assert( _aryCmdTargetStack.Size() == 0 );
    
    DeleteCommandTable();

    //  We need to make sure our tracker is torn down first before we destroy our editor
    if (_pSelMan && _pSelMan->GetActiveTracker())
    {
        IGNORE_HR( _pSelMan->GetActiveTracker()->BecomeDormant(NULL, TRACKER_TYPE_None, NULL) );
    }
    if (_pSelMan)
    {
        _pSelMan->Passivate(TRUE /* fEditorReleased */);
        ReleaseInterface( _pSelMan );
    }

    delete _pComposeSettings;
    delete _pStringCache;
    delete _pAutoUrlDetector;
    delete _pUndoManagerHelper;

    _aryDesigners.ReleaseAll();

    ReleaseInterface( _pDoc );
    _pDoc = NULL;

    ReleaseInterface( _pTopDoc );
    _pTopDoc = NULL;

    ReleaseInterface( _pMarkupServices );
    _pMarkupServices = NULL;
 
    ClearInterface( &_pDisplayServices );

    ClearInterface( & _pISelectionServices );
    ClearInterface( & _pICaptureElement);
#if DBG == 1
    ReleaseInterface( _pEditDebugServices );
    _pEditDebugServices = NULL;
#endif
    if (g_hEditLibInstance)
    {
        FreeLibrary(g_hEditLibInstance);
        g_hEditLibInstance = NULL;
    }

#ifndef NO_IME
    if (_fGotActiveIMM)
    {
        EnterCriticalSection(&g_csActiveIMM);
        Assert(g_cRefActiveIMM > 0);
        Assert(g_pActiveIMM != NULL);
        if (--g_cRefActiveIMM == 0)
            ClearInterface(&g_pActiveIMM);

        LeaveCriticalSection(&g_csActiveIMM);
    }
#endif

    ReleaseInterface(_pIHTMLEditHost);
    ReleaseInterface(_pIHTMLEditHost2);
    ReleaseInterface(_pHighlightServices);

    IGNORE_HR( ClearCommandTargets() );

    if ( _pDispOnDblClkTimer )
    {
        _pDispOnDblClkTimer->SetEditor(NULL);
        ReleaseInterface( _pDispOnDblClkTimer );
    }
    if (_pCaptureHandler )
    {    
        _pCaptureHandler->SetEditor(NULL);
        ReleaseInterface( _pCaptureHandler );
    }
    
    Assert( ! _pICaptureElement ); // must get released by trackers/selman

}

//+========================================================================
//
// Method: Initialize
//
// Synopsis: Set the Document's interfaces for this instance of HTMLEditor
//           Called from Formkrnl when it CoCreates us.
//
//           We are actually passed a COmDocument, which uses weak ref's for
//           the interfaces we are QIing for. If we need to add an interface
//           in the future, make sure you add it to COmDocument (omdoc.cxx)
//           QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CHTMLEditor::Initialize( IUnknown * pUnkDoc, IUnknown * pUnkContainer )
{
    HRESULT             hr;
    SP_IServiceProvider spSP;
    SP_IHTMLWindow2 spWindow2;
    SP_IHTMLScreen  spScreen;
    SP_IHTMLScreen2  spScreen2;

    IServiceProvider    *pDocServiceProvider = NULL;
    CIMEManager         *pIMEMgr = NULL;
    SP_IMarkupContainer spContainer;
    IUnknown *          pIHTMLEditorViewManager = NULL ;

    Assert( pUnkDoc );
    Assert( pUnkContainer );
    _pUnkDoc = pUnkDoc;
    _pUnkContainer = pUnkContainer;

    IFC( _pUnkDoc->QueryInterface( IID_IHTMLDocument2 , (void **) &_pTopDoc ));
    IFC( _pUnkDoc->QueryInterface( IID_IHTMLDocument2 , (void **) &_pDoc ));
    IFC( _pUnkDoc->QueryInterface( IID_IMarkupServices2 , (void **) &_pMarkupServices ));
    IFC( _pUnkDoc->QueryInterface( IID_IDisplayServices, (void **) &_pDisplayServices ));
    IFC( _pUnkDoc->QueryInterface( IID_IHighlightRenderingServices, (void **) &_pHighlightServices ));
    IFC( pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainer ) );

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC( spWindow2->get_screen(&spScreen) );
    IFC( spScreen->QueryInterface(IID_IHTMLScreen2, (LPVOID *)&spScreen2) );
    IFC( spScreen2->get_logicalXDPI(&_llogicalXDPI) );
    IFC( spScreen2->get_logicalYDPI(&_llogicalYDPI) );
    IFC( spScreen2->get_deviceXDPI(&_ldeviceXDPI) );
    IFC( spScreen2->get_deviceYDPI(&_ldeviceYDPI) );

#if DBG == 1
    //
    // We don't fail here. It can happen that a Non-Debug Mshtml calls into a debug mshtmled.
    // In which case failure is bad. Instead - every debug method - just checks we have a non-null
    // _pEditDebugServices.
    //
    IGNORE_HR( _pUnkDoc->QueryInterface( IID_IEditDebugServices, ( void**) & _pEditDebugServices));
#endif

    IFC( InitCommandTable() );

    // Set css editing level
    _dwCssEditingLevel = 1;

    // Set the active command target based on our initial container
    IFC( SetActiveCommandTarget( spContainer ) );
            
    // Create the selection manager
    _pSelMan = new CSelectionManager( this );
    if( _pSelMan == NULL )
        goto Error;

    IFC( _pSelMan->Initialize());

    _pStringCache = new CStringCache(IDS_CACHE_BEGIN, IDS_CACHE_END);
    if( _pStringCache == NULL )
        goto Error;

    _pAutoUrlDetector = new CAutoUrlDetector(this);
    if( _pAutoUrlDetector == NULL )
        goto Error;

    _pUndoManagerHelper = new CUndoManagerHelper(this);
    if( _pUndoManagerHelper == NULL )
        goto Error;
        

    // Need to delay loading of the string table because we can't LoadLibrary in process attach.
    // This is not delayed to the command level because checking if the table is already loaded
    // is expensive.
    CGetBlockFmtCommand::LoadStringTable(g_hInstance);    

#ifndef NO_IME
    SetupActiveIMM();  
#endif

    //
    // Set the Edit Host - if there is one.
    //

    IFC (_pUnkDoc->QueryInterface(IID_IServiceProvider, (void**)&pDocServiceProvider));
    IGNORE_HR( pDocServiceProvider->QueryService( SID_SHTMLEditHost, IID_IHTMLEditHost, ( void** ) &_pIHTMLEditHost ));
    IGNORE_HR( pDocServiceProvider->QueryService( SID_SHTMLEditHost, IID_IHTMLEditHost2, ( void** ) &_pIHTMLEditHost2 ));

    //
    // Get the undo manager
    //

    // Add a designer
    pIMEMgr = new CIMEManager;
    if( pIMEMgr == NULL )
        goto Error;

    IFC( pIMEMgr->Init( this ) );
    IFC( AddDesigner( (IHTMLEditDesigner *)pIMEMgr ) );

    // Use the new UI paste by default for now.  If we run into problems, we'll need to 
    // change the default.
    //
    // TODO: need a mechanism for the host to set paste mode [ashrafm]
    _fIE50CompatUIPaste = FALSE;

#ifndef NO_IME
    //
    // IME reconversion if a feature not supported in IE 50 era
    //
    IFC( SetupIMEReconversion() );
#endif

    //
    // Create our IDispatch handlers
    //
    _pDispOnDblClkTimer = new CTimeoutHandler(this);
    if( !_pDispOnDblClkTimer )
        goto Error;

    _pCaptureHandler = new CCaptureHandler(this);
    if( !_pCaptureHandler )
        goto Error;

    InitAppCompatFlags();

    if (OK(THR_NOTRACE( pDocServiceProvider->QueryService(
            SID_SHTMLEditorViewManager,
            IID_IHTMLEditorViewManager,
            (void**) &pIHTMLEditorViewManager))))
    {
        g_fInVid = TRUE;
    }

Cleanup:
    AssertSz( hr == S_OK , "Editor failed to initialize");
    ReleaseInterface( pIMEMgr );    
    ReleaseInterface( pIHTMLEditorViewManager ); 
    ReleaseInterface( pDocServiceProvider );
    return hr;

Error:
    return( E_OUTOFMEMORY );
 
}


//----------------------------------------------------------
//
//  Initialize the CommandTable
//
//
//     *** NOTE: Insert frequently used commands first ***
//     This will keep them closer to the top of the tree and make lookups 
//     faster
//   
//==========================================================

// TODO (johnbed) if memory/perf overhead of having this per instance is too great,
//                  move this to a static table and call in process attach. All static
//                  tables should be moved here since these are globally accessable.
HRESULT
CHTMLEditor::InitCommandTable()
{
    CCommand * pCmd = NULL;
    COutdentCommand * pOutdentCmd = NULL;

    _pCommandTable = new CCommandTable(60);
    if( _pCommandTable == NULL )
        goto Error;

    //+----------------------------------------------------
    // CHAR FORMAT COMMANDS 
    //+----------------------------------------------------

    pCmd = new CCharCommand( IDM_BOLD, TAGID_STRONG, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CCharCommand( IDM_ITALIC, TAGID_EM, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_STRIKETHROUGH, TAGID_STRIKE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_SUBSCRIPT, TAGID_SUB, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new  CCharCommand( IDM_SUPERSCRIPT, TAGID_SUP, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_UNDERLINE, TAGID_U, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CFontSizeCommand( IDM_FONTSIZE, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CFontNameCommand( IDM_FONTNAME, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CForeColorCommand( IDM_FORECOLOR, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CBackColorCommand( IDM_BACKCOLOR, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAnchorCommand( IDM_HYPERLINK, TAGID_A, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAnchorCommand( IDM_BOOKMARK, TAGID_A, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CRemoveFormatCommand( IDM_REMOVEFORMAT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CUnlinkCommand( IDM_UNLINK, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CUnlinkCommand( IDM_UNBOOKMARK, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // BLOCK FORMAT COMMANDS 
    //+----------------------------------------------------

    pCmd = new  CIndentCommand( IDM_INDENT, TAGID_BLOCKQUOTE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pOutdentCmd = new  COutdentCommand( IDM_OUTDENT, TAGID_BLOCKQUOTE , this );
    if( pOutdentCmd == NULL )
        goto Error;
    _pCommandTable->Add( (CCommand*) pOutdentCmd );

    pOutdentCmd = new  COutdentCommand( IDM_UI_OUTDENT, TAGID_BLOCKQUOTE , this );
    if( pOutdentCmd == NULL )
        goto Error;
    _pCommandTable->Add( (CCommand*) pOutdentCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYCENTER, TAGID_CENTER, _T("center"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYLEFT, TAGID_NULL, _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYGENERAL, TAGID_NULL, _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYRIGHT, TAGID_NULL, _T("right"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYNONE, TAGID_NULL, _T(""), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYFULL, TAGID_NULL, _T("justify"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CGetBlockFmtCommand( IDM_GETBLOCKFMTS, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CLocalizeEditorCommand( IDM_LOCALIZEEDITOR, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CListCommand( IDM_ORDERLIST, TAGID_OL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CListCommand( IDM_UNORDERLIST, TAGID_UL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockFmtCommand( IDM_BLOCKFMT , TAGID_NULL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockDirCommand( IDM_BLOCKDIRLTR, TAGID_NULL, _T("ltr"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockDirCommand( IDM_BLOCKDIRRTL, TAGID_NULL, _T("rtl"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // DIALOG COMMANDS 
    //+----------------------------------------------------

    pCmd = new CDialogCommand( UINT(~IDM_HYPERLINK) , this ); 
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDialogCommand( UINT(~IDM_IMAGE) , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDialogCommand( UINT(~IDM_FONT) , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // INSERT COMMANDS 
    //+----------------------------------------------------

    pCmd = new CInsertCommand( IDM_BUTTON, TAGID_BUTTON, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_TEXTBOX, TAGID_INPUT, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_TEXTAREA, TAGID_TEXTAREA, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_MARQUEE, TAGID_MARQUEE, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_HORIZONTALLINE, TAGID_HR, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_IFRAME, TAGID_IFRAME, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSFIELDSET, TAGID_FIELDSET, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertParagraphCommand( IDM_PARAGRAPH, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_IMAGE, TAGID_IMG, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_DROPDOWNBOX, TAGID_SELECT, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CInsertCommand( IDM_LISTBOX, TAGID_SELECT,  _T("MULTIPLE"), _T("TRUE") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_1D, TAGID_DIV, _T("POSITION:RELATIVE"), NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_CHECKBOX, TAGID_INPUT, _T("type"), _T("checkbox") , this );   
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_RADIOBUTTON, TAGID_INPUT, _T("type"), _T("radio") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTBUTTON, TAGID_INPUT, _T("type"), _T("button") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTRESET, TAGID_INPUT, _T("type"), _T("reset") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTSUBMIT, TAGID_INPUT, _T("type"), _T("submit") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTUPLOAD, TAGID_INPUT, _T("type"), _T("file") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTHIDDEN, TAGID_INPUT, _T("type"), _T("hidden") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTPASSWORD, TAGID_INPUT, _T("type"), _T("password") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTIMAGE, TAGID_INPUT, _T("type"), _T("image") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSERTSPAN, TAGID_SPAN, _T("class"), _T("") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKLEFT, TAGID_BR, _T("clear"), _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKRIGHT, TAGID_BR, _T("clear"), _T("right"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKBOTH, TAGID_BR, _T("clear"), _T("all"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKNORMAL, TAGID_BR, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_NONBREAK, TAGID_NULL, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    //+----------------------------------------------------
    // INSERTOBJECT COMMAND
    //+----------------------------------------------------
    
    pCmd = new CInsertObjectCommand( IDM_INSERTOBJECT, TAGID_OBJECT, _T( "CLASSID" ), NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // SELECTION COMMANDS 
    //+----------------------------------------------------

    pCmd = new CSelectAllCommand( IDM_SELECTALL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CClearSelectionCommand( IDM_CLEARSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CKeepSelectionCommand( IDM_KEEPSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // DELETE COMMAND
    //+----------------------------------------------------

    pCmd = new CDeleteCommand( IDM_DELETE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDeleteCommand( IDM_DELETEWORD , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // CUT COMMAND
    //+----------------------------------------------------

    pCmd = new CCutCommand( IDM_CUT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // COPY COMMAND
    //+----------------------------------------------------

    pCmd = new CCopyCommand( IDM_COPY , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // PASTE COMMAND
    //+----------------------------------------------------
    
    pCmd = new CPasteCommand( IDM_PASTE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // FORM EDITING COMMANDS 
    //+----------------------------------------------------

    pCmd = new CMultipleSelectionCommand( IDM_MULTIPLESELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new C2DPositionModeCommand( IDM_2D_POSITION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new C1DElementCommand( IDM_1D_ELEMENT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    pCmd = new C2DElementCommand( IDM_2D_ELEMENT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    pCmd = new CAbsolutePositionCommand( IDM_ABSOLUTE_POSITION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CLiveResizeCommand( IDM_LIVERESIZE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAtomicSelectionCommand( IDM_ATOMICSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // TRISTATE COMMANDS
    //+----------------------------------------------------

    pCmd = new CTriStateCommand( IDM_TRISTATEBOLD, TAGID_STRONG, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CTriStateCommand( IDM_TRISTATEITALIC, TAGID_EM, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CTriStateCommand( IDM_TRISTATEUNDERLINE, TAGID_U, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // MISCELLANEOUS OTHER COMMANDS 
    //+----------------------------------------------------

    pCmd = new CAutoDetectCommand( IDM_AUTODETECT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new COverwriteCommand( IDM_OVERWRITE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CComposeSettingsCommand( IDM_COMPOSESETTINGS, this );
    if (pCmd == NULL)
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAutoUrlDetectModeCommand( IDM_AUTOURLDETECT_MODE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDisalbeEditFocusHandlesCommand( IDM_DISABLE_EDITFOCUS_UI , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CIE50PasteModeCommand( IDM_IE50_PASTE_MODE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CCssEditingLevelCommand( IDM_CSSEDITING_LEVEL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CIMEReconversionCommand( IDM_IME_ENABLE_RECONVERSION, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    return( S_OK );
    
Error:
    return( E_OUTOFMEMORY );
}


HRESULT
CHTMLEditor::DeleteCommandTable()
{
    delete _pCommandTable;
    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor IHTMLEditor Implementation
//////////////////////////////////////////////////////////////////////////////////


HRESULT
CHTMLEditor::PreHandleEvent(DISPID inEvtDispId , 
                            IHTMLEventObj* pObj )
{
    HRESULT hr;
    
    if(!_pSelMan)
        return E_FAIL;

    CHTMLEditEvent evt( this );

    IFC( _pSelMan->EnsureEditContext());

    IFC( evt.Init( pObj, inEvtDispId ));
   
    //
    // Don't pass designers our internal double click event.
    // This event is really only intended to allow us
    // to maintain compat with previous versions of IE, and we
    // shouldn't tell the designers about it
    //
    if( evt.GetType() != EVT_INTDBLCLK )
    {
        hr = THR(DesignerPreHandleEvent( inEvtDispId, pObj ));
    }
    else
    {
        hr = S_FALSE;
    }
    
    
    if( hr == S_FALSE )
    {
        if (    
                ( evt.GetType() >= EVT_LMOUSEDOWN
                  && evt.GetType() <= EVT_MOUSEMOVE
                  && !_pSelMan->IsInCapture()
                  && IsEventInSelection( & evt ) == S_OK
                  && evt.IsInScrollbar() == S_FALSE  // ignore mouse events on scrollbars.
                )
             || 
                (((  evt.GetType() >= EVT_KEYDOWN
                 &&  evt.GetType() <= EVT_KEYPRESS )
#ifdef UNIX // Handle MMB paste action
                 || evt.GetType() == EVT_MMOUSEDOWN
#endif                 
                 )
                 && ( ( _pSelMan->GetEditableElement()                          && 
                        IsEditable(_pSelMan->GetEditableElement() ) == S_OK )   ||                
                        IsCurrentElementEditable() == S_OK )
                )
            ||  ( _pSelMan->ShouldHandleEventInPre( & evt ) == S_OK ) 
           )
        {                     
            if(evt.GetType() == EVT_KEYPRESS && !CanHandleEvent(pObj))
            {
                hr = E_ACCESSDENIED;
            }
            else
            {
                hr = THR ( _pSelMan->HandleEvent( & evt ));             
            }
        }
        else
            hr = S_FALSE;
    }

    if ( hr == S_OK )
    {
        IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pObj ));
    }
    
Cleanup:
    return( hr );
    
}

BOOL
CHTMLEditor::CanHandleEvent(IHTMLEventObj* pIObj)
{
    HRESULT                 hr;
    SP_IHTMLElement         spCurElement;
    SP_IHTMLElement         spSrcElement;
    SP_IHTMLInputElement    spCurInputElement;
    IObjectIdentity       * pIdent = NULL;

    BSTR bstrType		= NULL;
    BOOL fInputFileType = FALSE;

    IFC( pIObj->get_srcElement(&spSrcElement) );
    if (!spSrcElement.IsNull())
    {
        IFC( GetDoc()->get_activeElement( & spCurElement ));
        if (!spCurElement.IsNull())
        {
            IFC( spCurElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent)); 
            IFC( spCurElement->QueryInterface( IID_IHTMLInputElement, (void**) & spCurInputElement ));
            IFC( spCurInputElement->get_type(&bstrType));
            if (!StrCmpIC( bstrType, TEXT("file")) && pIdent->IsEqualObject(spSrcElement) != S_OK)
            {
                fInputFileType = TRUE;
            }
        }
    }        

Cleanup:
    SysFreeString( bstrType );
    ReleaseInterface( pIdent );
    return ((hr == E_OUTOFMEMORY) || fInputFileType) ? FALSE : TRUE;
}

HRESULT
CHTMLEditor::IsCurrentElementEditable()
{
    HRESULT hr;
    SP_IHTMLElement spCurElement;
    SP_IHTMLElement3 spCurElement3;
    VARIANT_BOOL vbEditable;
    
    IFC( GetDoc()->get_activeElement( & spCurElement ));
    if ( ! spCurElement.IsNull() )
    {
        IFC( spCurElement->QueryInterface( IID_IHTMLElement3, (void**) & spCurElement3 ));
        IFC( spCurElement3->get_isContentEditable( & vbEditable ));
        hr = ( vbEditable == VB_TRUE ) ? S_OK : S_FALSE;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr, S_FALSE);
}

HRESULT
CHTMLEditor::PostHandleEvent(DISPID inEvtDispId , 
                             IHTMLEventObj* pIEventObj )
{
    HRESULT         hr;
    CHTMLEditEvent  evt( this );
   
    if(!_pSelMan)
        return E_FAIL;
    
    IFC( evt.Init( pIEventObj, inEvtDispId ));
    IFC( _pSelMan->EnsureEditContext());

    //
    // Don't pass designers our internal double click event.
    // This event is really only intended to allow us
    // to maintain compat with previous versions of IE, and we
    // shouldn't tell the designers about it
    //    
    if( evt.GetType() != EVT_INTDBLCLK )
    {
        hr = THR(DesignerPostHandleEvent( inEvtDispId, pIEventObj ));
    }
    else
    {
        hr = S_FALSE;
    }
    
    if( hr == S_FALSE )
    {
        IFC( _pSelMan->HandleEvent( & evt ));             
    }

    IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pIEventObj));
    
Cleanup:
    return( hr );

}

HRESULT
CHTMLEditor::TranslateAccelerator(DISPID inEvtDispId, 
                                  IHTMLEventObj* pIEventObj )    
{
    HRESULT hr;
    
    if(!_pSelMan)
        return E_FAIL;

    IFC( _pSelMan->EnsureEditContext());

    hr = THR(DesignerTranslateAccelerator( inEvtDispId, pIEventObj ));
    
    if( hr == S_FALSE )
    {
        CHTMLEditEvent evt( this );
        IFC( evt.Init( pIEventObj, inEvtDispId ));
        //  Editor requires VK_TAB in <PRE> (61302), VK_BACK(58719, 58774),
        //  and the navigation keys 
        //
        //  Need to handle Ctrl-Shift (87715)  (zhenbinx)
        //
        if (  !evt.IsAltKeyDown() && (evt.GetType() == EVT_KEYDOWN || evt.GetType() == EVT_KEYUP) )
        {
            LONG keyCode;
            IGNORE_HR( evt.GetKeyCode( & keyCode ));

#if DBG==1
            if (evt.GetType() == EVT_KEYUP) 
            { 
                if ( 
                    (VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode) ||
                    (VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode)
                   ) 
                {
                    TraceTag((tagEditingKeyProcessing,"EVT_KEYUP - %x", keyCode)); 
                }
                
            } 
#endif
        
            if (  keyCode == VK_BACK
                 || (keyCode >= VK_PRIOR && keyCode <= VK_DOWN)
                 || (keyCode == VK_TAB && _pSelMan->CaretInPre())
                 || (VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode)
                 || ((VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode) && evt.GetType() == EVT_KEYUP)
               )
            {                       
                hr = THR ( _pSelMan->HandleEvent( & evt ));             
            }
            else
                hr = S_FALSE;
        }
        else
            hr = S_FALSE;
    }

    if ( hr == S_OK )
    {
        IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pIEventObj ));
    }
    
Cleanup:
    return( hr );

}



HRESULT
CHTMLEditor::GetSelectionType(SELECTION_TYPE *peSelectionType )
{
    Assert( peSelectionType && _pSelMan );
    if ( ! _pSelMan )
    {
        return( E_FAIL) ;
    }
    
    RRETURN( _pSelMan->GetSelectionType( peSelectionType ) );
}


        

HRESULT 
CHTMLEditor::RemoveContainer(IUnknown *pUnknown)
{
    HRESULT  hr  = S_OK;
    //
    // switch markup happened (e.g. frame navigation) or viewlinked 
    // doc design mode changed
    //
    CMshtmlEd *pCmdTarget, *pCmdActive;
    SP_IMarkupContainer2  spContainerEnded;
    BOOL    fContained = FALSE;

    IFC( pUnknown->QueryInterface( IID_IMarkupContainer2, (void **)&spContainerEnded) );
    hr = THR(FindCommandTarget( spContainerEnded, &pCmdTarget));
    if (!SUCCEEDED(hr))
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = S_OK;
    pCmdActive = GetActiveCommandTarget();
    if (pCmdActive)
    {
        if (pCmdActive == pCmdTarget)
        {
            fContained = TRUE;
        }
        else
        {
            // check to see if the active container is contained by the dying container
            IFC( EdUtil::CheckContainment(GetMarkupServices(), spContainerEnded, 
                                          pCmdActive->GetMarkupContainer(), &fContained) );
        }
    }
    
    if (fContained)
    {
#if DBG == 1
        Assert(_pSelMan);
        BOOL  fContextContained = FALSE;
        IFC( _pSelMan->IsContextWithinContainer(spContainerEnded, &fContextContained) );
        Assert(fContextContained && "edit context is not set to the active cmd target");
#endif

        //  We need to make sure our tracker is torn down first 
        if (_pSelMan && _pSelMan->GetActiveTracker())
        {
            IGNORE_HR( _pSelMan->GetActiveTracker()->BecomeDormant(NULL, TRACKER_TYPE_None, NULL) );
        }
        
        //
        // TODO: CSelectionManager should provide a way
        // to re-initialize itself when the active container
        // is removed. Now simply call Passivate and then 
        // redo Initailization();
        //
        IFC( _pSelMan->Passivate() );
        _pSelMan->Init();
        
        // Reset the active cmdTarget to the top container
        {
            SP_IMarkupContainer  spContainerNew;
            SP_IHTMLDocument2    spHtmlDoc;
            
            Assert(_pUnkContainer );
            IFC( _pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainerNew ) );
            IFC( FindCommandTarget( spContainerNew, &_pActiveCommandTarget ) );    
            Assert(_pActiveCommandTarget);
            Assert(_pActiveCommandTarget != pCmdTarget);

            IFC( spContainerNew->OwningDoc(&spHtmlDoc) );
            SetDoc(spHtmlDoc);
        }
    }

    if (pCmdTarget) 
    {
        // delete cmdTarget
        IGNORE_HR(DeleteCommandTarget(spContainerEnded) );
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::Notify(
    EDITOR_NOTIFICATION eSelectionNotification,
    IUnknown *pUnknown ,
    DWORD dword )
{
    HRESULT  hr = S_OK;
    
    if (eSelectionNotification == EDITOR_NOTIFY_CONTAINER_ENDED)
    {
        hr =THR(RemoveContainer(pUnknown));
        goto Cleanup;
    }
    
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!_pSelMan->_fInitialized)
    {
        hr = THR( _pSelMan->Initialize() );
        if (hr)
            goto Cleanup;
    }
    
    hr = THR( _pSelMan->Notify( eSelectionNotification, pUnknown, dword ) );
Cleanup:
    RRETURN1(hr, S_FALSE);
}
    

HRESULT
CHTMLEditor::GetCommandTarget(
    IUnknown *  pContext,
    IUnknown ** ppUnkTarget )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer     spContainer;
    CMshtmlEd               *pCmdTarget = NULL;
    SP_IMarkupContainer     spContainerFinal;
    
    if( !pContext || !ppUnkTarget )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // See if we are being passed in a markup container as our context
    hr = pContext->QueryInterface( IID_IMarkupContainer , (void **) &spContainer );

    if( !hr )
    {
        IFC( AdjustContainerCommandTarget( spContainer, &spContainerFinal) );
        
        //
        // Find the command target for this container
        //
        IFC( FindCommandTarget( spContainerFinal, &pCmdTarget ) );

        //
        // Didn't find a command target previously created for this IMarkupContainer.
        // Create one.
        //
        if( hr == S_FALSE )
        {
            IFC( AddCommandTarget( spContainerFinal, &pCmdTarget ) );        
        }

        // Retrieve the IUnknown pointer to pass back
        IFC( pCmdTarget->QueryInterface( IID_IUnknown, (void **)ppUnkTarget) );
    }
    else
    {
        //
        // We have a range asking for a command target.  Create a command
        // target and initialize the command target for the range.
        //
        pCmdTarget = new CMshtmlEd(this, TRUE);

        if( pCmdTarget == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    
        IFC( pCmdTarget->Initialize( pContext ) );
        IFC( pCmdTarget->QueryInterface( IID_IUnknown , (void **)ppUnkTarget ) );

        pCmdTarget->Release();
    }

Cleanup:
    RRETURN(hr);
}    

HRESULT
CHTMLEditor::GetElementToTabFrom(
            BOOL            fForward,
            IHTMLElement**  ppElement,
            BOOL *          pfFindNext)
{
    HRESULT         hr = S_OK;
            
    Assert( ppElement );
    if( ppElement == NULL )
        goto Cleanup;

    Assert(pfFindNext);
    if (!pfFindNext)
        goto Cleanup;

    *ppElement = NULL;
    *pfFindNext = TRUE;
    IFC( _pSelMan->EnsureEditContext());
    IFC( _pSelMan->GetActiveTracker()->GetElementToTabFrom( fForward, ppElement, pfFindNext ) );
       
Cleanup:
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the ISelectionServices interface
//
//  Arguments:  ppSelSvc = OUTPUT interface pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionServices( ISelectionServices **ppSelSvc )
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( ppSelSvc );

    if( ppSelSvc )
    {
        if( _pActiveCommandTarget )
        {
            CSelectionServices *pSelServ = _pActiveCommandTarget->GetSelectionServices();
            IFC(  pSelServ->QueryInterface( IID_ISelectionServices, (void **)ppSelSvc ) );
        }
        else
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN ( hr ) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the ISelectionServices interface
//
//  Arguments:  pIDoc = INPUT - Optional parameter indicating the doc to find
//                      the selection services for.
//              ppSelSvc = OUTPUT interface pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionServices( IMarkupContainer *pIContainer, ISelectionServices **ppSelSvc )
{
    HRESULT     hr = E_INVALIDARG;
    CMshtmlEd   *pCmdTarget = NULL;
    
    Assert( ppSelSvc );

    if( ppSelSvc )
    {
        //
        // Try and locate the command target for the given container
        //
        if( pIContainer )
        {
            IFC( FindCommandTarget( pIContainer, &pCmdTarget ) );
        }

        //
        // Give them the active command target
        //
        if( !pCmdTarget && _pActiveCommandTarget )
        {
            pCmdTarget = _pActiveCommandTarget;
        }
         
        if( pCmdTarget )
        {
            CSelectionServices *pSelServ = pCmdTarget->GetSelectionServices();
            IFC(  pSelServ->QueryInterface( IID_ISelectionServices, (void **)ppSelSvc ) );
        }
        else
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN ( hr ) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the active CSelectionServices pointer
//
//  Arguments:  None
//
//  Returns:    Pointer to CSelectionServices
//
//--------------------------------------------------------------------------
CSelectionServices *
CHTMLEditor::GetSelectionServices( )
{
    IGNORE_HR( DoPendingTasks() );
    
    if( _pActiveCommandTarget )
        return _pActiveCommandTarget->GetSelectionServices();
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::TerminateIMEComposition
//
//  Synopsis:   Terminates any active IME compositions
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::TerminateIMEComposition( )
{
    return GetSelectionManager()->TerminateIMEComposition(TERMINATE_NORMAL);
}

//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor IHTMLEditingServices Implementation
//////////////////////////////////////////////////////////////////////////////////


HRESULT 
CHTMLEditor::Delete ( 
    IMarkupPointer*     pStart, 
    IMarkupPointer*     pEnd,
    BOOL fAdjustPointers)
{
    HRESULT             hr;
    CDeleteCommand      *pDeleteCommand;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pDeleteCommand->Delete( spStartInternal, spEndInternal, fAdjustPointers) );

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::DeleteCharacter (
    IMarkupPointer * pPointer, 
    BOOL fLeftBound, 
    BOOL fWordMode,
    IMarkupPointer * pBoundary )
{
    HRESULT             hr, hrResult;
    SP_IMarkupPointer   spPointerInternal;
    CDeleteCommand      *pDeleteCommand;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );
    
    IFC( ConvertPointerToInternal( this, pPointer, &spPointerInternal) );

    //
    // Set the command target, the delete character function call sometimes
    // gets executed without having gone thru the plumbing which sets the commands
    // command targets
    //
    IFC( PushCommandTarget( _pActiveCommandTarget ) );
    
    hrResult = THR( pDeleteCommand->DeleteCharacter( spPointerInternal, fLeftBound, fWordMode, pBoundary ) );

    IFC( PopCommandTarget(WHEN_DBG(_pActiveCommandTarget)) );

    hr = hrResult;

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::Paste( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd, 
    BSTR bstrText )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    CPasteCommand       *pPasteCommand;
    CSpringLoader       *psl = GetPrimarySpringLoader();

    pPasteCommand = (CPasteCommand *) GetCommandTable()->Get( IDM_PASTE );
    Assert( pPasteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    if (psl && !psl->IsSpringLoaded())
    {
        psl = NULL; // avoid empty line formatting for external paste
    }

    IFC( pPasteCommand->Paste( spStartInternal, spEndInternal, psl, bstrText ) );      

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::PasteFromClipboard( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd,
    IDataObject* pDO )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    CPasteCommand  * pPasteCommand = NULL;

    pPasteCommand = (CPasteCommand *) GetCommandTable()->Get( IDM_PASTE );
    Assert( pPasteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pPasteCommand->PasteFromClipboard( spStartInternal, spEndInternal , pDO, GetPrimarySpringLoader(), FALSE /* fForceIE50Compat */) );

Cleanup:
    RRETURN(hr);
}       

///////////////////////////////////////////////////
// ISelectionObject2 Implementation
///////////////////////////////////////////////////
HRESULT 
CHTMLEditor::SelectRange( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd,
    SELECTION_TYPE eType)
{
    RRETURN (SelectRangeInternal(pStart,pEnd,eType,FALSE));
}     

HRESULT 
CHTMLEditor::SelectRangeInternal( 
                    IMarkupPointer* pStart, 
                    IMarkupPointer* pEnd,
                    SELECTION_TYPE  eType,
                    BOOL            fInternal)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    SP_IDisplayPointer  spDispStart;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    BOOL                fDidSelection = FALSE;


    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return E_FAIL;
    }
    //
    // Stop doing a set edit context range here, assume that its been set in Trident.
    //

#ifdef FORMSMODE
    IFC( CurrentScopeOrMaster(pStart, &spElement) );
    if (spElement != NULL)
    {
        if (_pSelMan->IsInFormsSelectionMode(spElement))
        {
            if (!fInternal && eType != SELECTION_TYPE_Caret && eType != SELECTION_TYPE_Control)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            else if (eType == SELECTION_TYPE_Caret)
            {
                hr = S_OK;
                goto Cleanup;
            }
     }
#endif
    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( _pSelMan->Select( spStartInternal, spEndInternal, eType, &fDidSelection ) );

    //  We need to scroll the selection into view.
    if ( fDidSelection )
    {
        //
        // We could have select a range different from spStartInternal/spEndInternal
        // due to adjustment
        //
        CEditTracker  *pTracker;
        pTracker = _pSelMan->GetActiveTracker();
        if (pTracker && pTracker->GetTrackerType() == TRACKER_TYPE_Selection)
        {
            CSelectTracker *pSelTracker = DYNCAST(CSelectTracker, pTracker);
            IFC( pSelTracker->GetStartSelection()->ScrollIntoView() );
        }
    }

Cleanup:
    RRETURN(hr);    
}     

HRESULT 
CHTMLEditor::Select( 
                ISegmentList* pISegmentList )
{
    HRESULT         hr = S_OK;
    SELECTION_TYPE  eType;
    
    Assert( _pSelMan && pISegmentList );
    if( !_pSelMan || !pISegmentList)
    {
        return E_FAIL;
    }

    //
    // If we are hosted under access, we cannot fire the onbeforeeditfocus event
    // when we are selecting items.  Because Access uses a magic div, controls that
    // are embedded in that magic div that are selected cause the magic div to become
    // current.  We didn't fire onbeforeeditfocus on select() calls in 5.0, but in
    // 5.5 we started firing this event.  Access cancels this event (they never want
    // their magic div to be editable) so we need to continue to not firing this
    // event for access.  And the magic continues!  Access also listens to when
    // their magic div becomes current.  Because CSelectionManager::Select() makes
    // their magic div current, Access panics and grabs the document.selection type 
    // to see if we are making their magic div active with a text selection on the
    // inside.  So we need to lie to them.  We ARE transitioning to a control tracker
    // in most every single case, but when BecomeCurrent() is called on the magic 
    // div, the tracker has not yet become active.  This is a nightmare, but we
    // need to keep this compat
    //
    if( IsHostedInAccess() )
    {
        IFC( pISegmentList->GetType( &eType ) );
        
        _pSelMan->SetDontFireEditFocus(TRUE);
        _fLieToAccess = TRUE;
        _eAccessLieType = eType;
    }

    //
    // Actually do the select
    //
    IFC( _pSelMan->Select( pISegmentList ) );


    if( IsHostedInAccess() )
    {
        _pSelMan->SetDontFireEditFocus(FALSE);
        _fLieToAccess = FALSE;
        _eAccessLieType = SELECTION_TYPE_None;
    }

Cleanup:
    RRETURN(hr);
}  


HRESULT 
CHTMLEditor::IsPointerInSelection(  IDisplayPointer *pDispPointer, 
                                    BOOL            *pfPointInSelection,
                                    POINT           *pptGlobal,
                                    IHTMLElement    *pIElementOver )
{
    HRESULT hr = S_OK;
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        hr = E_FAIL ;
        goto Cleanup;
    }
    IFC( _pSelMan->EnsureEditContext());    
    hr = THR( _pSelMan->IsPointerInSelection( pDispPointer, pfPointInSelection, pptGlobal, pIElementOver  ));
Cleanup:
    RRETURN( hr );
}     

HRESULT
CHTMLEditor::EmptySelection()
{
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }
    RRETURN ( _pSelMan->EmptySelection(TRUE) );

}

HRESULT
CHTMLEditor::DestroySelection()
{
    HRESULT hr = S_OK;
    
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }


    IFC( _pSelMan->DestroySelection() );

Cleanup:
    RRETURN(hr);
}

HRESULT
CHTMLEditor::DestroyAllSelection()
{
    HRESULT hr = S_OK;
    
    Assert(_pSelMan != NULL);
    
    if( ! _pSelMan )
    {
        return( E_FAIL );
    }
    IFC( _pSelMan->EnsureEditContext());
    
    if( !_pSelMan->IsInFireOnSelectStart() )
    {
        IFC( _pSelMan->EnsureDefaultTrackerPassive());
    }                    
    else
    {
        //
        // We're unloading during firing of OnSelectStart
        // We want to not kill the tracker now - but fail the OnSelectStart
        // resulting in the Tracker dieing gracefully.
        //
        _pSelMan->SetFailFireOnSelectStart( TRUE );
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::IsEventInSelection(CEditEvent* pEvent)
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;
    POINT pt;
    SP_IHTMLElement spElement;
    BOOL fInSelection = FALSE;
    SP_IDisplayPointer spDispPointer;
    
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPointer ));
    IFC( CreateMarkupPointer( & spPointer ));
    IFC( pEvent->MoveDisplayPointerToEvent( spDispPointer ));
    IFC( spDispPointer->PositionMarkupPointer( spPointer ));
    IFC( pEvent->GetPoint( & pt ));
    IFC( pEvent->GetElement( & spElement ));


    IFC( _pSelMan->IsPointerInSelection( spDispPointer, & fInSelection, & pt, spElement  ));
    
Cleanup:

    if ( hr == S_OK )
    {
        if ( ! fInSelection )
        {
            hr = S_FALSE;
        }
    }
    
    RRETURN1( hr, S_FALSE );
}

HRESULT 
CHTMLEditor::AdjustPointerForInsert ( 
                                    IDisplayPointer * pDispWhereIThinkIAm , 
                                    BOOL fFurtherInDocument, 
                                    IMarkupPointer* pConstraintStart,
                                    IMarkupPointer* pConstraintEnd )
{
    HRESULT hr = S_OK;
    BOOL    fAtBOL;
    SP_IHTMLElement     spElement;

    IFC( pDispWhereIThinkIAm->IsAtBOL(&fAtBOL) );
    IFC( AdjustPointer( pDispWhereIThinkIAm, fFurtherInDocument ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, 
                             ( pConstraintStart == NULL ) ? _pSelMan->GetStartEditContext() : pConstraintStart,
                             ( pConstraintEnd == NULL ) ? _pSelMan->GetEndEditContext() : pConstraintEnd, POSCARETOPT_None ) );

    //  Bug 102610: If the pointer was positioned into an atomic element, reposition it
    //  back outside.

    IFC( CurrentScopeOrMaster(pDispWhereIThinkIAm, &spElement) );
    if ( _pSelMan->CheckAtomic( spElement ) == S_OK )
    {
        SP_IMarkupPointer   spPointer;

        IFC( CreateMarkupPointer(&spPointer) );
        IFC( spPointer->MoveAdjacentToElement( spElement, 
                                                fFurtherInDocument ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
        IFC( pDispWhereIThinkIAm->MoveToMarkupPointer(spPointer, NULL) );
    }

Cleanup:
    RRETURN ( hr );
}

HRESULT 
CHTMLEditor::AdjustPointerForInsert ( 
                                    IDisplayPointer* pDispWhereIThinkIAm , 
                                    BOOL fFurtherInDocument, 
                                    IMarkupPointer* pConstraintStart,
                                    IMarkupPointer* pConstraintEnd,
                                    BOOL fStayOutsideUrl)
{
    HRESULT hr = S_OK;
    BOOL    fAtBOL;
    
    IFC( pDispWhereIThinkIAm->IsAtBOL(&fAtBOL) );
    IFC( AdjustPointer( pDispWhereIThinkIAm, fFurtherInDocument ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, 
                     ( pConstraintStart == NULL ) ? _pSelMan->GetStartEditContext() : pConstraintStart,
                     ( pConstraintEnd == NULL ) ? _pSelMan->GetEndEditContext() : pConstraintEnd, fStayOutsideUrl ? POSCARETOPT_None : ADJPTROPT_AdjustIntoURL ));

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: FindSiteSelectableElement
//
// Synopsis: Traverse through a range of pointers and find the site selectable element if any
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::FindSiteSelectableElement (
                                     IMarkupPointer* pPointerStart,
                                     IMarkupPointer* pPointerEnd, 
                                     IHTMLElement** ppIHTMLElement)  
{
    HRESULT hr = S_OK;
    IHTMLElement* pICurElement = NULL;
    IHTMLElement* pISiteSelectableElement = NULL;
    IMarkupPointer* pPointer = NULL;
    SP_IMarkupPointer   spPointerStartInternal;
    SP_IMarkupPointer   spPointerEndInternal;    
    int iWherePointer = 0;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    BOOL fValidForSelection  = FALSE;    
    BOOL fSiteSelectable = FALSE;
    BOOL fForceInvalid = FALSE;
    BOOL fIgnoreGlyphs = IgnoreGlyphs(TRUE);

    IFC( ConvertPointerToInternal( this, pPointerStart, &spPointerStartInternal) );
    IFC( ConvertPointerToInternal( this, pPointerEnd, &spPointerEndInternal) );
    
#if DBG == 1
    IFC( OldCompare( spPointerStartInternal, spPointerEndInternal, & iWherePointer ));
    Assert( iWherePointer != LEFT );
#endif

    IFC( CreateMarkupPointer( & pPointer ));
    IFC( pPointer->MoveToPointer( spPointerStartInternal));

    for(;;)
    {
        IFC( pPointer->Right( TRUE, & eContext, & pICurElement, NULL, NULL));
        IFC( OldCompare( pPointer, spPointerEndInternal, & iWherePointer));

        if ( iWherePointer == LEFT )
        {       
            goto Cleanup;
        }                    
        switch( eContext)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
            {
                Assert( pICurElement);

                fSiteSelectable = IsElementSiteSelectable( pICurElement ) == S_OK ;
                if ( fSiteSelectable )
                {
                    if (! fValidForSelection )
                    {
                        fValidForSelection = TRUE;
                        IFC( pPointer->MoveAdjacentToElement( pICurElement, ELEM_ADJ_AfterEnd ));
                        ReplaceInterface( & pISiteSelectableElement, pICurElement);
                    }
                    else if ( ! GetActiveCommandTarget()->IsMultipleSelection())
                    {                
                        //
                        // If we find a more than one site selectable elment ( and not Multiple-Sel)
                        // assume we are a text selection 
                        //
                        
                        fValidForSelection = FALSE;
                        goto Cleanup;
                    }
                    //
                    // else we are in multiple-selection mode. fValidForSelection remains true
                    // but we just return the FIRST site selectable element.
                    // 
                }                    
            }
            break;
            
            case CONTEXT_TYPE_Text:
            {
                // Must return S_FALSE indicating more than just an element here.
                fForceInvalid = TRUE;
                break;                    
            }

            case CONTEXT_TYPE_None:
            {
                fValidForSelection = FALSE;
                goto Cleanup;
            }

        }
        ClearInterface( & pICurElement );
    }

    
Cleanup:
    IgnoreGlyphs(fIgnoreGlyphs);
    
    ReleaseInterface( pICurElement);
    ReleaseInterface( pPointer );

    if ( hr == S_OK )
    {
        if ( !fValidForSelection || fForceInvalid)
            hr = S_FALSE;

        *ppIHTMLElement = pISiteSelectableElement;
        if (pISiteSelectableElement)
            pISiteSelectableElement->AddRef();
    }        
    ReleaseInterface( pISiteSelectableElement );
    return ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteSelectable
//
// Synopsis: Tests to see if a given element is site selectable (Doesn't drill up to the Edit
//           Context. - test is just for THIS Element
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::IsElementSiteSelectable( IHTMLElement* pIElement, IHTMLElement** ppIElement  )
{
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fSiteSelectable = FALSE;

    SP_IHTMLElement spActive;
    SP_IHTMLElement spClippedElement;
    

    IFC( GetActiveElement( this, pIElement, & spActive ));
    if ( spActive )
    {
        IFC( ClipToElement( this , spActive, pIElement, & spClippedElement ));
    }
    else
        spClippedElement = pIElement;

    IFC( GetMarkupServices()->GetElementTagId( spClippedElement , & eTag ));
        
    fSiteSelectable = CControlTracker::IsThisElementSiteSelectable(
                            _pSelMan,
                            eTag, 
                            spClippedElement );

    if ( fSiteSelectable && ppIElement )
    {
        *ppIElement = spClippedElement;
        (*ppIElement)->AddRef();
    }

Cleanup:

    if ( fSiteSelectable )
        hr = S_OK;
    else
        hr = S_FALSE;
    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: IsElementUIActivatable
//
// Synopsis: Tests to see if a given element is UI Activatable
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsElementUIActivatable( IHTMLElement* pIElement )
{
    HRESULT hr;
    
    hr =  _pSelMan->IsElementUIActivatable( pIElement ) ? S_OK : S_FALSE ; 

    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: IsElementAtomic
//
// Synopsis: Tests to see if a given element is atomic
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsElementAtomic( IHTMLElement* pIHTMLElement )
{
    HRESULT hr;

    hr = THR( _pSelMan->CheckAtomic(pIHTMLElement));

    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: PositionPointersInMaster
//
// Synopsis: Put pointers inside element for a viewlink editing.
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::PositionPointersInMaster( 
                                        IHTMLElement* pIElement, 
                                        IMarkupPointer* pIStart, 
                                        IMarkupPointer* pIEnd )
{
    HRESULT hr;

    hr = THR( EdUtil::PositionPointersInMaster( pIElement, pIStart, pIEnd ));

    RRETURN( hr );
}


BOOL
SkipCRLF ( TCHAR ** ppch )
{
    TCHAR   ch1;
    TCHAR   ch2;
    BOOL    fSkippedCRLF = FALSE;
    //
    // this function returns TRUE if a replacement of one or two chars
    // with br spacing is possible.  
    //

    //
    // is there a CR or LF?
    //

    ch1 = **ppch;
    if (ch1 != _T('\r') && ch1 != _T('\n'))
        goto Cleanup;

    //
    // Move pch forward and see of there is another CR or LF 
    // that can be grouped with the first one.
    //
    fSkippedCRLF = TRUE;
    ++(*ppch);
    ch2 = **ppch;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
        (*ppch)++;

Cleanup:
    
    return fSkippedCRLF;
}


HRESULT
CHTMLEditor::InsertLineBreak( IMarkupPointer * pStart, BOOL fAcceptsHTML )
{
    IMarkupPointer  * pEnd = NULL;
    IHTMLElement    * pIElement = NULL;
    HRESULT           hr;
    
    IFC( CreateMarkupPointer( & pEnd ) );
    IFC( pEnd->MoveToPointer( pStart ) );

    //
    // If pStart is in an element that accepts the truth, then insert a BR there
    // otherwise insert a carriage return
    //
    if (fAcceptsHTML)
    {
        IFC( GetMarkupServices()->CreateElement( TAGID_BR, NULL, & pIElement) );        
        IFC( InsertElement( pIElement, pStart, pEnd ) );
    }
    else
    {
        IFC( InsertMaximumText( _T("\r"), 1, pStart ) );
    }

Cleanup:
    ReleaseInterface( pIElement );
    ReleaseInterface( pEnd );
    RRETURN( hr );
}


HRESULT
CHTMLEditor::InsertSanitizedText(
    TCHAR *             pStr,
    LONG                cChInput,
    IMarkupPointer*     pStart,
    IMarkupServices*    pMarkupServices,
    CSpringLoader *     psl,
    BOOL                fDataBinding)
{
    const TCHAR chNBSP  = WCH_NBSP;
    const TCHAR chSpace = _T(' ');
    const TCHAR chTab   = _T('\t');

    HRESULT   hr = S_OK;;
    TCHAR     pchInsert[ TEXTCHUNK_SIZE + 1 ];
    TCHAR     chNext;
    TCHAR     *pStrInput;
    int       cch = 0;
    IHTMLElement        *   pFlowElement = NULL;
    VARIANT_BOOL            fAcceptsHTML;
    IMarkupPointer      *   pmpTemp = NULL;
    VARIANT_BOOL            fMultiLine = VARIANT_TRUE;
    POINTER_GRAVITY         eGravity = POINTER_GRAVITY_Left;
    SP_IHTMLElement3        spElement3;
    SP_IMarkupPointer       spStartInternal;

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );


    // Remember the gravity so we can restore it at Cleanup
    IFC( spStartInternal->Gravity(& eGravity ) );

    // we may be passed a null pStr if, for example, we are pasting an empty clipboard.
    
    if( pStr == NULL )
        goto Cleanup;

    IFC( spStartInternal->SetGravity( POINTER_GRAVITY_Right ) );

    //
    // Determine whether we accept HTML or not
    //
    IFC( spStartInternal->CurrentScope(&pFlowElement) );

    //
    // This should NEVER happen, but if it does, just fail the insert
    //
    if (! pFlowElement)
        goto Cleanup;
        
    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    IFC(spElement3->get_isMultiLine(&fMultiLine));

    if (*pStr && psl && fAcceptsHTML)
    {
        IFC( psl->SpringLoad(spStartInternal, SL_ADJUST_FOR_INSERT_RIGHT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
        IFC( psl->Fire(spStartInternal) );
    }

    chNext = *pStr;
    pStrInput = pStr;

    while( pStr - pStrInput < cChInput && chNext)
    {   
        //
        // If the first character is a space, 
        // it must turn into an nbsp if pStart is 
        // at the beginning of a block/layout or after a <BR>
        //    
        if ( fAcceptsHTML && chNext == chSpace )
        {
            CEditPointer    ePointer( this );
            DWORD           dwBreak;

            IFC( ePointer.MoveToPointer( spStartInternal ) );
            IGNORE_HR( ePointer.Scan(  LEFT,
                            BREAK_CONDITION_Block |
                            BREAK_CONDITION_Site |
                            BREAK_CONDITION_Control |
                            BREAK_CONDITION_NoScopeBlock |
                            BREAK_CONDITION_Text ,
                            &dwBreak ) );

            if ( ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) ||
                 ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitSite  ) ||
                 ePointer.CheckFlag( dwBreak, BREAK_CONDITION_NoScopeBlock ))
            {
                // Change the first character to an nbsp
                chNext = chNBSP;
            }
        }

        for ( cch = 0 ; (pStr - pStrInput < cChInput) && chNext && chNext != _T('\r') && chNext != _T('\n') ; )
        {
            if ( fAcceptsHTML )
            {
                //
                // Launder spaces if we accept html
                //
                switch ( chNext )
                {
                case chSpace:
                    if ( *(pStr + 1) == _T( ' ' ) )
                    {
                        chNext = chNBSP;
                    }
                    break;

                case chNBSP:
                    break;

                case chTab:
                    chNext = chNBSP;
                    break;
                }
            }

            pchInsert[ cch++ ] = chNext;
            
            chNext = *++pStr;
            
            if (cch == TEXTCHUNK_SIZE)
            {
                // pchInsert is full, empty the text into the tree
                pchInsert[ cch ] = 0;
                IFC( InsertMaximumText( pchInsert, TEXTCHUNK_SIZE, spStartInternal ) );
                cch = 0;
            }
        }
        
        pchInsert[ cch ] = 0;

        //
        // Check for NULL termination or exceeding cChInput.
        //
        if (pStr - pStrInput >= cChInput || (*pStr) == NULL)
        {
            if (cch)
            {
                // Insert processed text into the tree and bail
                IFC( InsertMaximumText( pchInsert, cch, spStartInternal ) );
            }
            break;
        }

        Verify( SkipCRLF( &pStr ) );        

        IFC( InsertMaximumText( pchInsert, -1, spStartInternal ) );

        if ( !fAcceptsHTML && !fMultiLine )
        {
            // 
            // We're done because this is not a multi line control and
            // the first line of text has already been inserted.
            // 
            goto Cleanup;
        }

        if ( SkipCRLF( &pStr ))
        {
            // We got two CRLFs. If we are in data binding, simply
            // insert two BRs. If we are not in databinding, insert
            // a new paragraph.
            if (fDataBinding || !fAcceptsHTML)
            {
                IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
                IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
            }
            else
            {
                ClearInterface( & pmpTemp );
                IFC( HandleEnter( spStartInternal, & pmpTemp, NULL, TRUE ) );
                if (pmpTemp)
                {
                    IFC( spStartInternal->MoveToPointer( pmpTemp ) );
                }
            }
        }
        else
        {
            IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
        }
        
        chNext = *pStr;
    }

Cleanup:
    ReleaseInterface( pmpTemp );
    ReleaseInterface( pFlowElement );
    IGNORE_HR( pStart->SetGravity( eGravity ) );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsEditContextUIActive
//
// Synopsis: Is the edit context Ui active ( does it have the hatched border ?).
//           If it does - return S_OK
//                      else return S_FALSE
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsEditContextUIActive()
{
    HRESULT hr;

    if ( !_pSelMan )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = _pSelMan->IsEditContextUIActive() ;

Cleanup:
    RRETURN1( hr, S_FALSE );
}    

HRESULT 
CHTMLEditor::InsertSanitizedText( 
    IMarkupPointer * pIPointerInsertHere, 
    OLECHAR *        pstrText,
    LONG             cCh,
    BOOL             fDataBinding)
{
    HRESULT           hr = S_OK;
    
    if (!pIPointerInsertHere)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now, do the insert
    //
    
    hr = THR( InsertSanitizedText( pstrText, cCh, pIPointerInsertHere, _pMarkupServices, NULL, fDataBinding ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}       

HRESULT
CHTMLEditor::UrlAutoDetectCurrentWord( 
    IMarkupPointer * pWord )
{
    HRESULT             hr;
    SP_IMarkupPointer   spWordInternal;

    if( !pWord )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( ConvertPointerToInternal( this, pWord, &spWordInternal) );
    
    IFC( GetAutoUrlDetector()->DetectCurrentWord( spWordInternal, NULL, NULL ) );
    
Cleanup:

    RRETURN( hr );
}

HRESULT
CHTMLEditor::UrlAutoDetectRange(
    IMarkupPointer * pStart,
    IMarkupPointer * pEnd )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    if( !pStart || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    hr = THR( GetAutoUrlDetector()->DetectRange( spStartInternal, spEndInternal ) );
    if( hr )
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

    
HRESULT
CHTMLEditor::ShouldUpdateAnchorText (
        OLECHAR * pstrHref,
        OLECHAR * pstrAnchorText,
        BOOL    * pfResult )
{
    return ( GetAutoUrlDetector()->ShouldUpdateAnchorText (pstrHref, pstrAnchorText, pfResult ) );
}


HRESULT 
CHTMLEditor::LaunderSpaces ( 
    IMarkupPointer  * pStart,
    IMarkupPointer  * pEnd  )
{
    HRESULT             hr;
    CDeleteCommand      *pDeleteCommand;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pDeleteCommand->LaunderSpaces( spStartInternal, spEndInternal ) );

Cleanup:
    RRETURN(hr);
}    

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor IHTMLEditServices Implementation
//////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AddDesigner
//
//  Synopsis:   This method adds a designer to the editor's current list of
//              designers.  A designer is a pluggable interface which allows
//              for third party interaction with our editor.
//
//  Arguments:  pIDesigner = Designer to add
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AddDesigner (
    IHTMLEditDesigner *pIDesigner )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIDesigner != NULL );

    if( (pIDesigner != NULL) && (_aryDesigners.Find( pIDesigner ) == -1) )
    {
        hr = _aryDesigners.Append( pIDesigner );
        pIDesigner->AddRef();
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::RemoveDesigner
//
//  Synopsis:   This method removes a designer from the editor's current 
//              list of designers.  A designer is a pluggable interface which 
//              allows for third party interaction with our editor.
//
//  Arguments:  pIDesigner = Designer to remove
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::RemoveDesigner (
    IHTMLEditDesigner *pIDesigner )
{
    HRESULT             hr = E_INVALIDARG;
    SP_IUnknown         spIDelUnk;          // IUnknown interface of designer to remove
    SP_IUnknown         spIUnknown;         // IUnknown interface of designer already added
    IHTMLEditDesigner   **pElem;   
    int                 i;
    BOOL                fFound = FALSE;
    
    Assert( pIDesigner != NULL );

    if( pIDesigner )
    {
        IFC( pIDesigner->QueryInterface( IID_IUnknown, (void **)&spIDelUnk ) );

        //
        // Make sure we use the IUnknown pointer for equality.
        //
        for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
             i > 0; 
             i--, pElem++ )
        {
            IFC( (*pElem)->QueryInterface( IID_IUnknown, (void **)&spIUnknown ) );

            if( spIUnknown == spIDelUnk )
            {
                (*pElem)->Release();
                _aryDesigners.DeleteByValue(*pElem);
                fFound = TRUE;
            }               
        }
    }

    hr = (fFound == TRUE) ? S_OK : E_INVALIDARG;

Cleanup:


    RRETURN( hr );
}


HRESULT
CHTMLEditor::InternalQueryStatus(
    const GUID * pguidCmdGroup,
    ULONG cCmds,
    OLECMD rgCmds[],
    OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_FALSE;

    Assert( cCmds == 1 );
    
    // Allow designers to handle the command, 
    // if none of the designers handle it, pass it on to the editor
    IFC( DesignerQueryStatus(pguidCmdGroup, &rgCmds[0], pcmdtext ));

Cleanup:
    RRETURN1(hr, S_FALSE);   
}    

HRESULT
CHTMLEditor::InternalExec(
    const GUID * pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut)
{
    HRESULT hr = S_FALSE;
    OLECMD  cmd;

    cmd.cmdID = nCmdID;

    // Check the designer, see if it even supports this command
    IFC(DesignerQueryStatus(pguidCmdGroup, &cmd, NULL));
    if (cmd.cmdf)
    {
        IFC(DesignerExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
    }
    else
    {
        // Not supported, therefore, not handled
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}    

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Public Utilities
//////////////////////////////////////////////////////////////////////////////////


BOOL 
CHTMLEditor::IsContextEditable()
{ 
    return _pSelMan->IsContextEditable();
}

HRESULT CHTMLEditor::FindBlockElement(  IHTMLElement    *pElement, 
                                        IHTMLElement    **ppBlockElement )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spOldElement;
    BOOL                bBlockElement;
    SP_IHTMLElement     spCurrent;

    Assert( ppBlockElement && pElement );
    
    spCurrent = pElement;

    while( spCurrent )
    {
        hr = THR(IsBlockOrLayoutOrScrollable(spCurrent, &bBlockElement));
        if (FAILED(hr) || bBlockElement)
            goto Cleanup;
            
        spOldElement = spCurrent;
        IFC( GetParentElement( spOldElement, &spCurrent) );
    }

Cleanup:
    *ppBlockElement = spCurrent;
    if( *ppBlockElement != NULL )
        (*ppBlockElement)->AddRef();

    RRETURN(hr);        
}

HRESULT CHTMLEditor::FindCommonElement( IMarkupPointer      *pStart,
                                        IMarkupPointer      *pEnd,
                                        IHTMLElement        **ppElement,
                                        BOOL                fIgnorePhrase /* = FALSE */,
                                        BOOL                fStayInMarkup /* = FALSE */)
{
    HRESULT             hr;
    IMarkupPointer      *pLeft;
    IMarkupPointer      *pRight;
    INT                 iPosition;
    SP_IMarkupPointer   spCurrent;
    SP_IHTMLElement     spElement;
    
    Assert( ppElement );
    
    // init for error case
    *ppElement = NULL;

   
    //
    // Find right/left pointers
    //

    IFC( OldCompare( pStart, pEnd, &iPosition) );

    if (iPosition == SAME)
    {
        if( fStayInMarkup )
        {
            IFC( pStart->CurrentScope( &spElement ) );
        }
        else
        {
            IFC( CurrentScopeOrMaster( pStart, &spElement ) );
        }

        goto Cleanup;
    }
    else if (iPosition == RIGHT)
    {
        pLeft = pStart;     // weak ref
        pRight = pEnd;      // weak ref
    }
    else
    {
        pLeft = pEnd;       // weak ref
        pRight = pStart;    // weak ref
    }

    //
    // Walk the left pointer up until the right end of the element
    // is to the right of pRight.  Also, keep track of the master
    // element in case the first 
    //
    IFC( pLeft->CurrentScope(&spElement) );

    IFC( CreateMarkupPointer(&spCurrent) );

    while( spElement )
    {
        IFC( spCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );

        if (fIgnorePhrase)
        {
            if (!IsPhraseElement(spElement))
            {
                IFC( OldCompare( spCurrent, pRight, &iPosition) );

                if( iPosition != RIGHT )
                {
                    // Retrieve the master element if we are not staying in the 
                    // markup
                    if( !fStayInMarkup )
                        IFC( CurrentScopeOrMaster( spCurrent, &spElement ) );

                    break;
                }
            }
        }
        else
        {
            IFC( OldCompare( spCurrent, pRight, &iPosition) );

            if (iPosition != RIGHT)
            {
                IFC( CurrentScopeOrMaster( spCurrent, &spElement ) );
                break;
            }
        }

        IFC( ParentElement( GetMarkupServices(), &(spElement.p) ) );
    }

Cleanup:

    *ppElement = spElement;

    if( *ppElement )
        (*ppElement)->AddRef();
    
    RRETURN(hr);
}

CSpringLoader *
CHTMLEditor::GetPrimarySpringLoader()
{
    if( _pActiveCommandTarget )
        return _pActiveCommandTarget->GetSpringLoader();
    else
        return NULL;
}

HRESULT 
CHTMLEditor::InsertElement(IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    RRETURN( EdUtil::InsertElement(GetMarkupServices(), pElement, pStart, pEnd) );
}

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Compose Settings Methods
//////////////////////////////////////////////////////////////////////////////////

struct COMPOSE_SETTINGS *
CHTMLEditor::GetComposeSettings(BOOL fDontExtract /*=FALSE*/)
{
    if (!fDontExtract)
        CComposeSettingsCommand::ExtractLastComposeSettings(this, _pComposeSettings != NULL);

    return _pComposeSettings;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::EnsureComposeSettings
//
//  Synopsis:   This function ensures the allocation of the compose font buffer
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

COMPOSE_SETTINGS *
CHTMLEditor::EnsureComposeSettings()
{
    if (!_pComposeSettings)
    {
        _pComposeSettings = (struct COMPOSE_SETTINGS *)MemAllocClear(Mt(CHTMLEditor_pComposeSettings), sizeof(struct COMPOSE_SETTINGS));

        if (_pComposeSettings)
            _pComposeSettings->_fComposeSettings = FALSE;
    }

    return _pComposeSettings;
}




HRESULT     
CHTMLEditor::GetSiteContainer(
    IHTMLElement *          pStart,
    IHTMLElement **         ppSite,
    BOOL *                  pfText,             /*=NULL*/
    BOOL *                  pfMultiLine,        /*=NULL*/
    BOOL *                  pfScrollable )      /*=NULL*/
{
    HRESULT hr = E_FAIL;
    BOOL fSite = FALSE;
    BOOL fText = FALSE;
    BOOL fMultiLine = FALSE;
    BOOL fScrollable = FALSE;

    SP_IHTMLElement spElement;

    Assert( pStart != NULL && ppSite != NULL );
    if( pStart == NULL || ppSite == NULL )
        goto Cleanup;

    *ppSite = NULL;
    spElement = pStart;

    while( ! fSite && spElement != NULL )
    {
        VARIANT_BOOL fMulti = VARIANT_FALSE;
        SP_IHTMLElement3  spElement3;

        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fSite, &fScrollable));
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        spElement3->get_isMultiLine(&fMulti);
        fMultiLine = !!fMulti;

        IFC(_pDisplayServices->HasFlowLayout(spElement, &fText));

        if( ! fSite )
        {
            SP_IHTMLElement  spParent;
            IFC( GetParentElement( spElement, &spParent ));
            spElement = spParent;
        }
    }
    
Cleanup:

    if( fSite )
    {
        hr = S_OK;
        
        *ppSite = spElement;
        (*ppSite)->AddRef();
        
        if( pfText != NULL )
            *pfText = fText;

        if( pfMultiLine != NULL )
            *pfMultiLine = fMultiLine;

        if( pfScrollable != NULL )
            *pfScrollable = fScrollable;
    }

    RRETURN( hr );
}

HRESULT
CHTMLEditor::GetBlockContainer(
    IHTMLElement *          pStart,
    IHTMLElement **         ppElement )
{
    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;
    SP_IHTMLElement spElement;

    Assert( pStart && ppElement );
    if( pStart == NULL || ppElement == NULL )
        goto Cleanup;

    *ppElement = NULL;
    spElement = pStart;

    while( ! fFound && spElement != NULL )
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, &fFound));
        
        if( ! fFound )
        {
            SP_IHTMLElement spParent;
            IFC( GetParentElement( spElement, &spParent ));
            spElement = spParent;
        }
    }
    
Cleanup:
    if( fFound )
    {
        hr = S_OK;
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }
        
    RRETURN( hr );
}


HRESULT     
CHTMLEditor::GetSiteContainer(
    IMarkupPointer *        pPointer,
    IHTMLElement **         ppSite,
    BOOL *                  pfText,             /*=NULL*/
    BOOL *                  pfMultiLine,        /*=NULL*/
    BOOL *                  pfScrollable )      /*=NULL*/
{
    HRESULT hr = E_FAIL;
    SP_IHTMLElement spElement;

    Assert( pPointer != NULL && ppSite != NULL );
    if( pPointer == NULL || ppSite == NULL )
        goto Cleanup;

    IFC( CurrentScopeOrMaster( pPointer, &spElement ));
    
    if( spElement )
        IFC( GetSiteContainer( spElement, ppSite, pfText, pfMultiLine, pfScrollable ));
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditor::GetBlockContainer(
    IMarkupPointer *        pPointer,
    IHTMLElement **         ppElement )
{
    HRESULT hr = E_FAIL;
    SP_IHTMLElement spElement;

    Assert( pPointer != NULL && ppElement != NULL );
    if( pPointer == NULL || ppElement == NULL )
        goto Cleanup;

    IFC( pPointer->CurrentScope( &spElement ));
    
    if( spElement )
        IFC( GetBlockContainer( spElement, ppElement ));
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInDifferentEditableSite
//
// Synopsis: Are we in a different site-selectable object from the edit context
//
//------------------------------------------------------------------------------------


BOOL
CHTMLEditor::IsInDifferentEditableSite(IMarkupPointer* pPointer)
{
    HRESULT hr = S_OK;
    BOOL fDifferent = FALSE;
    IHTMLElement* pIFlowElement = NULL ;

    IFC( GetFlowElement( pPointer, & pIFlowElement ));
    if ( pIFlowElement )
    {
        if ( ! SameElements( 
                             pIFlowElement, 
                             GetSelectionManager()->GetEditableElement()) && 
            IsElementSiteSelectable( pIFlowElement) == S_OK  )
        {
            fDifferent = TRUE;
        }
    }
    
Cleanup:
    ReleaseInterface( pIFlowElement);
    
    return( fDifferent );
}

HRESULT
CHTMLEditor::AdjustPointer(
    IDisplayPointer         *pDispPointer,
    Direction               eBlockDir,
    Direction               eTextDir,
    IMarkupPointer *        pLeftBoundary,
    IMarkupPointer *        pRightBoundary,
    DWORD                   dwOptions /* = ADJPTROPT_None */ )
{
    HRESULT hr = S_OK;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    CEditPointer ep( this );        // allocate a new MP
    CEditPointer epSave( this );    // allocate a place saver
    BOOL fTextSite = FALSE;
    BOOL fBlockHasLayout = FALSE;
    BOOL fValidAdjustment= FALSE;
    DWORD dwSearch = 0;
    DWORD dwFound = 0;
    BOOL fStayOutOfUrl = ! CheckFlag( dwOptions , ADJPTROPT_AdjustIntoURL );    // If the adjust into url flag is not set, we stay out of the url
    BOOL fDontExitPhrase = CheckFlag( dwOptions , ADJPTROPT_DontExitPhrase ); // If the don't exit phrase flag is set, we don't exit phrase elements while adjusting to text
    BOOL fEnterTables    = CheckFlag( dwOptions , ADJPTROPT_EnterTables );      // if we want to enter the first cell of the table
    SP_IDisplayPointer spLineStart, spLineEnd;
    SP_IMarkupPointer spLeftBoundaryInternal;
    SP_IMarkupPointer spRightBoundaryInternal;
    
    SP_IHTMLElement spIBlock;
    SP_IHTMLElement spISite;        
    
    CEditPointer epTest(this);
    CEditPointer epLB(this);
    CEditPointer epRB(this);

    IFC( pDispPointer->PositionMarkupPointer(ep) );

    IFC( ConvertPointerToInternal( this, pLeftBoundary, &spLeftBoundaryInternal) );
    IFC( ConvertPointerToInternal( this, pRightBoundary, &spRightBoundaryInternal) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineStart) );
    IFC( spLineStart->MoveToPointer(pDispPointer) );
    IFC( spLineStart->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineEnd) );
    IFC( spLineEnd->MoveToPointer(pDispPointer) );
    IFC( spLineEnd->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );

    IFC( spLineStart->PositionMarkupPointer(epLB) );
    IFC( spLineEnd->PositionMarkupPointer(epRB));

    //
    // We always enter table from left
    //
    if (fEnterTables)
    {
        EnterTables(ep, RIGHT);
    }
    //
    // We want to be sure that the pointer is located inside a valid
    // site. For instance, if we are in a site that can't contain text,
    // trying to cling to text within that site is a waste of time.
    // In that case, we have to scan entering sites until we find one
    // that can contain text. If we can't find one going in our move 
    // direction, reverse and look the other way. By constraining 
    // using Scan and only entering layouts, we prevent many problems 
    // (especially with tables)
    //

    hr = THR( GetSiteContainer( ep, &spISite, &fTextSite ));

    //
    // We dont really allow typing in a select right now - so you're in the "right" 
    // place.
    //
    IFC( GetMarkupServices()->GetElementTagId( spISite, & eTag ));
    if ( eTag == TAGID_SELECT )
        goto Cleanup;
        
    //
    // Is our pointer within a text site?
    //

    if( ! fTextSite )
    {
        hr = AdjustIntoTextSite( ep, eBlockDir );
        
        if( FAILED( hr ))
        {
            hr = AdjustIntoTextSite( ep, Reverse( eBlockDir ));
        }
        
        if( FAILED( hr ))
        {
            hr = E_FAIL;
            goto Cleanup;
        }     
        
        // Our line may have moved
        IFC( spLineStart->MoveToPointer(pDispPointer) );
        IFC( spLineStart->MoveToMarkupPointer(ep, NULL) );
        IFC( spLineStart->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

        IFC( spLineEnd->MoveToPointer(pDispPointer) );
        IFC( spLineEnd->MoveToMarkupPointer(ep, NULL) );
        IFC( spLineEnd->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );

        IFC( spLineStart->PositionMarkupPointer(epLB) );
        IFC( spLineEnd->PositionMarkupPointer(epRB) );
    }

    //
    // Constrain the pointer
    //
    
    if( spLeftBoundaryInternal )
    {
        BOOL fAdj = FALSE;
        IFC( spLeftBoundaryInternal->IsRightOf( epLB, &fAdj ));

        if( fAdj )
            IFC( epLB->MoveToPointer( spLeftBoundaryInternal ));
    }

    if( spRightBoundaryInternal )
    {
        BOOL fAdj = FALSE;
        IFC( spRightBoundaryInternal->IsLeftOf( epRB, &fAdj ));

        if( fAdj )
            IFC( epRB->MoveToPointer( spRightBoundaryInternal ));
    }        
    
    IFC( ep.SetBoundary( epLB, epRB ));
    IFC( ep.Constrain() );
    
    //
    // Now that we are assured that we are in a nice cozy text site, we would
    // like to be in a block element, if possible.
    //
    hr = THR( GetBlockContainer( ep, &spIBlock ));
    
    if( spIBlock )
    {
        IFC( _pMarkupServices->GetElementTagId( spIBlock, &eTag ));
        IFC(IsBlockOrLayoutOrScrollable(spIBlock, NULL, &fBlockHasLayout));
    }

    if( FAILED( hr ) || spIBlock == NULL || IsNonTextBlock( eTag ) || fBlockHasLayout )
    {
        BOOL fHitText = FALSE;
        
        hr = AdjustIntoBlock( ep, eBlockDir, &fHitText, TRUE, epLB, epRB );
        
        if( FAILED( hr ))
        {
            hr = AdjustIntoBlock( ep, Reverse( eBlockDir ), &fHitText, FALSE, epLB, epRB );
        }
        
        if( FAILED( hr ))
        {
            // Not so bad. Just cling to text...
            hr = S_OK;
        }
        
        if( fHitText )
        {
            goto Done;
        }
    }

    //
    // If we are block adjusting left, we can move exactly one NoscopeBlock to the left
    //
    
    if( eBlockDir == LEFT )
    {
        IFC( epSave.MoveToPointer( ep ));
        dwSearch =  BREAK_CONDITION_OMIT_PHRASE;
        dwFound = BREAK_CONDITION_None;

        hr = THR( ep.Scan( LEFT, dwSearch, &dwFound ));

        if( ! ep.CheckFlag( dwFound , BREAK_CONDITION_NoScopeBlock))
        {
            IFC( ep.MoveToPointer( epSave ));
        }

    }


Done:

    //
    // Search for text
    //
    IFC( epTest->MoveToPointer(ep) );
    IFC( AdjustIntoPhrase(epTest, eTextDir, fDontExitPhrase) );
    IFC( IsValidAdjustment(ep, epTest, &fValidAdjustment) );
    if (fValidAdjustment)
    {
        ep->MoveToPointer(epTest);
    }

    //
    // See if we need to exit from an URL boundary
    //

    IFC( epTest->MoveToPointer(ep) );
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    eTextDir = LEFT; // remember the direction of scan
    
    if (!epTest.CheckFlag(dwFound,  BREAK_CONDITION_ExitAnchor))
    {
        IFC( epTest->MoveToPointer(ep) );
        IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
        eTextDir = RIGHT ;// remember the direction of scan
    }
    
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitAnchor))
    {
        if (!fStayOutOfUrl)
        {
            CEditPointer epText(this);
            
            // Make sure we are adjacent to text
            IFC( epText->MoveToPointer(ep) );
            IFC( epText.Scan(Reverse(eTextDir), BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
            
            fStayOutOfUrl = !epText.CheckFlag(dwFound, BREAK_CONDITION_Text)
                            && !epText.CheckFlag(dwFound, BREAK_CONDITION_Anchor);
        }
        if (fStayOutOfUrl)
        {
            // Move into adjacent phrase elements if we can       
            IFC( AdjustIntoPhrase(epTest, eTextDir, fDontExitPhrase) );
            IFC( IsValidAdjustment(ep, epTest, &fValidAdjustment) )
            if (fValidAdjustment)
            {
                IFC( ep->MoveToPointer(epTest) );
            }
            
        }
    }

    IFC( pDispPointer->MoveToMarkupPointer(ep, NULL));
        
Cleanup:

    RRETURN( hr );
}


//
// HACKHACK: We don't want to stay out of URL/Phrase if we have adjust to a 
// different line. If we do, caret will get stuck since <A>/<B>/<I>/etc. 
// their content might be in different lines due to 
// our current line-breaking behaviours. See Bug #96038 for more details.
// In the future, if line-breaking is more intelligent, we might be 
// able to remove this hacking.  (zhenbinx)
//
//
HRESULT     
CHTMLEditor::IsValidAdjustment(
            IMarkupPointer  *pPointer,
            IMarkupPointer  *pAdjustedPointer,
            BOOL            *fValid
            )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spLinePointer, spLineAdjusted;

    //
    //       This function might not work in ambiguious position case 
    //       since the display pointer does not have gravity information.
    //       However this is not a problem since the display pointer has
    //       to adjust to that position anyway. 
    //

    //
    // Move to current line
    //
    IFC( GetDisplayServices()->CreateDisplayPointer(&spLinePointer) );
    IFC( spLinePointer->MoveToMarkupPointer(pPointer, NULL) );
    IFC( spLinePointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) )

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineAdjusted) );
    IFC( spLineAdjusted->MoveToMarkupPointer(pAdjustedPointer, NULL) );
    IFC( spLineAdjusted->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

    //
    // We only do adjustment if they are in the same line
    //
    IFC( spLineAdjusted->IsEqualTo(spLinePointer, fValid) );

Cleanup:
    RRETURN(hr);
}



HRESULT
CHTMLEditor::AdjustIntoTextSite(
    IMarkupPointer  *pPointer,
    Direction       eDir )
{
    HRESULT hr = E_FAIL;
    BOOL fDone = FALSE;
    BOOL fFound = FALSE;
    DWORD dwSearch = BREAK_CONDITION_Site;
    DWORD dwFound = BREAK_CONDITION_None;
    
    CEditPointer ep( this );
    SP_IHTMLElement spISite;

    Assert( pPointer );
    
    IFC( ep.MoveToPointer( pPointer ));
    
    while( ! fDone && ! fFound )
    {
        dwFound = BREAK_CONDITION_None;
        hr = THR( ep.Scan( eDir, dwSearch, &dwFound ));

        if( ep.CheckFlag( dwFound, BREAK_CONDITION_Site ))
        {
            // Did we enter a text site in the desired direction?
            hr = THR( GetSiteContainer( ep, &spISite, &fFound ));
        }
        else
        {
            // some other break condition, we are done
            fDone = TRUE;
        }
    }

Cleanup:
    if( fFound )
    {
        hr = THR( pPointer->MoveToPointer( ep ));
    }
    else
    {
        hr = E_FAIL;
    }
    
    return( hr );
}    


HRESULT
CHTMLEditor::AdjustIntoBlock(
    IMarkupPointer *        pPointer,
    Direction               eDir,
    BOOL *                  pfHitText,
    BOOL                    fAdjustOutOfBody,
    IMarkupPointer *        pLeftBoundary,
    IMarkupPointer *        pRightBoundary )
{
    HRESULT hr = E_FAIL;

    // Stop if we hit text, enter or exit a site, or
    // hit an intrinsic control. If we enter or exit
    // a block, make sure we didn't "leave" the current 
    // line.

    BOOL fDone = FALSE;
    BOOL fFound = FALSE;
    BOOL fHitText = FALSE;
    
    DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD dwFound = BREAK_CONDITION_None;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    TCHAR chFound = 0;
            
    CEditPointer ep( this );
    SP_IHTMLElement spIBlock;
    
    Assert( pPointer && pfHitText );
    if( pPointer == NULL || pfHitText == NULL )
        goto Cleanup;
        
    IFC( ep.MoveToPointer( pPointer ));
    IFC( ep.SetBoundary( pLeftBoundary, pRightBoundary ));
    IFC( ep.Constrain() );

    while( ! fDone )
    {
        dwFound = BREAK_CONDITION_None;
        IFC( ep.Scan( eDir , dwSearch, &dwFound, NULL, NULL, &chFound, NULL ));

        //
        // Did we hit text or a text like object?
        //

        if( ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
        {
            LONG                lChars = 1;
            MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;

            hr = THR( ep.Move( Reverse( eDir ), TRUE, &eCtxt, NULL, &lChars, NULL ));
            
            if( hr == E_HITBOUNDARY )
            { 
                fDone = TRUE;
                goto Cleanup;
            }
            
            IFC( pPointer->MoveToPointer( ep ));

            fHitText = TRUE;
            fFound = TRUE;
            fDone = TRUE;
            
            Assert( ! FAILED( hr ));
            
            goto Cleanup;
        }

        //
        // Did we hit a site boundary?
        //
        
        else if( ep.CheckFlag( dwFound, BREAK_CONDITION_Site ))
        {
            fDone = TRUE;
        }

        //
        // Did we enter a block?
        //
        
        else if( ep.CheckFlag( dwFound , BREAK_CONDITION_EnterBlock ))
        {   
            // Entered a Block
            hr = THR( GetBlockContainer( ep, &spIBlock ));

            if(( ! FAILED( hr )) && ( spIBlock != NULL ))
            {
                IFC( _pMarkupServices->GetElementTagId( spIBlock, &eTag ));

                if(( ! IsNonTextBlock( eTag )) && ( ! ( fAdjustOutOfBody && eTag == TAGID_BODY )))
                {
                    // found a potentially better block - check to see if eitehr breakonempty is set or the block contains text
                    VARIANT_BOOL fBOESet = VARIANT_FALSE;
                    SP_IHTMLElement3 spElement3;
                    IFC( spIBlock->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                    IFC( spElement3->get_inflateBlock( &fBOESet ));

                    if( fBOESet )
                    {
                        // it really is better - move our pointer there and set the sucess flag!!!
                        IFC( pPointer->MoveToPointer( ep ));
                        fFound = TRUE; // but, keep going!
                    }

                    // if BOE is not set, we have to keep going to determine if the block has content
                }
            }
            else
            {
                // didn't find a better block and we can go no farther... we are probably in the root
                fDone = TRUE;
            }
        }

        //
        // Did we exit a block - probably not a good sign, but we should keep going for now...
        //
        
        else if( ep.CheckFlag( dwFound, BREAK_CONDITION_ExitBlock ))
        {
            // we just booked out of a block element. things may be okay
        }

        else // hit something like boundary,  or error 
        {
            fDone = TRUE;
        }
    }

Cleanup:
    
    if( pfHitText )
    {
        *pfHitText = fHitText;
    }

    if( ! fFound )
        hr = E_FAIL;
    
    return( hr );
}

HRESULT
CHTMLEditor::AdjustIntoPhrase(IMarkupPointer  *pPointer, Direction eTextDir, BOOL fDontExitPhrase )
{
    HRESULT         hr;
    DWORD           dwFound;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;        
    
    CEditPointer    epSave(this);
    CEditPointer    ep(this, pPointer);

    if( fDontExitPhrase )
    {
        dwSearch = dwSearch + BREAK_CONDITION_ExitPhrase;
    }
    
    IFC( epSave.MoveToPointer( ep ));    
    hr = THR( ep.Scan( eTextDir, dwSearch, &dwFound ));    
                        
    if( ! ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
    {
        //
        // We didn't find any text, lets look the other way
        //

        eTextDir = Reverse( eTextDir ); // Reverse our direction, keeping track of which way we are really going        
        IFC( ep.MoveToPointer( epSave )); // Go back to where we started...
        hr = THR( ep.Scan( eTextDir, dwSearch, &dwFound ));
    }

    if( ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
    {
        //
        // We found something, back up one space
        //
    
        LONG lChars = 1;
        MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;
        hr = THR( ep.Move( Reverse( eTextDir ), TRUE, &eCtxt, NULL, &lChars, NULL ));
        if( hr == E_HITBOUNDARY )
        {
            Assert( hr != E_HITBOUNDARY );
            goto Cleanup;
        }

    }
    else
    {
        IFC( ep.MoveToPointer(epSave) );
    }

Cleanup:
    RRETURN(hr);
}    

BOOL     
CHTMLEditor::IsNonTextBlock(
    ELEMENT_TAG_ID          eTag )
{
    BOOL fIsNonTextBlock = FALSE;
        
    switch( eTag )
    {
        case TAGID_NULL:
        case TAGID_UL:
        case TAGID_OL:
        case TAGID_DL:
        case TAGID_DIR:
        case TAGID_MENU:
        case TAGID_FORM:
        case TAGID_FIELDSET:
        case TAGID_TABLE:
        case TAGID_THEAD:
        case TAGID_TBODY:
        case TAGID_TFOOT:
        case TAGID_COL:
        case TAGID_COLGROUP:
        case TAGID_TC:
        case TAGID_TH:
        case TAGID_TR:
            fIsNonTextBlock = TRUE;        
            break;
       
        default:
            fIsNonTextBlock = FALSE;
    }
    
    return( fIsNonTextBlock );    
}

TCHAR *
CHTMLEditor::GetCachedString(UINT uiStringId)
{
    TCHAR *pchResult = NULL;

    if (_pStringCache)
    {
        pchResult = _pStringCache->GetString(uiStringId);
    }

    return pchResult;
}


HRESULT
CHTMLEditor::RemoveEmptyCharFormat(IMarkupServices *pMarkupServices, IHTMLElement **ppElement, BOOL fTopLevel, CSpringLoader *psl)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spLeft;
    SP_IMarkupPointer   spRight;
    SP_IMarkupPointer   spWalk;
    ELEMENT_TAG_ID      tagId;
    BOOL                bEqual;
    BOOL                bHeading = FALSE;
    SP_IHTMLElement     spNewElement;

    IFC( pMarkupServices->GetElementTagId(*ppElement, &tagId) );
    
    switch (tagId)
    {
    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        if (!fTopLevel)
            goto Cleanup; // don't try heading reset if not in top level

        bHeading = TRUE;
        // fall through

    case TAGID_B:
    case TAGID_STRONG:
    case TAGID_U:
    case TAGID_EM:
    case TAGID_I:
    case TAGID_FONT:
    case TAGID_STRIKE:
    case TAGID_SUB:
    case TAGID_SUP:

        IFC( CreateMarkupPointer2(this, &spLeft) );
        IFC( spLeft->MoveAdjacentToElement(*ppElement, ELEM_ADJ_AfterBegin ) );

        IFC( CreateMarkupPointer2(this, &spRight) );
        IFC( spRight->MoveAdjacentToElement(*ppElement, ELEM_ADJ_BeforeEnd ) );

        IFC( spLeft->IsEqualTo(spRight, &bEqual) );

        //
        // If the pointers are not equal, allow one nbsp to be inside.
        //

        if (!bEqual)
        {
            MARKUP_CONTEXT_TYPE mctContext;
            long                cch = 1; // Walk one character at a time.
            TCHAR               ch;

            IFC( CreateMarkupPointer2(this, &spWalk) );
            IFC( spWalk->MoveToPointer(spLeft) );

            IFC( spWalk->Right(TRUE, &mctContext, NULL, &cch, &ch) );
            if (   mctContext == CONTEXT_TYPE_Text
                && cch && WCH_NBSP == ch )
            {
                IFC( spWalk->IsEqualTo(spRight, &bEqual) );
            }
        }

        if (bEqual)
        {
            if (bHeading)
            {
                IFC( CGetBlockFmtCommand::GetDefaultBlockTag(pMarkupServices, &tagId) );
                IFC( pMarkupServices->CreateElement(tagId, NULL, &spNewElement) );

                // We want the left pointer to end up inside the new element.
                // (bug 91683)
                IFC( spLeft->SetGravity(POINTER_GRAVITY_Right) );
                
                IFC( ReplaceElement(this, *ppElement, spNewElement, spLeft, spRight) );

                ReplaceInterface(ppElement, (IHTMLElement *)spNewElement);

                if (psl)
                {
                    IGNORE_HR( psl->SpringLoadComposeSettings(spLeft, TRUE) );
                }
            }   
            else
            {
                BOOL        fIsBlockElement = FALSE;

                //  Bug 25006: A formatting element, such as a <EM> could have style="display:block"
                //  making it a block element.  We don't want to remove the element if it is a block
                //  element.

                IFC( IsBlockOrLayoutOrScrollable(*ppElement, &fIsBlockElement) );
                if (!fIsBlockElement)
                {
                    IFC( pMarkupServices->RemoveElement(*ppElement) );
                    hr = S_FALSE;
                }
            }

        }
        break;

    default:
         hr = S_OK; // nothing to remove
    }    

Cleanup:    
    RRETURN1(hr, S_FALSE);
}

HRESULT
CHTMLEditor::HandleEnter(
    IMarkupPointer  *pCaret, 
    IMarkupPointer  **ppInsertPosOut,
    CSpringLoader   *psl       /* = NULL */,
    BOOL             fExtraDiv /* = FALSE */)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement     spNewElement;
    SP_IHTMLElement     spDivElement;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spCurElement;
    SP_IHTMLElement3    spElement3;
    ELEMENT_TAG_ID      tagId;
    ELEMENT_TAG_ID      tagIdDefaultBlock = TAGID_NULL;
    SP_IObjectIdentity  spIdent;
    BOOL                bListMode = FALSE;
    
    if (ppInsertPosOut)
        *ppInsertPosOut = NULL;

    //
    // Create helper pointers
    //

    IFC( CreateMarkupPointer(&spStart) );
    IFC( CreateMarkupPointer(&spEnd) );

    //
    // Walk up to get the block element
    //
    
    IFC( pCaret->CurrentScope(&spElement) );
    IFC( FindListItem(GetMarkupServices(), spElement, &spBlockElement) );
    if (spBlockElement)
    {
        bListMode = TRUE;

        //
        // Load the spring loader before processing the enter key to 
        // copy formats down
        //
        if (psl)
        {
            IFC( psl->SpringLoad(pCaret, SL_TRY_COMPOSE_SETTINGS) );
        }
    }
    else
    {
        CBlockPointer       bpCurrent(this);
        SP_IMarkupPointer   spTest;
        BOOL                bEqual;

        IFC( pCaret->CurrentScope(&spElement) );                       
        IFC( FindOrInsertBlockElement(spElement, &spBlockElement, pCaret, TRUE) );

        //
        // Load the spring loader before processing the enter key to 
        // copy formats down
        //
        if (psl)
        {
            IFC( psl->SpringLoad(pCaret, SL_TRY_COMPOSE_SETTINGS) );
        }

        // If we are not after begin or before end, it is safe to flatten
        IFC( CreateMarkupPointer(&spTest) );
        IFC( spTest->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_AfterBegin) );
        
        IFC( spTest->IsEqualTo(pCaret, &bEqual) );
        if (!bEqual)
        {
            IFC( spTest->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_BeforeEnd) );
            IFC( spTest->IsEqualTo(pCaret, &bEqual) );
            if (!bEqual)
            {
                // We need to flatten the block element so we don't introduce overlap
                IFC( bpCurrent.MoveTo(spBlockElement) );
                if (bpCurrent.GetType() == NT_Block)
                {
                    // we need a pointer with right gravity but we can't change the gravity of the input pointer
                    IFC( bpCurrent.FlattenNode() );
            
                    IFC( pCaret->CurrentScope(&spElement) );
                    IFC( FindOrInsertBlockElement(spElement, &spBlockElement, pCaret) );            
                }
            }
        }        
    }
   
    
    //
    //
    // Split the block element and all contained elements
    // Except Anchors
    //
    
    IFC( spBlockElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
    IFC( pCaret->CurrentScope(&spCurElement) );

    //
    // fExtraDiv works when the default block element is a DIV.
    // Refer to comment farther down for more information.
    //
    if ( fExtraDiv )
    {
        IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefaultBlock));
    }
    
    for (;;)
    {                    
        IFC( spStart->MoveAdjacentToElement(spCurElement, ELEM_ADJ_AfterBegin) );
        IFC( spEnd->MoveAdjacentToElement(spCurElement, ELEM_ADJ_BeforeEnd) );
        IFC( GetMarkupServices()->GetElementTagId(spCurElement, &tagId) );        
        IFC( CCommand::SplitElement(GetMarkupServices(), spCurElement, spStart, pCaret, spEnd, & spNewElement) );
        IGNORE_HR( spNewElement->removeAttribute(L"id", NULL, 0) );
        
        IFC( pCaret->MoveAdjacentToElement(spNewElement, ELEM_ADJ_BeforeBegin) );
        IFC( GetMarkupServices()->GetElementTagId(spNewElement, &tagId) );

        switch (tagId)
        {
            case TAGID_A:
                //
                // If we are splitting the anchor in the middle or end, the first element remains
                // an anchor while the second does not.  If we split the anchor at the start,
                // the second element remains an anchor while the first is deleted.
                //

                if (DoesSegmentContainText(spStart, pCaret))
                {
                    IFC( GetMarkupServices()->RemoveElement( spNewElement ));
                    spNewElement = NULL;

                    if (psl)
                    {
                        IFC( psl->SpringLoad(pCaret, SL_RESET | SL_TRY_COMPOSE_SETTINGS) );
                    }
                }
                else
                {
                    IFC( GetMarkupServices()->RemoveElement( spCurElement ));
                    spCurElement = NULL;
                }
                break;

            case TAGID_DIV:
                //
                // If the split block element was a div, and fExtraDiv
                // is TRUE, then (because naked divs have no inter-block 
                // spacing) insert am empty div to achieve the empty line effect.
                //
                if ( fExtraDiv && tagIdDefaultBlock == TAGID_DIV)
                {
                    // We correctly assume that pCaret is before the inserted element
                    IFC( GetMarkupServices()->CreateElement( TAGID_DIV, NULL, &spDivElement ));                    
                    IFC( InsertElement(spDivElement, pCaret, pCaret ));
                }
        
                IFC( spNewElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                break;                

            case TAGID_P:
            case TAGID_BLOCKQUOTE:
                IFC( spNewElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                break;

            case TAGID_LI:
                IFC( spNewElement->removeAttribute(_T("value"), 0, NULL) )
                break;
        }    
        
        if( spNewElement != NULL && psl )
        {
            if (spCurElement != NULL)
                hr = spIdent->IsEqualObject(spCurElement);
            else
                hr = S_FALSE; // can't be top level if we deleted it
            
            IFC( RemoveEmptyCharFormat(GetMarkupServices(), &(spNewElement.p), (hr == S_OK), psl) ); // pNewElement may morph
        }
        else
        {
            hr = S_OK;
        }
        
        if( spNewElement != NULL && S_OK == hr )
        {
            SP_IMarkupPointer spNewCaretPos;

            IFC( CreateMarkupPointer(&spNewCaretPos) );
            IFC( spNewCaretPos->MoveAdjacentToElement(spNewElement, ELEM_ADJ_AfterBegin) );
            IFC( LaunderSpaces(spNewCaretPos, spNewCaretPos) );
            
            if (ppInsertPosOut && !(*ppInsertPosOut))
            {
                IFC( CreateMarkupPointer(ppInsertPosOut) );
                IFC( (*ppInsertPosOut)->MoveToPointer(spNewCaretPos) );
            }
        }

        if (spCurElement != NULL)
        {
            hr = spIdent->IsEqualObject(spCurElement);
            if (S_OK == hr)
                break;
        }
        
        IFC( pCaret->CurrentScope(&spCurElement) );        
    } 

    Assert(spNewElement != NULL); // we must exit by hitting the block element
        
Cleanup:

    // We should have found a new position for the caret while walking up
    AssertSz(ppInsertPosOut == NULL || (*ppInsertPosOut), "Can't find new caret position");
    RRETURN(hr);    
}

IMarkupPointer* 
CHTMLEditor::GetStartEditContext()
{
    return _pSelMan->GetStartEditContext();
}

IMarkupPointer*
CHTMLEditor::GetEndEditContext()
{
    return _pSelMan->GetEndEditContext();
}

HRESULT
CHTMLEditor::IsInEditContext(   IMarkupPointer  *pPointer, 
                                BOOL            *pfInEdit,
                                BOOL            fCheckContainer /* = FALSE */)
{
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }
    return _pSelMan->IsInEditContext( pPointer, pfInEdit, fCheckContainer );
}


HRESULT
CHTMLEditor::DesignerPreHandleEvent( DISPID inDispId, IHTMLEventObj * pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PreHandleEvent( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}


HRESULT
CHTMLEditor::DesignerPostEditorEventNotify( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 ); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PostEditorEventNotify( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}


HRESULT
CHTMLEditor::DesignerPostHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PostHandleEvent( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}

HRESULT
CHTMLEditor::DesignerTranslateAccelerator( DISPID inDispId, IHTMLEventObj* pIObj  )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->TranslateAccelerator( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}

HRESULT
CHTMLEditor::DesignerQueryStatus(
    const GUID * pguidCmdGroup,
    OLECMD *rgCmd,
    OLECMDTEXT * pcmdtext)
{
    HRESULT             hr = S_OK;
    IHTMLEditDesigner   **pElem;
    int                 i;
    IOleCommandTarget *pCmdTarget=NULL;
    BOOL bHandled = FALSE;
   
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && bHandled == FALSE); 
         i--, pElem++ )
    {
        rgCmd->cmdf = 0;

        hr = THR( (*pElem)->QueryInterface(IID_IOleCommandTarget, (void **) &pCmdTarget));
        if (FAILED(hr) || pCmdTarget==NULL)
        {
            hr = S_OK;                        // This designer doesn't handle 'any' command!
            ReleaseInterface(pCmdTarget);
            continue;
        }
            
        hr = THR( pCmdTarget->QueryStatus(pguidCmdGroup, 1, rgCmd, pcmdtext) );
        if (SUCCEEDED(hr))
        {
            if (rgCmd->cmdf)                   // Supported
                bHandled = TRUE;
        }                
        ReleaseInterface(pCmdTarget);
    }
    return hr;
}
                    
HRESULT
CHTMLEditor::DesignerExec(
    const GUID * pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut)
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;
    IOleCommandTarget *pCmdTarget=NULL;
    BOOL                bDone = FALSE;
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         i > 0 && !bDone; 
         i--, pElem++ )
    {
        hr = THR( (*pElem)->QueryInterface(IID_IOleCommandTarget, (void **) &pCmdTarget));
        if (FAILED(hr) || pCmdTarget==NULL)
        {
            ReleaseInterface(pCmdTarget);
            continue;
        }

        OLECMD oleCmd;
        oleCmd.cmdID = nCmdID;
        oleCmd.cmdf = 0;
        IFC(pCmdTarget->QueryStatus(pguidCmdGroup, 1, &oleCmd, NULL)); 
        // If this designer supports this command, then let it
        // execute the command
        if ((oleCmd.cmdf & OLECMDF_SUPPORTED) && (oleCmd.cmdf & OLECMDF_ENABLED))
        {
            bDone = TRUE;
            hr = THR( pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut) );
        }
        
        ReleaseInterface(pCmdTarget);        
    }

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Private Methods
//////////////////////////////////////////////////////////////////////////////////



HRESULT 
CHTMLEditor::FindOrInsertBlockElement( IHTMLElement     *pElement, 
                                       IHTMLElement     **ppBlockElement,
                                       IMarkupPointer   *pCaret /* = NULL */,
                                       BOOL             fStopAtBlockquote /* = FALSE */ )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spParentElement;
    CEditPointer        epLeft(this);
    CEditPointer        epRight(this);
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement3    spElement3;
    BOOL                bBlockElement;
    BOOL                bLayoutElement;
    ELEMENT_TAG_ID      tagId;

    spBlockElement = pElement;

    do
    {
        IFC(IsBlockOrLayoutOrScrollable(spBlockElement, &bBlockElement, &bLayoutElement));
        if (bLayoutElement)
            break; // need to insert below
                    
        IFC( GetMarkupServices()->GetElementTagId(spBlockElement, &tagId) );
        if (tagId == TAGID_FORM || fStopAtBlockquote && tagId == TAGID_BLOCKQUOTE)
            break; // need to insert below

        if (bBlockElement)
            goto Cleanup; // done

        IFC( GetParentElement( spBlockElement, &spParentElement) );
        
        if (spParentElement != NULL)
            spBlockElement = spParentElement;
    }
    while (spParentElement != NULL);


    //
    // Need to insert a block element
    //

    if (pCaret)
    {
        DWORD           dwSearch = BREAK_CONDITION_Block | BREAK_CONDITION_Site;
        DWORD           dwFound;
        SP_IHTMLElement spElement;

        // Expand left
        IFC( epLeft->MoveToPointer(pCaret) );
        for (;;)
        {
            IFC( epLeft.Scan(LEFT, dwSearch, &dwFound, &spElement) );
            if (epLeft.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_ExitSite))
            {
                IFC( epLeft.Scan(RIGHT, dwSearch, &dwFound) );
                break; // done
            }

            // Now, we have a site which is not a block.  So, we must skip the site and continue
            // scanning

            Assert(epLeft.CheckFlag(dwFound, BREAK_CONDITION_Site));
            IFC( epLeft->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );            
        }

        // Expand right
        IFC( epRight->MoveToPointer(pCaret) );
        for (;;)
        {
            IFC( epRight.Scan(RIGHT, dwSearch, &dwFound, &spElement) );
            if (epRight.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_ExitSite))
            {
                IFC( epRight.Scan(LEFT, dwSearch, &dwFound) );
                break;
            }

            // Now, we have a site which is not a block.  So, we must skip the site and continue
            // scanning

            Assert(epRight.CheckFlag(dwFound, BREAK_CONDITION_Site));
            IFC( epRight->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );            
        }
    }
    else
    {
        // Just use the block element as the boundary
        IFC( epLeft->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_AfterBegin) );
        IFC( epRight->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_BeforeEnd) );        
    }

    IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );
    IFC( GetMarkupServices()->CreateElement(tagId, NULL, &spBlockElement) );
    IFC( spBlockElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
    IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );

    if (pCaret)
    {
        IFC( InsertBlockElement(GetMarkupServices(), spBlockElement, epLeft, epRight, pCaret) );
    }
    else
    {
        IFC( InsertElement(spBlockElement, epLeft, epRight) );
    }        

Cleanup:  
    if (ppBlockElement)
    {
        *ppBlockElement = spBlockElement;
        if (spBlockElement != NULL)
            spBlockElement->AddRef();
    }

    RRETURN(hr);
}


HRESULT
CHTMLEditor::IsPhraseElement(IHTMLElement *pElement)
{
    HRESULT hr;
    BOOL fBlock, fLayout;

    // Make sure the element is not a site or block element
    IFC(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    if (fLayout || fBlock)
        return FALSE;
        
    return TRUE;

Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: MovePointersToEquivalentContainers
//
// Synopsis: Move markup pointers that are in separate IMarkupContainers to the same markup containers
//           for the purposes of comparison. 
//
//           Done by drilling piInner up until you're in pIOuter (or you fail).
//
// RETURN:
//           S_OK if the inner pointer was able to be moved into the container of the OUTER
//           S_FALSE if this wasn't possible.
//------------------------------------------------------------------------------------

HRESULT CHTMLEditor::MovePointersToEqualContainers( IMarkupPointer  *pIInner,
                                                    IMarkupPointer  *pIOuter )
{
    HRESULT             hr = S_FALSE;
    SP_IMarkupContainer spIInnerMarkup;
    SP_IMarkupContainer spIOuterMarkup;
    SP_IMarkupContainer spIInnerDrill;
    SP_IHTMLElement     spIElement;
    BOOL                fDone = FALSE;    

    // Get the inner and outer containers, and a working
    // copy of the inner container (for drilling up)
    IFC( pIInner->GetContainer( &spIInnerMarkup ));
    IFC( pIOuter->GetContainer( &spIOuterMarkup ));

    spIInnerDrill = spIInnerMarkup;

    Assert( !EqualContainers( spIInnerDrill, spIOuterMarkup ));

    while( fDone == FALSE )
    {
        // See if we are in the right container
        if( !EqualContainers( spIInnerDrill, spIOuterMarkup ))
        {
            // Retrieve the current scope, or the master element, and move
            // our inner pointer before the beginning
            IFC( CurrentScopeOrMaster(pIInner, &spIElement));      
            IFC( pIInner->MoveAdjacentToElement( spIElement, ELEM_ADJ_BeforeBegin ));

            // Get our new container. and check to make sure it is 
            // different than our original container
            IFC( pIInner->GetContainer( &spIInnerDrill ));

            if( EqualContainers( spIInnerMarkup, spIInnerDrill ) )
            {
                fDone = TRUE;
            }

            spIInnerMarkup = spIInnerDrill;
        }
        else
        {
            //
            // Successfully drilled up to the same container
            //
            fDone = TRUE;
            hr = S_OK;
        }       
    }

Cleanup:
   
    RRETURN1( hr, S_FALSE );
}




//+====================================================================================
//
// Method: IsPassword
//
// Synopsis: Is the given IHTMLElement a Password element ?
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::IsPassword( IHTMLElement* pIElement, BOOL* pfIsPassword )
{
    HRESULT hr = S_OK;
    BOOL fIsPassword = FALSE;
    IHTMLElement* pIEditElement = NULL;   
    IHTMLInputElement * pIInputElement = NULL;
    BSTR bstrType = NULL;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    Assert( pIElement && pfIsPassword );
    
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    if ( eTag == TAGID_INPUT )
    {
        //
        // Get the Master.
        //
        IFC( GetSelectionManager()->GetEditableElement( &pIEditElement ));
                                                      
        IFC( pIEditElement->QueryInterface ( 
                                        IID_IHTMLInputElement, 
                                        ( void** ) & pIInputElement ));
                            
        IFC(pIInputElement->get_type(&bstrType));
        
        if ( bstrType && !StrCmpIC( bstrType, TEXT("password") ) )
        {
            fIsPassword = TRUE;

        }
    }

Cleanup:

    *pfIsPassword = fIsPassword;

    SysFreeString( bstrType );
    ReleaseInterface( pIEditElement );        
    ReleaseInterface( pIInputElement );
    RRETURN( hr );
}

//+====================================================================================
//
// Method: FindCommonParentElement
//
// Synopsis: Find the parent common to all segments in a segment list
//
//------------------------------------------------------------------------------------


HRESULT 
CHTMLEditor::FindCommonParentElement( 
                                        ISegmentList* pSegmentList, 
                                        IHTMLElement** ppIElement)
{
    HRESULT hr;
    HTMLED_PTR( edSegmentMin );
    HTMLED_PTR( edSegmentMax);

    IFC( FindOutermostPointers( pSegmentList, edSegmentMin, edSegmentMax ));

    IFC( FindCommonElement( edSegmentMin, edSegmentMax, ppIElement ));

Cleanup:
    RRETURN( hr );
    
}

//+====================================================================================
//
// Method: FindOutermostPointers
//
// Synopsis: Find the outermost set of pointers in a given segmentlist ( ie the 
//           "total" start and end pointers.
//
//------------------------------------------------------------------------------------


HRESULT 
CHTMLEditor::FindOutermostPointers( 
                                    ISegmentList* pSegmentList, 
                                    IMarkupPointer* pOutermostStart, 
                                    IMarkupPointer* pOutermostEnd )
{
    HRESULT hr;
    HTMLED_PTR( edMinStart ) ;
    HTMLED_PTR( edMaxEnd );
    HTMLED_PTR( edTempStart );
    HTMLED_PTR( edTempEnd );
    BOOL fRightOf,fLeftOf;
    SELECTION_TYPE eType;
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    
    Assert( pOutermostStart && pOutermostEnd );        
    
    IFC( pSegmentList->GetType( &eType ));
    IFC( pSegmentList->CreateIterator( &spIter ) );

    if( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( edMinStart, edMaxEnd ));

        IFC( spIter->Advance() );
        
#if DBG == 1
    IFC( edMinStart->IsLeftOfOrEqualTo( edMaxEnd, & fLeftOf));
    Assert( fLeftOf );
#endif

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current( &spSegment ) );
            IFC( spSegment->GetPointers( edTempStart, edTempEnd ));

#if DBG == 1
            IFC( edTempStart->IsLeftOfOrEqualTo( edTempEnd, & fLeftOf));
            Assert( fLeftOf );
#endif

            IFC( edTempStart->IsLeftOf( edMinStart, & fLeftOf ));
            if ( fLeftOf )
            {
                IFC( edMinStart->MoveToPointer( edTempStart ));
            }

            IFC( edTempEnd->IsRightOf( edMinStart, & fRightOf ));
            if ( fRightOf )
            {
                IFC( edMaxEnd->MoveToPointer( edTempEnd ));
            }        

            IFC( spIter->Advance() );
        }

        IFC( pOutermostStart->MoveToPointer( edMinStart ));
        IFC( pOutermostEnd->MoveToPointer( edMaxEnd ));
    }        
    
Cleanup:
    
    RRETURN( hr );
    
}

HRESULT
CHTMLEditor::GetTableFromTablePart( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement curElement;
    SP_IHTMLElement nextElement;
    ELEMENT_TAG_ID eTag;

    IFC( GetMarkupServices()->GetElementTagId( pIElement,  & eTag ));
    Assert( IsTablePart( eTag ));

    ReplaceInterface( & curElement, pIElement );

    while ( eTag != TAGID_TABLE && curElement )
    {
        IFC( GetParentElement( curElement, &nextElement) );
        IFC( GetMarkupServices()->GetElementTagId( nextElement, & eTag ));

        curElement =  nextElement ;
    }

    if ( eTag == TAGID_TABLE && ppIElement )
    {
        ReplaceInterface( ppIElement, (IHTMLElement*) curElement );
    }
    
Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditor::GetOutermostTableElement( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spCurElement;
    SP_IHTMLElement spNextElement;
    ELEMENT_TAG_ID eTag;
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement,  & eTag ));
    Assert( IsTablePart( eTag ) || eTag == TAGID_TABLE );

    spCurElement = (IHTMLElement*) pIElement ;

    while ( TRUE ) // terminate on finding a table - without it's parent being a table.
    {    
        while ( eTag != TAGID_TABLE && spCurElement )
        {
            IFC( GetParentElement( spCurElement, & spNextElement) );
            IFC( GetMarkupServices()->GetElementTagId( spNextElement, & eTag ));

            spCurElement =  spNextElement ;
        }

        if( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spNextElement) == S_OK )
        {
            IFC( GetMarkupServices()->GetElementTagId( spNextElement, & eTag ));
            if ( ! IsTablePart( eTag ))
            {
                break;
            }
            else
            {
                spCurElement = spNextElement;
            }
        }
        else
        {
            //
            // means there is no parent layout for the table.
            //
            AssertSz(0,"Expected to find a layout after a table");
            hr = E_FAIL;
            goto Cleanup;
        }        
    }
    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));    
    if ( eTag == TAGID_TABLE && ppIElement )
    {
        ReplaceInterface( ppIElement, (IHTMLElement*) spCurElement );
    }
    
Cleanup:
    RRETURN( hr );
}

#include <initguid.h>
DEFINE_GUID(IID_IHTMLEditDesigner,      0x3050f662, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);
DEFINE_GUID(IID_IHTMLEditServices,  0x3050f663, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

HRESULT
CHTMLEditor::StartDblClickTimer(LONG lMsec /*=0*/ )
{
    HRESULT hr;
    SP_IHTMLWindow2 spWindow2;
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC(spWindow2->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)_pDispOnDblClkTimer;

    IFC(spWindow3->setInterval(&varCallBack, 
                               lMsec == 0 ? GetDoubleClickTime() : lMsec, 
                               &varLang, &_lTimerID));

Cleanup:
    RRETURN (hr);
}

HRESULT
CHTMLEditor::StopDblClickTimer()
{
    HRESULT hr;
    SP_IHTMLWindow2 spWindow2;

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC(spWindow2->clearInterval(_lTimerID));

Cleanup:
    RRETURN (hr);
}


inline HRESULT
CTimeoutHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    if( _pEd )
        return _pEd->Notify(EDITOR_NOTIFY_TIMER_TICK, NULL, NULL);
    else
        return S_OK;
}

HRESULT
CCaptureHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    IHTMLEventObj *pObj=NULL;

    if( _pEd )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) );
            if ( pObj )
            {
                CHTMLEditEvent evt(  _pEd );
                IFC( evt.Init( pObj , dispidMember ));

                Assert( _pEd->GetSelectionManager()->IsInCapture());

                IFC( _pEd->GetSelectionManager()->DoPendingTasks());            

                if ( !_pEd->GetSelectionManager()->IsInCapture() )
                {
                    //
                    // We check that we still have capture. DoPendingTasks
                    // may have caused a tracker to become dormant
                    // so we fail & bail
                    //
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                hr = THR( _pEd->GetSelectionManager()->HandleEvent( & evt ));
                if ( hr == S_FALSE )
                {
                    //
                    // event was cancelled. We want to tell not to bubble anymore.
                    //
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = VARIANT_FALSE;
                    hr = S_OK; // attach event needs this.
                }
            }
        }
    }
    
Cleanup:
    ReleaseInterface( pObj );
    RRETURN1( hr , S_FALSE );
}


HRESULT 
CHTMLEditor::MakeCurrent( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());
    
Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditor::GetMarkupPosition( IMarkupPointer* pPointer, LONG* pMP )
{
    HRESULT hr;
    SP_IMarkupPointer2 spPointer2;
    
    IFC( pPointer->QueryInterface( IID_IMarkupPointer2, ( void**) & spPointer2 ));
    IFC( spPointer2->GetMarkupPosition( pMP ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditor::MoveToMarkupPosition( IMarkupPointer * pPointer,
                                   IMarkupContainer * pContainer, 
                                   LONG mp )
{
    HRESULT hr ;
    SP_IMarkupPointer2 spPointer2;
      
    IFC( pPointer->QueryInterface( IID_IMarkupPointer2, ( void**) & spPointer2 ));
    IFC( spPointer2->MoveToMarkupPosition( pContainer ,  mp ));
    
Cleanup:
    RRETURN( hr );
}

ISelectionServices*
CHTMLEditor::GetISelectionServices()
{   
    HRESULT hr = S_OK;
    
    if ( ! _pISelectionServices )
    {
        hr = THR( GetSelectionServices( NULL, &_pISelectionServices ));
        if ( FAILED(hr ))
            goto Error;
    }
    return _pISelectionServices;

Error:
    ClearInterface( & _pISelectionServices );
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::CurrentScopeOrMaster
//
//  Synopsis:   Retrieves the current element where the markup pointer is
//              positioned.  If the markup pointer is positioned in a slave
//              markup, returns the master element of that markup.
//
//  Arguments:  pIPointer = Pointer to markup position
//              pIDisplay = Display Pointer to position
//              ppElement = Pointer to returned root or scoped element.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::CurrentScopeOrMaster(  IDisplayPointer *pIDisplay, 
                                    IHTMLElement    **ppElement, 
                                    IMarkupPointer  *pIPointer /* = NULL */ )
{
    HRESULT             hr = S_OK;
    BOOL                fHasPointer = (pIPointer != NULL);
    
#if DBG
    SP_IMarkupPointer   spEqualTest;
    BOOL                fEqual;
#endif    

    Assert( pIDisplay && ppElement );

#if DBG

    if( fHasPointer )
    {
        IFC( CreateMarkupPointer( &spEqualTest ) );
        IFC( pIDisplay->PositionMarkupPointer( spEqualTest ) );

        IFC( spEqualTest->IsEqualTo(pIPointer, &fEqual) );

        Assert( fEqual );
    }
#endif

    if( !fHasPointer )
    {
        IFC( CreateMarkupPointer( &pIPointer ) );
        IFC( pIDisplay->PositionMarkupPointer( pIPointer ) );
    }

    IFC( pIPointer->CurrentScope( ppElement ) );

    if( !*ppElement )
    {
        IFC( pIDisplay->GetFlowElement( ppElement ) );
    }
        
Cleanup:
    if( !fHasPointer )
    {
        ReleaseInterface( pIPointer );
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::CurrentScopeOrMaster
//
//  Synopsis:   Retrieves the current element where the markup pointer is
//              positioned.  If the markup pointer is positioned in a slave
//              markup, returns the master element of that markup.
//
//  Arguments:  pIPointer = Pointer to markup position
//              ppElement = Pointer to returned root or scoped element.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::CurrentScopeOrMaster(  IMarkupPointer  *pIPointer, 
                                    IHTMLElement    **ppElement )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPtr;

    Assert( pIPointer && ppElement );

    IFC( pIPointer->CurrentScope( ppElement ) );

    if( !*ppElement )
    {
        //
        // Whoops.. the regular CurrentScope call failed.. we have
        // to get the flow element based on a display pointer that
        // we position at the markup pointer.  If this doesn't work,
        // then we are in deep, and we return failure to our caller.
        //
        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPtr ) );
        IFC( spDispPtr->MoveToMarkupPointer( pIPointer, NULL ) );
        IFC( spDispPtr->GetFlowElement( ppElement ) );
    }
    
        
Cleanup:

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionRenderingServices
//
//  Synopsis:   Retrieves the selection rendering services off the doc
//
//  Arguments:  ppSelRen = OUT Pointer to selren interface
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionRenderingServices(IHighlightRenderingServices **ppISelRen)
{
    return E_NOTIMPL;    
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetFlowElement
//
//  Synopsis:   Retrieves the flow element at the specified point by creating
//              a display pointer, and calling GetFlowElement.
//
//  Arguments:  pIPointer = Pointer to use for getting flow element
//              ppElement = Flow element to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetFlowElement(IMarkupPointer *pIPointer, IHTMLElement **ppElement)
{
    SP_IDisplayPointer  spIDispPtr;
    HRESULT             hr;

    Assert( pIPointer && ppElement );

    // Create a display pointer, and position it at our markup
    // pointer
    IFC( GetDisplayServices()->CreateDisplayPointer(&spIDispPtr) );
    IFC( spIDispPtr->MoveToMarkupPointer( pIPointer, NULL ) );

    // Retrieve the flow element based on the display pointer
    IFC( spIDispPtr->GetFlowElement(ppElement) );

Cleanup:
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = S_OK;
        *ppElement = NULL;
    }
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::PointersInSameFlowLayout
//
//  Synopsis:   Determines whether the two pointers passed in are contained
//              in the same flow layout.
//
//  Arguments:  pStart = Start position
//              pEnd = End position
//
//  Returns:    BOOL indicating whether or not they are in the same layout
//
//--------------------------------------------------------------------------
BOOL
CHTMLEditor::PointersInSameFlowLayout(  IMarkupPointer  *pStart, 
                                        IMarkupPointer  *pEnd,
                                        IHTMLElement    **ppFlowElement )
{
    BOOL                fInSameFlow = FALSE;
    SP_IHTMLElement     spElementFlowStart;
    SP_IHTMLElement     spElementFlowEnd;
    SP_IObjectIdentity  spIdentity;
    HRESULT             hr;

    if (ppFlowElement)
        *ppFlowElement = NULL;
    
    // Retrieve the flow elements for our pointers
    IFC( GetFlowElement( pStart, &spElementFlowStart ) );
    IFC( GetFlowElement( pEnd, &spElementFlowEnd ) );

    fInSameFlow = SameElements( spElementFlowStart, spElementFlowEnd );
    if (fInSameFlow && ppFlowElement)
    {
        *ppFlowElement = spElementFlowStart;
        spElementFlowStart->AddRef();
    }
        
Cleanup:

    return fInSameFlow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::PointersInSameFlowLayout
//
//  Synopsis:   Determines whether the two display pointers passed in 
//              are contained in the same flow layout.
//
//  Arguments:  pDispStart = Start position
//              pDispEnd = End position
//
//  Returns:    BOOL indicating whether or not they are in the same layout
//
//--------------------------------------------------------------------------
BOOL
CHTMLEditor::PointersInSameFlowLayout(  IDisplayPointer *pDispStart, 
                                        IDisplayPointer *pDispEnd, 
                                        IHTMLElement    **ppFlowElement )
{
    HRESULT             hr;
    SP_IHTMLElement     spElement1, spElement2;
    SP_IObjectIdentity  spIdent;
    BOOL                fSameFlow = FALSE;

    if (ppFlowElement)
        *ppFlowElement = NULL;
    
    IFC( pDispStart->GetFlowElement(&spElement1) );
    IFC( spElement1->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );

    IFC( pDispEnd->GetFlowElement(&spElement2) );

    fSameFlow = SameElements( spElement1, spElement2 );
    if (fSameFlow && ppFlowElement)
    {
        *ppFlowElement = spElement1;
        spElement1->AddRef();
    }

Cleanup:
    return fSameFlow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::IsElementLocked
//
//  Synopsis:   Determines whether the element passed in is locked or not.
//
//  Arguments:  pIElement = Element to check
//              pfLocked = Whether or not the element is locked
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::IsElementLocked(   IHTMLElement    *pIElement,
                                BOOL            *pfLocked )
{
    HRESULT         hr = S_OK;
    SP_IHTMLStyle   spCurStyle;
    CVariant        varLocked;
    BSTR            bstrLocked ; 

    Assert( pIElement && pfLocked );

    if (IsVMLElement(pIElement))
    {
        *pfLocked = TRUE ;
        goto Cleanup;
    }
         
    // Retrieve the current style, and check the design time lock
    // attribute
    IFC( pIElement->get_style( &spCurStyle ) );
    IFC( spCurStyle->getAttribute( _T("Design_Time_Lock"), 0, &varLocked ));

    // Check the result
    if (!varLocked.IsEmpty() )
    {   
        bstrLocked = V_BSTR(&varLocked);
        *pfLocked = ( StrCmpIW(_T("true"), bstrLocked ) == 0);
    }
    else
        *pfLocked = FALSE ;
        
Cleanup:
    RRETURN( hr );        
}

HRESULT
CHTMLEditor::TakeCapture(CEditTracker * pTracker )
{
    HRESULT hr;
    SP_IHTMLElement spElement;
    VARIANT_BOOL varAttach = VB_TRUE;
    SP_IDispatch spDisp;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pSelMan->GetActiveTracker() == pTracker )
    {       
        Assert( ! _pSelMan->IsInCapture() );

        Assert( ! _pICaptureElement );            

        IFC( _pSelMan->GetEditableElement( & spElement ));
        IFC( spElement->QueryInterface( IID_IHTMLElement2, ( void**) & _pICaptureElement ));

        IFC( _pICaptureElement->setCapture( VB_FALSE ));

        //
        // attach all our events
        //
        IFC( _pCaptureHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));

        IFC( _pICaptureElement->attachEvent(_T("onmousedown"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
        IFC( _pICaptureElement->attachEvent(_T("onmouseup"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
           
        IFC( _pICaptureElement->attachEvent(_T("onmousemove"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("oncontextmenu"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("ondblclick"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onkeydown"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onclick"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onlosecapture"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
        
        _pSelMan->SetInCapture( TRUE );

    }  
    else
    {
        hr = E_FAIL;
    }
    
Cleanup:
    if ( hr != S_OK)
    {
        _pSelMan->SetInCapture( FALSE );   
        ClearInterface( & _pICaptureElement );
    }
    
    RRETURN( hr );
}

HRESULT
CHTMLEditor::ReleaseCapture(CEditTracker* pTracker, BOOL fReleaseCapture /*=TRUE*/)
{
    HRESULT hr = S_OK;
    SP_IDispatch spDisp;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pSelMan->GetActiveTracker() == pTracker )
    {       
        Assert( _pSelMan->IsInCapture() );  
        
        Assert( _pICaptureElement);

        IFC( _pCaptureHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));

        IFC( _pICaptureElement->detachEvent(_T("onmousedown"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onmouseup"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onmousemove"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("oncontextmenu"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("ondblclick"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onkeydown"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onclick"),spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onlosecapture"), spDisp ));

        if ( fReleaseCapture )
        {
            IFC( _pICaptureElement->releaseCapture( )); 
        }
        
        _pSelMan->SetInCapture( FALSE );   
        ClearInterface( & _pICaptureElement );

    }
#if DBG == 1
    else
    {
        AssertSz(0,"Trying to release on the wrong tracker");
    }
#endif

Cleanup:
    RRETURN( hr );
}

HRESULT 
CHTMLEditor::AllowSelection(IHTMLElement *pIElement, CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fDisabled;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spElementCookie;
    SP_IHTMLElement3 spElement3;
    SP_IServiceProvider spSP;
    SP_IDocHostUIHandler spHostUIHandler;
    SP_IUnknown spUnkDialog;
    
    IHTMLInputElement *pInput = NULL;
    IHTMLTextAreaElement *pTextArea = NULL;
    RECT myRect;
    BSTR bstrType = NULL;
    DOCHOSTUIINFO Info;
    BOOL    fInDialog = FALSE;

    
    memset(&Info, 0, sizeof(DOCHOSTUIINFO));
    Info.cbSize = sizeof(DOCHOSTUIINFO);

    IFC( _pUnkDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP));
    spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)& spHostUIHandler);
    
    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pEvent );

    if (spHostUIHandler)
        IFC(spHostUIHandler->GetHostInfo(&Info));

    spElement = pIElement;

    //
    // we don't respect the DOCHOSTUIFLAG_DIALOG flag for editable regions
    // unless it's disabled
    // or the element is input file, text, hidden or password ( IE4 legacy)
    // 

    //  Bug 110069: (rolandt) We can't rely on Info.dwFlags with PhotoSuite because
    //  PhotoSuite adds the dialog bit even though not in a dialog and even though
    //  selection should be possible.  AppHack: we will look for IHTMLDialog to determine
    //  whether or not we are in a dialog.  This will not work for cases where they set
    //  the dialog bit when not in a dialog, or when they really want to allow selection
    //  in a dialog, but we are working around this to accomodate their error.  Note: this
    //  used to work in IE5 because we cached the initial info flags on load.  But PhotoSuite
    //  apparently changes the flags after loading and turns on the dialog bit.

    if (g_fInPhotoSuiteIII)
    {
        hr = THR(spSP->QueryService(IID_IHTMLDialog, IID_IUnknown, (void**)&spUnkDialog));
        fInDialog = (hr == S_OK);
    }
    else
    {
        fInDialog = !!(Info.dwFlags & DOCHOSTUIFLAG_DIALOG);
    }

    if (fInDialog)
    {
        BOOL fAllow = TRUE;

        if ( IsEditable(spElement) == S_OK  )
        {
            IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
            IFC(spElement3->get_isDisabled(&fDisabled));
            if (fDisabled)
            {
                fAllow = FALSE;
            }
            else
            {
                if ( SUCCEEDED( spElement->QueryInterface(IID_IHTMLInputElement, (void **)&pInput) ))
                {
                    IFC(pInput->get_type(&bstrType));
                    if (_tcscmp(bstrType, _T("file")) &&
                        _tcscmp(bstrType, _T("text")) &&
                        _tcscmp(bstrType, _T("hidden")) && 
                        _tcscmp(bstrType, _T("password")))
                    {
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                }
            }
        }
        else
        {
            IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fAllow));
            if (fAllow)
            {
                hr = THR(spElement->QueryInterface(IID_IHTMLTextAreaElement, (void **)&pTextArea));
                if (hr)
                {
                    hr = THR(spElement->QueryInterface(IID_IHTMLInputElement, (void **)&pInput));
                    if (hr)
                    {
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                    else
                    {
                        IFC(pInput->get_type(&bstrType));
                        if (_tcscmp(bstrType, _T("file")) &&
                            _tcscmp(bstrType, _T("text")) &&
                            _tcscmp(bstrType, _T("hidden")) && 
                            _tcscmp(bstrType, _T("password")))
                        {
                            hr = S_FALSE;
                            goto Cleanup;
                        }
                    }
                }

                IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                IFC(spElement3->get_isDisabled(&fDisabled));
                if (fDisabled)
                {
                    fAllow = FALSE;
                }
            }
        }
        
        if (!fAllow)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    IGNORE_HR( pEvent->GetElement( &spElementCookie));
    if (spElementCookie)
    {
        SP_IHTMLElement spLayoutElement;
        SP_IHTMLElement2 spElement2;
        
        if ( GetLayoutElement( GetMarkupServices(), spElementCookie, & spLayoutElement ) == S_OK )
        {
            // See if the point falls in the client rect      
            if (_pSelMan->CheckAtomic(spElementCookie) == S_OK)
            {
                // 
                // HACKHACK-IEV6-5244-2000/07/08-zhenbinx 
                //
                // For atomic element, we should allow selection tracker 
                // to be active even the hit-point is outside client area
                // (such as in scroll bar). Otherwise a carettracker would
                // be activated and caret will be placed inside atomic element.
                // A better fix should be checking atomic element whenever
                // a carettracker is positioned. However there are too
                // much to be done under current structure. Consider
                // doing it in next release.
                //
                // Get the IHTMLElement2 interface, and the bounding rect
                //
                IFC( spLayoutElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));    
                IFC( GetBoundingClientRect(spElement2, &myRect) );
            }
            else
            {
                IFC( GetClientRect( spLayoutElement, &myRect ) );
            }

            POINT pt;
            IFC( pEvent->GetPoint( & pt ));
            hr = ::PtInRect(&myRect, pt ) ? S_OK : S_FALSE;        
        }
        else
            hr = S_FALSE;
    }

Cleanup:
    ReleaseInterface(pInput);
    ReleaseInterface(pTextArea);
    SysFreeString(bstrType);
    CoTaskMemFree(Info.pchHostNS);
    CoTaskMemFree(Info.pchHostCss);
    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CHTMLEditor::MakeParentCurrent( IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spParent;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement spMaster;

    spMaster = pIElement;
    IFC( GetParentLayoutElement( GetMarkupServices(), spMaster, & spParent ));

    if ( ! spParent.IsNull())
    {
        IFC( spParent->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
        IGNORE_HR( spElement3->setActive());
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN( hr );
}


HRESULT 
CHTMLEditor::AdjustOut(IMarkupPointer *pPointer, Direction eDir)
{
    HRESULT      hr;
    CEditPointer ep(this);
    DWORD        dwFound;
    DWORD        dwSearchForward = BREAK_CONDITION_OMIT_PHRASE 
                                   - BREAK_CONDITION_ExitBlock
                                   - BREAK_CONDITION_ExitSite;
    DWORD        dwSearchBack = BREAK_CONDITION_OMIT_PHRASE 
                                - BREAK_CONDITION_EnterBlock
                                - BREAK_CONDITION_EnterSite;

    //
    // Adjust out so that we end up outside of block elements and sites
    //
        
    IFC( ep->MoveToPointer(pPointer) );
    IFC( ep.Scan(eDir, dwSearchForward, &dwFound) );
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site))
    {   
        IFC( ep.Scan(Reverse(eDir), dwSearchBack, &dwFound) );

        //
        // Move the markup pointer
        //

        IFC( pPointer->MoveToPointer(ep) );
    }

    // 
    // TODO: 
    // What if there is no next block??? Then this code will
    // not adjust at all. This is buggy.  Besides, it could happen 
    // that there are some phrase elements in between blocks. In this
    // case we might have adjusted too much. See bug #98353
    // 
    // [zhenbinx]
    //

Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::EnterTables(IMarkupPointer *pPointer, Direction eDir)
{
    HRESULT         hr = S_OK;
    CEditPointer    ep(this);
    ELEMENT_TAG_ID  tagId;
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    BOOL            fIgnoreGlyphs = _fIgnoreGlyphs;

    //
    // We don't want to stay in a position that is invalid
    // for display pointer so we always want the real text
    // instead of WCH_GLYPH. 
    //
    _fIgnoreGlyphs = TRUE;

    // Enter tables
    IFC( ep->MoveToPointer(pPointer) );
    for (;;)
    {
        IFC( ep.Scan(eDir, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );

        if (!CheckFlag(dwFound, BREAK_CONDITION_Site) 
           && !CheckFlag(dwFound, BREAK_CONDITION_Block)
           && !CheckFlag(dwFound, BREAK_CONDITION_TextSite)
           && !CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock)		// <COL> </COL> etc. 
           )
        {
            break;
        }

        if (spElement == NULL)
            break;
            
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (!IsTablePart(tagId) && tagId != TAGID_TABLE)
            break;

        // Don't exit TD's
        if (tagId == TAGID_TD && CheckFlag(dwFound, BREAK_CONDITION_ExitSite)) 
            break;

        IFC( pPointer->MoveToPointer(ep) );
    }

Cleanup:
    _fIgnoreGlyphs = fIgnoreGlyphs;

    RRETURN(hr);
}        
                
HRESULT
CHTMLEditor::GetHwnd(HWND* pHwnd)
{
    HRESULT hr;
    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;
    
    IFC( GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
    {
        IFC(spOleWindow->GetWindow( &myHwnd ));
    }
    
Cleanup:    

    *pHwnd = myHwnd;
    
    RRETURN( hr );
}

HRESULT
CHTMLEditor::ConvertRTFToHTML(LPOLESTR pszRtf, HGLOBAL* phglobalHTML)
{
    HRESULT  hr = THR(CRtfToHtmlConverter::StringRtfToStringHtml(NULL, (LPSTR)pszRtf, phglobalHTML));
    RRETURN(hr);
}


CCommand* 
CHTMLEditor::GetCommand(DWORD cmdID)
{
    return GetCommandTable()->Get(cmdID);
}        

HRESULT 
CHTMLEditor::DoTheDarnIE50PasteHTML(IMarkupPointer *pStart, IMarkupPointer *pEnd, HGLOBAL hGlobal)
{
    HRESULT                 hr;
    SP_IHTMLTxtRange        spRange;
    SP_IHTMLElement         spElement;
    SP_IHTMLBodyElement     spBody;
    SP_IOleCommandTarget    spCmdTarget;
    VARIANT                 varargIn;
    GUID                    guidCmdGroup = CGID_MSHTML;

    //
    // Create a text range
    //
    IFC( GetBody(&spElement) );

    IFC( spElement->QueryInterface(IID_IHTMLBodyElement, (void **)&spBody) );
    IFC( spBody->createTextRange(&spRange) );

    //
    // Do the paste
    //

    if (!pEnd)
        pEnd = pStart;
        
    IFC( GetMarkupServices()->MoveRangeToPointers( pStart, pEnd, spRange));

    IFC( spRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&spCmdTarget) );

    V_VT(&varargIn) = VT_BYREF;
    V_BYREF(&varargIn) = (VOID *)hGlobal;
    IFC( spCmdTarget->Exec(&guidCmdGroup, IDM_IE50_PASTE, 0, &varargIn, NULL) );

Cleanup:
    RRETURN(hr);
}


HRESULT 
CHTMLEditor::IsPointerInPre(IMarkupPointer *pPointer, BOOL *pfInPre)
{
    HRESULT                 hr;
    SP_IHTMLComputedStyle   spComputedStyle;
    VARIANT_BOOL            fPre;

    Assert(pfInPre);

    IFC( GetDisplayServices()->GetComputedStyle(pPointer, &spComputedStyle) );
    IFC( spComputedStyle->get_preFormatted(&fPre) );
    if (fPre)
    {
        SP_IHTMLElement spElementScope, spElementPre;
        SP_IHTMLElement spPre;

        IFC( pPointer->CurrentScope(&spElementScope) );
        IFC( FindTagAbove(GetMarkupServices(), spElementScope, TAGID_PRE, &spElementPre, TRUE /*fStopAtLayout*/) );

        *pfInPre = (spElementPre != NULL);
    }
    else
    {
        *pfInPre = FALSE; 
    }

Cleanup:
    RRETURN(hr);    
}

HRESULT 
CHTMLEditor::InsertMaximumText (OLECHAR * pstrText, 
                                LONG cch,
                                IMarkupPointer * pIMarkupPointer )
{   
    HRESULT             hr = S_OK ;
    SP_IHTMLElement     spMaster;
    IHTMLInputElement*  pInputElement = NULL;
    LONG                lActualLen = cch;
    ELEMENT_TAG_ID      eTag ;
    SP_IMarkupPointer	spCurrent, spEnd;
    SP_IMarkupContainer spMarkup;

    IFC (CurrentScopeOrMaster(pIMarkupPointer, &spMaster));
    IFC( GetMarkupServices()->GetElementTagId( spMaster, & eTag ));

    if ( eTag == TAGID_INPUT )
    {
        LONG lMaxLen     =  0 ;
        LONG lContentLen =  0;
        LONG lCharsAllowed  = 0 ;
        MARKUP_CONTEXT_TYPE context;
        BOOL fDone;

        if( lActualLen < 0 )
            lActualLen = pstrText ? _tcslen( pstrText ) : 0;

        // Walk right over text, inital pass, don't move, just get count of chars
        IFC( CreateMarkupPointer(&spCurrent) );
        IFC( CreateMarkupPointer(&spEnd) );

        IFC( pIMarkupPointer->GetContainer(&spMarkup) );

        IFC( spCurrent->MoveToContainer(spMarkup, TRUE /*fStart*/) );   
        IFC( spEnd->MoveToContainer(spMarkup, FALSE /*fStart*/) );

        do
        {
            LONG lLen = -1;     
            IFC( spCurrent->Right(TRUE, &context, NULL, &lLen, NULL) );

            if (context == CONTEXT_TYPE_Text)
                lContentLen += lLen;

            IFC( spCurrent->IsRightOfOrEqualTo(spEnd, &fDone) );
        } while (!fDone);

        IFC (spMaster->QueryInterface(IID_IHTMLInputElement, (void**)&pInputElement));
        IFC (pInputElement->get_maxLength(&lMaxLen));
        lCharsAllowed = lMaxLen - lContentLen;

        if( lActualLen > lCharsAllowed )
            lActualLen = lCharsAllowed;
    
        if( lActualLen <= 0 )
            goto Cleanup;
    }
   
    IFC( GetMarkupServices()->InsertText(pstrText, lActualLen ,pIMarkupPointer) );

Cleanup:
    ReleaseInterface (pInputElement);
    RRETURN( hr );
}  

BOOL 
CHTMLEditor::IsIE50CompatiblePasteMode()
{
    return WHEN_DBG(IsTagEnabled(tagIE50Paste) ||) _fIE50CompatUIPaste;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::IsMasterElement
//
//  Synopsis:   See's if this elmenet is a 'content element' - ie a slave
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsContentElement( IHTMLElement * pIElement )
{
    return EdUtil::IsContentElement( GetMarkupServices(), pIElement );
}    

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetLayoutElement
//
//  Synopsis:   Gets the Master Element
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetMasterElement( IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    return EdUtil::GetMasterElement( GetMarkupServices(), pIElement, ppILayoutElement );
}

IHTMLDocument4* 
CHTMLEditor::GetDoc4()
{
    IHTMLDocument4 *pDoc;
    Assert( _pUnkDoc );
    
    _pUnkDoc->QueryInterface( IID_IHTMLDocument4 , (void **) &pDoc );

    return pDoc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetComputedStyle, public
//
//  Synopsis:   Gets the computed style associated with a particular element
//
//  Arguments:  [pElement] -- Pointer to element
//              [ppComputedStyle] -- Output parameter for computed style
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetComputedStyle(IHTMLElement *pElement, IHTMLComputedStyle **ppComputedStyle)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;

    Assert(ppComputedStyle);
   
    *ppComputedStyle = FALSE;  
    
    IFC( CreateMarkupPointer(&spPointer) );   
    if (FAILED( spPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterBegin) ))
    {
        IFC( spPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    }
    IFC( GetDisplayServices()->GetComputedStyle(spPointer, ppComputedStyle) );

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetElementAttributeCount, public
//
//  Synopsis:   Gets the attribute count associated with a particular element
//
//  Arguments:  [pElement] -- Pointer to element
//              [ppComputedStyle] -- Output parameter for computed style
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetElementAttributeCount(IHTMLElement *pElement, UINT *pCount)
{
    HRESULT                         hr = S_OK;
    SP_IDispatch                    spdispAttrCollection;
    SP_IHTMLAttributeCollection     spAttrCollection;
    SP_IHTMLDOMNode                 spDomNode;
    SP_IDispatch                    spdispAttr;
    SP_IHTMLDOMAttribute            spDomAttr;
    LONG                            lLength;
    VARIANT                         varIndex;
    VARIANT_BOOL                    vBool;
    LONG                            i;

    VariantInit(&varIndex);

    Assert(pElement && pCount);

    *pCount = 0;

    //
    // Get attribute collection
    //
    IFC( pElement->QueryInterface(IID_IHTMLDOMNode, (LPVOID *)&spDomNode) );
    IFC( spDomNode->get_attributes(&spdispAttrCollection) );
    if (spdispAttrCollection == NULL)
        goto Cleanup;
    IFC( spdispAttrCollection->QueryInterface(IID_IHTMLAttributeCollection, (LPVOID *)&spAttrCollection) );

    //
    // Iterate through attributes
    //
    IFC( spAttrCollection->get_length(&lLength) );
    V_VT(&varIndex) = VT_I4;

    for (i = 0; i < lLength; ++i)
    {
        V_I4(&varIndex) = i;

        IFC( spAttrCollection->item(&varIndex, &spdispAttr) );
        IFC( spdispAttr->QueryInterface(IID_IHTMLDOMAttribute, (LPVOID *)&spDomAttr) );

        IFC( spDomAttr->get_specified(&vBool) );
        if (BOOL_FROM_VARIANT_BOOL(vBool))
        {
            *pCount += 1;
        }
    }

Cleanup:
    RRETURN(hr);   
}

//+---------------------------------------------------------------------------
//
//    Member:     IsContainer
//
//    Synopsis:   Return whether the element is a container.
//
//    Arguments:  [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//    TODO: rethink the role of the container here [ashrafm]
//
//----------------------------------------------------------------------------
BOOL
CHTMLEditor::IsContainer(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    Assert(pElement);

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    switch (tagId)
    {
        case TAGID_BODY:
        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_TEXTAREA:
        case TAGID_ROOT:
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: GetOuterMostEditableElement
//
// Synopsis: Given an element - get the outermost elemnet that 's editable.
//           In _fDesignMode - thsi is the Body.
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::GetOuterMostEditableElement( IHTMLElement* pIElement,
                                           IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag;    
    SP_IHTMLElement spCurElement = pIElement;
    SP_IHTMLElement spOuterElement;
    SP_IHTMLElement spParentElement;
    
    Assert( pIElement && ppIElement );

    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));    

    if ( eTag == TAGID_BODY )
    {
        spOuterElement = spCurElement;
    }
    else if ( IsContentElement( pIElement) == S_OK )
    {
        IFC( GetMasterElement( spCurElement, & spOuterElement )); 
    }    
    else 
    {       
        while( IsEditable( spCurElement ) == S_OK &&
               eTag != TAGID_BODY )
        {
            IFC( GetParentElement( spCurElement, & spParentElement ));
            if ( ! spParentElement )
                break;
            spOuterElement = spCurElement;
            spCurElement = spParentElement;            
            IFC( GetMarkupServices()->GetElementTagId( spCurElement , & eTag ));            
        }
        
        if ( eTag == TAGID_BODY || !spParentElement )
            spOuterElement = spCurElement;
        //
        // else spOuterElement was already set to the last thing that was editable.
        //
    }
    
    if ( spOuterElement )
    {
        *ppIElement = (IHTMLElement*) spOuterElement;
        (*ppIElement)->AddRef();
    }
    
Cleanup:    
    RRETURN( hr );
    
}

HRESULT 
CHTMLEditor::GetClientRect(IHTMLElement* pIElement, RECT* pRect )
{
    HRESULT             hr;
    SP_IHTMLElement2    spIHTMLElement2; 
    long                lWidth, lHeight;
    long                lLeft, lTop;
    
    //
    // Get the IHTMLElement2 interface, and the bounding rect
    //
    IFC( pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spIHTMLElement2));    
    IFC( GetBoundingClientRect( spIHTMLElement2, pRect ) );

    // Get our client width and height
    IFC( spIHTMLElement2->get_clientWidth( &lWidth ));
    IFC( spIHTMLElement2->get_clientHeight( &lHeight ));
    IFC( spIHTMLElement2->get_clientLeft( &lLeft ) );
    IFC( spIHTMLElement2->get_clientTop( &lTop ) );

    //
    // Adjust our bounding rect so that only client area is represented
    //
    pRect->left += lLeft;
    pRect->top += lTop;
    pRect->right = pRect->left + lWidth;
    pRect->bottom = pRect->top + lHeight;
                                                     
Cleanup:    
    RRETURN( hr );
}

HRESULT 
CHTMLEditor::GetViewLinkMaster(IHTMLElement *pIElement, IHTMLElement **ppIMasterElement)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;

    Assert(pIElement && ppIMasterElement);

    *ppIMasterElement = NULL;
    
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pIElement, ELEM_ADJ_BeforeBegin) );
    
    IFC( spPointer->GetContainer(&spContainer) );
    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    
    IFC( spContainer2->GetMasterElement(ppIMasterElement) );

Cleanup:
    RRETURN(hr);
}    


HRESULT 
CHTMLEditor::GetContainer(IHTMLElement *pIElement, IMarkupContainer **ppContainer)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;

    Assert(pIElement && ppContainer);

    *ppContainer = NULL;
    
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pIElement, ELEM_ADJ_BeforeBegin) );
    
    IFC( spPointer->GetContainer(ppContainer) );
Cleanup:
    RRETURN(hr);
}    

HRESULT
CHTMLEditor::IsMasterElement( IHTMLElement* pIElement )
{
    return EdUtil::IsMasterElement( GetMarkupServices(), pIElement ) ;
}

HRESULT
CHTMLEditor::IsPointerInMasterElementShadow( IMarkupPointer* pPointer )
{
    return EdUtil::IsPointerInMasterElementShadow( this, pPointer );
}


//
//  Remove Element Segments for Cut/Delete given SelectionRendering services SegmentList
//
HRESULT 
CHTMLEditor::RemoveElementSegments(ISegmentList *pISegmentList)
{
    HRESULT             hr = S_OK;
    CSegmentList       *pSegmentList = NULL ;
    BOOL                fEmpty = FALSE ;
    
    IFC( pISegmentList->AddRef());  
    
    IFC( pISegmentList->IsEmpty( &fEmpty ) );

    if (!fEmpty)
    {
        SP_ISegmentListIterator spIter ;
        SP_ISegmentListIterator spSegIter ;    
        SP_ISegmentList         spSegmentList ;
        SP_IMarkupPointer       spStart, spEnd;

        // Create an iterator
        IFC( pISegmentList->CreateIterator( &spIter ) );

        pSegmentList = new CSegmentList ;
        if (pSegmentList != NULL)
        {
            pSegmentList->SetSelectionType( SELECTION_TYPE_Control );

            while (spIter->IsDone() == S_FALSE)
            {
                SP_ISegment         spSegment ;
                SP_IElementSegment  spElemSegment ;
                SP_IElementSegment  spElemSegmentAdded ;
                SP_IHTMLElement     spElement;

                // Get the current segment, and advance the iterator right away, 
                // since we might blow away our segment in the delete call.
                IFC( spIter->Current(&spSegment) );
                IFC( spSegment->QueryInterface(IID_IElementSegment, (void**)&spElemSegment));
                IFC( spElemSegment->GetElement(&spElement)) ;
                IFC( pSegmentList->AddElementSegment( spElement, &spElemSegmentAdded ) );    
                IFC( spIter->Advance() );
            }

            
            IFC (pSegmentList->QueryInterface(IID_ISegmentList, (void**)&spSegmentList));

            // Create an iterator
            IFC( spSegmentList->CreateIterator( &spSegIter ) );

            // Create some markup pointers
            IFC( CreateMarkupPointer( &spStart ) );
            IFC( CreateMarkupPointer( &spEnd ) );

            while (spSegIter->IsDone() == S_FALSE)
            {
                SP_IElementSegment  spElemSegment ;
                SP_ISegment         spSegment ;
                
                // Get the current segment, and advance the iterator right away, 
                // since we might blow away our segment in the delete call.
                IFC( spSegIter->Current(&spSegment) );
                IFC( spSegIter->Advance() );
                IFC( spSegment->QueryInterface(IID_IElementSegment, (void**)&spElemSegment));
        
                hr = spElemSegment->GetPointers( spStart, spEnd ) ;

                if (hr == S_OK && spStart != NULL && spEnd != NULL)
                {
                    //
                    // Cannot delete or cut unless the range is in the same flow layout
                    //
                    if( PointersInSameFlowLayout( spStart, spEnd, NULL ) )
                    {                 
                        IFC( Delete( spStart, spEnd, FALSE /* fAdjust */ ) );
                    }
                }
                else
                {
                     // container case, where pointers are invalid as they removed from tree by ExitTree, 
                     // safe check as elements are removed already, don't crash
                    hr = S_OK;
                    continue ;
                }
            }                 
        }
    }

Cleanup:
    if (pSegmentList)
        delete pSegmentList ;

    pISegmentList->Release();
    RRETURN (hr);
}

HRESULT 
CHTMLEditor::GetBoundingClientRect(IHTMLElement2 *pElement, RECT *pRect)
{
    HRESULT         hr;
    SP_IHTMLRect    spRect;
    POINT           ptOrigin;
    SP_IHTMLElement spElement;

    IFC( pElement->getBoundingClientRect(&spRect) );
    
    IFC( spRect->get_top(&pRect->top) );
    IFC( spRect->get_bottom(&pRect->bottom) );
    IFC( spRect->get_left(&pRect->left) );
    IFC( spRect->get_right(&pRect->right) );

    IFC( pElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&spElement) );    
    IFC( EdUtil::GetClientOrigin( this, spElement, &ptOrigin) );

    pRect->top += ptOrigin.y;
    pRect->bottom += ptOrigin.y;
    pRect->left += ptOrigin.x;
    pRect->right += ptOrigin.x;

Cleanup:
    RRETURN(hr);
}

HRESULT 
CHTMLEditor::GetMargins(RECT* rcMargins)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spBodyElement;
    SP_IHTMLBodyElement spBody;
    VARIANT             vtMargin;
    
    IFC ( GetBody(&spBodyElement));
    IFC (spBodyElement->QueryInterface(IID_IHTMLBodyElement,(void **)&spBody));

    SetRect(rcMargins, 0,0,0,0);
    
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_leftMargin(&vtMargin)))
    {
        LONG lLeftMargin = 0;

        if (V_VT(&vtMargin) == VT_BSTR)
            lLeftMargin = _wtoi(V_BSTR(&vtMargin));
        
        if (lLeftMargin > 0)
            rcMargins->left = lLeftMargin;        
    }
    VariantClear(&vtMargin);
        
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_topMargin(&vtMargin)))
    {                    
        LONG lTopMargin = 0;
        if (V_VT(&vtMargin) == VT_BSTR)
           lTopMargin = ::_wtoi(V_BSTR(&vtMargin));
        
        if (lTopMargin > 0)
            rcMargins->top = lTopMargin;        
    }
    VariantClear(&vtMargin);

    if (SUCCEEDED(spBody->get_rightMargin(&vtMargin)))
    {
        LONG lRightMargin = 0;

        if (V_VT(&vtMargin) == VT_BSTR)
            lRightMargin = _wtoi(V_BSTR(&vtMargin));
        
        if (lRightMargin > 0)
            rcMargins->right = lRightMargin;        
    }
    VariantClear(&vtMargin);
        
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_topMargin(&vtMargin)))
    {                    
        LONG lBottomMargin = 0;
        if (V_VT(&vtMargin) == VT_BSTR)
           lBottomMargin = ::_wtoi(V_BSTR(&vtMargin));
        
        if (lBottomMargin > 0)
           rcMargins->bottom = lBottomMargin;        
    }
    VariantClear(&vtMargin);

Cleanup :
    RRETURN1 (hr , S_FALSE);
}
        
HRESULT
CHTMLEditor::EnableModeless ( 
            BOOL fEnable) 
{
    RRETURN( _pSelMan->EnableModeless( fEnable ));
}


BOOL 
CHTMLEditor::IgnoreGlyphs(BOOL fIgnoreGlyphs)
{
    BOOL fResult = !!_fIgnoreGlyphs;

    _fIgnoreGlyphs = fIgnoreGlyphs;

    return fResult;
}

HRESULT
CHTMLEditor::MoveToSelectionAnchor (
            IMarkupPointer * pIAnchor )
{
    if ( !_pSelMan || !pIAnchor)
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CHTMLEditor::MoveToSelectionEnd (
            IMarkupPointer* pISelectionEnd )
{
    if ( !_pSelMan || !pISelectionEnd )
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CHTMLEditor::MoveToSelectionAnchorEx (
            IDisplayPointer * pIAnchor )
{
    if ( !_pSelMan || !pIAnchor)
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CHTMLEditor::MoveToSelectionEndEx (
            IDisplayPointer* pISelectionEnd )
{
    if ( !_pSelMan || !pISelectionEnd )
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionEnd(pISelectionEnd));
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetParentElement, public
//
//  Synopsis:   Get the parent element.  If it is NULL, then get the 
//              master element
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetParentElement(IHTMLElement *pSrcElement, IHTMLElement **ppParentElement)
{
    RRETURN( ::GetParentElement(GetMarkupServices(), pSrcElement, ppParentElement) );    
}


BOOL 
CHTMLEditor::DoesSegmentContainText(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fSkipNBSP /* = TRUE */)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spCurrent;
    BOOL                    bEqual;
    MARKUP_CONTEXT_TYPE     context;
    TCHAR                   ch;
    LONG                    cch;

    IFC( CopyMarkupPointer(this, pStart, &spCurrent) );
    
    do
    {
        IFC( spCurrent->IsEqualTo(pEnd, &bEqual) );
        if (bEqual)
            return FALSE; // no text 

        cch = 1;
        IFC( spCurrent->Right(TRUE, &context, NULL, &cch, &ch) );

        if (context == CONTEXT_TYPE_Text)
        {
            if (ch == WCH_NBSP && fSkipNBSP)
                continue;
                
            goto Cleanup;
        }
    } 
    while (context != CONTEXT_TYPE_NoScope);

Cleanup:
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Method:     CHTMLEditor::SetActiveCommandTarget
//
//  Synopsis:   Sets the active CMshtmlEd command target based on the
//              IHTMLDocument2 structure passed in.  The editor keeps an
//              array of CMshtmlEd structures, each one corresponds to
//              a seperate IHTMLDocument2 interface.  Since each IHTMLDocument2
//              has its own seperate selection, the tracker's need to know 
//              the active commadn target in order to add segments to the correct
//              CSelectionServices.
//
//  Arguments:  pIDoc = IHTMLDocument becoming active
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::SetActiveCommandTarget( IMarkupContainer *pIContainer )
{
    HRESULT             hr = S_OK;
    
    Assert( pIContainer );
   
    IFC( FindCommandTarget( pIContainer, &_pActiveCommandTarget ) );

    //
    // Didn't find a command target previously created for this IHTMLDocument.
    // Create one, and make it active
    //
    if( hr == S_FALSE )
    {
        IFC( AddCommandTarget( pIContainer, &_pActiveCommandTarget ) );  
    }

    //
    // Clear cached _pISelectionServices
    //
    ClearInterface( & _pISelectionServices );
    
Cleanup:    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//  Method:     CHTMLEditor::SetActiveCommandTargetFromPointer
//
//  Synopsis:   Sets the active command target based on the
//              pointer passed in.  Usually this is done when the edit context
//              is changing. 
//
//  Arguments:  pIPointer = Pointer to set active doc from
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::SetActiveCommandTargetFromPointer(IMarkupPointer *pIPointer)
{
    HRESULT             hr = S_OK;
    SP_IMarkupContainer spContainerFinal;
    SP_IMarkupContainer spContainer;

    Assert( pIPointer );

    //
    // Get the IMarkupContainer pointer
    //
    IFC( pIPointer->GetContainer( &spContainer ) );
    Assert(spContainer != NULL);

    IFC( AdjustContainerCommandTarget( spContainer, &spContainerFinal ) );

    //
    // Speedup.  Check to see if our active doc is already this one.  Only 
    // set the active doc if this is not true.
    //
    if( !_pActiveCommandTarget || !EqualContainers( spContainerFinal, _pActiveCommandTarget->GetMarkupContainer() ) )
    {
        IFC( SetActiveCommandTarget( spContainerFinal ) );
    }

    //
    // Clear cached _pISelectionServices
    //
    ClearInterface( & _pISelectionServices );
    
Cleanup:    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::ClearCommandTargets
//
//  Synopsis:   Clears the memory used by the CMshtmlEd array.
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::ClearCommandTargets( )
{
    HRESULT         hr = S_OK;
    
    _pActiveCommandTarget = NULL;
    // Clear all the command targets
    _aryActiveCmdTargets.ReleaseAll();

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::FindCommandTarget
//
//  Synopsis:   Finds an command target given an IHTMLDocument
//
//  Arguments:  pIContainer = IMarkupContainer to find command target for
//              ppCmdTarget = OUTPUT - Found command target
//
//  Returns:    S_OK = Found result
//              S_FALSE = Did not find CDocInfo
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::FindCommandTarget(IMarkupContainer *pIContainer, CMshtmlEd **ppCmdTarget)
{
    HRESULT     hr = S_FALSE;
    int         nCount;
    CMshtmlEd   **pTest;

    Assert( pIContainer && ppCmdTarget );

    *ppCmdTarget = NULL;
    
    //
    // Try to find an existing doc info
    //
    for( nCount = _aryActiveCmdTargets.Size(), pTest = _aryActiveCmdTargets;
         nCount > 0;
         nCount--, pTest++)
    {
        //
        // Only check the command targets if they are based off an IMarkupContainer
        // 
        if( (*pTest)->IsDocTarget() &&
            EqualContainers( (*pTest)->GetMarkupContainer(), pIContainer ) )
        {
            *ppCmdTarget = *pTest;
            hr = S_OK;
            break;
        }
    }

#if DBG == 1
    if( hr == S_OK )
    {
        TraceTag( (tagEditingExecRouting, "CHTMLEditor::FindCommandTarget: Found [%x] SelServ [%x]", *ppCmdTarget, (*ppCmdTarget)->GetSelectionServices() ) );
    }
#endif

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AddCommandTarget
//
//  Synopsis:   Adds a new CMshtmlEd for the given IHTMLDocument2 to the
//              array of command targets tracked by the editor.
//
//  Arguments:  pIDoc = IHTMLDocument to add structure for
//              ppCmdTarget = OUTPUT - Added command target
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AddCommandTarget(IMarkupContainer *pIContainer, CMshtmlEd **ppCmdTarget)
{
    HRESULT hr;
    
    Assert( pIContainer && ppCmdTarget);
    
    *ppCmdTarget = new CMshtmlEd(this, FALSE);
    
    if( *ppCmdTarget == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Initialize our command target, allowing it to create its own
    // CSelectionServices
    //
    IFC( (*ppCmdTarget)->Initialize(pIContainer) );

    //
    // Add it to our array ( already add'refed up above )
    //
    IFC( _aryActiveCmdTargets.Append( *ppCmdTarget ) );

    TraceTag( (tagEditingExecRouting, "CHTMLEditor::AddCommandTarget: Added [%x]", *ppCmdTarget ) );

Cleanup:

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::DeleteCommandTarget
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::DeleteCommandTarget(IMarkupContainer *pIContainer)
{
    HRESULT hr;
    CMshtmlEd *pCmdTarget;

    Assert( pIContainer );
    IFC( FindCommandTarget( pIContainer, &pCmdTarget ) );
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (hr == S_OK)
    {
        hr = THR(_aryActiveCmdTargets.DeleteByValue( pCmdTarget ));
        pCmdTarget->Release();
        TraceTag( (tagEditingExecRouting, "CHTMLEditor::DeleteCommandTarget: Deleted [%x]", pCmdTarget ) );
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}




//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AdjutContainerCommandTarget
//
//  Synopsis:   Helper function used to adjust which markup container is 
//              actually used when dealing with swapping in and out of
//              command targets.  Inputs require that we use the
//              parent container for compat reasons.
//
//  Arguments:  pIContainer = candidate IMarkupContainer
//              ppINewContainer = OUTPUT - New container
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AdjustContainerCommandTarget(IMarkupContainer *pIContainer, IMarkupContainer **ppINewContainer)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer2    spContainer2;
    SP_IHTMLElement         spElement;
    ELEMENT_TAG_ID          tagID;
    SP_IMarkupPointer       spPointer;
    
    Assert( pIContainer && ppINewContainer );

    *ppINewContainer = NULL;
    
    // We have an IMarkupContainer based context.  First, figure out if
    // this markup container is owned by an input.  If it is owned by
    // an input then (for compat reasons) we do not want to create
    // a special command target for inputs.  Instead, we want to find
    // or create the command target for the input's parent container.
    // The reason for this is because if a 
    // document.querycommandenabled("cut") is done from the parent document
    // we must return TRUE because this is what IE 5.0 did.

    IFC( pIContainer->QueryInterface( IID_IMarkupContainer2, (void **)&spContainer2 ) );
    IFC( spContainer2->GetMasterElement(&spElement) );

    if( spElement )
    {
        IFC( GetMarkupServices()->GetElementTagId( spElement, &tagID ) );

        if( tagID == TAGID_INPUT )
        {
            IFC( CreateMarkupPointer( &spPointer ) );
            IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) );

            IFC( spPointer->GetContainer( ppINewContainer ) );
        }
        else
        {
            ReplaceInterface( ppINewContainer, pIContainer );
        }
    }
    else
    {
        ReplaceInterface( ppINewContainer, pIContainer );
    }
    

Cleanup:
    RRETURN(hr);
}

HRESULT 
CHTMLEditor::PushCommandTarget(CMshtmlEd *pCommandTarget)
{
    HRESULT hr;
    
    hr = THR( _aryCmdTargetStack.Append( pCommandTarget) );

    RRETURN(hr);
}

HRESULT 
CHTMLEditor::PopCommandTarget(WHEN_DBG(CMshtmlEd *pCommandTarget))
{
    LONG lStackTop = _aryCmdTargetStack.Size()-1;

#if DBG==1
    Assert(pCommandTarget == _aryCmdTargetStack.Item(lStackTop));
#endif

    _aryCmdTargetStack.Delete(lStackTop);

    return S_OK;    
}

CMshtmlEd *
CHTMLEditor::TopCommandTarget()
{
    LONG lStackTop = _aryCmdTargetStack.Size()-1;

    if (lStackTop < 0)
        return NULL;

    return _aryCmdTargetStack.Item(lStackTop);
}


//+====================================================================================
//
// Method: fire On Before Selection type change
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
CHTMLEditor::FireOnSelectionChange(BOOL fIsContextEditable)
{
    HRESULT hr;
    SP_IHTMLDocument4 spDocument4;
    VARIANT_BOOL fRet = VB_TRUE;
    

    if ( fIsContextEditable )
    {    
        IFC(GetDoc()->QueryInterface(IID_IHTMLDocument4, (void **)&spDocument4));       
        IFC(spDocument4->fireEvent(_T("onselectionchange"), NULL, &fRet));
    }
    
Cleanup:

    _dwSelectionVersion++;
    
    return !!fRet;
}

HRESULT
CHTMLEditor::GetUndoManager( IOleUndoManager** ppIUndoManager )
{
    HRESULT hr;
    SP_IServiceProvider spProvider;

    Assert( ppIUndoManager );
    IFC ( _pUnkDoc->QueryInterface(IID_IServiceProvider, (void**) & spProvider ));
    IFC( spProvider->QueryService(SID_SOleUndoManager, IID_IOleUndoManager, (LPVOID *) ppIUndoManager ) );  

Cleanup:
    RRETURN ( hr );
}

HRESULT
CHTMLEditor::DoPendingTasks()
{
    HRESULT hr = S_OK;

    if (!_pSelMan->_fInitialized)
    {
        _pSelMan->Initialize();
    }
    IFC( _pSelMan->DoPendingTasks());
Cleanup:
    RRETURN( hr );
}


VOID
CHTMLEditor::SetDoc( IHTMLDocument2* pIDoc )
{
    //  The Doc maintains the actual timer ids, so we need to make sure to stop the timer
    //  before we switch docs here.  This would only affect us when we try to switch docs
    //  before we receive the timer event, which should kill the timer.  If we don't kill
    //  it here we won't be able to stop the timer later during the timer event.

    Assert(_pSelMan);

    CEditTracker    *pActiveTracker = _pSelMan->GetActiveTracker();

    if (pActiveTracker && _pSelMan->IsInTimer())
    {
        pActiveTracker->StopTimer();
    }
    
    ReplaceInterface( & _pDoc, pIDoc);
}


#ifndef NO_IME
//+====================================================================================
//
// Method:      CHTMLEditor::SetupIMEReconversion
//
// Synopsis:    IME Reconversion is off by default since it is not supported by TridentV2
//              We will query host to see if it wants IME reconversion and enable as 
//              appropriate
//
//              [zhenbinx]
//
//+=====================================================================================
HRESULT
CHTMLEditor::SetupIMEReconversion()
{
    HRESULT                 hr = S_OK;
    SP_IServiceProvider     spSP;
    SP_IDocHostUIHandler    spHostUIHandler;

    //
    // disble it by default
    //
    _fIMEReconversionEnabled = FALSE;

    
    Assert (_pUnkDoc);
    IFC( _pUnkDoc->QueryInterface(IID_IServiceProvider, reinterpret_cast<VOID **>(&spSP)) );
    spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, reinterpret_cast<VOID **>(&spHostUIHandler));
    if (spHostUIHandler)
    {
        DOCHOSTUIINFO           info;

        memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
        info.cbSize = sizeof(DOCHOSTUIINFO);

        //
        // HACKHACK: Photodraw fails GetHostInfo, so we need to 
        // avoid propagating the hr.  (bug 103706)
        // 

        if (SUCCEEDED(spHostUIHandler->GetHostInfo(&info))
            && (info.dwFlags & DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION))
        {
            _fIMEReconversionEnabled = TRUE;
        }

        //
        // CoTaskMemFree can handle NULL case.
        //
        CoTaskMemFree(info.pchHostNS);
        CoTaskMemFree(info.pchHostCss);
    }
    

Cleanup:
    RRETURN(hr);
}

void
CHTMLEditor::InitAppCompatFlags()
{
    char szModule[MAX_PATH + 1];

    if (GetModuleFileNameA(NULL, szModule, MAX_PATH))
    {
        _fInAccess = NULL != StrStrIA(szModule, "msaccess.exe");
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Method:  CHTMLEditor::SetupActiveIMM
//
// Synopsis:
//          Setup local reference to ActiveIMM instance so that the IMM wrapper function works
//          as expected.  
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CHTMLEditor::SetupActiveIMM(IUnknown *pIUnknown)
{
    HRESULT     hr = S_OK;

    if (!_fGotActiveIMM)
    {
        EnterCriticalSection(&g_csActiveIMM);
        if (g_pActiveIMM == NULL)
        {
            Assert (!_fGotActiveIMM);
            
            IIMEServices *pimes = NULL;
            if (pIUnknown)
            {
                hr = THR( pIUnknown->QueryInterface(IID_IIMEServices, reinterpret_cast<void **>(&pimes)) );
            }
            else
            {
                hr = THR( GetDoc()->QueryInterface(IID_IIMEServices, reinterpret_cast<void **>(&pimes)) );
            }
            
            if (SUCCEEDED(hr))
            {
                Assert (pimes);
                IGNORE_HR( pimes->GetActiveIMM(&g_pActiveIMM) );
                ReleaseInterface( pimes );
            }

            if (g_pActiveIMM)
            {
                _fGotActiveIMM  = TRUE;
                g_cRefActiveIMM = 1;
            }
        } 
        else
        {
            Assert(!_fGotActiveIMM);
             _fGotActiveIMM = TRUE;
             g_cRefActiveIMM++;
        }
        LeaveCriticalSection(&g_csActiveIMM);
    }
    
    RRETURN(hr);
}
#endif

HRESULT 
CHTMLEditor::GetBody( IHTMLElement** ppIElement, IHTMLDocument2 * pIDoc /*=NULL */ )
{
    HRESULT hr;

    Assert( ppIElement );

    if ( ! pIDoc ) 
    {
        IFC( GetDoc()->get_body( ppIElement )); 
    }
    else
    {
        IFC( pIDoc->get_body( ppIElement ));
    }
    
    if ( !*ppIElement )
    {
        hr = E_FAIL;
    }
    
Cleanup:
    RRETURN ( hr );
}


//+====================================================================================
//
// See comments on CSelectionManager::FreezeVirtualCaretPos
//
//+=====================================================================================
HRESULT
CHTMLEditor::FreezeVirtualCaretPos(BOOL fReCompute)
{
    if (!_pSelMan)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(_pSelMan->FreezeVirtualCaretPos(fReCompute));
}


//+====================================================================================
//
// See comments on CSelectionManager::UnFreezeVirtualCaretPos
//
//+=====================================================================================
HRESULT
CHTMLEditor::UnFreezeVirtualCaretPos(BOOL fReset)
{
    if (!_pSelMan)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(_pSelMan->UnFreezeVirtualCaretPos(fReset));
}


//+====================================================================================
//
// Make sure CHTMLEditor is in good state
//
//+=====================================================================================
HRESULT 
CHTMLEditor::EnsureEditorState()
{
    HRESULT  hr = S_OK;

    if (!(_pTopDoc && _pUnkDoc && _pUnkContainer))
    {
        TraceTag( (tagEditingInterface, "EDITOR - initialized was not called or failed however interface was called") );
        hr = E_FAIL;
        goto Cleanup;
    }
    IFC( EnsureActiveCommandTarget() );
    IFC( EnsureSelectionMan() );
    
Cleanup:
    RRETURN(hr);
}


//
// Make sure active command target is set correctly
// otherwise reset it to the top level container
//
HRESULT 
CHTMLEditor::EnsureActiveCommandTarget()
{
    HRESULT  hr = S_OK;

    if (!_pActiveCommandTarget)
    {
        SP_IMarkupContainer  spContainerNew;
        SP_IHTMLDocument2    spHtmlDoc;
        
        Assert(_pUnkContainer );
        IFC( _pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainerNew ) );
        IFC( FindCommandTarget( spContainerNew, &_pActiveCommandTarget ) );    
        Assert(_pActiveCommandTarget);

        IFC( spContainerNew->OwningDoc(&spHtmlDoc) );
        SetDoc(spHtmlDoc);
    }
Cleanup:
    RRETURN(hr);
}


//
// Make sure selection manager is initialized
//
HRESULT CHTMLEditor::EnsureSelectionMan()
{
    if (!_pSelMan)
    {
        TraceTag( (tagEditingInterface, "EDITOR - interface called while selman does not exist") );
        return E_FAIL;
    }
    
    if (!_pSelMan->_fInitialized)
    {
        TraceTag( (tagEditingInterface, "EDITOR - interface called while SelMan is not initialized - initialize SelMan") );
        return _pSelMan->Initialize();
    }
    return S_OK;
}



BOOL 
CHTMLEditor::IsInWindow( HWND hwnd, POINT pt, BOOL fConvertToScreen /*=FALSE*/ )
{
    RECT windowRect ;
    POINT myPt;

    myPt.x = pt.x;
    myPt.y = pt.y;

    DeviceFromDocPixels(&myPt);
    
    if ( fConvertToScreen )
        ::ClientToScreen( hwnd, &myPt );

    ::GetWindowRect( hwnd, & windowRect );

    return ( ::PtInRect( &windowRect, myPt ) ); 
}


void 
CHTMLEditor::DocPixelsFromDevice(POINT *pPt)
{
    pPt->x = (pPt->x * _llogicalXDPI) / _ldeviceXDPI; 
    pPt->y = (pPt->y * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(POINT *pPt)
{
    pPt->x = (pPt->x * _ldeviceXDPI) / _llogicalXDPI; 
    pPt->y = (pPt->y * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::DocPixelsFromDevice(SIZE *pSize)
{
    pSize->cx = (pSize->cx * _llogicalXDPI) / _ldeviceXDPI; 
    pSize->cy = (pSize->cy * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(SIZE *pSize)
{
    pSize->cx = (pSize->cx * _ldeviceXDPI) / _llogicalXDPI; 
    pSize->cy = (pSize->cy * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::DocPixelsFromDevice(RECT *pRect)
{
    pRect->left = (pRect->left * _llogicalXDPI) / _ldeviceXDPI; 
    pRect->right = (pRect->right * _llogicalXDPI) / _ldeviceXDPI; 
    pRect->top = (pRect->top * _llogicalYDPI) / _ldeviceYDPI; 
    pRect->bottom = (pRect->bottom * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(RECT *pRect)
{
    pRect->left = (pRect->left * _ldeviceXDPI) / _llogicalXDPI; 
    pRect->right = (pRect->right * _ldeviceXDPI) / _llogicalXDPI; 
    pRect->top = (pRect->top * _ldeviceYDPI) / _llogicalYDPI; 
    pRect->bottom = (pRect->bottom * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::ClientToScreen(HWND hwnd, POINT * pPt)
{
    // return logical coordinates
    DeviceFromDocPixels(pPt);
    ::ClientToScreen(hwnd, pPt);
    DocPixelsFromDevice(pPt);
}

void 
CHTMLEditor::GetWindowRect(HWND hwnd, RECT * pRect)
{
    // return logical coordinates
    ::GetWindowRect(hwnd, pRect);
    DocPixelsFromDevice(pRect);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\inscmd.cxx ===
//+------------------------------------------------------------------------
//
//  File:       InsCmd.cxx
//
//  Contents:   CInsertCommand, CInsertObjectCommand Class implementation
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

extern HRESULT HtmlStringToSignaturedHGlobal (HGLOBAL * phglobal, const TCHAR * pStr, long cch);

using namespace EdUtil;

MtDefine(CInsertCommand, EditCommand, "CInsertCommand")
MtDefine(CInsertObjectCommand, EditCommand, "CInsertObjectCommand")
MtDefine(CInsertParagraphCommand, EditCommand, "CInsertParagraphCommand")

//
// Forward references
//

HRESULT LoadProcedure(DYNPROC *pdynproc);

void DeinitDynamicLibraries();

int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);


//+---------------------------------------------------------------------------
//
//  CInsertCommand Constructor
//
//----------------------------------------------------------------------------

CInsertCommand::CInsertCommand(DWORD cmdId,
                               ELEMENT_TAG_ID etagId,
                               LPTSTR pstrAttribName,
                               LPTSTR pstrAttribValue,  
                                                           CHTMLEditor * pEd )
: CCommand( cmdId, pEd )
{
    _tagId = etagId;

    _bstrAttribName  = pstrAttribName  ? SysAllocString( pstrAttribName  ) : NULL;
    _bstrAttribValue = pstrAttribValue ? SysAllocString( pstrAttribValue ) : NULL;
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand Destructor
//
//----------------------------------------------------------------------------

CInsertCommand::~CInsertCommand()
{
    if (_bstrAttribName)
        SysFreeString( _bstrAttribName );
    
    if (_bstrAttribValue)
        SysFreeString( _bstrAttribValue );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::SetAttributeValue
//
//----------------------------------------------------------------------------

void
CInsertCommand::SetAttributeValue(LPTSTR pstrAttribValue)
{
    Assert(pstrAttribValue);

    if (_bstrAttribValue)
        SysFreeString( _bstrAttribValue );
    
    _bstrAttribValue = SysAllocString( pstrAttribValue );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    CSpringLoader           *psl = GetSpringLoader();
    OLECMD                  cmd;
    CEdUndoHelper           undoUnit(GetEditor());

    IFC( PrivateQueryStatus(&cmd, NULL) );
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;
      
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

    IFC( undoUnit.Begin(IDS_EDUNDONEWCTRL) );

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->CreateIterator( &spIter ));

    while( spIter->IsDone() == S_FALSE )
    {
        BOOL fResult;
        BOOL  fRepositionSpringLoader = FALSE;

        // Get the position of the curren segment
        IFC( spIter->Current(&spSegment) );        
        IFC( spSegment->GetPointers( spStart, spEnd ) );

        if (_tagId == TAGID_HR && psl)
            fRepositionSpringLoader = psl->IsSpringLoadedAt(spStart);

        if ( pvarargIn )
        {
            CVariant var;
            
            IFC( VariantChangeTypeSpecial( & var, pvarargIn, VT_BSTR ) );
            
            IFC( ApplyCommandToSegment( spStart, spEnd, V_BSTR( & var ) ) );
        }
        else
        {
            IFC( ApplyCommandToSegment( spStart, spEnd, NULL ) );
        }

        //
        // Collapse the pointers after the insertion point
        //

        IFC( spStart->IsRightOf( spEnd, & fResult ) );

        if ( fResult )
        {
            IFC( spEnd->MoveToPointer( spStart ) );
        }
        else
        {
            IFC( spStart->MoveToPointer( spEnd ) );
        }

        // Reposition springloader after insertion (63304).
        if (fRepositionSpringLoader)
            psl->Reposition(spEnd);

       IFC( spIter->Advance() );
    }            

Cleanup:
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )
{
    HRESULT             hr;
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    // Make sure the edit context is valid
    if (!(GetCommandTarget()->IsRange()) && GetEditor())
    {
        CSelectionManager *pSelMan;
        
        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            ELEMENT_TAG_ID  tagId;

            IFR( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );

            //From download\htmdesc.cxx:
            //button, input, textarea, a, select are prohinited inside a button. Admittedly, the list is kind of arbitrary.
            if (tagId == TAGID_BUTTON)
            {
                switch (_tagId)
                {
                case TAGID_BUTTON:
                case TAGID_INPUT:
                case TAGID_TEXTAREA:
                case TAGID_SELECT:
                    pCmd->cmdf = MSOCMDSTATE_DISABLED;                
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }


    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;
    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   MapObjectToIntrinsicControl
//
//  Synopsis:   Find a match for pClsId within s_aryIntrinsicsClsid[]
//              If a match is found the IDM command corresponding to 
//              the matched intrinsic control is returned in pdwCmdId
//              otherwise 0 is returned.
//
//-------------------------------------------------------------------------

void
CInsertObjectCommand::MapObjectToIntrinsicControl (CLSID * pClsId, DWORD * pdwCmdId)
{
    int i;

    *pdwCmdId = 0;

    for (i = 0; i < ARRAY_SIZE(s_aryIntrinsicsClsid); i++)
    {
        if ( pClsId->Data1 != s_aryIntrinsicsClsid[i].pClsId->Data1 )
            continue;

        if( IsEqualCLSID( *pClsId, *s_aryIntrinsicsClsid[i].pClsId ) )
        {
            // Match is made, congratulations!
            *pdwCmdId = s_aryIntrinsicsClsid[i].CmdId;
            break;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   SetAttributeFromClsid
//
//  Synopsis:   Sets the attribute value for <OBJECT CLASSID=...> using the 
//              class id.
//
//-------------------------------------------------------------------------
HRESULT
CInsertObjectCommand::SetAttributeFromClsid (CLSID * pClsid )
{   
    HRESULT     hr = S_OK;
    TCHAR       pstrClsid[40];
    int         cch;
    TCHAR       pstrParam[ 128 ];

    //
    // Get the string value of pClsid
    //
    cch = StringFromGUID2( *pClsid, pstrClsid, ARRAY_SIZE(pstrClsid) );
    if (!cch)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Construct the correct syntax for CLASSID attribute value
    //
    hr = StringCchPrintf(pstrParam, ARRAY_SIZE(pstrParam), _T("clsid%s"), pstrClsid);
    if (hr != S_OK)
        goto Cleanup;

    if ( (_T('{') != pstrParam[5+0]) || (_T('}') != pstrParam[5+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }   
    pstrParam[5+0 ] = _T(':');
    pstrParam[5+37] = 0;

    //
    // Set _varAttribValue 
    //

    SetAttributeValue( pstrParam );

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
// Function:    OleUIMetafilePictIconFree
//
// Synopsis:    Deletes the metafile contained in a METAFILEPICT structure and
//              frees the memory for the structure itself.
//
//
//--------------------------------------------------------------------

void
CInsertObjectCommand::OleUIMetafilePictIconFree( HGLOBAL hMetaPict )
{
    LPMETAFILEPICT      pMF;

    if (NULL==hMetaPict)
        return;

    pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict);

    if (NULL!=pMF)
    {
        if (NULL!=pMF->hMF)
            DeleteMetaFile(pMF->hMF);
    }

    GlobalUnlock(hMetaPict);
    GlobalFree(hMetaPict);
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleInsertObjectDialog
//
//  Synopsis:   Executes UI for Insert Object
//
//  Arguments   [in]  hwnd          hwnd passed from Trident
//              [out] dwResult      result of user action specified in UI
//              [out] pstrResult    classid, file name, etc., depending
//                                  on dwResult flags
//
//  Returns:    S_OK                OK hit in UI, pstrResult set
//              S_FALSE             CANCEL hit in UI, NULL == *pstrResult
//              other               failure
//
//-----------------------------------------------------------------------------

DYNLIB g_dynlibOLEDLG = { NULL, NULL, "OLEDLG.DLL" };

DYNPROC g_dynprocOleUIInsertObjectA =
         { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };

HRESULT
CInsertObjectCommand::HandleInsertObjectDialog (HWND hwnd, DWORD * pdwResult, DWORD * pdwIntrinsicCmdId)
{
    HRESULT                 hr = S_OK;
    OLEUIINSERTOBJECTA      ouio;
    CHAR                    szFile[MAX_PATH] = "";
    UINT                    uRC;

    *pdwIntrinsicCmdId = 0;
    *pdwResult = 0;

    //
    // Initialize ouio
    //
    memset(&ouio, 0, sizeof(ouio));
    ouio.cbStruct = sizeof(ouio);
    ouio.dwFlags =
            IOF_DISABLELINK |    
            IOF_SELECTCREATENEW |
            IOF_DISABLEDISPLAYASICON |
            IOF_HIDECHANGEICON |
            IOF_VERIFYSERVERSEXIST |
            IOF_SHOWINSERTCONTROL;
    ouio.hWndOwner = hwnd;
    ouio.lpszFile = szFile;
    ouio.cchFile = ARRAY_SIZE(szFile);

    //
    // Bring up the OLE Insert Object Dialog
    //
    hr = THR(LoadProcedure(&g_dynprocOleUIInsertObjectA));
    if (!OK(hr))
        goto Cleanup;

    uRC = (*(UINT (STDAPICALLTYPE *)(LPOLEUIINSERTOBJECTA))
            g_dynprocOleUIInsertObjectA.pfn)(&ouio);

    hr = (OLEUI_OK     == uRC) ? S_OK :
         (OLEUI_CANCEL == uRC) ? S_FALSE :
                                 E_FAIL;
    if (S_OK != hr)
        goto Cleanup;

    //
    // Process what the user wanted
    //
    Assert((ouio.dwFlags & IOF_SELECTCREATENEW) ||
           (ouio.dwFlags & IOF_SELECTCREATEFROMFILE) ||
           (ouio.dwFlags & IOF_SELECTCREATECONTROL));

    *pdwResult = ouio.dwFlags;

    if ( *pdwResult & IOF_SELECTCREATENEW )
    {
        //
        // For create new object, set the CLASSID=... attribute
        //
        SetAttributeFromClsid ( & ouio.clsid );
    }
    else if ( *pdwResult & IOF_SELECTCREATECONTROL )
    {
        //
        // For create control, first check to see whether the selected
        // control maps to an HTML intrinsic control
        // If there is a match PrivateExec will fire the appropriate IDM
        // insert command based on pdwInstrinsicCmdId, otherwise an 
        // <OBJECT> tag will be inserted.
        //
        MapObjectToIntrinsicControl( & ouio.clsid, pdwIntrinsicCmdId );
        if (! *pdwIntrinsicCmdId )
        {
            SetAttributeFromClsid ( & ouio.clsid );
        }
    }
    // TODO: IOF_SELECTCREATEFROMFILE is not supported

Cleanup:
    if (ouio.hMetaPict)
        OleUIMetafilePictIconFree(ouio.hMetaPict);

    DeinitDynamicLibraries();

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  CInsertObjectCommand Exec
//
//----------------------------------------------------------------------------

HRESULT 
CInsertObjectCommand::PrivateExec( DWORD nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut )
{
    HRESULT     hr;
    HWND        hwndParent;
    DWORD       dwResult;
    DWORD       dwIntrinsicCmdId;
    CCommand *  theCommand = NULL;
    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    ISegmentList* pSegmentList = NULL;
    SP_IOleWindow spOleWindow;
    
    Assert( nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER );

    IFC( GetSegmentList( &pSegmentList ));
    IFR( GetFirstSegmentPointers(pSegmentList, &pStart, &pEnd) );
    IFC( pStart->SetGravity( POINTER_GRAVITY_Left ));
    IFC( pEnd->SetGravity( POINTER_GRAVITY_Right ));
    
    //
    // Get the parent handle
    //
    IFC(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    IFC(spOleWindow->GetWindow(&hwndParent));

    //
    // Bring up the dialog and handle user selections
    //
    hr = THR( HandleInsertObjectDialog( hwndParent, &dwResult, & dwIntrinsicCmdId ) );
    if (hr != S_OK)
    {
        // hr can be S_FALSE, indicating cancelled dialog
        hr = S_OK;
        goto Cleanup;
    }

    //
    // Either insert a new <OBJECT> tag or instantiate an intrinsic
    // control based on the results from HandleInsertObjectDialog()
    // s_aryIntrinsicsClsid[] table is used to map Forms3 controls
    // to their corresponding HTML tags, denoted by the CmdId field. 
    // This table enables us to handle the scenario where user picks
    // a Forms3 control using the Insert Object Dialog. In this case
    // rather than inserting an <OBJECT> with the specified class id,
    // we instantiate the corresponding HTML tag.
    //

    if (dwResult & (IOF_SELECTCREATENEW | IOF_SELECTCREATECONTROL) )
    {
        if (! dwIntrinsicCmdId)
        {
            // 
            // Delegate to super class to insert an <OBJECT> tag
            //
            hr = CInsertCommand::PrivateExec( nCmdexecopt, pvarargIn, pvarargOut );
        }
        else   
        {
            //
            // Delegate to the insertcommand denoted by dwIntrinsicCmdId
            // to insert an intrinsic control
            //
            theCommand = GetEditor()->GetCommandTable()->Get( dwIntrinsicCmdId );

            if ( theCommand )
            {
                hr = theCommand->Exec( nCmdexecopt, pvarargIn, pvarargOut, GetCommandTarget() );
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }

        }
    }
    else if (dwResult & IOF_SELECTCREATEFROMFILE)
    {
        // TODO (alexz): when async download from file for <OBJECT> tag is implemented,
        // this can be done such that html like <OBJECT SRC = "[pstrResult]"> </OBJECT>
        // is used to create the object.
        // Currently the feature left disabled.
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    if ( FAILED(hr) )
        goto Cleanup;

    //
    // Site Select the inserted object
    //
    if ( hr == S_OK )
    {
        GetEditor()->SelectRangeInternal( pStart, pEnd, SELECTION_TYPE_Control, TRUE );
    }
    
Cleanup:
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  CInsertCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::ApplyCommandToSegment( IMarkupPointer * pStart,
                                       IMarkupPointer * pEnd,
                                       TCHAR *          pchVar,
                                       BOOL             fRemove /* = TRUE */ )
{
    HRESULT             hr = S_OK;
    CStr                strAttributes;
    IMarkupServices     *pMarkupServices = GetMarkupServices();
    IHTMLElement        *pIHTMLElement = NULL;
    CEditPointer        edStart( GetEditor(), pStart );
    CEditPointer        edEnd( GetEditor(), pEnd );
    DWORD               dwFound;
    SP_IDisplayPointer  spDispEnd;

    Assert( pStart );

    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispEnd ) );
    
    if (pchVar && *pchVar)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("src") : _T("id") ) );
        IFC( strAttributes.Append( _T("=") ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("\"") : _T("") ) );
        IFC( strAttributes.Append( pchVar ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("\"") : _T("") ) );
    }

    if (_bstrAttribName && _bstrAttribValue)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _bstrAttribName ) );
        IFC( strAttributes.Append( _T("=") ) );
        IFC( strAttributes.Append( _bstrAttribValue ) );
    }

    if (_cmdId == IDM_INSINPUTSUBMIT)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _T("value='Submit Query'") ) );
    }

    // When we insert an NBSP, we need to remember the old end position
    IFC( spDispEnd->MoveToMarkupPointer( pEnd, NULL ) );
    IFC( spDispEnd->SetDisplayGravity( DISPLAY_GRAVITY_PreviousLine ) );
    IFC( spDispEnd->SetPointerGravity( POINTER_GRAVITY_Right ) );
    
    //
    // Setup the edit pointers to cling to text (but if we hit a block pointer, then
    // stop at that boundary.  This behavior correctly fixes 71146 and 90862.
    //

    //
    // also break for NoScope's ( scripts or comments). This fixes 89483
    //

    
    IFC( edStart.SetBoundary( GetEditor()->GetStartEditContext(), pEnd ) );
    IFC( edEnd.SetBoundary( pStart, GetEditor()->GetEndEditContext() ) );

#define BREAK_CONDITION_Insert  (BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_NoScope) - BREAK_CONDITION_EnterBlock 
#define BREAK_CONDITION_InsertBackscan (BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_NoScope) 
    //
    // #108607 -- BREAK_CONDITION_Insert is asymmetric! a reverse
    // scan with same parameter does not stop it at the desired 
    // position! consider the following case:
    //
    //      before{epStart}</P>after
    //
    // A forward scan will position the pointer at 
    //
    //      before</P>{epStart}after 
    //
    // while a reverse scan will position the pointer at 
    //
    //      befor{epStart}e</P>after
    //
    // This is because BREAK_CONDITION_EnterBlock is asymmertic!
    // 
    // [zhenbinx]
    //
    IFC( edStart.Scan(RIGHT, BREAK_CONDITION_Insert, &dwFound) );
    if (!edStart.CheckFlag( dwFound, BREAK_CONDITION_Boundary))
    {
        IFC( edStart.Scan(LEFT, BREAK_CONDITION_InsertBackscan, &dwFound) );
    }

    IFC( edEnd.Scan( LEFT, BREAK_CONDITION_Insert, &dwFound ) );
    if (!edEnd.CheckFlag( dwFound, BREAK_CONDITION_Boundary) )
    {
        IFC( edEnd.Scan(RIGHT, BREAK_CONDITION_InsertBackscan, &dwFound) );
    }
#undef BREAK_CONDITION_Insert 
#undef BREAK_CONDITION_InsertBackscan

   
    if (fRemove)
    {
        IFC( pMarkupServices->Remove( pStart, pEnd ) );

        IFC( ClingToText( pEnd, LEFT, pStart ) );
        IFC( ClingToText( pStart, RIGHT, pEnd ) );
    }

    if (_cmdId == IDM_NONBREAK)
    {
        OLECHAR             ch = WCH_NBSP;
        
        IFC( GetEditor()->InsertMaximumText( &ch, 1, pEnd ) );

        // If we're here becuase the user typed CTRL-SHIFT-SPACE to insert a nbsp, we need to 
        // autodetect for URLs. (see bug 83096). If for some reason we shouldn't be autodetecting,
        // ShouldPerformAutoDetection (called from CAutoUrlDetector::DetectCurrentWord) should
        // catch it.
        IFC( GetEditor()->UrlAutoDetectCurrentWord(pEnd) );

        //
        // When we insert an NBSP, we should position the caret tracker after where the
        // NBSP was inserted (word behavior, bug 96433)
        //
        IFC( GetEditor()->GetSelectionManager()->SetCurrentTracker( TRACKER_TYPE_Caret,
                                                                    spDispEnd, spDispEnd ) );
    }
    else
    {
        IFC( pMarkupServices->CreateElement( _tagId, strAttributes, & pIHTMLElement ) );
        IFC( InsertElement( pMarkupServices, pIHTMLElement, pStart, pEnd ) );
    }

    if (_tagId == TAGID_BR)
    {
        SP_ISegmentList spSegmentList;
        SELECTION_TYPE  eSelectionType;
        
        IFR( GetSegmentList(&spSegmentList) );
        if (spSegmentList != NULL)
        {
            IFR( spSegmentList->GetType( &eSelectionType) );
            if (eSelectionType == SELECTION_TYPE_Caret)
            {
                SP_IHTMLCaret      spCaret;
                
                IFR( GetDisplayServices()->GetCaret(&spCaret) );
                if (spCaret != NULL)
                {
                    SP_IDisplayPointer spDispPointer;

                    IFR( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
                    IFR( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
                    IFR( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    
                    IFR( spCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE) );
                }
            }
        }
    }
    else if(pIHTMLElement                                                   &&
            GetEditor()->IsElementSiteSelectable( pIHTMLElement) == S_OK    &&
            GetEditor()->IsContextEditable()                                && 
            _cmdId != IDM_HORIZONTALLINE ) // don't do this for HR's to make OE happy.
    {
        //
        // Site Select the inserted object
        //
        IFC( pStart->MoveAdjacentToElement( pIHTMLElement , ELEM_ADJ_BeforeBegin ));
        IFC( pEnd->MoveAdjacentToElement( pIHTMLElement , ELEM_ADJ_AfterEnd ));
        IFC( GetEditor()->SelectRangeInternal( pStart, pEnd, SELECTION_TYPE_Control, TRUE));
    }

Cleanup:

    ClearInterface( & pIHTMLElement );

    RRETURN( hr );
}


BOOL 
CInsertCommand::IsValidOnControl()
{
    ELEMENT_TAG_ID          eTag;
    SP_IHTMLElement         spElement;
    BOOL                    fValid = FALSE;
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    IFC( spSegmentList->GetType( &eSelectionType ) );

    if (eSelectionType != SELECTION_TYPE_Control || fEmpty )
        goto Cleanup;

    IFC( spSegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment) );
        IFC( GetSegmentElement(spSegment, &spElement) );

        if (! spElement)
            goto Cleanup;

        IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
        fValid = ( eTag == TAGID_IMG && _cmdId == IDM_IMAGE );
        if ( ! fValid )
            goto Cleanup;

        IFC( spIter->Advance() );
    }        
    
Cleanup:
    return fValid;
}


//+---------------------------------------------------------------------------
//
//  CInsertParagraphCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertParagraphCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr;
    CEdUndoHelper           undoUnit(GetEditor());
    SP_IMarkupPointer       spStart, spEnd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    CStr                    strPara;
    OLECMD                  cmd;  
    HGLOBAL                 hGlobal = 0;

    IFR( PrivateQueryStatus(&cmd, NULL) );
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    IFR( GetSegmentList( &spSegmentList ));        
    IFR( spSegmentList->CreateIterator( &spIter ) );
    
    IFR( undoUnit.Begin(IDS_EDUNDONEWCTRL) );

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

    while( spIter->IsDone() == S_FALSE )
    {
        // Position our pointers to the next segment
        IFR( spIter->Current(&spSegment) );
        IFR( spSegment->GetPointers( spStart, spEnd) );

        if ( pvarargIn )
        {
            CVariant var;
            
            IFR( VariantChangeTypeSpecial(&var, pvarargIn, VT_BSTR) );
            IFR( strPara.Set(_T("<P id=\"")) );
            IFR( strPara.Append(V_BSTR(&var)) );
            IFR( strPara.Append(_T("\"></P>")) );
        }
        else
        {
            IFR( strPara.Set(_T("<P></P>")) );
        }
        
        IFR( HtmlStringToSignaturedHGlobal(&hGlobal, strPara, _tcslen(strPara)) );
        hr = THR( GetEditor()->DoTheDarnIE50PasteHTML(spStart, spEnd, hGlobal) );
        GlobalFree(hGlobal);
        IFR(hr);

        IFR( spIter->Advance() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\isclist.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       ISCLIST.CXX
//
//  Contents:   Implementation of input sequence checker list. Input 
//              Sequence Checkers are used for validating input of languages
//              like Thai, Hindi, and Vietnamese.
//
//  Classes:    CISCList
//
//  History:    10-13-98 - paulnel - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

const IID IID_IInputSequenceChecker = {0x6CF60DE0,0x42DC,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};
const IID IID_IEnumInputSequenceCheckers = {0x6FA9A2A8,0x437A,0x11d2,{0x97,0x12,0x00,0xC0,0x4F,0x79,0xE9,0x8B}};
const IID IID_IInputSequenceCheckerContainer = {0x02D887FA,0x4358,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};
const CLSID CLSID_InputSequenceCheckerContainer = {0x02D887FB,0x4358,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};

MtDefine(CAryISCData_pv, CSelectionManager, "CAryISCData::_pv");

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::CISCList
//
//  Synopsis:   Create the ISC list
//
//-----------------------------------------------------------------------------
CISCList::CISCList()
{
    _lcidCurrent = 0;
    _pISCCurrent = NULL;
    _nISCCount = FillList();
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::~CISCList
//
//  Synopsis:   Release interfaces and destroy the ISC list
//
//-----------------------------------------------------------------------------
CISCList::~CISCList()
{
    ISCDATA* prgISC;
    int i;
    
    for(i = _aryInstalledISC.Size(), prgISC = _aryInstalledISC;
	i > 0;
	i--, prgISC++)
    {
	// We need to make sure to release the ISC interfaces
	ReleaseInterface(prgISC->pISC);
    }
    _aryInstalledISC.DeleteAll();
}


//-----------------------------------------------------------------------------
//
//  Function:   CISCList::FillList
//
//  Synopsis:   Create the list of ISCs from the COM interface (if available)
//
//  Return:     Number of ISCs installed
//
//-----------------------------------------------------------------------------
int CISCList::FillList()
{
    int nListCount = 0;
    LCID lcidCurrent = LOWORD(GetKeyboardLayout(0));

    HRESULT hr = 0;
    IUnknown *pUnk = NULL;
    IInputSequenceCheckerContainer *pISCCont = NULL;
    IEnumInputSequenceCheckers *pEnum = NULL;
    ULONG lRequested = MAX_ISC_COUNT, lFetched;
    ISCDATA pISCEngines[MAX_ISC_COUNT];

    // cocreate the input sequence checker container
    // NT5 bug 298904 - add context CLSCTX_NO_CODE_DOWNLOAD because this
    //                  does not require a download from the Class Store.
    if(g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        hr = CoCreateInstance(CLSID_InputSequenceCheckerContainer, 
                  NULL, 
                  CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                  IID_IUnknown,
                  (void**)&pUnk);
    }
    else
    {
        hr = CoCreateInstance(CLSID_InputSequenceCheckerContainer, 
                  NULL, 
                  CLSCTX_INPROC_SERVER, 
                  IID_IUnknown,
                  (void**)&pUnk);
    }

    if(hr || !pUnk)
	goto Cleanup;

    // get the container interface
    hr = pUnk->QueryInterface(IID_IInputSequenceCheckerContainer, (void**)&pISCCont);

    if(hr || !pISCCont)
	goto Cleanup;

    // enum the input sequence checkers
    hr = pISCCont->EnumISCs(&pEnum);

    if(hr | !pEnum)
	goto Cleanup;

    do
    {
	// fetch any input sequence checkers
	hr = pEnum->Next(lRequested, (ISCDATA*) pISCEngines, &lFetched);

	if(FAILED(hr))
		goto Cleanup;

	for (ULONG i = 0; i < lFetched; i++)
	{       
	    // load ISC interfaces into the list.
	    hr = Add(pISCEngines[i].lcidChecker, pISCEngines[i].pISC);

	    if(!hr)
			nListCount++;
	}

    } while (lFetched != 0);

    // set the ISC to the current keyboard LCID
    SetActive(lcidCurrent);

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pISCCont);
    ReleaseInterface(pEnum);

    return nListCount;
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::SetActive
//
//  Synopsis:   Set the current ISC to the LCID passed in
//
//  Return:     A pointer to the ISC. This will be NULL if an ISC for the 
//              LCID does not exist.
//
//-----------------------------------------------------------------------------
IInputSequenceChecker* CISCList::SetActive(LCID lcidISC)
{
    // make sure to find the ISC first. We will short circuit inside of Find
    // if _lcidCurrent = lcidISC
    _pISCCurrent = Find(lcidISC);
    _lcidCurrent = lcidISC;

    return _pISCCurrent;
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::CheckInputSequence
//
//  Synopsis:   Pass the input character and a buffer of characters before the
//              location of insertion to be analysed for correctness of addition
//              to text store
//
//  Return:     A BOOL indicating whether the input character should be added
//              to the text store
//
//-----------------------------------------------------------------------------
BOOL CISCList::CheckInputSequence(LPTSTR pszISCBuffer, long ich, WCHAR chTest)
{
    BOOL fAccept=TRUE;
    HRESULT hr;

    Assert(_pISCCurrent);
    hr = _pISCCurrent->CheckInputSequence(pszISCBuffer, ich, chTest, &fAccept);

    // We don't want to lock a person out from editing in
    // the event the sequence checker is hosed.
    return (hr == S_OK ? fAccept : TRUE);
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::Add
//
//  Synopsis:   Add an Input Sequence Check data item to the list of checkers.
//
//  Return:     HRESULT indicating success or error condition
//
//-----------------------------------------------------------------------------
HRESULT CISCList::Add(LCID lcidISC, IInputSequenceChecker* pISC)
{
    ISCDATA newISC;
	
    if(pISC == NULL)
	return E_POINTER;

    if(Find(lcidISC))
	return CONNECT_E_ADVISELIMIT;

    newISC.lcidChecker = lcidISC;
    newISC.pISC = pISC;

    return _aryInstalledISC.AppendIndirect(&newISC);
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::Find
//
//  Synopsis:   Find the ISC process that correspondes to an LCID
//
//  Return:     A pointer to the ISC process that corresponds to the LCID. 
//              This will be NULL if an ISC for the LCID does not exist.
//
//-----------------------------------------------------------------------------
IInputSequenceChecker* CISCList::Find(LCID lcidISC)
{
    if(lcidISC == _lcidCurrent)
	return _pISCCurrent;

    ISCDATA* prgISC;
    int i;

    for(i = _aryInstalledISC.Size(), prgISC = _aryInstalledISC;
	i > 0;
	i--, prgISC++)
    {
	if(prgISC->lcidChecker == lcidISC)
	{
	    return prgISC->pISC;
	}
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\iscsa.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Sep 29 10:54:33 1998
 */
/* Compiler settings for ISCSa.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef UNIX
#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ISCSa_h__
#define __ISCSa_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IInputSequenceChecker_FWD_DEFINED__
#define __IInputSequenceChecker_FWD_DEFINED__
typedef interface IInputSequenceChecker IInputSequenceChecker;
#endif 	/* __IInputSequenceChecker_FWD_DEFINED__ */


#ifndef __IEnumInputSequenceCheckers_FWD_DEFINED__
#define __IEnumInputSequenceCheckers_FWD_DEFINED__
typedef interface IEnumInputSequenceCheckers IEnumInputSequenceCheckers;
#endif 	/* __IEnumInputSequenceCheckers_FWD_DEFINED__ */


#ifndef __IInputSequenceCheckerContainer_FWD_DEFINED__
#define __IInputSequenceCheckerContainer_FWD_DEFINED__
typedef interface IInputSequenceCheckerContainer IInputSequenceCheckerContainer;
#endif 	/* __IInputSequenceCheckerContainer_FWD_DEFINED__ */


#ifndef __ISCThai_FWD_DEFINED__
#define __ISCThai_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCThai ISCThai;
#else
typedef struct ISCThai ISCThai;
#endif /* __cplusplus */

#endif 	/* __ISCThai_FWD_DEFINED__ */


#ifndef __InputSequenceCheckerContainer_FWD_DEFINED__
#define __InputSequenceCheckerContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class InputSequenceCheckerContainer InputSequenceCheckerContainer;
#else
typedef struct InputSequenceCheckerContainer InputSequenceCheckerContainer;
#endif /* __cplusplus */

#endif 	/* __InputSequenceCheckerContainer_FWD_DEFINED__ */


#ifndef __EnumInputSequenceCheckers_FWD_DEFINED__
#define __EnumInputSequenceCheckers_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInputSequenceCheckers EnumInputSequenceCheckers;
#else
typedef struct EnumInputSequenceCheckers EnumInputSequenceCheckers;
#endif /* __cplusplus */

#endif 	/* __EnumInputSequenceCheckers_FWD_DEFINED__ */


#ifndef __ISCHindi_FWD_DEFINED__
#define __ISCHindi_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCHindi ISCHindi;
#else
typedef struct ISCHindi ISCHindi;
#endif /* __cplusplus */

#endif 	/* __ISCHindi_FWD_DEFINED__ */


#ifndef __ISCVietnamese_FWD_DEFINED__
#define __ISCVietnamese_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCVietnamese ISCVietnamese;
#else
typedef struct ISCVietnamese ISCVietnamese;
#endif /* __cplusplus */

#endif 	/* __ISCVietnamese_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IInputSequenceChecker_INTERFACE_DEFINED__
#define __IInputSequenceChecker_INTERFACE_DEFINED__

/* interface IInputSequenceChecker */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInputSequenceChecker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CF60DE0-42DC-11D2-BE22-080009DC0A8D")
    IInputSequenceChecker : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLCID( 
            /* [out] */ LCID __RPC_FAR *plcid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckInputSequence( 
            /* [string][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [out] */ BOOL __RPC_FAR *pfValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckAndReplaceInputSequence( 
            /* [size_is][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT cchCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [in] */ UINT cchBuffer,
            /* [size_is][out][in] */ LPWSTR pOutBuffer,
            /* [out] */ UINT __RPC_FAR *pchOutBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputSequenceCheckerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputSequenceChecker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputSequenceChecker __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLCID )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [out] */ LCID __RPC_FAR *plcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckInputSequence )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [string][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [out] */ BOOL __RPC_FAR *pfValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckAndReplaceInputSequence )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [size_is][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT cchCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [in] */ UINT cchBuffer,
            /* [size_is][out][in] */ LPWSTR pOutBuffer,
            /* [out] */ UINT __RPC_FAR *pchOutBuffer);
        
        END_INTERFACE
    } IInputSequenceCheckerVtbl;

    interface IInputSequenceChecker
    {
        CONST_VTBL struct IInputSequenceCheckerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputSequenceChecker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputSequenceChecker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputSequenceChecker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputSequenceChecker_GetLCID(This,plcid)	\
    (This)->lpVtbl -> GetLCID(This,plcid)

#define IInputSequenceChecker_CheckInputSequence(This,pCharBuffer,ichPosition,chEval,pfValue)	\
    (This)->lpVtbl -> CheckInputSequence(This,pCharBuffer,ichPosition,chEval,pfValue)

#define IInputSequenceChecker_CheckAndReplaceInputSequence(This,pCharBuffer,cchCharBuffer,ichPosition,chEval,cchBuffer,pOutBuffer,pchOutBuffer)	\
    (This)->lpVtbl -> CheckAndReplaceInputSequence(This,pCharBuffer,cchCharBuffer,ichPosition,chEval,cchBuffer,pOutBuffer,pchOutBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_GetLCID_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [out] */ LCID __RPC_FAR *plcid);


void __RPC_STUB IInputSequenceChecker_GetLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_CheckInputSequence_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [string][in] */ LPWSTR pCharBuffer,
    /* [in] */ UINT ichPosition,
    /* [in] */ WCHAR chEval,
    /* [out] */ BOOL __RPC_FAR *pfValue);


void __RPC_STUB IInputSequenceChecker_CheckInputSequence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_CheckAndReplaceInputSequence_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [size_is][in] */ LPWSTR pCharBuffer,
    /* [in] */ UINT cchCharBuffer,
    /* [in] */ UINT ichPosition,
    /* [in] */ WCHAR chEval,
    /* [in] */ UINT cchBuffer,
    /* [size_is][out][in] */ LPWSTR pOutBuffer,
    /* [out] */ UINT __RPC_FAR *pchOutBuffer);


void __RPC_STUB IInputSequenceChecker_CheckAndReplaceInputSequence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputSequenceChecker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ISCSa_0209 */
/* [local] */ 

typedef struct  tagISCDATA
    {
    LCID lcidChecker;
    IInputSequenceChecker __RPC_FAR *pISC;
    }	ISCDATA;



extern RPC_IF_HANDLE __MIDL_itf_ISCSa_0209_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ISCSa_0209_v0_0_s_ifspec;

#ifndef __IEnumInputSequenceCheckers_INTERFACE_DEFINED__
#define __IEnumInputSequenceCheckers_INTERFACE_DEFINED__

/* interface IEnumInputSequenceCheckers */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumInputSequenceCheckers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FA9A2A8-437A-11d2-9712-00C04F79E98B")
    IEnumInputSequenceCheckers : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cISCs,
            /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cICSs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputSequenceCheckersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ ULONG cISCs,
            /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ ULONG cICSs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumInputSequenceCheckersVtbl;

    interface IEnumInputSequenceCheckers
    {
        CONST_VTBL struct IEnumInputSequenceCheckersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputSequenceCheckers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputSequenceCheckers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputSequenceCheckers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputSequenceCheckers_Next(This,cISCs,pISCData,pcFetched)	\
    (This)->lpVtbl -> Next(This,cISCs,pISCData,pcFetched)

#define IEnumInputSequenceCheckers_Skip(This,cICSs)	\
    (This)->lpVtbl -> Skip(This,cICSs)

#define IEnumInputSequenceCheckers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputSequenceCheckers_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Next_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [in] */ ULONG cISCs,
    /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumInputSequenceCheckers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Skip_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [in] */ ULONG cICSs);


void __RPC_STUB IEnumInputSequenceCheckers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Reset_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This);


void __RPC_STUB IEnumInputSequenceCheckers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Clone_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumInputSequenceCheckers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputSequenceCheckers_INTERFACE_DEFINED__ */


#ifndef __IInputSequenceCheckerContainer_INTERFACE_DEFINED__
#define __IInputSequenceCheckerContainer_INTERFACE_DEFINED__

/* interface IInputSequenceCheckerContainer */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInputSequenceCheckerContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02D887FA-4358-11D2-BE22-080009DC0A8D")
    IInputSequenceCheckerContainer : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumISCs( 
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputSequenceCheckerContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputSequenceCheckerContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputSequenceCheckerContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputSequenceCheckerContainer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumISCs )( 
            IInputSequenceCheckerContainer __RPC_FAR * This,
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IInputSequenceCheckerContainerVtbl;

    interface IInputSequenceCheckerContainer
    {
        CONST_VTBL struct IInputSequenceCheckerContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputSequenceCheckerContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputSequenceCheckerContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputSequenceCheckerContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputSequenceCheckerContainer_EnumISCs(This,ppEnum)	\
    (This)->lpVtbl -> EnumISCs(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceCheckerContainer_EnumISCs_Proxy( 
    IInputSequenceCheckerContainer __RPC_FAR * This,
    /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IInputSequenceCheckerContainer_EnumISCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputSequenceCheckerContainer_INTERFACE_DEFINED__ */



#ifndef __ISCSALib_LIBRARY_DEFINED__
#define __ISCSALib_LIBRARY_DEFINED__

/* library ISCSALib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ISCSALib;

EXTERN_C const CLSID CLSID_ISCThai;

#ifdef __cplusplus

class DECLSPEC_UUID("6CF60DE1-42DC-11D2-BE22-080009DC0A8D")
ISCThai;
#endif

EXTERN_C const CLSID CLSID_InputSequenceCheckerContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("02D887FB-4358-11D2-BE22-080009DC0A8D")
InputSequenceCheckerContainer;
#endif

EXTERN_C const CLSID CLSID_EnumInputSequenceCheckers;

#ifdef __cplusplus

class DECLSPEC_UUID("BCB80276-4807-11d2-9717-00C04F79E98B")
EnumInputSequenceCheckers;
#endif

EXTERN_C const CLSID CLSID_ISCHindi;

#ifdef __cplusplus

class DECLSPEC_UUID("0666DB29-4823-11d2-9717-00C04F79E98B")
ISCHindi;
#endif

EXTERN_C const CLSID CLSID_ISCVietnamese;

#ifdef __cplusplus

class DECLSPEC_UUID("75624FA1-4826-11d2-9717-00C04F79E98B")
ISCVietnamese;
#endif
#endif /* __ISCSALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\makefile.inc ===
#MIDL= $(DEVTOOLS)\midl.exe

PASS0_HEADERDIR =$(O)
PASS0_SOURCEDIR =$(O)
MIDL_UUIDDIR    =$(O)

$O\OptsHold.idl : $(ROOT)\src\edit\OptsHold.idl
    copy $** $@

$O\OptsHold.h $O\OptsHold.tlb libmain.cxx : OptsHold.idl

#this is not final yet
$O\optshold.tlb : $O\optshold.idl
    $(MIDL) \
!ifndef WIN16
    -Zp8 \
!else
    /Zp2 /DWIN16 /DDOS /DWIN $(MIDL_FLAGS) \
!endif
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\optshold_p.c \
    -dlldata $O\dlldata.c \
    -iid $O\optshold_i.c \
    -header $O\optshold.h \
    -cpp_cmd $(TARGET_CPP) \
    -tlb $(O)\optshold.tlb \
    $(C_DEFINES) \
    $(MIDL_OPTIMIZATION) \
    $O\optshold.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\misccmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       MiscCmd.cxx
//
//  Contents:   Implementation of miscellaneous edit commands
//
//  Classes:    CComposeSettingsCommand
//
//  History:    08-05-98 - OliverSe - created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDUTIL_HXX_
#define _X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CComposeSettingsCommand, EditCommand, "CComposeSettingsCommand");
MtDefine(COverwriteCommand, EditCommand, "COverwriteCommand");
MtDefine(CAutoDetectCommand, EditCommand, "CAutoDetectCommand");
MtDefine(CMovePointerToSelectionCommand, EditCommand, "CMovePointerToSelectionCommand");
MtDefine(CLocalizeEditorCommand, EditCommand, "CLocalizeEditorCommand");
MtDefine(CAutoUrlDetectModeCommand, EditCommand, "CAutoUrlDetectModeCommand");
MtDefine(CIE50PasteModeCommand, EditCommand, "CIE50PasteModeCommand");
MtDefine(CCssEditingLevelCommand, EditCommand, "CCssEditingLevelCommand");
MtDefine(CIMEReconversionCommand, EditCommand, "CIMEReconversionCommand");

CRITICAL_SECTION CComposeSettingsCommand::s_csLastComposeSettings;
BSTR             CComposeSettingsCommand::s_bstrLastComposeSettings = NULL;
BOOL             CComposeSettingsCommand::s_fCSInited = FALSE;

//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::PrivateExec
//
//  Synopsis: Pass compose settings to the springloader
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    // If an inArg and an outArg was specified, this means we are querying the
    // compose font.
    if (pvarargIn && pvarargOut)
    {
        return THR(QueryComposeSettings(pvarargIn, pvarargOut));
    }

    struct COMPOSE_SETTINGS * pComposeSettings = NULL;
    CSpringLoader     * psl = GetSpringLoader();
    IHTMLCaret        * pCaret = NULL;
    IMarkupPointer    * pmpCaret = NULL;
    BOOL                fToggleComposeSettings = FALSE;
    HRESULT             hr;

    Assert(GetEditor());

    //
    // Check parameters.
    //

    if (!pvarargIn || (V_VT(pvarargIn) != VT_BSTR && V_VT(pvarargIn) != VT_BOOL))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    //
    // If specified, parse and memorize compose settings.
    //

    if (V_VT(pvarargIn) == VT_BSTR)
    {
        pComposeSettings = GetEditor()->EnsureComposeSettings();
        if (!pComposeSettings)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        Assert(pvarargIn && V_VT(pvarargIn) == VT_BSTR);

        hr = THR(ParseComposeSettings(V_BSTR(pvarargIn), pComposeSettings));
        if (hr)
            goto Error;

        fToggleComposeSettings = TRUE;
    }
    else
    {
        BOOL fComposeSettings;

        fToggleComposeSettings = TRUE;
        pComposeSettings = GetEditor()->GetComposeSettings(fToggleComposeSettings);

        Assert(pvarargIn && V_VT(pvarargIn) == VT_BOOL);
        fComposeSettings = !!V_BOOL(pvarargIn);

        if (!pComposeSettings || !!pComposeSettings->_fComposeSettings == fComposeSettings)
            goto Cleanup;

        pComposeSettings->_fComposeSettings = fComposeSettings;
    }

    //
    // Springload compose settings at the caret.
    //

    hr = THR(GetDisplayServices()->GetCaret(&pCaret));
    if (hr || !pCaret)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpCaret));
    if (!hr && pmpCaret)
    {
        if (S_OK != THR(pCaret->MoveMarkupPointerToCaret(pmpCaret)))
        {
            ClearInterface(&pmpCaret);
        }
    }

    IGNORE_HR(psl->SpringLoadComposeSettings(pmpCaret, fToggleComposeSettings));

Cleanup:

    if (!fToggleComposeSettings)
    {
        Assert(pvarargIn && V_VT(pvarargIn) == VT_BSTR);
        EnterCriticalSection(&s_csLastComposeSettings);

        if (s_bstrLastComposeSettings)
            SysFreeString(s_bstrLastComposeSettings);

        s_bstrLastComposeSettings = SysAllocString(V_BSTR(pvarargIn));

        LeaveCriticalSection(&s_csLastComposeSettings);
    }

    hr = S_OK;

Error:

    ReleaseInterface(pmpCaret);
    ReleaseInterface(pCaret);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::ParseComposeSettings
//
//  Synopsis:   This function parses the string coming in and sets up the
//              default composition font.
//
//  Params:     [pbstrComposeSettings]: A BSTR containing the string telling
//                                      us the font settings to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::ParseComposeSettings(
    BSTR bstrComposeSettings,
    struct COMPOSE_SETTINGS * pComposeSettings )
{
    typedef enum {
        IT_INT,
        IT_COLOR,
        IT_STRING
    } INFO_TYPE;

    static const struct {
        INFO_TYPE itType;
        DWORD     offset;
    } itParseTable[] = {
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fBold)      },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fItalic)    },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fUnderline) },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _lSize)      },
        {IT_COLOR, offsetof(struct COMPOSE_SETTINGS, _color)      },
        {IT_COLOR, offsetof(struct COMPOSE_SETTINGS, _colorBg)    },
        {IT_STRING,offsetof(struct COMPOSE_SETTINGS, _varFont)    },
        {IT_STRING,offsetof(struct COMPOSE_SETTINGS, _varSpanClass)},
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fUseOutsideSpan)},
    };

    const TCHAR FIELD_SEPARATOR = _T(',');
    const TCHAR COLOR_SEPARATOR = _T('.');
    const INT REQUIRED_FIELDS = 7; // 8th and 9th fields optional
    TCHAR   achComposeFont[LF_FACESIZE];
    TCHAR * pstr;
    TCHAR * pstrEnd;
    DWORD_PTR pDest;
    INT     index;
    HRESULT hr = E_INVALIDARG;

    Assert(pComposeSettings);

    // Setup the default compose settings.
    SetDefaultComposeSettings(pComposeSettings);

    // Get the string.
    pstr = bstrComposeSettings;

    // Index is used to walk the parse table.
    index = 0;

    while (index < ARRAY_SIZE(itParseTable))
    {
        // Skip commas: empty fields indicate that we should use
        // defaults for that field.
        while(   *pstr == FIELD_SEPARATOR
              && *pstr != 0
              && index < ARRAY_SIZE(itParseTable)
             )
        {
            index++;
            pstr++;
        }

        // Last field was omitted, so quit.
        if (index >= ARRAY_SIZE(itParseTable))
            break;

        // Ran out of the string early --> invalid arg, return
        if (*pstr == 0)
        {
            if (index >= REQUIRED_FIELDS)
                hr = S_OK;
            goto Cleanup;
        }

        pstrEnd = NULL;
        pDest = ((DWORD_PTR)pComposeSettings) + itParseTable[index].offset;
        switch (itParseTable[index].itType)
        {
        case IT_INT:
            *((INT *)pDest) = wcstol(pstr, &pstrEnd, 10);
            break;

        case IT_COLOR:
        {

            INT Colors[3];
            INT i;
            for (i = 0; i < 3; i++)
            {
                Colors[i] = wcstol(pstr, &pstrEnd, 10);

                Assert(    *pstrEnd == COLOR_SEPARATOR
                       || (*pstrEnd == FIELD_SEPARATOR && (i == 2))
                      );
                if  (!(    *pstrEnd == COLOR_SEPARATOR
                       || (*pstrEnd == FIELD_SEPARATOR && (i == 2))
                      )
                    )
                    goto Cleanup;

                // RGB values are separated by a '.'. Go past them.
                pstr = pstrEnd + 1;
            }

            // Finally construct the color.
            *((INT *)pDest) = RGB(Colors[0], Colors[1], Colors[2]);
            break;
        }

        case IT_STRING:
        {
            INT    i = 0;
            TCHAR *pDestChar = achComposeFont;
            INT iSize = ARRAY_SIZE(achComposeFont);

            //
            // Loop thru the string till we reach the end or a comma.
            //

            while (*pstr != 0 && *pstr != FIELD_SEPARATOR && i < iSize)
            {
                // Copy the character into the destination
                *pDestChar++ = *pstr++;
                i++;
            }

            // If some character was copied to the destination then we need
            // to put in the NULL terminator. If no character was copied, then
            // we want to leave the destn as it was since, we want to retain
            // the default values in it.
            if (i > 0)
            {
                // If the while loop terminated because we ran out of space
                // in the destination then put the \0 in the last possible space
                // of the destination.
                if (i >= iSize)
                    pDestChar--;

                // Finally, terminate the string.
                *pDestChar = 0;

                {
                    CVariant * pvarDest = (CVariant *)pDest;
                    V_VT(pvarDest) = VT_BSTR;
                    THR(EdUtil::FormsAllocString(achComposeFont, &V_BSTR(pvarDest)));
                }
            }

            // This is where the string field ended.
            pstrEnd = pstr;
            break;
        }

        default:
            AssertSz(0, "Unexpected type");
            goto Cleanup;
        }

        // We are either at the EOI, or end of a field
        Assert(*pstrEnd == 0 || *pstrEnd == FIELD_SEPARATOR);
        if  (!(*pstrEnd == 0 || *pstrEnd == FIELD_SEPARATOR))
            goto Cleanup;

        // Read next field from the string
        index++;

        if (*pstrEnd == 0)
        {
            if (index >= REQUIRED_FIELDS)
                hr = S_OK;
            goto Cleanup;
        }

        pstr = pstrEnd + 1;
    }

    hr = S_OK;

Cleanup:

    // Do we have any compose settings?
    pComposeSettings->_fComposeSettings = hr == S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::SetDefaultComposeSettings
//
//  Synopsis:   This function sets up the default values in compose settings.
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

void
CComposeSettingsCommand::SetDefaultComposeSettings(struct COMPOSE_SETTINGS * pComposeSettings)
{
    Assert(pComposeSettings);

    //
    // By default, no underline, bold or italic
    //

    pComposeSettings->_fBold        = FALSE;
    pComposeSettings->_fItalic      = FALSE;
    pComposeSettings->_fUnderline   = FALSE;
    pComposeSettings->_fSuperscript = FALSE;
    pComposeSettings->_fSubscript   = FALSE;

    // Compose sizes in option settings are in 1-7 range
    pComposeSettings->_lSize        = -1;

    // By default, FG and BG undefined
    pComposeSettings->_color        = VALUE_UNDEF;
    pComposeSettings->_colorBg      = VALUE_UNDEF;

    // By default, fontface and spanclass are undefined.
    VariantClear(&pComposeSettings->_varFont);
    V_VT(&pComposeSettings->_varFont)= VT_NULL;

    VariantClear(&pComposeSettings->_varSpanClass);
    V_VT(&pComposeSettings->_varSpanClass)= VT_NULL;

    // Don't use compose settings everywhere outside span by default.
    pComposeSettings->_fUseOutsideSpan = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::ExtractLastComposeSettings
//
//  Synopsis:   This function extracts the compose settings of a previous
//              document if we don't have any.
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

void
CComposeSettingsCommand::ExtractLastComposeSettings(CHTMLEditor * pEditor, BOOL fEditorHasComposeSettings)
{
    Assert(pEditor);

    if (!s_bstrLastComposeSettings)
        return;

    EnterCriticalSection(&s_csLastComposeSettings);

    if (s_bstrLastComposeSettings)
    {
        //
        // If we don't have compose settings, parse and memorize last compose settings.
        //

        if (!fEditorHasComposeSettings)
        {
            // Ensure compose settings.
            struct COMPOSE_SETTINGS * pComposeSettings = pEditor->EnsureComposeSettings();
            if (pComposeSettings)
            {
                IGNORE_HR(ParseComposeSettings(s_bstrLastComposeSettings, pComposeSettings));
            }
        }

        SysFreeString(s_bstrLastComposeSettings);
        s_bstrLastComposeSettings = NULL;
    }

    LeaveCriticalSection(&s_csLastComposeSettings);
}


//+------------------------------------------------------------------------
//
//  Function:  CComposeSettingsCommand::QueryComposeSettings
//
//  Synopsis:  Return information about the current compose settings
//
//  Arguments: pvarargIn:  Which IDM command to return the value for.
//                         If this is of type VT_UNKNOWN, we interpret
//                         it as a markup pointer, and ask the springloader
//                         whether it would springload at that position.
//
//                         If no markup pointer is passed in, we are
//                         asking about the current (springloaded) font
//                         instead.
//
//             pvarargOut: The value of the IDM command as found in
//                         the compose settings.
//
//  Returns:   VT_NULL in pvarargOut if we don't have compose settings or
//             they don't apply to the position of the markup pointer
//             passed in.
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::QueryComposeSettings( 
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    CHTMLEditor     *pEditor = GetEditor();
    CSpringLoader   *psl = GetSpringLoader();
    HRESULT         hr = S_OK;
    DWORD           cmdId;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD           dwFound = 0;
    
    Assert(pvarargIn && pvarargOut);
    Assert(V_VT(pvarargIn) == VT_I4 || V_VT(pvarargIn) == VT_UNKNOWN);
    Assert(psl);

    V_VT(pvarargOut) = VT_NULL;

    if (VT_UNKNOWN == V_VT(pvarargIn))
    {
        IMarkupPointer * pmpPosition = ((IMarkupPointer *)V_UNKNOWN(pvarargIn));
        psl->OverrideComposeSettings(FALSE);

        if( pmpPosition )
        {
            CEditPointer ep(pEditor, pmpPosition);
        
            if( psl->IsSpringLoadedAt( pmpPosition ) )
            {
                // Return success
                psl->OverrideComposeSettings(TRUE);
                V_VT(pvarargOut) = VT_I4;
                V_I4(pvarargOut) = 1;
            }
            else
            {
                IFC( ep.Scan(LEFT, dwSearch | BREAK_CONDITION_ExitPhrase, &dwFound) );

                // Scan to the right inner-most phrase element, return the formatting there
                if( ep.CheckFlag( dwFound, BREAK_CONDITION_ExitPhrase ) )
                {
                    IFC( ep.Scan(RIGHT, dwSearch | BREAK_CONDITION_EnterPhrase ) );
                    IFC( GetDisplayServices()->GetComputedStyle(ep, &_spComputedStyle) );

                    V_VT(pvarargOut) = VT_I4;
                    V_I4(pvarargOut) = 1;
                }
                    
            }
        }
        else
        {
            if( psl->IsSpringLoaded() )
            {
                // Springloader overrides composesettings.
                psl->OverrideComposeSettings(TRUE);

                // Success
                V_VT(pvarargOut) = VT_I4;
                V_I4(pvarargOut) = 1;
            }
        }
    }
    else if (psl->IsSpringLoaded() && psl->OverrideComposeSettings())
    {
        cmdId = V_I4(pvarargIn);

        switch (cmdId)
        {
            case IDM_BOLD:
            case IDM_ITALIC:
            case IDM_UNDERLINE:
            case IDM_SUPERSCRIPT:
            case IDM_SUBSCRIPT:
            {
                OLECMD cmd;
                IFC( psl->PrivateQueryStatus(cmdId, &cmd) );
                V_I4(pvarargOut) = cmd.cmdf == MSOCMDSTATE_DOWN;
                break;
            }

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
            case IDM_BACKCOLOR:
                IFC( psl->PrivateExec(cmdId, NULL, pvarargOut, NULL) );
                break;
        }
    }
    else
    {
        cmdId = V_I4(pvarargIn);

        switch (cmdId)
        {
            case IDM_BOLD:
            case IDM_ITALIC:
            case IDM_UNDERLINE:
            case IDM_SUPERSCRIPT:
            case IDM_SUBSCRIPT:
            case IDM_FORECOLOR:
            case IDM_BACKCOLOR:
            case IDM_INSERTSPAN:
                AssertSz( FALSE, "CComposeSettings::QueryComposeSettings: Invalid QUERY");
                break;

               
            case IDM_FONTSIZE:
            {
                LONG lFontSize;
                
                V_VT(pvarargOut) = VT_I4;
                IFC( _spComputedStyle->get_fontSize(&lFontSize) );
                V_I4(pvarargOut) = EdUtil::ConvertTwipsToHtmlSize(lFontSize);
                break;
            }

            case IDM_FONTNAME:
            {
                TCHAR szFont[LF_FACESIZE+1];
                
                V_VT(pvarargOut) = VT_BSTR;
                IFC( _spComputedStyle->get_fontName((TCHAR *)&szFont) );
                V_BSTR(pvarargOut) = SysAllocString(szFont);
                if (V_BSTR(pvarargOut) == NULL)
                    hr = E_OUTOFMEMORY;

                break;
            }
        }

    }

Cleanup:

    // Don't return failure, renderer will use default font size
    hr = S_OK;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    if (pCmd)
        pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::Init (static)
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::Init()
{
    HRESULT hr;

    hr = HrInitializeCriticalSection(&s_csLastComposeSettings);
    if (hr)
        goto Cleanup;

    s_fCSInited = TRUE;
    s_bstrLastComposeSettings = NULL;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::Deinit (static)
//
//-------------------------------------------------------------------------

void
CComposeSettingsCommand::Deinit()
{
    if (s_bstrLastComposeSettings)
        SysFreeString(s_bstrLastComposeSettings);

    s_bstrLastComposeSettings = NULL;

    if (s_fCSInited)
    {
        DeleteCriticalSection(&s_csLastComposeSettings);
        s_fCSInited = FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Function: COverwriteCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
COverwriteCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    if (pCmd)
    {
        if (!GetEditor()->GetSelectionManager()->IsContextEditable())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        }
        else
        {        
            pCmd->cmdf = (GetEditor()->GetSelectionManager()->GetOverwriteMode()) 
                                          ? MSOCMDSTATE_DOWN
                                          : MSOCMDSTATE_UP;
        }
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function: COverwriteCommand::PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
COverwriteCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr                 = S_OK;
    CSelectionManager   *pSelectionManager = GetEditor()->GetSelectionManager();
    CVariant            var;

    if (pvarargOut && V_VT(pvarargOut) == VT_BOOL)
    {
        // Output param is specified, return current stat of overwrite flag and bool
        V_BOOL(pvarargOut) = (pSelectionManager->GetOverwriteMode())
                ? VB_TRUE
                : VB_FALSE;
    }
    else
    {
        if (!pSelectionManager->IsContextEditable())
        {
            hr = MSOCMDERR_E_DISABLED;
            goto Cleanup;
        }

        if (pvarargIn)
        {

            // Try to convert the argument to boolean
            IFC( VariantChangeType(&var, pvarargIn, 0, VT_BOOL) );
            if (hr == S_OK)
            {
                pSelectionManager->SetOverwriteMode(V_BOOL(&var) == VB_TRUE);
            }
            else 
            {                
                pSelectionManager->SetOverwriteMode(FALSE);
                hr = S_OK;
            }
        }
        else
        {
            // No input argument was specified, toggle the overwrite flag
            pSelectionManager->SetOverwriteMode(!pSelectionManager->GetOverwriteMode());
        }

    }

Cleanup:
    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function: CAutoDetectCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CAutoDetectCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    pCmd->cmdf = MSOCMDSTATE_UP;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function: CAutoDetectCommand::PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CAutoDetectCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->CreateIterator(&spIter ) );
    
    IFC( GetEditor()->CreateMarkupPointer( & spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment ) );
        IFC( spSegment->GetPointers( spStart, spEnd ) );

        IFC( GetEditor()->GetAutoUrlDetector()->DetectRange( spStart, spEnd, FALSE ) );

        IFC( spIter->Advance() );
    }


Cleanup:
    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function: CLocalizeEditorCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CLocalizeEditorCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CLocalizeEditorCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT     hr;
    HINSTANCE   hinst;

    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    if (V_BOOL(pvarargIn))
    {
        // Use localized resource dll
        IFR( GetEditResourceLibrary(&hinst) );    
        CGetBlockFmtCommand::LoadDisplayNames(hinst);
    }
    else
    {
        // Use local english version
        CGetBlockFmtCommand::LoadDisplayNames(g_hInstance);
    }
    
    return S_OK;    
}

//+------------------------------------------------------------------------
//
//  Function: CAutoUrlDetectModeCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CAutoUrlDetectModeCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CAutoUrlDetectModeCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    Assert(GetEditor()->GetAutoUrlDetector());
    GetEditor()->GetAutoUrlDetector()->SetEnabled(V_BOOL(pvarargIn));
    
    return S_OK;    
}


//+------------------------------------------------------------------------
//
//  Function: CIE50PasteModeCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CIE50PasteModeCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CIE50PasteModeCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    GetEditor()->SetIE50PasteMode(V_BOOL(pvarargIn));
    
    return S_OK;    
}


//+------------------------------------------------------------------------
//
//  Function: CEditingCssLevelCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CCssEditingLevelCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    

//+------------------------------------------------------------------------
//
//  Function: CEditingCssLevelCommand::PrivateExec
//
//  Synopsis: What kind of css can we generate?
//              0 - none
//              1 - must be down level 
//              2 - rich css editing
//
//-------------------------------------------------------------------------

HRESULT 
CCssEditingLevelCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT hr = S_OK;
    VARIANT varLevel;

    VariantInit(&varLevel);

    if (pvarargOut != NULL)
    {
        V_VT(pvarargOut) = VT_I4;
        V_I4(pvarargOut) = GetEditor()->GetCssEditingLevel();
        goto Cleanup;
    }

    if (pvarargIn == NULL)
        return E_INVALIDARG;

    IFC( VariantChangeTypeSpecial(&varLevel, pvarargIn, VT_I4) );
    switch (V_I4(&varLevel))
    {
        case 0:
        case 1:
            GetEditor()->SetCssEditingLevel(V_I4(&varLevel));
            break;

        case 2:
            hr = E_NOTIMPL;
            break;

        default:
            hr = E_INVALIDARG;
            break;                    
    }

Cleanup:
    VariantClear(&varLevel);    
    RRETURN(hr);    
}


//+------------------------------------------------------------------------
//
//  Function: CIMEReconversionCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CIMEReconversionCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = GetEditor()->IsIMEReconversionEnabled() ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;

    return S_OK;
}    


HRESULT 
CIMEReconversionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,     
    VARIANTARG * pvarargOut     
    )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    GetEditor()->EnableIMEReconversion(V_BOOL(pvarargIn));
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\libmain.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       LIBMAIN.CXX
//
//  Contents:   DLL implementation for MSHTMLED
//
//  History:    7-Jan-98   raminh  Created
//             12-Mar-98   raminh  Converted over to use ATL
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#include "optshold_i.c"

#ifndef X_DLGHELPR_H_
#define X_DLGHELPR_H_
#include "dlghelpr.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_EDUTIL_H_
#define X_EDUTIL_H_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_H_
#define X_EDCMD_H_
#include "edcmd.hxx"
#endif

#ifndef X_BLOCKCMD_H_
#define X_BLOCKCMD_H_
#include "blockcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef NO_IME
#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

MtDefine(OpNewATL, Mem, "operator new (mshtmled ATL)")

//
// Misc stuff to keep the linker happy
//
DWORD               g_dwFALSE = 0;          // Used for assert to fool the compiler
EXTERN_C HANDLE     g_hProcessHeap = NULL;  // g_hProcessHeap is set by the CRT in dllcrt0.c
HINSTANCE           g_hInstance = NULL;
HINSTANCE           g_hEditLibInstance = NULL;

BOOL                g_fInVizAct2000;
BOOL                g_fInPhotoSuiteIII;
BOOL                g_fInVid = FALSE ;

#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

// Below is the trick used to make ATL use our memory allocator
void    __cdecl ATL_free(void * pv) { MemFree(pv); }
void *  __cdecl ATL_malloc(size_t cb) { return(MemAlloc(Mt(OpNewATL), cb)); }
void *  __cdecl ATL_realloc(void * pv, size_t cb)
{
    void * pvNew = pv;
    HRESULT hr = MemRealloc(Mt(OpNewATL), &pvNew, cb);
    return(hr == S_OK ? pvNew : NULL);
}

//
// For the Active IMM (aka DIMM)
//
// This object is cocreated inside mshtml.  We need to get the
// pointer from mshtml because DIMM needs to intercept IMM32 calls. Currently
// DIMM functionality is crippled because we never set g_pActiveIMM.
//

#ifndef NO_IME
CRITICAL_SECTION g_csActiveIMM ; // Protect access to IMM
int g_cRefActiveIMM = 0;    // Local Ref Count for acess to IMM
IActiveIMMApp * g_pActiveIMM = NULL;
BOOL HasActiveIMM() { return g_pActiveIMM != NULL; }
IActiveIMMApp * GetActiveIMM() { return g_pActiveIMM; }
#endif

//
// CComModule and Object map for ATL
//

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HtmlDlgHelper, CHtmlDlgHelper)
    OBJECT_ENTRY(CLSID_HtmlDlgSafeHelper, CHtmlDlgSafeHelper)
    OBJECT_ENTRY(CLSID_HTMLEditor, CHTMLEditorProxy)
END_OBJECT_MAP()

#ifdef UNIX
void DeinitDynamicLibraries();
#endif

//+----------------------------------------------------------------------------
//
// Function: DllMain
//
//+----------------------------------------------------------------------------
#ifdef UNIX
extern "C"
#endif
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL fInit = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef UNIX // Unix setup doesn't invoke COM. Need to do it here.
        CoInitialize(NULL);
#endif
        _Module.Init(ObjectMap, hInstance);
        CEditTracker::InitMetrics();
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
#ifdef DLOAD1
        BaseDllHandle = hInstance;
#endif
        if (CGetBlockFmtCommand::Init() != S_OK)
            fInit = FALSE;
        else if (CComposeSettingsCommand::Init() != S_OK)
            fInit = FALSE;
        else if (CRtfToHtmlConverter::Init() != S_OK)
            fInit = FALSE;            

        InitUnicodeWrappers();

        char szModule[MAX_PATH];
        GetModuleFileNameA(NULL, szModule, MAX_PATH);
        g_fInVizAct2000 = NULL != StrStrIA(szModule, "vizact.exe");
        g_fInPhotoSuiteIII = NULL != StrStrIA(szModule, "PhotoSuite.exe");

#if DBG==1

    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif // DBG==1

#ifdef UNIX
        CoUninitialize();
#endif
#ifndef NO_IME
        if (HrInitializeCriticalSection(&g_csActiveIMM) != S_OK)
            fInit = FALSE;
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifndef UNIX    // because of the extern "C" change above
        extern void DeinitDynamicLibraries();
#endif
        _Module.Term();
        CGetBlockFmtCommand::Deinit();
        CComposeSettingsCommand::Deinit();
        CRtfToHtmlConverter::Deinit();
        DeinitDynamicLibraries();

#ifndef NO_IME
        DeleteCriticalSection( & g_csActiveIMM );
#endif        
    }
    return fInit;    
}

//+----------------------------------------------------------------------------
//
// Function: DllCanUnloadNow
//
// Used to determine whether the DLL can be unloaded by OLE
//+----------------------------------------------------------------------------
STDAPI 
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
// Function: DllClassObject
//
// Returns a class factory to create an object of the requested type
//+----------------------------------------------------------------------------
STDAPI 
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

//+----------------------------------------------------------------------------
//
// Function: DllRegisterServer
//
// Adds entries to the system registry
//+----------------------------------------------------------------------------
STDAPI 
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    DbgMemoryTrackDisable(TRUE);
    HRESULT hr = _Module.RegisterServer(TRUE);
    DbgMemoryTrackDisable(FALSE);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Function: DllUnRegisterServer
//
// Removes entries from the system registry
//+----------------------------------------------------------------------------
STDAPI 
DllUnregisterServer(void)
{
    DbgMemoryTrackDisable(TRUE);
    THR_NOTRACE( _Module.UnregisterServer() );
    DbgMemoryTrackDisable(FALSE);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Function:   DllEnumClassObjects
//
//  Synopsis:   Given an index in class object map, returns the
//              corresponding CLSID and IUnknown
//              This function is used by MsHtmpad to CoRegister
//              local class ids. 
//
//----------------------------------------------------------------
STDAPI
DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    HRESULT             hr      = S_FALSE;
    _ATL_OBJMAP_ENTRY * pEntry  = _Module.m_pObjMap;
    
    if (!pEntry)
        goto Cleanup;

    pEntry += i;

    if (pEntry->pclsid == NULL)
        goto Cleanup;

    memcpy(pclsid, pEntry->pclsid, sizeof( CLSID ) );
    hr = THR( DllGetClassObject( *pclsid, IID_IUnknown, (void **)ppUnk) );

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\pastecmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       PASTECMD.CXX
//
//  Contents:   Implementation of Paste command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_PASTECMD_HXX_
#define _X_PASTECMD_HXX_
#include "pastecmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_IME_HXX_
#define X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

ExternTag(tagIE50Paste);

extern LONG edNlstrlenW(LPWSTR pstrIn, LONG cchLimit );

//
// Externs
//

MtDefine(CPasteCommand, EditCommand, "CPasteCommand");
MtDefine(CPasteCharFormatManager_aryCommands_pv, Locals, "PasteCharFormatManager_aryCommands_pv")
MtDefine(CPasteCharFormatManager_formatMap_pv, Locals, "PasteCharFormatManager_formatMap_pv")

//+---------------------------------------------------------------------------
//
//  Member:     ScanForText, helper function
//
//  Synopsis:   Scan right for CONTEXT_TYPE_Text while remaining left of pLimit
//
//  Arguments:  [pPointer] - pointer used for scan
//              [pLimit]   - right limit
//              [pCch]     - pCch for IMarkupPointer::Right
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ScanForText(IMarkupPointer *pPointer, IMarkupPointer *pLimit, LONG *pCch, IMarkupPointer *pLastBlockPointer = NULL)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context;
    BOOL                fNotFound;
    LONG                cch;
    LONG                cchGoal = pCch ? *pCch : -1;
    SP_IHTMLElement     spElement;
    BOOL                fBlock, fLayout;
    
    for (;;)
    {
        cch = cchGoal;
        IFC( pPointer->Right(TRUE, &context, &spElement, &cch, NULL) );        

        switch (context)
        {
            case CONTEXT_TYPE_None:
                hr = S_FALSE; // not found
                goto Cleanup;

            case CONTEXT_TYPE_Text:
                if (pCch)
                    *pCch = cch;
                    
                goto Cleanup; // found

            case CONTEXT_TYPE_EnterScope:                
            case CONTEXT_TYPE_ExitScope:                
                if (pLastBlockPointer)
                {
                    IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );
                    if (fBlock || fLayout)
                    {
                        IFC( pLastBlockPointer->MoveToPointer(pPointer) );
                    }
                }
                break;
        }

        if (pLimit)
        {
            IFC( pPointer->IsRightOfOrEqualTo(pLimit, &fNotFound) );
            if (fNotFound)
            {
                hr = S_FALSE; // not found
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Struct:     CFormatMapInfo 
//
//  Synopsis:   Stores formatting at a particular position in a markup
//
//-----------------------------------------------------------------------------

struct CFormatMapInfo
{
    SP_IHTMLComputedStyle   _spComputedStyle;
    SP_IHTMLComputedStyle   _spBlockComputedStyle;
    LONG                    _cchNext;   // Number of characters to the next CFormatMapInfo
};

//+----------------------------------------------------------------------------
//
//  Class:      CFormatMap
//
//  Synopsis:   Array of CFormatMapInfo's
//
//-----------------------------------------------------------------------------

class CFormatMap : public CDataAry<CFormatMapInfo> 
{
public:
    CFormatMap(PERFMETERTAG mt) : CDataAry<CFormatMapInfo> (mt) 
        {}
        
    CFormatMapInfo *Item(INT i) 
        {return &CDataAry<CFormatMapInfo>::Item(i);}
};

//+----------------------------------------------------------------------------
//
//  Class:      CFormatMapPointer
//
//  Synopsis:   Format map pointer used to move through format map.
//
//-----------------------------------------------------------------------------

class CFormatMapPointer
{
public:
    CFormatMapPointer(CFormatMap *_pFormatMap);

    HRESULT Right(LONG *pCch);
    HRESULT Left(LONG *pCch);

    IHTMLComputedStyle *GetComputedStyle();
    IHTMLComputedStyle *GetBlockComputedStyle();

private:
    INT         _iCurrentFormat; // Index of current CFormatMapInfo
    INT         _icch;           // Character offset into a CFormatMapInfo
    CFormatMap  *_pFormatMap;    // Pointer to the format map
};

//+----------------------------------------------------------------------------
//
//  Class:      CPasteCharFormatManager
//
//  Synopsis:   Preserves character formatting on paste
//
//-----------------------------------------------------------------------------

class CPasteCharFormatManager
{
public:
    CPasteCharFormatManager(CHTMLEditor *pEd);
    ~CPasteCharFormatManager();

    // Remembers formatting in source range
    HRESULT ComputeFormatMap(        
        IMarkupPointer  *pSourceStart, 
        IMarkupPointer  *pSourceFinish);

    // Applies formatting to target
    HRESULT FixupFormatting(
        IMarkupPointer      *pTarget,
        BOOL                 fFixupOrderedList,
        BOOL                 fForceFixup);

private:
    HRESULT ScanForTextStart(IMarkupPointer *pPointer, IMarkupPointer *pLastBlockPointer);
    HRESULT SyncScanForTextEnd(CFormatMapPointer *pSource, IMarkupPointer *pTarget);

public:
    // Used to defer application of commands
    struct CCommandParams
    {
        DWORD             _cmdId;
        IMarkupPointer    *_pStart;
        IMarkupPointer    *_pEnd;
        VARIANT           _varValue;        
    };
    
private:
    CHTMLEditor          *_pEd;      // Editor
    SP_IHTMLTxtRange      _spRange;   // Used to exec commands

    enum FormatType
    {
        FT_Bold,
        FT_Italic,
        FT_Underline,
        FT_Superscript,
        FT_Subscript,
        FT_Strikethrough,
        FT_ForeColor,
        FT_BackColor,
        FT_FontFace,
        FT_FontName,
        FT_FontSize,
        FT_OrderedList,
        FT_NumFormatTypes
    };

    struct
    {
        IMarkupPointer *_pStart;
        VARIANT        _varValue;
    } 
    _rgFixupTable[FT_NumFormatTypes];       // Used to manage fixup ranges

    CDataAry<CCommandParams> _aryCommands;  // Deferred commands
    CFormatMap               _formatMap;    // Source formatting

    IMarkupServices  *GetMarkupServices()  {return _pEd->GetMarkupServices();}
    IDisplayServices *GetDisplayServices() {return _pEd->GetDisplayServices();}
    IHTMLDocument2   *GetDoc()             {return _pEd->GetDoc();}
private:
    HRESULT InitFixupTable();

    HRESULT FixupPosition(
        CFormatMapPointer       *pSource,
        IMarkupPointer          *pTarget,
        IMarkupPointer          *pTargetBlock,
        BOOL                    fFixupOrderedList,
        BOOL                    fForceFixup);

    HRESULT FinishFixup(IMarkupPointer *pTarget, BOOL fFixupOrderedList);

    HRESULT RegisterCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn);
    HRESULT FireCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn);
    HRESULT FireRegisteredCommands();
    HRESULT FixupBoolCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual);
    HRESULT FixupVariantCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual, VARIANT *pvarargIn);
};


//+----------------------------------------------------------------------------
//
//  Functions:  ShouldFixupFormatting
//
//  Synopsis:   Given char and block format for source and target, should we 
//              fixup formatting.
//
//-----------------------------------------------------------------------------

template <class T> BOOL 
ShouldFixupFormatting( T& charFormatSource, T& blockFormatSource, T& charFormatTarget, T& blockFormatTarget, BOOL fForceFixup)
{
    if (charFormatSource == charFormatTarget)
        return FALSE;

    if (blockFormatTarget == blockFormatSource || fForceFixup)
        return TRUE;

    //
    // blockFormatTarget != blockFormatSource
    //

    return (charFormatSource != blockFormatSource);        
}

//+----------------------------------------------------------------------------
//
//  Functions:  ShouldFixupFormatting
//
//  Synopsis:   Given char and block format for source and target, should we 
//              fixup formatting.
//
//-----------------------------------------------------------------------------

BOOL 
ShouldFixupFormatting(
    TCHAR *szCharFormatSource, 
    TCHAR *szBlockFormatSource, 
    TCHAR *szCharFormatTarget, 
    TCHAR *szBlockFormatTarget,
    BOOL   fForceFixup)
{
    //
    // For perf reasons, the caller does this initial check
    //
    
#if 0
    if (_tcscmp(szCharFormatSource, szBlockFormatSource) == 0)
        return FALSE;
#endif

    //
    // Compute block format info
    //

    if (_tcscmp(szBlockFormatTarget, szBlockFormatSource) == 0 || fForceFixup)
        return TRUE;

    //
    // blockFormatTarget != blockFormatSource
    //

    return (_tcscmp(szCharFormatSource, szBlockFormatSource) != 0);      
}

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
Compare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+---------------------------------------------------------------------------
//
//  CPasteCommand::Paste
//
//----------------------------------------------------------------------------

enum FETCINDEX                          // Keep in sync with g_rgFETC[]
{
    iHTML,                              // HTML (in ANSI)
    iRtfFETC,                           // RTF
#ifndef WIN16
    iUnicodeFETC,                       // Unicode plain text
#endif // !WIN16
    iAnsiFETC,                          // ANSI plain text
//    iFilename,                          // Filename
    iRtfAsTextFETC,                     // Pastes RTF as text
    iFileDescA,                         // FileGroupDescriptor
    iFileDescW,                         // FileGroupDescriptorW
    iFileContents                       // FileContents
};

FORMATETC *
GetFETCs ( int * pnFETC )
{
    static int fInitted = FALSE;

    static FORMATETC rgFETC[] =
    {
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_HTML
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTF
    #ifndef WIN16
        { CF_UNICODETEXT,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    #endif
        { CF_TEXT,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTFASTEXT
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORA
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORW
        { 0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_FILECONTENTS
    };

    if (!fInitted)
    {
        fInitted = TRUE;

        Assert( ! rgFETC [ iHTML          ].cfFormat );
        Assert( ! rgFETC [ iRtfFETC       ].cfFormat );
        Assert( ! rgFETC [ iRtfAsTextFETC ].cfFormat );
        Assert( ! rgFETC [ iFileDescA     ].cfFormat );
        Assert( ! rgFETC [ iFileContents  ].cfFormat );

        rgFETC [ iHTML          ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "HTML Format" );
        rgFETC [ iRtfFETC       ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "Rich Text Format" );
        rgFETC [ iRtfAsTextFETC ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "RTF As Text" );
        rgFETC [ iFileDescW     ].cfFormat = (CLIPFORMAT)RegisterClipboardFormat ( CFSTR_FILEDESCRIPTORW );
        rgFETC [ iFileContents  ].cfFormat = (CLIPFORMAT)RegisterClipboardFormat ( CFSTR_FILECONTENTS );
    }

    if (pnFETC)
        *pnFETC= ARRAY_SIZE( rgFETC );

    return rgFETC;
}

extern HGLOBAL TextHGlobalAtoW( HGLOBAL hglobalA );

HRESULT 
CPasteCommand::Paste (
    IMarkupPointer* pStart, IMarkupPointer* pEnd, CSpringLoader * psl, BSTR bstrText /* = NULL */)
{
    HRESULT           hr;
    IMarkupServices * pMarkupServices = GetMarkupServices();
    BOOL              fResult;
    
    //
    // Delete the range first
    //
    IFC( pMarkupServices->Remove( pStart, pEnd ) );

    //
    // If there is nothing to paste we're done
    //
    if (bstrText == NULL || *bstrText == 0)
    {
        return S_OK;
    }

    //
    // InsertSanitized text checks whether we accept html or not
    // and handles CR LF characters appropriately
    //
    IFC( GetEditor()->InsertSanitizedText( bstrText, SysStringLen(bstrText), pStart, pMarkupServices, psl, FALSE ) );

    // Call the url autodetector

    IFC( pStart->IsRightOf(pEnd, &fResult) );

    if (fResult)
    {
        IFC( AutoUrlDetect(pEnd, pStart) );
    }
    else
    {    
        IFC( AutoUrlDetect(pStart, pEnd) );
    }

    // Collapse the range
    IFC( pStart->IsRightOf( pEnd, & fResult ) );
    if ( fResult )
    {
        IFC( pEnd->MoveToPointer( pStart ) );
    }
    else
    {
        IFC( pStart->MoveToPointer( pEnd ) );
    }

Cleanup:
    RRETURN( hr );
}


#ifdef MERGEFUN
//TODO: this function came from the old LDTE code
//
//+----------------------------------------------------------------------------
//
//  Member:     FilterReservedChars
//
//  Synopsis:   Replaces any characters within our reserved unicode range
//              with question marks.
//
//-----------------------------------------------------------------------------


static void
FilterReservedChars( TCHAR * pStrText )
{
    while (*pStrText)
    {
        if (!IsValidWideChar(*pStrText))
        {
            *pStrText = _T('?');
        }
        pStrText++;
    }
}
#endif

HRESULT 
CPasteCommand::PasteFromClipboard (
                    IMarkupPointer *  pPasteStart, 
                    IMarkupPointer *  pPasteEnd, 
                    IDataObject *     pDataObject,
                    CSpringLoader *   psl,
                    BOOL              fForceIE50Compat,
                    BOOL              fClipboardDone)
{
    CHTMLEditor * pEditor = GetEditor();
    IDataObject * pdoFromClipboard = NULL;
    CLIPFORMAT  cf = 0;
    HGLOBAL     hglobal = NULL;
    HRESULT     hr = DV_E_FORMATETC;
    HRESULT     hr2 = S_OK;
    HGLOBAL     hUnicode = NULL;
    int         i;
    int         nFETC;
    STGMEDIUM   medium = {0, NULL};
    FORMATETC * pfetc;
    LPTSTR      ptext = NULL;
    LONG        cCh   = 0;
    IHTMLElement        *   pElement = NULL;
    IHTMLElement        *   pFlowElement = NULL;
    VARIANT_BOOL            fAcceptsHTML;
    LPSTR                   pszRtf;
    IMarkupServices     *   pMarkupServices = pEditor->GetMarkupServices();
    IMarkupPointer      *   pRangeStart   = NULL;
    IMarkupPointer      *   pRangeEnd     = NULL;
    IDataObject         *   pdoFiltered = NULL;
    IDocHostUIHandler   *   pHostUIHandler = NULL;
    SP_IServiceProvider     spSP;
    SP_IHTMLElement3        spElement3;
    BOOL                    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    //
    // Set up a pair of pointers for URL Autodetection after the insert
    //
    IFC( GetEditor()->CreateMarkupPointer( &pRangeStart ) );
    IFC( pRangeStart->MoveToPointer( pPasteStart ) );
    IFC( pRangeStart->SetGravity( POINTER_GRAVITY_Left ) );        

    IFC( GetEditor()->CreateMarkupPointer( &pRangeEnd ) );
    IFC( pRangeEnd->MoveToPointer( pPasteStart ) );
    IFC( pRangeEnd->SetGravity( POINTER_GRAVITY_Right ) );

    pfetc = GetFETCs ( & nFETC );

    Assert( pfetc );

    if (!pDataObject)
    {
        hr2 = OleGetClipboard( & pdoFromClipboard );
        
        if (hr2 != NOERROR)
        {
            hr = hr2;
            goto Cleanup;
        }

        Assert( pdoFromClipboard );

        //
        // See if the host handler wants to give us a massaged data object.
        //
        
        IFC(GetDoc()->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP));
        spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)&pHostUIHandler);

        pDataObject = pdoFromClipboard;
        
        if (pHostUIHandler)
        {
            //
            // The host may want to massage the data object to block/add
            // certain formats.
            //
            
            hr = THR( pHostUIHandler->FilterDataObject( pDataObject, & pdoFiltered ) );
            
            if (!hr && pdoFiltered)
            {
                pDataObject = pdoFiltered;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    if ( pPasteEnd )
    {
        IFC( pMarkupServices->Remove( pPasteStart, pPasteEnd ) );
    }

    if (fClipboardDone)
        goto Cleanup;
        
    //
    // Check if we accept HTML
    //
    IFC( GetEditor()->GetFlowElement(pPasteStart, & pFlowElement) );

    if (! pFlowElement)
    {
        //
        // Elements that do not accept HTML, e.g. TextArea, always have a flow layout.
        // If the element does not have a flow layout then it might have been created
        // using the DOM (see bug 42685). Set fAcceptsHTML to true.
        //
        fAcceptsHTML = TRUE;
    }
    else
    {
        IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
        IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    }
    
    for( i = 0; i < nFETC; i++, pfetc++ )
    {
        // make sure the format is either 1.) a plain text format
        // if we are in plain text mode or 2.) a rich text format
        // or 3.) matches the requested format.

        if( cf && cf != pfetc->cfFormat )
        {
            continue;
        }

        //
        // If we don't accept HTML and i does not correspond to text format
        // skip it
        //
#ifndef WIN16
        if ( fAcceptsHTML || i == iAnsiFETC || i == iUnicodeFETC )
#else
        if ( fAcceptsHTML || i == iAnsiFETC )                        
#endif // !WIN16
        {
            //
            // make sure the format is available
            //
            if( pDataObject->QueryGetData(pfetc) != NOERROR )
            {
                continue;
            }

            //
            // If we have one of the formats that uses an hglobal get it
            // and lock it.
            //
            if (
#ifndef NO_RTF
                i == iRtfAsTextFETC ||  i == iRtfFETC ||
#endif
                i == iAnsiFETC ||
#ifndef WIN16
                i == iUnicodeFETC ||
#endif // !WIN16
                i == iHTML )
            {
                if( pDataObject->GetData(pfetc, &medium) == NOERROR )
                {
                    Assert(medium.tymed == TYMED_HGLOBAL);

                    hglobal = medium.hGlobal;
                    ptext = (LPTSTR)GlobalLock(hglobal);
                    if( !ptext )
                    {
                        ReleaseStgMedium(&medium);
                        return E_OUTOFMEMORY;
                    }
                }
                else
                {
                    continue;
                }
            }

            switch(i)
            {
            case iHTML:
            {
                if (fForceIE50Compat || GetEditor()->IsIE50CompatiblePasteMode())
                {
                    IFC( GetEditor()->DoTheDarnIE50PasteHTML(pPasteStart, pPasteEnd, hglobal) );
                }
                else
                {
                    IFC( HandleUIPasteHTML(pPasteStart, pPasteEnd, hglobal) );
                }

                goto Cleanup;
            }
            case iRtfFETC:
            {
                BOOL fEnabled = IsRtfConverterEnabled(pHostUIHandler);
                if (!fEnabled)
                    continue;
                
                pszRtf = LPSTR( GlobalLock( hglobal ) );

                if(!pszRtf)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(GetEditor()->ConvertRTFToHTML((LPOLESTR)pszRtf, &hglobal));


                if (!hr)
                {
                    //
                    // RTF conversion worked
                    //

                    if (fForceIE50Compat || GetEditor()->IsIE50CompatiblePasteMode())
                    {
                        IFC( GetEditor()->DoTheDarnIE50PasteHTML(pPasteStart, pPasteEnd, hglobal) );
                    }
                    else
                    {
                        IFC( HandleUIPasteHTML(pPasteStart, pPasteEnd, hglobal) );
                    }

                }
                else
                {
                    // RTF conversion failed, try the next format
                    hr = DV_E_FORMATETC;
                    continue;
                }

                goto Cleanup;
            }

            case iRtfAsTextFETC:
            case iAnsiFETC:         // ANSI plain text. If data can be stored

                hUnicode = TextHGlobalAtoW(hglobal);

                if (hUnicode)
                {
                    ptext = (LPTSTR)GlobalLock(hUnicode);
                    if(!ptext)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    //FilterReservedChars(ptext);


                    //
                    // Review-2000/07/25-zhenbinx: 
                    //
                    // We still expect ptext to be NULL terminated!!! GlobalSize does not really return the exact 
                    // bytes allocated. Here we just want to make sure the strlen code does not step over other's 
                    // memory space in case ptext is not NULL terminated.   (zhenbinx)
                    //
                    cCh = edNlstrlenW(ptext, GlobalSize(hUnicode)/sizeof(WCHAR));
                    hr = THR( GetEditor()->InsertSanitizedText( ptext, cCh, pPasteStart, pMarkupServices, psl, FALSE ) );
                    
                    IGNORE_HR( AutoUrlDetect(pRangeStart, pRangeEnd) );
                    
                    GlobalUnlock(hUnicode);
                }

                goto Cleanup;

            case iUnicodeFETC:                          // Unicode plain text

                ptext   = (LPTSTR)GlobalLock(hglobal);
                if(!ptext)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                //FilterReservedChars(ptext);

                //
                // Review-2000/07/25-zhenbinx: 
                //      Better be NULL terminated! Otherwise we might insert
                //      extra text since GlobalSize could be aligned to some
                //      memory boundary. 
                //
                cCh= edNlstrlenW(ptext, GlobalSize(hglobal)/sizeof(WCHAR));
                hr = THR( GetEditor()->InsertSanitizedText( ptext, cCh, pPasteStart, pMarkupServices, psl, FALSE ) );

                IGNORE_HR( AutoUrlDetect(pRangeStart, pRangeEnd) );

                goto Cleanup;
            }

            //Break out of the for loop
            break;
        }
    }

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    ReleaseInterface( pRangeStart );
    ReleaseInterface( pRangeEnd );

    ReleaseInterface( pElement );
    ReleaseInterface( pFlowElement );

    ReleaseInterface( pdoFiltered );
    ReleaseInterface( pHostUIHandler );

    ReleaseInterface( pdoFromClipboard );

    if (hUnicode)
    {
        GlobalFree(hUnicode);
    }

    //If we used the hglobal unlock it and free it.
    if(hglobal)
    {
        GlobalUnlock(hglobal);
        ReleaseStgMedium(&medium);
    }

    return hr;
}


HRESULT
CPasteCommand::InsertText(OLECHAR         * pchText,
                          long              cch,
                          IMarkupPointer  * pPointerTarget,
                          CSpringLoader   * psl)
{
    // Fire the spring loader.
    if (psl)
    {
        Assert(pPointerTarget);

        IGNORE_HR(psl->Fire(pPointerTarget));
    }

    RRETURN( THR( GetEditor()->InsertMaximumText( pchText, cch, pPointerTarget ) ) );
}


//+---------------------------------------------------------------------------
//
//  CPasteCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CPasteCommand::PrivateExec( 
                    DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn,
                    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentListIterator spIter;
    SP_ISegmentList         spSegmentList;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    CHTMLEditor             *pEditor = GetEditor();
    CEdUndoHelper           undoUnit(pEditor);
    BOOL                    fEmpty = FALSE;
    int                     iCount = 0;
    
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    if (IsSelectionActive())
        return S_OK; // don't paste into an active selection

    if( GetEditor()->GetSelectionManager()->IsIMEComposition() )
        IFC( GetEditor()->GetSelectionManager()->TerminateIMEComposition(TERMINATE_NORMAL) );

    //
    // Get the segment etc., let's get busy
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    IFC (GetSegmentCount(spSegmentList, &iCount));

    // multiple selection and paste, will put the insertion point at the 
    // start of the body element
    if (eSelectionType == SELECTION_TYPE_Control && iCount > 1)
    {
        SP_IDisplayPointer spDispCtlTemp;
        SP_IMarkupPointer  spPointer ;
        SP_IHTMLElement    spElement ;
        
        IFC (GetEditor()->GetBody( &spElement ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( spPointer->MoveAdjacentToElement( spElement,ELEM_ADJ_AfterBegin));
   
        IFC( pEditor->GetSelectionManager()->GetDisplayServices()->CreateDisplayPointer(&spDispCtlTemp) );
        IFC( spDispCtlTemp->MoveToMarkupPointer(spPointer, NULL) );       
        IFC( spDispCtlTemp->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        hr = THR( pEditor->GetSelectionManager()->SetCurrentTracker( TRACKER_TYPE_Caret, spDispCtlTemp, spDispCtlTemp ) );
    }
    
    IFC( GetEditor()->CreateMarkupPointer( &spStart ));
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ));

    if ( fEmpty == FALSE )
    {       
        SP_IHTMLElement spElement;
        SP_IHTMLElement3 spElement3;
        BOOL fClipboardDone = FALSE ;

        IFC( undoUnit.Begin(IDS_EDUNDOPASTE) );

        IFC( spSegmentList->CreateIterator(&spIter ) );
                
        while( spIter->IsDone() == S_FALSE )
        {
            //
            // Continues all over this function means we have to advance our 
            // iterator at top
            //
            IFC( spIter->Current(&spSegment) );
            IFC( spIter->Advance() );

            IFC( spSegment->GetPointers( spStart, spEnd ));

            // Bug 103778: Make sure that spStart and spEnd are not in an atomic element.
            // Adjust out if necessary.
            IFC( AdjustPointersForAtomic(spStart, spEnd) );

            IFC( IsPastePossible( spStart, spEnd, & fRet ) );
            if (! fRet)
            {
                continue;
            }

            IFC( GetEditor()->FindCommonElement( spStart, spEnd, &spElement ));

            if (! spElement)
            {
                continue;
            }

            IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
            IFC(spElement3->fireEvent(_T("onpaste"), NULL, &fRetVal));
            
            if (! fRetVal)
            {
                continue;
            }

            //
            // Paste can cause re-entrancy which will invalidate the cmdtarget.  So, we must
            // must cache it and restore it.
            //

            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                // Paste the passed in bstrText 
                IFC( Paste( spStart, spEnd, GetSpringLoader(), V_BSTR(pvarargIn) ) );
            }
            else
            {
                // Paste from the clipboard
                IFC( PasteFromClipboard( spStart, spEnd, NULL, GetSpringLoader(), 
                                         GetCommandTarget()->IsRange()/* fForceIE50Compat */,
                                         fClipboardDone));

                if (eSelectionType == SELECTION_TYPE_Control)
                      fClipboardDone = TRUE ;
            }

        }

        if ( ! GetCommandTarget()->IsRange() && 
             eSelectionType != SELECTION_TYPE_Control  ) // Control is handled in ExitTree
        {
            pEditor->GetSelectionManager()->EmptySelection();
        }


        if ( ! GetCommandTarget()->IsRange() )
        {
            //
            // Update selection - go to pStart since it has gravity Right
            //
            IGNORE_HR( spEnd->MoveToPointer( spStart ) );            
            pEditor->SelectRangeInternal( spStart, spEnd, SELECTION_TYPE_Caret,TRUE);

            CSelectionChangeCounter selCounter(GetEditor()->GetSelectionManager());
            selCounter.SelectionChanged();
        }
    }

Cleanup:   
    ReleaseInterface((IHTMLEditor *) pEditor);
    RRETURN ( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     CheckOnBeforePasteSecurity
//
//  Synopsis:   Since we fire OnBeforePaste synchronously, the script can
//              switch focus and cause the target of the paste to change.  
//              Make sure that the target never changes to a different
//              file upload input.
//
//  Arguments:  [pElementActiveBefore] - active element before we fired OnBeforePaste
//              [pElementActiveAfter]  - active element after we fired OnBeforePaste
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::CheckOnBeforePasteSecurity(
    IHTMLElement *pElementActiveBefore,
    IHTMLElement *pElementActiveAfter)
{
    HRESULT hr = S_OK;
    BSTR    bstrType = NULL;

    //
    // If the active element after OnBeforeFocus is a file upload input,
    // we could have a security violation if it is not the same element
    // we had before OnBeforeFocus was called.
    //

    if (pElementActiveAfter != NULL)
    {
        ELEMENT_TAG_ID tagId;

        // Check for file upload input 
        IFC(GetMarkupServices()->GetElementTagId(pElementActiveAfter, &tagId));
        if (tagId == TAGID_INPUT)
        {
            SP_IHTMLInputElement spInputElement;

            IFC(pElementActiveAfter->QueryInterface(IID_IHTMLInputElement, (void **)&spInputElement));
            IFC(spInputElement->get_type(&bstrType));

            if (bstrType && !StrCmpIC(bstrType, TEXT("file")))
            {
                SP_IObjectIdentity spIdent;

                // Fail security check if the previous active element was NULL
                if (pElementActiveBefore == NULL)
                {
                    hr = E_ACCESSDENIED;  // fail security check
                    goto Cleanup;
                }

                // Fail security check if the previous active element was different
                IFC(pElementActiveBefore->QueryInterface(IID_IObjectIdentity, (void **)&spIdent));
                if (spIdent->IsEqualObject(pElementActiveAfter) != S_OK)
                {
                    hr = E_ACCESSDENIED;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    SysFreeString(bstrType);
    RRETURN(hr);
}


HRESULT
CPasteCommand::PrivateQueryStatus( 
                        OLECMD * pCmd,
                        OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart ;
    SP_IMarkupPointer   spEnd ;
    SP_IHTMLElement     spElement ;
    SP_ISegmentList     spSegmentList ;
    SP_IHTMLElement3    spElement3;
    SP_IHTMLElement     spElementActiveBefore;
    SP_IHTMLElement     spElementActiveAfter;
    SELECTION_TYPE      eSelectionType;
    VARIANT_BOOL        fEditable;
    VARIANT_BOOL        fRetVal;
    BOOL                fRet;
    BOOL                fEmpty;

    // Status is disabled by default
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    if ( fEmpty ) 
        goto Cleanup;

    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );
    IFC( GetEditor()->FindCommonElement( spStart, spEnd, &spElement ) );
    if (! spElement)
        goto Cleanup;

    //
    // We are about the fire a sync event, so we can re-enter here and 
    // focus can be switched to another element like a file upload input.
    //
    // For security purposes, we need to check for the file upload input.
    // case.
    //
    
    IFC(GetDoc()->get_activeElement(&spElementActiveBefore));

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("onbeforepaste"), NULL, &fRetVal));

    IFC(GetDoc()->get_activeElement(&spElementActiveAfter));

    if (CheckOnBeforePasteSecurity(spElementActiveBefore, spElementActiveAfter) != S_OK)
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        goto Cleanup;
    }
    fRet = !!fRetVal;

    if (! fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP;
        goto Cleanup;
    }

    if ( ! GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC(spElement3->get_isContentEditable(&fEditable));
        if (! fEditable)
            goto Cleanup;
    }

    if (!GetCommandTarget()->IsRange())
    {
        VARIANT_BOOL fDisabled;

        spElement = GetEditor()->GetSelectionManager()->GetEditableElement();
        
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isDisabled(&fDisabled));

        if (fDisabled)
            goto Cleanup;
    }

    IFC( IsPastePossible( spStart, spEnd, & fRet ) );
    if ( fRet )
    {
        pCmd->cmdf = MSOCMDSTATE_UP; // It's a GO
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CPasteCommand::IsPastePossible ( IMarkupPointer * pStart,
                                 IMarkupPointer * pEnd,
                                 BOOL * pfResult )
{    
    HRESULT         hr = S_OK;    
    IHTMLElement *  pFlowElement = NULL;
    VARIANT_BOOL    fAcceptsHTML;
    CLIPFORMAT      cf;
    int             nFETC = 0;
    FORMATETC *     pfetc;
    SP_IHTMLElement3 spElement3;

    Assert( pfResult );
    *pfResult = FALSE;

    //
    // Cannot paste unless the range is in the same flow layout
    //            
    if( !GetEditor()->PointersInSameFlowLayout( pStart, pEnd, & pFlowElement ) )
    {
        goto Cleanup;
    }

    if (! pFlowElement)
        goto Cleanup;

    pfetc = GetFETCs ( & nFETC );
    
    //
    // If we don't accept HTML and there is no text on clipboard, it's a no go
    //    
    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    if ( (! fAcceptsHTML) && 
         (! IsClipboardFormatAvailable( pfetc[iAnsiFETC].cfFormat ) ) )
    {
        goto Cleanup;
    }

    //
    // Make sure that the clipboard has data in it
    //
    while (nFETC--)                 
    {
        cf = pfetc[nFETC].cfFormat;
        if( IsClipboardFormatAvailable(cf) )
        {
            *pfResult = TRUE; // It's a GO
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pFlowElement );
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCommand::AutoUrlDetect
//
//  Synopsis:   Does a paste limited auto url detect.  See comments below.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CPasteCommand::AutoUrlDetect(IMarkupPointer *pStart,
                             IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spLimit;
    BOOL                fResult;
    
    // In general, we want to limit autodetection to the next word immediately to the right
    // of the pasted text is not autodetected.  For example:
    //
    // {paste www.foo.com}other words
    //
    // products:
    //
    // <a>www.foo.com</a>other words
    //
    // However, if we are pasting inside an existing anchor, we don't want this limit to apply.
    //
    IFC( pStart->IsRightOf(pEnd, &fResult) );
    spLimit = fResult ? pStart : pEnd;

    IFC( spLimit->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        SP_IHTMLElement spAnchorElement;
        
        IFC( FindTagAbove( GetMarkupServices(), spElement, TAGID_A, &spAnchorElement) );        
        if (spAnchorElement != NULL)
        {
            spLimit = NULL; // ignore limit if inside anchor
        }
    }
    
    IFC( GetEditor()->GetAutoUrlDetector()->DetectRange( pStart, pEnd, TRUE, spLimit) );

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchToRootForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, goes all the
//              way up to the <HTML> tag.
//
//-----------------------------------------------------------------------------

HRESULT 
CPasteCommand::SearchBranchToRootForTag (ELEMENT_TAG_ID tagIdDest, IHTMLElement *pElemStart, IHTMLElement **ppElement)
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    ELEMENT_TAG_ID  tagId;

    Assert(ppElement && pElemStart);
    *ppElement = NULL;

    ReplaceInterface(&pElemCurrent, pElemStart);
    do
    {        
        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );
        if (tagId == tagIdDest)
        {
            *ppElement = pElemCurrent;
            (*ppElement)->AddRef();
            goto Cleanup;
        }

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     HasContainer
//
//  Synopsis:   Searches the given branch for a container
////
//-----------------------------------------------------------------------------
BOOL
CPasteCommand::HasContainer(IHTMLElement *pElement)
{
    HRESULT         hr;
    BOOL            fResult = FALSE;
    IHTMLElement    *pElemCurrent = pElement;

    Assert(pElemCurrent);
    pElemCurrent->AddRef();
    
    do
    {
        if (GetEditor()->IsContainer(pElemCurrent))
        {
            fResult = TRUE;
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );        
    }
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    return fResult;
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceFragComments
//
//  Synopsis:   Remove the fragment begin and end comments which occur
//              in CF_HTML.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSourceFragComments(
    IMarkupPointer  *pSourceStart,
    IMarkupPointer  *pSourceFinish )
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *pmp = NULL;
    IHTMLElement        *pElement = NULL;
    IHTMLCommentElement *pElemComment = NULL;
    MARKUP_CONTEXT_TYPE ct;
    BSTR                bstrCommentText = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pmp) );

    //
    // Remove the start frag comment
    //

    IFC( pmp->MoveToPointer(pSourceStart) );

    for (;;)
    {
        ClearInterface(&pElement);
        IFC( pmp->Left(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope)
        {
            ELEMENT_TAG_ID tagId;        

            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

            if (tagId == TAGID_COMMENT_RAW)
            {
                LONG lAtomic;
                
                ClearInterface(&pElemComment);
                IFC( pElement->QueryInterface(IID_IHTMLCommentElement, (LPVOID *)&pElemComment) );

                IFC( pElemComment->get_atomic(&lAtomic) );
                if (lAtomic)
                {
                    SysFreeString(bstrCommentText);
                    IFC( pElemComment->get_text(&bstrCommentText) );
                    if (!StrCmpIC( _T("<!--StartFragment-->"), bstrCommentText))
                    {
                        IFC( GetMarkupServices()->RemoveElement(pElement) );
                        break;
                    }
                }                
            }
        }
    }

    //
    // Remove the end frag comment
    //

    IFC( pmp->MoveToPointer( pSourceFinish ) );

    for ( ; ; )
    {
        ClearInterface(&pElement);
        IFC( pmp->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope)
        {
            ELEMENT_TAG_ID tagId;        

            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

            if (tagId == TAGID_COMMENT_RAW)
            {
                LONG lAtomic;
                
                ClearInterface(&pElemComment);
                IFC( pElement->QueryInterface(IID_IHTMLCommentElement, (LPVOID *)&pElemComment) );

                IFC( pElemComment->get_atomic(&lAtomic) );
                if (lAtomic)
                {
                    SysFreeString(bstrCommentText);
                    IFC( pElemComment->get_text(&bstrCommentText) );
                    if (!StrCmpIC( _T("<!--EndFragment-->"), bstrCommentText))
                    {
                        IFC( GetMarkupServices()->RemoveElement(pElement) );
                        break;
                    }
                }                
            }
        }
    }

Cleanup:
    ReleaseInterface(pmp);
    ReleaseInterface(pElement);
    ReleaseInterface(pElemComment);
    SysFreeString(bstrCommentText);

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceTables
//
//  Synopsis:   Makes sure that whole (not parts of) tables are included in
//              the source of a paste.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSourceTables (
    IMarkupPointer  *pSourceStart,
    IMarkupPointer  *pSourceFinish )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemTable = NULL;
    IHTMLElement    *pElement = NULL;
    IMarkupPointer  *pPointer;

    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    
    //
    // Here we make sure there are no stranded tables in the source
    //

    Assert( Compare(pSourceStart, pSourceFinish) <= 0 );

    for ( pPointer->MoveToPointer(pSourceStart) ;
          Compare(pPointer, pSourceFinish) < 0 ; )
    {
        MARKUP_CONTEXT_TYPE ct;

        ClearInterface(&pElement);
        IFC( pPointer->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            ELEMENT_TAG_ID tagId;
            
            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
            switch (tagId)
            {
            case TAGID_TC : case TAGID_TD : case TAGID_TR : case TAGID_TBODY :
            case TAGID_THEAD : case TAGID_TFOOT : case TAGID_TH : case TAGID_TABLE :
            case TAGID_CAPTION: case TAGID_COL: case TAGID_COLGROUP:
                {
                    ClearInterface(&pElemTable);
                    IFC( SearchBranchToRootForTag(TAGID_TABLE, pElement, &pElemTable) );

                    if (pElemTable)
                    {
                        BOOL fResult;

                        IFC( pPointer->MoveAdjacentToElement(pElemTable, ELEM_ADJ_BeforeBegin) );
                        IFC( pSourceStart->IsRightOf(pPointer, &fResult) );
                        if (fResult)
                        {
                            IFC( pSourceStart->MoveToPointer(pPointer) );
                        }
                        
                        IFC( pPointer->MoveAdjacentToElement(pElemTable, ELEM_ADJ_AfterEnd) );
                        IFC( pSourceFinish->IsLeftOf(pPointer, &fResult) );
                        if (fResult)
                        {
                            IFC( pSourceFinish->MoveToPointer(pPointer) );
                        }
                        
                    } // if pElemTable
                } // case
            } // switch (tagId)
        } // if CONTEXT_TYPE_EnterScope
    }

    
Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pElemTable);
    ReleaseInterface(pPointer);

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceBody
//
//  Synopsis:   Makes sure the <body> is NOT included in the source of the
//              paste.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::Contain (
    IMarkupPointer *pPointer,
    IMarkupPointer *pPointerLeft,
    IMarkupPointer *pPointerRight )
{
    HRESULT hr = S_OK;
    
    if (Compare(pPointerLeft, pPointer) > 0)
    {
        IFC( pPointer->MoveToPointer(pPointerLeft) );
    }

    if (Compare(pPointerRight, pPointer ) < 0)
    {
        IFC( pPointer->MoveToPointer(pPointerRight) );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CPasteCommand::FixupPasteSourceBody (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pElementClient = NULL;
    IMarkupContainer    *pMarkupContainer = NULL;
    IMarkupPointer      *pPointerBodyStart = NULL;
    IMarkupPointer      *pPointerBodyFinish = NULL;
    ELEMENT_TAG_ID      tagId;
    
    //
    // Get the markup container associated with the sel
    //

    IFC( pPointerSourceStart->GetContainer(&pMarkupContainer) );
    Assert( pMarkupContainer );

    //
    // Get the client element from the markup and check to make sure
    // it's there and is a body element.
    //

    IFC( GetElementClient(pMarkupContainer, &pElementClient) );
    if (!pElementClient)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( GetMarkupServices()->GetElementTagId(pElementClient, &tagId) );
    if (tagId != TAGID_BODY)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    //
    // Move temp pointers to the inside edges of the body
    //

    IFC( GetEditor()->CreateMarkupPointer(&pPointerBodyStart) );
    IFC( pPointerBodyStart->MoveAdjacentToElement(pElementClient, ELEM_ADJ_AfterBegin) );
    
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBodyFinish) );    
    IFC( pPointerBodyFinish->MoveAdjacentToElement(pElementClient, ELEM_ADJ_BeforeEnd) );

    //
    // Make sure the source start and finish are within the body
    //

    IFC( Contain(pPointerSourceStart, pPointerBodyStart, pPointerBodyFinish) );
    IFC( Contain(pPointerSourceFinish, pPointerBodyStart, pPointerBodyFinish) );
    
Cleanup:
    ReleaseInterface(pElementClient);
    ReleaseInterface(pMarkupContainer);
    ReleaseInterface(pPointerBodyStart);
    ReleaseInterface(pPointerBodyFinish);
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPastePhraseElements
//
//  Synopsis:   To excessive nesting, adjust past edge phrase elements. 
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPastePhraseElements (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT         hr;
    CEditPointer    epStart(GetEditor());
    CEditPointer    epFinish(GetEditor());
    DWORD           dwFound;
    DWORD           dwSearchForward = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_EnterPhrase;
    DWORD           dwSearchBack    = BREAK_CONDITION_ANYTHING;
    DWORD           eScanOptions    = SCAN_OPTION_None;     
    SP_IDocHostUIHandler spHostUIHandler;
    SP_IServiceProvider  spSP;
    DOCHOSTUIINFO        info;

    //
    // Cling to content to avoid generate nesting tags.  Contextual paste will
    // take of the formatting except for the following case:
    //
    // <B><P>...</P></B>
    //
    // In this case, contextual paste assumes the <B> is paragraph level formatting
    // so it won't pick it up.  So, we must be careful to throw away the 
    // <B>.  (Note, this structure is generated by the RTF converter.  See
    // bug 105644)
    //
    
    //
    // Skip start past phrase elements 
    //
    
    //
    // IE6 bug# 31832 (mharper) Generics (tags with a namespace) are considered phrase elements if
    // there is no <?import...?> on the source or destination.  This breaks VS7 drag-drop behavior
    // for behaviors because they don't use import PI's and they don't yet have the implementation
    // or the namespace in the target document.  
    //

    if ( SUCCEEDED(GetDoc()->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP)) )
    {
        
        if ( SUCCEEDED( spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)& spHostUIHandler) ) )
        {
            memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
            info.cbSize = sizeof(DOCHOSTUIINFO);
        
            if (SUCCEEDED(spHostUIHandler->GetHostInfo(&info))
                && (info.dwFlags & DOCHOSTUIFLAG_DISABLE_EDIT_NS_FIXUP))
            {
                eScanOptions = SCAN_OPTION_BreakOnGenericPhrase;
            }
        }
    }



    IFC( epStart->MoveToPointer(pPointerSourceStart) );
    IFC( epStart.Scan(RIGHT, dwSearchForward, &dwFound, 
                      NULL /*ppElement*/, NULL /*peTagId*/, NULL /*pChar*/, eScanOptions) );

    if (!epStart.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( epStart.Scan(LEFT, dwSearchBack, &dwFound) );
        IFC( pPointerSourceStart->MoveToPointer(epStart) );
    }

    //
    // Skip finish past phrase elements 
    //

    IFC( epFinish->MoveToPointer(pPointerSourceFinish) );
    IFC( epFinish.Scan(LEFT, dwSearchForward, &dwFound,
                        NULL /*ppElement*/, NULL /*peTagId*/, NULL /*pChar*/, eScanOptions) );
    if (!epFinish.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( epFinish.Scan(RIGHT, dwSearchBack, &dwFound) );
        IFC( pPointerSourceFinish->MoveToPointer(epFinish) );
    }
     

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSource
//
//  Synopsis:   Makes sure the source of a paste is valid.  This means, for
//              the most part, that sub-parts of tables must not be pasted
//              without their corresponding table.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSource (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT hr = S_OK;

    IFC( FixupPasteSourceFragComments(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPasteSourceBody(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPasteSourceTables(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPastePhraseElements(pPointerSourceStart, pPointerSourceFinish) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   IsContainedInElement
//
//  Synopsis:   Is pPointer contained in the scope of pElement
//
//-----------------------------------------------------------------------------
HRESULT
CPasteCommand::IsContainedInElement(
    IMarkupPointer  *pPointer,
    IHTMLElement    *pElement,
    IMarkupPointer  *pTempPointer, 
    BOOL            *pfResult)
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pPointer && pElement && pTempPointer && pfResult);

    *pfResult = FALSE;

    IFC( pTempPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
    IFC( pTempPointer->IsRightOf(pPointer, &fResult) );
    if (fResult)
    {
        IFC( pTempPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
        IFC( pTempPointer->IsLeftOf(pPointer, &fResult) );        
        if (fResult)
            *pfResult = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsContainedInOL
//
//  Synopsis:   Determines if the markup pointer is contained within an OL
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::IsContainedInOL (
    IMarkupPointer  *pPointerLeft,
    IMarkupPointer  *pPointerRight,
    BOOL            *pfInOrderedList )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    IMarkupPointer  *pTemp = NULL;
    ELEMENT_TAG_ID  tagId;
    BOOL            fContained;

    Assert(pPointerLeft && pPointerRight);
    Assert(pfInOrderedList);

    *pfInOrderedList = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

    IFC( pPointerLeft->CurrentScope(&pElemCurrent) );

    // Walk up looking of OLs or LIs
    while (pElemCurrent)
    {
        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );

        if (tagId == TAGID_OL)
        {
            *pfInOrderedList = TRUE;
            goto Cleanup;
        }

        if (tagId == TAGID_LI)
        {
            SP_IMarkupPointer       spCurrent;
            long                    cchNext = -1;

            // If we've found an LI, we only care about the parent if the range is not
            // contained within the LI. If the range is contained within the LI, we don't 
            // want to paste the LI or the OL.
            IFC( IsContainedInElement(pPointerRight, pElemCurrent, pTemp, &fContained) );

            if (!fContained)
            {
                IFC( GetEditor()->CreateMarkupPointer(&spCurrent) );
                IFC( spCurrent->MoveToPointer(pPointerLeft) );

                IFC( ScanForText(spCurrent, pPointerRight, &cchNext) );
                if (hr == S_OK)
                {
                    SP_IHTMLComputedStyle   spStyle;
                    VARIANT_BOOL            vb;

                    IFC( GetDisplayServices()->GetComputedStyle(spCurrent, &spStyle) );

                    IFC( spStyle->get_OL(&vb) );
                    *pfInOrderedList = vb == VB_TRUE;
                
                    goto Cleanup;
                }
            }
            else
            {
                goto Cleanup;
            }
        }

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    }

Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pTemp);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRightPartialBlockElement
//
//  Synopsis:   Get the partial block element on the right
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::GetRightPartialBlockElement (
    IMarkupPointer  *pPointerLeft,
    IMarkupPointer  *pPointerRight,
    IHTMLElement    **ppElementPartialRight )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    IMarkupPointer  *pLeft = NULL;
    IMarkupPointer  *pRight = NULL;
    IMarkupPointer  *pTemp = NULL;
    BOOL            fContained;

    Assert(ppElementPartialRight && pPointerLeft && pPointerRight);
    *ppElementPartialRight = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

    IFC( pPointerRight->CurrentScope(&pElemCurrent) );
    while (pElemCurrent)
    {        
        if (IsBlockElement(pElemCurrent))
        {
            IFC( IsContainedInElement(pPointerRight, pElemCurrent, pTemp, &fContained) );
            if (fContained)
            {
                IFC( IsContainedInElement(pPointerLeft, pElemCurrent, pTemp, &fContained) );
                if (!fContained)
                {
                    *ppElementPartialRight = pElemCurrent;
                    pElemCurrent->AddRef();
                    
                    goto Cleanup;
                }
            }
        }
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 

Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pLeft);
    ReleaseInterface(pRight);
    ReleaseInterface(pTemp);

    RRETURN(hr);
}
    
//+----------------------------------------------------------------------------
//
//  Function:   ResolveConflict
//
//  Synopsis:   Resolves an HTML DTD conflict between two elements by removing
//              the top element over a limited range (defined by the bottom
//              element).
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::ResolveConflict(
    IHTMLElement    *pElementBottom,
    IHTMLElement    *pElementTop,
    BOOL            fIsOfficeContent)
{
    HRESULT             hr = S_OK;
    BOOL                fFoundContent;
    IHTMLElement        *pElementClone = NULL;
    SP_IHTMLElement     spElementPara;
    IMarkupPointer      *pPointerTopStart = NULL;
    IMarkupPointer      *pPointerTopFinish = NULL;
    IMarkupPointer      *pPointerBottomStart = NULL;
    IMarkupPointer      *pPointerBottomFinish = NULL;
    IMarkupPointer      *pPointerInsertClone = NULL;
    CEditPointer        epPointerTemp(GetEditor());
    DWORD               dwFound;
    ELEMENT_TAG_ID       tagIdTop = TAGID_NULL;
    ELEMENT_TAG_ID       tagIdBottom = TAGID_NULL;
    MARKUP_CONTEXT_TYPE  ct = CONTEXT_TYPE_None;

    //
    // Addref the top element to make sure it does not go away while it
    // is out of the tree.
    //

    pElementTop->AddRef();

    IFC( GetEditor()->CreateMarkupPointer(&pPointerTopStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerTopFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBottomStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBottomFinish) );
    
    //
    // In IE4, we would never remove a ped (IsContainer is nearly equivalent).
    // So, if a conflict arises where the top element is a ccontainer, remove
    // the bottom element instead.  Also, if there is no container above the
    // top element, we should not remove it.  THis takes care to not remove
    // elements like HTML.
    //

    if (GetEditor()->IsContainer(pElementTop) 
        || !HasContainer(pElementTop))
    {
        IFC( GetMarkupServices()->RemoveElement(pElementBottom) );
        goto Cleanup;
    }

#if DBG == 1
    IEditDebugServices *pEditDebugServices;
    
    if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
    {
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerTopStart, _T("Top Start")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerTopFinish, _T("Top Finish")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerBottomStart, _T("Bottom Start")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerBottomFinish, _T("Bottom Finish")) );

        pEditDebugServices->Release();
    }
#endif
    
    //
    // First, more pointer to the locations of the elements in question.
    //
    
    IFC( pPointerTopStart->MoveAdjacentToElement(pElementTop, ELEM_ADJ_BeforeBegin) );
    IFC( pPointerTopFinish->MoveAdjacentToElement(pElementTop, ELEM_ADJ_AfterEnd) );

    IFC( pPointerBottomStart->MoveAdjacentToElement(pElementBottom, ELEM_ADJ_BeforeBegin) );
    IFC( pPointerBottomFinish->MoveAdjacentToElement(pElementBottom, ELEM_ADJ_AfterEnd) );

    {
        SP_IObjectIdentity spIdent;

        IFC( pElementTop->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
        if (spIdent->IsEqualObject(pElementBottom) == S_OK)
            goto Cleanup;
    }        

    //
    // Make sure the input elements are where we think they 'aught to be
    //

#ifdef _PREFIX_
    BOOL fDbgFlag;
#else
    WHEN_DBG( BOOL fDbgFlag; )
#endif    
    Assert( pPointerTopStart->IsLeftOf(pPointerBottomStart, &fDbgFlag) == S_OK && fDbgFlag);
    Assert( pPointerTopFinish->IsRightOf(pPointerBottomStart, &fDbgFlag) == S_OK && fDbgFlag);

    //
    // Now, remove the top element and reinsert it so that it is no
    // over the bottom element.
    //

    IFC( GetMarkupServices()->RemoveElement(pElementTop) );

    //
    // Look left.  If we can get to the beginning of the top element,
    // without seeing any text (including break chars) or any elements
    // terminating then we must not put the top element back in before
    // the bottom.
    //

    IFC( epPointerTemp->MoveToPointer(pPointerBottomStart) );
    
    IFC( epPointerTemp.SetBoundaryForDirection(LEFT, pPointerTopStart) );
    IFC( epPointerTemp.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

    fFoundContent = !epPointerTemp.CheckFlag(dwFound, BREAK_CONDITION_Boundary);

    if (fFoundContent)
    {
        IFC( GetMarkupServices()->InsertElement(pElementTop, pPointerTopStart, pPointerBottomStart) );
    }

    //
    // Look right.
    //
    

    IFC( epPointerTemp->MoveToPointer(pPointerBottomFinish) );

    IFC( epPointerTemp.SetBoundaryForDirection(RIGHT, pPointerTopFinish) );
    IFC( epPointerTemp.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

    fFoundContent = !epPointerTemp.CheckFlag(dwFound, BREAK_CONDITION_Boundary);

    if (fFoundContent)
    {
 
        IFC( GetMarkupServices()->CloneElement(pElementTop, &pElementClone) );
        IFC( GetEditor()->CreateMarkupPointer(&pPointerInsertClone) );
        IFC( pPointerInsertClone->MoveToPointer(pPointerBottomFinish) );

        //
        // Now we check for the degenarate case where multiple <p></p>'s are being pasted
        // If we have a document that looks like this:
        //
        // {top start}
        // <p>
        //    {bottom start}<p> </p>{bottom finish}
        //    <p> </p>
        // </p>{top finish}
        //    
        // and we then just remove the top element and insert it right after {bottom finish}
        // we are sure to *generate* another conflict immediately below bottom because the document
        // will look like:  
        //
        // <p></p>
        // <p>  <-- (this is where the top element moved to) 
        //    <p></p>
        // </p>
        //
        // so we will now pass as many consecutive <p></p>'s as we can in one fell swoop
        // -mharper
        // 


        if( fIsOfficeContent )
        {

            IFC( GetMarkupServices()->GetElementTagId(pElementTop, &tagIdTop) );
            IFC( GetMarkupServices()->GetElementTagId(pElementBottom, &tagIdBottom) );

            if( tagIdTop == TAGID_P && tagIdBottom == TAGID_P)
            {
        
                do
                {
                    IFC( pPointerInsertClone->Right(FALSE, &ct, &spElementPara, NULL, NULL) );

                    if(spElementPara && ct == CONTEXT_TYPE_EnterScope)
                    {
                    
                        IFC( GetMarkupServices()->GetElementTagId(spElementPara, &tagIdBottom) ); 

                        if( tagIdBottom == TAGID_P )
                        {
                            IFC( pPointerInsertClone->MoveAdjacentToElement(spElementPara, ELEM_ADJ_AfterEnd) );
                        }

                    }
                }
                while(spElementPara && tagIdBottom == TAGID_P && ct == CONTEXT_TYPE_EnterScope);

            }
        }
        
        IFC( GetMarkupServices()->InsertElement(pElementClone, pPointerInsertClone, pPointerTopFinish) );


    }

Cleanup:
    ReleaseInterface(pPointerTopStart);
    ReleaseInterface(pPointerTopFinish);
    ReleaseInterface(pPointerBottomStart);
    ReleaseInterface(pPointerBottomFinish);
    ReleaseInterface(pPointerInsertClone);
    ReleaseInterface(pElementClone);
    ReleaseInterface(pElementTop);
    
    RRETURN( hr );
}

HRESULT
CPasteCommand::UiDeleteContent(IMarkupPointer * pmpStart, IMarkupPointer * pmpFinish)
{
    HRESULT hr;;
    
    hr = THR( GetEditor()->Delete(pmpStart, pmpFinish, TRUE) );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Performs the actual work of pasting (like, ctrl-V)
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::HandleUIPasteHTML (
    IMarkupPointer  *pPointerTargetStart,
    IMarkupPointer  *pPointerTargetFinish,
    HGLOBAL          hglobal)
{
    HRESULT                hr = S_OK;
    IMarkupContainer       *pMarkup = NULL;
    IMarkupContainer       *pMarkupContext = NULL;
    IMarkupPointer         *pPointerSourceStart = NULL;
    IMarkupPointer         *pPointerSourceFinish = NULL;
    IMarkupPointer         *pPointerStatus = NULL;
    IMarkupPointer         *pPointerNewContentLeft = NULL;
    IMarkupPointer         *pPointerNewContentRight = NULL;
    IMarkupPointer         *pPointerMergeRight = NULL;
    IMarkupPointer         *pPointerMergeLeft = NULL;
    IMarkupPointer         *pPointerRemoveLeft = NULL;
    IMarkupPointer         *pPointerRemoveRight = NULL;
    IMarkupPointer         *pPointerDoubleBulletsLeft = NULL;
    IMarkupPointer         *pPointerDoubleBulletsRight = NULL;
    IMarkupPointer         *pTemp = NULL;
    IHTMLElement           *pElementMergeRight = NULL;
    IHTMLElement           *pElement = NULL;
    IHTMLElement           *pElemFailBottom = NULL;
    IHTMLElement           *pElemFailTop = NULL;
    IMarkupPointer         *pPointer = NULL;
    CStackPtrAry <IHTMLElement *, 4 > aryRemoveElems ( Mt( Mem ) );
    INT                    i;
    SP_IMarkupPointer      spLocalPointerTargetFinish;
    BOOL                   fInOrderedList = FALSE;
    CEditPointer           ep(GetEditor());
    DWORD                  dwFound = NULL;
    SP_IHTMLElement        spElement;
    BOOL                   fIsOfficeContent = FALSE;
    MARKUP_CONTEXT_TYPE    ct = CONTEXT_TYPE_None;
    TCHAR                  ch = NULL;
    long                   cch = 0l;


    CPasteCharFormatManager charFormatManager(GetEditor());

    if (!pPointerTargetFinish)
    {
        IFC( GetEditor()->CreateMarkupPointer(&spLocalPointerTargetFinish) );
        IFC( spLocalPointerTargetFinish->MoveToPointer(pPointerTargetStart) );

        pPointerTargetFinish = spLocalPointerTargetFinish;
    }

#if DBG==1
    {
        BOOL fDbgIsPositioned;
        IEditDebugServices *pEditDebugServices = NULL;
        IMarkupContainer *pDbgMarkup1, *pDbgMarkup2;
        IObjectIdentity *pDbgIdent = NULL;
        
        //
        // Make sure the pointers are in the same markup and are ordered
        // correctly.
        //

        Assert( pPointerTargetStart->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
        Assert( pPointerTargetFinish->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned);

        if (SUCCEEDED(pPointerTargetStart->GetContainer(&pDbgMarkup1)))
        {
            if (SUCCEEDED(pPointerTargetStart->GetContainer(&pDbgMarkup2)))
            {
                if (SUCCEEDED(pDbgMarkup1->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pDbgIdent)))
                {
                    Assert(pDbgIdent->IsEqualObject(pDbgMarkup2) == S_OK);
                    pDbgIdent->Release();
                }
                pDbgMarkup2->Release();        
            }       
            pDbgMarkup1->Release();        
        }
        
        if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            WHEN_DBG( pEditDebugServices->SetDebugName(pPointerTargetStart, _T("Target Start")) );
            WHEN_DBG( pEditDebugServices->SetDebugName(pPointerTargetFinish, _T("Target Finish")) );

            pEditDebugServices->Release();
        }
    }
#endif

    IFC( GetEditor()->CreateMarkupPointer(&pPointerSourceStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerSourceFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerNewContentLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerNewContentRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerMergeRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerMergeLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerRemoveLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerRemoveRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerDoubleBulletsLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerDoubleBulletsRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerStatus) );
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );


    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    IFC( EnsureLogicalOrder(pPointerTargetStart, pPointerTargetFinish) );

    Assert( Compare(pPointerTargetStart, pPointerTargetFinish) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    IFC( pPointerTargetStart->GetContainer(&pMarkupContext) );

    IFC( GetMarkupServices()->ParseGlobalEx( 
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pMarkupContext,  // pContextMarkup
            & pMarkup,
            pPointerSourceStart,
            pPointerSourceFinish ) );
    
#if DBG==1
    {
        IEditDebugServices *pEditDebugServices = NULL;

        if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(pPointerSourceStart, _T("Source Start")) );
            IGNORE_HR( pEditDebugServices->SetDebugName(pPointerSourceFinish, _T("Source Finish")) );

            pEditDebugServices->Release();
        }
    }
#endif    

    //
    // If there was nothing really there to parse, just do a remove
    //
    
    if (!pMarkup)
    {
        IFC( UiDeleteContent(pPointerTargetStart, pPointerTargetFinish) );
        goto Cleanup;
    }
    


    //
    // Make sure this current range is one which is valid to delete and/or
    // replace with something else.  In the old IE4 code, the function
    // ValidateRplace was used to determine this.
    //
    // Also, the ole code used to call ValidateInsert which would decide if
    // the target location was a validate place to insert stuff.
    //
    // Ramin - do this here.
    //

// ValidateInsert code goes here (or similar)

    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // We paste NULL for the last parameter because I do not want the
    // fixup code to conditionally not do the table check.
    //
    
    IFC( FixupPasteSource(pPointerSourceStart, pPointerSourceFinish) );
    

    //
    // Check to see if the content comes from Excel or Word
    // and then apply styles that are not in the Computed Formats
    // Office uses stylesheet rules that can change (among other 
    // things)  the margins on <P> tags which are quite different
    // from the default.
    //
    
    IFC( IsOfficeFormat(pPointerSourceStart, &fIsOfficeContent) );
    if ( fIsOfficeContent )
    {

        IFC( FixupStyles(pPointerSourceStart, pPointerSourceFinish) );

        //
        // APPHACK: Office adds multiple cr-lf pairs after the <!--StartFragment-->
        // these are correctly converted to a space in ParseGlobal() which causes
        // a <P> </P> to be added in ResolveConflicts().  
        //
        // ParseGlobal can't just go around eating whitespace after the StartFragment
        // because that would break the scenario where the selection is 
        // <!--StartFragment--> two<!--EndFragment--> and we are pasting into
        // <body>one{target}</body. So we can only eat this space if we are sure that
        // it is evil i.e.: a)This is office content b)the first content is a space, and 
        // c)the next non-whitespace content is entering a block element -(mharper)
        // 

        IGNORE_HR(pPointerSourceStart->Right(FALSE, &ct, NULL, &(cch = 1), &ch ) );

        if( ct == CONTEXT_TYPE_Text && ch == _T(' ') )
        {
            IFC( ep->MoveToPointer(pPointerSourceStart) );
            IFC( ep.Scan( RIGHT, BREAK_CONDITION_Content, &dwFound, &spElement, 
                            NULL, NULL, SCAN_OPTION_SkipWhitespace) );

            if ( ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock) )
            {
                IFC( pTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                IFC( GetMarkupServices()->Remove(pPointerSourceStart, pTemp) );
            }
        }

    }

    //
    // We need to remember the formatting at this position before the markup
    // is munged and before we lose the information on the move.
    //

    IFC( charFormatManager.ComputeFormatMap(pPointerSourceStart, pPointerSourceFinish) );
    
    //
    // Compute right block element to merge.  However, we only merge if the target
    // contains content to the right.  
    //
    // For example:
    //
    // source:   {start fragment><p>foo{end fragment}</p>
    //
    // target 1: <P>{target}sometext</P> - we need to merge to avoid introducing a line break before sometext
    // target 2: <P>{target}</P> - we shouldn't merge.  
    //

    IFC( ep->MoveToPointer(pPointerTargetFinish) );
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Site | BREAK_CONDITION_Block))
    {
        IFC( GetRightPartialBlockElement(pPointerSourceStart, pPointerSourceFinish, &pElementMergeRight) );
    }
    
    //
    // If we overlap or are within a LI, we need to see if we're within a OL and reapply the OL
    // when we paste.
    //

    IFC( IsContainedInOL(pPointerSourceStart, pPointerSourceFinish, &fInOrderedList) );

    //
    // In IE4 because of the way the splice operation was written, any
    // elements which partially overlapped the left side of the stuff to
    // move would not be move to the target.  This implicit behaviour
    // was utilized to effectively get left handed block merging (along
    // with not moving any elements which partially overlapped).
    //
    // Here, I remove all elements which partially overlap the left
    // hand side so that the move operation does not move a clone of them
    // to the target.
    //

    ClearInterface(&pElement);
    IFC( pPointerSourceStart->CurrentScope(&pElement) );

    while (pElement)
    {        
        BOOL fContained;
                
        IFC( IsContainedInElement(pPointerSourceStart, pElement, pTemp, &fContained) );
        if (fContained)
        {
            IFC( IsContainedInElement(pPointerSourceFinish, pElement, pTemp, &fContained) );
            if (!fContained)
            {
                pElement->AddRef();
                IFC( aryRemoveElems.Append(pElement) );
            }
        }

        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    for (i = 0; i < aryRemoveElems.Size(); i++)
    {
        IFC( GetMarkupServices()->RemoveElement(aryRemoveElems[i]) );
        ClearInterface(&aryRemoveElems[i]);
    }
    
    //
    // Before actually performing the move, insert two pointers into the
    // target such that they will surround the moved source.
    //
    
    IGNORE_HR( pPointerNewContentLeft->SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pPointerNewContentRight->SetGravity( POINTER_GRAVITY_Right ) );

    IFC( pPointerNewContentLeft->MoveToPointer(pPointerTargetStart) );
    IFC( pPointerNewContentRight->MoveToPointer(pPointerTargetStart) );

    //
    // Locate the target with pointers which stay to the right of
    // the newly inserted stuff.  This is especially needed when
    // the two are equal.
    //

    IFC( pPointerRemoveLeft->MoveToPointer(pPointerTargetStart) );
    IFC( pPointerRemoveRight->MoveToPointer(pPointerTargetFinish) );


    IGNORE_HR( pPointerRemoveLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerRemoveRight->SetGravity(POINTER_GRAVITY_Right) );

    //
    // Before performing the move, we insert pointers with cling next
    // to elements which we will later perform a merge.  We need to do
    // this because (potentially) clones of the merge elements in the
    // source will be moved to the target because those elements are
    // only partially selected int the source.
    //

    if (pElementMergeRight)
    {
        IFC( pPointerMergeRight->MoveAdjacentToElement(pElementMergeRight, ELEM_ADJ_BeforeBegin) );

        IGNORE_HR( pPointerMergeRight->SetGravity( POINTER_GRAVITY_Right ) );        
        IGNORE_HR( pPointerMergeRight->SetCling( TRUE ) );
    }

    //
    // Now, move the source to the target. Here I insert two pointers
    // to record the location of the source after it has moved to the
    // target.
    //

    IFC( GetMarkupServices()->Move(pPointerSourceStart, pPointerSourceFinish, pPointerTargetStart ) );

    //
    // If this is not being performed from the automation range, then
    // include formatiing elements from the context
    //

    IFC( charFormatManager.FixupFormatting(pPointerNewContentLeft, fInOrderedList, fIsOfficeContent) );
        
    //
    // Now that the new stuff is in, make the pointers which indicate
    // it point inward so that the isolating char does not get in between
    // them.
    //

    IGNORE_HR( pPointerNewContentLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerNewContentRight->SetGravity(POINTER_GRAVITY_Left) );

    //
    // Now, remove the old stuff.  Because we use a rather high level
    // operation to do this, we have to make sure the newly inserted
    // stuff does not get mangled.  We do this by inserting an insulating
    // character.
    //

    {
        long  cch;
        TCHAR ch = _T('~');

        IFC( GetMarkupServices()->InsertText(&ch, 1, pPointerNewContentRight) );

        IFC( UiDeleteContent(pPointerRemoveLeft, pPointerRemoveRight) );

#if DBG == 1
        {
            MARKUP_CONTEXT_TYPE ct;
        
            IGNORE_HR(
                pPointerNewContentRight->Right(
                    FALSE, & ct, NULL, & (cch = 1), & ch ) );

            Assert( ct == CONTEXT_TYPE_Text && ch == _T('~') );
        }
#endif

        IFC( pPointerRemoveLeft->MoveToPointer(pPointerNewContentRight) );
        IFC( pPointerRemoveLeft->Right(TRUE, NULL, NULL, & (cch = 1), NULL) );

        IFC( GetMarkupServices()->Remove(pPointerNewContentRight, pPointerRemoveLeft) );

        IFC( pPointerRemoveLeft->Unposition() );
        IFC( pPointerRemoveRight->Unposition() );
    }

    //
    // Now, recover the elements to merge in the target tree
    //

    if (pElementMergeRight)
    {
        MARKUP_CONTEXT_TYPE ct;

#if DBG==1
    BOOL fDbgIsPositioned;
    
    Assert( pPointerMergeRight->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
#endif

        ClearInterface(&pElementMergeRight);
        pPointerMergeRight->Right(FALSE, &ct, &pElementMergeRight, NULL, NULL);

        Assert( ct == CONTEXT_TYPE_EnterScope );

        IFC( pPointerMergeRight->Unposition() );
    }
    
    //
    // Now, look for conflicts and remove them
    //

    //
    // Make sure changes to the document get inside the new content pointers
    //
    
    IGNORE_HR( pPointerNewContentLeft->SetGravity(POINTER_GRAVITY_Left) );
    IGNORE_HR( pPointerNewContentRight->SetGravity(POINTER_GRAVITY_Right) );
    
    //
    // (Bug 1677) - ResolveConflict can cause the pPointerNewContentLeft and
    // new pPointerNewContentRight to float outward because of their Left and
    // Right gravity respectively, so here we use temporary markup pointers 
    // pPointerDoubleBulletsLeft (with right gravity) and pPointerDoubleBulletsRight 
    // (with left gravity) 
    //

    IFC( pPointerDoubleBulletsLeft->MoveToPointer(pPointerNewContentLeft) );
    IFC( pPointerDoubleBulletsRight->MoveToPointer(pPointerNewContentRight) );

    IGNORE_HR( pPointerDoubleBulletsLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerDoubleBulletsRight->SetGravity(POINTER_GRAVITY_Left) );


    for ( ; ; )
    {
        ClearInterface(&pElemFailBottom);
        ClearInterface(&pElemFailTop);
    
        IFC( GetMarkupServices()->ValidateElements(
                pPointerNewContentLeft, pPointerNewContentRight, NULL,
                pPointerStatus, &pElemFailBottom, &pElemFailTop) );

        if (hr == S_OK)
            break;

        IFC( ResolveConflict(pElemFailBottom, pElemFailTop, fIsOfficeContent) );
    }


    //
    // Perform any merging
    //

    if (pElementMergeRight)
    {
        IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
        
        ClearInterface(&pMarkupContext);
        IFC( pPointer->GetContainer(&pMarkupContext) );

        IFC( pPointer->MoveAdjacentToElement(pElementMergeRight, ELEM_ADJ_BeforeEnd) );

        IFC( MergeBlock(pPointer) );
    }

    //
    // Because the source context for the paste may have allowed \r's and
    // the like in the text which we just pasted to the target, and the
    // recieving target element may not allow these kind of chars, we must
    // sanitize here.
    //

    IFC( SanitizeRange(pPointerNewContentLeft, pPointerNewContentRight) );

    //
    // Check for double bullets
    //

    IFC( pPointerDoubleBulletsLeft->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }

    IFC( pPointerDoubleBulletsRight->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }

    //
    // Unposition pointers
    //

    IFC( pPointerNewContentLeft->Unposition() );
    IFC( pPointerNewContentRight->Unposition() );

    IFC( pPointerDoubleBulletsLeft->Unposition() );
    IFC( pPointerDoubleBulletsRight->Unposition() );

Cleanup:
    ReleaseInterface(pMarkup);
    ReleaseInterface(pMarkupContext);
    ReleaseInterface(pPointerSourceStart);
    ReleaseInterface(pPointerSourceFinish);
    ReleaseInterface(pPointerStatus);
    ReleaseInterface(pPointerNewContentLeft);
    ReleaseInterface(pPointerNewContentRight);
    ReleaseInterface(pPointerMergeRight);
    ReleaseInterface(pPointerMergeLeft);
    ReleaseInterface(pPointerRemoveLeft);
    ReleaseInterface(pPointerRemoveRight);
    ReleaseInterface(pPointerDoubleBulletsLeft);
    ReleaseInterface(pPointerDoubleBulletsRight);
    ReleaseInterface(pTemp);
    ReleaseInterface(pElementMergeRight);
    ReleaseInterface(pElement);
    ReleaseInterface(pElemFailBottom);
    ReleaseInterface(pElemFailTop);
    ReleaseInterface(pPointer);
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::HandleUIPasteHTML (
    IMarkupPointer * pPointerTargetStart,
    IMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch)
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    IFC( HandleUIPasteHTML(pPointerTargetStart, pPointerTargetFinish, hHtmlText) );


Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   IsOfficeFormat
//
//  Synopsis:   Determines if the HTML is coming from an Office document
//              
//
//-----------------------------------------------------------------------------

HRESULT 
CPasteCommand::IsOfficeFormat(
    IMarkupPointer      *pPointerSourceStart,
    BOOL                *pfIsOfficeFormat)
{

    HRESULT             hr = S_OK;
    IMarkupPointer      *pPointer = NULL;
    IMarkupContainer    *pMarkup = NULL;
    ELEMENT_TAG_ID      tagId = TAGID_NULL;
    SP_IHTMLElement     spElement; 
    VARIANT             var;
    MARKUP_CONTEXT_TYPE ct = CONTEXT_TYPE_None;


    VariantInit(&var);
    *pfIsOfficeFormat = FALSE;


    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    IFC( pPointerSourceStart->GetContainer(&pMarkup) );
    IFC( pPointer->MoveToContainer(pMarkup, TRUE) );
    
    //
    // Start from the beginning of the MarkupContainer looking for 
    // META tags.  Word adds the following:
    //     <meta name=Generator content="Microsoft Word 9">
    // and Excel adds:
    //     <meta name=Generator content="Microsoft Excel 9">
    //


    for(;;)
    {
        hr = THR( pPointer->Right(TRUE, &ct, &spElement, NULL, NULL) );

        switch(ct)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                if ( tagId == TAGID_META )
                {
                    VariantClear(&var);
                    IFC( spElement->getAttribute(_T("name"), 0, &var) );

                    if ( V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL 
                        && StrCmpIC( _T("Generator"), var.bstrVal) == 0 )
                    {
                        VariantClear(&var);

                        IFC( spElement->getAttribute( _T("content"), 0, &var) );

                        if( V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL &&
                            ( StrCmpNIC( _T("Microsoft Word"), var.bstrVal, 14) == 0 || 
                            StrCmpNIC( _T("Microsoft Excel"), var.bstrVal, 15) == 0) )
                        {
                            *pfIsOfficeFormat = TRUE;  //found it
                            goto Cleanup;
                        }

                    }
                } 
                else if (tagId == TAGID_BODY)
                {
                    //
                    // Since META tags (at least the ones we are interested in) 
                    // should be in the HEAD, if we are already entering the scope 
                    // of the BODY and haven't found what we're looking for, then 
                    // we never will.
                    // 

                    *pfIsOfficeFormat = FALSE;
                    goto Cleanup;
                }
                
                break;

            case CONTEXT_TYPE_None:
                *pfIsOfficeFormat = FALSE;
                goto Cleanup;
        }       
    }


Cleanup:
  
    ReleaseInterface(pPointer);
    ReleaseInterface(pMarkup);
    VariantClear(&var);

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   FixupStyle
//
//  Synopsis:   Applies styles that are not part of the computed format
//              
//
//-----------------------------------------------------------------------------
HRESULT
CPasteCommand::FixupStyles(
    IMarkupPointer      *pPointerSourceStart,
    IMarkupPointer      *pPointerSourceFinish)
{
    
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pTemp = NULL;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLCurrentStyle    spCurrentStyle;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLElement         spElement;
    BSTR                    bstrClassName = NULL;
    BSTR                    bstrStyleValue = NULL;
    VARIANT                 vStyleValue;
    ELEMENT_TAG_ID          tagId = TAGID_NULL;
    MARKUP_CONTEXT_TYPE     ct = CONTEXT_TYPE_None;

    VariantInit(&vStyleValue);
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

#define COPY_STYLE_VARIANT(style)                                                   \
                    VariantClear( &vStyleValue );                                   \
                    IFC( spCurrentStyle->get_ ## style( &vStyleValue ) );           \
                    IFC( spStyle->put_ ## style( vStyleValue ) );   

#define COPY_STYLE_BSTR(style)                                                      \
                    SysFreeString( bstrStyleValue );                                \
                    IFC( spCurrentStyle->get_ ## style( &bstrStyleValue ) );        \
                    IFC( spStyle->put_ ## style( bstrStyleValue ) ); 




    IFC( pTemp->MoveToPointer(pPointerSourceStart) );

    IFC( pTemp->Right(TRUE, &ct, &spElement, NULL, NULL) );
    
    while ( ct != CONTEXT_TYPE_None && Compare(pTemp, pPointerSourceFinish) < 0 )
    {
        
        
        if ( ct == CONTEXT_TYPE_EnterScope )
        {

            IFC( spElement->get_className(&bstrClassName) );
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            
            //
            // If bstrTemp is not NULL and is not pointing to a null string, then there is a value
            // for class name, and is likely to have styles that are of interest to us.  Also,
            // Word/Excel may define rules for tags without giving specific class names, so we would 
            // also be interested in the tags listed below. (mharper - 11/7/2000)
            //

            if ( (bstrClassName && *bstrClassName) || tagId == TAGID_TD || tagId == TAGID_SPAN || tagId == TAGID_H1 ||
                tagId == TAGID_H2 || tagId == TAGID_H3 || tagId == TAGID_H4 || tagId == TAGID_H5)
            {

                IFC( spElement->QueryInterface(IID_IHTMLElement2, (void**)&spElement2) );


                if ( spElement2 )
                {

                    IFC( spElement->get_style( & spStyle) );
                    IFC( spElement2->get_currentStyle( & spCurrentStyle ) );
                    
                    SysFreeString( bstrStyleValue );
                    IFC( spCurrentStyle->get_margin(&bstrStyleValue) );
                    
                    if(bstrStyleValue && StrCmpC(_T("auto"), bstrStyleValue) != 0 )
                    {

                        COPY_STYLE_VARIANT( marginBottom );     // "auto" is default for margin
                        COPY_STYLE_VARIANT( marginTop );        
                        COPY_STYLE_VARIANT( marginRight );
                        COPY_STYLE_VARIANT( marginLeft );

                    }

                    if (tagId == TAGID_TD)
                    {
                        COPY_STYLE_VARIANT( backgroundColor );
                        COPY_STYLE_VARIANT( borderTopWidth );
                        COPY_STYLE_VARIANT( borderBottomWidth );
                        COPY_STYLE_VARIANT( borderLeftWidth );
                        COPY_STYLE_VARIANT( borderRightWidth );
                        COPY_STYLE_BSTR( borderTopStyle );          
                        COPY_STYLE_BSTR( borderBottomStyle );
                        COPY_STYLE_BSTR( borderLeftStyle );
                        COPY_STYLE_BSTR( borderRightStyle );
                        COPY_STYLE_VARIANT( borderTopColor );
                        COPY_STYLE_VARIANT( borderBottomColor );
                        COPY_STYLE_VARIANT( borderLeftColor );
                        COPY_STYLE_VARIANT( borderRightColor );
                    }
            
                }

#undef COPY_STYLE_VARIANT
#undef COPY_STYLE_BSTR
 
            }
        }

        IFC( pTemp->Right(TRUE, &ct, &spElement, NULL, NULL) );

    }
    
Cleanup:
    
    ReleaseInterface( pTemp );
    SysFreeString( bstrStyleValue );
    SysFreeString( bstrClassName );
    VariantClear( &vStyleValue );

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::CPasteCharFormatManager, public
//
//  Synopsis:   ctor
//
//  Arguments:  [pEd] -- CHTMLEditor pointer
//
//----------------------------------------------------------------------------

CPasteCharFormatManager::CPasteCharFormatManager(CHTMLEditor *pEd) 
: _aryCommands(Mt(CPasteCharFormatManager_aryCommands_pv) ),
_formatMap(Mt(CPasteCharFormatManager_formatMap_pv) )
{
    _pEd = pEd; 
    memset(&_rgFixupTable, 0, sizeof(_rgFixupTable));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::~CPasteCharFormatManager, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CPasteCharFormatManager::~CPasteCharFormatManager()
{
    int             i;
    CFormatMapInfo  *pFormatMapInfo;

    //
    // Release fixup table
    //    
    for (i = 0; i < FT_NumFormatTypes; ++i)
    {
        ReleaseInterface(_rgFixupTable[i]._pStart);
        VariantClear(&_rgFixupTable[i]._varValue);
    }

    //
    // Release format cache
    //

    for (i = _formatMap.Size(), pFormatMapInfo = _formatMap;
         i > 0;
         i--, pFormatMapInfo++)
    {
        pFormatMapInfo->_spComputedStyle = NULL;        // release computed style
        pFormatMapInfo->_spBlockComputedStyle = NULL;   // release computed style
    }   
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::SyncScanForTextStart, private
//
//  Synopsis:   Scan both pointers right for CONTEXT_TYPE_Text and break
//              before the text.
//
//  Arguments:  [pPointer] - pointer used for scan
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::ScanForTextStart(IMarkupPointer *pPointer, IMarkupPointer *pLastBlockPointer)
{
    HRESULT hr;
    LONG    cch = -1;

    // Search for CONTEXT_TYPE_Text from pTarget
    cch = -1;
    IFC( ScanForText(pPointer, NULL, &cch, pLastBlockPointer) );
    if (hr == S_FALSE)
        goto Cleanup;

    // Position pointers before text
    IFC( pPointer->Left(TRUE, NULL, NULL, &cch, NULL) );    
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::SyncScanForTextEnd, private
//
//  Synopsis:   Scan both pointers right for CONTEXT_TYPE_Text and break
//              after the text.  However, assure that both pointers moved
//              the same number of characters.
//
//  Arguments:  [pPointer1] - pointer1 used for scan
//              [pPointer2] - pointer2 used for scan
//              [pLimit1]   - rightmost limit for scan
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::SyncScanForTextEnd(CFormatMapPointer *pSource, IMarkupPointer *pTarget)
{
    HRESULT hr;
    LONG    cch1;
    LONG    cch = -1;
    BOOL    fDone = FALSE;

    // Scan format map pointer
    IFC( pSource->Right(&cch) );
    fDone = (hr == S_FALSE); // if fDone == TRUE, cch is still valid
    cch1 = cch;
    
    // Search for CONTEXT_TYPE_Text from pPointer2
    IFC( ScanForText(pTarget, NULL, &cch) );
    if (hr == S_FALSE)
        goto Cleanup;

    Assert(cch <= cch1);

    // Position pointers at min(cch1, cch2) so that we advance
    // both pointers the same cch
    if (cch < cch1)
    {
        cch = cch1 - cch;
        IFC( pSource->Left(&cch) );
    }

    hr = fDone ? S_FALSE : S_OK;
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::InitFixupTable, private
//
//  Synopsis:   Init the format fixup table
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::InitFixupTable()
{
    HRESULT         hr = S_OK;
    IMarkupPointer  *pPointer;

    for (int i = 0; i < FT_NumFormatTypes; ++i)
    {
        pPointer = _rgFixupTable[i]._pStart;
        if (pPointer)
            IFC( pPointer->Unposition() );

        VariantClear(&_rgFixupTable[i]._varValue);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FireRegisteredCommands, private
//
//  Synopsis:   Fires all fixup commands
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::FireRegisteredCommands()
{
    HRESULT         hr = S_OK;
    CCommandParams  *pCmdParams;
    int             i;
    VARIANT         *pvarargIn = NULL;

    for (i = _aryCommands.Size(), pCmdParams = _aryCommands;
         i > 0;
         i--, pCmdParams++)
    {
        if (V_VT(&pCmdParams->_varValue) != VT_NULL)
            pvarargIn = &pCmdParams->_varValue;
            
        IFC( FireCommand(pCmdParams->_cmdId, pCmdParams->_pStart, pCmdParams->_pEnd, pvarargIn) ); 
        pCmdParams->_pStart->Release();
        pCmdParams->_pEnd->Release();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FireCommand, private
//
//  Synopsis:   Fire an editor command through a text range
//
//  Arguments:  [cmdId]     - command to fire
//              [pStart]    - range start
//              [pEnd]      - range end
//              [pvarargIn] - argument for command
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FireCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr = S_OK;
    GUID                    guidCmdGroup = CGID_MSHTML;
    SP_IOleCommandTarget    spCmdTarget;

    // create the text range (on demand)
    if (_spRange == NULL)
    {
        SP_IHTMLElement     spElement;
        SP_IHTMLBodyElement spBody;
    
        IFC( _pEd->GetBody(&spElement) );

        IFC( spElement->QueryInterface(IID_IHTMLBodyElement, (void **)&spBody) );
        IFC( spBody->createTextRange(&_spRange) );
    }
    
    Assert(_spRange != NULL);
    
    IFC( GetMarkupServices()->MoveRangeToPointers( pStart, pEnd, _spRange));
    
    // Fire the command

    IFC( _spRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&spCmdTarget) );

    //
    // Note that we may try to fixup content that can't accept HTML here.  
    // However, the commands will check and fail this operation.  So, since
    // the commands do the validation, we don't need to repeat it here.  Instead, 
    // just IGNORE_HR.
    //
    
    IGNORE_HR( spCmdTarget->Exec(&guidCmdGroup, cmdId, 0, pvarargIn, NULL) );


Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::RegisterCommand, private
//
//  Synopsis:   Register an editor command to be fired at some later point in time
//
//  Arguments:  [cmdId]     - command to fire
//              [pStart]    - range start
//              [pEnd]      - range end
//              [pvarargIn] - argument for command
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::RegisterCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    CCommandParams  *pParams;

    IFC( _aryCommands.AppendIndirect(NULL, &pParams) );

    pParams->_cmdId = cmdId;

    IFC( _pEd->CreateMarkupPointer(&pParams->_pStart) );
    IFC( pParams->_pStart->MoveToPointer(pStart) );

    IFC( _pEd->CreateMarkupPointer(&pParams->_pEnd) );
    IFC( pParams->_pEnd->MoveToPointer(pEnd) );

    if (pvarargIn == NULL)
    {
        V_VT(&pParams->_varValue) = VT_NULL;
    }
    else
    {
        IFC( VariantCopy(&pParams->_varValue, pvarargIn) );
    }
    
Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupBoolCharFormat, private
//
//  Synopsis:   Fixup paste formatting for boolean format type like B, I, U.
//
//  Arguments:  [ft]               - formatting type
//              [cmdId]            - fixup command
//              [pPosition]        - position in target
//              [fFormattingEqual] - is source formatting equal
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupBoolCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual)
{
    HRESULT          hr = S_OK;
    BOOL             fPrevFormattingEqual;
    IMarkupPointer   *pPrevPointer = _rgFixupTable[ft]._pStart;

    fPrevFormattingEqual = TRUE;
    if (pPrevPointer)
    {
        BOOL fPositioned;
        
        IFC( pPrevPointer->IsPositioned(&fPositioned) );
        fPrevFormattingEqual = !fPositioned;
    }

    if (fPrevFormattingEqual && !fFormattingEqual)
    {
        //
        // Start a fixup segment
        //

        if (!pPrevPointer)
        {
            IFC( _pEd->CreateMarkupPointer(&_rgFixupTable[ft]._pStart) );
        }

        IFC( _rgFixupTable[ft]._pStart->MoveToPointer(pPosition) );
    }
    else if (!fPrevFormattingEqual && fFormattingEqual)
    {
        //
        // End a fixup segment
        //

#if DBG==1       
        BOOL fDbgIsPositioned;
        
        Assert(_rgFixupTable[ft]._pStart);
        
        IGNORE_HR(_rgFixupTable[ft]._pStart->IsPositioned(&fDbgIsPositioned));
        Assert(fDbgIsPositioned);
#endif        

        IFC( RegisterCommand(cmdId, _rgFixupTable[ft]._pStart, pPosition, NULL) );
        IFC( _rgFixupTable[ft]._pStart->Unposition() );
    }

Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupVariantCharFormat, private
//
//  Synopsis:   Fixup paste formatting for variant format type like font color, font size, etc...
//
//  Arguments:  [ft]               - formatting type
//              [cmdId]            - fixup command
//              [pPosition]        - position in target
//              [fFormattingEqual] - is source formatting equal
//              [pvarargIn]        - input variant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupVariantCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    BOOL            fPrevFormattingEqual;
    IMarkupPointer  *pPrevPointer = _rgFixupTable[ft]._pStart;
    BOOL            fValueChange = FALSE;

    fPrevFormattingEqual = TRUE;
    if (pPrevPointer)
    {
        BOOL fPositioned;
        
        IFC( pPrevPointer->IsPositioned(&fPositioned) );
        fPrevFormattingEqual = !fPositioned;
    }


    if (!fPrevFormattingEqual && !fFormattingEqual)
    {
        // Compare variants
        if (V_VT(pvarargIn) == VT_BSTR && V_VT(&_rgFixupTable[ft]._varValue) == VT_BSTR)
        {
            UINT iLen1 = SysStringLen(V_BSTR(&_rgFixupTable[ft]._varValue));
            UINT iLen2 = SysStringLen(V_BSTR(pvarargIn));

            if (iLen1 != iLen2)
                fValueChange = TRUE;
            else
                fValueChange = memcmp(V_BSTR(pvarargIn), V_BSTR(&_rgFixupTable[ft]._varValue), min(iLen1, iLen2));
        }
        else
        {
            fValueChange = memcmp(pvarargIn, &_rgFixupTable[ft]._varValue, sizeof(VARIANT));
        }
    }

    if (!fPrevFormattingEqual && (fFormattingEqual || fValueChange))
    {
        //
        // End a fixup segment
        //

        IFC( RegisterCommand(cmdId, _rgFixupTable[ft]._pStart, pPosition, &_rgFixupTable[ft]._varValue) );
        IFC( _rgFixupTable[ft]._pStart->Unposition() );
        IFC( VariantClear(&_rgFixupTable[ft]._varValue) );
    }

    if (fValueChange || (fPrevFormattingEqual && !fFormattingEqual))
    {
        //
        // Start a fixup segment
        //

        if (!pPrevPointer)
        {
            IFC( _pEd->CreateMarkupPointer(&_rgFixupTable[ft]._pStart) );
        }

        IFC( _rgFixupTable[ft]._pStart->MoveToPointer(pPosition) );
        IFC( VariantClear(&_rgFixupTable[ft]._varValue) );
        IFC( VariantCopy(&_rgFixupTable[ft]._varValue, pvarargIn) );
    }

Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FinishFixup, private
//
//  Synopsis:   Closes all open fixup ranges
//
//  Arguments:  [pTarget] - end of fixup range
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FinishFixup(
    IMarkupPointer *pTarget, BOOL fFixupOrderedList)
{
    HRESULT hr;
    VARIANT varargIn;
    
    //
    // Fixup bool-style formatting
    //    

    IFC( FixupBoolCharFormat(FT_Bold, IDM_BOLD, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Italic, IDM_ITALIC, pTarget, TRUE) );   
    IFC( FixupBoolCharFormat(FT_Underline, IDM_UNDERLINE, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Subscript, IDM_SUBSCRIPT, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Superscript, IDM_SUPERSCRIPT, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Strikethrough, IDM_STRIKETHROUGH, pTarget, TRUE) );

    if (fFixupOrderedList)
    {
        IFC( FixupBoolCharFormat(FT_OrderedList, IDM_ORDERLIST, pTarget, TRUE) );
    }

    //
    // Fixup variant based formatting
    //    
    V_VT(&varargIn) = VT_NULL;

    IFC( FixupVariantCharFormat(FT_FontSize, IDM_FONTSIZE, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_ForeColor, IDM_FORECOLOR, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_BackColor, IDM_BACKCOLOR, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_FontFace, IDM_FONTNAME, pTarget, TRUE, &varargIn) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupPosition, private
//
//  Synopsis:   Fixup paste formatting at current pSource (and pTarget) using 
//              format cache info
//
//  Arguments:  [pSource]          - source position
//              [pTarget]          - matching target position
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupPosition(
    CFormatMapPointer    *pSource, 
    IMarkupPointer       *pTarget,
    IMarkupPointer       *pBlockTarget,
    BOOL                  fFixupOrderedList,
    BOOL                  fForceFixup)
{
    HRESULT                 hr;
    VARIANT                 varargIn;
    BOOL                    fEqual;
    SP_IHTMLComputedStyle   spStyleSource, spStyleSourceBlock;
    SP_IHTMLComputedStyle   spStyleTarget, spStyleTargetBlock;
    VARIANT_BOOL            bSourceAttribute, bTargetAttribute;
    VARIANT_BOOL            bSourceBlockAttribute, bTargetBlockAttribute;
    VARIANT_BOOL            fAllEqual;
    LONG                    lHeightTarget, lHeightSource;
    DWORD                   dwColorTarget, dwColorSource;
    LONG                    lHeightTargetBlock, lHeightSourceBlock;
    DWORD                   dwColorTargetBlock, dwColorSourceBlock;
    
    VariantInit(&varargIn);

    // 
    // Get the format cache info at the source/target
    //

    spStyleSource = pSource->GetComputedStyle();
    if (spStyleSource == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    spStyleSourceBlock = pSource->GetBlockComputedStyle();
    if (spStyleSourceBlock == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    IFC( GetDisplayServices()->GetComputedStyle(pTarget, &spStyleTarget) );
    if (spStyleTarget == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( GetDisplayServices()->GetComputedStyle(pBlockTarget, &spStyleTargetBlock) );
    if (spStyleTargetBlock == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( spStyleSource->IsEqual(spStyleTarget, &fAllEqual) );
    
    //
    // Fixup bool-style formatting
    //    

#define FIXUP_FORMATTING(index, cmd, attr)                                      \
    if (fAllEqual == VB_TRUE)                                                   \
    {                                                                           \
        IFC( FixupBoolCharFormat(index, cmd, pTarget, TRUE) );                  \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        IFC( spStyleSource->get_ ## attr(&bSourceAttribute) );                  \
        IFC( spStyleTarget->get_ ## attr(&bTargetAttribute) )                   \
        IFC( spStyleSourceBlock->get_ ## attr(&bSourceBlockAttribute) );        \
        IFC( spStyleTargetBlock->get_ ## attr(&bTargetBlockAttribute) );        \
        fEqual = !ShouldFixupFormatting(bSourceAttribute, bSourceBlockAttribute, bTargetAttribute, bTargetBlockAttribute, fForceFixup);  \
        IFC( FixupBoolCharFormat(index, cmd, pTarget, fEqual) );                \
    }                                                                         

    
    FIXUP_FORMATTING( FT_Bold, IDM_BOLD, bold );
    FIXUP_FORMATTING( FT_Italic, IDM_ITALIC, italic );   
    FIXUP_FORMATTING( FT_Underline, IDM_UNDERLINE, underline );
    FIXUP_FORMATTING( FT_Subscript, IDM_SUBSCRIPT, subScript );
    FIXUP_FORMATTING( FT_Superscript, IDM_SUPERSCRIPT, superScript );
    FIXUP_FORMATTING( FT_Strikethrough, IDM_STRIKETHROUGH, strikeOut);
#undef FIXUP_FORMATTING

    if (fFixupOrderedList)
    {
        IFC( spStyleSource->get_OL(&bSourceAttribute) );
        IFC( spStyleTarget->get_OL(&bTargetAttribute) );

        fEqual = (bSourceAttribute == bTargetAttribute);

        IFC( FixupBoolCharFormat(FT_OrderedList, IDM_ORDERLIST, pTarget, fEqual) );              
    }

    //
    // Fixup variant based formatting
    //    

    // Font size
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        IFC( spStyleSource->get_fontSize(&lHeightSource) );
        IFC( spStyleTarget->get_fontSize(&lHeightTarget) );
        fEqual = (lHeightSource == lHeightTarget);
        if (!fEqual)
        {
            IFC( spStyleSourceBlock->get_fontSize(&lHeightSourceBlock) );
            IFC( spStyleTargetBlock->get_fontSize(&lHeightTargetBlock) );
            fEqual = !ShouldFixupFormatting(lHeightSource, lHeightSourceBlock, lHeightTarget, lHeightTargetBlock, fForceFixup);
        }
        if (!fEqual)
        {
            V_VT(&varargIn) = VT_I4;
            V_I4(&varargIn) = EdUtil::ConvertTwipsToHtmlSize(lHeightSource);
        }   
    }
    IFC( FixupVariantCharFormat(FT_FontSize, IDM_FONTSIZE, pTarget, fEqual, &varargIn) );
    
    // Fore color
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
         IFC( spStyleSource->get_textColor(&dwColorSource) );
         IFC( spStyleTarget->get_textColor(&dwColorTarget) );
         fEqual = (dwColorSource == dwColorTarget);
         if (!fEqual)
         {
             IFC( spStyleSourceBlock->get_textColor(&dwColorSourceBlock) );
             IFC( spStyleTargetBlock->get_textColor(&dwColorTargetBlock) );
             fEqual = !ShouldFixupFormatting(dwColorSource, dwColorSourceBlock, dwColorTarget, dwColorTargetBlock, fForceFixup);
         }
         if (!fEqual)
         {
             V_VT(&varargIn) = VT_I4;
             V_I4(&varargIn) = ConvertRGBColorToOleColor(dwColorSource);
         }   
    }
    IFC( FixupVariantCharFormat(FT_ForeColor, IDM_FORECOLOR, pTarget, fEqual, &varargIn) );

    // Background color
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        IFC( spStyleSource->get_hasBgColor(&bSourceAttribute) );
        IFC( spStyleTarget->get_hasBgColor(&bTargetAttribute) );
        fEqual = (bSourceAttribute == FALSE);
        if (!fEqual)
        {
            IFC( spStyleSource->get_backgroundColor(&dwColorSource) );
            IFC( spStyleTarget->get_backgroundColor(&dwColorTarget) );
            fEqual = (dwColorSource == dwColorTarget);
            if (!fEqual)
            {
                IFC( spStyleSourceBlock->get_backgroundColor(&dwColorSourceBlock) );
                IFC( spStyleTargetBlock->get_backgroundColor(&dwColorTargetBlock) );
                fEqual = !ShouldFixupFormatting(dwColorSource, dwColorSourceBlock, dwColorTarget, dwColorTargetBlock, fForceFixup);
            }
            if (!fEqual)
            {
                V_VT(&varargIn) = VT_I4;
                V_I4(&varargIn) = ConvertRGBColorToOleColor(dwColorSource);
            }
        }
    }
    IFC( FixupVariantCharFormat(FT_BackColor, IDM_BACKCOLOR, pTarget, fEqual, &varargIn) );

    // Font face 
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        TCHAR szFontNameSource[LF_FACESIZE+1];
        TCHAR szFontNameTarget[LF_FACESIZE+1];

        IFC( spStyleSource->get_fontName(szFontNameSource) );
        IFC( spStyleTarget->get_fontName(szFontNameTarget) );
        
        fEqual = (_tcscmp(szFontNameSource, szFontNameTarget) == 0);
        if (!fEqual)
        {
            TCHAR szFontNameSourceBlock[LF_FACESIZE+1];
            TCHAR szFontNameTargetBlock[LF_FACESIZE+1];            

            IFC( spStyleSourceBlock->get_fontName(szFontNameSourceBlock) );
            IFC( spStyleTargetBlock->get_fontName(szFontNameTargetBlock) );

            fEqual = !ShouldFixupFormatting(szFontNameSource, szFontNameSourceBlock, szFontNameTarget, szFontNameTargetBlock, fForceFixup);            
        }
        
        if (!fEqual)
        {
            V_VT(&varargIn) = VT_BSTR;
            V_BSTR(&varargIn) = SysAllocString(szFontNameSource);
        }   
    }
    IFC( FixupVariantCharFormat(FT_FontFace, IDM_FONTNAME, pTarget, fEqual, &varargIn) );

Cleanup:
    VariantClear(&varargIn);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupFormatting, private
//
//  Synopsis:   Fixup paste formatting for pasted range
//
//  Arguments:  [pSourceStart]     - source start position
//              [pSourceFinish]    - source finish position
//              [pTarget]          - target for paste
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupFormatting(
    IMarkupPointer  *pTarget,
    BOOL             fFixupOrderedList,
    BOOL             fForceFixup)
{
    HRESULT             hr ;
    SP_IMarkupPointer   spTargetCurrent;
    CFormatMapPointer   formatMapPointer(&_formatMap);
    CEditPointer        epLastBlockPointer(_pEd);
    DWORD               dwFound;

    IFC( _pEd->CreateMarkupPointer(&spTargetCurrent) );

    //
    // If there was no text being pasted, we don't need to fixup the formatting
    //

    if (_formatMap.Size() == 0)
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( InitFixupTable() );
    
    //
    // Move sourceCurrent and targetCurrent to pSourceStart and pTarget
    //

    IFC( spTargetCurrent->MoveToPointer(pTarget) );
    IFC( spTargetCurrent->SetGravity(POINTER_GRAVITY_Right) );

    //
    // Position spLastBlockPointer so that the loop below can always assume it has a positioned pointer
    //

    IFC( epLastBlockPointer->MoveToPointer(spTargetCurrent) );
    IFC( epLastBlockPointer.Scan(LEFT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    // Make sure we have some block.  Since we're always in the body or a table, we should
    // not walk off the edge of the document.
    Assert(epLastBlockPointer.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site) );

    IFC( epLastBlockPointer.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    //
    // Scan until we see text
    //
    
    do
    { 
        IFC( ScanForTextStart(spTargetCurrent, epLastBlockPointer) );    
        if (hr == S_FALSE)
            break;

        IFC( FixupPosition(&formatMapPointer, spTargetCurrent, epLastBlockPointer, fFixupOrderedList, fForceFixup) );
        
        //
        // Scan for next text block
        //        
        
        IFC( SyncScanForTextEnd(&formatMapPointer, spTargetCurrent) );    
    }
    while (hr != S_FALSE);

    //
    // Flush formatting
    //

    IFC( FinishFixup(spTargetCurrent, fFixupOrderedList) );
    IFC( FireRegisteredCommands() );

    // Proper termination
    hr = S_OK; 
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::ComputeFormatMap, private
//
//  Synopsis:   Remember formatting from source markup
//
//  Arguments:  [pSourceStart]     - source start position
//              [pSourceFinish]    - source finish position
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::ComputeFormatMap(        
        IMarkupPointer  *pSourceStart, 
        IMarkupPointer  *pSourceFinish)
{                
    HRESULT             hr ;
    SP_IMarkupPointer   spSourceCurrent;
    CEditPointer        epLastBlockPointer(_pEd);
    LONG                cchNext = -1;
    CFormatMapInfo      *pFormatInfo;
    DWORD               dwFound;

    AssertSz(_formatMap.Size() == 0, "ComputeFormatMap called more than once");

    IFC( _pEd->CreateMarkupPointer(&spSourceCurrent) );
    IFC( _pEd->CreateMarkupPointer(&epLastBlockPointer) );

    //
    // Position spLasteBlockPointer so that the loop below can always assume it has a positioned pointer
    //

    IFC( epLastBlockPointer->MoveToPointer(pSourceStart) );
    IFC( epLastBlockPointer.Scan(LEFT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    // Make sure we have some block.  Since we're always in the body or a table, we should
    // not walk off the edge of the document.
    Assert(epLastBlockPointer.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site) );

    IFC( epLastBlockPointer.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );
    
    //
    // Compute the format map
    //
    
    IFC( spSourceCurrent->MoveToPointer(pSourceStart) );
    do
    { 
        //
        // Scan for text
        //
        cchNext = -1;
        IFC( ScanForText(spSourceCurrent, pSourceFinish, &cchNext, epLastBlockPointer) );
        if (hr == S_FALSE)
            break; 

        //
        // Add to format map
        //
        IFC( _formatMap.AppendIndirect(NULL, &pFormatInfo) );

        pFormatInfo->_cchNext = cchNext;
        IFC( GetDisplayServices()->GetComputedStyle(spSourceCurrent, &pFormatInfo->_spComputedStyle) );
        IFC( GetDisplayServices()->GetComputedStyle(epLastBlockPointer, &pFormatInfo->_spBlockComputedStyle) );
    }
    while (hr != S_FALSE);

    //
    // proper termination
    //
    
    hr = S_OK;
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::CFormatMapPointer, public
//
//  Synopsis:   ctor
//
//  Arguments:  [pFormatMap] - Format map pointer
//
//----------------------------------------------------------------------------
CFormatMapPointer::CFormatMapPointer(CFormatMap *pFormatMap)
{
    Assert(pFormatMap);

    _iCurrentFormat = 0;
    _icch = 0;
    _pFormatMap = pFormatMap;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::Right, public
//
//  Synopsis:   Moves format pointer pCch characters through the format map.
//              if *pCch < 0, the pointer is moved to the position in the 
//              format map
//
//  Arguments:  [pCch] - Number of characters moved.  Also used to return 
//                       characters actually moved.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CFormatMapPointer::Right(LONG *pCch)
{
    HRESULT         hr = S_OK;
    CFormatMapInfo  *pFormatInfo;

    Assert(pCch);    
    Assert(_iCurrentFormat < _pFormatMap->Size());

    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    Assert(pFormatInfo && _icch < pFormatInfo->_cchNext);

    if (*pCch == -1)
    {
        *pCch = pFormatInfo->_cchNext - _icch;
    }
    else
    {
        *pCch = min(*pCch, LONG(pFormatInfo->_cchNext - _icch));
    }

     _icch += *pCch;
        
    if (_icch >= pFormatInfo->_cchNext)
    {
        if (_iCurrentFormat >= _pFormatMap->Size() - 1)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _icch = 0;        
        _iCurrentFormat++;            
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::Left, public
//
//  Synopsis:   Moves format pointer pCch characters left through the
//              format map.
//
//              NOTE: left doesn't currently support moving to the 
//              previous format map entry
//
//  Arguments:  [pCch] - Number of characters moved.  Also used to return 
//                       characters actually moved.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CFormatMapPointer::Left(LONG *pCch)
{
    HRESULT         hr = S_OK;
    CFormatMapInfo  *pFormatInfo;

    Assert(pCch && *pCch > 0);    
    Assert(_iCurrentFormat < _pFormatMap->Size());

    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    Assert(pFormatInfo && _icch < pFormatInfo->_cchNext && *pCch < _icch);

    _icch -= *pCch;
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::GetComputedStyle, public
//
//  Synopsis:   Gets the IHTMLComputedStyle object.
//
//  Returns:    IHTMLComputedStyle*
//
//----------------------------------------------------------------------------
IHTMLComputedStyle *
CFormatMapPointer::GetComputedStyle()
{
    CFormatMapInfo *pFormatInfo;

    Assert(_iCurrentFormat < _pFormatMap->Size());
    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    
    return  pFormatInfo->_spComputedStyle;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::GetBlockComputedStyle, public
//
//  Synopsis:   Gets the IHTMLComputedStyle object.
//
//  Returns:    IHTMLComputedStyle*
//
//----------------------------------------------------------------------------
IHTMLComputedStyle *
CFormatMapPointer::GetBlockComputedStyle()
{
    CFormatMapInfo *pFormatInfo;

    Assert(_iCurrentFormat < _pFormatMap->Size());
    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    
    return  pFormatInfo->_spBlockComputedStyle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\selcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_SELCMD_HXX_
#define X_SELCMD_HXX_
#include "selcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef X_SLIST_HXX_
#define X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

//
// Externs
//
MtDefine(CSelectAllCommand, EditCommand, "CSelectAllCommand");
MtDefine(CClearSelectionCommand, EditCommand, "CClearSelectionCommand");
MtDefine(CKeepSelectionCommand, EditCommand, "CKeepSelectionCommand");

using namespace EdUtil;

////////////////////////////////////////////////////////////////////////////////
// CSelectAllCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CSelectAllCommand::PrivateExec( 
                        DWORD nCmdexecopt,
                        VARIANTARG * pvarargIn,
                        VARIANTARG * pvarargOut )
{
    HRESULT         hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        IFC (SelectAllSiteSelectableElements());
    }
    else
    {
#endif
        SP_ISegmentList     spSegmentList;
        SP_IMarkupPointer   spStart;
        SP_IMarkupPointer   spEnd;
        SELECTION_TYPE      eSelType;
        BOOL                fSelectedAll = FALSE;
        BOOL                fEmpty = FALSE;

        
        IFC( GetSegmentList( &spSegmentList ));
                
        //
        // NOTE: This code is required for select all after range.pastehtml
        //       so that it auto-detects any existing url's.  This is
        //       a BVT case.  See bug 40009. [ashrafm]
        //

        if ( GetEditor()->GetSelectionManager()->IsParentEditable() )
        {
            IFC( spSegmentList->GetType( &eSelType ) );
            IFC( spSegmentList->IsEmpty( &fEmpty ) );

            if( eSelType == SELECTION_TYPE_Caret && !fEmpty )
            {           
                IFC( GetFirstSegmentPointers( spSegmentList, &spStart, &spEnd ) );
                IGNORE_HR( GetEditor()->GetAutoUrlDetector()->DetectCurrentWord( spStart, NULL, NULL ));
            }
        }

        // Check to see if the edit context is contained in the doc that our CommandTarget 
        // is based off of.  If the command target executing this command belongs to a different
        // IHTMLDocument than the edit context, we need to adjust the edit context

        if( !GetCommandTarget()->IsRange() )
        {
            BOOL                fHasContext;
            SP_IHTMLDocument2   spDoc;
            SP_IHTMLElement     spBody;

            IFC( GetEditor()->GetSelectionManager()->IsContextWithinContainer(  GetCommandTarget()->GetMarkupContainer(),
                                                                                &fHasContext ) );
            if( !fHasContext || !GetEditor()->GetSelectionManager()->IsEnabled())
            {
                // The markup container on which this command was executed was not in our edit
                // context, or our edit context is not enabled.  Get the body of the markup 
                // container on which this command was executed, and make it current.

                IFC( GetCommandTarget()->GetMarkupContainer()->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc) );
                IFC( GetEditor()->GetBody(&spBody, spDoc ) );
                IFC( GetEditor()->GetSelectionManager()->EnsureEditContextClick( spBody ) );
            }
        }                                               
                                        
        IFC( GetEditor()->GetSelectionManager()->SelectAll( spSegmentList, & fSelectedAll, GetCommandTarget()->IsRange() ));   
#ifdef FORMSMODE
    }
#endif 

Cleanup:

    return S_OK;
}

HRESULT 
CSelectAllCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CClearSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CClearSelectionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    IGNORE_HR( GetEditor()->GetSelectionManager()->EmptySelection( FALSE /*fHideCaret*/, FALSE /*fChangeTrackerAndSetRange*/) );

    return S_OK;
}

HRESULT 
CClearSelectionCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}

HRESULT 
CSelectAllCommand::SelectAllSiteSelectableElements()
{
    HRESULT              hr = S_OK;
    CSegmentList        *pSegmentList = NULL;
    SP_IHTMLElement      spStartElement ;
    SP_ISegmentList      spISegmentList ;
    SP_IElementSegment   spISegment ;
    int                  iCount = 0;
    BOOL                 fEqual = FALSE ;

    CEditPointer         ep(GetEditor());
    CEditPointer         epStart(GetEditor());
    CEditPointer         epEnd(GetEditor());

    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;    
 
    pSegmentList = new CSegmentList ;
    if( !pSegmentList )
        goto Error;

    pSegmentList->SetSelectionType( SELECTION_TYPE_Control );

    IFC( GetEditor()->GetBody(&spStartElement));
    IFC( epStart->MoveAdjacentToElement( spStartElement, ELEM_ADJ_AfterBegin ));
    IFC( epEnd->MoveAdjacentToElement  ( spStartElement, ELEM_ADJ_BeforeEnd  ));

    IFC( ep->MoveToPointer(epStart) );
    IFC( ep.SetBoundary( epStart, epEnd ));
    IFC( ep.Constrain() );
       
    IFC( epStart->IsEqualTo(epEnd, &fEqual) );
    
    while (!fEqual)
    {
        SP_IHTMLElement     spElement;
        ELEMENT_TAG_ID      eTag;
        DWORD               dwSearch = BREAK_CONDITION_EnterSite | BREAK_CONDITION_NoScopeSite;
        DWORD               dwFound = 0;

        IFC ( ep.Scan(RIGHT, dwSearch, &dwFound, &spElement, &eTag) );

        if  (!ep.CheckFlag(dwFound, BREAK_CONDITION_EnterSite | BREAK_CONDITION_NoScopeSite))
            break;

        //
        // Verify that this object CAN be site selected
        //
        IGNORE_HR( GetEditor()->GetSelectionManager()->GetControlTracker()->IsElementSiteSelectable( eTag, spElement, &eHow ));       
        if( eHow == CControlTracker::HS_FROM_ELEMENT )
        {            
            IFC( pSegmentList->AddElementSegment( spElement, &spISegment ) );
        }
        IFC( ep->IsEqualTo(epEnd, &fEqual) );
    }

    IFC(pSegmentList->QueryInterface(IID_ISegmentList, (void**)&spISegmentList));
    IFC(GetSegmentCount(spISegmentList , &iCount));
    if (iCount > 0)
    {       
         IFC(GetEditor()->GetSelectionManager()->Select(spISegmentList));
    }
    
Cleanup:
      if (pSegmentList)
        pSegmentList->Release();
    RRETURN (hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

////////////////////////////////////////////////////////////////////////////////
// CKeepSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CKeepSelectionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT hr = S_OK;
    
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetKeepSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else if ( (pvarargIn && pvarargIn->vt == VT_EMPTY) || !pvarargIn )
    {
        GetCommandTarget()->SetKeepSelection( ! GetCommandTarget()->IsKeepSelection());
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr ;
}

HRESULT 
CKeepSelectionCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsKeepSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\mshtmled.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       MSHTMLED.CXX
//
//  Contents:   Implementation of Mshtml Editing Component
//
//  Classes:    CMshtmlEd
//
//  History:    7-Jan-98   raminh  Created
//             12-Mar-98   raminh  Converted over to use ATL
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDUTIL_HXX_
#define _X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif
#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif
#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif
#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

MtDefine(CMshtmlEd, Utilities, "CMshtmlEd")

extern HRESULT      InsertObject (UINT cmdID, LPTSTR pstrParam, IHTMLTxtRange * pRange, HWND hwnd);
extern HRESULT      ShowEditDialog(UINT idm, VARIANT * pvarExecArgIn, HWND hwndParent, VARIANT * pvarArgReturn);

extern "C" const GUID CGID_EditStateCommands;

DeclareTag(tagEditingTrackQueryStatusFailures, "Edit", "Track query status failures")
ExternTag(tagEditingTrackExecFailures);
ExternTag(tagEditingExecRouting);

//+---------------------------------------------------------------------------
//
//  CMshtmlEd Constructor
//
//----------------------------------------------------------------------------
CMshtmlEd::CMshtmlEd( CHTMLEditor * pEd, BOOL fRange )
                        : _sl(this)
{
    Assert( pEd );
    Assert (_pISegList == NULL);
    Assert (_pSelectionServices == NULL);
    Assert (_fMultipleSelection == FALSE);          
    Assert (_fLiveResize == FALSE);
    Assert (_f2DPositionMode == FALSE);
    Assert (_fDisableEditFocusHandles == FALSE);    
    Assert (_fNoActivateNormalOleControls == FALSE);    
    Assert (_fNoActivateDesignTimeControls == FALSE);
    Assert (_fNoActivateJavaApplets == FALSE);;        
    Assert (_fInitialized == FALSE);
    
    _pEd = pEd;
    _cRef = 1;
    SetRange(fRange);
}


CMshtmlEd::~CMshtmlEd()
{
    ReleaseInterface( _pISegList );
    ReleaseInterface( _pIContainer );
    ReleaseInterface( (ISegmentList *)_pSelectionServices );
}


HRESULT
CMshtmlEd::Initialize( IUnknown *pContext )
{
    HRESULT hr = S_OK;

    //
    // If we have a range, then the context must be passed in (as we retrieve
    // the ISegmentList pointer off the context).  If we don't have a range, we
    // are being attached to an IHTMLDocument2 pointer, and we need to create
    // a selection services for this pointer
    //
#if DBG == 1
    {
        SP_IMarkupContainer spContainer;
        SP_ISegmentList     spSegList;

        if( _fRange )
        {
            IFC( pContext->QueryInterface( IID_ISegmentList, (void **)&spSegList ) );
            AssertSz( spSegList.p, "CMshtmlEd::Initialize: Trying to initialize a range based CMshtmlEd without an ISegmentList" );
        }
        else
        {
            IFC( pContext->QueryInterface( IID_IMarkupContainer, (void **)&spContainer ) );
            AssertSz( spContainer.p, "CMshtmlEd::Initialize: Trying to initialize a document based CMshtmlEd without an IHTMLDocument2" );
        }
    }
#endif // DBG
    
    if ( !_fRange )
    {       
        // Grab the IMarkupContainer interface
        IFC( pContext->QueryInterface( IID_IMarkupContainer, (void **)&_pIContainer ) );

        Assert( _pIContainer );
        
        //
        // We are a document command target.  Create a selection services pointer
        // to contain the selected segments for this doc.
        //
        _pSelectionServices = new CSelectionServices();
        if( !_pSelectionServices )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        IFC( _pSelectionServices->Init( _pEd, _pIContainer ) );
        IFC( _pSelectionServices->QueryInterface( IID_ISegmentList, (void **)&_pISegList ) );
    }
    else
    {
        IFC( pContext->QueryInterface( IID_ISegmentList, (void **)&_pISegList ) );
    }
        
    _fInitialized = TRUE;
    
Cleanup:
    RRETURN(hr);
}    


//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CMshtmlEd::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CMshtmlEd::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CMshtmlEd::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    if( iid == IID_IUnknown )
    {
        *ppv = static_cast< IUnknown * >( this );
    }
    else if( iid == IID_IOleCommandTarget )
    {
        *ppv = static_cast< IOleCommandTarget * >( this );
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

BOOL
CMshtmlEd::IsDialogCommand(DWORD nCmdexecopt, DWORD nCmdID, VARIANT *pvarargIn)
{
    BOOL bResult = FALSE;
    
    if (nCmdID == IDM_HYPERLINK)
    {
        bResult = (pvarargIn == NULL) || (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER);
    }
    else if (nCmdID == IDM_IMAGE || nCmdID == IDM_FONT)
    {
        bResult = (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER);
    }
    
    return bResult;
}


//+---------------------------------------------------------------------------
//
//  CMshtmlEd IOleCommandTarget Implementation for Exec() 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CMshtmlEd::Exec( const GUID *       pguidCmdGroup,
                       DWORD        nCmdID,
                       DWORD        nCmdexecopt,
                       VARIANTARG * pvarargIn,
                       VARIANTARG * pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    CCommand* theCommand = NULL;

    Assert( *pguidCmdGroup == CGID_MSHTML );
    Assert( _pEd );
    Assert( _pEd->GetDoc() );
    Assert( _pISegList );

    ((IHTMLEditor*) GetEditor())->AddRef();

    // ShowHelp is not implemented 
    if(nCmdexecopt == OLECMDEXECOPT_SHOWHELP)
        goto Cleanup;

    //
    // Do any pending tasks.
    //
    //
    // Dont do this for ComposeSettings, as the pending tasks, may cause the caret 
    // to attempt a scroll in the middle of a measure ( which will assert )
    //
    if ( nCmdID != IDM_COMPOSESETTINGS )
    {
        IFC( GetEditor()->DoPendingTasks() );
    }
    
    //
    // Give the editor a chance to route this exec to any external components
    // 
    IFC( GetEditor()->InternalExec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut ) );
    
    if( hr == S_OK )
        goto Cleanup;
    
    switch (nCmdID)
    {
        case IDM_NOACTIVATENORMALOLECONTROLS:
        case IDM_NOACTIVATEDESIGNTIMECONTROLS:
        case IDM_NOACTIVATEJAVAAPPLETS:
        {
            if (!pvarargIn || V_VT(pvarargIn) != VT_BOOL)
                return E_INVALIDARG;

            BOOL fSet = ENSURE_BOOL(V_BOOL(pvarargIn));

            if (nCmdID == IDM_NOACTIVATENORMALOLECONTROLS)
                SetNoActivateNormalOleControls(fSet);
            else if (nCmdID == IDM_NOACTIVATEDESIGNTIMECONTROLS)
                SetNoActivateDesignTimeControls(fSet);
            else if (nCmdID == IDM_NOACTIVATEJAVAAPPLETS)
                SetNoActivateJavaApplets(fSet);

            hr = S_OK;
            goto Cleanup;
        }

        default:
            break;
    }

    if (IsDialogCommand(nCmdexecopt, nCmdID, pvarargIn) )
    {
        // Special case for image or hyperlink or font dialogs
        theCommand = _pEd->GetCommandTable()->Get( ~nCmdID );    
    }
    else
    {
        theCommand = _pEd->GetCommandTable()->Get( nCmdID );
    }
    
    if ( theCommand )
    {
        hr = theCommand->Exec( nCmdexecopt, pvarargIn, pvarargOut, this );
    }
    else
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

#if DBG==1
    if (IsTagEnabled(tagEditingTrackExecFailures))
    {
        if (FAILED(hr))
        {
            CHAR szBuf[1000];

            wsprintfA(szBuf, "CHTMLEditor::Exec failed: nCmdId=%d, nCmdexecopt=0x%x, pvarargIn=0x%x, pvarargOut=0x%x",
                    nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            AssertSz(0, szBuf);
        }
    }
#endif    

Cleanup:

    ((IHTMLEditor*) GetEditor())->Release();

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  CMshtmlEd IOleCommandTarget Implementation for QueryStatus()
//
//  Note: QueryStatus() is still being handled by Trident
//----------------------------------------------------------------------------
STDMETHODIMP
CMshtmlEd::QueryStatus(
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        OLECMD rgCmds[],
        OLECMDTEXT * pcmdtext)
{
    HRESULT   hr = OLECMDERR_E_NOTSUPPORTED ;
    CCommand *theCommand = NULL;
    OLECMD   *pCmd = &rgCmds[0];

    Assert( *pguidCmdGroup == CGID_MSHTML );
    Assert( _pEd );
    Assert( _pEd->GetDoc() );
    Assert( _pISegList );
    Assert( cCmds == 1 );

    //
    // Give the editor a chance to intercept this query for any registered components
    // 
    IFC( GetEditor()->InternalQueryStatus( pguidCmdGroup, cCmds, rgCmds, pcmdtext ) );

    if (hr == S_OK && pCmd->cmdf)
        goto Cleanup;
    
    // TODO: The dialog commands are hacked with strange tagId's.  So, for now we just
    // make sure the right command gets the query status [ashrafm]
    
    if (pCmd->cmdID == IDM_FONT)
    {
        theCommand = GetEditor()->GetCommandTable()->Get( ~(pCmd->cmdID)  );
    }
    else
    {
        theCommand = GetEditor()->GetCommandTable()->Get( pCmd->cmdID  );
    }
    
    if (theCommand )
    {
        hr = theCommand->QueryStatus( pCmd, pcmdtext, this );                      
    }
    else 
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

#if DBG==1
    if (IsTagEnabled(tagEditingTrackQueryStatusFailures))
    {
        if (FAILED(hr))
        {
            CHAR szBuf[1000];

            wsprintfA(szBuf, "CMshtmlEd::QueryStatus failed: nCmdId=%d", pCmd->cmdID);
            AssertSz(0, szBuf);
        }
    }
#endif

Cleanup:
    RRETURN ( hr ) ;
}


HRESULT 
CMshtmlEd::GetSegmentList( ISegmentList **ppSegmentList ) 
{ 
    HRESULT hr = S_OK;

    Assert( ppSegmentList && IsInitialized() && _pISegList);
    
    IFC(  _pISegList->QueryInterface( IID_ISegmentList, (void **)ppSegmentList ));

Cleanup:    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OptsHold.rc
//
#define IDS_PROJNAME                    100
#define IDR_HTMLDLGHELPER               101
#define IDR_MSHTMLED                    102
#define IDR_FONTSOPTION                 103
#define IDR_HTMLEDITOR                  104
#define IDR_HTMLDLGSAFEHELPER           105
#define IDS_BLOCKFMT_NORMAL             1000
#define IDS_BLOCKFMT_PRE                1001
#define IDS_BLOCKFMT_ADDRESS            1002
#define IDS_BLOCKFMT_H1                 1003
#define IDS_BLOCKFMT_H2                         1004
#define IDS_BLOCKFMT_H3                         1005
#define IDS_BLOCKFMT_H4                         1006
#define IDS_BLOCKFMT_H5                         1007
#define IDS_BLOCKFMT_H6                         1008
#define IDS_BLOCKFMT_OL                         1009
#define IDS_BLOCKFMT_UL                         1010
#define IDS_BLOCKFMT_DIR                        1011
#define IDS_BLOCKFMT_MENU                       1012
#define IDS_BLOCKFMT_DT                         1013
#define IDS_BLOCKFMT_DD                         1014
#define IDS_BLOCKFMT_P                          1016
#define IDS_BLOCKFMT_PRE_TAG                    1017
#define IDS_BLOCKFMT_ADDRESS_TAG                1018
#define IDS_BLOCKFMT_H1_TAG                     1019
#define IDS_BLOCKFMT_H2_TAG                     1020
#define IDS_BLOCKFMT_H3_TAG                     1021
#define IDS_BLOCKFMT_H4_TAG                     1022
#define IDS_BLOCKFMT_H5_TAG                     1023
#define IDS_BLOCKFMT_H6_TAG                     1024
#define IDS_BLOCKFMT_OL_TAG                     1025
#define IDS_BLOCKFMT_UL_TAG                     1026
#define IDS_BLOCKFMT_DIR_TAG                    1027
#define IDS_BLOCKFMT_MENU_TAG                   1028
#define IDS_BLOCKFMT_DT_TAG                     1029
#define IDS_BLOCKFMT_DD_TAG                     1030
#define IDS_BLOCKFMT_P_TAG                      1031
#define IDS_BLOCKFMT_DIV_TAG                    1032

#define IDS_BEGIN_DELIMITER                     1033
#define IDS_END_DELIMITER                       1034
#define IDS_END_LINE_DELIMITER                  1035

//------------------------------------------------------------------------------------
//
// Bitmaps and other UI goodies
//
//------------------------------------------------------------------------------------

#define IDR_FEEDBACKRECTBMP             2505
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_CACHE_BEGIN                   2000
#define IDS_EDUNDO                        (IDS_CACHE_BEGIN)
#define IDS_EDREDO                        (IDS_EDUNDO + 1)
#define IDS_EDCANTUNDO                    (IDS_EDUNDO + 2)
#define IDS_EDCANTREDO                    (IDS_EDUNDO + 3)
#define IDS_EDUNDONEWCTRL                 (IDS_EDUNDO + 4)
#define IDS_EDUNDODELETE                  (IDS_EDUNDO + 5)
#define IDS_EDUNDOPROPCHANGE              (IDS_EDUNDO + 6)
#define IDS_EDUNDOMOVE                    (IDS_EDUNDO + 7)
#define IDS_EDUNDORESIZE                  (IDS_EDUNDO + 8)
#define IDS_EDUNDODRAGDROP                (IDS_EDUNDO + 9)
#define IDS_EDUNDOALIGN                   (IDS_EDUNDO + 10)
#define IDS_EDUNDOCENTER                  (IDS_EDUNDO + 11)
#define IDS_EDUNDOSIZETO                  (IDS_EDUNDO + 12)
#define IDS_EDUNDOSPACING                 (IDS_EDUNDO + 13)
#define IDS_EDUNDOARRANGE                 (IDS_EDUNDO + 14)
#define IDS_EDUNDOPASTE                   (IDS_EDUNDO + 15)
#define IDS_EDUNDOTYPING                  (IDS_EDUNDO + 16)
#define IDS_EDUNDOTEXTDELETE              (IDS_EDUNDO + 17)
#define IDS_EDUNDOCUT                     (IDS_EDUNDO + 18)
#define IDS_EDUNDOGENERICTEXT             (IDS_EDUNDO + 19)
#define IDS_EDUNDOCHANGEVALUE             (IDS_EDUNDO + 20)
#define IDS_EDUNDOBACKSPACE               (IDS_EDUNDO + 21)
#define IDS_EDUNDOBLOCKDIR                (IDS_EDUNDO + 22)
#define IDS_EDUNDOOVERWRITE               (IDS_EDUNDO + 23)
#define IDS_CACHE_END                     IDS_EDUNDOOVERWRITE

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\selserv.cxx ===
//+----------------------------------------------------------------------------
//
// File:        selserv.CXX
//
// Contents:    Implementation of CSelectionServices class
//
// Purpose:
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif


#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SLIST_HXX_
#define X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

using namespace EdUtil;

#if DBG == 1 
int CSelectionServices::s_NextSerialNumber = 1;
#endif

//-----------------------------------------------------------------------------
//
//  Function:   CSelectionServices::CSelectionServices
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CSelectionServices::CSelectionServices(void)
#if DBG == 1
    : _nSerialNumber( CSelectionServices::s_NextSerialNumber++ )
#endif
{
    _cRef = 1;
    _eType = SELECTION_TYPE_None;
    _pISelListener = NULL;
    _pIContainer = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::~CSelectionServices
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CSelectionServices::~CSelectionServices(void)
{
    ClearSegments();
    ReleaseInterface( _pISelListener );
    ReleaseInterface( _pIContainer );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::Init
//
//  Synopsis:   Initializes the CSelectionServices object
//
//  Arguments:  pEd = Pointer to CHTMLEditor object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::Init(CHTMLEditor *pEd, IMarkupContainer *pIContainer)
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( pEd && pIContainer );

    if( pEd && pIContainer )
    {
        _pEd = pEd;
        if (_pEd && _pEd->GetSelectionManager() && !_pEd->GetSelectionManager()->_fInitialized)
        {
            _pEd->GetSelectionManager()->Initialize();
        }
        _pIContainer = pIContainer;
        _pIContainer->AddRef();
        
        hr = S_OK;
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( _pEd->ShouldLieToAccess()  )
    {
        *peType = _pEd->AccessLieType(); 
        hr = S_OK;
    }
    else
    {
        hr = CSegmentList::GetType(peType);
    }
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::SetSelectionType
//
//  Synopsis:   Sets the current selection type of the CSelectionServices.
//              Only one type of selection can be active at any given point.
//              Any time this method is called, all segments are cleared.
//
//  Arguments:  eType = new selection type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::SetSelectionType(SELECTION_TYPE eType, ISelectionServicesListener* pIListener )
{
    HRESULT         hr = S_OK;
    SP_ISegment     spICaretSegment = NULL;
    SP_IHTMLCaret   spICaret = NULL;

    Assert( eType == SELECTION_TYPE_None || pIListener );
    if ( _pISelListener )
    {
        IGNORE_HR( _pISelListener->OnChangeType( eType, pIListener ));
    }
    
    // Clear any existing segments, and set the new type
    IFC( CSegmentList::SetSelectionType(eType) );

    //
    // Setup the selection listener interfaces
    //
    ClearInterface( & _pISelListener );

    if ( pIListener )
    {
        ReplaceInterface( & _pISelListener, pIListener );
    }

    if( eType == SELECTION_TYPE_Caret )
    {
        SP_IMarkupPointer   spPointer;
        BOOL                fPositioned;
        BOOL                fVisible;

        IFC( _pEd->GetDisplayServices()->GetCaret(&spICaret) );

        IFC( _pEd->CreateMarkupPointer(&spPointer) );
        IFC( spICaret->MoveMarkupPointerToCaret(spPointer) );

        IFC( spPointer->IsPositioned(&fPositioned) );
        IFC( spICaret->IsVisible( &fVisible ) );

        if( fPositioned && fVisible )
        {
            IFC( AddCaretSegment( spICaret, &spICaretSegment ) );
        }
        else
        {
            IFC( CSegmentList::SetSelectionType(SELECTION_TYPE_None) );
        }
    }
       
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::GetMarkupContainer
//
//  Synopsis:   Retrieves the markup container in which all the segments
//              in CSelectionServices belong to.  CSelectionServices
//              can only contain selection segments from the same markup.
//              Any attempt to add multiple segments which belong to different
//              markups will result in a failure.
//
//  Arguments:  ppIContainer = OUTPUT - Markup container
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::GetMarkupContainer(IMarkupContainer **ppIContainer)
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( ppIContainer && _pIContainer);

    if( ppIContainer && _pIContainer )
    {
        *ppIContainer = _pIContainer;
        (*ppIContainer)->AddRef();

        hr = S_OK;
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::EnsureMarkupContainer
//
//  Synopsis:   Ensures the pointers passed in are compatible with the 
//              current markup container.
//
//  Arguments:  pIStart = INPUT - Starting pointer
//              pIEnd = INPUT - Ending pointer
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::EnsureMarkupContainer(IMarkupPointer *pIStart, IMarkupPointer *pIEnd )
{
    HRESULT             hr;
    SP_IMarkupContainer spStartContainer;
    SP_IMarkupContainer spEndContainer;
    
    Assert( pIStart && pIEnd );
    Assert( _pIContainer != NULL );

    //
    // Retrieve the containers
    //
    IFC( pIStart->GetContainer( &spStartContainer ) );
    IFC( pIEnd->GetContainer( &spEndContainer ) );

    //
    // Make sure the containers are equal, and they match the current container
    //
    if( !EqualContainers( spStartContainer, spEndContainer ) ||
        !EqualContainers( spStartContainer, _pIContainer )  )
    {
        AssertSz(FALSE, "Attempting to add a segment from a different markup to SelServ");
        hr = E_FAIL;
    }
    
Cleanup:

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::EnsurePositioned
//
//  Synopsis:   Ensures the pointers passed in are positioned
//
//  Arguments:  pIStart = INPUT - Starting pointer
//              pIEnd = INPUT - Ending pointer
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::EnsurePositioned(IMarkupPointer *pIStart, IMarkupPointer *pIEnd )
{
    BOOL    fPositioned;
    HRESULT hr = S_OK;
    
    Assert( pIStart && pIEnd );
    
    IFC( pIStart->IsPositioned(&fPositioned) );
    if( !fPositioned )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIEnd->IsPositioned(&fPositioned) );
    if( !fPositioned )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSelectionServices::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CSelectionServices::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CSelectionServices::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegmentList)
    {
        *ppvObj = (ISegmentList *)this;
    }
    else if( iid == IID_ISelectionServices )
    {
        *ppvObj = (ISelectionServices *)this;
    }    
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::ClearSegments
//
//  Synopsis:   Removes all of the segments currently in use
//
//  Arguments:  fInvalidate = BOOLEAN indicating whether to invalidate the
//              segments.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionServices::ClearSegments()
{
    HRESULT         hr = S_OK;

    // Free any empty elements so we can
    // do a simple recursion thru our segments
    IFC( RemoveAll() );
    
Cleanup:
    
    RRETURN(hr);
}

HRESULT
CSelectionServices::AddSegment( IMarkupPointer  *pStart,
                                IMarkupPointer  *pEnd,
                                ISegment        **pISegmentAdded)
{
    HRESULT             hr;

    //
    // Make sure we are positioned
    //
    IFC( EnsurePositioned( pStart, pEnd ) );
    
    //
    // Ensure we are in the right container
    //
    // IFC( EnsureMarkupContainer( pStart, pEnd ) );

    //
    // Add the element segment
    //
    IFC( CSegmentList::AddSegment(pStart, pEnd, pISegmentAdded) );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionServices::AddElementSegment(  IHTMLElement     *pIElement,
                                        IElementSegment  **ppISegmentAdded)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;

    //
    // Add the element segment
    //
    IFC( CSegmentList::AddElementSegment(pIElement, ppISegmentAdded) );

    //
    // Position pointers, and set (or ensure) the markup container
    //       
    IFC( CreateMarkupPointer2( GetEditor(), &spStart ) );
    IFC( CreateMarkupPointer2( GetEditor(), &spEnd ) );
    IFC( (*ppISegmentAdded)->GetPointers( spStart, spEnd ) );

    //
    // Ensure we are position
    //
    IFC( EnsurePositioned( spStart, spEnd ) );
    
    //
    // We have to do the add first, to get the IElementSegment
    //
    Assert( GetSize() );

    // IFC( EnsureMarkupContainer( spStart, spEnd ) );

Cleanup:
    RRETURN(hr);
    
}

HRESULT
CSelectionServices::RemoveSegment(ISegment *pISegment)
{
    HRESULT hr;
    BOOL fEmpty;
    
    hr = THR( CSegmentList::RemoveSegment(pISegment));

    IGNORE_HR( IsEmpty( & fEmpty ));

    if ( fEmpty )
    {
        CSegmentList::SetSelectionType( SELECTION_TYPE_None);
        ClearInterface( & _pISelListener );
    }
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionServices::GetSelectionServicesListener( ISelectionServicesListener** ppISelectionUndoListener)
{
    if ( ! ppISelectionUndoListener )
    {
        return E_INVALIDARG;
    }

    *ppISelectionUndoListener = NULL;
    
    if( ! _pISelListener )
    {
        return E_FAIL;
    }    

    ReplaceInterface( ppISelectionUndoListener,_pISelListener );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\stdafx.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.CXX
//
//  Contents:   Source file that includes ATL standard files
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#pragma warning(disable:4701)   /* local variable  may be used without having been initialized */
#include "stdafx.h"

#pragma warning(disable:4189)   /* local variable is initialized but not referenced */

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\selman.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       SELMAN.CXX
//
//  Contents:   Implementation of ISelectionManager interface inisde of mshtmled.dll
//
//  Classes:    CMshtmlEd
//
//  History:    06-10-98 - marka - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_ 
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef  X_EDTRACK_HXX_
#define  X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef X_IME_HXX_
#define X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CSelectionManager, Utilities, "Selection Manager")
DeclareTag(tagSelectionMgrState, "Selection", "Selection show manager state")
DeclareTag(tagSelectionMgrNotify, "Selection", "SelectionManager show TrackerNotify")
DeclareTag(tagSelectionMessage, "Selection","Show New Edit Messages")
DeclareTag(tagSelectionChangeCounter, "Selection", "Selection change counter");

ExternTag( tagSelectionTrackerState );

extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);
#if DBG == 1

static const LPCTSTR strStartContext = _T( "   ** Start_Edit_Context");
static const LPCTSTR strEndContext = _T( "   ** End_Edit_Context");
#endif

extern BOOL g_fInVizAct2000  ;

CSelectionManager::CSelectionManager( CHTMLEditor * pEd )
                                 : _pEd( pEd )
{
    _ulRefs = 1;
    Init();
}

HRESULT
CSelectionManager::Initialize()
{
    HRESULT hr = S_OK;
    IHTMLDocument4 *pDoc = NULL;

    if (_fInInitialization)
    {
        return hr;
    }
    _fInInitialization = TRUE;
    
    //
    // Create our listeners that derive from CDispWrapper.  Since we pass
    // out IDispatch pointers when we do an AttachEvent() with these 
    // listeners, they must obey all nice COM rules.
    //
    _pEditContextBlurHandler = new CEditContextHandler(this);
    if( !_pEditContextBlurHandler )
        goto Error;

    _pActElemHandler = new CActiveElementHandler(this);
    if( !_pActElemHandler )
        goto Error;

    _pDragListener = new CDragListener(this);
    if( !_pDragListener )
        goto Error;

    _pFocusHandler = new CFocusHandler(this);
    if( !_pFocusHandler )
        goto Error;
        
    _pExitTimer = new CExitTreeTimer(this);
    if( !_pExitTimer )
        goto Error;

    _pDropListener = new CDropListener(this);
    if( !_pDropListener )
        goto Error;
   
    IFC( _pEd->CreateMarkupPointer(& _pStartContext ));
    IFC( _pStartContext->SetGravity( POINTER_GRAVITY_Left ) );
    IFC( _pEd->CreateMarkupPointer( &_pEndContext ));
    IFC( _pEndContext->SetGravity( POINTER_GRAVITY_Right ) );

    pDoc = _pEd->GetDoc4();
    IFC(pDoc->createRenderStyle(NULL, &_pISelectionRenderStyle));
    
#if DBG == 1
    SetDebugName( _pStartContext,strStartContext );
    SetDebugName( _pEndContext,strEndContext );
#endif

    IFC( InitTrackers());
    IFC( EnsureDefaultTracker());
    

    IFC( SetInitialEditContext());    

Cleanup:
    ReleaseInterface(pDoc);
    _fInitialized = TRUE;
    _fInInitialization = FALSE;
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


HRESULT 
CSelectionManager::Passivate(BOOL fEditorReleased /* = FALSE */)
{
    if (_pEd)
    {
        ClearInterface( &_pStartContext );
        ClearInterface( &_pEndContext );
        ClearInterface( &_pIEditableElement );
        ClearInterface( &_pIEditableFlowElement );
        ClearInterface( &_pDeferStart );
        ClearInterface( &_pDeferEnd ); 
        ClearInterface( &_pISelectionRenderStyle );

        ClearInterface( &_pIElementExitStart);
        ClearInterface( &_pIElementExitEnd );
        ClearInterface( &_pIElementExitContentStart );
        ClearInterface( &_pIElementExitContentEnd);
        IGNORE_HR( DestroyFakeSelection());
       
        if ( _pIBlurElement )
        {
            IGNORE_HR( DetachEditContextHandler());
        }
        
        if ( _pIActiveElement )
        {
            IGNORE_HR( DetachActiveElementHandler());
        }
        if ( _pIDropListener )
        {
            IGNORE_HR( DetachDropListener());
        }
        if ( _fInExitTimer )
        {
            IGNORE_HR( StopExitTreeTimer());
            Assert( ! _pITimerWindow );
        }

        if( _pISCList )
        {
            delete _pISCList;
            _pISCList = NULL;
        }
            
        //
        // Release all of our IDispatch based event handlers
        //
        if ( _pEditContextBlurHandler )
        {
            _pEditContextBlurHandler->SetManager(NULL);
            ClearInterface( &_pEditContextBlurHandler );
        }
        if ( _pActElemHandler )
        {
            _pActElemHandler->SetManager(NULL);
            ClearInterface( &_pActElemHandler );
        }
        if ( _pDragListener )
        {
            _pDragListener->SetManager(NULL);
            ClearInterface( &_pDragListener );
        }
        if ( _pFocusHandler )
        {    
            _pFocusHandler->SetManager(NULL);
            ClearInterface( &_pFocusHandler );
        }
        if ( _pExitTimer )
        {
            _pExitTimer->SetManager(NULL);
            ClearInterface( &_pExitTimer );
        }
        if ( _pDropListener )
        {
            _pDropListener->SetManager(NULL);
            ClearInterface( &_pDropListener );
        }

        Assert(!_pIme);

        DestroyAdorner();
        DestroyTrackers(); 

        if ( _pIFocusWindow )
        {
            IGNORE_HR( DetachFocusHandler());
            Assert( ! _pIFocusWindow );
        }
        
        Assert( ! _fInCapture );
    }

    if (fEditorReleased)
        _pEd = NULL;

    return S_OK;
}


CSelectionManager::~CSelectionManager()
{
    Passivate();
}


VOID
CSelectionManager::Init()
{
    Assert( !_pActiveTracker );    // The currently active tracker.
    Assert( !_pAdorner );
    Assert( !_pStartContext );
    Assert( ! _pEndContext );
    Assert( !_pISCList );
    Assert( !_pIEditableElement);
    Assert( !_pIEditableFlowElement);
    Assert( !_pEditContextBlurHandler );
    Assert( !_pActElemHandler );
    Assert( !_pDragListener );
    Assert( !_pFocusHandler );
    Assert( !_pExitTimer );
    
    _fInitSequenceChecker = FALSE;
    _fIgnoreSetEditContext = FALSE;
    _fDontChangeTrackers = FALSE;
    _fDrillIn = FALSE;
    _fLastMessageValid = FALSE;
    _fNoScope = FALSE;
    _fInTimer = FALSE;
    _fInCapture = FALSE;
    _fContextAcceptsHTML = FALSE;
    _fPendingUndo = FALSE ;
    _pDeferStart = NULL;
    _pDeferEnd = NULL;
    _fContextEditable = FALSE;
    _fParentEditable = FALSE;
    _fPositionedSet = FALSE;
    _fDontScrollIntoView = FALSE ;
    _fDestroyedTextSelection = FALSE ;
    
    _eDeferSelType = SELECTION_TYPE_None;
    _lastStringId = UINT(-1);
    _eContextTagId = TAGID_NULL ;
    _fEditFocusAllowed = TRUE;

    _fInitialized = FALSE;
    _fInInitialization = FALSE;

#ifdef FORMSMODE
    _eSelectionMode = SELMODE_MIXED; // THIS MUST go before setting the edit context
#endif
    
    WHEN_DBG( _ctMsgLoop = 0 );
    WHEN_DBG( _ctEvtLoop = 0 );
    WHEN_DBG( _ctSetEditContextCurChg = 0 );    

    CreateISCList();
}
//+------------------------------------------------------------------------
//
//  Member:     CSelectionManager::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------
HRESULT
CSelectionManager::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown ||
       riid == IID_ISelectionServicesListener )
    {
        *ppv = this;
    }
    
    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}
//+====================================================================================
//
// Method: InitTrackers
//
// Synopsis: Initialize all trackers 
//
//------------------------------------------------------------------------------------


HRESULT
CSelectionManager::InitTrackers()
{
    Assert( ! _pCaretTracker );
    _pCaretTracker = new CCaretTracker( this );
    if ( ! _pCaretTracker )
        goto Error;

    Assert( ! _pSelectTracker );
    _pSelectTracker = new CSelectTracker( this );
    if ( ! _pSelectTracker )
        goto Error;

    Assert( ! _pControlTracker );
    _pControlTracker = new CControlTracker( this );        
    if ( ! _pControlTracker )
        goto Error;

    return S_OK;
  
Error:
    return( E_OUTOFMEMORY );
}

VOID
CSelectionManager::DestroyTrackers()
{
    HibernateTracker( NULL, TRACKER_TYPE_None, FALSE); // don't tear down UI during passivation
    _pActiveTracker = NULL;
    _pCaretTracker->Release();   _pCaretTracker = NULL;
    _pSelectTracker->Release();  _pSelectTracker = NULL;
    _pControlTracker->Release(); _pControlTracker = NULL;
}

//+=====================================================================
// Method: HandleMessage
//
// Synopsis: Handle a UI Message passed from Trident to us.
//
//----------------------------------------------------------------------
#define OEM_SCAN_RIGHTSHIFT 0x36

HRESULT
CSelectionManager::HandleEvent( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE ;
    BOOL    fStarted = FALSE;
    Assert( _pEd->GetDoc() );
    HWND    hwndDoc;
    CEditTracker* pTracker = _pActiveTracker;

    if ( pTracker )
        pTracker->AddRef();
        
#ifndef NO_IME
    //
    // Always check to see if IME wants to handle it.
    //
    hr = THR( HandleImeEvent(pEvent) );
    if (S_OK == hr)
    {
        goto Cleanup;
    }
#endif // NO_IME
    
    switch ( pEvent->GetType() )
    {
        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
#ifdef UNIX
        case EVT_MMOUSEDOWN:
#endif
            {
                CSelectionChangeCounter selCounter(this);
                BOOL fChangedCurrency = FALSE;
                BOOL fSelectionTrackerChange = FALSE;
                BOOL fSelectionExtended = FALSE;
                TRACKER_TYPE eType = GetTrackerType();
                TRACKER_TYPE eNewType = eType;

                SP_IHTMLElement spElement;
                IFC( pEvent->GetElement( & spElement));
                if ( CheckUnselectable( spElement ) == S_OK )
                {
                    goto Cleanup;
                }

                selCounter.BeginSelectionChange();

                if ( pEvent->GetType() == EVT_LMOUSEDOWN ||
                     pEvent->GetType() == EVT_RMOUSEDOWN )
                {
                    IFC( EnsureEditContextClick( spElement, pEvent , & fChangedCurrency ));
                }

                if ( IsDefaultTrackerPassive() ||
                    !_pActiveTracker->IsListeningForMouseDown(pEvent) )
                {
                    SP_IOleWindow spOleWindow;

                    IFC(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
                    IFC(spOleWindow->GetWindow(&hwndDoc));
                    POINT pt;
                    IFC( pEvent->GetPoint( & pt ));

                    if ( ! GetEditor()->IsInWindow( hwndDoc, pt , TRUE))
                    {
                        hr = S_FALSE;
                        goto Cleanup; // Ignore mouse down messages that aren't in Trident's Window or in the Content of the EditContext
                    }                        
                    hr = ShouldChangeTracker( pEvent, & fStarted );
                    if ( !fStarted )
                        hr = _pActiveTracker->HandleEvent( pEvent );
                }
                else
                {
                    if( pEvent->GetType() != EVT_RMOUSEDOWN || IsIMEComposition() )
                        hr = _pActiveTracker->HandleEvent( pEvent );
                }

                //  Now determine if we changed to/from a select tracker.  If we did then we want to
                //  fire off a selection change event.

                eNewType = GetTrackerType();

                if (eType != eNewType &&
                    (eType == TRACKER_TYPE_Selection || eNewType == TRACKER_TYPE_Selection))
                {
                    fSelectionTrackerChange = TRUE;
                }

                if (eNewType == TRACKER_TYPE_Selection && _pSelectTracker->IsSelectionShiftExtending())
                {
                    fSelectionExtended = TRUE;
                }

                selCounter.EndSelectionChange( fChangedCurrency || fStarted || fSelectionTrackerChange || fSelectionExtended);
                
#ifdef UNIX
                if ( pEvent->GetType() == EVT_MMOUSEDOWN )
                    hr = S_FALSE;
#endif
                //
                // Special case context menu.
                //

                if ( pEvent->GetType() == EVT_RMOUSEDOWN )
                    hr = S_FALSE ;  // don't cancel bubbling for the editor

                _fEnsureAtomicSelection = TRUE;
            }                
            break;

        case EVT_KEYDOWN:
        case EVT_KEYUP:
            if ( ! IsEnabled() )
            {
                goto Cleanup;
            }
            // else continue
            //
            
        case EVT_LMOUSEUP:
        case EVT_RMOUSEUP:
        case EVT_DBLCLICK:
        case EVT_MOUSEMOVE:
        case EVT_CONTEXTMENU:
        case EVT_TIMER:
        case EVT_CLICK:
        case EVT_INTDBLCLK:
        case EVT_LOSECAPTURE:

        case EVT_KILLFOCUS:
        case EVT_SETFOCUS:

            AssertSz( _pActiveTracker, "Expected to have a tracker when you have an event");            
            if ( _pActiveTracker )
            {
                hr = _pActiveTracker->HandleEvent( pEvent );

                if (pEvent->GetType() == EVT_RMOUSEUP )
                    hr = S_FALSE;
            }

            //
            // Pretend we didn't handle this internal event.  This event occurs when
            // Trident gets a WM_LBUTTONDBLCLK windows message.  We use this to
            // maintain compat with previous versions of IE, and it shouldn't look
            // like we handle this message
            //
            if( pEvent->GetType() == EVT_INTDBLCLK )
            {
                hr = S_FALSE;
            }

            // See if we got a click event on a control in a text selection.  If so,
            // we want to transition to a control tracker.

            if (pEvent->GetType() == EVT_CLICK &&
                GetTrackerType() == TRACKER_TYPE_Selection)
            {
                ELEMENT_TAG_ID      eTag;
                SP_IHTMLElement     spElement ;
                SST_RESULT          eResult      = SST_NO_CHANGE;

                //  We need to check to see if we are clicking in a table.  The table
                //  editor designer could have made a text selection here while the
                //  user clicked within the table (eg. column selection).  However,
                //  we don't want to site select the table.  We won't get to this point
                //  when normally site selecting the table because we would have already
                //  done that by now on the mouse down.
                IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));
                if (eTag != TAGID_TABLE)
                {
                    IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
                
                    if (eResult == SST_CHANGE)
                    {
                        CSelectionChangeCounter selCounter(this);
                        selCounter.BeginSelectionChange();

                        hr = THR( SetCurrentTracker( TRACKER_TYPE_Control, pEvent, 0));
                        // fire the selectionchange event
                        selCounter.EndSelectionChange();         
                    }
                }
            }
            
            if (pEvent->GetType() == EVT_LMOUSEUP || pEvent->GetType() == EVT_RMOUSEUP || pEvent->GetType() == EVT_INTDBLCLK)
            {
                _fEnsureAtomicSelection = TRUE;
            }

            break;


        case EVT_KEYPRESS: 
            if ( ! IsEnabled() )
            {
                goto Cleanup;
            }
            hr = _pActiveTracker->HandleEvent( pEvent );
            break;

        case EVT_INPUTLANGCHANGE:

            // Update the Input Sequence Checker (Thai, Hindi, Vietnamese, etc.)
            LONG_PTR lParam;
            IFC( DYNCAST( CHTMLEditEvent, pEvent)->GetKeyboardLayout( & lParam ));
            LCID lcidCurrent = LOWORD(lParam);            
            // PaulNel - If ISC is not initialized, this is a good place to do it.
            if(!_fInitSequenceChecker)
            {
                CreateISCList();
            }
            if(_pISCList)
            {
                _pISCList->SetActive(lcidCurrent);
            }

            hr = _pActiveTracker->HandleEvent( pEvent );
            break;
    }

    //  Make sure we don't position a caret inside of an atomic element
    if (_fEnsureAtomicSelection &&
        (GetTrackerType() == TRACKER_TYPE_Caret ||
         GetTrackerType() == TRACKER_TYPE_Selection))
    {
        IGNORE_HR( _pActiveTracker->EnsureAtomicSelection(pEvent) );
    }
    
Cleanup:

    _fEnsureAtomicSelection = FALSE;

    if ( pTracker )
        pTracker->Release();

    return ( hr );
}

HRESULT
CSelectionManager::EnsureEditContext()
{
    HRESULT hr = S_OK;

    if (!_fInitialized)
    {
        hr = THR(Initialize() );
        if (hr)
            goto Cleanup;
    }
    
    if ( !_pIEditableElement )
    {
        IFC( SetInitialEditContext());
    }

    IFC( DoPendingTasks() );
    
    if (! _pIEditableElement)
        hr = E_FAIL;
Cleanup:        
    RRETURN( hr );
}

//+====================================================================================
//
// Method:      SetEditContext
//
// Synopsis:    Sets the "edit context". Called by trident when an Editable
//              element is made current.
//
// Arguements:  fEditable = Is the element becoming active editable?
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::SetEditContext(  
                            BOOL fEditable,
                            BOOL fParentEditable,
                            IMarkupPointer* pStart,
                            IMarkupPointer* pEnd,
                            BOOL fNoScope ,
                            BOOL fFromClick /*=FALSE*/ )
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    BOOL            fContextChanging;
    
    Assert( GetDoc() );

    IFC( GetEditor()->SetActiveCommandTargetFromPointer( pStart ) );
    
    fContextChanging = IsContextChanging( fEditable, fParentEditable, pStart, pEnd, fNoScope );
    
    if ( fContextChanging )
    {
        IFC( InitEditContext ( fEditable, 
                               fParentEditable, 
                               pStart, 
                               pEnd, 
                               fNoScope ));
    }

    //
    // Set our "enableness" based on whether the edit context is enabled. .
    //
    SetEnabled( EdUtil::IsEnabled( _pIEditableElement) == S_OK );
    
    if ( fContextChanging ||
         IsDefaultTrackerPassive() ||   // we may have lost a tracker on a lose focus
         _fDrillIn )            // always bounce trackers on Drilling In
    {
        IFC( CreateTrackerForContext( pStart, pEnd ));       
    }

#ifdef FORMSMODE
    // Set the selection mode based on the currently editable content (for view linking, this
    // will return the root element)
    IFC( GetEditableContent(&spElement) );
    if (spElement != NULL)
    {
        IFC( SetSelectionMode(spElement) );
    }
#endif    

    Assert( _pActiveTracker );
    IFC( _pActiveTracker->OnSetEditContext( fContextChanging ));

    IFC( EnsureAdornment( !fFromClick || fContextChanging ));    

    //
    // Reset the drill in flag
    //
    _fDrillIn = FALSE;

Cleanup:

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsContextChanging ?
//
// Synopsis:Is the Current context in any way different from the given context ?
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::IsContextChanging(
                            BOOL fEditable, 
                            BOOL fParentEditable,
                            IMarkupPointer* pStart,
                            IMarkupPointer* pEnd,
                            BOOL fNoScope )
{
    BOOL fChanging = FALSE;
    
    fChanging =  fEditable !=  ENSURE_BOOL( _fContextEditable) ||
                 fNoScope != ENSURE_BOOL( _fNoScope ) ||
                 fParentEditable != ENSURE_BOOL( _fParentEditable ) ||
                 ! IsSameEditContext( pStart, pEnd ) ||
                 _pIEditableElement == NULL ;

    return fChanging ;
    
}

//+====================================================================================
//
// Method: InitEditContext
//
// Synopsis: Set all state associated with the edit context.
//
//------------------------------------------------------------------------------------

HRESULT 
CSelectionManager::InitEditContext(
                           BOOL fEditable,
                           BOOL fParentEditable,
                           IMarkupPointer* pStart,
                           IMarkupPointer* pEnd,
                           BOOL fNoScope)
{
    HRESULT hr = S_OK;
    BOOL    fIsPassword = FALSE;
    SP_IHTMLElement  spElement;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement  spContainer;
    VARIANT_BOOL     fHTML;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;            
    
    IFC( _pStartContext->MoveToPointer( pStart ));
    IFC( _pEndContext->MoveToPointer( pEnd ));
    _fNoScope = fNoScope; // Why ? We need to set this to ensure edit context is set correctly.
    
    //
    // Set the Editable Element
    //

    if ( _pIBlurElement )
    {
        IFC( DetachEditContextHandler());
    }
    
    ClearInterface( & _pIEditableElement );
    ClearInterface( & _pIEditableFlowElement );

    IFC( InitializeEditableElement());

    //
    // Set the doc the editor is in.
    //
    IFC( GetEditableElement()->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
    GetEditor()->SetDoc( spElemDoc );
    
    IFC( GetEditor()->IsPassword( _pIEditableElement, & fIsPassword ));

    _fEnableWordSel =  ! fIsPassword ;
    _fContextEditable = fEditable;
    _fParentEditable = fParentEditable ;
    _eContextTagId = TAGID_NULL;
    _fPositionedSet = FALSE;
    _fEditFocusAllowed = TRUE;
    //
    // Set _fContextAcceptsHTML - and reset spring loader - if context doesn't accept HTML
    //
    _fContextAcceptsHTML = FALSE; // false by default

    // Determine the ContextAcceptsHTML attribute based on the editable element
    // (master in the view-linking scenario)
    IFC( _pIEditableElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC( spElement3->get_canHaveHTML(&fHTML) );
    _fContextAcceptsHTML = !!fHTML;
    
    if (!_fContextAcceptsHTML )
    {
        CSpringLoader *psl = _pActiveTracker->GetSpringLoader();

        if (psl)
            psl->Reset();
    }

    IFC( AttachEditContextHandler());
    
Cleanup:
    RRETURN( hr );
    
}

//+====================================================================================
//
// Method: CreateTrackerForContext
//
// Synopsis: Create a tracker appropriate for your edit context. If we had a caret
//           in the context - and we are creating a caret - we restore the caret to that location.
//
//------------------------------------------------------------------------------------

//
// NOTE: the pointers passed in may be adjusted ( due to caret calling AdjPointerForIns ).
//

HRESULT
CSelectionManager::CreateTrackerForContext( 
                                IMarkupPointer* pStart, 
                                IMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    TRACKER_TYPE myType = TRACKER_TYPE_Caret;

    if ( WeOwnSelectionServices() == S_FALSE )
        goto Cleanup;

#ifdef FORMSMODE
    if (IsInFormsSelectionMode())
    {
        SP_IDisplayPointer spDispPointer;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
        hr = THR( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
        if ( hr == CTL_E_INVALIDLINE)
        {
            CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
            hr = S_OK;
            goto Cleanup;
        }
        else if ( FAILED(hr))
        {
            goto Cleanup;
        }
        hr = SetCurrentTracker( TRACKER_TYPE_Caret , spDispPointer, spDispPointer );
    }
    else
    {      
#endif
        if ( ! IsDontChangeTrackers() &&
               GetEditableElement() && 
               CheckUnselectable( GetEditableElement() ) != S_OK )
        {

            //
            // don't change trackers if we have a selection in the context already.
            //
            if ( GetTrackerType() == TRACKER_TYPE_Selection &&
                 _pActiveTracker->IsPassive() && 
                 IsInEditContext( _pSelectTracker->GetStartSelection(), TRUE ) &&
                 IsInEditContext( _pSelectTracker->GetEndSelection() , TRUE ))
            {
                goto Cleanup;                
            }
            
            //
            // If we have a no scope element, we don't want to destroy the current tracker unless
            // we are drilling into an element.
            //
            ELEMENT_TAG_ID  eTag;
        
            IFC( GetMarkupServices()->GetElementTagId(_pIEditableElement, & eTag));

            if( !_fNoScope || _fDrillIn || eTag == TAGID_APPLET)
            {
            //
                // See if we already had a caret in this edit context.
                // if so - create the tracker there instead of just at the start of the edit context
                //
                if ( myType == TRACKER_TYPE_Caret && !_fInPendingElementExit && 
                     IsCaretAlreadyWithinContext() && 
                     GetTrackerType() != TRACKER_TYPE_Control)
                {
                    SP_IHTMLCaret       spCaret;
                    SP_IDisplayPointer  spDispPointer;
                    CSelectionChangeCounter selCounter(this);
                    BOOL                fOldDontScrollIntoView;
                    
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
                    IFC( GetDisplayServices()->GetCaret(&spCaret) );
                    IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer) );

                    selCounter.BeginSelectionChange();
                    fOldDontScrollIntoView = _fDontScrollIntoView;
                    _fDontScrollIntoView = TRUE;
                    hr = SetCurrentTracker( myType  , spDispPointer, spDispPointer );
                    _fDontScrollIntoView = fOldDontScrollIntoView;
                    selCounter.EndSelectionChange(); 
                }
                else
                {
                    CSelectionChangeCounter selCounter(this);
                    SP_IDisplayPointer spDispStart;
                    SP_IDisplayPointer spDispEnd;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) )

                    hr = THR( spDispStart->MoveToMarkupPointer(pStart, NULL) );
                    if ( hr == CTL_E_INVALIDLINE)
                    {
                        CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else if ( FAILED(hr))
                    {
                        goto Cleanup;
                    }
                    
                    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) )

                    hr = THR( spDispEnd->MoveToMarkupPointer(pEnd, NULL) );
                    if ( hr == CTL_E_INVALIDLINE)
                    {
                        CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else if ( FAILED(hr))
                    {
                        goto Cleanup;
                    }

                    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );                

                    selCounter.BeginSelectionChange();
                    hr = SetCurrentTracker( myType , spDispStart, spDispEnd );
                    selCounter.EndSelectionChange();                    
                }

                //
                // We must hide the caret that was just positioned if the
                // context is being set to a no-scope element.  The start
                // and end pointers will be set to before and after the element,
                // so the caret will actually be hidden before the element.
                //
                if( _fNoScope )
                {
                    CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                }
                
            }
            else
            {
                CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
            }            
        }
#ifdef FORMSMODE
    }            
#endif

Cleanup:
    if ( ShouldDestroyAdorner() == S_OK )         
        DestroyAdorner();

    RRETURN ( hr );    
}

//
// CHeck to see if we should tear down the existing adorner
// for the current edit context
//
HRESULT
CSelectionManager::ShouldDestroyAdorner()
{
    HRESULT hr;
    SP_IHTMLElement spAdornElement;;

    if ( _pAdorner )
    {
        IFC( GetElementToAdorn( GetEditableElement(), & spAdornElement ));
        hr = SameElements( _pAdorner->GetAdornedElement(), spAdornElement ) ? S_FALSE : S_OK;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::GetElementToAdorn(
            IHTMLElement* pIElement , 
            IHTMLElement** ppIElement , 
            BOOL* pfAtBoundaryOfVL)
{
    HRESULT hr = S_OK ;
    SP_IHTMLElement spAdorn;
    BOOL fAtVL = FALSE;
    
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK  )
    {
        IFC( GetEditor()->GetMasterElement( pIElement, ppIElement ));   
        fAtVL = TRUE;
    }
    else
    {
        *ppIElement = pIElement;
        (*ppIElement)->AddRef();
        
    }
Cleanup:
    if ( pfAtBoundaryOfVL )
        *pfAtBoundaryOfVL = fAtVL;  
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsCaretAlreadyWithinContext
//
// Synopsis: Look and see if the physical Caret is already within the edit context
//           This is a check to see if we previously had the focus - and we can just restore
//           the caret to where we were
//          
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsCaretAlreadyWithinContext(BOOL * pfVisible /* =NULL*/)
{
    HRESULT           hr ;
    SP_IMarkupPointer spPointer;
    SP_IHTMLCaret     spCaret;
    BOOL              fInEdit = FALSE;
    BOOL              fPositioned = FALSE;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));
    
    IFC( GetDisplayServices()->GetCaret( & spCaret ));    
    IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));
    IFC( spPointer->IsPositioned( & fPositioned ));

    if ( fPositioned )
    {    
        IFC( IsInEditContext( spPointer, & fInEdit, TRUE /* fCheckContainer */));
    }

    if ( pfVisible )
    {
        IFC( spCaret->IsVisible( pfVisible ));
    }


Cleanup:
    return  fInEdit ;
}


//+====================================================================================
//
// Method: EnsureAdornment
//
// Synopsis: Ensure that if it's valid for us to have a UI-Active border - that we have one.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureAdornment( BOOL fFireEventLikeIE5 )
{
    //
    // Create a UI-Active adorner, if the TrackerType() is CONTROL, we may
    // have a NO-SCOPE element becoming current.  If we are drilling into a
    // no scope item, then create an adorner for the element
    // 
    if ( ShouldElementShowUIActiveBorder(fFireEventLikeIE5) &&
         _fEditFocusAllowed && 
         !_pAdorner &&
         (GetTrackerType() != TRACKER_TYPE_Control) &&
         !IsDontChangeTrackers() )
    {
        IGNORE_HR( CreateAdorner() );
    }
 
    RRETURN( S_OK );
}

HRESULT
CSelectionManager::EmptySelection(
                        BOOL   fHideCaret /*= FALSE */,
                        BOOL   fChangeTrackerAndSetRange /*=TRUE*/) // If called from the OM Selection, it may want to hide the caret
{
    HRESULT                 hr = S_OK;
    
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    SP_IDisplayPointer      spDispPointer;
    SP_IDisplayPointer      spDispPointer2;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;   
    BOOL                    fEmpty = FALSE;

    if ( _fInFireOnSelect )
    {
        _fFailFireOnSelect = TRUE;
    }
    
    IFC( EnsureEditContext() );    
    IFC( GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );

    //
    // We will always position the Caret on Selection End. The Caret will decide
    // whehter it's visible
    //
    IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
    IFC( GetEditor()->CreateMarkupPointer( &spPointer2 ));

    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer2 ));

    IFC( spSegmentList->IsEmpty( &fEmpty ) )
    if( !fEmpty  )
    {
        IFC( spSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );

        IFC( spSegment->GetPointers( spPointer, spPointer2 ));
        
        IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        
        IFC( spDispPointer2->MoveToMarkupPointer(spPointer2, NULL) );
        IFC( spDispPointer2->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        
        AssertSz( hr == 0 , "Unable to position pointers");
    }

    // Clear the segments
    IFC( _pActiveTracker->EmptySelection(fChangeTrackerAndSetRange) );

    if ( fChangeTrackerAndSetRange )
    {
        //
        // After the delete the BOL'ness maybe invalid. Force a recalc.
        //
        _pActiveTracker->SetRecalculateBOL( TRUE);

        //
        // We want to have currency if this becomes empty. #95487
        //
        SetEnabled(TRUE);

        IFC( SetCurrentTracker( TRACKER_TYPE_Caret, spDispPointer, spDispPointer2 ) );
    }

    if( fHideCaret )
    {
        if ( fChangeTrackerAndSetRange )
        {
            IFC( EnsureDefaultTrackerPassive()); // go to a passive state.           
        }
        else
            CCaretTracker::SetCaretVisible( GetDoc(), FALSE);
    }

Cleanup:

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for WM_TIMER messages. Route these to the tracker (if any).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::OnTimerTick()
{
    HRESULT hr = S_OK;
    Assert( _pActiveTracker );
    hr = _pActiveTracker->OnTimerTick();
    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: DeleteSelection
//
// Synopsis: Do the deletion of the Selection by firing IDM_DELETE
//
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::DeleteSelection(BOOL fAdjustPointersBeforeDeletion )
{
    HRESULT hr = S_OK;

    Assert( _fContextEditable );
    
    if( GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Selection )
    {
        IFC( DYNCAST( CSelectTracker, _pActiveTracker )->DeleteSelection( fAdjustPointersBeforeDeletion ) );
    }
        

Cleanup:
    RRETURN( hr );
}

IHTMLDocument2*
CSelectionManager::GetDoc()
{
    return _pEd->GetDoc();
}

//+====================================================================================
//
// Method: HandleAdornerResize
//
// Synopsis: Check to see if the down-click was inside the UI-Active adorner of the Edit
//           context.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::HandleAdornerResize( 
                        CEditEvent* pEvent  , 
                        SST_RESULT* peResult )
{
    HRESULT    hr = S_OK;    
    SST_RESULT eResult = SST_NO_CHANGE;        
    BOOL       fInResize = FALSE;
    BOOL       fInMove = FALSE;
    DWORD      dwTCFlags = 0;
    
    
    Assert( pEvent && _pAdorner );

    fInResize = _pAdorner->IsInResizeHandle(pEvent);
    if ( ! fInResize )
        fInMove = _pAdorner->IsInMoveArea(pEvent);
    
    if ( fInMove || fInResize )
    {
        TRACKER_TYPE    eType = GetTrackerType();

        DestroyAdorner();

        //
        // We are transitioning from a UI Active tracker, to begin a move/resize
        // If we have a text selection - we whack it - or else we will end up dragging
        // the text (and mess-up access which uses the type of selection)
        // IE 5 Bug 39974
        //
        if ( GetTrackerType() == TRACKER_TYPE_Selection )
            EmptySelection(FALSE/*fHideCaret*/,FALSE/*fChangeTrackerAndSetRange*/);
        //
        // we are transitioning from a UI Active tracker
        // to a SiteSelected tracker, and will allow dragging/resizing.
        // We need to force a currency change here ( important for OLE Controls )
        // BUT We don't want to whack any trackers on the set edit context
        //
        SP_IHTMLElement spElement = GetEditableElement();
        
        SetDontChangeTrackers( TRUE );
        IGNORE_HR( GetEditor()->MakeParentCurrent( spElement ));
        SetDontChangeTrackers( FALSE );

        if ( !fInMove  )
        {
            //
            // More specialness for going from UI-Active to a live resizing site selection
            // we need to listed for the AdornerPositioned Notification from the tracker
            // to then tell the tracker to to go "live"
            //
            _fPendingAdornerPosition = TRUE;
            _lastEvent = new CHTMLEditEvent( DYNCAST( CHTMLEditEvent, pEvent ));
            if (_lastEvent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        if (fInMove)
        {
            dwTCFlags |= TRACKER_CREATE_ACTIVEONMOVE;
        }

        dwTCFlags |= TRACKER_CREATE_GOACTIVE;

        hr =  SetCurrentTracker( TRACKER_TYPE_Control ,
                                 pEvent,
                                 dwTCFlags,
                                 CARET_MOVE_NONE,
                                 FALSE,
                                 spElement  );

        //  Make sure we are still in a control tracker
        if (!hr && !fInMove && GetTrackerType() == TRACKER_TYPE_Control)
            AdornerPositionSet(); // marka says this will just do the magic

        //  Did the tracker change?
        if (eType != GetTrackerType())
            eResult = SST_TRACKER_CHANGED;            
    }
 
    *peResult = eResult;

Cleanup:
    RRETURN ( hr );
}


HRESULT
CSelectionManager::ShouldHandleEventInPre( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE ;
    ELEMENT_TAG_ID      eTag;
    SP_IHTMLElement     spElement ;
    SST_RESULT          eResult      = SST_NO_CHANGE;

    switch( pEvent->GetType() )
    {
        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
        case EVT_MMOUSEDOWN:
        {
            IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));

            IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));

            if (eResult == SST_NO_CHANGE && CheckAtomic(spElement) == S_OK)
            {
                IFC(_pSelectTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
            }

            hr = ( ( eResult == SST_CHANGE ) || 
                   ( eResult == SST_NO_BUBBLE && GetTrackerType() == TRACKER_TYPE_Control ) )
                     ? S_OK 
                     : S_FALSE;
        }
        break;

        //
        // This message is generated when Trident receives a WM_LBUTTONDBLCLK message.
        // We need to always handle this event in the PRE, because CDoc::PumpMessage
        // will sometimes cause the LBUTTONDBLCLK message to get swallowed after 
        // giving it to the editor in the PRE, so we don't get the EVT_INTDBLCLK in the
        // post handle message
        //
        case EVT_INTDBLCLK:
            hr = S_OK;
            break;
            
        
    }
    
Cleanup:
    RRETURN1( hr, S_FALSE );
    
}

//+====================================================================================
//
// Method:
//
// Synopsis: An Event has occurred, which may require changing of the current tracker,
//           poll all your trackers, and see if any require a change.
//
//           If any trackers require changing, end them, and start the new tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ShouldChangeTracker(
                        CEditEvent *pEvent  ,
                        BOOL       *pfStarted)
{
    ELEMENT_TAG_ID      eTag;
    HRESULT             hr           = S_OK;
    SP_IHTMLElement     spElement ;
    SST_RESULT          eResult      = SST_NO_CHANGE;
    TRACKER_TYPE        eTrackerType = TRACKER_TYPE_None;
    
    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));

    if ( pEvent && _pAdorner )
    {
        IFC( HandleAdornerResize( pEvent, & eResult )) ;
        if ( eResult == SST_TRACKER_CHANGED )
        {
            goto Cleanup;
        }
    }

    IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
    if ( eResult == SST_CHANGE )
    {
        eTrackerType = TRACKER_TYPE_Control;
    }
    else if ( eResult != SST_NO_BUBBLE )
    {
        IFC( _pSelectTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
        if ( eResult == SST_CHANGE )
        {
           eTrackerType = TRACKER_TYPE_Selection;
        }
        else if ( eResult != SST_NO_BUBBLE )        
        {
           IFC( _pCaretTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
           if ( eResult == SST_CHANGE )
           {
                eTrackerType = TRACKER_TYPE_Caret;    
           }
        }
    }    
    
    if ( eResult == SST_CHANGE )
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.BeginSelectionChange();

        hr = THR( SetCurrentTracker( eTrackerType, pEvent, 0));
         // fire the selectionchange event
        selCounter.EndSelectionChange();         
    }

Cleanup:
    if ( eResult == SST_CHANGE || eResult == SST_TRACKER_CHANGED )
        *pfStarted = TRUE ;
    else
        *pfStarted = FALSE;
        
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: ChangeTracker
//
// Synopsis: Change what my Tracker is
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ChangeTracker( TRACKER_TYPE eType, CEditEvent* pEvent)
{
    HRESULT hr = S_OK;

    //
    // Did we just destroy a text selection?
    //
    _fDestroyedTextSelection = ( _pActiveTracker                                            && 
                                _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection &&
                                 _pSelectTracker->GetMadeSelection() );
                                 
    if ( _pActiveTracker ) // possible to be null on startup.
    {
        IFC( HibernateTracker( pEvent, eType ));
    }        
    
    switch ( eType )
    {
        case TRACKER_TYPE_Caret:
            _pActiveTracker = _pCaretTracker;            
            break;

        case TRACKER_TYPE_Selection:
            _pActiveTracker = _pSelectTracker;
            break;

        case TRACKER_TYPE_Control:
            _pActiveTracker = _pControlTracker;
            break;
    }
    IFC( _pActiveTracker->Awaken() );

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: SetCurrent Tracker.
//
// Synopsis: Set what the current tracker is from MarkupPointers
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::SetCurrentTracker(
                        TRACKER_TYPE        eType ,
                        IDisplayPointer*    pDispStart,
                        IDisplayPointer*    pDispEnd,
                        DWORD               dwTCFlagsIn,
                        CARET_MOVE_UNIT     inLastCaretMove,
                        BOOL                fSetTCFromActiveTracker /*= TRUE*/)
{
    HRESULT  hr = S_OK;
    DWORD    dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType );
    
    hr = _pActiveTracker->Init2( pDispStart, pDispEnd, dwTCFlags, inLastCaretMove );

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     SetCurrentTracker
//
//  Synopsis:   ISegmentList based way of starting a tracker.
//
//----------------------------------------------------------------------------

HRESULT 
CSelectionManager::SetCurrentTracker(                     
                        TRACKER_TYPE    eType , 
                        ISegmentList*   pSegmentList,
                        DWORD           dwTCFlagsIn /*=0*/,
                        CARET_MOVE_UNIT inLastCaretMove /*=CARET_MOVE_NONE*/, 
                        BOOL            fSetTCFromActiveTracker /*=FALSE*/ )
{
    HRESULT  hr  = S_OK;
    DWORD    dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType );
    
    hr = _pActiveTracker->Init2( pSegmentList, dwTCFlags, inLastCaretMove );

    RRETURN ( hr );
 }
            
//+====================================================================================
//
// Method: SetCurrent Tracker.
//
// Synopsis: Set what the current tracker is from a SelectionMessage
//
//------------------------------------------------------------------------------------


HRESULT
CSelectionManager::SetCurrentTracker(
                            TRACKER_TYPE    eType ,
                            CEditEvent*     pEvent,
                            DWORD           dwTCFlagsIn,
                            CARET_MOVE_UNIT inLastCaretMove,
                            BOOL            fSetTCFromActiveTracker /*= TRUE*/,
                            IHTMLElement    *pIElement /*=NULL*/)
{
    HRESULT         hr        = S_OK;
    DWORD           dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType, pEvent );
    
    hr = _pActiveTracker->Init2( pEvent , dwTCFlags, pIElement );

    RRETURN ( hr );
}

HRESULT
CSelectionManager::CreateFakeSelection(IHTMLElement* pIElement, IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr;

    Assert( ! _pIRenderSegment );
    
    IFC( GetEditor()->GetHighlightServices()->AddSegment( 
                                                                pDispStart, 
                                                                pDispEnd, 
                                                                GetSelRenderStyle(), 
                                                                &_pIRenderSegment ));
    IFC( AttachDragListener( pIElement ));

Cleanup:    

    RRETURN( hr );    
}

HRESULT
CSelectionManager::DestroyFakeSelection()
{
    HRESULT hr = S_OK;
   
    if ( _pIRenderSegment )
    {
        IFC( GetEditor()->GetHighlightServices()->RemoveSegment( _pIRenderSegment ) );
        ClearInterface( &_pIRenderSegment );
        IFC( DetachDragListener());
    }

Cleanup:

    RRETURN( hr );    
}

HRESULT 
CDragListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                _pMan->DestroyFakeSelection();
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CDropListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CVariant cvarRet;
                
                IFC( spObj->get_returnValue( & cvarRet ));
                
                if ( ( V_VT( & cvarRet ) == VT_BOOL )  &&
                     ( V_BOOL( & cvarRet ) == VARIANT_FALSE ) )
                {
                    _pMan->OnDropFail();
                }
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: EnsureDefaultTracker
//
// Synopsis: Make sure we always have a current tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureDefaultTracker(BOOL fFireOnChangeSelect /*=TRUE*/ )
{
    HRESULT hr = S_OK;
    CEditTracker* pTrack = _pActiveTracker;
    
    IFC( ChangeTracker( TRACKER_TYPE_Caret ));
    IFC( _pActiveTracker->Init2());

    // fire the type change event
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.SelectionChanged( fFireOnChangeSelect && pTrack != NULL );
    }
    
Cleanup:
    RRETURN ( hr );    
}

BOOL
CSelectionManager::IsDefaultTracker()
{
    return ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret );
}

BOOL
CSelectionManager::IsDefaultTrackerPassive()
{
    return ( ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret ) &&
               _pActiveTracker->IsPassive() );
}

//+====================================================================================
//
// Method: EnsureDefaultTrackerPassive
//
// Synopsis: Return to the "default tracker" and make it's state passive
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureDefaultTrackerPassive(
                                                CEditEvent* pEvent /* = NULL */, 
                                                BOOL fFireOnChangeSelect /*=TRUE*/)                                                
{
    HRESULT hr = S_OK;
    
    if ( !IsDefaultTracker() || !_pActiveTracker->IsPassive() )
    {
        IFC( HibernateTracker( pEvent, TRACKER_TYPE_Caret, TRUE ));
        IFC( EnsureDefaultTracker( fFireOnChangeSelect ));
    }
    
Cleanup:
    RRETURN( hr );
}    

//+====================================================================================
//
// Method: StartSelectionFromShift
//
// Synopsis:
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::StartSelectionFromShift(
                            CEditEvent* pEvent )
{
    HRESULT hr = S_OK;

    IDisplayPointer* pDispStartCaret = NULL ;
    IDisplayPointer* pDispEndCaret = NULL   ;
    LONG  eLineDir = LINE_DIRECTION_LeftToRight;
    SP_IHTMLCaret      spCaret;
    DWORD dwCode = TRACKER_CREATE_STARTFROMSHIFTKEY;
    CARET_MOVE_UNIT eCaretMove = CARET_MOVE_NONE;
    POINT   ptGlobal;
    BOOL    fVertical = FALSE;
    SP_ILineInfo spLineInfo;
    SP_IMarkupPointer   spMarkup;
    SP_IHTMLElement     spElement;
    CSelectionChangeCounter selCounter(this);

    Assert( GetTrackerType() == TRACKER_TYPE_Caret );
    CCaretTracker* pCaretTracker = DYNCAST( CCaretTracker, _pActiveTracker );

    IFC( GetDisplayServices()->CreateDisplayPointer( & pDispStartCaret ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & pDispEndCaret ));

    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispStartCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispEndCaret ));
    IFC( spCaret->GetLocation( &ptGlobal , TRUE /* fTranslate to global */));
    IFC( pDispStartCaret->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_lineDirection(&eLineDir));

    IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
    IFC( pDispEndCaret->PositionMarkupPointer(spMarkup) );
    IFC( spMarkup->CurrentScope(&spElement) );
    IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );

    eCaretMove = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);

    if ( FAILED( pCaretTracker->MovePointer( eCaretMove, pDispEndCaret, &ptGlobal, NULL )))
    {
        if ( pCaretTracker->GetPointerDirection(eCaretMove) == RIGHT)
        {
            IGNORE_HR(  pCaretTracker->MovePointer( CARET_MOVE_LINEEND, pDispEndCaret, &ptGlobal, NULL ));
        }
        else
        {
            IGNORE_HR(  pCaretTracker->MovePointer( CARET_MOVE_LINESTART, pDispEndCaret, &ptGlobal, NULL ));     
        }    
    }

    IGNORE_HR( pDispEndCaret->ScrollIntoView() );   // DO NOT CHANGE THIS TO AN IFC. It can return S_FALSE - saying we didn't handle the event.
                                                    // if you change this to an IFC - YOU WILL BREAK THE DRT ( try merge.js in edit2.js)

    selCounter.BeginSelectionChange();
    
    SetCurrentTracker(  TRACKER_TYPE_Selection,
                        pDispStartCaret,
                        pDispEndCaret, 
                        dwCode, 
                        eCaretMove,
                        FALSE );

    // fire the selectionchange event
    selCounter.EndSelectionChange() ;

Cleanup:
    ReleaseInterface( pDispStartCaret);
    ReleaseInterface( pDispEndCaret);
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: Hibernate Tracker
//
// Synopsis: Make the current tracker become dormant.
//
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::HibernateTracker(CEditEvent      *pEvent,
                                    TRACKER_TYPE    eType,
                                    BOOL            fTearDownUI /* = TRUE*/ )
{
    HRESULT hr = S_OK;
    
    Assert( _pActiveTracker );
    
    CEditTracker * pTracker = _pActiveTracker;
    pTracker->BecomeDormant( pEvent, eType, fTearDownUI );
    

    //
    // After we kill ANY tracker, we better not have capture or a timer.
    //
    Assert( !_fInTimer );
    Assert( !_fInCapture );

    RRETURN( hr );
}

SELECTION_TYPE
CSelectionManager::ConvertTrackerType(TRACKER_TYPE eType)
{
    SELECTION_TYPE selType = SELECTION_TYPE_None;
    switch (eType)
    {
        case TRACKER_TYPE_Caret :
            selType =  SELECTION_TYPE_Caret;
            break;

        case TRACKER_TYPE_Selection :
            selType =  SELECTION_TYPE_Text;
            break;

        case TRACKER_TYPE_Control :
            selType =  SELECTION_TYPE_Control;
            break;
    }
    return selType;
}

TRACKER_TYPE
CSelectionManager::ConvertSelectionType(SELECTION_TYPE eType)
{
    TRACKER_TYPE trType = TRACKER_TYPE_None;
    switch (eType)
    {
        case SELECTION_TYPE_Caret :
            trType =  TRACKER_TYPE_Caret;
            break;

        case SELECTION_TYPE_Text :
            trType =  TRACKER_TYPE_Selection;
            break;

        case SELECTION_TYPE_Control :
            trType =  TRACKER_TYPE_Control;
            break;
    }
    return trType;
}

SELECTION_TYPE
CSelectionManager::GetSelectionType()
{
    if ( _pActiveTracker )
        return ConvertTrackerType(_pActiveTracker->GetTrackerType());
    else
        return SELECTION_TYPE_None;
}

HRESULT
CSelectionManager::GetSelectionType ( 
                              SELECTION_TYPE * peSelectionType )
{
    HRESULT hr = S_OK;

    Assert( peSelectionType );

    if ( peSelectionType )
    {
        *peSelectionType = GetSelectionType();
    }
    else
        hr = E_INVALIDARG;

    RRETURN ( hr );
}

TRACKER_TYPE
CSelectionManager::GetTrackerType()
{
    if ( _pActiveTracker )
        return _pActiveTracker->GetTrackerType();
    else
        return TRACKER_TYPE_None;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::NotifyBeginSelection
//
//  Synopsis:   Posts a WM_BEGINSELECTION message to every Trident HWND.  This allows
//              other trident instances to determine when a selection has been started
//              in a seperate trident instance.
//
//  Arguments:  wParam = Additional data to post with WM_BEGINSELECTION
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::NotifyBeginSelection(WPARAM wParam)
{
    HRESULT hr = S_OK;
    HWND    hwndCur;                        // Current HWND for trident
    HWND    hwndParent;                     // Parent window walk
    HWND    hwndTopTrident = NULL;          // Top HWND of trident

    IFC( GetEditor()->GetHwnd( &hwndCur ) );
    
    SetNotifyBeginSelection(TRUE);

    //
    // Find the topmost Instance of Trident
    //
    while(hwndCur)
    {
        if ( EdUtil::IsTridentHwnd( hwndCur ))
        {
            hwndTopTrident = hwndCur;
        }    
        hwndParent = hwndCur;
        hwndCur = GetParent(hwndCur);        
    }

    if( hwndTopTrident )
    {
        ::SendMessage( hwndTopTrident,
                       WM_BEGINSELECTION, 
                       wParam ,
                       0);
    }

    SetNotifyBeginSelection(FALSE);
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Notify
//
// Synopsis: This is the 'external' notify - used by Trident to tell the selection manager
//           that 'something' has happened that it should do soemthing about.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::Notify(
        EDITOR_NOTIFICATION eSelectionNotification,
        IUnknown* pUnknown,
        DWORD dword )
{
    HRESULT hr = S_OK;

    if (eSelectionNotification != EDITOR_NOTIFY_DOC_ENDED &&
        eSelectionNotification != EDITOR_NOTIFY_YIELD_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_BEFORE_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_EXIT_TREE &&
        eSelectionNotification != EDITOR_NOTIFY_LOSE_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_ATTACH_WIN
        )
        IFC( EnsureEditContext() );
    
    switch( eSelectionNotification )
    {
        case EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE:
            {
                //
                // disallow currency changes on unselectable.
                //
                SP_IHTMLElement spElement;
                IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
                if ( CheckUnselectable( spElement) == S_OK )
                {
                    hr = S_FALSE;
                }
            }
            break;
            
        case EDITOR_NOTIFY_BEGIN_SELECTION_UNDO:
        case EDITOR_NOTIFY_UPDATE_CARET:
            hr = THR( DoPendingTasks() );
            break;

        case EDITOR_NOTIFY_EDITABLE_CHANGE :
            {
                SP_IHTMLElement spElement;
                ELEMENT_TAG_ID  eTag;
                IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
                IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));

                Assert( eTag != TAGID_ROOT );
                if( eTag != TAGID_ROOT )
                {               
                    hr = EditableChange( pUnknown);
                }
            }
            break;
            
        case EDITOR_NOTIFY_YIELD_FOCUS:
                IFC( YieldFocus( pUnknown) );
            break;
            
        case EDITOR_NOTIFY_CARET_IN_CONTEXT:
            hr = CaretInContext();
            break;

        case EDITOR_NOTIFY_TIMER_TICK:
            hr = OnTimerTick(  );
            break;

        case EDITOR_NOTIFY_EXIT_TREE:
        case EDITOR_NOTIFY_SETTING_VIEW_LINK:
            {
                //
                // An element left the tree.  This potentially caused a change in our cached
                // values for our display pointers, so increment the counter so that
                // the events 
                GetEditor()->IncEventCacheCounter();
                hr = ExitTree( pUnknown );
            }

            // We are setting the viewlink here.  We need to destroy our selection because
            // we may crash when trying to destroy the selection after the viewlink is set
            // if the viewlink removes the selection context.  Pending tasks will clean up.
            if (hr == S_OK && eSelectionNotification == EDITOR_NOTIFY_SETTING_VIEW_LINK)
            {
                if (GetTrackerType() == TRACKER_TYPE_Selection)
                {
                    DYNCAST( CSelectTracker, _pActiveTracker )->EmptySelection();
                }
            }
            break;

        case EDITOR_NOTIFY_BEFORE_FOCUS:
            {
                SP_IHTMLEventObj spEventObj;
                SP_IHTMLElement spElement;
                ELEMENT_TAG_ID  eTag;
                
                IFC( pUnknown->QueryInterface( IID_IHTMLEventObj, (void**) & spEventObj));
                IFC( spEventObj->get_toElement( & spElement ));                
                IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));

                Assert( eTag != TAGID_ROOT );
                if( eTag != TAGID_ROOT )
                {               
                    IFC( SetEditContextFromCurrencyChange( spElement, dword , spEventObj ));
                }
            }
            break;

        case EDITOR_NOTIFY_DOC_ENDED:

            
            if ( ! IsInFireOnSelectStart() )
            {
                IFC( EnsureDefaultTrackerPassive( NULL,  FALSE ));
            }                    
            else
            {
                //
                // We're unloading during firing of OnSelectStart
                // We want to not kill the tracker now - but fail the OnSelectStart
                // resulting in the Tracker dieing gracefully.
                //
                SetFailFireOnSelectStart( TRUE );
            }
            
            if ( eSelectionNotification == EDITOR_NOTIFY_DOC_ENDED )
            {
                SetDrillIn( FALSE );
            }

            //
            // Sometimes we navigate away to a different URL
            // without losing focus. So we double-check to 
            // terminate IME composition. 
            //
            if (IsIMEComposition())
            {
                IGNORE_HR(TerminateIMEComposition(TERMINATE_FORCECANCEL));
            }
            break;
            
        case EDITOR_NOTIFY_LOSE_FOCUS_FRAME: 
            //
            // Selection is being made in another frame/instance of trident
            // we just kill ourselves.
            //
            if( ! _fNotifyBeginSelection && !GetEditor()->GetActiveCommandTarget()->IsKeepSelection())
            {
                hr = LoseFocusFrame( dword );
            }
            
            break;

        case EDITOR_NOTIFY_LOSE_FOCUS:
            _fLastMessageValid = FALSE;
            hr = LoseFocus();
            break;

        case EDITOR_NOTIFY_ATTACH_WIN:
            {
                Assert ( GetEditor() ); // This is true for now since we fire this notification only after Editor is created!
                hr = GetEditor()->SetupActiveIMM(pUnknown);
            }
            break;
    }

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CSelectionManager::YieldFocus( IUnknown* pUnkElemNext )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    SP_IObjectIdentity spIdent;

    if( pUnkElemNext )
    {
        IFC( pUnkElemNext->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
        IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

        if ( spIdent->IsEqualObject( GetEditableElement() ) == S_FALSE &&
             IsElementContentSameAsContext( spElement) != S_OK )
        {
            //
            // an element other than the edit context is becoming current.
            // we whack the caret if there is one.
            // at some point we may want to hide selection
            //
            if ( GetTrackerType() == TRACKER_TYPE_Caret && 
                 CheckUnselectable(spElement) == S_FALSE )
            {
                EnsureDefaultTrackerPassive();
            }
            SetEnabled( FALSE );
        }
    }
    else
    {
        //
        // ROOT element become active... make sure default tracker is passive
        //
        EnsureDefaultTrackerPassive();
        SetEnabled(FALSE);
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EditableChange( IUnknown* pUnkElemNext )
{
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IObjectIdentity spIdent;
    SP_IMarkupPointer spStart, spEnd ;

    IFC( pUnkElemNext->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
    IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

    IFC( GetEditor()->CreateMarkupPointer( & spStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ));
    
    if ( spIdent->IsEqualObject( GetEditableElement() ) == S_OK ||
         IsElementContentSameAsContext( spElement) == S_OK ||    

        //
        // this is for "reductions" in edit context - ie. a sub-region of the edit context
        // became editable
        //
        
         ( IsInEditContext( spStart ) &&          
           IsInEditContext( spEnd ) &&
           IsEditable( spElement) == S_OK  ) ) 
    {
        IFC( SetEditContextFromElement( spElement ));
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: LoseFocusFrame
//
// Synopsis: Do some work to end the current tracker, and to create/destroy adorners
//           for Iframes
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::LoseFocusFrame( DWORD selType )
{
    HRESULT hr = S_OK;
    
    IFC( EnsureDefaultTrackerPassive());
    
    if ( selType == START_TEXT_SELECTION )
    {
        //
        // I'm in a UIActive control - that doesn't have an adorner
        // Special case Adorner Creation for Iframes. Why ? because the above would
        // have destroyed it
        //
        // Only if this is an Iframe - can we guess that it's ok to create the adorner.
        // otherwise the adorner should be already created around the element that's we're making
        // the selection in.
        // Why all this bizarreitude ? Because IFrames are in one document - and their inner 
        // document is in another
        // 
        if ( !_pAdorner && 
             ShouldElementShowUIActiveBorder()  && 
             GetEditableTagId() == TAGID_IFRAME  )
        {
            hr = THR( CreateAdorner() ) ;
            _pAdorner->InvalidateAdorner() ;
        }
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: ExitTree
//
// Synopsis: Check to see if the element leaving the tree intersects the current selserv.
//           if it does - we tell the SelectionServicesListener.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ExitTree( IUnknown* pUnknown)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    SP_ISegmentList spSegmentList;

    
    IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) &spElement ));
    IFC( GetEditor()->GetISelectionServices()->QueryInterface( IID_ISegmentList, (void**) & spSegmentList ));

    if( _pIElementExitStart ||
        EdUtil::SegmentIntersectsElement(GetEditor(), spSegmentList, spElement) == S_OK )
    {    
        if ( ! _pIElementExitStart )
        {        
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitStart ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitEnd ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitContentStart ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitContentEnd ) );

            IFC( _pIElementExitStart->SetGravity(POINTER_GRAVITY_Left));
            IFC( _pIElementExitEnd->SetGravity(POINTER_GRAVITY_Right));
            IFC( _pIElementExitContentStart->SetGravity(POINTER_GRAVITY_Left));
            IFC( _pIElementExitContentEnd->SetGravity(POINTER_GRAVITY_Right));
            
            IFC( _pIElementExitStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin));
            IFC( _pIElementExitEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd));  

            SP_IMarkupPointer2 spStartContent;
            SP_IMarkupPointer2 spEndContent;

            IFC( _pIElementExitContentStart->QueryInterface( IID_IMarkupPointer2, ( void**) & spStartContent ));
            IFC( _pIElementExitContentEnd->QueryInterface( IID_IMarkupPointer2, ( void**) & spEndContent ));

            IGNORE_HR( spStartContent->MoveToContent( spElement , TRUE));
            IGNORE_HR( spEndContent->MoveToContent( spElement, FALSE ));

            IFC( StartExitTreeTimer());
        }
        else
        {
            // 
            // we have gotten several exit trees, that intersect selection
            // we conglomerate them - and get the "biggest" range
            //
            Assert( _fInExitTimer );
            SP_IMarkupPointer spStart;
            SP_IMarkupPointer spEnd;
            BOOL fRightOf, fLeftOf;
            
            IFC( GetEditor()->CreateMarkupPointer( & spStart ));
            IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

            IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin));
            IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd));  

            IFC( spStart->IsLeftOf( _pIElementExitStart , & fLeftOf ));
            if ( fLeftOf )
            {
                IFC( _pIElementExitStart->MoveToPointer( spStart ));
            }

            IFC( spEnd->IsRightOf( _pIElementExitEnd , & fRightOf ));
            if ( fRightOf )
            {
                IFC( _pIElementExitEnd->MoveToPointer( spEnd ));
            }

        }

    }
    
Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectionManager::DoPendingElementExit()
{
    HRESULT hr = S_OK ;
    Assert( _pIElementExitStart || _fInPendingElementExit );
    SP_ISelectionServicesListener spListener;
    BOOL fPosStart, fPosEnd;
    BOOL fPosElemStart, fPosElemEnd;
    BOOL fPosElemCtxStart, fPosElemCtxEnd;
    
    if ( _fInPendingElementExit )
        return S_OK;
        
    _fInPendingElementExit = TRUE;
    if ( GetEditor()->GetISelectionServices()->GetSelectionServicesListener( & spListener ) == S_OK )
    {
        IFC( spListener->OnSelectedElementExit(  _pIElementExitStart, _pIElementExitEnd, _pIElementExitContentStart, _pIElementExitContentEnd ));
    }

    //
    // If we are UI-active, and the element leaving contained us - destroy the UI-active.
    //
    IFC( _pStartContext->IsPositioned( & fPosStart ));
    IFC( _pEndContext->IsPositioned( & fPosEnd ));
    IFC( _pIElementExitStart->IsPositioned( & fPosElemStart ));
    IFC( _pIElementExitEnd->IsPositioned( & fPosElemEnd ));
    IFC( _pIElementExitContentStart->IsPositioned( & fPosElemCtxStart ));
    IFC( _pIElementExitContentStart->IsPositioned( & fPosElemCtxEnd ));
    
    if ( fPosStart && fPosEnd &&
         ( ( fPosElemStart && fPosElemEnd && 
           Between( _pStartContext, _pIElementExitStart, _pIElementExitEnd ) &&
           Between( _pEndContext, _pIElementExitStart, _pIElementExitEnd ) ) ||
         ( fPosElemCtxStart && fPosElemCtxEnd &&
           Between( _pStartContext, _pIElementExitContentStart, _pIElementExitContentEnd ) &&
           Between( _pEndContext, _pIElementExitContentStart, _pIElementExitContentEnd ) ) ) )
    {
        if ( _pAdorner )
            DestroyAdorner();

        //
        // While this call to ClearInterface seems redundant, given that EnsureEditContext() will clear it 
        // and initialize it... we clear the editable element here so that WE FORCE a context change when
        // we attempt to set the edit context.
        //
        ClearInterface( & _pIEditableElement );
        EnsureDefaultTrackerPassive();
        EnsureEditContext( _pIElementExitStart );
    }
    
    
    ClearInterface( & _pIElementExitStart );
    ClearInterface( & _pIElementExitEnd );
    ClearInterface( & _pIElementExitContentStart );
    ClearInterface( & _pIElementExitContentEnd );
 
    Assert( ! IsInCapture());
    Assert( ! IsInTimer() );

    if ( _fInExitTimer )
    {
        IFC( StopExitTreeTimer());
    }
Cleanup:
    _fInPendingElementExit = FALSE;

    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::LoseFocus()
{
    HRESULT        hr = S_OK;
    SP_IHTMLCaret  spCaret = 0;

    IFC( GetDisplayServices()->GetCaret( & spCaret ));

    TerminateIMEComposition(TERMINATE_NORMAL);
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: CaretInContext
//
// Synopsis: Position a Caret at the start of the edit context. Used to do somehting
//           meaningful on junk, eg. calling select() on a control range that is empty
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::CaretInContext(  )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(_pStartContext, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    hr = THR ( SetCurrentTracker(
                        TRACKER_TYPE_Caret, 
                        spDispPointer, 
                        spDispPointer ) );
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::DestroySelection( )
{
    HRESULT hr = S_OK;
    if( ! IsDontChangeTrackers() )
    {
        // 
        // Destroy any and all selections, by causing the
        // caret tracker to become active
        //
        IFC( EnsureDefaultTrackerPassive() );
        DestroyAdorner();
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method:ShouldElementBeAdorned
//
// Synopsis: Is it valid to show a UI Active border around this element ? 
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::IsElementUIActivatable()
{
    if ( _fParentEditable )
    {
        return IsElementUIActivatable( GetEditableElement());
    }
    else
        return FALSE;        
}

//+====================================================================================
//
// Method:IsElementUIActivatable
//
// Synopsis: Is it valid to show a UI Active border around this element ? 
//
//------------------------------------------------------------------------------------

//**************************************************
//
// This function is called by trident during design time - to see if an element can be made current.
//
// Look out for making this too heavy. Also changes can make different elements become editable
//
//**************************************************

BOOL 
CSelectionManager::IsElementUIActivatable(IHTMLElement* pIElement)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spMaster;
    BOOL fShouldBeActive = FALSE;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    if (!pIElement)
          goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
 
    //
    // Are we inside a viewlink'ed master, and putting inside the master gets us to the edit ctxt ?
    //
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK )
    {
        fShouldBeActive = TRUE;
        goto Cleanup;
    }


    switch( eTag )
    {
        case TAGID_INPUT:
        case TAGID_BUTTON:
//      case TAGID_HTMLAREA:
        case TAGID_TEXTAREA:
        case TAGID_DIV:
        case TAGID_SPAN:   // Divs and Spans - because if these have the Edit COntext - they must be current.
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_IFRAME:
        case TAGID_SELECT:
            fShouldBeActive = TRUE;
            break;

        case TAGID_BODY:                
        case TAGID_TABLE:
            goto Cleanup; // skip the positioning checks here for these common cases

        case TAGID_OBJECT:
        {
            fShouldBeActive = ShouldObjectHaveBorder(pIElement);
        }
        break;
    }
    
    if ( ! fShouldBeActive )
    {
        fShouldBeActive = (IsLayout( pIElement ) == S_OK);
    }

Cleanup:
    return fShouldBeActive;
}

EXTERN_C const CLSID CLSID_AppletOCX = { 0x08B0e5c0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01 };
EXTERN_C const IID IID_IActiveDesigner;

//+====================================================================================
//
// Method:ShouldObjectHaveBorder
//
// Synopsis: Should there be a border around the object element
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::ShouldObjectHaveBorder(IHTMLElement* pIElement)
{
    HRESULT             hr = S_OK;
    SP_IPersist         spPersist;
    BOOL                fBorder = FALSE;
    BOOL                fJavaApplet = FALSE;
    BOOL                fHasClassid = FALSE;
    CLSID               classid;

    Assert(pIElement);

    hr = THR_NOTRACE(pIElement->QueryInterface(IID_IPersist, (void **)&spPersist));
    if (hr == S_OK)
    {
        fHasClassid = TRUE;
        IGNORE_HR(spPersist->GetClassID(&classid));
        if (IsEqualGUID((REFGUID)classid, (REFGUID)CLSID_AppletOCX))
            fJavaApplet = TRUE;
    }

    if (!fJavaApplet)
    {
        SP_IOleControl      spCtrl;
        SP_IQuickActivate   spQA;

        hr = THR_NOTRACE(pIElement->QueryInterface(IID_IQuickActivate, (LPVOID*)&spQA));
        if (hr)  // not a quick activate control
        {
            hr = THR_NOTRACE(pIElement->QueryInterface(IID_IOleControl, (LPVOID*)&spCtrl));
            if (hr == S_OK) // is ole control
                fBorder = TRUE;
        }
    }

    if (GetCommandTarget()->IsNoActivateNormalOleControls() ||
        GetCommandTarget()->IsNoActivateDesignTimeControls() ||
        GetCommandTarget()->IsNoActivateJavaApplets() )
    {
        SP_IUnknown     spAD;
        BOOL            fDesignTimeControl = FALSE;

        if (S_OK == (pIElement->QueryInterface(IID_IActiveDesigner, (LPVOID*)&spAD)))
            fDesignTimeControl = TRUE;

        fBorder = ( (GetCommandTarget()->IsNoActivateNormalOleControls()  && fDesignTimeControl) ||
                    (GetCommandTarget()->IsNoActivateDesignTimeControls() && fJavaApplet) ||
                    (GetCommandTarget()->IsNoActivateJavaApplets() && !fDesignTimeControl && !fJavaApplet) ) ;
    }

    //
    // If NoUIActivateInDesign is set, then override this if they support 
    // CATID_DesignTimeUIActivatableControl. Note that anything with an appropriate
    // CATID will be UI active even if the HOST tells us not to do so.
    //

    if (fBorder)
    {
        //
        // Get the category manager
        //
        SP_ICatInformation spCatInfo;
        
        hr = THR(CoCreateInstance(
                        CLSID_StdComponentCategoriesMgr, 
                        NULL, 
                        CLSCTX_INPROC_SERVER, 
                        IID_ICatInformation, 
                        (void **) &spCatInfo));

        if (hr) // couldn't get the category manager--
            goto Cleanup;

        Assert(spCatInfo.p);
        
        //
        // Check if control supports CATID_DesignTimeUIActivatableControl
        //
        CATID rgcatid[1];
        rgcatid[0] = CATID_DesignTimeUIActivatableControl;

        if (fHasClassid)
        {
            fBorder = (spCatInfo->IsClassOfCategories(classid, 1, rgcatid, 0, NULL) != S_OK);        
        }
        else
        {
            fBorder = TRUE;
        }
    }    

Cleanup:    
    return fBorder;
}

//+====================================================================================
//
// Method:ShouldElementShowUIActiveBorder
//
// Synopsis: Should there be a UI-Active border around the current element that has focus
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::ShouldElementShowUIActiveBorder( BOOL fFireEventLike5 )
{
#ifdef FORMSMODE
    if (IsInFormsSelectionMode(GetEditableElement()))
         return FALSE;
    else
    {
#endif
        BOOL fOkEditFocus = TRUE;
        
        BOOL fActivatable = IsElementUIActivatable( );

        if ( fFireEventLike5 )
        {
            fOkEditFocus = FireOnBeforeEditFocus();
        }
        
        return fActivatable && fOkEditFocus ; 
        
#ifdef FORMSMODE
    }
#endif
}

//+====================================================================================
//
// Method:CreateAdorner
//
// Synopsis: Create a UI Active Adorner for this type of tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::CreateAdorner()
{
    HRESULT         hr = S_OK;
    BOOL            fLocked = FALSE ;
    BOOL fAdornMaster = FALSE; 
    Assert( ! _pAdorner );
    SP_IHTMLElement spAdornerElement;
    AssertSz( _fEditFocusAllowed , " UI Activation of Control not allowed" );
    ELEMENT_TAG_ID eTag;
    BOOL fAtBoundary;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;
    

    IFC( GetElementToAdorn( GetEditableElement(), & spAdornerElement, & fAtBoundary));
    IFC( GetMarkupServices()->GetElementTagId( spAdornerElement, & eTag ));
    
    fAdornMaster= fAtBoundary || eTag == TAGID_IFRAME ; 

    IFC( GetEditableElement()->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
        
    IFC( GetEditor()->IsElementLocked( spAdornerElement, & fLocked ));
    if ( ! fAdornMaster )
    {
        _pAdorner = new CActiveControlAdorner( spAdornerElement , spElemDoc , fLocked );
    }
    else
    {
        _pAdorner = new CSelectedControlAdorner( spAdornerElement , spElemDoc , fLocked );
    }
    
    if ( ! _pAdorner )
        goto Error;

    _pAdorner->SetManager( this );
    _pAdorner->AddRef();

    hr = _pAdorner->CreateAdorner() ;

Cleanup:
    
    RRETURN ( hr );

Error:
    return E_OUTOFMEMORY;
}


//+====================================================================================
//
// Method:DestroyAdorner
//
// Synopsis: Destroy the adorner associated with this tracker
//
//------------------------------------------------------------------------------------

VOID
CSelectionManager::DestroyAdorner()
{
    if ( _pAdorner ) 
    {
        _pAdorner->DestroyAdorner();
        _pAdorner->Release();
        _pAdorner = NULL;
    }
}


BOOL
CSelectionManager::HasFocusAdorner()
{
    return ( _pAdorner != NULL );
}

#if DBG == 1

void
TrackerTypeToString( TCHAR* pAryMsg, TRACKER_TYPE eType )
{
    switch ( eType )
    {
        case TRACKER_TYPE_None:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_None"));
            break;

        case TRACKER_TYPE_Caret:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Caret"));
            break;

        case TRACKER_TYPE_Selection:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Selection"));
            break;

        case TRACKER_TYPE_Control:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Control"));
            break;

        default:
            edWsprintf( pAryMsg, _T("%s"), _T("Unknown Type"));
            break;
    }
}

#endif


ELEMENT_TAG_ID
CSelectionManager::GetEditableTagId()
{
    IHTMLElement    *pIElement = NULL;
    HRESULT          hr = S_OK;

    if ( _eContextTagId == TAGID_NULL )
    {
        hr = THR( GetEditableElement( & pIElement ));
        if ( hr)
            goto Cleanup;

        hr = THR( _pEd->GetMarkupServices()->GetElementTagId( pIElement, & _eContextTagId ));
    }
Cleanup:
    ReleaseInterface(pIElement);
    return ( _eContextTagId );
}

BOOL 
CSelectionManager::IsEditContextPositioned()
{
    if (! _fPositionedSet )
    {
        _fPositioned = IsElementPositioned( GetEditableElement() );
        _fPositionedSet = TRUE;
    }

    return ( _fPositioned );
}

BOOL
CSelectionManager::IsEditContextSet()
{
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    if ( fPositioned )
        IGNORE_HR( _pEndContext->IsPositioned( & fPositioned ));

    return fPositioned;
}

HRESULT
CSelectionManager::MovePointersToContext(
                        IMarkupPointer*  pLeftEdge,
                        IMarkupPointer*  pRightEdge )
{
    HRESULT hr = S_OK;
    IFR( pLeftEdge->MoveToPointer( _pStartContext ));
    IFR( pRightEdge->MoveToPointer( _pEndContext ));
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given markup pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsInEditContext( IMarkupPointer* pPointer, BOOL fCheckContainer /*=FALSE*/)
{
    BOOL fInside = FALSE;
    
    IsInEditContext( pPointer, & fInside, fCheckContainer );
    
    return fInside;
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given display pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsInEditContext(IDisplayPointer* pDispPointer, BOOL fCheckContainer /*=FALSE*/)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    return IsInEditContext(spPointer, fCheckContainer);
    
Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given display pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditContext(IDisplayPointer* pDispPointer, BOOL *pfInEdit , BOOL fCheckContainer )
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( IsInEditContext( spPointer, pfInEdit, fCheckContainer  ));
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given markup pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditContext( IMarkupPointer  *pPointer, 
                                    BOOL            *pfInEdit,
                                    BOOL            fCheckContainer /* = FALSE */)
{
    HRESULT hr = S_OK;
    BOOL fInside = FALSE;
    BOOL fResult = FALSE;
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned  ));
    Assert( fPositioned );
#endif

    IFC( pPointer->IsLeftOf( _pStartContext, & fResult ));
        
    if ( fResult )
        goto Cleanup;

    IFC( pPointer->IsRightOf( _pEndContext, & fResult ));
    
    if ( fResult )
        goto Cleanup;

    //
    // Check the container, if necessary, otherwise, then the pointers
    // are in the same markup
    //
    if( fCheckContainer )
    {
        IFC( ArePointersInSameMarkup( pPointer, _pStartContext, &fInside ) );
    }
    else
    {
        fInside = TRUE;
    }

Cleanup:
    if ( pfInEdit )
        *pfInEdit = fInside;

    return ( hr );
}

//+====================================================================================
//
// Method: IsAfterStart
//
// Synopsis: Check to see if this markup pointer is After the Start ( ie to the Right )
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsAfterStart( IMarkupPointer* pPointer, BOOL * pfAfterStart )
{
    HRESULT hr = S_OK;
    Assert( pfAfterStart );

    BOOL fAfterStart = FALSE;

#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
#endif
    int iWherePointer = SAME;

    hr = THR( OldCompare( _pStartContext, pPointer, & iWherePointer  ));
    if ( hr )
    {
        //AssertSz(0, "Unable To Compare Pointers - Are they in the same tree?");
        goto Cleanup;
    }

    fAfterStart =  ( iWherePointer != LEFT );

Cleanup:
    *pfAfterStart = fAfterStart;
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsBeforeEnd
//
// Synopsis: Check to see if this markup pointer is Before the End ( ie to the Left )
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsBeforeEnd( IMarkupPointer* pPointer, BOOL *pfBeforeEnd )
{
    HRESULT hr = S_OK;
    BOOL fBeforeEnd = FALSE;

#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
#endif
    int iWherePointer = SAME;

    hr = THR( OldCompare( _pEndContext, pPointer, & iWherePointer  ));
    if ( hr )
    {
        //AssertSz(0, "Unable To Compare Pointers - Are they in the same tree?");
        goto Cleanup;
    }

    fBeforeEnd =  ( iWherePointer != RIGHT );

Cleanup:
    *pfBeforeEnd = fBeforeEnd;

    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsSameEditContext
//
// Synopsis: Compare two given markup pointers to see if they represent a context
//           change from the current markup context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsSameEditContext(
                        IMarkupPointer* pPointerStart,
                        IMarkupPointer* pPointerEnd,
                        BOOL * pfPositioned /* = NULL */ )
{
    HRESULT hr = S_OK;
    BOOL fSame = FALSE;
    BOOL fPositioned = FALSE;

    hr = THR(_pStartContext->IsPositioned( & fPositioned));
    if (hr)
        goto Cleanup;
        
    if ( ! fPositioned )
        goto Cleanup;

    hr = THR(_pEndContext->IsPositioned( & fPositioned));
    if (hr)
        goto Cleanup;

    if ( ! fPositioned )
        goto Cleanup;

    hr = THR(_pStartContext->IsEqualTo( pPointerStart, & fSame ));
    if (hr)
        goto Cleanup;
        
    if ( ! fSame )
        goto Cleanup;

    hr = THR(_pEndContext->IsEqualTo( pPointerEnd, & fSame ));
    if (hr)
        goto Cleanup;
        
Cleanup:
    if ( pfPositioned )
        *pfPositioned = fPositioned;

    return ( fSame );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::InitializeEditableElement
//
//  Synopsis:   Retrieves the currently editable element and stores it in a
//              local variable for retrieval.
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::InitializeEditableElement(void)
{
    HRESULT                 hr = S_FALSE;
    SP_IMarkupContainer     spIContainer;
    SP_IMarkupContainer     spIContainer2;
    BOOL                    fPositioned = FALSE;
    
    Assert( _pStartContext );

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned));

    if ( fPositioned )
    {       
        if( ! _fNoScope )
        {
            IFC( GetEditor()->CurrentScopeOrMaster( _pStartContext, &_pIEditableElement ) );
        }
        else
        {
            // Our edit context is outside of a no-scope element, scan right with
            // the start pointer to see what it is
            IFC( _pStartContext->Right( FALSE, FALSE, &_pIEditableElement, NULL, NULL ) );;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: GetEditableElement
//
// Synopsis: Return an IHTMLElement of the current editing context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::GetEditableElement( IHTMLElement** ppElement)
{
    Assert( ppElement );
    Assert( _pIEditableElement );

    *ppElement = _pIEditableElement;
    (*ppElement)->AddRef();

    return S_OK;
}

//+====================================================================================
//
// Method: GetEditableElement
//
// Synopsis: GetEditable Element as an Accessor
//
//------------------------------------------------------------------------------------

IHTMLElement* 
CSelectionManager::GetEditableElement()
{
    return _pIEditableElement;
}

IHTMLElement*
CSelectionManager::GetEditableFlowElement()
{
    HRESULT hr = S_OK;

    if ( ! _pIEditableFlowElement )
    {   
        SP_IDisplayPointer spDispPtr;
        IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPtr ));
        IFC( spDispPtr->SetPointerGravity(POINTER_GRAVITY_Left));
        IFC( spDispPtr->MoveToMarkupPointer( GetStartEditContext(), NULL ));
        IFC( spDispPtr->GetFlowElement( & _pIEditableFlowElement ));
    }

Cleanup:
    Assert( SUCCEEDED( hr ));
    Assert( _pIEditableFlowElement );
    return ( _pIEditableFlowElement );
}

HRESULT
CSelectionManager::IsElementContentSameAsContext(IHTMLElement* pIElement )
{
    HRESULT  hr  ;
    BOOL     fEqual = FALSE;
    SP_IMarkupPointer  spInsideMaster;
    SP_IMarkupPointer spEndInsideMaster;    
    ELEMENT_TAG_ID eTag;
    BOOL fNoScope = FALSE;
    
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMaster ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndInsideMaster ));
    IFC( GetMarkupServices()->GetElementTagId( pIElement, &eTag ) );
    
    if ( _pEd->IsMasterElement( pIElement ) == S_OK )
    {
        hr = THR( PositionPointersInMaster( pIElement, spInsideMaster, spEndInsideMaster ));
        if (FAILED( hr)  )
        {
            //
            // move to content fails on img.
            //
            hr = S_OK;
            goto Cleanup;
        }
    }
    else if ( IsNoScopeElement( pIElement, eTag ) == S_OK )
    {
        IFC( spInsideMaster->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        fNoScope = TRUE; 
    }
    else
    {
        IFC( spInsideMaster->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    }

    
    IFC( spInsideMaster->IsEqualTo( _pStartContext, & fEqual ));

    //
    // We can only be equal for no-scopes - if the edit context is also equal.
    //
    
    if ( fNoScope && fEqual )
    {
        fEqual = _fNoScope; 
    }
    
Cleanup:
    if ( ! FAILED( hr ))
    {
        hr = fEqual ? S_OK: S_FALSE;
    }

    RRETURN1( hr, S_FALSE );
}    

HRESULT
CSelectionManager::GetEditableContent(IHTMLElement **ppIElement)
{
    Assert( _pStartContext );
 
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned));

    if ( fPositioned )
    {
        if ( ! _fNoScope )
            RRETURN( _pStartContext->CurrentScope( ppIElement ));
        else
        {
            RRETURN ( _pStartContext->Right( FALSE, FALSE, ppIElement, NULL, NULL ) );
        }
    }
    return S_FALSE;
}

//+====================================================================================
//
// Method: SetDrillIn
//
// Synopsis: Tell the Manager we're "drilling in". Used so we know whether to set
//           or reset the _fHadGrabHandles Flag ( further used to ensure we don't create
//           a Site Selection again on an object that's UI Active).
//
//------------------------------------------------------------------------------------

void
CSelectionManager::SetDrillIn(BOOL fDrillIn)
{
    _fDrillIn = fDrillIn;
}

//+====================================================================================
//
// Method: Select All
//
// Synopsis: Do the work required by a select all.
//
//          If ISegmentList is not null it is either a TextRange or a Control Range, and we
//          select around this segment
//
//          Else we do a Select All on the Current Edit Context.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::SelectAll(ISegmentList * pSegmentList, BOOL *pfDidSelectAll, BOOL fIsRange /*=FALSE*/)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLElement         spIOuterElement;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    int                     iWherePointer = SAME;
    SELECTION_TYPE          desiredType = SELECTION_TYPE_Text;
    BOOL                    fEmpty = FALSE;
    
    Assert( pSegmentList );


    if ( pSegmentList )
    {
        IFC( pSegmentList->GetType( &desiredType ));
        IFC( pSegmentList->IsEmpty(&fEmpty ) );
    }

    if ( fIsRange && !fEmpty )
    {
        IFC( _pEd->CreateMarkupPointer( &spStart));
        IFC( _pEd->CreateMarkupPointer( &spEnd ));

        IFC( pSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spStart, spEnd ));

        IFC( OldCompare( spStart, spEnd, & iWherePointer));

        if ( iWherePointer == SAME )
            desiredType = SELECTION_TYPE_Caret;
        else
            desiredType = SELECTION_TYPE_Text;

        IFC( EnsureEditContext( spStart ));            
            
        hr = Select( spStart, spEnd , desiredType, pfDidSelectAll );

    }
    else
    {
        BOOL fStartPositioned = FALSE;
        BOOL fEndPositioned = FALSE;

        IGNORE_HR( _pStartContext->IsPositioned( & fStartPositioned ));
        IGNORE_HR( _pEndContext->IsPositioned( & fEndPositioned ));
        desiredType = SELECTION_TYPE_Text;

        //
        // If we're not editable, or we're UI Active we select the edit context
        //
        if ( ( !IsParentEditable() || HasFocusAdorner() )
                && fStartPositioned && fEndPositioned )
        {
           SP_IHTMLElement spElement;
           IFC( _pEndContext->CurrentScope(&spElement) );
           if ( CheckUnselectable(spElement) == S_OK )
               goto Cleanup;

           hr = Select( _pStartContext, _pEndContext , desiredType , pfDidSelectAll );
        }
        else
        {
            //
            // Select the "outermost editable element"
            //
            IFC( _pEd->CreateMarkupPointer( & spStart));
            IFC( _pEd->CreateMarkupPointer( & spEnd ));
            SP_IHTMLElement spActive;
            IFC( GetDoc()->get_activeElement( & spActive ));
            hr = THR( _pEd->GetOuterMostEditableElement( spActive , &spIOuterElement ));
            if (FAILED(hr))
            { 
                // We can fail in frameset cases, so don't propogate the hr
                hr = S_OK;
                goto Cleanup;
            }
            
            if ( CheckUnselectable(spIOuterElement) == S_OK )
                goto Cleanup;

            IFC( spStart->MoveAdjacentToElement( spIOuterElement, ELEM_ADJ_AfterBegin));
            IFC( spEnd->MoveAdjacentToElement( spIOuterElement, ELEM_ADJ_BeforeEnd ));

            IFC( EnsureEditContext( spStart ));
#if DBG == 1
            BOOL fEqual = FALSE;
            IGNORE_HR( _pStartContext->IsEqualTo( spStart, & fEqual ));
            AssertSz( fEqual , "Pointers not same - did Ensure Edit Context work ?");
#endif 
            hr = Select( spStart, spEnd , desiredType, pfDidSelectAll );
        }
    }

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: SegmentList based way of implementing selection
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::Select( ISegmentList * pISegmentList )
{
    HRESULT        hr = S_OK;
    SELECTION_TYPE eType  = SELECTION_TYPE_None;
    TRACKER_TYPE   trType = TRACKER_TYPE_None;
    CSelectionChangeCounter selCounter(this);

    // chandras04/27/2000 :
    //          we should be checking for the empty segment list condition here to avoid 
    //          unnecessary code execution
    //
    selCounter.BeginSelectionChange();
    
    IFC( EnsureEditContext( pISegmentList ));
    if( hr == S_FALSE )
    {
        //
        // The become current call was cancelled, we need to gracefully bail the select
        //
        hr = S_OK;
        goto Cleanup;
    }
    
    IFC( pISegmentList->GetType( & eType ));

    trType = ConvertSelectionType(eType);

    Assert( trType == TRACKER_TYPE_Control || trType == TRACKER_TYPE_Selection || trType == TRACKER_TYPE_Caret );
    
    IFC( SetCurrentTracker( trType, pISegmentList ));

    // fire the selectionchange event
    selCounter.EndSelectionChange();
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::Select(  
                    IMarkupPointer* pStart, 
                    IMarkupPointer * pEnd, 
                    SELECTION_TYPE eType,
                    BOOL *pfDidSelection /*= FALSE */)
{
    HRESULT             hr = S_OK;
    BOOL                fDidSelection = FALSE;      // Success
    SP_IDisplayPointer  spDispStart;                // Begin display pointer
    SP_IDisplayPointer  spDispEnd;                  // End display pointer
    BOOL                fPositioned;                // Are the pointers positioned?
    DWORD               dwTCCode = 0;               // For transitioning trackers
    POINTER_GRAVITY     eGravity;
    TRACKER_TYPE        trType ;
    BOOL                fSameMarkup;
    CSelectionChangeCounter selCounter(this);

    //  Make sure pStart is not in a master element
    hr = THR( GetEditor()->IsPointerInMasterElementShadow(pStart) );
    if ( hr == S_OK )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else if ( FAILED(hr) )
    {
        goto Cleanup;
    }

    selCounter.BeginSelectionChange();
    
    IFC( EnsureEditContext( pStart ));
    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    trType = ConvertSelectionType(eType);

#ifdef FORMSMODE
    Assert (!(IsInFormsSelectionMode() && (trType == TRACKER_TYPE_Caret || trType == TRACKER_TYPE_Selection)));
#endif

    if (_fDeferSelect)
    {
        //
        // Ensure we have defer pointers
        //

        if (!_pDeferStart)
            IFC( _pEd->CreateMarkupPointer(&_pDeferStart) );
    
        if (!_pDeferEnd)
            IFC( _pEd->CreateMarkupPointer(&_pDeferEnd) );

        //
        // Just remember the parameters for now.  At some point, we should
        // get another select call with _fDeferSelect == FALSE.
        //

        IFC( _pDeferStart->MoveToPointer(pStart) );
        IFC( pStart->Gravity(&eGravity) );
        IFC( _pDeferStart->SetGravity(eGravity) );

        IFC( _pDeferEnd->MoveToPointer(pEnd) );
        IFC( pEnd->Gravity(&eGravity) );
        IFC( _pDeferEnd->SetGravity(eGravity) );

        _eDeferSelType = eType; 
    }
    else
    {
        Assert( pStart && pEnd );

        IFC( pStart->IsPositioned( &fPositioned ));

        if ( ! fPositioned )
        {
            AssertSz( 0, "Select - Start Pointer is NOT positioned!");
            hr = E_INVALIDARG;
            goto Cleanup;
        }


        IFC( pEnd->IsPositioned( &fPositioned ));
        if ( ! fPositioned )
        {
            AssertSz( 0, "Select - End Pointer is NOT positioned!");
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Verify that the pointers we're been given are in the Edit Context.
        //
        AssertSz( IsInEditContext(pStart), "Start Pointer is NOT in Edit Context");
        AssertSz( IsInEditContext(pEnd), "End Pointer is NOT in Edit Context");

        //
        // If the specified type is of type selection, but the two pointers they
        // gave us are equal, coerce the type so that we create a caret tracker
        // instead
        //
        if( trType == TRACKER_TYPE_Selection )
        {
            CEditPointer    edptrStart( GetEditor(), pStart );
            BOOL            fEqual;

            IFC( edptrStart.IsEqualTo( pEnd, 
                    BREAK_CONDITION_ANYTHING - BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, 
                    &fEqual ) ); 

            if( fEqual )
                trType = TRACKER_TYPE_Caret;
        }

         // If caret tracker is both source and destination, and the caret did not move, do nothing
        if (trType == TRACKER_TYPE_Caret )
        {                
            if( GetTrackerType() == TRACKER_TYPE_Caret && 
                !IsDefaultTrackerPassive() )
            {
                BOOL                fEqual;
                SP_IMarkupPointer   spMarkupCaret;
                SP_IDisplayPointer  spDispCaret;
                CCaretTracker       *pCaretTracker = DYNCAST(CCaretTracker, _pActiveTracker);

                if (pCaretTracker)
                {
                    IFC( pCaretTracker->GetCaretPointer(&spDispCaret) );
                    IFC( GetEditor()->CreateMarkupPointer(&spMarkupCaret) );
                    IFC( spDispCaret->PositionMarkupPointer(spMarkupCaret) );
                    
                    if (spMarkupCaret != NULL )
                    {
                        IFC( spMarkupCaret->IsEqualTo(pStart, &fEqual) );

                        if (fEqual)
                        {
                            IFC( spMarkupCaret->IsEqualTo(pEnd, &fEqual) );

                            if (fEqual)
                            {
                                SP_IDisplayPointer spDispPointer;
                                SP_IHTMLCaret      spCaret;
                                CARET_DIRECTION    eOrigDir;

                                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                                hr = THR( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
                                if ( hr == CTL_E_INVALIDLINE )
                                {
                                    hr = S_OK;
                                    goto Cleanup;
                                }
                                else if ( FAILED( hr ))
                                {
                                    goto Cleanup;
                                }

                                //
                                // Since range select is ambiguous, we normalize by setting gravity to line start
                                //
                                
                                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                                
                                //
                                // For app compat, if you select and the caret doesn't move, then we don't
                                // do anything.  (bug 99367)
                                //
                                
                                IFC( spDispPointer->IsEqualTo(spDispCaret, &fEqual) );
                                if (fEqual)
                                {   
                                    goto Cleanup;
                                }                 
                                
                                //
                                // We need to preserve the caret direction just in case
                                // we are calling select and the caret is already there.
                                // [zhenbinx]
                                //
                                IFC( GetDisplayServices()->GetCaret(&spCaret) );
                                IFC( spCaret->GetCaretDirection(&eOrigDir) );
                                IFC( pCaretTracker->PositionCaretAt( spDispPointer, eOrigDir, POSCARETOPT_None, ADJPTROPT_None ));
                            }
                        }           
                    }
                }
            }
        }

        IFC( EnsureAdornment( FALSE ));

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
        hr = THR( spDispStart->MoveToMarkupPointer(pStart, NULL) );
        if ( hr == CTL_E_INVALIDLINE )
        {
            hr = S_OK;
            ED_PTR( edStart );
            IFC( edStart.MoveToPointer( pStart ));
            DWORD dwBreak;
            
            edStart.SetBoundary( GetStartEditContext() , pEnd );

            IFC( edStart.Scan( RIGHT , BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite , & dwBreak ));
            if ( edStart.CheckFlag( dwBreak, BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite ))
            {
                if ( edStart.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                {
                    IFC( edStart.Scan( LEFT , BREAK_CONDITION_Text, & dwBreak ));            // bring it back to before the start of the text.            
                }                            
                IFC( spDispStart->MoveToMarkupPointer( edStart , NULL) );
            }
            else
            {
                hr = S_OK;
                AssertSz(0,"Not a valid point for start of selection");
            }
        }
        else if ( FAILED( hr ))
        {
            goto Cleanup;
        }
        
        IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
        hr = THR ( spDispEnd->MoveToMarkupPointer(pEnd, NULL) );

        //
        // Not a valid place for the display pointer. We handle by scanning for text.
        //
        if ( hr == CTL_E_INVALIDLINE )
        {
            hr = S_OK;
            ED_PTR( edEnd );
            IFC( edEnd.MoveToPointer( pEnd ));
            DWORD dwBreak;
            
            edEnd.SetBoundary( pStart , GetEndEditContext());

            IFC( edEnd.Scan( LEFT, BREAK_CONDITION_Text| BREAK_CONDITION_EnterTextSite , & dwBreak ));
            if ( edEnd.CheckFlag( dwBreak, BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite ))
            {
                if ( edEnd.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                {
                    IFC( edEnd.Scan( RIGHT, BREAK_CONDITION_Text  & dwBreak ));            // bring it back to before the start of the text.
                }                    
                IFC( spDispEnd->MoveToMarkupPointer( edEnd , NULL) );
            }
            else
            {
                hr = S_OK;
                AssertSz(0,"Not a valid point for end of selection");
            }
        }
        else if ( FAILED( hr ))
        {
            goto Cleanup;
        }
       
        IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

        // We just potentially moved our pointers into different markup containers
        // If this happens, fail the select, but don't propogate the hr
        IFC( ArePointersInSameMarkup( GetEditor(), spDispStart, spDispEnd, &fSameMarkup ) );
        if( !fSameMarkup )
        {
            goto Cleanup;
        }

        if( trType == TRACKER_TYPE_Selection )
        {
            SP_IHTMLElement  spIEditElement;             // Which element is bound by the pointers

            // Try to find the element under the start pointer
            IFC( GetEditor()->CurrentScopeOrMaster( spDispStart, &spIEditElement, pStart ));
            BOOL fSelect;
            
            IFC( FireOnSelectStart( spIEditElement, &fSelect , NULL));

            if ( ! fSelect )
            {
                fDidSelection = FALSE;
                goto Cleanup;
            }
        }
        
        hr = SetCurrentTracker ( trType,  
                                 spDispStart, 
                                 spDispEnd, 
                                 dwTCCode, 
                                 CARET_MOVE_NONE, 
                                 FALSE );

        if (hr == S_OK)
            fDidSelection = TRUE;
    }

    if (fDidSelection)
    {
        // fire the selectionchange event
        selCounter.EndSelectionChange();
    }

Cleanup:
    if ( pfDidSelection )
        *pfDidSelection = fDidSelection;
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteSelected
//
// Synopsis: See if the given element is Site Selected
//
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::IsElementSiteSelected( IHTMLElement* pIElement)
{
    HRESULT hr = S_FALSE;

    if ( GetTrackerType() == TRACKER_TYPE_Control )
    {
        CControlTracker* pControlTrack = DYNCAST( CControlTracker, _pActiveTracker );
        hr = pControlTrack->IsSelected( pIElement , NULL ) ;
    }
        
    RRETURN1 ( hr , S_FALSE);
}

//+====================================================================================
//
// Method: IsPointerInSelection
//
// Synopsis: Check to see if the given pointer is in a Selection
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsPointerInSelection( 
                         IDisplayPointer    *pIDispPointer ,
                         BOOL               *pfPointInSelection,
                         POINT              *pptGlobal,
                         IHTMLElement       *pIElementOver)
{
    BOOL fInSelection = FALSE;


    if ( ! IsDefaultTrackerPassive() )
    {
        fInSelection = _pActiveTracker->IsPointerInSelection( pIDispPointer, pptGlobal, pIElementOver );
    }

    if ( pfPointInSelection )
        *pfPointInSelection = fInSelection;

    RRETURN ( S_OK );
}

VOID
CSelectionManager::AdornerPositionSet()
{
    Assert( _fPendingAdornerPosition );

    if (_lastEvent)
    {
        DYNCAST( CControlTracker, _pActiveTracker)->BecomeActiveOnFirstMove( _lastEvent );
        delete _lastEvent;
        _lastEvent = NULL;
    }
    _fPendingAdornerPosition = FALSE;
}

//+===================================================================================
// Method: IsMessageInSelection
//
// Synopsis: Check to see if the given message is in the current SelectionRenderingServices
//
//------------------------------------------------------------------------------------
BOOL
CSelectionManager::IsMessageInSelection( CEditEvent* pEvent )
{
    HRESULT         hr = S_OK;
    SELECTION_TYPE  eSegmentType = SELECTION_TYPE_None;
    BOOL            fEmpty = FALSE;
    BOOL            fIsInSelection = FALSE;
    SP_ISegmentList spSegmentList;

    IFC( GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );

    IFC( spSegmentList->GetType(&eSegmentType ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    if ( ( fEmpty == FALSE ) &&
         ( GetTrackerType() == TRACKER_TYPE_Selection ) )
    {
        fIsInSelection = DYNCAST( CSelectTracker, _pActiveTracker )->IsMessageInSelection(pEvent);
    }

Cleanup:
    return fIsInSelection;
}

//+====================================================================================
//
// Method: IsOkToEditContents
//
// Synopsis: Fires the OnBeforeXXXX Event back to Trident to see if its' ok to UI-Activate,
//           and place a caret inside a given control.
//
// RETURN: TRUE - if it's ok to go ahead and UI Activate
//         FALSE - if it's not ok to UI Activate 
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::FireOnBeforeEditFocus()
{
    BOOL fEditFocusBefore = _fEditFocusAllowed;
    SP_IHTMLElement spElement = GetEditableElement();

    if ( IsDontFireEditFocus() )
    {
        return TRUE;
    }
    
    BOOL fReturn = EdUtil::FireOnBeforeEditFocus(spElement,IsContextEditable() ) ;

    _fEditFocusAllowed = fReturn ;
    //
    // We have changed states - so we need to enable/disable the UI Active border
    // Note that by default _fUIActivate == TRUE - so this will not fire on SetEditContextPrivate
    // for the first time.
    //
    if ( _fEditFocusAllowed != fEditFocusBefore )
    {
        if ( _fEditFocusAllowed && IsElementUIActivatable())
        {
            IGNORE_HR( CreateAdorner());
        }
        else if ( !_fEditFocusAllowed && _pAdorner )
        {
            DestroyAdorner();
        }
        _pActiveTracker->OnEditFocusChanged();
    }

    return fReturn;
}

//+====================================================================================
//
// Method: IsInEditContextClientRect
//
// Synopsis: Is the given point in the content area of the Editable Element ?
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditableClientRect( POINT ptGlobal )
{
    HRESULT         hr = S_OK;
    RECT            rectGlobal;

    //
    // Retrieve the rect for our editable element, and transform
    // it to global coord's
    //
    IFC( GetEditor()->GetClientRect( GetEditableElement() , &rectGlobal ));

    // Check if our event is in the rect
    hr =  ::PtInRect( & rectGlobal, ptGlobal ) ? S_OK : S_FALSE;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

#if DBG == 1

void 
CSelectionManager::DumpTree( IMarkupPointer* pPointer )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled
    if ( GetEditDebugServices() )
    {
        IGNORE_HR( GetEditDebugServices()->DumpTree( pPointer ));
    }        
}

long
CSelectionManager::GetCp( IMarkupPointer* pPointer )
{
    long cp = 0;

    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled
    
    if ( GetEditDebugServices() )
    {
        IGNORE_HR( GetEditDebugServices()->GetCp( pPointer, & cp));
    }
    return cp;
}

void 
CSelectionManager::SetDebugName( IMarkupPointer* pPointer, LPCTSTR strDebugName )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled

    if ( GetEditDebugServices())
    {
        IGNORE_HR( GetEditDebugServices()->SetDebugName( pPointer, strDebugName));
    }        
}

void 
CSelectionManager::SetDebugName( IDisplayPointer* pDispPointer, LPCTSTR strDebugName )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled

    if ( GetEditDebugServices())
    {
        IGNORE_HR( GetEditDebugServices()->SetDisplayPointerDebugName( pDispPointer, strDebugName));
    }        
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CSelectionmManager::DeferSelection, public
//
//  Synopsis:   Defers selection until some future point in time.  Created for undo batching.
//
//  Arguments:  [fDeferSelect] - If fDeferSelection==TRUE, selection is deferred until 
//                               fDeferSelection is called with fDeferSelect==FALSE.  
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CSelectionManager::DeferSelection(BOOL fDeferSelect)
{
    HRESULT hr = S_OK;

    _fDeferSelect = fDeferSelect; 

    if (!fDeferSelect && _eDeferSelType != TRACKER_TYPE_None)
    {
        BOOL fTypedSinceLastUrlDetect = HaveTypedSinceLastUrlDetect();

        // We only get called if undo is restoring the selection state.  In this 
        // case, don't autodetect while restoring the selection.
        SetHaveTypedSinceLastUrlDetect( FALSE );
        hr = THR(Select(_pDeferStart, _pDeferEnd, _eDeferSelType));
        if (!_fDontScrollIntoView)
        {
            SP_IDisplayPointer  spDispPointer;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->MoveToMarkupPointer(_pDeferStart, NULL) );

            IGNORE_HR(spDispPointer->ScrollIntoView());
        }
        SetHaveTypedSinceLastUrlDetect( fTypedSinceLastUrlDetect );
    }
    _eDeferSelType = SELECTION_TYPE_None;  // clear deferred selection type

Cleanup:
    RRETURN(hr);
}

#ifdef FORMSMODE
BOOL 
CSelectionManager::IsInFormsSelectionMode()
{
    return (IsContextEditable() &&  (_eSelectionMode == SELMODE_FORMS));
}

BOOL 
CSelectionManager::IsInFormsSelectionMode(IHTMLElement* pIElement)
{
    BOOL fFormsMode = FALSE;

    if (IsContextEditable())
    {
        IGNORE_HR( CheckFormSelectionMode( pIElement, & fFormsMode ));
    }
    return fFormsMode ;
}
        
HRESULT 
CSelectionManager::CheckFormSelectionMode(IHTMLElement* pElement,BOOL *pfFormSelMode)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spCheckElement;
    BOOL    fMixedSelectionMode = FALSE;
    BSTR    bstrSelectionMode      = SysAllocString(_T("selectionMode"));
    BSTR    bstrFormsSelectionMode = SysAllocString(_T("forms"));
    BSTR    bstrMixedSelectionMode = SysAllocString(_T("mixed"));

    Assert (pfFormSelMode);
    
    *pfFormSelMode = FALSE;
        
    if (bstrSelectionMode == NULL || bstrFormsSelectionMode == NULL || bstrMixedSelectionMode == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }    

    ReplaceInterface( &spCheckElement , pElement );
    while (1)
    {
        SP_IHTMLElement spParentElement;
        IFC(CheckAttribute( spCheckElement, pfFormSelMode, bstrSelectionMode, bstrFormsSelectionMode));
        
        if (*pfFormSelMode)
            break;
    
        IFC(CheckAttribute( spCheckElement, &fMixedSelectionMode, bstrSelectionMode, bstrMixedSelectionMode));
        
        if (fMixedSelectionMode)
            break;
    
        IFC(GetParentElement(GetMarkupServices(), spCheckElement, &spParentElement));
        if (spParentElement == NULL)
        {
            break;
        }
        ReplaceInterface( &spCheckElement , (IHTMLElement*)spParentElement );
   }

Cleanup:
    if (fMixedSelectionMode)
        *pfFormSelMode = FALSE;

    SysFreeString(bstrSelectionMode);
    SysFreeString(bstrFormsSelectionMode);
    SysFreeString(bstrMixedSelectionMode);
    RRETURN (hr);
}

HRESULT 
CSelectionManager::SetSelectionMode(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;
    BOOL fFormsSelMode = FALSE;

    IFC( CheckFormSelectionMode(pElement, &fFormsSelMode));
     _eSelectionMode = (fFormsSelMode ?  SELMODE_FORMS : SELMODE_MIXED);
    
Cleanup:
    RRETURN (hr);
}
#endif

//+---------------------------------------------------------------------
//
// Method: SelectFromShift
//
// Synopsis: Start a select tracker given 2 pointers 
//           Equivalent to old TN_END_POS_SELECT
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::SelectFromShift( IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr = S_OK ;
    
#if DBG ==1
    Assert( pDispStart && pDispEnd);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned));
    Assert( fPositioned );
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned));
    Assert( fPositioned );
#endif

    if ( ! pDispStart || ! pDispEnd )
    {
        return E_FAIL;
    }

    pDispStart->AddRef();
    pDispEnd->AddRef();

    // NOTE: - correct for all the places POS_SELECT is used.
    DWORD dwCode = TRACKER_CREATE_STARTFROMSHIFTKEY | TRACKER_CREATE_STARTFROMSHIFTMOUSE;

    if ( pDispStart && pDispEnd )
    {
        hr = THR( SetCurrentTracker( TRACKER_TYPE_Selection,
                                     pDispStart,
                                     pDispEnd,
                                     dwCode ));
    }            

    pDispStart->Release();
    pDispEnd->Release();
    RRETURN( hr );
}

HRESULT
CSelectionManager::StartAtomicSelectionFromCaret( IDisplayPointer *pPosition )
{
    HRESULT hr = S_OK ;
    
#if DBG ==1
    Assert( pPosition );
    BOOL fPositioned = FALSE;
    IGNORE_HR( pPosition->IsPositioned( & fPositioned));
    Assert( fPositioned );
#endif

    if ( ! pPosition )
    {
        return E_FAIL;
    }

    pPosition->AddRef();
    hr = THR( SetCurrentTracker( TRACKER_TYPE_Selection,
                                 pPosition,
                                 pPosition,
                                 0 ));
    _fEnsureAtomicSelection = TRUE;
    pPosition->Release();

    CSelectionChangeCounter selCounter(this);
    selCounter.SelectionChanged();

    RRETURN( hr );
}


HRESULT
CSelectionManager::PositionCaret( CEditEvent* pEvent )
{
    RRETURN (SetCurrentTracker( 
                        TRACKER_TYPE_Caret,
                        pEvent,
                        0,
                        CARET_MOVE_NONE ) );
}

HRESULT
CSelectionManager::PositionControl( IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr = S_OK;
    CSelectionChangeCounter selCounter(this);
#if DBG ==1
    Assert( pDispStart);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned));
    Assert( fPositioned );

    Assert( pDispEnd);
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned));
    Assert( fPositioned );    
#endif
    if ( ! pDispStart || ! pDispEnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDispStart->AddRef();
    pDispEnd->AddRef();

    selCounter.BeginSelectionChange();
    
    hr = THR(SetCurrentTracker( TRACKER_TYPE_Control, 
                                pDispStart, 
                                pDispEnd ));

    // fire the selectionchange event
    selCounter.EndSelectionChange();
    
    pDispStart->Release();
    pDispEnd->Release();

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: PositionCaret
//
// Synopsis: Place the caret at the given locaiton. Replacement for TN_END_TRACKER_POS_CARET
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::PositionCaret( IDisplayPointer * pDispPointer, CEditEvent* pEvent /*=NULL*/ )
{
    HRESULT hr;
    

    Assert( pDispPointer);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispPointer->IsPositioned( & fPositioned));

    if ( !pDispPointer || ! fPositioned)
    {
        return E_FAIL;
    }
    
    pDispPointer->AddRef();      
    IFC( SetCurrentTracker( TRACKER_TYPE_Caret,
                            pDispPointer,
                            pDispPointer ));

    IFC( EnsureAdornment());
 
    if ( pEvent )
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.BeginSelectionChange();
    
        Assert( _pActiveTracker );
        IFC( _pActiveTracker->HandleEvent( pEvent));

        selCounter.EndSelectionChange();
    }

    
Cleanup:
    pDispPointer->Release();
        
    RRETURN( hr );
}           

//+---------------------------------------------------------------------
//
// Method: DeleteRebubble
//
// Synopsis: Delete the selection - bubble event to new tracker
//           Used for typing into selection. Equivalent to TN_FIRE_DELETE_REBUBBLE
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::DeleteRebubble( CEditEvent* pEvent )
{
    HRESULT             hr;            
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spDispSelectionStart;

    // To be word2k compat, we need to start a new undo unit on delete rebubble and group
    // it with typing

    IFC( _pCaretTracker->TerminateTypingBatch() );
    IFC( _pCaretTracker->BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) )

    // Springload formats at start of selection (Word behavior).
    if ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection)
    {
        CSelectTracker  * pSelectTrack = DYNCAST( CSelectTracker, _pActiveTracker );
        IFC( pSelectTrack->AdjustPointersForChar() );
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispSelectionStart) );
        IFC( spDispSelectionStart->MoveToPointer(pSelectTrack->GetStartSelection()) );
    }

    IFC( DeleteSelection( FALSE ));

    // Make sure we move into an adjacent url
    Assert( GetTrackerType() == TRACKER_TYPE_Caret && spDispSelectionStart != NULL);
    if (GetTrackerType() == TRACKER_TYPE_Caret && spDispSelectionStart != NULL)
    {
        CEditPointer        epTest(GetEditor());
        DWORD               dwSearch = DWORD(BREAK_CONDITION_OMIT_PHRASE);
        DWORD               dwFound;
        CCaretTracker       *pCaretTracker = DYNCAST(CCaretTracker, _pActiveTracker);
        SP_IDisplayPointer  spDispPointer;
        
        IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );

        IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
        if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );
        }

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->MoveToMarkupPointer(epTest, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IFC( pCaretTracker->PositionCaretAt( spDispPointer, 
                                                CARET_DIRECTION_INDETERMINATE, 
                                                POSCARETOPT_None, 
                                                ADJPTROPT_None ));
        }                   
        else 
        {
            BOOL fAdjust;

            //
            // Only adjust if we can possibly be in the an ambiguous position.
            // This is necessary to preserve compat with outlook.  We can't
            // adjust if there are just phrase elements.
            //
        
            IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );
            IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
            
            fAdjust = epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock 
                                       | BREAK_CONDITION_EnterSite 
                                       | BREAK_CONDITION_EnterTextSite
                                       | BREAK_CONDITION_NoScopeBlock);
                                       
            IFC( pCaretTracker->PositionCaretAt( 
                    spDispPointer, 
                    CARET_DIRECTION_INDETERMINATE, 
                    fAdjust ? POSCARETOPT_None : POSCARETOPT_DoNotAdjust, 
                    ADJPTROPT_DontExitPhrase | ADJPTROPT_AdjustIntoURL));
        }
    }

    hr = THR( HandleEvent( pEvent ));
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSelectionManager::DeleteNoBubble()
{
    HRESULT hr;

    IFC( DeleteSelection( TRUE ));
    if ( IsPendingUndo())
    {
        IFC( GetMarkupServices()->EndUndoUnit());
        SetPendingUndo( FALSE );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::HideCaret()
{
    RRETURN( CCaretTracker::SetCaretVisible( GetDoc(), FALSE ));
}

HRESULT 
CSelectionManager::AttachFocusHandler()
{
    HRESULT hr = S_OK ;

    VARIANT_BOOL varAttach = VB_TRUE;
    
    SP_IHTMLWindow2 spWindow2;
    SP_IDispatch    spDisp;
    
    BSTR bstrFocusEvent = ::SysAllocString(_T("onfocus"));
    BSTR bstrBlurEvent  = ::SysAllocString(_T("onblur"));
    Assert( ! _pIFocusWindow );
    
    IFC( _pFocusHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));    
    IFC( GetDoc()->get_parentWindow( & spWindow2));
    IFC( spWindow2->QueryInterface( IID_IHTMLWindow3, (void**) & _pIFocusWindow ));

    IFC( _pIFocusWindow->attachEvent(bstrFocusEvent , spDisp, & varAttach));
    Assert( varAttach == VB_TRUE );
    
    IFC( _pIFocusWindow->attachEvent(bstrBlurEvent, spDisp , & varAttach));
    Assert( varAttach == VB_TRUE );

    _fFocusHandlerAttached = TRUE ;

Cleanup:
    ::SysFreeString(bstrFocusEvent);
    ::SysFreeString(bstrBlurEvent);
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachFocusHandler()
{
    HRESULT hr = S_OK ;

    BSTR bstrFocusEvent = ::SysAllocString(_T("onfocus"));
    BSTR bstrBlurEvent  = ::SysAllocString(_T("onblur"));

    if (_fFocusHandlerAttached)
    {
        Assert( _pIFocusWindow );
        
        SP_IHTMLWindow3 spWindow3;
        SP_IHTMLWindow2 spWindow2;
        SP_IDispatch    spDisp;
        
        IFC( _pFocusHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));        

        IFC( _pIFocusWindow->detachEvent(bstrFocusEvent, spDisp ));   
        IFC( _pIFocusWindow->detachEvent(bstrBlurEvent , spDisp ));

        ClearInterface( & _pIFocusWindow );
        _fFocusHandlerAttached = FALSE ;
    }

Cleanup:
    ::SysFreeString(bstrFocusEvent);
    ::SysFreeString(bstrBlurEvent);

    RRETURN( hr );
}

HRESULT
CSelectionManager::RebubbleEvent( CEditEvent* pEvent )
{
    HRESULT hr;

    WHEN_DBG( _ctEvtLoop++ );
#ifndef _PREFIX_
    AssertSz( _ctEvtLoop == 1,"Recursive Rebubble Event calls");    
#endif

    hr = THR( _pActiveTracker->HandleEvent( pEvent ));

    WHEN_DBG( _ctEvtLoop -- );
    
    RRETURN1( hr, S_FALSE);
}


inline HRESULT
CFocusHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    IHTMLEventObj *pObj=NULL;
    BOOL fValidEvent = FALSE;
    SP_IHTMLDocument4 spDoc4;
    VARIANT_BOOL vbFocus;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) );
            if ( pObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor() );
                IFC( evt.Init( pObj ));

                IFC( _pMan->GetDoc()->QueryInterface( IID_IHTMLDocument4, (void**) & spDoc4 ));
                IFC( spDoc4->hasFocus( & vbFocus ));
                //
                // for Nav compat - we can have window.onBlur - that don't correspond to WM_KILLFOCUS
                // we have to do this magic - to distinguish between the bogus onblurs' and a "real" onblur
                //
                
                switch( evt.GetType() )
                {
                    case EVT_KILLFOCUS:
                        fValidEvent = vbFocus == VB_FALSE ;                    
                        break;
                        
                    case EVT_SETFOCUS:

                        fValidEvent = vbFocus == VB_TRUE  ;
                        break;                
                        
                    default:
                        AssertSz(0,"Unexpected event");
                }

                if ( fValidEvent )
                {
                    IFC( _pMan->HandleEvent( & evt ));                         
                }
            }
        }
    }
    
Cleanup:
    ReleaseInterface( pObj );
    
    return S_OK; // Attach Events expects this.
}


BOOL
CSelectionManager::CaretInPre()
{
    Assert( _pCaretTracker);
    if ( GetDisplayServices() )
    {
        SP_IHTMLCaret spCaret;    
        IGNORE_HR( GetDisplayServices()->GetCaret( & spCaret ));
        return _pCaretTracker->IsCaretInPre( spCaret );
    }
    return FALSE;
}

HRESULT
CSelectionManager::ContainsSelectionAtBrowse( IHTMLElement* pIElement )
{
    HRESULT hr;
    ELEMENT_TAG_ID eTag;
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));

    switch( eTag )
    {
        case TAGID_BODY:
        case TAGID_INPUT:
        case TAGID_TEXTAREA:
            hr = S_OK;
            break;
            
        default:
        {
            //
            // If we are not editable, and our parent is editable, then we treat this element
            // like it is at browse time, and we need to contain selection
            //
            if( (IsEditable( pIElement ) == S_FALSE) &&
                (EdUtil::IsParentEditable( GetMarkupServices(), pIElement ) == S_OK) )
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }
    
Cleanup:
    RRETURN1 ( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::GetEditContext
//
//  Synopsis:   Retrieves the element which should contain the edit context, based
//              on an element passed in, and whether or not a 'drill in' is 
//              occuring.  A drill in is when the user has done a lbutton down
//              on an element in an attempt to drill in.
//
//               - pIEnd and pIStart are NOT used 
//              TODO: Remove pIEnd and pIStart or populate them?
//
//  Arguments:  pIStartElement = Candidate element for edit context
//              ppEditThisElement = Element where edit context should be set
//              fDrillingIn = Are we drilling into the element?
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::GetEditContext( 
                            IHTMLElement* pIStartElement, 
                            IHTMLElement** ppEditThisElement, 
                            IMarkupPointer* pIStart, /* = NULL */
                            IMarkupPointer* pIEnd, /*= NULL */ 
                            BOOL fDrillingIn /*= FALSE */)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spEditableElement;              // Element which should get edit context
    SP_IHTMLElement spCurElement;                   

    BOOL fNoScope = FALSE;
    BOOL fEditable = FALSE;
    BOOL fHasReadOnly = FALSE;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

#if DBG == 1
    BOOL fSkipTableCheck = FALSE;
#endif

    SP_IHTMLElement spLastReadOnly;
    SP_IHTMLInputElement spInputElement;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLElement spNextElement;

    //
    // If we are drilling into a viewlink, then the editable element should
    // be the master
    //
    if ( fDrillingIn && _pEd->IsMasterElement( pIStartElement) == S_OK )
    {
        spEditableElement = pIStartElement;
    }

    if ( spEditableElement.IsNull() )
    {        
        if ( IsEditable( pIStartElement) == S_OK ||
             ( ! fDrillingIn && EdUtil::IsParentEditable( GetMarkupServices(), pIStartElement ) == S_OK ))
        {            
            IFC( GetMarkupServices()->GetElementTagId( pIStartElement, &eTag ));
        
            if ( fDrillingIn &&
                 IsNoScopeElement( pIStartElement, eTag) == S_OK )
            {
                //
                // Stop on a No-Scope (eg. CheckBox - or input ). If we're drilling in .
                //
                spEditableElement = (IHTMLElement*) pIStartElement;
                fNoScope = TRUE;
            }            
            else
            {
                spCurElement = (IHTMLElement*) pIStartElement; 
                //
                // If we're not drilling in - and starting at a site selectable element
                // we can then start at the ParentLayout Node - as this will be our edit context
                //
                if ( !fDrillingIn )
                {
                    if ( _pEd->IsContentElement(pIStartElement) == S_OK )
                    {
                        ParentElement( GetMarkupServices(), &spCurElement.p );
                        AssertSz( ! spCurElement.IsNull() , "Master not in Tree");
                    }

                    if ( ! spCurElement.IsNull() ) // should always be true - unless master wasn't in tree.
                    {
                        IFHRC( GetLayoutElement( GetMarkupServices(), spCurElement , & spNextElement));

                        spCurElement = spNextElement;
                    }
                    
                    if ( _pEd->IsElementSiteSelectable( spCurElement ) == S_OK )
                    {
                        IFHRC( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spNextElement ));
                        spCurElement = spNextElement;
                    }
                }       
                
                while ( ! spCurElement.IsNull() )
                {
                    
                    //
                    // marka - we no longer want to have the edit context a table. However
                    // it is still valid to call GetEditContext in PumpMessage and have to special case
                    // tables. 
                    //
                    // If the spCurElement is any derivative of a table - we will find the outermost table cell.
                    // Pumpmessage will then make the parent of this table current.
                    //
                    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));
                    BOOL fFlowLayout;
                    IFC(IsBlockOrLayoutOrScrollable(spCurElement, NULL, &fFlowLayout));

                    if ( IsTablePart( eTag ) || eTag == TAGID_TABLE )
                    {
                        SP_IHTMLElement spParentElement;
                        IFC( spCurElement->get_parentElement( & spParentElement ));
                        
                        if (! ( IsEditable( spCurElement) == S_OK &&
                                IsEditable( spParentElement ) == S_FALSE ))
                        {                             
                            IFC( _pEd->GetOutermostTableElement( spCurElement, & spNextElement ));                    
                            spCurElement = spNextElement;
#if DBG == 1
                            ELEMENT_TAG_ID eTagDbg = TAGID_NULL;
                            IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTagDbg));
                            Assert( eTagDbg == TAGID_TABLE );
#endif
                            IFHRC( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spEditableElement ));
                        }    
                        else
                        {
                            //
                            // editable -> non-editable transition.
                            //
                            spEditableElement = spCurElement;                        
#if DBG == 1                            
                            fSkipTableCheck = TRUE;
#endif                            
                        }
                        break;                                                    
                    }                     
                    else if ( eTag == TAGID_FRAMESET )
                    {
                        SP_IHTMLElement spFrameSet;
                        SP_IHTMLElement spFlow;
                        SP_IMarkupPointer spContent;
                        SP_IMarkupPointer2 spContent2;
                        SP_IMarkupContainer spContainer;
                        
                        hr = THR( GetFirstFrameElement( spCurElement , & spFrameSet ));
                        //
                        // we want to bail for S_FALSE
                        //
                        if ( hr )
                            goto Cleanup;                            
                            
#if DBG == 1
                        IFC( GetMarkupServices()->GetElementTagId( spFrameSet, & eTag ));
                        Assert( eTag == TAGID_FRAME );
#endif
                        IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spContent ));
                        IFC( spContent->QueryInterface( IID_IMarkupPointer2, (void**) & spContent2));                        
                        IFC( spContent2->MoveToContent( spFrameSet, TRUE ));
                        
                        hr = THR ( GetFirstFlowElement( spContent, & spEditableElement));
                        if ( hr == S_FALSE )
                        {
                            IFC( spContent->CurrentScope(& spEditableElement));
                        }
                            
                    }
                    else if (( fFlowLayout ||
                             ( eTag == TAGID_SELECT ) || 
                             ( _pEd->IsContentElement( spCurElement) == S_OK && fDrillingIn ) ))
                    {                            
                        spEditableElement = spCurElement;
                        break;
                    }    
                    if ( _pEd->IsContentElement(spCurElement) == S_OK && !fDrillingIn )
                    {
                        if ( GetLayoutElement( GetMarkupServices(), spCurElement, & spNextElement) == S_OK )
                            spCurElement = spNextElement;
                        else
                            break;
                    }
                    IFC( GetParentElement(GetMarkupServices(), spCurElement, & spNextElement)); 
                    if ( ! spNextElement.IsNull() )
                        spCurElement = spNextElement;
                    else 
                        break;                        
                }                    
                
                if ( spEditableElement.IsNull() )
                {
                    hr = THR( GetOutermostLayout( GetMarkupServices(), pIStartElement, & spEditableElement));
                    if ( FAILED(hr ) || hr == S_FALSE )
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }
                }                
            } // else IsNoScope()
        } // IsEditable                         
        else
        {
            //
            // We are here with the following conditions.
            //  - pIStartElement is NOT editable AND
            //  - we are drilling in OR we are NOT drilling in and our parent is not editable
            //
            // In either case, keep moving up until you hit the outermost editable element
            //
            BOOL fFoundEditableElement = IsContentEditable( pIStartElement) == S_OK && 
                                         EdUtil::IsEnabled( pIStartElement) == S_OK;

            spCurElement = (IHTMLElement*) pIStartElement;
            while ( ! spCurElement.IsNull() )
            {
                //
                // pIStartElement is never updated, and this should always be false
                // TODO: move this to be outside the loop. 
                //
                fEditable = IsContentEditable( pIStartElement) == S_OK && 
                            EdUtil::IsEnabled( pIStartElement) == S_OK;

                //
                // If the current element contains selection at browse time, or it is a 
                // viewlinked element, we need to stop walking
                //
                if ( fEditable  || 
                     ContainsSelectionAtBrowse( spCurElement ) == S_OK || 
                     _pEd->IsContentElement( spCurElement) == S_OK )
                {
                    spEditableElement = spCurElement;          
                    fFoundEditableElement = TRUE;

                    if ( ContainsSelectionAtBrowse( spCurElement ) == S_OK ||
                         _pEd->IsContentElement( spCurElement ) == S_OK )
                        break;
                }
                
                IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));

                //
                // Keep track of read-only inputs and textareas
                // 
                if ( !fHasReadOnly && !fFoundEditableElement &&
                     eTag == TAGID_INPUT || 
                     eTag == TAGID_TEXTAREA)
                {
                    VARIANT_BOOL fRet = VB_FALSE;
                    
                    if ( eTag == TAGID_INPUT )
                    {
                        IFC( spCurElement->QueryInterface( IID_IHTMLInputElement, (void**) & spInputElement));
                        IFC( spInputElement->get_readOnly( & fRet ));
                    }
                    else
                    {
                        IFC( spCurElement->QueryInterface( IID_IHTMLTextAreaElement, (void**) & spTextAreaElement));
                        IFC( spTextAreaElement->get_readOnly( & fRet ));
                    }
                    if ( fRet == VB_TRUE )
                    {
                        fHasReadOnly = TRUE;
                        spLastReadOnly = spCurElement ;
                    }
                }
                if ( fFoundEditableElement && ( ! fEditable ) )
                {
                    break;
                }
                IFC( GetParentElement(GetMarkupServices(), spCurElement, & spNextElement ));
                if ( spNextElement )
                    spCurElement = spNextElement;
                else
                    break;
            }
            
            if ( ! fFoundEditableElement )
            {
                //
                // There is no Edtiable element. Look for a ReadOnly Element.
                //
                if ( fHasReadOnly )
                {
                    spEditableElement = spLastReadOnly;
                }               
                else      
                {                     
                    //
                    // We're in browse mode, there is nothing editable.
                    // assume this is a selection in the body. Make the context the body.
                    //
                    hr = THR( GetOutermostLayout( GetMarkupServices(), pIStartElement, & spEditableElement ) );                    
                    if ( hr == S_FALSE || spEditableElement.IsNull() )
                    {
                        IFC( GetEditor()->GetBody( & spEditableElement ));                        
                    }
                    else if ( FAILED( hr ))
                    {
                        goto Cleanup;
                    }
                }                    
            }    
        }
    }

#if DBG ==1 
    IGNORE_HR( GetMarkupServices()->GetElementTagId( spEditableElement, & eTag ));
    AssertSz( eTag != TAGID_TABLE, "Found Editable element to be table");
    AssertSz( ! IsTablePart( eTag) || fSkipTableCheck , "Found editable element to be part of a table");
    Assert( ! spEditableElement.IsNull() );
    Assert( IsLayout( spEditableElement) == S_OK );
#endif

    if ( ppEditThisElement )
    {
        *ppEditThisElement = spEditableElement;
        (*ppEditThisElement)->AddRef();
    }

Cleanup:
    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::IsInEditContext( IHTMLElement* pIElement )
{
    HRESULT hr;
    BOOL fInside = FALSE;
    
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    
    IFC( GetEditor()->CreateMarkupPointer( & spStart )); 

    IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( IsInEditContext( spStart , & fInside, TRUE )); // only compare ptrs in same markup

    if ( fInside )
    {
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        IFC( IsInEditContext( spEnd , & fInside, TRUE )); // only compare ptrs in same markup
    }
    
Cleanup:
    hr = fInside ? S_OK : S_FALSE; 
    
    RRETURN1( hr, S_FALSE );
}


HRESULT
CSelectionManager::CheckCurrencyInIframe( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IObjectIdentity spIdent;
    
    IFC( pIElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

    if ( _pIEditableElement &&
         ( spIdent->IsEqualObject( GetEditableElement() ) == S_OK ||
           IsElementContentSameAsContext( pIElement) == S_OK ||    
           IsInEditContext( pIElement ) == S_OK ) )
    {
        hr = S_OK;
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );        
}

HRESULT
CSelectionManager::EnsureEditContextClick( IHTMLElement* pIElementClick, CEditEvent* pEvent, BOOL* pfChangedCurrency)
{
    HRESULT hr = S_OK ;
    Assert( pIElementClick );
    SP_IHTMLElement spCurElement = (IHTMLElement*) pIElementClick;
    SP_IHTMLElement spLayoutElement;
    SP_IHTMLElement spActiveElement;
    SP_IObjectIdentity spIdent, spIdent2;
    SP_IHTMLElement spElementThatShouldBeCurrent;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

#ifdef FORMSMODE
    if (!spCurElement.IsNull())
    {
        IFC (SetSelectionMode(spCurElement));
    }
#endif

    Assert( pIElementClick );
    if (! pIElementClick )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if ( pfChangedCurrency )
    {
        *pfChangedCurrency = FALSE;
    }

    IGNORE_HR( GetDoc()->get_activeElement( & spActiveElement ));                        
    if ( spActiveElement )
    {
        IFC( spActiveElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        IFC( GetMarkupServices()->GetElementTagId( spActiveElement, & eTag ));
    }

    IFC( GetEditableElement()->QueryInterface( IID_IObjectIdentity, (void**) & spIdent2 ));
    
    //
    // marka - in design mode, we change the currency behavior to make the parent
    // of a 'site selectable' object active.
    //
    //
    if ( !spCurElement.IsNull() &&
         EdUtil::IsParentEditable( GetMarkupServices(), spCurElement) == S_OK )
    { 
        IFC( GetLayoutElement( GetMarkupServices(), spCurElement, & spLayoutElement ));
        if ( ! spLayoutElement )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        //
        // We only do the change of currency - if a change of currency is implied.
        //
        // Hence clicking on a UI Active Div - will not change currency ( as the div is already current )
        // also clicking on any SiteSelected elmenet - will not change currency.
        // this is handled by mshtmled.dll directly
        // 
       
        BOOL fSiteSelected = IsElementSiteSelected(spLayoutElement) == S_OK ;
        
        BOOL fSiteSelectable = _pEd->IsElementSiteSelectable( spLayoutElement ) == S_OK &&
                                EdUtil::IsParentEditable( GetMarkupServices(), spLayoutElement) == S_OK ;

        if ( ( spIdent && 
               spIdent->IsEqualObject( spLayoutElement) == S_FALSE &&   // the thing we clicked on isn't the layout that's current & it's not site selected
              ! fSiteSelected ) 
              ||
             ( spIdent2 && 
               spIdent2->IsEqualObject( spLayoutElement) == S_FALSE &&   // the thing we clicked on isn't the layout that's current & it's not site selected
              ! fSiteSelected )               

            ||

            ( fSiteSelectable  &&         /* the thing we clicked on is site selectable, but it isn't site selected */
             ! fSiteSelected &&
             ! ( HasFocusAdorner() && IsElementContentSameAsContext( spLayoutElement) == S_OK  ) )
             
            ||
            
            // Special case table parts (bug 101670)
            ( eTag == TAGID_TABLE || IsTablePart( eTag) ) )
        {                               
            IFC( GetEditContext( 
                        spCurElement , 
                        & spElementThatShouldBeCurrent,
                        NULL,
                        NULL,
                        FALSE )); 

        }

        if ( ! spElementThatShouldBeCurrent.IsNull() )
        {
            //
            // Look to see if we would extend a multiple selection here. If we would
            // then don't do any currency change.
            //
            
            if ( ( ( pEvent && ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) && 
                   fSiteSelectable )
                  ||      
                   fSiteSelected
                 )                 
                && GetCommandTarget()->IsMultipleSelection() 
                && CheckAnyElementsSiteSelected() )
                    goto Cleanup ;
                
            if ( (spIdent &&
                  spIdent->IsEqualObject( spElementThatShouldBeCurrent) == S_FALSE ) 
                 ||
                  ( spIdent2 && 
                    spIdent2->IsEqualObject( spLayoutElement) == S_FALSE ))
            {
                IFC( BecomeCurrent( GetDoc(), spElementThatShouldBeCurrent ));
                if ( pfChangedCurrency ) 
                    *pfChangedCurrency = TRUE;
            }            
            IFC( SetEditContextFromElement( spElementThatShouldBeCurrent, TRUE  ));                                        
        }
    }
    else
    {
        BOOL fParentEditable;
        BOOL fEditable;
        
        //
        // This is for "browse mode" setting of the edit context.
        //
        IFC( GetEditContext( 
                    spCurElement , 
                    & spElementThatShouldBeCurrent,
                    NULL,
                    NULL,
                    TRUE )); 

        fEditable = (EdUtil::IsEditable( spElementThatShouldBeCurrent ) == S_OK);
        fParentEditable = (EdUtil::IsParentEditable( GetMarkupServices(), spElementThatShouldBeCurrent ) == S_OK);
        
        if( !fEditable && fParentEditable && spIdent &&
            spIdent->IsEqualObject( spElementThatShouldBeCurrent) == S_FALSE )
        {
            IFC( BecomeCurrent( GetDoc(), spElementThatShouldBeCurrent ));
            if ( pfChangedCurrency ) 
                *pfChangedCurrency = TRUE;
        }

        IFC( SetEditContextFromElement( spElementThatShouldBeCurrent ));  

        //
        // Listen to active element property change - so if the current eleemnt
        // becomes editable - we do the right thing - and reset our edit context.
        // 
        if ( spElementThatShouldBeCurrent )
        {
            if ( _pIActiveElement )
            {
                IFC( DetachActiveElementHandler());
            }
            IFC( AttachActiveElementHandler( spElementThatShouldBeCurrent ));        
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::AttachDragListener(IHTMLElement* pIElement)
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( ! _pIDragListener );

    ReplaceInterface( & _pIDragListener , pIElement );
    
    IFC( _pDragListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIDragListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("ondragend"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );
   
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::DetachDragListener()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIDragListener );
    
    IFC( _pDragListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIDragListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("ondragend"), spDisp ));
    
    ClearInterface( & _pIDragListener );

Cleanup:
    RRETURN( hr );

}

HRESULT 
CSelectionManager::AttachActiveElementHandler(IHTMLElement* pIElement )
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;
    
    Assert( ! _pIActiveElement );

    ReplaceInterface( & _pIActiveElement , pIElement );
    
    IFC( _pActElemHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIActiveElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachActiveElementHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIActiveElement );
    
    IFC( _pActElemHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIActiveElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));
    
    ClearInterface( & _pIActiveElement );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CSelectionManager::AttachEditContextHandler()
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( GetEditableElement());
    Assert( ! _pIBlurElement );

    ReplaceInterface( & _pIBlurElement, GetEditableElement() );
    
    IFC( _pEditContextBlurHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIBlurElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    //IFC( spElement2->attachEvent(_T("onblur"), spDisp, & varAttach));
    //Assert( varAttach == VB_TRUE );

    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachEditContextHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIBlurElement );
    
    IFC( _pEditContextBlurHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pIBlurElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    //IFC( spElement2->detachEvent(_T("onblur"), spDisp ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));

    ClearInterface( & _pIBlurElement );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CActiveElementHandler::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor());
                IFC( evt.Init(  spObj , dispidMember));
                Assert( evt.GetType() == EVT_PROPERTYCHANGE );
                if( evt.GetType() == EVT_PROPERTYCHANGE )
                {
                    IFC( _pMan->OnPropertyChange( & evt ));
                }                    
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CEditContextHandler::Invoke(
                        DISPID dispidMember,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo,
                        UINT * puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            if(!pdispparams->rgvarg[0].pdispVal)
                RRETURN(hr);
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CHTMLEditEvent evt( _pMan->GetEditor());
                IFC( evt.Init(  spObj , dispidMember));

                switch( evt.GetType())
                {
                    case EVT_PROPERTYCHANGE:
                        IFC( _pMan->OnPropertyChange( & evt ));
                        break;
                    default:
                        AssertSz(0,"Unexpected event");
                        break;
                }                    
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::IsInsideElement( IHTMLElement* pIElement, IHTMLElement* pIElementOutside )
{
    HRESULT hr = S_FALSE;
    SP_IMarkupPointer spPointer1, spPointer2;
    SP_IMarkupPointer spPointerOutside1, spPointerOutside2;

    if (pIElement && pIElementOutside)
    {
        IFC( GetEditor()->CreateMarkupPointer( & spPointer1 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointer2 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointerOutside1 ));
        IFC( GetEditor()->CreateMarkupPointer( & spPointerOutside2 ));

        IFC( spPointer1->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spPointer2->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        IFC( spPointerOutside1->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
        IFC( spPointerOutside2->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ));

        hr = Between ( spPointer1, spPointerOutside1, spPointerOutside2 ) &&
             Between ( spPointer2, spPointerOutside1, spPointerOutside2 ) ?  S_OK : S_FALSE; 
    }

Cleanup:
    RRETURN1(hr, S_FALSE );
}

//
//
// We've recieved a currency change from Trident. Time to call our workhorse SetEditContext.
//
//

HRESULT
CSelectionManager::SetEditContextFromCurrencyChange( IHTMLElement* pIElement, DWORD dword, IHTMLEventObj* pIEventObj  )
{
    HRESULT        hr ;
    ELEMENT_TAG_ID eTag;
    SP_IHTMLElement spActive;
    SP_IHTMLElement spClippedElement;
    SP_IHTMLElement spParentElement;
    
    Assert( pIElement );
    
    WHEN_DBG(_ctSetEditContextCurChg++);

    //
    // Fire OnBeforeDeactivate to Designer Event Pump...
    //
    hr = THR(GetEditor()->DesignerPreHandleEvent( DISPID_EVMETH_ONBEFOREDEACTIVATE, pIEventObj ));
    if ( hr == S_OK )
    {
        //
        // S_OK means designer wants to consume event. 
        // we need to return S_FALSE so CDoc::SetCurrentElement gets' expected value back.
        // indicating that we don't want the currency change to occur
        //
        hr = S_FALSE;
        goto Cleanup;
    }
    else if ( FAILED(hr ))
        goto Cleanup;
        
        
    // Edit team's hack for TABLE && TD
    IGNORE_HR( GetActiveElement( GetEditor(), pIElement, & spActive , 
                            CheckCurrencyInIframe( pIElement) == S_OK ));
                            
    if (( dword == 1 || dword == 2 || dword == 4 ) && spActive )
    {
        IFC( ClipToElement( GetEditor(), spActive, pIElement, & spClippedElement ));
    }
    else
        spClippedElement = pIElement;
        
    IFC( GetMarkupServices()->GetElementTagId( spClippedElement, & eTag ));
    IFC( spClippedElement->get_parentElement( & spParentElement ));
    
    if ((eTag == TAGID_TABLE || IsTablePart( eTag)) &&
         IsEditable( spClippedElement) == S_OK &&
         IsEditable( spParentElement ) == S_OK )
    {
#ifndef _PREFIX_
        Assert( _ctSetEditContextCurChg == 1 ); // coming in here twice would be bad.
#endif
        
        SP_IHTMLElement spMakeMeCurrent;
        
        IFC( GetEditContext( spClippedElement,
                            &spMakeMeCurrent,
                             NULL,
                             NULL,
                             TRUE ));
#if DBG == 1
        SP_IObjectIdentity spIdent;
        IFC( spClippedElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        Assert( spIdent->IsEqualObject( spMakeMeCurrent ) == S_FALSE );
        IFC( GetMarkupServices()->GetElementTagId( spMakeMeCurrent, & eTag ));
#endif
        // We want the body to become current, and we want to fail the
        // table trying to become current.       
        IFC( BecomeCurrent( GetDoc(), spMakeMeCurrent ));

        hr = S_FALSE; // disallow the attempted change in currency
    }
    else 
    {       
        SP_IHTMLElement spSiteSelectable;
        BOOL fSiteSelectable;
        BOOL fParentEditable;
        
        fSiteSelectable = _pControlTracker->GetSiteSelectableElementFromElement( spClippedElement, & spSiteSelectable) == S_OK ;        
        fParentEditable = fSiteSelectable ? 
                            EdUtil::IsParentEditable( GetMarkupServices(), spSiteSelectable ) == S_OK  :
                            FALSE; 
        
        if ( ( dword == 1 || dword == 2 ) &&                     
             ( fSiteSelectable && fParentEditable ) )
        {             
            //
            // We don't want any currency changes happening as a result of clicking.
            // we handle doing the right thing in EnsureEditContextClick
            // 
            hr = S_FALSE;
            goto Cleanup;
        }
        

        //
        // Do we have to update our editing UI ? 
        //
        if ( _fDrillIn || 
            IsEditable( spClippedElement) == S_OK ||
            ( fSiteSelectable && fParentEditable ) ||
            ( GetTrackerType() == TRACKER_TYPE_Control && 
              IsInsideElement( spClippedElement, _pControlTracker->GetPrimaryElement()) == S_OK ) ||
            ( IsAtBoundaryOfViewLink( spClippedElement) == S_OK ) 
           )
        {           
            CSelectionChangeCounter selCounter(this);
            selCounter.BeginSelectionChange();
            IFC( SetEditContextFromElement( spClippedElement ));

            //
            // NOTE: We don't fire this event for mouseevents
            // as we assume that the event will come to us on HandleEvent
            // if the element consumes it - then this won't happen.
            // 
            // this seems ok as it makes the event fire almost entirely consistently.
            //
            selCounter.EndSelectionChange( dword != 1 && dword != 2  );
        }
        else
        {
            if ( _pIActiveElement )
            {
                IFC( DetachActiveElementHandler());
            }
            IFC( AttachActiveElementHandler( spClippedElement ));
        }
    }   
    
    
Cleanup:
    WHEN_DBG( _ctSetEditContextCurChg-- );
    
    RRETURN1( hr, S_FALSE );
}

        

HRESULT
CSelectionManager::SetEditContextFromElement( IHTMLElement* pIElement , BOOL fFromClick /*=FALSE*/)
{
    HRESULT hr = S_OK ;
    BOOL    fEditable, fParentEditable, fNoScope ;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IHTMLElement   spParent;
    ELEMENT_TAG_ID  eTag;

    IFC( GetEditor()->CreateMarkupPointer( & spStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    //
    // Iframe or viewlink in edit mode check.
    //
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK )
    {
        SP_IHTMLElement spMaster;
        IFC( GetEditor()->GetMasterElement( pIElement, & spMaster ));
        IFC( GetEditor()->GetParentElement( spMaster, & spParent ));
    }
    else
    {
        IFC( GetEditor()->GetParentElement(pIElement, &spParent) );
    }
    
    fEditable = IsEditable( pIElement ) == S_OK ;

    if ( spParent )
    {
        fParentEditable = IsEditable( spParent ) == S_OK ;
    }
    else
        fParentEditable = fEditable;
    
    // 
    // 'No-scopeness' for SelMan - refers to whether we have pointers outside
    // the edit context element or not.
    // For Master Elements - we position the pointers in the content
    // so setting no-scopeness here is invalid
    //
    // NOTE: - we could eliminate this hokiness by passing an IHTMLElement* to SetEditContext
    // it would constrain us to being element based however. 
    //
    IFC( GetMarkupServices()->GetElementTagId( pIElement, &eTag ) );
    
    fNoScope = IsNoScopeElement( pIElement, eTag ) == S_OK && 
       _pEd->IsMasterElement( pIElement) == S_FALSE ;

    if ( _pEd->IsMasterElement( pIElement ) == S_OK )
    {        
        IFC( PositionPointersInMaster( pIElement, spStart, spEnd ));        
        //
        // for viewlinks - we derive our editability by the editability of the element
        // inside the content.
        // 
        SP_IHTMLElement spElementGetEditability;
        IFC( spStart->CurrentScope( & spElementGetEditability));
        
        if ( _pEd->IsMasterElement(spElementGetEditability) == S_OK )
        {
            //
            // We found the master from current scope. What we do is we grovel around the sub-document
            // and find an element to derive editability from
            //

            DWORD dwBreak;
            SP_IHTMLElement spScanElement;
            
            ED_PTR( edRightLooker );
            IFC( edRightLooker.MoveToPointer( spStart ));
            IFC( edRightLooker.SetBoundary( spStart, spEnd ));
            IFC( edRightLooker.Scan( RIGHT, 
                                     BREAK_CONDITION_ANYTHING - 
                                     BREAK_CONDITION_NoScope - 
                                     BREAK_CONDITION_NoScopeBlock - 
                                     BREAK_CONDITION_NoScopeSite, 
                                     & dwBreak, 
                                     & spScanElement ));

            IFC( edRightLooker.CurrentScope( & spElementGetEditability ));

        }
        
        if ( spElementGetEditability )
        {        
            fEditable = IsEditable( spElementGetEditability ) == S_OK ;       
        }            
    }
    else if ( fNoScope )
    {
        IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd));
    }
    else
    {
        IFC( spStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
        IFC( spEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ));
    }

    IFC( SetEditContext(  
                        fEditable,
                        fParentEditable,
                        spStart,
                        spEnd ,
                        fNoScope,
                        fFromClick ));
                        
Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::EnsureEditContext( IMarkupPointer* pPointer )
{
    HRESULT            hr = S_OK;
    SP_IHTMLElement    spElement;
    SP_IDisplayPointer spDisp;

    IFC( pPointer->CurrentScope( & spElement));
    if ( spElement.IsNull() )
    {
        IFC( GetDisplayServices()->CreateDisplayPointer( & spDisp ) );
        IFC( spDisp->MoveToMarkupPointer( pPointer, NULL ));
        IFC( spDisp->GetFlowElement( & spElement ));
    }
    
    if ( ! spElement.IsNull() )
    {
        hr = THR( EnsureEditContext( spElement, TRUE ));
    }
    else
    {
        AssertSz(0, "Unable to find an element");
        hr = E_FAIL;
    }        
    
Cleanup:
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::DoPendingTasks()
{   
    HRESULT hr = S_OK;
    
    if ( _pIElementExitStart )
    {
        IFC( DoPendingElementExit());
        if ( hr == S_FALSE )
            hr = S_OK; // don't bubble this back hr = S_FALSE, means a change in currency did not occur
        Assert( ! _pIElementExitStart || _fInPendingElementExit );

        
        
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EnsureEditContext( IHTMLElement* pIElement, BOOL fDrillIn )
{
    HRESULT            hr = S_OK;
    SP_IHTMLElement    spEditContextElement; 
    SP_IHTMLElement    spMaster;
    BOOL               fIsContent = FALSE ;

    IFC( DoPendingTasks());
    
    IFC( GetEditContext( pIElement,
                    & spEditContextElement,
                    NULL,
                    NULL,
                    fDrillIn ));

    if ( ! spEditContextElement ) 
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    
    if( _pEd->IsContentElement( spEditContextElement ) == S_OK )
    {
        fIsContent = TRUE;
        IFC( _pEd->GetMasterElement( spEditContextElement, & spMaster ));
    }
    
    //
    // _pElemEditContext should always be in sync with _pElemCurrent
    // however there are some cases where _pElemCurrent gets set to the root and testing 
    // for pEditContextEleemnt == _pElemEditContext is not sufficient
    //
    if ( ! fIsContent )
    {
        hr = THR( BecomeCurrent( GetDoc(), spEditContextElement ));
    }
    else
    {
        hr = THR( BecomeCurrent( GetDoc(), spMaster ));
    }
    
    if (FAILED(hr ) || ( hr == S_FALSE ))
    {
        goto Cleanup ;
    }
    
    //
    // The Edit Context is not Editable, and calling becomeCurrent is NOT sufficient to set
    // the EditContext. This is valid if we were called in browse mode.
    // We call SetEditContext directly
    //
    hr = THR( SetEditContextFromElement( spEditContextElement ));
    
    //
    // There are cases where become current may fail. A common one is 
    // from forced currency changes (via script) - during a focus change
    // change in currency.
    // 
    // During focus changes - we set the ELEMENTLOCK_FOCUS flag. Any forced 
    // currency changes via calls to become current - will fail - until
    // the end of the focus change has occurred.
    //
    // A common example of this is the Find Dialog's use of the select method
    // during a focus change. This is all fine - but will cause the assert below to fire
    // - so I've added the ElementLockFocus check
    //

Cleanup:
    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CSelectionManager::EnsureEditContext( ISegmentList* pSegmentList )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spTemp;
    SP_IMarkupPointer       spTemp2;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    IFC( GetEditor()->CreateMarkupPointer( & spTemp ));
    IFC( GetEditor()->CreateMarkupPointer( & spTemp2 ));

    IFC( pSegmentList->CreateIterator(& spIter) );

    // Try and retrieve the first element, will fail if there
    // is none
    IFC( spIter->Current(&spSegment) );

    IFC( spSegment->GetPointers( spTemp, spTemp2 ) );

    hr = THR( EnsureEditContext( spTemp ));

Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::SetInitialEditContext()
{
    HRESULT         hr ;
    SP_IHTMLElement spActive;
    
    IGNORE_HR( GetDoc()->get_activeElement( & spActive )); // blindly ignore HR here. if hosted by vid - we return E_FAIL for root being current !!!!   
    if ( spActive.IsNull() )
    {
        hr = THR( GetEditor()->GetBody( & spActive ));
        if ( FAILED( hr ) && spActive )
        {
            // some other failure. we bail
            goto Cleanup;
        }   
    }

    if ( ! spActive )
    {
        //
        // No body ? Doc probably isn't parsed as yet. we return s-ok - and assume 
        // edit context will be set somewhere later.
        //
        hr = S_OK;
        goto Cleanup; 
    }

    if ( ! spActive.IsNull() )
    {
        IFC( SetEditContextFromElement( spActive ));
    }
    else
    {
        AssertSz(0,"Unable to get an active element");            
        hr = E_FAIL;
    }    

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::UpdateEditContextFromElement(IHTMLElement* pIElement,
        IMarkupPointer* pIStartPointer /* =NULL */,
        IMarkupPointer* pIEndPointer /* =NULL */,
        BOOL* pfEditContextWasUpdated /* =NULL */)
{
    HRESULT hr;
    SP_IMarkupPointer   spStartPointer = pIStartPointer;
    SP_IMarkupPointer   spEndPointer = pIEndPointer;

    int iWhereStartPointer, iWhereEndPointer;

    if (pfEditContextWasUpdated)
        *pfEditContextWasUpdated = FALSE;
    
    //  If we are not given a start markup pointer, create one before our element.
    if (spStartPointer == NULL)
    {
        IFC( _pEd->CreateMarkupPointer( & spStartPointer ));
        IFC( spStartPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    }

    //  If we are not given an end markup pointer, create one after our element.
    if (spEndPointer == NULL)
    {
        IFC( _pEd->CreateMarkupPointer( & spEndPointer ));
        IFC( spEndPointer->MoveAdjacentToElement( pIElement,  ELEM_ADJ_BeforeEnd ));
    }
    
    //  Determine if our atomic parent element is outside of the edit context.
    IGNORE_HR( OldCompare( _pStartContext, spStartPointer, & iWhereStartPointer));                       
    IGNORE_HR( OldCompare( _pEndContext, spEndPointer, & iWhereEndPointer));                       

    //  If the given element is outside of the edit context, we need to change
    //  the edit context to be the given element.
    if (iWhereStartPointer > 0 || iWhereEndPointer < 0)
    {
        SetDontChangeTrackers(TRUE);
        IFC( SetEditContextFromElement(pIElement) );
        SetDontChangeTrackers(FALSE);

        if (pfEditContextWasUpdated)
            *pfEditContextWasUpdated = TRUE;
    }
    
    hr = S_OK;
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::IsEqualEditContext( IHTMLElement* pIElement )
{
    HRESULT  hr ;
    SP_IObjectIdentity spIdent;

    if ( _pEd->IsContentElement(GetEditableElement()) == S_OK )
    {
        SP_IHTMLElement spMaster;
        IFC( _pEd->GetMasterElement( GetEditableElement(), & spMaster ));
        IFC( spMaster->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));        
    }
    else
    {
        IFC( GetEditableElement()->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
    }
    
    hr = spIdent->IsEqualObject( pIElement );
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT
CSelectionManager::OnPropertyChange( CEditEvent* pEvt )
{
    HRESULT hr ;
    BSTR    bstrPropChange = NULL ;

    IFC( DYNCAST( CHTMLEditEvent, pEvt)->GetPropertyChange( & bstrPropChange ));
    if ( !StrCmpICW (bstrPropChange, L"contentEditable")
        || !StrCmpICW( bstrPropChange, L"style.visibility")
#ifdef FORMSMODE
        || !StrCmpICW (bstrPropChange, L"selectionMode")
#endif
       )
    {
        SP_IHTMLElement    spElement;
        SP_IHTMLElement    spParentElement;
        SP_IObjectIdentity spIdent;
        SP_IObjectIdentity spIdentParent;

        IFC( pEvt->GetElement( & spElement ));
        IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

        if( !StrCmpICW( bstrPropChange, L"style.visibility" ) )
        {
            if( IsElementVisible( spElement ) )
            {
                IFC( SetEditContextFromElement( spElement ) );
            }
            else
            {
                IFC( GetEditor()->GetParentElement( spElement, &spParentElement ) );

                if( spParentElement )
                {
                    IFC( SetEditContextFromElement( spParentElement ) );
                }
            }
        }
        else if( _pIEditableElement && spIdent->IsEqualObject( GetEditableElement()) == S_OK )
        {
            IFC( SetEditContextFromElement( spElement ));
        }
        else
        {
            //
            // Also listen to changes on the parent element.
            //
            IFC( GetEditor()->GetParentElement(spElement, & spParentElement ));
            IFC( spParentElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdentParent));

            if ( spIdentParent->IsEqualObject( GetEditableElement()) == S_OK )
            {
                IFC( SetEditContextFromElement( spElement ));
            }
            else if ( !StrCmpICW (bstrPropChange, L"contentEditable"))
            {
                //
                // the editability of the active element may have become true.
                // If so - we need to set our edit context to match that of the active element
                //
                
                SP_IHTMLElement spActiveElement;
                
                IFC( GetDoc()->get_activeElement( & spActiveElement ));
                if ( spIdent->IsEqualObject( spActiveElement ) == S_OK &&
                     IsEditable( spActiveElement) == S_OK )
                {
                    IFC( SetEditContextFromElement( spElement ));                   
                }
            }
        }
       
    }
    
Cleanup:
    if (bstrPropChange)
        ::SysFreeString( bstrPropChange);
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: OnLayoutChange
//
// Synopsis: A 'layout' change has occurred ( eg. we removed the layout on something that was site-seelcted)
//           Tell the trackers to fix themselves.
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::OnLayoutChange()
{
    Assert( _pActiveTracker);
    RRETURN( _pActiveTracker->OnLayoutChange());
}

HRESULT
CSelectionManager::GetFirstFrameElement( IHTMLElement* pIStartElement, IHTMLElement** ppIElement)
{
    HRESULT hr ;
    ED_PTR( edScanFrame );
    SP_IMarkupPointer spBoundaryStart;
    SP_IMarkupPointer spBoundaryEnd;
    SP_IHTMLElement   spFrameElement;
    DWORD             dwFound;
    ELEMENT_TAG_ID    eTag;
    
    Assert( pIStartElement && ppIElement );
    IFC( edScanFrame.MoveAdjacentToElement( pIStartElement, ELEM_ADJ_AfterBegin ));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryEnd ));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryStart ));

    IFC( spBoundaryStart->MoveAdjacentToElement( pIStartElement, ELEM_ADJ_AfterBegin ));
    IFC( spBoundaryEnd->MoveAdjacentToElement( pIStartElement, ELEM_ADJ_BeforeEnd ));
    
    IFC( edScanFrame.SetBoundary( spBoundaryStart, spBoundaryEnd  ));

    IFC( edScanFrame.Scan(
                            RIGHT ,
                            BREAK_CONDITION_Site,
                            & dwFound,
                            & spFrameElement ));

    if ( edScanFrame.CheckFlag( dwFound, BREAK_CONDITION_Site ))
    {
        IFC( GetMarkupServices()->GetElementTagId( spFrameElement, & eTag ));
        
        if ( eTag == TAGID_FRAME )
        {
            *ppIElement = (IHTMLElement*) spFrameElement;
            (*ppIElement)->AddRef();
        }
        else
            hr = S_FALSE;
    }
    else
        hr = S_FALSE;
Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
CSelectionManager::GetFirstFlowElement( IMarkupPointer* pStart, IHTMLElement** ppIElement)
{
    HRESULT hr;
    ED_PTR( edScanFrame );
    SP_IHTMLElement     spFrameElement;
    SP_IMarkupContainer spContainer;
    SP_IMarkupPointer   spBoundaryEnd;
    DWORD               dwFound;
    
    Assert( pStart && ppIElement );
    IFC( edScanFrame.MoveToPointer( pStart ));

    IFC( pStart->GetContainer( & spContainer));
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spBoundaryEnd ));
    IFC( spBoundaryEnd->MoveToContainer( spContainer, FALSE ));
    
    IFC( edScanFrame.SetBoundary( pStart, spBoundaryEnd  ));

    IFC( edScanFrame.Scan(
                            RIGHT ,
                            BREAK_CONDITION_EnterTextSite ,
                            & dwFound,
                            & spFrameElement ));

    if ( edScanFrame.CheckFlag( dwFound, BREAK_CONDITION_EnterTextSite ))
    {
        *ppIElement = (IHTMLElement*) spFrameElement;
        (*ppIElement)->AddRef();
    }
    else
        hr = S_FALSE;
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT 
CSelectionManager::PositionCaretAtPoint(POINT ptGlobal)
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer spDispPointer ;
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToPoint(ptGlobal, COORD_SYSTEM_GLOBAL, NULL, 0, NULL));
    IFC (PositionCaret( spDispPointer));
    
Cleanup :
    RRETURN (hr);
}

HRESULT
CSelectionManager::BeginSelectionUndo()
{
    CSelectionUndo undoSel( DYNCAST( CEditorDoc , GetEditor() )); 
    
    return S_OK;
}

HRESULT
CSelectionManager::EndSelectionUndo()
{
    CDeferredSelectionUndo DeferredUndo( DYNCAST( CEditorDoc, GetEditor() ));   
    
    return S_OK;
}

HRESULT
CSelectionManager::OnSelectedElementExit(                                             
                                            IMarkupPointer* pIStart, 
                                            IMarkupPointer * pIEnd,
                                            IMarkupPointer* pIContentStart,
                                            IMarkupPointer* pIContentEnd
                                            )
{
    Assert( _pActiveTracker );

    return ( _pActiveTracker->OnExitTree(  pIStart, pIEnd, pIContentStart, pIContentEnd  ));
}

HRESULT
CSelectionManager::OnChangeType( SELECTION_TYPE eType , ISelectionServicesListener * pIListener )
{
    HRESULT hr = S_OK;

    if ( ! _pActiveTracker ) // possible to call this on shutdown.
        return S_OK;

    SP_IUnknown spUnk;
    
    if ( pIListener )
    {
        IFC( pIListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
        
        //
        //
        // we assume that if we're being changed - then we don't have to do anything
        // as the type change is handled by the existing selection tracker update mechanism
        //
        if( (IUnknown*) spUnk != (IUnknown*) this )
        {
            EnsureDefaultTrackerPassive();
        }
    }
    
Cleanup:
    RRETURN( hr );    
}

HRESULT
CSelectionManager::GetTypeDetail( BSTR* p)
{
    *p = SysAllocString(_T("undefined"));
    return S_OK;
}

//+---------------------------------------------------------------------
//
// Method: MshtmledOwnsSelectionServices
//
// Synopsis: Do we own the things in selection services ? If not it's 
//           considered bad to do things like change trackers etc.
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::WeOwnSelectionServices()
{
    HRESULT hr;
    SP_IUnknown spUnk;
    SP_ISelectionServicesListener spListener;
    
    IFC( GetSelectionServices()->GetSelectionServicesListener( & spListener ));
    if ( spListener )
    {
        IFC( spListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
       
        hr = (IUnknown*) spUnk == (IUnknown*) this  ? S_OK : S_FALSE ;
    }
    else
        hr = E_FAIL ;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

BOOL
CSelectionManager::CheckAnyElementsSiteSelected()
{
    if ( GetTrackerType() == TRACKER_TYPE_Control )
    {
        CControlTracker* pControlTracker = DYNCAST( CControlTracker, _pActiveTracker );
        if (pControlTracker)
        {
            if (pControlTracker->NumberOfSelectedItems() > 0)
                return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CSelectionManager::GetSiteSelectableElementFromElement( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    RRETURN1( _pControlTracker->GetSiteSelectableElementFromElement( pIElement, ppIElement), S_FALSE ) ;
}

HRESULT
CSelectionManager::EnableModeless( BOOL fEnable )
{
    HRESULT hr;
    
    hr = THR( _pActiveTracker->EnableModeless( fEnable ));

    RRETURN( hr );
}

HRESULT
CSelectionManager::CheckUnselectable(IHTMLElement* pIElement)
{
    HRESULT hr;
    BSTR    bstrUnselectable = SysAllocString(_T("unselectable"));
    BSTR    bstrOn = SysAllocString(_T("on"));
    BOOL fUnselectable;

    IFC( CheckAttribute( pIElement, & fUnselectable, bstrUnselectable, bstrOn ));

    hr = fUnselectable ? S_OK : S_FALSE;
    
Cleanup:
    SysFreeString( bstrUnselectable );
    SysFreeString( bstrOn );

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::MoveToSelectionAnchor (
            IMarkupPointer * pIAnchor )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }

    Assert( _pActiveTracker == _pSelectTracker );
    
    RRETURN( _pSelectTracker->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CSelectionManager::MoveToSelectionEnd (
            IMarkupPointer* pISelectionEnd )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }
    Assert( _pActiveTracker == _pSelectTracker );

    RRETURN( _pSelectTracker->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CSelectionManager::MoveToSelectionAnchor (
            IDisplayPointer * pIAnchor )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }

    Assert( _pActiveTracker == _pSelectTracker );
    
    RRETURN( _pSelectTracker->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CSelectionManager::MoveToSelectionEnd (
            IDisplayPointer* pISelectionEnd )
{
    if ( GetTrackerType() != TRACKER_TYPE_Selection )
    {
        return E_FAIL;
    }
    Assert( _pActiveTracker == _pSelectTracker );

    RRETURN( _pSelectTracker->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CSelectionManager::IsEditContextUIActive()
{
    HRESULT hr;
    
    hr = ( HasFocusAdorner() && _pAdorner->IsEditable()  ) ? S_OK : S_FALSE;

    RRETURN1( hr, S_FALSE ) ;
}    

//
//
// Is this element at the boundary of the view link ? 
//
//
HRESULT
CSelectionManager::IsAtBoundaryOfViewLink( IHTMLElement* pIElement )
{
    HRESULT hr;

    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer2 spContainer2;
    SP_IHTMLElement spMaster;
    SP_IMarkupPointer spElem;
    SP_IMarkupPointer spInsideMasterStart;
    SP_IMarkupPointer spInsideMasterEnd ;
    BOOL fEqual;
    ELEMENT_TAG_ID eTag;

    Assert( pIElement );
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    if ( eTag == TAGID_INPUT )
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    IFC( GetEditor()->CreateMarkupPointer( & spElem ));
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMasterStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMasterEnd ));

    IFC( spElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    IFC( spElem->GetContainer( & spContainer ));
    IFC( spContainer->QueryInterface( IID_IMarkupContainer2, (void**) & spContainer2 ));

    IFC( spContainer2->GetMasterElement( & spMaster ));
    if ( spMaster )
    {
        IFC( PositionPointersInMaster( spMaster, spInsideMasterStart, spInsideMasterEnd ));
        IFC( spInsideMasterStart->IsEqualTo( spElem, & fEqual ));
        
        hr = fEqual ? S_OK : S_FALSE;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::RequestRemoveAdorner( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spEditElement;
    ELEMENT_TAG_ID eTag;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));    
    IFC( GetEditableElement( & spEditElement ));

    if ( IsAtBoundaryOfViewLink( spEditElement) == S_OK ||
         GetEditableTagId() == TAGID_IFRAME )
    {
        //
        // Is the element we're site selecting inside or outside the viewlink ?
        //
        SP_IMarkupPointer spElemStart;
        SP_IMarkupPointer spElemEnd;
        IFC( GetEditor()->CreateMarkupPointer( & spElemStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spElemEnd ));

        IFC( spElemStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        IFC( spElemEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
        BOOL fStartInsideContext = Between( spElemStart, _pStartContext, _pEndContext );
        BOOL fEndInsideContext = Between( spElemEnd, _pStartContext, _pEndContext );

        if ( ! ( fStartInsideContext && fEndInsideContext ) )
        {
            DestroyAdorner();
        }           
    }
    else
    {
        DestroyAdorner();
    }        
        
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::IsContextWithinContainer
//
//  Synopsis:   Checks to see if the edit context is contained within the
//              current container.  This method uses flat markup pointers,
//              so sub-containers for things like viewlinks and will be
//              correctly retrieved.
//
//  Arguments:  pIContainer = Markup container to check context against
//              pfContained = OUTPUT - Success flag
//
//  Returns:    HRESULT indicating success.
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::IsContextWithinContainer(IMarkupContainer *pIContainer, BOOL *pfContained)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    BOOL                fResult;

    Assert( pIContainer && pfContained );
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned  ));
    Assert( fPositioned );
#endif

    *pfContained = FALSE;
    
    // Create markup pointers and position them on the 
    // start and end of the container in question
    
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

    IFC( spStart->MoveToContainer( pIContainer, TRUE ) );
    IFC( spEnd->MoveToContainer( pIContainer, FALSE ) );

    // Check to see if we are contained
    IFC( _pStartContext->IsRightOfOrEqualTo( spStart, &fResult ) );
    if( !fResult )
        goto Cleanup;

    IFC( _pEndContext->IsLeftOfOrEqualTo( spEnd, &fResult ) );
    if( !fResult )
        goto Cleanup;

    *pfContained = TRUE;

Cleanup:

    RRETURN(hr);
}

HRESULT
CSelectionManager::FindAtomicElement(IHTMLElement* pIElement, IHTMLElement** ppIAtomicParentElement, BOOL fFindTopmost /*=TRUE*/)
{
    HRESULT     hr = S_FALSE;
    BSTR        bstrAtomic = SysAllocString(_T("atomicSelection"));
    BSTR        bstrOn = SysAllocString(_T("true"));
    BOOL        fAtomic = FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spAtomicElement;

    if (bstrAtomic == NULL || bstrOn == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }    

    if (GetEditor()->GetActiveCommandTarget()->IsAtomicSelection())
    {
        //  Walk up the tree until we find an element with atomic
        //  selection turned on or until we hit the root.  If fFindTopmost
        //  is true we find the topmost atomic element.  Otherwise we
        //  just find the first one starting with pIElement.

        ReplaceInterface( &spElement , pIElement );
        while (1)
        {
            SP_IHTMLElement spParentElement;
            ELEMENT_TAG_ID  eTag;

            IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
            if (eTag == TAGID_INPUT || eTag == TAGID_GENERIC)
            {
                SP_IHTMLElement spMaster;

                if( GetMasterElement(GetMarkupServices(), spElement, &spMaster) == S_OK )
                {
                    ReplaceInterface( &spElement , (IHTMLElement*)spMaster );
                }
            }

            //  Get the atomicSelection attribute value
            IFC( CheckAttribute( spElement, & fAtomic, bstrAtomic, bstrOn ));

            if (fAtomic)
            {
                //  We found an atomic element.  Keep a pointer to it,
                //  break if we don't care to find the topmost.
                ReplaceInterface(&spAtomicElement, (IHTMLElement*)spElement);

                if (!fFindTopmost)
                    break;
            }
    
            //  atomicSelection not set.  Walk up the tree.
            IFC(GetParentElement(GetMarkupServices(), spElement, &spParentElement));
            if (spParentElement == NULL)
                break;

            ReplaceInterface( &spElement , (IHTMLElement*)spParentElement );
        }
    }
    
    hr = (spAtomicElement != NULL) ? S_OK : S_FALSE;
    
Cleanup:

    if (ppIAtomicParentElement)
        ReplaceInterface(ppIAtomicParentElement, (IHTMLElement*)spAtomicElement);

    SysFreeString( bstrAtomic );
    SysFreeString( bstrOn );

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::CheckAtomic(IHTMLElement *pIElement)
{
    HRESULT hr = S_FALSE;
    BOOL    fAtomic = FALSE;
    SP_IHTMLElement spAtomicParentElement;
    
    if (pIElement == NULL)
        goto Cleanup;

    //  First determine if atomic selection is enabled.
    if (GetEditor()->GetActiveCommandTarget()->IsAtomicSelection())
    {
        IFC( FindAtomicElement(pIElement, &spAtomicParentElement, FALSE) );

        if (spAtomicParentElement)
        {
            fAtomic = TRUE;
        }
    }
    
    hr = fAtomic ? S_OK : S_FALSE;
    
Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::AdjustPointersForAtomic( IMarkupPointer *pStart, IMarkupPointer *pEnd )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    int                 wherePointer = SAME;
    BOOL                fStartAdjusted = FALSE;

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    IFC( pStart->CurrentScope(&spElement) );
    if ( CheckAtomic( spElement ) == S_OK )
    {
        SP_IMarkupPointer   spTestPointer;
        BOOL                fAtBeforeEndOrAfterBegin = FALSE;

        IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
        if (wherePointer == SAME)
        {
            IFC( spTestPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ) );
            IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) );
                fStartAdjusted = TRUE;
            }
            else
            {
                IFC( spTestPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ) );
                IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
                if (fAtBeforeEndOrAfterBegin)
                {
                    IFC( pStart->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ) );
                    fStartAdjusted = TRUE;
                }
            }
        }
        else
        {
            IFC( spTestPointer->MoveAdjacentToElement( spElement,
                                            (wherePointer == LEFT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );

            IFC( spTestPointer->IsEqualTo(pStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pStart->MoveAdjacentToElement( spElement,
                                        (wherePointer == LEFT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                fStartAdjusted = TRUE;
            }
        }
    }

    if (fStartAdjusted && wherePointer == SAME)
    {
        IFC( pEnd->MoveToPointer(pStart) );
    }
    else
    {
        IFC( pEnd->CurrentScope(&spElement) );
        if ( CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtBeforeEndOrAfterBegin = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spElement ,
                                            (wherePointer == RIGHT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );

            IFC( spTestPointer->IsEqualTo(pEnd, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( pEnd->MoveAdjacentToElement( spElement,
                                        (wherePointer == RIGHT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::FireOnSelect(IHTMLElement* pIElement)
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbResult;
    SP_IMarkupPointer spPointer;
    
    ((IHTMLEditor*) GetEditor())->AddRef();
    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, ( void**) & spElement3 ));

    if ( _fInFireOnSelect) 
    {
        goto Cleanup; // bail to not have any rentrcny
    }
    
    _fInFireOnSelect = TRUE;
    IFC( spElement3->fireEvent( _T("onselect"), NULL, & vbResult ));
    _fInFireOnSelect = FALSE;

    //
    // Check to see if element is still in tree - by trying to move a pointer to it.
    //
    IFC( spPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin));
    
    if ( _fFailFireOnSelect )
    {
        hr = E_FAIL;
        _fFailFireOnSelect = FALSE;
    }
    
Cleanup:
    ((IHTMLEditor*)GetEditor())->Release();
    
    RRETURN( hr );
}

HRESULT
CSelectionManager::FireOnSelectStart( CEditEvent* pEvent, BOOL* pfOkToSelect, CEditTracker* pTracker )
{
    HRESULT hr;
    SP_IHTMLElement spElement;

    IFC( pEvent->GetElement( & spElement ));
    IFC( FireOnSelectStart( spElement, pfOkToSelect, pTracker ));

Cleanup:
    RRETURN( hr );
}

//+===============================================================================
//
// Method: FireOnSelectStart..
//
// Synopsis - Fire On Select Start back to the element and return the result.
//
//--------------------------------------------------------------------------------
HRESULT
CSelectionManager::FireOnSelectStart( IHTMLElement* pIElement, BOOL * pfOkToSelect , CEditTracker* pTracker )
{
    HRESULT hr     = S_OK ;
    BOOL fireValue = FALSE;

    Assert( !pTracker || !pTracker->IsDormant() );
    Assert( pfOkToSelect != NULL );

    if ( _fInFireOnSelectStart) 
    {
        goto Cleanup; // bail to not have any rentrcny
    }
    _fInFireOnSelectStart = TRUE;
    fireValue = EdUtil::FireOnSelectStart(pIElement) ;
    _fInFireOnSelectStart = FALSE;

    IFC( DoPendingTasks() );
    
    //
    // we fired select start, but something 'bad' happened - and we got made dormant.
    //
    if ( pTracker && pTracker->IsDormant() )
    {
        Assert( GetActiveTracker() != pTracker );
        hr = E_FAIL;
    }        
Cleanup:
    *pfOkToSelect = _fFailFireOnSelectStart ? FALSE : fireValue;
    _fFailFireOnSelectStart = FALSE;
    
    RRETURN (hr);
}


HRESULT 
CSelectionManager::TerminateTypingBatch()
{
    HRESULT hr = S_OK;
    
    if (_pCaretTracker)
        hr = THR(_pCaretTracker->TerminateTypingBatch());

    RRETURN(hr);
}

       
HRESULT
CSelectionManager::StartExitTreeTimer()
{
    HRESULT hr = S_OK;


    Assert(! _fInExitTimer && ! _pITimerWindow );

    //
    // Temp fix for 101237
    // NOTE!  If this EVER gets re'enabled, make sure this object gets addref'd and
    // released properly
    //
#if 0   
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;
    IFC( GetDoc()->get_parentWindow(&_pITimerWindow));
    IFC(_pITimerWindow->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)&_pExitTimer;

    IFC(spWindow3->setInterval(&varCallBack, 
                               0 , 
                               &varLang, &_lTimerID));
#endif

    _fInExitTimer = TRUE;
    
//Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectionManager::StopExitTreeTimer()
{
    HRESULT hr = S_OK ;



#if 0
    Assert( _fInExitTimer && _pITimerWindow );
    IFC( _pITimerWindow->clearInterval(_lTimerID));
#endif

    // Release the cached'd window
    ReleaseInterface( _pITimerWindow );
    _pITimerWindow = NULL;
    
    _fInExitTimer = FALSE;
//Cleanup:
    RRETURN (hr);
}

HRESULT
CExitTreeTimer::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;

    if( _pMan )
    {
        if ( _pMan->_pIElementExitStart )
        {
            IFC( _pMan->DoPendingElementExit());
            Assert( ! _pMan->_pIElementExitStart || _pMan->_fInPendingElementExit );
        }

        if ( _pMan->_fInExitTimer )
        {
            IFC( _pMan->StopExitTreeTimer());
        }
    }
 Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectionManager::GetAdornedElement( IHTMLElement** ppIElement )
{ 
    HRESULT hr = S_OK ;
    
    Assert( HasFocusAdorner());

    if ( ! HasFocusAdorner() || ! ppIElement )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    *ppIElement = _pAdorner->GetAdornedElement(); 
    (*ppIElement)->AddRef();
    
Cleanup:
    RRETURN( hr );
}


VOID
CSelectionManager::EndSelectionChange( BOOL fSucceed /*=TRUE*/)
{
    _ctSelectionChange--;

    //  Sometimes we one of the calls to end selection change may be with fSucceed true,
    //  but we weren't firing onselectionchange unless the last call was fSucceed true.
    //  Now we'll set a flag so that if we are called with fSucceed true at any point
    //  during the event handling, we'll fire onselectionchange.
    if (fSucceed)
        _fSelectionChangeSucceeded = fSucceed;

    if ( _ctSelectionChange == 0 && _fSelectionChangeSucceeded )
    {
        _fSelectionChangeSucceeded = FALSE;

        //
        // We don't fire OnSelectionChange if the caret isn't in an editable region.
        //
        IGNORE_HR( GetEditor()->FireOnSelectionChange( ( GetTrackerType() == TRACKER_TYPE_Caret ||
                                                         (GetTrackerType() == TRACKER_TYPE_Selection && 
                                                          _pSelectTracker->IsWaitingForMouseUp()) ) ? 

                                                        IsContextEditable() || _fDestroyedTextSelection :
                                                        TRUE  ) ); 
    }
}


HRESULT
CSelectionManager::AttachDropListener(IHTMLElement *pDragElement /*=NULL*/)
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLElement spElement;
    
    Assert( ! _pIDropListener );

    IGNORE_HR( GetEditor()->GetBody( & spElement ));

    //  Viewlinks may not have a BODY element, so in that case we'll use the drag element.
    if (!spElement && pDragElement)
    {
        spElement = pDragElement;
    }

    if (spElement)
    {
        ReplaceInterface( & _pIDropListener , (IHTMLElement*) spElement );
        
        IFC( _pDropListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
        IFC( _pIDropListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
        IFC( spElement2->attachEvent(_T("ondrop"), spDisp, & varAttach ));
        Assert( varAttach == VB_TRUE );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CSelectionManager::DetachDropListener()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pIDropListener );
    
    if (_pIDropListener)
    {
        IFC( _pDropListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
        IFC( _pIDropListener->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
        IFC( spElement2->detachEvent(_T("ondrop"), spDisp ));
    }
    
    ClearInterface( & _pIDropListener );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::BeginDrag(IHTMLElement *pDragElement /*=NULL*/)
{
    HRESULT hr;
    Assert( ! _fDontScrollIntoView );
    IFC( AttachDropListener(pDragElement));
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EndDrag()
{
    HRESULT hr;
    IFC( DetachDropListener());
    _fDontScrollIntoView = FALSE;

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: OnDropFail
//
// Synopsis: We don't want to cause any scroll into views to occur if OnDrop failed
//           IE5.5 bug 103831
//
//------------------------------------------------------------------------------------


VOID
CSelectionManager::OnDropFail()
{
    _fDontScrollIntoView = TRUE;
}



CSelectionChangeCounter::CSelectionChangeCounter(CSelectionManager *pManager)
{
    Assert(pManager);
    _pManager = pManager;
    _ctSelectionChange = 0;
}

CSelectionChangeCounter::~CSelectionChangeCounter()
{
    Assert(_ctSelectionChange >= 0);
    
    if (_ctSelectionChange > 0)
    {
        TraceTag((tagSelectionChangeCounter, "_ctSelectionChange is %d, should be 0", _ctSelectionChange));
        
        while (_ctSelectionChange)
        {
            EndSelectionChange(FALSE);
        }
    }
}

VOID
CSelectionChangeCounter::BeginSelectionChange()
{
    _pManager->BeginSelectionChange();

    _ctSelectionChange++;
}

VOID
CSelectionChangeCounter::EndSelectionChange(BOOL fSucceed /*=TRUE*/)
{
    _pManager->EndSelectionChange(fSucceed);
    _ctSelectionChange--;
    Assert(_ctSelectionChange >= 0);
}

VOID
CSelectionChangeCounter::SelectionChanged(BOOL fSucceed /*=TRUE*/)
{
    BeginSelectionChange();
    EndSelectionChange(fSucceed);
}



//+====================================================================================
//
// Method:     CSelectionManager::FreezeVirtualCaretPos
//
// Synopsis:   Enter the mode that will freeze virtual caret position. Virtual Caret 
//             position is the X/Y coordinate used as the starting position for up/down line
//             movement. In consecutive up/down line movement case, we want to let 
//             caret move in a vertical/horizontal line as much as possible. If the real caret
//             move up/down lines using the virtual caret position, we will have the desired
//             behavior.  
//
//             Note that virtual caret position might be undefined if there is no previous up/down 
//             movement. Also the Editor can reset virtual caret position in many 
//             occasions that it sees appropriate. This function explicitly asks Editor NOT to reset 
//             virtual caret psotion. 
//
//             We use the X value in horizontal text flow case and Y value in vertical text flow case.
//
// Argument:
//             fReCompute:  TRUE    recompute the Virtual Caret Position with current real caret
//                          FALSE   use current Virtual Caret Position. be it defined or underfined
// Returns:       
//             S_OK:    If MoveStart has been preserved
//             E_FAIL:  if caret tracker is not the active tracker
//
// Note:       This method is only meanful if caret tracker is in control
//
//+=====================================================================================
HRESULT
CSelectionManager::FreezeVirtualCaretPos(BOOL fReCompute)
{
    HRESULT             hr = S_OK;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spMarkup;
    SP_IDisplayPointer  spDisplay;
    POINT               ptLoc;

    if (!_pCaretTracker || _pCaretTracker != _pActiveTracker)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (fReCompute)
    {
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDisplay) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDisplay) );
        IFC( EdUtil::GetDisplayLocation(GetEditor(), spDisplay, &ptLoc, TRUE) );
        
        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );                        
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );

        _pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
        IFC( _pCaretTracker->_ptVirtualCaret.UpdatePosition(spMarkup, ptLoc) );
    }
    
    _pCaretTracker->GetVirtualCaret().FreezePosition(TRUE);

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method:     CSelectionManager::UnFreezeVirtualCaretPos
//
// Synopsis:   We are free to reset virtual caret position.  
//
// Argument:   fReset: TRUE     reset virtual caret position to underfined value
//                     FALSE    don't reset virtual caret position.  
//              
// Returns:       
//             S_OK:     Success
//             E_FAIL:   caret tracker is not in control
//
// Note:       This method is only meanful if caret tracker is in control
//
//+=====================================================================================
HRESULT
CSelectionManager::UnFreezeVirtualCaretPos(BOOL fReset)
{
    HRESULT     hr = S_OK;

    if (!_pCaretTracker || _pCaretTracker != _pActiveTracker)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
    if (fReset)
    {
        _pCaretTracker->GetVirtualCaret().InitPosition();
    }
    else
    {
        //
        // Update MoveStart with current caret CP
        //
        POINT               ptLoc;
        SP_IMarkupPointer   spMarkup;
        SP_IHTMLCaret       spCaret;

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );
        _pCaretTracker->GetVirtualCaret().PeekPosition(&ptLoc);
        IFC( _pCaretTracker->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) );
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT
CSelectionManager::FirePreDrag()
{
    IHTMLEditHost2 *pEditHost2 = GetEditor()->GetEditHost2();

    if (pEditHost2)
    {
        IGNORE_HR( pEditHost2->PreDrag() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\stdafx.h ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.H
//
//  Contents:   Include file for standard ATL include files
//
//-------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_)
#define AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_MIN_CRT
//#define _ATL_MIN_CRT
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

//
// NOTE: ATL depends on the *presence* of _DEBUG to switch into DEBUG mode.
// Trident *always* sets _DEBUG to some value. This causes a problem when
// building a retail build in the Trident tree. 
// undef'ing _DEBUG when _DEBUG is zero solves the problem.
//
#if _DEBUG == 0
# undef _DEBUG
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <stddef.h>
#include <malloc.h>

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void   __cdecl ATL_free(void *);
void * __cdecl ATL_malloc(size_t);
void * __cdecl ATL_realloc(void *, size_t);

#define lstrlenW _tcslen
#define lstrcmpiW StrCmpIW
#define lstrcpynW StrCpyNW
#define lstrcpyW StrCpyW
#define lstrcatW StrCatW

#undef HIMETRIC_PER_INCH

#undef SubclassWindow
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

typedef INT Direction;

#pragma warning( disable : 4510 4610 )  

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#undef malloc
#undef free
#undef realloc


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\seltrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

DeclareTag(tagSelectionDumpOnCp, "Selection","DumpTreeOnCpRange")
DeclareTag(tagSelectionTrackerState, "Selection", "Selection show tracker state")
DeclareTag(tagSelectionDisableWordSel, "Selection", "Disable Word Selection Model")
DeclareTag(tagSelectionValidate, "Selection", "Validate Selection Size in edtrack")
DeclareTag(tagShowScroll,"Selection", "Show scroll pointer into  view");
DeclareTag(tagShowSelectionCp,"Selection", "Show Selection Cp");

#if DBG == 1

static const LPCTSTR strStartSelection = _T( "    ** Start_Selection (Highlight)");
static const LPCTSTR strEndSelection = _T( "    ** End_Selection (Highlight)");
static const LPCTSTR strWordPointer = _T( "    ** Word");
static const LPCTSTR strTestPointer = _T( "    ** Test");
static const LPCTSTR strPrevTestPointer = _T( "    ** Last Test");
static const LPCTSTR strImeIP = _T( "    ** IME IP");
static const LPCTSTR strImeUncommittedStart = _T( "    ** IME Uncommitted Start");
static const LPCTSTR strImeUncommittedEnd = _T( "    ** IME Uncommitted End");
static const LPCTSTR strSelServStart = _T( "    ** Start_Selection (SelServ)");
static const LPCTSTR strSelServEnd = _T( "    ** End_Selection (SelServ)");
static const LPCTSTR strShiftPointer = _T( "    ** Shift-Selection Pointer");
static const LPCTSTR strSelectionAnchorPointer = _T( "    ** Selection Anchor Pointer");
static int gDebugTestPointerCp = -100;
static int gDebugEndPointerCp = -100;
static int gDebugTestPointerMinCp = -100;
static int gDebugTestPointerMaxCp = -100;
#endif


extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);

const LONG SEL_TIMER_INTERVAL = 100;

const long scrollSize = 5;

MtDefine( CSelectTracker, Utilities , "CSelectionTracker" )

#include "selstate.hxx"

using namespace EdUtil;

//
//
// Constructors & Initializations
//
//

CSelectTracker::CSelectTracker( CSelectionManager* pManager) :
    CEditTracker( pManager )
{
    //
    // We are no longer zero-memed out on creation. We explicitly set all instance vars.
    //
    _pDispStartPointer = NULL;
    _pDispEndPointer = NULL;
    _pDispTestPointer = NULL;
    _pDispWordPointer = NULL;
    _pDispPrevTestPointer = NULL;
    _pDispShiftPointer = NULL;
    _pDispSelectionAnchorPointer = NULL;
    _pISegment = NULL;
    _pIRenderSegment = NULL;
    _pSelServStart = NULL;
    _pSelServEnd = NULL;
    _pITimerWindow = NULL;
    _fInSelTimer = FALSE;
    _pITimerWindow = NULL;
    _fInSelTimer = FALSE;
    _pISelectStartElement = NULL;
    _pIScrollingAnchorElement = NULL;
    _pIDragElement = NULL;
    _pSelectionTimer = NULL;
    _pPropChangeListener = NULL;
    _fFiredNotify = FALSE;
    _lTimerID = 0;

    Init();

}

HRESULT
CSelectTracker::InitPointers()
{
    HRESULT hr = S_OK;

    Assert( !_pDispStartPointer );
    Assert( !_pDispEndPointer );
    Assert( !_pDispTestPointer );
    Assert( !_pDispWordPointer );
    Assert( !_pDispPrevTestPointer );
    Assert( !_pDispShiftPointer );
    Assert( !_pDispSelectionAnchorPointer );

    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispStartPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispEndPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispTestPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispPrevTestPointer));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispWordPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispShiftPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & _pDispSelectionAnchorPointer ));

    IFC( GetEditor()->CreateMarkupPointer( &_pSelServStart) );
    IFC( GetEditor()->CreateMarkupPointer( &_pSelServEnd) );

    _pSelectionTimer = new CSelectionTimer(this);
    if( !_pSelectionTimer )
        goto Error;

    _pPropChangeListener = new CPropertyChangeListener(this);
    if( !_pPropChangeListener )
        goto Error;

#if DBG == 1
    _pManager->SetDebugName( _pDispStartPointer, strStartSelection ) ;
    _pManager->SetDebugName( _pDispEndPointer, strEndSelection );
    _pManager->SetDebugName( _pDispWordPointer, strWordPointer );
    _pManager->SetDebugName( _pDispTestPointer, strTestPointer);
    _pManager->SetDebugName( _pDispPrevTestPointer, strPrevTestPointer );
    _pManager->SetDebugName( _pDispSelectionAnchorPointer, strSelectionAnchorPointer );
    _pManager->SetDebugName( _pSelServStart, strSelServStart) ;
    _pManager->SetDebugName( _pSelServEnd, strSelServEnd );
    _pManager->SetDebugName( _pDispShiftPointer, strShiftPointer );

#endif

Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

VOID
CSelectTracker::Init()
{
    _anchorMouseX = CARET_XPOS_UNDEFINED ;
    _anchorMouseY = CARET_YPOS_UNDEFINED ;
    _ptCurMouseXY.x = CARET_XPOS_UNDEFINED;
    _ptCurMouseXY.y = CARET_YPOS_UNDEFINED;
#ifdef UNIX
    _firstMessage = NULL;
#endif
    _fShift = FALSE;
    _fDragDrop = FALSE;
    _fDoubleClickWord = FALSE;
    _fState = ST_DORMANT;

    _eType = TRACKER_TYPE_Selection;
    _fEndConstrained = FALSE;
    _fMadeSelection = FALSE;
    _fAddedSegment = FALSE;
    _fInWordSel = FALSE;
    _fWordPointerSet = FALSE;
    _fWordSelDirection = FALSE;
    _fStartAdjusted = FALSE;
    _fExitedWordSelectionOnce = FALSE;

    _fStartIsAtomic = FALSE;
    _fStartAdjustedForAtomic = FALSE;
    _fEditContextUpdatedForAtomic = FALSE;
    _fTookCapture = FALSE;
    _fFiredNotify = FALSE;
    _ptVirtualCaret.InitPosition();
    _lastCaretMove = CARET_MOVE_NONE;
    _fMouseClickedInAtomicSelection = FALSE;
    WHEN_DBG( _ctStartAdjusted = 0 );
    WHEN_DBG( _ctScrollMessageIntoView = 0 );
}

HRESULT
CSelectTracker::Init2(
        CEditEvent*             pEvent ,
        DWORD                   dwTCFlags,
        IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;

    Assert( _fState == ST_DORMANT );

    hr = InitPointers();
    if ( hr )
        goto Cleanup;
#ifdef UNIX
    _firstMessage = *pMessage;
#endif

    _fState = _pManager->IsMessageInSelection(pEvent) ? ST_WAIT1 : ST_WAIT2; // marka - we should look to see if we're alredy in a selection here.
    _fDragDrop = ( _fState == ST_WAIT1);

    if( _fDragDrop )
    {
        //
        // Make sure we can retrieve the drag element.  If we were unable to retrieve the drag
        // element, we should just do a normal selection.
        //
        hr = THR( RetrieveDragElement( pEvent ) );
        if( FAILED( hr ) )
        {
            _fState = ST_WAIT2;
            _fDragDrop = NULL;
        }
    }
    
    _fShift = FALSE;

    if (!_fDragDrop)
    {
        IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );
    }

    hr = BeginSelection( pEvent );

Cleanup:
    return hr;
}


HRESULT
CSelectTracker::Init2(
        IDisplayPointer*         pDispStart,
        IDisplayPointer*         pDispEnd,
        DWORD                   dwTCFlags,
        CARET_MOVE_UNIT inLastCaretMove )
{
    HRESULT hr                  = S_OK;
    BOOL    fStartFromShiftKey  = ENSURE_BOOL( dwTCFlags & TRACKER_CREATE_STARTFROMSHIFTKEY );
    BOOL    fMouseShift         = ENSURE_BOOL( dwTCFlags & TRACKER_CREATE_STARTFROMSHIFTMOUSE );
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    BOOL    fDidSelection = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

    Assert( _fState == ST_DORMANT );

    hr = InitPointers();
    if ( hr )
        goto Cleanup;

    _fState = ST_WAIT2;
    _fDragDrop = FALSE;
    _fShift = fStartFromShiftKey ;
    SetLastCaretMove( inLastCaretMove );

    IFC( pDispStart->PositionMarkupPointer(spStart) );
    IFC( pDispEnd->PositionMarkupPointer(spEnd) );
    ResetSpringLoader(_pManager, spStart, spEnd);

    // Set the selection type
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );

    //
    // Shift selection.  If we positioned the selection tracker based off of a shift select, then we
    //
    if( fStartFromShiftKey )
    {
        IFC( UpdateShiftPointer( pDispEnd ) );
    }

    IFC( Position( pDispStart, pDispEnd, &fDidSelection, inLastCaretMove) );
    if (fDidSelection)
        goto Cleanup;

    if ( fStartFromShiftKey && fMouseShift )
    {
        //  If we started a selection with the shift key down, we want to go straight into word
        //  selection mode.
        int iWherePointer;

        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( pDispStart, pDispEnd, & iWherePointer));
        IFC( _pDispTestPointer->MoveToPointer( pDispEnd ));
        IFC( _pDispSelectionAnchorPointer->MoveToPointer( pDispStart ) );

        IFC( DoWordSelection(NULL, &fDidSelection, ( iWherePointer == RIGHT )) );
        if (fDidSelection)
        {
            IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
            IFC( UpdateShiftPointer( _pDispEndPointer ));
            IFC( UpdateSelectionSegments() );

            //  Set our current state.
            SetState( ST_WAIT2, TRUE );

            //  Reset our timers.
            StartTimer();
            StartSelTimer();

            goto Cleanup;
        }
    }

    if (GetTrackerType() == TRACKER_TYPE_Caret)
    {
        _pManager->GetActiveTracker()->GetLocation(&_ptCurMouseXY, TRUE);
    }

    // Our selection is passive if it's been set by TreePointers
    BecomePassive( TRUE );

Cleanup:
    return hr;
}

HRESULT
CSelectTracker::Init2(
        ISegmentList*           pSegmentList,
        DWORD                   dwTCFlags ,
        CARET_MOVE_UNIT inLastCaretMove   )
{
    HRESULT hr = S_OK;
    SELECTION_TYPE eType;
    ED_PTR ( edStart );
    ED_PTR ( edEnd );
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    SP_IDisplayPointer spDispStart, spDispEnd;

    IFC( pSegmentList->GetType( & eType ));
    Assert( eType == SELECTION_TYPE_Text );

    IFC( pSegmentList->CreateIterator( & spIter ));

    Assert( spIter->IsDone() != S_OK );

    IFC( spIter->Current( & spSegment ));
    IFC( spSegment->GetPointers( edStart, edEnd ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->MoveToMarkupPointer(edStart, NULL) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->MoveToMarkupPointer(edEnd, NULL) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    hr = THR( Init2(
                     spDispStart,
                     spDispEnd,
                     dwTCFlags,
                     inLastCaretMove ));
    IFC( spIter->Advance() );

    AssertSz( spIter->IsDone() == S_OK , "Multiple-text selection not implemented yet" );

Cleanup:
    RRETURN( hr );
}

CSelectTracker::~CSelectTracker()
{
    BecomeDormant( NULL, TRACKER_TYPE_None, FALSE );

    Assert( !_pITimerWindow );
}

//
//
// Virtuals for all trackers
//
//


//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::BecomeDormant(  CEditEvent      *pEvent,
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI     /* = TRUE */)

{
    HRESULT hr = S_OK;

    TraceTag( ( tagSelectionTrackerState, "CSelectTimer::BecomeDormant"));

    if ( _pManager->IsInTimer() )
        StopTimer();
    if (  _pManager->IsInCapture()  )
        ReleaseCapture();

    Assert(! _pManager->IsInCapture() );

    if ( _fInSelTimer )
        StopSelTimer();

    if ( fTearDownUI &&  pEvent )
    {
        SP_IHTMLElement spElement;
        IFC( pEvent->GetElement( & spElement));

        //
        // Only clear the selection if we are starting a selection somewhere else,
        // or if we clicked on selection but the tracker which is becoming active
        // is not the select tracker (IE: if the select tracker is becoming active,
        // we are going to be doing a drag and drop, and definitely don't want to
        // destroy selection)
        //
        if( !_pManager->IsMessageInSelection( pEvent ) ||
            typeNewTracker != TRACKER_TYPE_Selection )
        {
            IGNORE_HR( ClearSelection() );
        }
    }
    else
        IGNORE_HR( ClearSelection());

    Destroy();

    SetState( ST_DORMANT, TRUE );

Cleanup:

    RRETURN( hr );
}


BOOL
CSelectTracker::IsActive()
{
    return(  ! IsPassive() && ! IsDormant() );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::Awaken()
{
    Assert( IsDormant());
    Assert(! _pManager->IsInCapture() );

    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::Destroy()
{
    ClearInterface( & _pDispStartPointer );
    ClearInterface( & _pDispEndPointer );
    ClearInterface( & _pDispTestPointer );
    ClearInterface( & _pDispWordPointer );
    ClearInterface( & _pDispShiftPointer );
    ClearInterface( & _pDispPrevTestPointer );
    ClearInterface( & _pDispSelectionAnchorPointer );
    ClearInterface( & _pSelServStart);
    ClearInterface( & _pSelServEnd);

    if ( _pIDragElement )
    {
        ClearInterface( & _pIDragElement );
    }
    
    if ( _pISelectStartElement )
    {
        DetachPropertyChangeHandler();
        ClearInterface( & _pISelectStartElement );
    }

    if ( _pIScrollingAnchorElement )
    {
        ClearInterface( & _pIScrollingAnchorElement );
    }

    if ( _fInSelTimer )
    {
        StopSelTimer();
        Assert( ! _fInSelTimer );
    }

    if (_pSelectionTimer)
    {
        _pSelectionTimer->SetSelectTracker(NULL);
        ClearInterface( & _pSelectionTimer );
    }

    if (_pPropChangeListener)
    {
        _pPropChangeListener->SetSelectTracker(NULL);
        ClearInterface( & _pPropChangeListener );
    }
}


BOOL
CSelectTracker::IsPointerInSelection(   IDisplayPointer *pDispPointer,
                                        POINT           *pptGlobal,
                                        IHTMLElement    *pIElementOver )
{
    HRESULT             hr = S_OK;
    BOOL                fWithin = FALSE;
    BOOL                fEqual;
    int                 iWherePointer = SAME;
    IMarkupContainer    *pIContainer1 = NULL;
    IMarkupContainer    *pIContainer2 = NULL;
    SP_IMarkupPointer   spPointerStartSel;
    SP_IMarkupPointer   spSelectionPtr;
    SP_IMarkupPointer   spPointerEndSel;
    SP_IMarkupPointer   spPointer;
    
    if ( _fState == ST_WAIT2 || _fState == ST_WAITBTNDOWN2  )
    {
        //
        // just say no when selection hasn't really started.
        //
        goto Cleanup;
    }

    if ( _pISegment )
    {
        //
        // Create the pointers we need, and position them around selection
        // 
        IFC( GetEditor()->CreateMarkupPointer( &spPointerStartSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerEndSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));

        IFC( _pISegment->GetPointers(spPointerStartSel, spPointerEndSel ) );
        IFC( spPointerStartSel->IsEqualTo( spPointerEndSel, &fEqual ));

        //
        // Make sure that we are not in a 0 sized selection
        //
        if ( ! fEqual )
        {
            //
            // If the pointers aren't in equivalent containers, adjust them so they are.
            //
            IFC( pDispPointer->PositionMarkupPointer(spPointer) );
            IFC( spPointer->GetContainer( &pIContainer1 ));

            IFC( spPointerStartSel->GetContainer( & pIContainer2 ));

            if (! EqualContainers( pIContainer1 , pIContainer2 ))
            {
                IFC( GetEditor()->MovePointersToEqualContainers( spPointer, spPointerStartSel ));
            }

            IFC( _pISegment->GetPointers( spPointerStartSel, spPointerEndSel ) );
            IFC( OldCompare( spPointerStartSel, spPointer, &iWherePointer ));

            if ( iWherePointer != LEFT )
            {
                IFC( OldCompare( spPointerEndSel, spPointer, &iWherePointer));
                
                fWithin = ( iWherePointer != RIGHT ) ;
            }
        }
    }

Cleanup:
    ReleaseInterface( pIContainer1 );
    ReleaseInterface( pIContainer2 );

    return ( fWithin );
}

//+====================================================================================
//
// Method: ShouldBeginSelection
//
// Synopsis: We don't want to start selection in Anchors, Images etc.
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::ShouldStartTracker(
                            CEditEvent* pEvent,
                            ELEMENT_TAG_ID eTag,
                            IHTMLElement* pIElement,
                            SST_RESULT * peResult )
{
    HRESULT             hr = S_OK;
    SST_RESULT          eResult = SST_NO_CHANGE;
    VARIANT_BOOL        fScoped;
    IHTMLInputElement   *pInputElement = NULL;
    IDocHostUIHandler   *pHostUIHandler = NULL;
    SP_IServiceProvider spSP;
    SP_IHTMLElement2    spElement2;
    BSTR                bstrType = NULL;
    SP_IDisplayPointer  spEventPtr;                 // Display pointer where event was positioned

    Assert( peResult );

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Create a display pointer, and move it to the event.  This allows
    // us to do hit testing
    //
    IFC( GetDisplayServices()->CreateDisplayPointer( &spEventPtr ) );
    IFC( pEvent->MoveDisplayPointerToEvent ( spEventPtr, NULL ));

#if DBG == 1
    //  We may be called on an EVT_LMOUSEDOWN when clicking on an atomic element.
    //  So we want to assert _fState != ST_WAIT3RDBTNDOWN only if the element
    //  we clicked on was not atomic.
    if( _fState == ST_WAIT3RDBTNDOWN)
    {
        SP_IHTMLElement spElement;
        
        IFC ( pEvent->GetElement( &spElement ));
        if (_pManager->CheckAtomic(spElement) != S_OK)
        {
            AssertSz(FALSE, "_fState != ST_WAIT3RDBTNDOWN");
        }
    }
#endif

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_canHaveChildren(&fScoped));

    if ( ! IsDormant() && IsShiftKeyDown() )
    {
        goto Cleanup;
    }

    if ( IsShiftKeyDown() && _pManager->GetSelectionType() == SELECTION_TYPE_Caret )
    {
        goto Cleanup;
    }

    if ( pEvent->GetType() == EVT_RMOUSEDOWN )
    {
        if( IsPassive() || IsActive() )
            eResult = SST_NO_BUBBLE;
        else
            eResult = SST_NO_CHANGE;

        goto Cleanup;
    }

    //
    // Always allow the selection manager to start
    // if the event is within an existing selection (drag -n- drop)
    //
    if ( _pManager->IsMessageInSelection( pEvent ) )
    {
        Assert( ! IsDormant());
        eResult = SST_CHANGE;
    }
    //
    // Make sure selection is allowed here.  We don't want to allow selection
    // in no-scope elements, unless they are an input or an IFRAME.
    //
    else if ( GetEditor()->AllowSelection( pIElement, pEvent ) != S_OK )
    {
        goto Cleanup;
    }
    else if ( !fScoped && (eTag != TAGID_INPUT) && (eTag != TAGID_IFRAME) && !(pEvent->GetHitTestResult() & HT_RESULTS_Glyph) )
    {
        goto CheckAtomic;
    }
    else
    {
        switch ( eTag )
        {
            case TAGID_BUTTON:
            {
                eResult  = _pManager->IsContextEditable() ? SST_CHANGE : SST_NO_CHANGE;
            }
            break;

            case TAGID_INPUT:
            {
                if ( ( eTag == TAGID_INPUT )
                    && S_OK == THR( pIElement->QueryInterface ( IID_IHTMLInputElement, ( void** ) & pInputElement ))
                    && S_OK == THR(pInputElement->get_type(&bstrType)))
                {
                    if (   !StrCmpIC( bstrType, TEXT("image") )
                        || !StrCmpIC( bstrType, TEXT("radio") )
                        || !StrCmpIC( bstrType, TEXT("checkbox") ))
                    {
                        goto CheckAtomic;
                    }
                    else if ( !StrCmpIC( bstrType, TEXT("button")) &&
                              !_pManager->IsContextEditable() )
                    {
                        //
                        // disallow selecting in a button if it's not editable.
                        //
                        goto CheckAtomic;
                    }
                    else
                    {
                        eResult = SST_CHANGE;
                    }

                }
                break;
            }

            default:
                eResult = SST_CHANGE;
                break;
        }
    }

    //
    // This code is no longer required. We used to require this for clicking on the magic div
    // in a text selection.
    //
    // In IE5.0 - a click on a site selected element in a text selection - would constitute a drag.
    // if you moused up - you could then get a caret in the magic div
    //
    // In IE 5.5 - we now site select the element in this case
    // so this is no longer required
    //

#if 0
    //
    // verify it's really ok to start a selection by firing on edit focus.
    //

    if ( eResult == SST_CHANGE )
    {
        //
        // This case is for you have a text selection through the "magic div",
        // and you click on the magic div. We don't fire the event on the edit context
        // but on the element you clicked on
        //
        if ( ! _pManager->IsDontFireEditFocus() )
        {
            if ( IsPassive() &&
                 (CControlTracker::IsThisElementSiteSelectable( _pManager, eTag, pIElement) ) )
            {
                eResult = FireOnBeforeEditFocus( pIElement, _pManager->IsParentEditable() ) ? SST_CHANGE : SST_NO_CHANGE;
            }
            else
            {
                eResult = _pManager->FireOnBeforeEditFocus() ? SST_CHANGE : SST_NO_CHANGE ;
            }
        }
    }
    Assert( ! _pManager->IsIMEComposition());
#endif

CheckAtomic:
    
    //  Bug 104792: Change if the user clicked on a control in an atomic element.
    if (eResult == SST_NO_CHANGE && _pManager->CheckAtomic(pIElement) == S_OK)
    {
        eResult = SST_CHANGE;
    }

Cleanup:

    if( hr == CTL_E_INVALIDLINE )
    {
        //
        // Tried to start selection where a display pointer could not be positioned.
        // Don't change the tracker
        //
        hr = S_OK;
        eResult = SST_NO_CHANGE;
    }

    *peResult = eResult ;

    SysFreeString(bstrType);

    ReleaseInterface( pHostUIHandler );
    ReleaseInterface( pInputElement );

    RRETURN( hr );
}


BOOL
CSelectTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    return ( _fState == ST_WAIT3RDBTNDOWN );
}

BOOL
CSelectTracker::IsWaitingForMouseUp()
{
    return ( _fState == ST_WAIT2 ||
             _fState == ST_WAITCLICK ||
             _fState == ST_WAITBTNDOWN2 ||
             _fState == ST_MAYSELECT2 ||
             _fState == ST_WAIT3RDBTNDOWN );

}

HRESULT
CSelectTracker::GetLocationForDisplayPointer(
                    IDisplayPointer *pDispPointer,
                    POINT           *pPoint,
                    BOOL            fTranslate
                    )
{
    HRESULT             hr;
    SP_ILineInfo        spLineInfo;
    SP_IMarkupPointer   spPointer;
    IHTMLElement        *pIFlowElement = NULL;

    Assert( pPoint );

    IFR( pDispPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if( fTranslate )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( pDispPointer->GetFlowElement(&pIFlowElement) );

        if (!pIFlowElement)
        {
            IFC(_pManager->GetEditableElement(&pIFlowElement));
        }

        IFC( GetDisplayServices()->TransformPoint(pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, pIFlowElement) );
    }

Cleanup:
    ReleaseInterface(pIFlowElement);
    return S_OK;
}

//
// Always takes _pDispEndPointer!!!
//
//
HRESULT
CSelectTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    return GetLocationForDisplayPointer( _pDispEndPointer, pPoint, fTranslate);
}


//+====================================================================================
//
// Method: CalculateBOL
//
// Synopsis: Get our BOL'ness.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::CalculateBOL()
{
    IGNORE_HR( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
}

HRESULT
CSelectTracker::Position(
                    IDisplayPointer* pDispStart,
                    IDisplayPointer* pDispEnd)
{
    HRESULT hr = S_OK;

    IFC( Position(pDispStart, pDispEnd, NULL, CARET_MOVE_NONE) );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::Position(   IDisplayPointer *pDispStart,
                            IDisplayPointer *pDispEnd,
                            BOOL            *pfDidSelection,
                            CARET_MOVE_UNIT inCaretMove)
{
    HRESULT             hr = S_OK;
    POINTER_GRAVITY     eGravity;
    BOOL                fAdjust = FALSE;
    BOOL                fEndIsAtomic = FALSE;
    SP_ILineInfo        spLineInfo;
    SP_IHTMLElement     spFlowElement;
    SP_IHTMLElement     spAtomicElement;
    SP_IMarkupPointer   spEndPointer;
    BOOL                fBlockEmpty;
    BOOL                fBetweenBlocks;
    CBlockPointer       ptrBlock( GetEditor() );
    POINT               ptLoc;
    BOOL                fStartIsAtomic = FALSE;

#if DBG==1
    BOOL fPositioned = FALSE;
    hr = _pDispStartPointer->IsPositioned(& fPositioned );
    Assert( ! fPositioned);
#endif
    //
    // We assume that you can only set a position on a New Tracker.
    //
    Assert( ! _fAddedSegment );

    IFC( MoveStartToPointer( pDispStart ));
    IFC( MoveEndToPointer( pDispEnd ));

    //
    // copy gravity - important for commands
    //
    IFC(  pDispStart->GetPointerGravity( &eGravity ) );            // need to maintain gravity
    IFC( _pDispStartPointer->SetPointerGravity( eGravity ) );
    IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

    IFC( pDispEnd->GetPointerGravity( &eGravity ));            // need to maintain gravity
    IFC( _pDispEndPointer->SetPointerGravity( eGravity ));
    IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );
    IFC( GetLocation(&_ptCurMouseXY, FALSE) );

    IFC( GetCurrentScope(_pDispStartPointer, &spAtomicElement) );
    fStartIsAtomic = ( _pManager->CheckAtomic( spAtomicElement ) == S_OK );

    IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
    fEndIsAtomic = ( _pManager->CheckAtomic( spAtomicElement) == S_OK );

    if (fStartIsAtomic && !(!fEndIsAtomic && inCaretMove == CARET_MOVE_FORWARD))
    {
        _fStartIsAtomic = TRUE;

        IFC( AdjustForAtomic( _pDispStartPointer, spAtomicElement, TRUE, NULL, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }

    if (fEndIsAtomic && !(!fStartIsAtomic && inCaretMove == CARET_MOVE_BACKWARD))
    {
        fEndIsAtomic = TRUE;

        IFC( AdjustForAtomic( _pDispEndPointer, spAtomicElement, FALSE, NULL, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }

    if (fStartIsAtomic || fEndIsAtomic)
    {
        //
        // We need to fix up display gravity properly since atomic selection
        // was initiated programmatically. We do not have gravity information
        // properly setup as such. 
        //
        // IEV6-7270-2000/08/07-zhenbinx
        //
        int iWherePointer = 0;
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare(_pDispStartPointer, _pDispEndPointer, &iWherePointer) );
        if (iWherePointer == RIGHT)  // start < end
        {
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
        else
        {
            IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
    }
    

    IFC( _pDispStartPointer->GetFlowElement( & spFlowElement )) ;
    IFC( AttachPropertyChangeHandler( spFlowElement ));

    if ( _fShift )
    {
        // Before we call AdjustSelection, we should try and do major adjustments here.
        //
        // A major adjustment includes selecting additional words or characters during
        // a single selection move.
        //
        // For example, If we were between blocks and we tried to move forward, then
        // we need to call MovePointer() again to select the first character in the next block.
        //
        // Likewise, if we were moving forwards or backwards by one character or
        // on word, and we ended up on a table boundary with content in that
        // boundary, we need to select the content.  This fixes VID issues like
        // bug 71907.
        //
        fBetweenBlocks = IsBetweenBlocks( _pDispShiftPointer );

        IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
        IFC( _pDispShiftPointer->PositionMarkupPointer(spEndPointer) );

        if( inCaretMove == CARET_MOVE_FORWARD     || inCaretMove == CARET_MOVE_BACKWARD ||
            inCaretMove == CARET_MOVE_WORDFORWARD || inCaretMove == CARET_MOVE_WORDBACKWARD )
        {
            IFC( ptrBlock.MoveTo( spEndPointer, GetPointerDirection(inCaretMove) ) );
            IFC( ptrBlock.IsEmpty( &fBlockEmpty ) );

            if( fBetweenBlocks ||
                ( IsAtEdgeOfTable( Reverse(GetPointerDirection(inCaretMove)), spEndPointer) &&
                  !fBlockEmpty ) )
            {
                IFC( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc));
            }
        }

        //  If the end is atomic, we do not want to move it to the shift pointer since we
        //  already positioned it earlier.
        if (!fEndIsAtomic)
        {
            IFC( _pDispEndPointer->MoveToPointer( _pDispShiftPointer ) );
        }

        IFC( AdjustSelection( & fAdjust ));
    }
    IFC( ConstrainSelection(TRUE, NULL, _fStartIsAtomic, fEndIsAtomic) );

    IFC( CreateSelectionSegments() );
    IFC( FireOnSelect());

    SetMadeSelection( TRUE );

#if DBG == 1
    {
        SP_ISegmentList spSegmentList;
        BOOL            fEmpty = FALSE;
        HRESULT         hrDbg;

        hrDbg = GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList );
        if( !hrDbg ) spSegmentList->IsEmpty(&fEmpty);

        Assert( !fEmpty );
    }
#endif

Cleanup:

    RRETURN ( hr );

}


//
//
// Message Handling
//
//

//+---------------------------------------------------------------------------
//
//  Member:     CSelectTracker::GetAction
//
//  Synopsis:   Get the action to be taken, given the state we are in.
//
//----------------------------------------------------------------------------
ACTIONS
CSelectTracker::GetAction(CEditEvent* pEvent)
{
    unsigned int LastEntry = sizeof (ActionTable) / sizeof (ActionTable[0]);
    unsigned int i;
    ACTIONS Action = A_ERR;

    Assert (_fState <= ST_WAITCLICK );

    // Discard any spurious mouse move messages
    if ( pEvent->GetType() == EVT_MOUSEMOVE  )
    {
        POINT pt;
        IGNORE_HR( pEvent->GetPoint( & pt ));

        if (!IsValidMove ( & pt ))
        {
            Action = A_DIS;
        }

    }

    if ( Action != A_DIS )
    {
        // Lookup the state-message tabl to find the appropriate action
        // ActionTable[LastEntry - 1]._iJMessage = pMessage->message;
        for (i = 0; i < LastEntry; i++)
        {
            if ( (ActionTable[i]._iJMessage == pEvent->GetType()) || ( i == LastEntry ) )
            {
                Action = ActionTable[i]._aAction[_fState];
                break;
            }
        }
    }
    return (Action);
}

HRESULT
CSelectTracker::HandleEvent(
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;

    switch( pEvent->GetType() )
    {
        case EVT_RMOUSEUP:
        {
            // Destroy the selection tracker if the user right clicks on another valid
            // selection location.
            if ( ! _pManager->IsMessageInSelection(  pEvent )  &&
                   ( GetEditor()->AllowSelection( GetEditableElement(), pEvent ) == S_OK ) )
            {
                    IGNORE_HR( pEvent->MoveDisplayPointerToEvent(
                                            _pDispStartPointer,
                                            GetEditableElement() ));


                    IFC( _pManager->PositionCaret( _pDispStartPointer ));
            }
        }
        break;

        case EVT_LMOUSEUP:
        case EVT_LMOUSEDOWN:
        case EVT_TIMER:
        case EVT_DBLCLICK:
        case EVT_MOUSEMOVE:
        case EVT_CLICK:
        case EVT_INTDBLCLK:

            if ( IsPassive() )
            {
#if DBG == 1
                BOOL fWentDormant = FALSE;
#endif

                if ( ( pEvent->GetType() == EVT_LMOUSEDOWN) && ( pEvent->IsShiftKeyDown() ) )
                {
                        BOOL fDidSelection = FALSE;
                        BOOL fEqual;

                        IFC(DoSelection( pEvent, FALSE, &fDidSelection ));
                        if (fDidSelection)
                            goto Cleanup;

                        //
                        // If we are equal, create a caret tracker, selection has disappeared
                        //
                        IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, & fEqual ));
                        if ( fEqual )
                        {
#if DBG == 1
                            fWentDormant = TRUE;
#endif
                            BecomePassive( TRUE );
                        }
                }
#ifndef _PREFIX_
                Assert( (_fState == ST_PASSIVE) || fWentDormant ); // make sure we're still passive
#endif

                //
                // If we get here - we're passive. Make sure we're not in capture
                //
                if (  _pManager->IsInCapture()  )
                    ReleaseCapture();

                if ( _pManager->IsInTimer() )
                    StopTimer();

                if ( _fInSelTimer )
                {
                    StopSelTimer();
                    Assert( ! _fInSelTimer );
                }
            }
            else
            {
                hr = HandleMessagePrivate( pEvent  );
            }
            break;

        case EVT_KEYPRESS:
            hr = THR( HandleChar( pEvent));
            break;


        case EVT_KEYDOWN:
            if ( IsPassive() )
                hr = THR( HandleKeyDown( pEvent  ));
            else
                hr = THR( HandleMessagePrivate( pEvent ));
            break;

        case EVT_KEYUP:
            if ( IsPassive() )
                hr = THR ( HandleKeyUp ( pEvent ));
            break;

        case EVT_KILLFOCUS:
        case EVT_LOSECAPTURE:
            //
            // A focus change/loss of capture has occured.
            // If we have capture - this is a bad thing.
            // a sample of this is throwing up a dialog from a script.
            //

            IFC( OnLoseCapture());
            break;

#ifndef NO_IME
        case EVT_IME_STARTCOMPOSITION:
            hr = THR( HandleImeStartComposition( pEvent ));
            break;
#endif // !NO_IME

    }
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectTracker::EnableModeless( BOOL fEnable )
{
    HRESULT hr = S_OK;

    if ( ! fEnable ) // dialog is coming up. we better shut ourselves down.
    {
        hr = THR( OnLoseCapture()) ;
    }

    RRETURN( hr );
}

HRESULT
CSelectTracker::OnLoseCapture()
{
    if ( ! IsPassive() )
    {
        if ( _pManager->IsInFireOnSelectStart() )
        {
            //
            // If we are in a FireOnSelectStart - gracefully bail.
            //
            _pManager->SetFailFireOnSelectStart( TRUE );
        }
        else
        {
            BecomePassive(TRUE);
        }
    }
    return S_OK;
}

HRESULT
CSelectTracker::HandleMessagePrivate(
                CEditEvent* pEvent)
{
    HRESULT hr = S_OK;
    BOOL fHandledDrag = FALSE;
    BOOL fSelect;
    ACTIONS Action = A_UNK;

    // If we have not already decided what to do with the message ...
    Action = GetAction (pEvent) ;

    switch (Action)
    {
    case A_ERR: // Spurious error, bail out please
        AssertSz(0,"Unexpected event for State");
        if ( _pManager->IsInCapture() )
            ReleaseCapture();
        IFC( _pManager->PositionCaret( _pDispStartPointer ));
        break;

    case A_DIS: // Discard the message
        break;

    case A_IGN: // Do nothing, just ignore the message, let somebody else process it
        hr = S_FALSE;

        //
        // the code below is to eat keystrokes while dragging and make sure they dont'
        // get translated into commands - eg. IDM_DELETE.
        //
        if ( ( pEvent->GetType() == EVT_KEYDOWN ) && ! IsPassive() )
        {
            hr = S_OK; // eat all keystrokes while dragging.
        }
        break;

    case A_5_16: // ST_WAIT2 & EVT_LBUTTONUP
        SetState( ST_WAITCLICK );
        break;

    case A_16_7: // ST_WAITCLICK & EVT_CLICK
        SetState( ST_WAITBTNDOWN2 );
        break;

    case A_5_6: // ST_WAIT2 & EVT_MOUSEMOVE
        // if the bubblable onselectstart event is cancelled, don't
        // go into DuringSelection State, and cnx the tracker

        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );

        if( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();
            StopTimer();
            IFC(_pManager->PositionCaret(_pDispStartPointer));
        }
        else
        {
            HWND hwnd = NULL;
            SP_IOleWindow spOleWindow;

            StopTimer();

            _pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow);
            if (spOleWindow)
                spOleWindow->GetWindow(&hwnd);

            if (hwnd)
            {
                UINT uDragDelay = GetProfileIntA("windows", "DragDelay", DD_DEFDRAGDELAY);
                KillTimer(hwnd, 1);
                if (uDragDelay)
                    SetTimer(hwnd, 1, uDragDelay, 0);
            }

            //  Bug 110575: During very quick selections we may get a mouse down and mouse up
            //  before setting the state to ST_WAIT2.  This causes us to be in this selection
            //  mode while the mouse button is already up.  We'll check to make sure that the
            //  mouse button is down before we initiate a selection.
            if (!pEvent->IsLeftButton())
            {
                if (  _pManager->IsInCapture()  )
                    ReleaseCapture();
                BecomePassive( TRUE );
                break;
            }

            HRESULT hrCapture;

            if ( ! _fTookCapture )
            {
                hrCapture = THR( TakeCapture());
                _fTookCapture = TRUE;
            }
            else
                hrCapture = S_OK;

            if (SUCCEEDED( hrCapture ))
            {
                BOOL fDidSelection = FALSE;
                IFC( DoSelection( pEvent, FALSE, &fDidSelection ));
                if (fDidSelection)
                    goto Cleanup;

                SetState( ST_DOSELECTION ) ;
            }

        }
        break;

    case A_1_4: // ST_WAIT1 & EVT_LBUTTONUP
        {
            ClearSelection();
            SetState( ST_WAITBTNDOWN1 ) ;

            //
            // Scenario.  User left mouse downs on something that is already
            // selected, and then immediately releases the left mouse button.
            // A click has occured on selected text.  We can't swallow the
            // LBUTTON_UP event because the on-click needs to occur for
            // elements (so that navigation can occur if the user clicked on a
            // hyperlink, for instance)
            //
            hr = S_FALSE;
        }
        break;

    case A_1_2: // ST_WAIT1 & EVT_MOUSEMOVE
        {
            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_FALSE;
            SetState( ST_DRAGOP );
        }
        break;

    case A_2_14: // ST_DRAGOP & EVT_LBUTTONUP
        // hr = SetCaret( pMessage );
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        IFC( _pManager->PositionCaret( _pDispStartPointer ));
        break;

    case A_3_14 :  // ST_MAYDRAG & (EVT_LBUTTONUP || EVT_RBUTTONUP)
    case A_4_14m : // ST_WAITBTNDOWN1 & EVT_MOUSEMOVE (was b05)
        // In this case, the cp is *never* updated to the
        // new position. So go and update it. Remember SetCaret
        // also kills any existing selections.
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        //  If the user clicked in an atomic element that was part of
        //  a text selection, we don't want to clear the selection.
        //  In this case the selection would have been constrained to
        //  the atomic element and we want to keep it that way on mouse up.
        if ( _fMouseClickedInAtomicSelection)
        {
            BecomePassive();
        }
        else
        {
            ClearSelection();

            IFC( _pManager->PositionCaret( _pDispStartPointer ));
        }
        break;

    case A_3_2: // ST_MAYDRAG & EVT_TIMER

        if ( _pManager->IsInTimer() )
            StopTimer();
        // Convert to a move message with correct coordinates
        POINT pt;
        GetMousePoint(&pt);
        if ( IsValidMove( & pt ) )
        {
            hr = S_FALSE;
            SetState( ST_DRAGOP );
            fHandledDrag = TRUE;
            DoTimerDrag();
        }

        break;

    case A_3_2m: // ST_MAYDRAG & EVT_MOUSEMOVE
        {
            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_FALSE;
            SetState( ST_DRAGOP );
        }
        break;

    case A_4_8 :// ST_WAITBTNDOWN1 & EVT_INTDBLCLK
    case A_7_8 :// ST_WAITBTNDOWN2 & EVT_LBUTTONUP (was b60)
    case A_16_8:
        if ( _fDragDrop )
            _fDragDrop = FALSE;


        StopTimer();
        StartTimer();

        // only do this for this branch of the state diagram.
        // the event for the other branch is fired in A_16_7
        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) ); 
            
        // if the bubblable onselectstart event is cancelled, don't
        // go into DoSelection State, and cnx the tracker

        if ( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            BOOL fPositioned = FALSE;
            IGNORE_HR( _pDispStartPointer->IsPositioned( & fPositioned));
            if ( ! fPositioned )
            {
                //
                // Bad things have happened - probably tree has been torn down from under us.
                // we shut down this tracker.
                //
                _pManager->EnsureDefaultTrackerPassive();
                goto Cleanup;
            }
            
            IFC(_pManager->PositionCaret( _pDispStartPointer ));
        }
        else
        {
            BOOL    fDidSelection = FALSE;
            hr = DoSelectWord( pEvent, &fDidSelection );
            if (fDidSelection)
                goto Cleanup;

            SetState( ST_SELECTEDWORD );
#ifdef UNIX
            if (CheckSelectionWasReallyMade())
            {
                if (!_hwndDoc)
                    _pManager->GetEditor()->GetViewServices()->GetViewHWND(&_hwndDoc);
                SendMessage(_hwndDoc, EVT_GETTEXTPRIMARY, (WPARAM)&_firstMessage, IDM_CLEARSELECTION);
            }
#endif
        }
        break;

    case A_6_14 :   // ST_DOSELECTION & (EVT_LBUTTONUP || EVT_RBUTTONUP )
    case A_9_14 :   // ST_SELECTEDPARA & EVT_LBUTTONUP (was b90)
    case A_10_14m : // ST_WAIT3RDBTNDOWN & EVT_MOUSEMOVE
    case A_12_14 :  // ST_MAYSELECT2 & EVT_LBUTTONUP (was c50)
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( Action == A_6_14 )
        {
            BOOL        fDidSelection = FALSE;
            hr = THR( DoSelection( pEvent, TRUE, &fDidSelection ));
            if (fDidSelection)
            {
                goto Cleanup;
            }
            else if (hr)
            {
                AssertSz(0, "An error occurred in DoSelection");

                //  An error occurred in DoSelection.  Since we're going to go passive
                //  here, we'll ignore this error and continue.
                hr = S_OK;
            }

#ifdef UNIX // Now we have a selection we can paste using middle button paste.
            if (CheckSelectionWasReallyMade())
            {
                if (!_hwndDoc)
                    _pManager->GetEditor()->GetViewServices()->GetViewHWND(&_hwndDoc);
                SendMessage(_hwndDoc, EVT_GETTEXTPRIMARY, (WPARAM)&_firstMessage, IDM_CLEARSELECTION);
            }
#endif
        }

        if ( _fState == ST_SELECTEDPARA )
        {
            hr = S_FALSE; // don't consume event so on-click gets fired.
        }

        BecomePassive( TRUE);


        break;

    case A_6_6:     // ST_DOSELECTION & EVT_TIMER (CSynthEditEvent already constructed)
    case A_6_6m:    // ST_DOSELECTION & EVT_MOUSEMOVE

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }

        // Remain in same state
        break;

    case A_10_9: // ST_WAIT3RDBTNDOWN & EVT_LBUTTONDOWN

        if ( _pManager->IsInTimer() )
            StopTimer();

        SetState( ST_SELECTEDPARA );
        {
            BOOL    fDidSelection = FALSE;
            DoSelectParagraph( pEvent, &fDidSelection );
            if (fDidSelection)
                goto Cleanup;
        }
        break;

    case A_11_6: // ST_MAYSELECT1 & EVT_MOUSEMOVE (was c40)
        // if the bubblable onselectstart event is cancelled, don't
        // go into DoSelection State, and cnx the tracker

        //  Bug 110575: During very quick selections we may get a mouse down and mouse up
        //  before setting the state to ST_MAYSELECT1.  This causes us to be in this selection
        //  mode while the mouse button is already up.  We'll check to make sure that the
        //  mouse button is down before we initiate a selection.
        if (!pEvent->IsLeftButton())
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();
            if ( _pManager->IsInTimer() )
                StopTimer();
            BecomePassive( TRUE );
            break;
        }

        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );
        if ( !fSelect )
        {
            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            _pManager->PositionCaret( _pDispStartPointer );
            break;
        }
        // else not canceled so fall through

    case A_8_6 : // ST_SELECTEDWORD & EVT_MOUSEMOVE
    case A_12_6: // ST_MAYSELECT2 & EVT_MOUSEMOVE (was c60)
        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( ! _fTookCapture )
        {
            TakeCapture();
            _fTookCapture = TRUE;
        }

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }
        SetState( ST_DOSELECTION );
        break;

    case A_9_6: // ST_SELECTEDPARA & EVT_MOUSEMOVE
        if ( ! _fTookCapture )
        {
            TakeCapture();
            _fTookCapture = TRUE;
        }

        {
            BOOL    fDidSelection = FALSE;
            IFC( DoSelection (pEvent, FALSE, &fDidSelection));
            if (fDidSelection)
                goto Cleanup;
        }
        SetState( ST_DOSELECTION );
        break;

    case A_8_10: // ST_SELECTEDWORD & EVT_LBUTTONUP

        StopTimer();
        StartTimer();

        SetState( ST_WAIT3RDBTNDOWN );
        break;

    case A_1_14  : // ST_WAIT1          & EVT_RBUTTONUP
    case A_2_14r : // ST_DRAGOP         & EVT_RBUTTONUP
    case A_7_14  : // ST_WAITBTNDOWN2   & EVT_KEYDOWN
                   // ST_WAITBTNDOWN2   & EVT_MOUSEMOVE
    case A_10_14 : // ST_WAIT3RDBTNDOWN & EVT_KEYDOWN
    case A_11_14 : // ST_MAYSELECT1     & EVT_LBUTTONUP (was c30)
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        if ( _pManager->IsInTimer() )
            StopTimer();

        if ( _fMadeSelection )
        {
            BecomePassive( TRUE );
        }
        else
        {
            //
            // Scenario.  User left mouse downs on text in document, and holds
            // mouse button down without moving the mouse.  We swallow the
            // LBUTTON_UP because the message occurs 'in selection', but we
            // still need to post an EVT_CLICK.  In order to do this, we have
            // to return S_FALSE
            //
            hr = (Action == A_11_14) ? S_FALSE : S_OK;
            _pManager->PositionCaret( _pDispStartPointer );
        }
        break;

    //
    // ST_KEYDOWN
    // Become Passive & Handle the Key.
    //
    // This is a "psuedo-state" - we really transition to ST_PASSIVE
    // however - we do a HandleKeyDown as well.
    //
    //
    case A_1_15:
    case A_3_15:
    case A_4_15:
    case A_5_15:
    case A_7_15:
    case A_8_15:
    case A_10_15:
    case A_12_15:
    case A_9_15:
    case A_16_15:
        //
        // Ignore the Control Key, as it's used in Drag & Drop or during selection etc.
        //
        if ( pEvent->IsControlKeyDown())
            break;

        BecomePassive( TRUE);
        //
        // If no selection was made - become passive will turn active tracker to a caret.
        // so we check for our state.
        //
        if ( IsPassive() )
        {
            hr = HandleKeyDown(
                        pEvent);
        }
        else
        {
            Assert( _pManager->GetActiveTracker() != this );
            hr = _pManager->RebubbleEvent( pEvent );
        }

        break;

    default:
        AssertSz (0, "Should never come here!");
        break;
    }

    if ( ( _fState == ST_DRAGOP ) &&
         ( ! fHandledDrag ) )
    {
        BecomePassive(); // DO NOT PASS A NOTIFY CODE HERE - IT WILL BREAK DRAG AND DROP
        hr = S_FALSE;
        DoTimerDrag();
    }

//
// We dump the select state for Dbg on - and the trace tag is on. Or we compiled with TRACKER_RETAIL_DUMP
//

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif

        DumpSelectState( pEvent, Action ) ;

#if DBG == 1
    }
#endif

#endif


Cleanup:
    RRETURN1 ( hr, S_FALSE );

}

//+====================================================================================
//
// Method: HandleChar
//
// Synopsis: Delete the Selection, and cause this tracker to end ( & kill us ).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::HandleChar(
                CEditEvent* pEvent )

{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spFlowElement;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL     bMultiLine = VARIANT_FALSE;
    SP_IMarkupPointer   spStart, spEnd;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

    LONG keyCode;
    IFC( pEvent->GetKeyCode( & keyCode ));

    if ( _pManager->IsContextEditable() && IsPassive() )
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(spStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(spEnd) );

        if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ))
        {
            if ( keyCode == VK_ESCAPE )
                goto Cleanup; // BAIL - we don't want to type a character

            if (keyCode == VK_RETURN)
            {
                Assert(_pDispStartPointer);
                IFR( _pDispStartPointer->GetFlowElement(&spFlowElement) );
                if ( spFlowElement )
                {
                    IFR(spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                    IFR(spElement3->get_isMultiLine(&bMultiLine));
                }


                if (bMultiLine)
                {
                    IFC( _pManager->DeleteRebubble( pEvent ));
                }
                else
                    return S_FALSE;
            }
            else
            {

                if (keyCode == VK_TAB)
                {
                    BOOL fPre;

                    IFC( GetStartSelection()->PositionMarkupPointer(spStart) );
                    IFC( GetEditor()->IsPointerInPre(spStart, &fPre));
                    if (fPre)
                    {
                        IFC( GetEndSelection()->PositionMarkupPointer(spEnd) );
                        IFC( GetEditor()->IsPointerInPre(spStart, &fPre));
                        if (fPre)
                        {
                            IFC( _pManager->DeleteRebubble( pEvent ));
                            goto Cleanup;
                        }
                    }
                    hr = S_FALSE;
                }
                else if( keyCode >= ' ' )
                {
                    IFC( _pManager->DeleteRebubble( pEvent ));
                }
            }
        }
    }
Cleanup:

    RRETURN1( hr, S_FALSE);
}


HRESULT
CSelectTracker::HandleKeyUp(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG keyCode;

    hr = HandleDirectionalKeys(pEvent);
    if (S_FALSE == hr)
    {
        IGNORE_HR( pEvent->GetKeyCode( & keyCode ));
        if ( (keyCode == VK_SHIFT ) && ( _fShift ) )
        {
            BecomePassive(TRUE);
            _fShift = FALSE;

            if (  _pManager->IsInCapture()  )
                ReleaseCapture();

            if ( _pManager->IsInTimer() )
                StopTimer();
            hr = S_OK;
        }
    }

    RRETURN1( hr, S_FALSE);
}


HRESULT
CSelectTracker::HandleKeyDown(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    CSpringLoader * psl;
    int iWherePointer = SAME;
    long eLineDir= LINE_DIRECTION_LeftToRight;
    SP_ILineInfo spLineInfo;
    LONG keyCode;
    BOOL   fVertical = FALSE;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spMarkup;
    BOOL                fSelectionChanged = FALSE;
    BOOL                fCheckIfMovedIntoAtomicElement = FALSE;
    int                 iDirectionForAtomicAdjustment = SAME;

    Assert( IsPassive());

    if ( _pManager->IsContextEditable() )
    {

        IGNORE_HR( pEvent->GetKeyCode( & keyCode ));

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        
        switch( keyCode )
        {

            case VK_BACK:
            case VK_F16:
            {
                if ( _pManager->IsContextEditable() )
                {
                    psl = GetSpringLoader();
                    if (psl && _pDispStartPointer)
                    {
                        BOOL fDelaySpringLoad;
                        SP_IMarkupPointer spPointer;

                        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                        IFC( GetStartSelection()->PositionMarkupPointer(spPointer) );
                        IFC( MustDelayBackspaceSpringLoad(psl, spPointer, &fDelaySpringLoad) );

                        if (!fDelaySpringLoad)
                            IFC( psl->SpringLoad( spPointer, SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                    }

                    if ( pEvent->IsControlKeyDown() )
                    {
                        //
                        // TODO - make this use GetMoveDirection - after your checkin
                        //
                        IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
                        IFC( _pManager->PositionCaret( (iWherePointer == RIGHT ) ?
                                                        _pDispStartPointer :
                                                        _pDispEndPointer ,
                                                        pEvent ));
                    }
                    else
                    {
                        if ( CheckSelectionWasReallyMade())
                        {
                            IFC( _pManager->DeleteNoBubble());
                        }
                        else
                        {
                            _pManager->PositionCaret( _pDispStartPointer );
                        }
                    }
                }
            }
            break;


            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
                IFC( _pDispEndPointer->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_lineDirection(&eLineDir) );
                Assert( _pManager );

                //
                // See if this is in vertical layout
                //
                IFC( _pDispEndPointer->PositionMarkupPointer(spMarkup) );
                IFC( spMarkup->CurrentScope(&spElement) );
                IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );

                if (!IsShiftKeyDown())
                {
                    //
                    //  fForward    *1
                    //  fRTL        *2
                    //
                    BOOL  fForward = GetMoveDirection() ? TRUE: FALSE;
                    BOOL  fRTL     = (eLineDir == LINE_DIRECTION_LeftToRight) ? FALSE : TRUE;
                    UINT  nState   = 0;

                    if (fForward)    nState += 1;
                    if (fRTL)        nState += 2;

                    if (!fVertical) // horizontal
                    {
                        if (VK_LEFT == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 1 || nState == 2) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = LEFT;
                            break;
                        }
                        else if (VK_RIGHT == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 0 || nState == 3) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = RIGHT;
                            break;
                        }
                    }
                    else    // vertical
                    {
                        if (VK_UP == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 1 || nState == 2) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = LEFT;
                            break;
                        }
                        else if (VK_DOWN == keyCode)
                        {
                            IFC( _pManager->PositionCaret( (nState == 0 || nState == 3) ? _pDispStartPointer : _pDispEndPointer ));
                            fSelectionChanged = TRUE;
                            fCheckIfMovedIntoAtomicElement = TRUE;
                            iDirectionForAtomicAdjustment = RIGHT;
                            break;
                        }
                    }
                    //
                    // only break for !ShiftKeyDown.
                    //
                }
                //
                // shift key is down - we fall thru.
                //

                // don't put a break here. We want to fall through
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            {
                if ( IsShiftKeyDown() )
                {
                    SP_IMarkupPointer   spOrigEndPointer;
                    SP_IHTMLElement spAtomicElement;
                    SP_IHTMLElement spElementAtSelectionAnchor;
                    SP_IHTMLElement spElementAtSelectionEnd;
                    CARET_MOVE_UNIT eMoveUnit = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);
                    Direction       eDirection = GetPointerDirection(eMoveUnit);
                    BOOL            fUpdateSelection = FALSE;

                    //  Keep track of where this end pointer was so that we can determine
                    //  whether we need to adjust out of an atomic element.
                    IFC( GetEditor()->CreateMarkupPointer(&spOrigEndPointer) );
                    IFC( _pDispEndPointer->PositionMarkupPointer(spOrigEndPointer) );

                    _fShift = TRUE;

                    //
                    // We don't have a shift pointer.  This can happen if the user shift extends a current
                    // selection.  In this case, update the shift pointer with the current end of selection
                    //
                    //
                    IFC( GetCurrentScope(_pDispShiftPointer, &spAtomicElement) );
                    if ( !HasShiftPointer() || _pManager->CheckAtomic(spAtomicElement) == S_OK )
                    {
                        IFC( UpdateShiftPointer( _pDispEndPointer ) );
                    }

                    //  If the user clicked in an atomic element and then does a shift-arrow to extend the selection
                    //  we want to keep the atomic element in the selection.  So, we need to check the selection
                    //  anchor pointer to see if the user clicked in an atomic element.  We will need to swap start
                    //  and end pointers as well depending on which direction the selection is extended.

                    IFC( GetCurrentScope(_pDispSelectionAnchorPointer, &spElementAtSelectionAnchor) );
                    if ( _pManager->CheckAtomic(spElementAtSelectionAnchor) ==  S_OK)
                    {
                        SP_IDisplayPointer      spDispTestPointer;
                        BOOL                    fSwapPointersForAtomicSelectionAnchor;

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispTestPointer) );

                        if (eDirection == LEFT)
                        {
                            //  We need to swap pointers if the end pointer is at the right edge of the atomic element
                            //  and the start pointer is to the left of the anchor pointer.

                            IFC( EdUtil::AdjustForAtomic(GetEditor(), spDispTestPointer, spElementAtSelectionAnchor, FALSE, RIGHT) );
                            IFC( _pDispEndPointer->IsLeftOf(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            if (!fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispEndPointer->IsEqualTo(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                            if (fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispStartPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                        }
                        else
                        {
                            //  We need to swap pointers if the end pointer is at the left edge of the atomic element
                            //  and the start pointer is to the right of the anchor pointer.

                            IFC( EdUtil::AdjustForAtomic(GetEditor(), spDispTestPointer, spElementAtSelectionAnchor, FALSE, LEFT) );
                            IFC( _pDispEndPointer->IsRightOf(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            if (!fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispEndPointer->IsEqualTo(spDispTestPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                            if (fSwapPointersForAtomicSelectionAnchor)
                            {
                                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fSwapPointersForAtomicSelectionAnchor) );
                            }
                        }

                        if (fSwapPointersForAtomicSelectionAnchor)
                        {
                            SP_IDisplayPointer      spDispTemp;

                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispTemp) );
                            IFC( spDispTemp->MoveToPointer(_pDispStartPointer) );
                            IFC( _pDispStartPointer->MoveToPointer(_pDispEndPointer) );
                            IFC( _pDispEndPointer->MoveToPointer(spDispTemp) );
                            IFC( _pDispShiftPointer->MoveToPointer(_pDispEndPointer) );
                            IFC( AdjustPointerForInsert( _pDispEndPointer, RIGHT, RIGHT ));
                            IFC( _pDispEndPointer->PositionMarkupPointer(spOrigEndPointer) );
                        }
                    }

                    hr = MoveSelection( eMoveUnit );

                    //  See if our selection ended up in an atomic element,
                    IFC( GetCurrentScope(_pDispEndPointer, &spElementAtSelectionEnd) );
                    if ( _pManager->FindAtomicElement(spElementAtSelectionEnd, &spAtomicElement) == S_OK )
                    {
                        //  We need to first see if we moved into the inside edge of the atomic element.
                        //  If so, we do not want to move again.

                        SP_IMarkupPointer   spPointer;
                        BOOL                fAtOutsideEdge = FALSE;
                        
                        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                        IFC( spPointer->MoveAdjacentToElement( spAtomicElement,
                                            (eDirection == RIGHT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
                        IFC( spPointer->IsEqualTo(spOrigEndPointer, &fAtOutsideEdge) );

                        if (!fAtOutsideEdge)
                        {
                            SP_IMarkupPointer   spAnotherPointer;

                            IFC( GetEditor()->CreateMarkupPointer(&spAnotherPointer) );
                            IFC( spAnotherPointer->MoveAdjacentToElement( spAtomicElement,
                                            (eDirection == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                            IFC( spAnotherPointer->IsEqualTo(spOrigEndPointer, &fAtOutsideEdge) );
                        }
                        if (fAtOutsideEdge)
                        {
                            IFC( spPointer->MoveAdjacentToElement( spAtomicElement,
                                                    (eDirection == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                        }

                        IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
                        fUpdateSelection = TRUE;
                    }

                    IFC( GetCurrentScope(_pDispStartPointer, &spAtomicElement) );
                    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
                    {
                        IFC( AdjustOutOfAtomicElement(_pDispStartPointer, spAtomicElement, eDirection) );
                        fUpdateSelection = TRUE;
                    }

                    if (fUpdateSelection)
                    {
                        IFC( UpdateSelectionSegments() );
                    }

                    //
                    // If the selection pointers collapse to the same point - we will start a caret.
                    //
                    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
                    if ( iWherePointer == SAME )
                    {
                        ClearSelection();
                        _pManager->PositionCaret( _pDispStartPointer );
                        fCheckIfMovedIntoAtomicElement = TRUE;
                    }
                }
                else if ( _pManager->IsContextEditable())
                {
                    SP_IDisplayPointer spDispPointer;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

                    CARET_MOVE_UNIT cmuMove;
                    cmuMove = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical ) ;

                    if ( cmuMove != CARET_MOVE_NONE )
                    {
                        IFC( GetCaretStartPoint( cmuMove,
                                                 spDispPointer ));

                        _pManager->PositionCaret( spDispPointer );

                        if (_pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Caret)
                        {
                            //
                            // Update the CaretTracker's _ptVirtualCaret if current _ptVirtualCaret
                            // preserves the caret "xy location". Which implies that this is a
                            // result of keynav into Atomic element. 
                            //
                            if (cmuMove == CARET_MOVE_PREVIOUSLINE || cmuMove == CARET_MOVE_NEXTLINE)
                            {
                                {
                                    SP_IMarkupPointer   spMarkup;
                                    POINT               ptLoc;
                                    BOOL                fFreeze;
                                    CCaretTracker   *pCaretTracker = DYNCAST(CCaretTracker, _pManager->GetActiveTracker());
                                    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
                                    IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                                    IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
                                    //
                                    // Update the pointer/(and location if possible).
                                    //
                                    fFreeze = pCaretTracker->GetVirtualCaret().FreezePosition(FALSE);
                                    IFC( pCaretTracker->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) ); 
                                    pCaretTracker->GetVirtualCaret().FreezePosition(fFreeze);
                                }
                            }
                        }

                        fSelectionChanged = TRUE;
                        fCheckIfMovedIntoAtomicElement = TRUE;

                        if (keyCode == VK_HOME)
                            iDirectionForAtomicAdjustment = LEFT;
                        else if (keyCode == VK_END)
                            iDirectionForAtomicAdjustment = RIGHT;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
            break;

#ifndef NO_IME
            case VK_KANJI:
                if (   949 == GetKeyboardCodePage()
                    && _pManager->IsContextEditable()
                    && EndPointsInSameFlowLayout())
                {
                    BOOL fEndAfterStart;
                    SP_IMarkupPointer spPointer;

                    IFC( _pDispEndPointer->IsRightOf( _pDispStartPointer, &fEndAfterStart ) );
                    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

                    if (fEndAfterStart)
                    {
                        IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) );
                    }
                    else
                    {
                        IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
                    }

                    _pManager->StartHangeulToHanja( spPointer, pEvent );
                }
                hr = S_OK;
                break;
#endif // !NO_IME
        }

        //  We don't want to position our caret inside of the atomic element, so check to make sure that
        //  we are outside of it.  We only care about cases where we have transitioned to a caret.  We
        //  don't want to transition back to atomic selection here.

        if (fCheckIfMovedIntoAtomicElement && _pManager->GetTrackerType() == TRACKER_TYPE_Caret)
        {
            SP_IHTMLCaret       spCaret;
            SP_IDisplayPointer  spDispPointer;

            IFC( GetDisplayServices()->GetCaret( &spCaret ));
            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
            IFC( GetCurrentScope(spDispPointer, &spElement) );

            if (_pManager->CheckAtomic(spElement) == S_OK)
            {
                SP_IHTMLCaret pc;
                IFC( GetDisplayServices()->GetCaret( &pc ));
                IFC( AdjustOutOfAtomicElement(spDispPointer, spElement, iDirectionForAtomicAdjustment) );
                IFC( pc->MoveCaretToPointer(spDispPointer, FALSE, CARET_DIRECTION_INDETERMINATE) );
            }
        }

        if (fSelectionChanged)
        {
            CSelectionChangeCounter selCounter(_pManager);
            selCounter.SelectionChanged();
        }
        
        if (S_FALSE == hr)
        {
            hr = HandleDirectionalKeys(pEvent);
        }

    }

Cleanup:

    return ( hr );
}









//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for EVT_TIMER messages.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::OnTimerTick()
{
    HRESULT                 hr = S_OK;

    if ( _pManager->IsInFireOnSelectStart() )
        return S_OK; // do nothing for timer ticks when we're in the middle of OnSelectStart

    StopTimer();

    switch (_fState)
    {
    case ST_MAYDRAG: // A_3_2 - start a drag.
        BecomePassive(); // DO NOT PASS A NOTIFY CODE HERE - IT WILL BREAK DRAG AND DROP
        hr = DoTimerDrag();
        goto Cleanup; // bail - as the tracker is dead.

    case ST_WAIT1:  // === A_1_3
        StartTimer();
        SetState( ST_MAYDRAG ) ;
        break;

    case ST_WAITBTNDOWN1: // === A_4_14t == A_4_14m
        // In this case, the cp is *never* updated to the
        // new position. So go and update it. Remember SetCaret
        // also kills any existing selections.

        if (  _pManager->IsInCapture()  )
            ReleaseCapture();

        // If we clicked in an atomic element, do not clear the selection during this timer event.
        if ( _fMouseClickedInAtomicSelection)
        {
            BecomePassive();
        }
        else
        {
            ClearSelection();

            _pManager->PositionCaret( _pDispStartPointer );

            {
                CSelectionChangeCounter selCounter(_pManager);
                selCounter.SelectionChanged();
            }
        }
        break;

    case ST_WAIT2:  // === A_5_11

        SetState( ST_MAYSELECT1 );
        break;

    case ST_WAITCLICK:
    case ST_WAITBTNDOWN2:   // === A_7_14
    case ST_WAIT3RDBTNDOWN: // === A_10_14
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();


        if (( _fMadeSelection ) && ( CheckSelectionWasReallyMade() ))
        {
            BecomePassive( TRUE );
        }
        else
        {
            _pManager->PositionCaret( _pDispStartPointer );
        }
        break;

    case ST_SELECTEDWORD:   // === A_8_12

        SetState( ST_MAYSELECT2 ) ;
        break;


    case ST_PASSIVE:
        if (  _pManager->IsInCapture()  )
            ReleaseCapture();
        break;
    // ST_START, ST_DRAGOP, ST_MAYDRAG, ST_DOSELECTION,
    // ST_SELECTEDPARA, ST_MAYSELECT1, ST_MAYSELECT2
    default:
        AssertSz (0, "Invalid state & message combination!");
        break;
    }

    WHEN_DBG( DumpSelectState( NULL, A_UNK, TRUE ) );

Cleanup:
    RRETURN(hr);
}

#ifndef NO_IME
CSpringLoader *
CIme::GetSpringLoader()
{
    CSpringLoader * psl = NULL;
    CHTMLEditor   * pEditor;

    if (!_pManager)
        goto Cleanup;

    pEditor = _pManager->GetEditor();

    if (!pEditor)
        goto Cleanup;

    psl = pEditor->GetPrimarySpringLoader();

Cleanup:
    return psl;
}

HRESULT
CSelectTracker::HandleImeStartComposition(
    CEditEvent* pEvent)
{
    // We want to kill the current selection.
    // Bubble on up: CSelectTracker -> CCaretTracker -> CImeTracker

    if( GetEditor()->PointersInSameFlowLayout( _pDispStartPointer, _pDispEndPointer, NULL))
    {
        if ( _pManager->IsContextEditable() )
        {
            _pManager->DeleteRebubble( pEvent );
        }
    }

    return S_OK;
}

#endif // !(NO_IME)

//
//
// Selection Handling & Management
//
//

//+=================================================================================================
// Method: Begin Selection
//
// Synopsis: Do the things you want to do at the start of selection
//             This will involve updating the mouse position, and telling the Selection to add a Segment
//
//--------------------------------------------------------------------------------------------------

HRESULT
CSelectTracker::BeginSelection(
                        CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    POINT pt;
    BOOL fSelect;
    WHEN_DBG( int startCp;)
    SP_IHTMLElement spFlowElement;
    SP_IHTMLElement spAtomicElement;
    SP_IHTMLElement spBodyElement;
    SP_IDisplayPointer  spDispTempTestPointer;
    SP_IMarkupPointer   spPointer;
    BOOL    fClickOnAtomicElement = FALSE;

    Assert( _pDispStartPointer );

#if DBG == 1
    VerifyOkToStartSelection(pEvent);
    _ctScrollMessageIntoView = 0;
#endif

#if DBG == 1
    IFC( pEvent->GetPoint( & pt ));
    TraceTag(( tagSelectionTrackerState, "\n---BeginSelection---\nMouse:x:%d,y:%d", pt.x, pt.y));
#endif

    IFC( pEvent->MoveDisplayPointerToEvent ( _pDispStartPointer, NULL ));
    IFC( _pDispSelectionAnchorPointer->MoveToPointer(_pDispStartPointer) );

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(spPointer) );
    IGNORE_HR( GetEditor()->GetBody(&spBodyElement) );
    IFC( EdUtil::GetScrollingElement(GetMarkupServices(), spPointer, spBodyElement, &_pIScrollingAnchorElement, TRUE) );

#if DBG == 1
    startCp = GetCp( _pDispStartPointer );
#endif

    hr = MoveEndToPointer( _pDispStartPointer );
    if ( hr )
    {
        AssertSz( 0, "CSelectTracker::BeginSelection: Unable to position EndPointer");
        goto Cleanup;
    }

    // If atomic selection is on for the current element, we need to select the entire element
    // on the initial mouse click.

    IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
    if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
    {
        BOOL    fStartDidSelection = FALSE;
        BOOL    fEndDidSelection = FALSE;

        IFC( AdjustForAtomic( _pDispStartPointer, spAtomicElement, TRUE , & pt, &fStartDidSelection));
        IFC( AdjustForAtomic( _pDispEndPointer, spAtomicElement, FALSE , & pt, &fEndDidSelection));

        if (fStartDidSelection || fEndDidSelection)
        {
            goto Cleanup;
        }

        fClickOnAtomicElement = TRUE;
        _fStartIsAtomic = TRUE;
        _fStartAdjustedForAtomic = TRUE;

        //  Bug 102485: check to make sure click didn't occur in a selection (_fState != ST_WAIT1)
        //  before setting state to ST_WAIT2.
        if (_fState != ST_WAIT1)
            SetState( ST_WAIT2 );

        SetMadeSelection(TRUE);
        StartTimer();
        StartSelTimer();
    }

    //
    // BUG BUG - this is a bit expensive - but here I want to hit test EOL
    // and previously I didn't.
    //
    // Why do we want to hit test EOL here ? Otherwise we'll get bogus changes
    // in direction.
    //


    ReplaceInterface(&spDispTempTestPointer, _pDispTestPointer);

    //  If we adjusted for an atomic element, we want to move the test pointer with it.  The
    //  event pt may be inside of a nested markup.  We need to make sure that these pointers
    //  remain in the same markup.
    if (_fStartAdjustedForAtomic)
    {
        IFC( _pDispTestPointer->MoveToPointer( _pDispStartPointer ));
    }
    else
    {
        IFC( pEvent->MoveDisplayPointerToEvent( _pDispTestPointer, NULL , TRUE ));
    }

    if (_pDispTestPointer == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    IFC( pEvent->GetPoint( & pt ));
    IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));

    //
    // Set the tree the mouse is in.
    //

    if ( ! _fDragDrop )
    {
        BOOL		fSameMarkup;

        hr = ConstrainSelection( TRUE , & pt );

        // ConstrainSelection may have moved start pointer out of the markup where the event occurred.  In this
        // case we want to make sure we move the test pointer out with it to keep them in the same markup.
        IGNORE_HR( ArePointersInSameMarkup(GetEditor(), _pDispTestPointer, _pDispStartPointer, &fSameMarkup) );
        if (!fSameMarkup)
        {
	        IFC( _pDispTestPointer->MoveToPointer( _pDispStartPointer ));
        }

        IFC( CreateSelectionSegments() );

#if DBG == 1
        {
            SP_ISegmentList spSegmentList;
            BOOL            fEmpty = FALSE;
            HRESULT         hrDbg;

            hrDbg = GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList );
            if( !hrDbg ) spSegmentList->IsEmpty(&fEmpty);

            Assert( !fEmpty );
        }
#endif

    }

    Assert( ! hr );

    _ptCurMouseXY.x = _anchorMouseX = pt.x;
    _ptCurMouseXY.y = _anchorMouseY = pt.y;

    if (!fClickOnAtomicElement)
    {
        IFC( GetCurrentScope(_pDispEndPointer, &spAtomicElement) );
        if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
        {
            _fStartIsAtomic = TRUE;
        }

        // ignore control-click for drag drop - they may want to copy
        if ( pEvent->IsControlKeyDown() && !_fDragDrop )
        {
            // Fire an event notification to determine whether to allow selection
            IFC( _pManager->FireOnSelectStart( pEvent, &fSelect, this ) );

            if( fSelect )
            {
                BOOL    fDidSelection = FALSE;
                DoSelectParagraph( pEvent, &fDidSelection );
                if (fDidSelection)
                    goto Cleanup;
                SetState( ST_SELECTEDPARA );
            }
        }
        else if( (pEvent->GetHitTestResult() & HT_RESULTS_Glyph) && !_fDragDrop )
        {
            IFC( DoSelectGlyph(pEvent) );
            SetState( ST_PASSIVE );
        }
        else
        {
            StartTimer();
            StartSelTimer();
        }
    }


    IFC( _pDispStartPointer->GetFlowElement( & spFlowElement ));
    IFC( AttachPropertyChangeHandler( spFlowElement ));

Cleanup:
    if( FAILED(hr ))
    {
        //
        // We should have NEVER "began selection" on a place where we knew
        // we wouldn't be able to position a display pointer
        //
        Assert( hr != CTL_E_INVALIDLINE );

        _pManager->EnsureDefaultTrackerPassive( pEvent );

        if ( _pManager->IsInCapture())
            ReleaseCapture();
        if ( _pManager->IsInTimer())
            StopTimer();
    }

    RRETURN ( hr );
}

//+=================================================================================================
// Method: During Selection
//
// Synopsis: Do the things you want to do at the during a selection
//             Tell the selection to extend the current segment.
//
//--------------------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DoSelection(
                    CEditEvent* pEvent,
                    BOOL fAdjustSelection /*=FALSE*/,
                    BOOL* pfDidSelection /*=NULL*/)
{
    HRESULT hr = S_OK;
    Assert( _pDispEndPointer );

    BOOL fValidTree = TRUE ;
    BOOL fAdjustedSel = FALSE;
    int iWherePointer = SAME;
    BOOL fValidLayout = FALSE;
    HRESULT hrTestTree;
    BOOL fInEdit;
    SP_IMarkupPointer spPointer;
    SP_IHTMLElement spFlowElement;
    SP_IHTMLElement     spElement;
    SP_IDisplayPointer  spDispPointer;
    POINT pt;
    BOOL fSameMarkup = TRUE;
    BOOL fScrollSelectAnchorElement = FALSE;

#if DBG==1
    int endCp = 0;
    int startCp = 0;
    int testCp = 0;
    int oldEndCp = GetCp( _pDispEndPointer );
    int oldStartCp = GetCp( _pDispStartPointer );
    int newSelSize = 0;
    int oldSelSize = 0;
    int selDelta = 0;

    Assert(GetEditor()->ShouldIgnoreGlyphs() == FALSE);
#endif

    IFC( pEvent->GetPoint( & pt ));

    Assert( ! _fDragDrop );

    if (  fAdjustSelection ||
          ( pt.x != _ptCurMouseXY.x) ||
          ( pt.y != _ptCurMouseXY.y) ||
          ( pEvent->GetType() == EVT_TIMER ) )  // ignore spurious mouse moves.
    {
        //
        // When performing a selection, always pass NULL into the MoveDisplayPointerToEvent()
        // method if we are inside our editable element.  This way, hit testing works correctly
        // on elements with their own flow layout (like images, tables, etc.) that need to be hit
        // tested against their own layout, rather than the editable element (which could be the body,
        // for instance).  If we are outside our editable element, then pass in the editable element
        // to perform hit testing against.  This allows virtual hit testing to occur on things
        // like textareas.
        //

        // We want to make sure that we don't position _pDispTestPointer into another markup since
        // it could lead to problems where we update selection segments with pointers in different
        // markups.  We'll move a temp disp pointer to the event and see if the event occurred in
        // the same markup as where the selection started.
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( pEvent->MoveDisplayPointerToEvent( spDispPointer,
                                                _pManager->IsInEditableClientRect( pt) == S_OK ?
                                                                        NULL :
                                                                        GetEditableElement() ,
                                                TRUE));
        IFC( ArePointersInSameMarkup(_pManager->GetEditor(), spDispPointer, _pDispStartPointer, &fSameMarkup) );
        if (!fSameMarkup)
        {
            goto Cleanup;
        }

        //  See if we are extending the selection outside of the element where the selection
        //  began.  If this is the case, we want to scroll the anchor element when we call
        //  ScrollMessageIntoView.  Otherwise we'll scroll the editable element, which could
        //  be something else.
        IFC( GetCurrentScope(spDispPointer, &spElement) );
        if ( _pIScrollingAnchorElement && spElement && !SameElements(spElement, _pIScrollingAnchorElement) )
        {
            fScrollSelectAnchorElement = TRUE;
        }

        IFC( _pDispTestPointer->MoveToPointer(spDispPointer) );

        IFC( _pDispTestPointer->GetFlowElement(&spFlowElement) );
        fValidLayout = SameLayoutForJumpOver( spFlowElement,
                                              _pManager->GetEditableFlowElement());

        //
        // Ensure that we are in the edit context, and that fValidTree is set properly.
        //
        hrTestTree = _pManager->IsInEditContext( _pDispTestPointer, & fInEdit );
        Assert( fInEdit || hrTestTree || fValidTree );
        if ( hrTestTree == CTL_E_INCOMPATIBLEPOINTERS )
        {
            fValidTree = FALSE;
        }

#if DBG ==1
        testCp = GetCp( _pDispTestPointer );

        if ( IsTagEnabled( tagShowSelectionCp ))
        {
           CHAR sEvent[50];
           pEvent->toString(  sEvent );
           TraceTag((tagShowSelectionCp, "SelectionCp:%ld Event:%s", testCp , sEvent ));
        }

        if ( testCp == gDebugTestPointerCp ||
          ( testCp >= gDebugTestPointerMinCp && testCp <= gDebugTestPointerMaxCp ) )
        {
             if ( IsTagEnabled(tagSelectionDumpOnCp))
             {
                 DumpTree( _pDispTestPointer );
             }
         }
#endif

        //  Determine which direction we are going.  We compare the test pointer and the
        //  previous test pointer.  If both are equal, we use the word selection direction.
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
        BOOL fDirection = (iWherePointer == SAME ) ?
                            ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( & pt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                            ( iWherePointer == RIGHT ) ;

        // We do virtual hit testing, so we should always have fValidTree
        Assert(fValidTree);

        if ( fValidTree || !fAdjustedSel )
        {
            if ( !fValidLayout || !fInEdit )
            {
                ELEMENT_TAG_ID eTag = TAGID_NULL;
                SP_IHTMLElement spAtomicElement;

                IFC( GetEditor()->GetMarkupServices()->GetElementTagId( spFlowElement, &eTag ));
                IFC( GetCurrentScope(_pDispTestPointer, &spAtomicElement) );

                if ( !fInEdit )
                {
                    Assert( ! fInEdit && fValidTree );
                    fAdjustedSel = TRUE;

                    //
                    // TODO - I don't think I need this special case anymore.
                    // MoveMarkupPointer should magically be fixing this.
                    // but too much risk to change this now
                    //


                    //
                    // Just move the End to the Test. Constrain Selection will fix up
                    //
                    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, _pDispTestPointer) );
                    IFC( _pDispEndPointer->MoveToPointer( _pDispTestPointer ));
                }
                else if ( _pManager->IsContextEditable() ||
                          IsJumpOverAtBrowse( spFlowElement, eTag ) ||
                          _pManager->CheckAtomic( spAtomicElement )== S_OK ) // we only jump over at edit time or you can jump over this thing.
                {
                    if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
                    {
                        IFC( AdjustEndForAtomic(spAtomicElement, pt, fDirection, pfDidSelection, &fAdjustedSel) );
                        if (pfDidSelection && *pfDidSelection)
                            goto Cleanup;
                    }
                    else
                        fAdjustedSel = AdjustForSiteSelectable() ;

                }

                if ( fAdjustedSel )
                {
                    SetMadeSelection( TRUE );
                    _ptCurMouseXY.x = pt.x;
                    _ptCurMouseXY.y = pt.y;
                    IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
                }
            }

            if ( ! fAdjustedSel )
            {
                _fEndConstrained = FALSE;

                iWherePointer = SAME;
                IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispEndPointer, _pDispTestPointer, & iWherePointer )); // DO NOT IFC'IZE this. We want to do the constrain for inputs.
                if ( iWherePointer != SAME  )
                {
                    if ( ! _pManager->IsWordSelectionEnabled()
                        WHEN_DBG( || IsTagEnabled( tagSelectionDisableWordSel ))
                       )
                    {
                        MoveEndToPointer( _pDispTestPointer );
                        fAdjustedSel = TRUE;
                    }
                    else
                    {
                        SP_IHTMLElement spAtomicElement;
                        IFC( GetCurrentScope(_pDispTestPointer, &spAtomicElement) );

                        if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
                        {
                            BOOL        fBetween = TRUE;

                            IFC( AdjustEndForAtomic(spAtomicElement, pt, fDirection, pfDidSelection, &fAdjustedSel) );

                            //  Bug 102482: If we positioned the end pointer such that our initial selection
                            //  hit point is outside of the current selection, readjust the start so that it
                            //  will contain the selection hit point.

                            IFC( _pDispEndPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
                            if (fBetween)
                            {
                                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
                                if (!fBetween)
                                {
                                    //  Okay, we need to readjust our start pointer
                                    IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );

                                    //  We are already prep'd from the AdjustEndForAtomic call.  Just
                                    //  update the selection segments 'cause we're gonna exit early.
                                    if (pfDidSelection && *pfDidSelection)
                                    {
                                        IFC( UpdateSelectionSegments() );
                                    }
                                }
                            }

                            if (pfDidSelection && *pfDidSelection)
                                goto Cleanup;
                        }
                        else
                        {
                            //
                            // WORKITEM - we can enable paragraph selection mode here
                            // We should be checking _fInParagraph here. We've cut this for now.
                            //
                            Assert( fInEdit );

                            IFC( DoWordSelection( pEvent, & fAdjustedSel,fDirection ));

                            if (  _fShift || IsShiftKeyDown() )
                            {
                                IFC( UpdateShiftPointer( _pDispEndPointer ));
                                _fShift = TRUE;
                            }
                        }
                    }

                    SetMadeSelection( TRUE );
                    _ptCurMouseXY.x = pt.x;
                    _ptCurMouseXY.y = pt.y;
                    if ( fAdjustedSel )
                        IFC( _pDispPrevTestPointer->MoveToPointer( _pDispTestPointer ));
                }
            }
        }

        //
        // Adjust the start if it's atomic. Do this only once.
        //
        if ( _fStartIsAtomic && ! _fStartAdjustedForAtomic )
        {
            SP_IHTMLElement     spElement;

            IFC( GetCurrentScope( _pDispStartPointer, &spElement) );
            IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE , & pt, pfDidSelection));

            _fStartAdjustedForAtomic = TRUE ;

            if (*pfDidSelection)
                goto Cleanup;

            fAdjustedSel = TRUE;
        }

        if ( fAdjustSelection || fAdjustedSel )
        {
            BOOL fDidAdjust = FALSE;

            if ( fAdjustSelection )
                IFC( AdjustSelection( & fDidAdjust ));

            if ( fDidAdjust || fAdjustedSel )
            {
                SP_IMarkupPointer spStartPointer;
                SP_IMarkupPointer spEndPointer;

                if (!fInEdit && fValidTree)
                {
                    IFC( ConstrainSelection( FALSE, & pt ) );
                }
#if  DBG == 1
                endCp = GetCp( _pDispEndPointer );
                startCp = GetCp( _pDispStartPointer );
                oldSelSize = oldEndCp - oldStartCp;
                newSelSize = endCp - startCp;
                selDelta  = newSelSize - oldSelSize;

                if ( endCp == gDebugEndPointerCp ||
                  ( ( newSelSize == 0 )  && (  oldSelSize != 0  ) ) )
                {
                    if ( IsTagEnabled(tagSelectionDumpOnCp))
                    {
                        DumpTree( _pDispEndPointer );
                    }
                }
#endif
                if ( _fDoubleClickWord ) // extra funky IE 4/Word behavior
                {
                    //  Determine which direction we are going.  We compare the test pointer and the
                    //  previous test pointer.  If both are equal, we use the word selection direction.
                    IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
                    BOOL fDirectionNew = (iWherePointer == SAME ) ?
                                        ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( & pt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                                        ( iWherePointer == RIGHT ) ;

                    //
                    // WORKITEM. We should be checking _fInParagraph here. We've cut this for now.
                    //
                    Assert( fInEdit );

                    IFC( DoWordSelection( pEvent, & fAdjustedSel,fDirectionNew ));
                }

                IFC( UpdateSelectionSegments() );

                IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
                IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );

                IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
                IFC( _pDispEndPointer->PositionMarkupPointer(spEndPointer) );
                ResetSpringLoader(_pManager, spStartPointer, spEndPointer);

                IFC( ScrollMessageIntoView( pEvent, fScrollSelectAnchorElement ));

            }
        }

        else if ( pEvent->GetType() == EVT_TIMER )
        {
           //
           // Always scroll into view on EVT_TIMER. Why ?
           // So we can scroll the mousepoint into view if necessary
           //

           IFC( ScrollMessageIntoView( pEvent, fScrollSelectAnchorElement ));
        }

        IFC( AdjustStartForAtomic(fDirection) );
    }

    SetLastCaretMove( CARET_MOVE_NONE ); // Reset this to say we didn't have a MouseMove.
Cleanup:

    if (fAdjustedSel)
    {
        IGNORE_HR( EnsureAtomicSelection( pEvent ) );
    }

    if( hr == CTL_E_INVALIDLINE )
    {
        //
        // We tried to move selection into a place where a display pointer could not
        // be positioned.  In this case, we didn't adjust anything, so just return
        // S_OK;
        //
        hr = S_OK;
    }

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}



//+====================================================================================
//
// Method: DoSelectWord
//
// Synopsis: Select a word at the given point.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::DoSelectWord( CEditEvent* pEvent, BOOL* pfDidSelection /*=NULL*/ )
{
    HRESULT hr = S_OK;
    BOOL fAtStart = FALSE;
    BOOL fAtEnd = FALSE;
    IMarkupPointer* pTest = NULL;
    IHTMLElement * pIFlowElement = NULL;
    VARIANT_BOOL fDisabled = VARIANT_TRUE;
    IHTMLInputElement* pIInputElement = NULL;
    BSTR bstrType = NULL;
    BOOL fWasPassword = FALSE;
    IHTMLElement* pIElement = NULL;
    SP_IHTMLElement3 spElement3;
    CSpringLoader *psl = GetSpringLoader();
    SP_IMarkupPointer spStartPointer;
    SP_IMarkupPointer spEndPointer;
    POINT pt;

    IFC( pEvent->GetPoint(& pt ));

    // Currently, we reset for empty selections.  We may want to change this at some point.
    if (psl)
        psl->Reset();

    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
    IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );

    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );

    IFC( _pDispStartPointer->GetFlowElement( &pIFlowElement ));
    if ( ! pIFlowElement )
        goto Cleanup;

    IFC(pIFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->get_isDisabled(&fDisabled));

    if ( !fDisabled )
    {
        //
        // Special case to look to see if we are in a Password.
        // If we are - we don't want to do a word select - just select the entire contents of the password
        // Why ? Because we might then be revealing the presence of a space in the password ( gasp !)
        //
        if ( _pManager->GetEditableTagId() == TAGID_INPUT )
        {
            //
            // Get the Master.
            //
            IFC( _pManager->GetEditableElement(&pIElement) );

            IFC( pIElement->QueryInterface (
                                            IID_IHTMLInputElement,
                                            ( void** ) & pIInputElement ));

            IFC(pIInputElement->get_type(&bstrType));

            if (!StrCmpIC( bstrType, TEXT("password")))
            {
                SP_IDisplayPointer spDispPointer;

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

                IFC( spDispPointer->MoveToMarkupPointer(_pManager->GetStartEditContext(), NULL) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                IFC( MoveStartToPointer(spDispPointer) );

                IFC( _pDispEndPointer->MoveToMarkupPointer( _pManager->GetEndEditContext(), NULL));
                IFC( _pDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                fWasPassword = TRUE;
            }
        }

        if ( ! fWasPassword )
        {
            SP_IHTMLElement     spElement;

            IFC( GetCurrentScope(_pDispStartPointer, &spElement) );
            if ( _pManager->CheckAtomic( spElement ) == S_OK )
            {
                IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE, & pt, pfDidSelection ));
                if (*pfDidSelection)
                    goto Cleanup;
                IFC( AdjustForAtomic( _pDispEndPointer, spElement, FALSE , & pt, pfDidSelection ));
                if (*pfDidSelection)
                    goto Cleanup;
            }
            else
            {

                SP_IMarkupPointer spPointer;

                ClearInterface( & pIFlowElement );
                IFC( GetEditor()->CreateMarkupPointer( & pTest ));

                //  For atomic elements, we want to do word selection depending on where the user
                //  double clicked.  So, we really want to adjust using our anchor pointer.
                if (_fStartIsAtomic)
                {
                    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(pTest) );
                }
                else
                {
                    IFC( _pDispStartPointer ->PositionMarkupPointer(pTest) );
                }

                //
                // Move Start
                //
                IsAtWordBoundary( pTest, & fAtStart, NULL );
                if ( ! fAtStart )
                {
                    IFC( MoveWord(  pTest, MOVEUNIT_PREVWORDBEGIN));
                }
                IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) )

                //
                // See if we're in the same flow layout
                //
                if ( GetEditor()->PointersInSameFlowLayout( spPointer, pTest, NULL ))
                {
                    SP_IDisplayPointer  spDispPointer;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    IFC( spDispPointer->MoveToMarkupPointer(pTest, NULL) );
                    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    IFC( MoveStartToPointer( spDispPointer, TRUE ));
                }
                else
                {
                    SP_IDisplayPointer  spDispPointer;

                    //
                    // We know the Start went into another layout. If we go left - we will find that
                    // layout start. We position ourselves at the start of the layout boundary.
                    //

                    DWORD dwBreak = 0;
                    ED_PTR( scanPointer);
                    _pDispTestPointer->PositionMarkupPointer(scanPointer);
                    scanPointer.Scan( LEFT,
                                      BREAK_CONDITION_Site,
                                      &dwBreak);
                    Assert( scanPointer.CheckFlag(  dwBreak, BREAK_CONDITION_Site ));
                    scanPointer->Right(TRUE, NULL, NULL, NULL, NULL);

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    IFC( spDispPointer->MoveToMarkupPointer(scanPointer, _pDispTestPointer) );

                    IFC( MoveStartToPointer( spDispPointer, TRUE ));
                }

                //
                // Move End
                //

                //  For atomic elements, we want to do word selection depending on where the user
                //  double clicked.  So, we really want to adjust using our anchor pointer.
                if (_fStartIsAtomic)
                {
                    IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(pTest) );
                }
                else
                {
                    IFC( _pDispEndPointer->PositionMarkupPointer(pTest) );
                }

                IsAtWordBoundary( pTest, NULL, & fAtEnd );
                if ( ! fAtEnd )
                {
                    IFC( MoveWord( pTest, MOVEUNIT_NEXTWORDBEGIN ));
                }
                //
                // See if we're in the same flow layout
                //
                IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
                if ( GetEditor()->PointersInSameFlowLayout( spPointer, pTest, NULL ))
                {
                    //
                    // See if we moved pass a block boundary.
                    //
                    ED_PTR( endPointer );
                    DWORD dwBreakCondition = 0;

                    endPointer.MoveToPointer( pTest );

                    if ( ! fAtEnd )
                    {
                        endPointer.SetBoundary(
                                _pManager->GetStartEditContext(),
                                _pManager->GetEndEditContext());
                        endPointer.Scan( LEFT,
                                         BREAK_CONDITION_Text |
                                         BREAK_CONDITION_Block |
                                         BREAK_CONDITION_NoScopeBlock |
                                         BREAK_CONDITION_Site ,
                                         & dwBreakCondition);

                        WHEN_DBG( SetDebugName( endPointer, _T(" Word Block Scanner")));
                        BOOL fHitBlock =   endPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Block | BREAK_CONDITION_NoScopeBlock  );

                        if ( fHitBlock )
                        {
                            //
                            // We found an Exit Block. Instead of doing a move word - scan
                            // from the end looking for a block boundary.
                            //
                            _pDispEndPointer->PositionMarkupPointer(endPointer);
                            endPointer.Scan( RIGHT,
                                                BREAK_CONDITION_Block |
                                                BREAK_CONDITION_Site |
                                                BREAK_CONDITION_NoScopeBlock |
                                                BREAK_CONDITION_Boundary |
                                                BREAK_CONDITION_NoLayoutSpan,
                                                & dwBreakCondition );

                            if ( ! endPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ))
                            {
                                endPointer.Scan( LEFT,
                                                    BREAK_CONDITION_Block |
                                                    BREAK_CONDITION_Site |
                                                    BREAK_CONDITION_NoScopeBlock |
                                                    BREAK_CONDITION_Boundary |
                                                    BREAK_CONDITION_NoLayoutSpan,
                                                    & dwBreakCondition );
                            }

                            hr = THR( MoveEndToMarkupPointer(endPointer, NULL, TRUE) );
                        }
                        else
                        {
                            Assert( ! fHitBlock ); // I know this looks funny. The debugger gets confused on the above so looks like it steps into here.

                            hr = THR( MoveEndToMarkupPointer(pTest, NULL, TRUE) );
                        }
                    }
                }
                else
                {
                    //
                    // We know the End went into another layout. If we go right  we will find that
                    // layout boundary - we position ourselves at the start of the layout boundary.
                    //

                    DWORD dwBreak = 0;
                    ED_PTR( scanPointer);
                    _pDispTestPointer->PositionMarkupPointer(scanPointer);
                    scanPointer.Scan( RIGHT,
                                      BREAK_CONDITION_Site,
                                      &dwBreak);

                    Assert( scanPointer.CheckFlag( dwBreak, BREAK_CONDITION_Site ));

                    IFC( scanPointer->Left( TRUE, NULL, NULL, NULL, NULL ));
                    IFC( MoveEndToMarkupPointer(scanPointer, NULL, TRUE) );
                }
            }
        }
    }
    else
    {
        IFC( spStartPointer->MoveAdjacentToElement( pIFlowElement, ELEM_ADJ_BeforeBegin ));
        IFC( _pDispStartPointer->MoveToMarkupPointer(spStartPointer, NULL) );

        IFC( spEndPointer->MoveAdjacentToElement( pIFlowElement, ELEM_ADJ_AfterEnd));
        IFC( _pDispEndPointer->MoveToMarkupPointer(spEndPointer, NULL) );
    }

    if ( hr )
        goto Cleanup;

    IFC( ConstrainSelection( TRUE, & pt));
    IFC( AdjustSelection( NULL ));
    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );
    }

    if ( !fWasPassword && !fDisabled && !_fStartIsAtomic )
    {
        _fDoubleClickWord = TRUE;

        //
        // If we got here by double-click - we're in word sel mode.
        //
        _fInWordSel = TRUE;
        IFC( _pDispWordPointer->MoveToPointer( _pDispEndPointer ));
        _fWordPointerSet = TRUE;

    }

    SetMadeSelection( TRUE);
Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    SysFreeString( bstrType );
    ReleaseInterface( pIElement );
    ReleaseInterface( pIInputElement );
    ReleaseInterface( pIFlowElement );
    ReleaseInterface( pTest );
    RRETURN( hr );
}


//+====================================================================================
//
// Method: DoSelectParagraph
//
// Synopsis: Select a paragraph at the given point.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::DoSelectParagraph( CEditEvent* pEvent, BOOL* pfDidSelection /*=NULL*/ )
{
    HRESULT hr = S_OK;
    CSpringLoader   *psl = GetSpringLoader();
    SP_IHTMLElement spBlockElement = NULL;
    CBlockPointer copyBlock( _pManager->GetEditor() );
    CBlockPointer bpLeft( _pManager->GetEditor() );
    SP_IMarkupPointer spPointer;
    SP_IDisplayPointer  spDispPointer;
    POINT pt;
    BOOL fEmpty = FALSE;

    CBlockPointer blockPointer( _pManager->GetEditor() );
    IFC( pEvent->GetPoint( & pt ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

    if (psl)
        psl->Reset();
    //
    // Find left edge
    //
    if ( _fStartIsAtomic )
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope( _pDispStartPointer, &spElement) );
        IFC( AdjustForAtomic( _pDispStartPointer, spElement, TRUE, & pt, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
        IFC( AdjustForAtomic( _pDispEndPointer, spElement, FALSE , & pt, pfDidSelection ));
        if (*pfDidSelection)
            goto Cleanup;
    }
    else
    {
        BOOL                fSameMarkup = TRUE;

        IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFC( _pDispStartPointer->PositionMarkupPointer(spPointer) );

        IFC( bpLeft.MoveTo(spPointer, RIGHT) );

        IFC( bpLeft.IsEmpty(&fEmpty) );
        if (!fEmpty)
        {
            IFC( bpLeft.MoveToFirstNodeInBlock() );
        }

        IFC( bpLeft.MovePointerTo(spPointer, ELEM_ADJ_AfterBegin) );

        IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispStartPointer, spDispPointer, &fSameMarkup) );
        if (!fSameMarkup)
            goto Cleanup;

        IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );

        //
        // Find right edge of current block.  For our purposes, the right
        // edge of the block should include any siblings in the parent block.
        // This will cause a triple click in a paragraph that contains controls
        // to have the controls selected.  We move past all siblings by calling
        // MoveToLastNodeInBlock().  This will position the block pointer at the
        // last node in the parent block, or it will break on layout in the block.
        //

        IFC( blockPointer.MoveTo(&bpLeft) );

        if (!fEmpty)
            IFC( blockPointer.MoveToLastNodeInBlock());

        IFC( copyBlock.MoveTo( & blockPointer ));

        if ( blockPointer.MoveToSibling(RIGHT) == S_FALSE )
        {
            //
            // If we positioned our blockPointer at the last block in our parent
            // block, we may have to move our end of selection past our parent block
            // so that select past the end of block.
            //
            if ( copyBlock.IsLeafNode() )
            {
                //
                // Move to our parent block.  If we have a parent block
                // with type BLOCK, then we can adjust our pointers to
                // encompass the end of this block.
                //
                IFC( copyBlock.MoveToParent());

                if( copyBlock.GetType() != NT_Block )
                {
                    copyBlock.MoveTo( &blockPointer );
                }
            }

            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
            IFC( copyBlock.MovePointerTo( spPointer, ELEM_ADJ_AfterEnd ));

            IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
            IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spDispPointer, &fSameMarkup) );
            if (!fSameMarkup)
                goto Cleanup;

            IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
        else
        {
            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );
            IFC( copyBlock.MovePointerTo( spPointer, ELEM_ADJ_BeforeEnd ));

            IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
            IFC( ArePointersInSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spDispPointer, &fSameMarkup) );
            if (!fSameMarkup)
                goto Cleanup;

            IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
    }

    IFC( ConstrainSelection( TRUE, & pt ));
    IFC( AdjustSelection( NULL ));
    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );
        IFC( FireOnSelect() );
    }

    //
    // Not scrolling into view here is correct.
    //
    SetMadeSelection( FALSE );

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: ConstrainSelection
//
// Synopsis: Constrain a Selection between the editable context
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::ConstrainSelection( BOOL fMoveStart /*=fALSE*/, POINT* pptGlobal /*=NULL*/, BOOL fStartAdjustedForAtomic /*=FALSE*/, BOOL fEndAdjustedForAtomic /*=FALSE*/ )
{
    HRESULT hr = S_OK;
    BOOL fDirection = GetMoveDirection();
    ELEMENT_ADJACENCY eAdj = ELEMENT_ADJACENCY_Max;

    if ( fMoveStart )
    {
        hr = ConstrainPointer( _pDispStartPointer, fDirection );
        if (hr == CTL_E_INVALIDLINE && fStartAdjustedForAtomic)
            hr = S_OK;
    }

    if ( !pptGlobal ||
         !_pManager->IsEditContextPositioned() )
    {
        hr = THR( ConstrainPointer( _pDispEndPointer, fDirection ));
        if (hr == CTL_E_INVALIDLINE && fEndAdjustedForAtomic)
            hr = S_OK;
    }
    else if ( ! _pManager->IsInEditContext( _pDispEndPointer ))
    {
        //
        // We do this for positioned elements only. Why ? Because where the pointer is in the stream
        // may not necessarily match where it "looks like" it should be.
        //
        // Most of the time we don't get here. MoveMarkupPointer should have adjusted us perfectly already.
        //
        long midX, lLeft, lRight;
        RECT rect;
        SP_IHTMLElement2 spElement2;
        SP_IHTMLElement spElement = _pManager->GetEditableElement();
        SP_IMarkupPointer spEndPointer;

        if (!spElement)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        IFC(spElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
        // Editable Element always has a flowlayout, so no need to check here.
        IFC(GetEditor()->GetBoundingClientRect(spElement2, &rect));

        lLeft = rect.left;
        lRight = rect.right;

        midX = ( lRight + lLeft) / 2;

        if ( pptGlobal->x <= midX )
            eAdj = ELEM_ADJ_AfterBegin;
        else
            eAdj = ELEM_ADJ_BeforeEnd;

        IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
        IFC( spEndPointer->MoveAdjacentToElement( spElement, eAdj ));
        
        WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, spEndPointer) );
        IFC( _pDispEndPointer->MoveToMarkupPointer(spEndPointer, NULL) );
    }

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );

    RRETURN( hr );
}

//+====================================================================================
//
// Method: DoWordSelection
//
// Synopsis: Do the word selection behavior. Select on word boundaries when in Word Selection
//           mode.
//
//------------------------------------------------------------------------------------

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used
#endif

HRESULT
CSelectTracker::DoWordSelection(
                        CEditEvent* pEvent ,
                        BOOL* pfAdjustedSel,
                        BOOL fFurtherInStory )
{
    HRESULT hr = S_OK;
    BOOL fStartWordSel = FALSE;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;

    Assert( pfAdjustedSel );
#if DBG == 1
    int endCp = 0;
    int oldEndCp = GetCp( _pDispEndPointer );
    int oldStartCp = GetCp( _pDispStartPointer );
    int startCp = oldStartCp;
#endif

    if ( _fInWordSel )
    {
        if ( !!_fWordSelDirection != fFurtherInStory ) // only look at changes in direction that are not in Y
        {
            SP_IMarkupPointer spTestPointer;

            // We only pay attention to changes in direction in the scope of the previous
            // word. Hence moves up or down by a line - that are changes in direction won't
            // snap us out of word select mode.
            //
            ED_PTR( prevWordPointer );
            ED_PTR( nextWordPointer );
            IFC( _pDispPrevTestPointer->PositionMarkupPointer(prevWordPointer) );
            IFC( _pDispPrevTestPointer->PositionMarkupPointer(nextWordPointer) );
            IFC( MoveWord( prevWordPointer, MOVEUNIT_PREVWORDBEGIN ));
            IFC( MoveWord( nextWordPointer, MOVEUNIT_NEXTWORDBEGIN ));
            BOOL fBetween = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
            IFC( spTestPointer->IsRightOfOrEqualTo( prevWordPointer, & fBetween ));
            if ( fBetween )
            {
                IFC( spTestPointer->IsLeftOfOrEqualTo( nextWordPointer, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok
            }

            if ( fBetween )
            {
                _fInWordSel = FALSE;
                WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer));
                IFC( _pDispWordPointer->MoveToPointer( _pDispSelectionAnchorPointer ) );
                IFC( MoveEndToPointer ( _pDispTestPointer, TRUE ));
                _fWordPointerSet = FALSE;
                *pfAdjustedSel = TRUE;
            }
        }

        if ( _fInWordSel ) // if we're still in word sel
        {
            //
            // We're in the same direction, we can move words.
            //

            IFC( AdjustEndForWordSelection(fFurtherInStory) );
            *pfAdjustedSel = TRUE;
        }
    }
    else
    {
        SP_IMarkupPointer spWordPointer;
        BOOL fWordPointerSet = FALSE;
        IFC( GetEditor()->CreateMarkupPointer(&spWordPointer) );
        IFC( _pDispWordPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( _pDispWordPointer->PositionMarkupPointer(spWordPointer) );

        IFC( SetWordPointer( spWordPointer, fFurtherInStory, FALSE , & fStartWordSel , &fWordPointerSet) );
        IFC( _pDispWordPointer->MoveToMarkupPointer(spWordPointer, NULL) );

        _fWordPointerSet = fWordPointerSet;

        if ( _fWordPointerSet )
        {
            if ( ! fStartWordSel )
            {
                int iWherePointer = SAME;

                WHEN_DBG( ValidateWordPointer(_pDispWordPointer));
                IFC( _pManager->GetEditor()->OldDispCompare( _pDispWordPointer, _pDispTestPointer, & iWherePointer ));

                switch( iWherePointer )
                {
                    case LEFT:
                        fStartWordSel = !fFurtherInStory ;
                        break;

                    case RIGHT:
                        fStartWordSel = fFurtherInStory;
                        break;
                }
            }

            if ( fStartWordSel )
            {
                SP_IDisplayPointer spDispEndPointer;

                _fInWordSel = TRUE;

                WHEN_DBG( ValidateWordPointer( _pDispWordPointer ));

                //
                // The first time we jump into word sel mode, we set the word pointer off of StartPointer.
                // This is valid for the purposes of determining if we went past the boundary - and for
                // determining where to set the Start Pointer to.
                // It is also valid to set the end off of this if you moved over this pointer
                //
                // However there are some cases (like starting a selection in the empty space of tables)
                // Where this causes us to move the end to the start - when it should be moved to test
                // So what we do here is always set the end off of test.
                //

                ED_PTR( tempPointer );
                IFC( _pDispTestPointer->PositionMarkupPointer(tempPointer) );
                IFC( SetWordPointer( tempPointer, fFurtherInStory , TRUE ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndPointer) );
                IFC( spDispEndPointer->MoveToMarkupPointer(tempPointer, NULL) );
                IFC( spDispEndPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( MoveEndToPointer( spDispEndPointer, TRUE ));

                WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer ));

                _fWordPointerSet = FALSE;


                if ( ! ENSURE_BOOL(_fStartAdjusted) )
                {
                    SP_IMarkupPointer spStartPointer;

                    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );

                    //
                    // Check to see if the Start is already at a word boundary
                    // we don't make the adjustment if the context to the left/right of start
                    // is not text !
                    //

                    IFC( _pDispStartPointer->PositionMarkupPointer(spStartPointer) );
                    if ( fFurtherInStory )
                    {
                        IFC( spStartPointer->Left( FALSE, & eContext, NULL, NULL, NULL ));
                    }
                    else
                    {
                        IFC( spStartPointer->Right( FALSE, & eContext, NULL, NULL, NULL ));
                    }

                    if ( eContext == CONTEXT_TYPE_Text )
                    {
                        SP_IMarkupPointer   spMarkup;
                        SP_IMarkupPointer2  spMarkup2;
                        BOOL fAlreadyAtStartOfWord = FALSE;

                        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
                        IFC( _pDispStartPointer->PositionMarkupPointer(spMarkup) );

                        IFC( spMarkup->QueryInterface(IID_IMarkupPointer2, (void **) &spMarkup2));
                        IFC( spMarkup2->IsAtWordBreak(&fAlreadyAtStartOfWord));

                        if ( ! fAlreadyAtStartOfWord && !_fExitedWordSelectionOnce )
                        {
                            IFC( MoveWord( _pDispStartPointer, fFurtherInStory ?
                                                          MOVEUNIT_PREVWORDBEGIN  :
                                                          MOVEUNIT_NEXTWORDBEGIN ));

                            ConstrainPointer( _pDispStartPointer, fFurtherInStory );
                            IFC( MoveStartToPointer(_pDispStartPointer, TRUE) );
                        }
                    }

                    _fStartAdjusted = TRUE;

                    WHEN_DBG( _ctStartAdjusted++);
#ifndef _PREFIX_
                    Assert( _ctStartAdjusted == 1);
#endif
                }
                _fStartAdjusted = TRUE;
                _fWordSelDirection = fFurtherInStory;

                *pfAdjustedSel = TRUE;
            }
            else
            {
                IFC( MoveEndToPointer( _pDispTestPointer ));
                *pfAdjustedSel = TRUE;
            }
            WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer));
        }
    }

    //  If we are no longer in word selection and the start pointer was adjusted for word selection
    //  we need to reset it to the anchor point if the anchor and word adjusted start pointers
    //  are in the same word.

    if ( !_fInWordSel && _fStartAdjusted )
    {
        BOOL                fBetween = FALSE;
        SP_IMarkupPointer   spTestPointer;
        ED_PTR( prevWordPointer );
        ED_PTR( nextWordPointer );

        _fExitedWordSelectionOnce = TRUE;

        IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(prevWordPointer) );
        IFC( _pDispSelectionAnchorPointer->PositionMarkupPointer(nextWordPointer) );
        IFC( MoveWord( prevWordPointer, MOVEUNIT_PREVWORDBEGIN ));
        IFC( MoveWord( nextWordPointer, MOVEUNIT_NEXTWORDBEGIN ));

        IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
        IFC( spTestPointer->IsRightOfOrEqualTo( prevWordPointer, & fBetween ));
        if ( fBetween )
        {
            IFC( spTestPointer->IsLeftOfOrEqualTo( nextWordPointer, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok
        }

        if ( fBetween )
        {
            IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );
            _fStartAdjusted = FALSE;
            WHEN_DBG( _ctStartAdjusted = 0 );
            *pfAdjustedSel = TRUE;
        }
    }

    IFC( AdjustStartForAtomic(fFurtherInStory) );

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN ( hr );
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

HRESULT
CSelectTracker::AdjustEndForWordSelection(BOOL fFurtherInStory)
{
    HRESULT hr = S_OK;
    BOOL    fNeedsAdjust;

    if ( fFurtherInStory )
    {
        IFC( _pDispWordPointer->IsLeftOf(_pDispTestPointer, &fNeedsAdjust) );
    }
    else
    {
        IFC( _pDispWordPointer->IsRightOf(_pDispTestPointer, &fNeedsAdjust) );
    }

    if ( fNeedsAdjust )
    {
        SP_IMarkupPointer   spMarkup;
        SP_IMarkupPointer2  spMarkup2;
        BOOL                fAlreadyAtWord = FALSE;

        IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spMarkup) );

        IFC( spMarkup->QueryInterface(IID_IMarkupPointer2, (void **) &spMarkup2));
        IFC( spMarkup2->IsAtWordBreak(&fAlreadyAtWord));

        IFC( _pDispWordPointer->MoveToPointer( _pDispTestPointer ));
        if ( ! fAlreadyAtWord )
        {
            //
            // Use GetMoveDirection() instead of fFurtherInStory here.
            //
            IFC( MoveWord( _pDispWordPointer, GetMoveDirection() ?
                                          MOVEUNIT_NEXTWORDBEGIN :
                                          MOVEUNIT_PREVWORDBEGIN   ));
            IFC( ConstrainPointer( _pDispWordPointer, fFurtherInStory ));
        }

        WHEN_DBG( ValidateWordPointer(_pDispWordPointer) );
        IFC( MoveEndToPointer( _pDispWordPointer, TRUE ));
    }
    WHEN_DBG( if ( _fInWordSel ) ValidateWordPointer( _pDispEndPointer ));

Cleanup:

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispWordPointer, _pDispStartPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN(hr);
}

//+====================================================================================
//
// Method: SetWordPointer
//
// Synopsis: Set the Word Pointer if it's not set already.
//
// Parameters:
//      fSetFromGivenPOinter - if false - we use either _pDispStartPointer, or _pDispPrevTestPointer to determine
//                                what to set the WOrd Pointer off of.
//                                if true we use where the Pointer given already is - to set the word pointer
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::SetWordPointer(
                                IMarkupPointer* pPointerToSet,
                                BOOL fFurtherInStory,
                                BOOL fSetFromGivenPointer, /* = FALSE*/
                                BOOL* pfStartWordSel, /* = NULL*/
                                BOOL* pfWordPointerSet /*= NULL*/ )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spTestPointer;
    BOOL fStartWordSel = FALSE;
    BOOL fAtWord = FALSE;
    BOOL fBlockBetween = FALSE;
    BOOL fWordPointerSet = FALSE;
    BOOL fPointersAreEqual = FALSE;

    //
    // The first time we drop into word selection mode - we use the start pointer
    // from then on - we go off of the _testPointer
    // We know if this is the first time if we haven't reversed yet
    //
    BOOL fAtStart = FALSE;
    BOOL fAtEnd = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
    IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );

    if ( ! fSetFromGivenPointer )
    {
        //
        // You may be at a word boundary. But it may not be the "right" word boundary.
        // Hence if you start a selection at the beginning of a word and select right
        // the "right" word boundary is the end of the word - not where you started !
        //

        fAtWord = IsAtWordBoundary( _pDispTestPointer/*_pDispStartPointer*/, &fAtStart, &fAtEnd, TRUE  );
        if (fAtWord)
        {
            //  Okay, we are at some word boundary.  Check to make sure we are not
            //  at the same position as the given pointer.  If we are, we need
            //  to reposition it.

            IFC( spTestPointer->IsEqualTo(pPointerToSet, &fPointersAreEqual) );
        }
        IFC( _pDispStartPointer->PositionMarkupPointer(pPointerToSet) );
    }
    else
    {
#if DBG == 1
        BOOL fPositioned;
        IGNORE_HR( pPointerToSet->IsPositioned( & fPositioned));
        Assert( fPositioned );
#endif
        fAtWord = IsAtWordBoundary( pPointerToSet, & fAtStart, &fAtEnd );
    }



    //
    // We move the word pointer, if start was not already at a word.
    //
    if ( !fAtWord || fPointersAreEqual )
    {
        IFC( MoveWord( pPointerToSet,
                       fFurtherInStory ? MOVEUNIT_NEXTWORDBEGIN : MOVEUNIT_PREVWORDBEGIN ));

        IFC( ConstrainPointer( pPointerToSet, fFurtherInStory ));

        //
        // Compensate for moving past the end of a line.
        //
        // We look for this by seeing if the Test is to the left of a block (for the fFurtherInStory case)
        // and the word is to the right of a block.
        //

        fBlockBetween = IsAdjacentToBlock( pPointerToSet, fFurtherInStory ? LEFT: RIGHT ) &&
                        IsAdjacentToBlock( spTestPointer, fFurtherInStory ? RIGHT : LEFT );

        if ( fBlockBetween )
        {
            //
            // We moved past line end. Compensate.
            //

            IFC( _pDispTestPointer->PositionMarkupPointer(pPointerToSet) );
            fStartWordSel = TRUE;
            fWordPointerSet = TRUE;
        }
        else
        {
            fWordPointerSet = IsAtWordBoundary( pPointerToSet );
        }
    }
    else
    {
        //
        // We know we're at a word boundary.
        //
        fWordPointerSet = TRUE;
    }

    if ( pfStartWordSel )
        *pfStartWordSel = fStartWordSel;

    if ( pfWordPointerSet )
        *pfWordPointerSet = fWordPointerSet;

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispWordPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN( hr );
}

#if DBG == 1

//+====================================================================================
//
// Method: ValidateWordPointer
//
// Synopsis: Do some checks to see the Word Pointer is at a valid place
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::ValidateWordPointer(IDisplayPointer* pDispPointer)
{
#if 0
    if ( IsTagEnabled ( tagSelectionValidateWordPointer ))
    {
        SP_IMarkupPointer spPointer;

        ELEMENT_TAG_ID eTag = TAGID_NULL;
        IHTMLElement* pIElement = NULL;
        BOOL fAtWord = FALSE;
        //
        // Check to see we're not in the root or other garbage
        //
        IGNORE_HR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IGNORE_HR( pDispPointer->PositionMarkupPointer(spPointer) );
        IGNORE_HR( GetEditor()->CurrentScopeOrMaster( pDispPointer, &pIElement, spPointer ) );
        IGNORE_HR( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
        Assert( eTag != TAGID_NULL );

        fAtWord = IsAtWordBoundary( spPointer );
        AssertSz( fAtWord, "Pointer is not at a word");
        ReleaseInterface( pIElement );
    }
#endif
}

#endif

//
//
// Adjustment Code.
//
//
//+====================================================================================
//
// Method: AdjustPointersForLayout - used by Adjust Selection
//
// Synopsis: AdjustPointers for not being in the same flow layout.
//
//      Check to see if start and end aren't in the same flow layout.
//
//      If they aren't try and move them inwards - so they end up in the same layout.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustPointersForLayout( IMarkupPointer* pStart,
                                         IMarkupPointer* pEnd,
                                         BOOL* pfStartAdjusted /* = NULL*/ ,
                                         BOOL* pfEndAdjusted /*= NULL*/ )
{
    HRESULT hr = S_OK;
    ED_PTR( edScanStart );
    ED_PTR( edScanEnd );
    BOOL fFoundEndLayout= FALSE;
    BOOL fFoundStartLayout = FALSE;

    SP_IHTMLElement spEndLayout;
    SP_IHTMLElement spStartLayout;
    SP_IHTMLElement spAdjustStart;
    SP_IHTMLElement spAdjustEnd;


    //
    // See if the pointers are in the same flow layout
    //

    if ( !GetEditor()->PointersInSameFlowLayout( pStart, pEnd, NULL))
    {
        IFC( edScanStart.MoveToPointer( pStart ));
        IFC( edScanEnd.MoveToPointer( pEnd ));

        IFC( GetEditor()->GetFlowElement( pEnd, &spEndLayout));

        IFC( ScanForLayout( RIGHT,
                            edScanStart,
                            spEndLayout,
                            & fFoundEndLayout,
                            & spAdjustStart ));

        if ( ! fFoundEndLayout )
        {
            //
            // Move out of the layout - until you're in the same layout
            // as the StartPointer
            //
            IFC( GetEditor()->GetFlowElement( pStart, & spStartLayout));
            IFC( ScanForLayout( LEFT,
                                edScanEnd,
                                spStartLayout,
                                & fFoundStartLayout,
                                & spAdjustEnd ));
        }

        //
        // We didn't find the end or the start - but when we adjusted both of them
        // we ended up in the same layout
        // an example would be adjusting across TD's
        //
        // so we had:
        //  <td>  start-> </td><td>   </td><td> <- end </td>
        //
        // and end up  with:
        //  <td>  </td> <td> start->  <- end </td><td>  </td>
        //

        if ( ! fFoundEndLayout && ! fFoundStartLayout
             && GetEditor()->PointersInSameFlowLayout( edScanStart, edScanEnd, NULL ))
        {
            fFoundEndLayout = TRUE;
            fFoundStartLayout = TRUE;
        }
    }

    if ( fFoundEndLayout )
    {
        IFC( pStart->MoveToPointer( edScanStart ));
    }

    if ( fFoundStartLayout)
    {
        IFC( pEnd->MoveToPointer( edScanEnd ));
    }

    if ( pfStartAdjusted )
        *pfStartAdjusted = fFoundEndLayout;

    if ( pfEndAdjusted )
        *pfEndAdjusted = fFoundStartLayout;

Cleanup:

    RRETURN( hr );

}

//+====================================================================================
//
// Method: AdjustPointersBetweenBlocks - used by AdjustSelection
//
// Synopsis: Will try to adjust a given pointer to the "magic place" between blocks.
//
//          So if your pointer was inside the enter block of a <p> like this
//
//              <p> ... </p><p> <- Ptr
//
//
//          This routine will try and place the ptr between the 2 blocks like this:
//
//
//              <p>....</p> <-Ptr <p>
//
// We do this by :
//
//      Looking left to see if there is an ExitBlock. If there is - we Scan for the FirstEnterBlock
//      Then we go right for last exit block
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustEndPointerBetweenBlocks(
                            IMarkupPointer* pStartPointer,
                            IMarkupPointer* pEndPointer,
                            DWORD dwAdjustOptions,
                            BOOL* pfAdjusted )
{
    HRESULT hr = S_OK;
    ED_PTR( epScan);
    ED_PTR( epAdjust);
    SP_IHTMLElement spElement;
    BOOL fAdjustedIn = FALSE;
    BOOL fAdjustedOut = FALSE;
    DWORD dwBreakCondition = 0;

    IFC( epScan.MoveToPointer( pEndPointer ));
    IFC( epAdjust.MoveToPointer( pEndPointer ));
    IFC( epScan.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));
    IFC( epAdjust.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));

    //
    // Look Left - to see if you hit an exit block.
    // If you did - then we need to Scan Left - until we hit an EnterBlock
    //
    IFC( epScan.Scan( LEFT,
                     BREAK_CONDITION_Content ,
                     & dwBreakCondition,
                     & spElement,
                     NULL,
                     NULL,
                     SCAN_OPTION_TablesNotBlocks ));


	if ( epScan.CheckFlag( dwBreakCondition,
                              BREAK_CONDITION_ExitBlock )
         && spElement ) // possible to be null for a return in a PRE ( NoScopeBlock breaks on hard returns).
    {
            BOOL fEqualFuzzy = FALSE;

            IFC( epScan.IsEqualTo( pStartPointer ,
                                 BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor,
                                 & fEqualFuzzy ));
            if ( ! fEqualFuzzy )
            {
                //
                // If we found an exit block - continue looking to the left to see if
                // you enter a block. Only if you do find an Enter Block and nothing else
                // do you have to move to the special place.
                //
                IFC( epScan.Scan( LEFT,
                                  BREAK_CONDITION_Content - BREAK_CONDITION_ExitBlock ,
                                  & dwBreakCondition ));


                if( epScan.CheckFlag( dwBreakCondition,
                                      BREAK_CONDITION_EnterBlock | BREAK_CONDITION_NoScopeBlock ))
                {
                    fAdjustedIn = TRUE;

                    IFC( epScan.Scan( RIGHT ,
                                      BREAK_CONDITION_Content  ,
                                      & dwBreakCondition ));

                }
            }
    }

    if ( fAdjustedIn )
    {
        IFC( epAdjust.MoveToPointer( epScan ));
    }
    //
    //
    // Now go right - looking for last Exit Block
    // This handles the Nested Block case
    //
    // eg.
    //    if we had : </div> <- End Ptr </span> </font> </div>
    //
    // we want to have
    //                </div> </span> </font> </div> <- End Ptr
    //

    if ( dwAdjustOptions & ADJ_END_SelectBlockRight )
    {
        IFC( epScan.MoveToPointer( epAdjust ));

        IFC( epScan.Scan(   RIGHT,
                            BREAK_CONDITION_Content ,
                            & dwBreakCondition,
                            NULL,
                            NULL,
                            NULL,
                            SCAN_OPTION_TablesNotBlocks ));

        if ( epScan.CheckFlag(  dwBreakCondition,
                                BREAK_CONDITION_ExitBlock |
                                BREAK_CONDITION_NoScopeBlock |
                                BREAK_CONDITION_Boundary ))
        {
            fAdjustedOut = TRUE;

            //
            // If we found an exit block - continue looking to the right to see if
            // you enter a block. Only if you do find an Enter Block and nothing else
            // do you have to move to the special place.
            //
            if( !epScan.CheckFlag( dwBreakCondition, BREAK_CONDITION_NoScopeBlock ) )
            {
                IFC( ScanForLastExitBlock( RIGHT , epScan ));
            }

            IFC( epAdjust.MoveToPointer( epScan ));

        }
    }

    if ( fAdjustedIn || fAdjustedOut )
    {
        IFC( pEndPointer->MoveToPointer( epAdjust ));
    }

Cleanup:
    if ( pfAdjusted )
        *pfAdjusted = fAdjustedIn || fAdjustedOut ;

    RRETURN( hr );
}

//+====================================================================================
//
// Method: AdjustSelection
//
// Synopsis: Adjust the Selection to wholly encompass blocks. We do this if the End point is
//           outside a block, or we started from the shift key.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::AdjustSelection(BOOL* pfAdjustedSel )
{
    HRESULT hr = S_OK;
    ED_PTR( epEnd );
    ED_PTR( epStart ) ;
    SP_IDisplayPointer spDispPointer;
    SP_IDisplayPointer spDispStart;
    SP_IDisplayPointer spDispEnd;

    BOOL fSwap = FALSE;
    BOOL fEqualFuzzy = FALSE;
    BOOL fBOL = FALSE;
    DWORD dwAdjustOptions = 0;
    BOOL fAdjustShiftPtr = FALSE;
    BOOL fRightOf;

#if DBG == 1
    BOOL fPointersInSameBefore;
    BOOL fPointersInSameAfter ;
#endif

    //
    // Find the "True" Start & End
    //
    IFC( MovePointersToTrueStartAndEnd( epStart, epEnd, & fSwap ));

    //
    // See if you're in the same place as the start pointer. If you are - there's no need
    // to adjust (happens in selection at start of a block )
    // eg.
    //              <p> <--Start <-- End
    //

    IFC( epStart.IsEqualTo( epEnd,
                            BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor,
                            & fEqualFuzzy ));

    //
    // If the pointers are equal, check to see if they are also at the
    // beginning of a line.  We still want to adjust the end pointer
    // if it falls at the end of a line
    //
    if( fEqualFuzzy )
    {
        IFC( _pDispStartPointer->IsAtBOL(&fBOL) );
    }

    if ( !fEqualFuzzy || !fBOL )
    {
#if DBG == 1
        fPointersInSameBefore = GetEditor()->PointersInSameFlowLayout( epStart, epEnd, NULL );
#endif

        //
        // Adjust the end to enclose the last block.  Don't do the adjust if
        // we are moving the selection by a word forward or back.. we need to
        // be able to adjust past block boundaries when doing word select
        //
        if( !( _fShift && ( _lastCaretMove == CARET_MOVE_WORDFORWARD ||
                            _lastCaretMove == CARET_MOVE_WORDBACKWARD ) ) )
        {
            if( _lastCaretMove == CARET_MOVE_LINEEND || _lastCaretMove == CARET_MOVE_LINESTART )
            {
                //
                // Adjust the REAL end pointer
                //
                IFC( AdjustEndPointerBetweenBlocks( fSwap ? epEnd : epStart,
                                                    fSwap ? epStart : epEnd,
                                                    ADJ_END_SelectBlockRight,
                                                    &fAdjustShiftPtr) );
            }
            else
            {
                dwAdjustOptions = _fState == ST_SELECTEDPARA ? ADJ_END_SelectBlockRight : 0;
                IFC( AdjustEndPointerBetweenBlocks( epStart, epEnd, dwAdjustOptions) );
            }            
        }

        //
        // Tweak for "incorrect" layouts.
        //
        IFC( AdjustPointersForLayout( epStart, epEnd ));

        //
        // Adjust the Start  pointer for insert to move into text.
        //
        //
        // We can't use the _fAtBOL flag here - it's only meaningful for the
        // end point of selection
        //

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->MoveToMarkupPointer(epStart, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

        IFC( AdjustPointerForInsert( spDispPointer, RIGHT, RIGHT ));

        IFC( spDispPointer->PositionMarkupPointer(epStart) );

        //
        // AdjustPointerForInsert could have moved epStart beyond epEnd
        //
        IFC( epEnd->IsRightOfOrEqualTo(epStart, &fRightOf) );
        if (!fRightOf)
        {
            //
            // Collapse into caret
            //
            epEnd->MoveToPointer(epStart);
        }
        
        if ( _fShift && ( _lastCaretMove == CARET_MOVE_PREVIOUSLINE || _lastCaretMove == CARET_MOVE_NEXTLINE ) )
        {
            IFC( spDispPointer->MoveToMarkupPointer(epEnd, NULL) );
            IFC( _pDispStartPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        }

#if DBG == 1
        fPointersInSameAfter = GetEditor()->PointersInSameFlowLayout( epStart, epEnd, NULL );

        AssertSz( (fPointersInSameBefore && fPointersInSameAfter) ||
                !fPointersInSameBefore, "Pointers have been adjusted out of Layout");
#endif

        //
        // Now adjust the context to the adjusted start and end
        //

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
        
        if (!fRightOf)
        {
            IFC( spDispStart->MoveToMarkupPointer(epStart, spDispPointer) );
            IFC( spDispEnd->MoveToMarkupPointer(epEnd, spDispPointer) );
        }
        else
        {
            IFC( spDispStart->MoveToMarkupPointer(epStart, _pDispStartPointer) );
            IFC( spDispEnd->MoveToMarkupPointer(epEnd, _pDispEndPointer) );
        }

        if ( ! fSwap )
        {
            IFC( MoveStartToPointer( spDispStart ));
            IFC( MoveEndToPointer( spDispEnd ));
        }
        else
        {
            IFC( MoveEndToPointer( spDispStart ));
            IFC( MoveStartToPointer( spDispEnd ));
        }

        //
        // marka - explicitly set the pointer gravity - based on the direction of the selection
        //
        if ( ! fSwap )
        {
            IFC( _pDispStartPointer->SetPointerGravity( POINTER_GRAVITY_Right ));

            IFC( _pDispEndPointer->SetPointerGravity( POINTER_GRAVITY_Left ));
        }
        else
        {
            IFC( _pDispEndPointer->SetPointerGravity( POINTER_GRAVITY_Right ));

            IFC( _pDispStartPointer->SetPointerGravity( POINTER_GRAVITY_Left ));
        }
        
        IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );
        IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

        if( fAdjustShiftPtr )
        {
            IFC( _pDispShiftPointer->MoveToPointer( _pDispEndPointer ) );
        }            
    }    

    if ( pfAdjustedSel )
        *pfAdjustedSel = TRUE ;
Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectTracker::AdjustPointersForChar()
{
    HRESULT         hr;
    DWORD           dwBreak;
    ED_PTR( epStart );
    ED_PTR( epEnd );

    DWORD           eBreakCondition = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor;
    CSpringLoader * psl = _pManager->GetEditor()->GetPrimarySpringLoader();
    SP_IDisplayPointer  spDispPointer;

    IFC( epStart.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext() ));
    IFC( epEnd.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext() ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

    IFC( MovePointersToTrueStartAndEnd(epStart, epEnd, NULL) );

    IFC( epStart.Scan(RIGHT, eBreakCondition, & dwBreak ) ); // skip phrase elements
    if ( ! epStart.CheckFlag( dwBreak, BREAK_CONDITION_Boundary ))
    {
        IFC( epStart.Scan(LEFT, eBreakCondition, NULL) ); // move back
    }

    IFC( epEnd.Scan(RIGHT, eBreakCondition, & dwBreak ) ); // skip phrase elements
    if ( ! epEnd.CheckFlag( dwBreak, BREAK_CONDITION_Boundary ))
    {
        IFC( epEnd.Scan(LEFT, eBreakCondition, NULL) ); // move back
    }

    IFC( spDispPointer->MoveToMarkupPointer(epStart, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( MoveStartToPointer( spDispPointer ));

    IFC( spDispPointer->MoveToMarkupPointer(epEnd, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( _pDispEndPointer->MoveToPointer(spDispPointer) );

    IFC( UpdateSelectionSegments( FALSE ) ); // dont' fire OM - selection is going away

    //
    // Spring load in the right place
    //

    if (psl)
    {
        BOOL fFurtherInStory = GetMoveDirection();

        if (fFurtherInStory)
        {
            if (SUCCEEDED(_pDispStartPointer->PositionMarkupPointer(epStart)))
            {
                IGNORE_HR( psl->SpringLoad(epStart, SL_TRY_COMPOSE_SETTINGS) );
            }
        }
        else
        {
            if (SUCCEEDED(_pDispEndPointer->PositionMarkupPointer(epEnd)))
            {
                IGNORE_HR( psl->SpringLoad(epEnd, SL_TRY_COMPOSE_SETTINGS) );
            }
        }
    }

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: AdjustForSiteSelectable.
//
// Synopsis: We just moved the end point into a different flow layout. Check to see if
//           the thing we moved into is Site Selectable. If it is - Jump Over it, using the
//           direction in which we are moving.
//
//           Return - TRUE - if we adjusted the selection
//                    FALSE if we didn't make any adjustments. Normal selection processing
//                          should occur.
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::AdjustForSiteSelectable()
{
    HRESULT             hr = S_OK;
    BOOL                fAdjustedSelection = FALSE;     // Did we adjust selection?
    SP_IHTMLElement     spStartElement;                 // Element where selection started
    SP_IHTMLElement     spStartSiteSelectElement;       // Site selectable element where selection started
    SP_IHTMLElement     spInThisElement;                // Element over candidate end of selection
    SP_IHTMLElement     spFlowElement;
    SP_IMarkupPointer   spTestPointer;                  // Where the candidate end of selection is at
    SP_IHTMLElement     spSiteSelectThis;
    SP_IMarkupPointer   spStartPointer;                 // Markup pointer for start of selection
    BOOL                fSameMarkup = FALSE;            // Are the candidate and the start in the same markup?
    ELEMENT_ADJACENCY   eAdj;
    SP_IHTMLElement     spOldSiteSelect;                // Guarantee for loop termination

    // Figure out our adjacency based on movedirection
    eAdj = GetMoveDirection() ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin;

    //
    // Position a pointer at start of selection
    //
    IFC( GetEditor()->CreateMarkupPointer( & spStartPointer ));
    IFC( _pDispStartPointer->PositionMarkupPointer( spStartPointer ));

    //
    // Create a markup pointer, and position it at the test pointer
    //
    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );

    IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
    IFC( GetEditor()->CurrentScopeOrMaster(_pDispTestPointer, &spInThisElement, spTestPointer ));

    if ( _pManager->GetSiteSelectableElementFromElement(spInThisElement, &spSiteSelectThis ) == S_OK )
    {
        //
        // spSiteSelectThis now points to the element which would be siteselected had a mouse
        // down occurred at our candidate end of selection
        //
        Assert( _pManager->IsInEditContext(_pDispTestPointer ) );

        IFC( spTestPointer->MoveAdjacentToElement( spSiteSelectThis, eAdj ));

        //
        // The following figures out dragging across multiple nested markups.
        // We just keep walking up the master chain until we are in the same markup
        //
        IFC( ArePointersInSameMarkup( spStartPointer, spTestPointer, &fSameMarkup ) )

        while( !fSameMarkup )
        {
            SP_IHTMLElement spMaster;

            //
            // Get the master element, and position our test pointer after or
            // before this element
            //
            IFC( GetEditor()->GetViewLinkMaster( spSiteSelectThis, &spMaster ) );

            if( !spMaster )
                goto Cleanup;

            IFC( spTestPointer->MoveAdjacentToElement( spMaster, eAdj ));

            IFC( ArePointersInSameMarkup( spStartPointer, spTestPointer, &fSameMarkup ) );
            spSiteSelectThis = spMaster;
        }

        //
        // We can't arbitrarily position the end pointer to the test pointer.
        // Consider the following case (input inside a positioned div)
        //
        //   |============|
        //   |            |
        //   |  ________  |
        //   | |________| |
        //   |            |
        //   |            |
        //   |============|
        //
        // We start selecting outside the positioned div, and we successfully text
        // select the div.  Now we move the mouse over the input.  The candidate
        // end of selection is over the input, but we cannot move the end of selection
        // to that point, as that would de text-select the div, which is not the behavior
        // we want.
        //
        // We want to make sure we don't position the end pointer across any elements
        // that are site-selectable.
        //

        IFC( GetCurrentScope(_pDispStartPointer, &spStartElement) );
        IFC( _pManager->GetSiteSelectableElementFromElement(spStartElement, &spStartSiteSelectElement ) );
        IFC( _pDispTestPointer->PositionMarkupPointer(spTestPointer) );
        IFC( GetEditor()->CurrentScopeOrMaster(spTestPointer, &spInThisElement ));

        //
        // Keep moving the test pointer until we come to an element which is not
        // site selectable
        //
        while( (_pManager->GetSiteSelectableElementFromElement(spInThisElement, &spSiteSelectThis ) == S_OK)
                && !(SameElements( spSiteSelectThis, spOldSiteSelect ) )
                && !(SameElements( spSiteSelectThis, spStartSiteSelectElement ) ) )
        {
            IFC( spTestPointer->MoveAdjacentToElement( spSiteSelectThis, eAdj ) );
            IFC( GetEditor()->CurrentScopeOrMaster( spTestPointer, &spInThisElement ) );

            spOldSiteSelect = spSiteSelectThis;
        }

        IFC( _pDispEndPointer->MoveToMarkupPointer(spTestPointer, NULL) );
        fAdjustedSelection = TRUE;
    }

Cleanup:
    return ( fAdjustedSelection );
}

//
//
// Privates / Utils
//
//

void
CSelectTracker::ResetSpringLoader( CSelectionManager* pManager, IMarkupPointer* pStart, IMarkupPointer* pEnd )
{
    CHTMLEditor   * ped = pManager ? pManager->GetEditor() : NULL;
    CSpringLoader * psl = ped ? ped->GetPrimarySpringLoader() : NULL;
    BOOL            fResetSpringLoader = FALSE;

    // Not using a BOOLEAN OR because it bugs PCLint, which thinks
    // that they're evaluated right to left.
    if (!psl)
        goto Cleanup;
    if (!psl->IsSpringLoaded())
        goto Cleanup;

    // Hack for Outlook: Are the pointers only separated by an &nbsp on an empty line.
    fResetSpringLoader = S_OK != psl->CanSpringLoadComposeSettings(pStart, NULL, FALSE, TRUE);
    if (fResetSpringLoader)
        goto Cleanup;

    {
        SP_IMarkupPointer   spmpStartCopy;
        BOOL                fEqual = FALSE;
        MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
        long                cch = 1;
        TCHAR               ch;
        HRESULT             hr;

        fResetSpringLoader = TRUE;

        hr = THR(CopyMarkupPointer(pManager->GetEditor(), pStart, &spmpStartCopy));
        if (hr)
            goto Cleanup;

        hr = THR(spmpStartCopy->Right(TRUE, &eContext, NULL, &cch, &ch));
        if (hr)
            goto Cleanup;

        hr = THR(spmpStartCopy->IsEqualTo(pEnd, &fEqual));
        if (hr)
            goto Cleanup;

        if (   eContext == CONTEXT_TYPE_Text
            && cch == 1
            && ch == WCH_NBSP
            && fEqual )
        {
            fResetSpringLoader = FALSE;
        }
    }

Cleanup:

    if (fResetSpringLoader)
        psl->Reset();
}

//+====================================================================================
//
// Method: SetState
//
// Synopsis: Set the State of the tracker. Don't set state if we're in the passive state
//           unless we're explicitly told to do so.
//
//------------------------------------------------------------------------------------

VOID
CSelectTracker::SetState(
                    SELECT_STATES inState,
                    BOOL fIgnorePassive /*=FALSE*/)
{
    if ( _fState != ST_PASSIVE || fIgnorePassive )
    {
        _fState = inState;
    }
}


//+====================================================================================
//
// Method: DoTimerDrag
//
// Synopsis: Do a drag from a EVT_TIMER message
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DoTimerDrag()
{
    HRESULT             hr = S_OK;
    CEdUndoHelper       undoDrag(GetEditor());
    SP_IHTMLElement3    spElement3;
    VARIANT_BOOL        fRet;
    SP_IDisplayPointer  spDispStart;
    SP_IDisplayPointer  spDispEnd;
    SP_IMarkupPointer   spStartSel,spEndSel ;
#if DBG == 1
    SP_IMarkupPointer   spTestPointer;
#endif
       
    Assert( _pIDragElement );        

    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispStart ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispEnd ));

    IFC( GetEditor()->CreateMarkupPointer( & spStartSel ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndSel ));
#if DBG == 1
    IFC( GetEditor()->CreateMarkupPointer( & spTestPointer ));
#endif
    IFC( _pISegment->GetPointers(spStartSel, spEndSel ) );

    IFC( spDispStart->MoveToMarkupPointer( spStartSel , NULL ));
    IFC( spDispEnd->MoveToMarkupPointer( spEndSel, NULL ));

    //
    // We would like to create a 'fake selection' when the edit context is editable.
    // For instance, when we drag from inside trident to another location inside Trident,
    // CDoc::DragEnter() destroys selection if the doc is in edit mode (so that document.selection
    // returns type CARET and the user gets visual feedback (in the form of a caret) of where
    // the drop would occur.  With the new IHighlightRenderingServices interface, we can
    // still render the original selection as selected to give feedback about what is being dropped
    //
    if( GetEditor()->IsContextEditable() )
    {
        IFC( _pManager->CreateFakeSelection( _pIDragElement, spDispStart, spDispEnd ));
    }

    //
    // Begin the drag
    //
    IFC( undoDrag.Begin(IDS_EDUNDOMOVE) );

    IGNORE_HR( GetSelectionManager()->FirePreDrag() );

    IFC( _pManager->BeginDrag(_pIDragElement));

    IFC(_pIDragElement->QueryInterface(IID_IHTMLElement3, (void**)&spElement3));

#if DBG == 1
    hr = THR( spTestPointer->MoveAdjacentToElement( _pIDragElement, ELEM_ADJ_BeforeBegin ) );
    Assert(hr == S_OK);
#endif

    IFC(spElement3->dragDrop(&fRet));

    hr = fRet ? S_OK : S_FALSE;

    if ( _pManager->HasFakeSelection() )
    {
        //  The drag may cause us to remove spElement3 from the tree, in which case ondragend will
        //  not be fired.  So we can't assume that if we still have a fake selection the drag
        //  failed.  If we do have a fake selection we'll check to make sure that the element
        //  is no longer positioned.
#if DBG == 1
        if( fRet )
        {
            hr = THR( spTestPointer->MoveAdjacentToElement( _pIDragElement, ELEM_ADJ_BeforeBegin ) );
            AssertSz(hr == CTL_E_UNPOSITIONEDELEMENT, "An error occurred during the drag");
        }
#endif
        IFC( _pManager->DestroyFakeSelection());
    }

    if (!fRet)
    {
        //  Drag failed.  Scroll selection back into view.
        IFC( spDispStart->ScrollIntoView() );
    }

    IFC( _pManager->EndDrag()); // ensure this happens

Cleanup:
    if ( FAILED(hr) )
    {
        // It is possible that we exited prematurely.  If this is the case we need to ensure
        // that we cleanup after ourself to make sure that we don't leak here.  We need to
        // ensure that we destroyed our fake selection and detached our drag listeners.
        
        TraceTag((tagError, "CSelectTracker::DoTimerDrag(): An error occurred during the drag.  hr=0x%x", hr));
        
        if ( _pManager->HasFakeSelection() )
        {
            IFC( _pManager->DestroyFakeSelection());
        }
        if (_pManager->_pIDropListener)
        {
            IFC( _pManager->EndDrag()); // ensure this happens
        }
    }

    Assert(!_pManager->HasFakeSelection());
    Assert(_pManager->_pIDragListener == NULL);
    Assert(_pManager->_pIDropListener == NULL);

    RRETURN ( hr );
}


VOID
CSelectTracker::SetMadeSelection( BOOL fMadeSelection )
{
    if ( ! _fMadeSelection )
    {
        _pManager->HideCaret();
    }
    _fMadeSelection = fMadeSelection;
}

//+====================================================================================
//
// Method: GetCaretStartPoint
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::GetCaretStartPoint(
                        CARET_MOVE_UNIT inCaretMove,
                        IDisplayPointer* pDispCopyStart )
{
    HRESULT     hr = S_OK;
    int         iWherePointer;
    SP_IMarkupPointer   spMarkup;
    SP_IHTMLElement     spAtomicElement;
    POINT               ptLoc;

    Assert( pDispCopyStart);

    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
    switch (inCaretMove)
    {
    case    CARET_MOVE_BACKWARD:
    case    CARET_MOVE_FORWARD:
    case    CARET_MOVE_WORDBACKWARD:
    case    CARET_MOVE_WORDFORWARD:
            {
                //
                // We really only care about PointerDirection when it is inline movement
                //
                Direction   dir;

                dir = GetPointerDirection(inCaretMove);
                if ( (RIGHT == iWherePointer && LEFT  == dir )||
                     (LEFT  == iWherePointer && RIGHT == dir )   )
                {
                    IFC( pDispCopyStart->MoveToPointer( _pDispStartPointer ) );
                }
                else
                {
                    IFC( pDispCopyStart->MoveToPointer( _pDispEndPointer ) );
                }
                break;
            }

     case CARET_MOVE_PREVIOUSLINE:
     case CARET_MOVE_NEXTLINE:
            {
                if (RIGHT == iWherePointer)
                {
                    IFC( pDispCopyStart->MoveToPointer(
                            (CARET_MOVE_PREVIOUSLINE == inCaretMove) ? _pDispStartPointer : _pDispEndPointer
                                )
                       );
                }
                else
                {
                    IFC( pDispCopyStart->MoveToPointer(
                            (CARET_MOVE_NEXTLINE == inCaretMove) ? _pDispStartPointer : _pDispEndPointer
                                )
                       );
                }
                IFC( GetLocationForDisplayPointer( pDispCopyStart, &_ptCurMouseXY, TRUE) );
                break;
            }

     default:
            {
                IFC( pDispCopyStart->MoveToPointer( _pDispEndPointer ) );
                _ptCurMouseXY.x = CARET_XPOS_UNDEFINED;
                _ptCurMouseXY.y = CARET_YPOS_UNDEFINED;
            }
     }

    //
    // Adjust the pointer
    //
    switch( inCaretMove )
    {
        case CARET_MOVE_BACKWARD:
            IFC( pDispCopyStart->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
            goto Cleanup;

        case CARET_MOVE_FORWARD:
            IFC( pDispCopyStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            goto Cleanup; // we're done

        case CARET_MOVE_WORDBACKWARD:
        case CARET_MOVE_WORDFORWARD:
            if (IsAtWordBoundary(pDispCopyStart))
            {
                IFC( pDispCopyStart->SetDisplayGravity(
                        (inCaretMove == CARET_MOVE_WORDFORWARD) ? DISPLAY_GRAVITY_NextLine : DISPLAY_GRAVITY_PreviousLine) );
                goto Cleanup; // we're done
            }
            break;

        case CARET_MOVE_NEXTLINE:
            {
                //
                // Adjust pointer if it is located at the end of scope position
                //
                ED_PTR( epScan );
                DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor; // anchors are just phrase elements to me here
                DWORD dwFound  = BREAK_CONDITION_None;

                IFC( pDispCopyStart->PositionMarkupPointer(epScan) );
                IFC( epScan.Scan(LEFT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {
                    //
                    // Try to position the caret inside the closing scope
                    // If it fails, leave the caret positioned at the end of selection
                    //

                    hr = THR( pDispCopyStart->MoveToMarkupPointer(epScan, NULL) );

                    if( hr == CTL_E_INVALIDLINE )
                    {
                        hr = S_OK;
                    }

                }
            }

            break;

        default:
            //
            // boundary cases are excepted to return failure codes but don't move the pointer
            //
            break;
    }

    ptLoc = _ptCurMouseXY;
    if (inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE)
    {
        //
        // For up/down movement, we always want to use
        // either the virtual caret position saved for 
        // due to tracker transition from caret to 
        // selection if we have one. 
        //
        // Otherwise we want the "end of selection" position,
        // which is implied by MovePointer (it calls GetLocation
        // on select tracker which uses _pDispEndSelection)
        // so in this case we want to flush out ptLoc, pass in 
        // _undefined_ value to MovePointer. 
        // 
        // [zhenbinx]
        //
        SP_IHTMLCaret   spCaret;

        IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->MoveMarkupPointerToCaret(spMarkup) );
        IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
    }

    IGNORE_HR(MovePointer(inCaretMove, pDispCopyStart, &ptLoc));

    //
    // To be used by caret tracker
    //
    if (inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE)
    {
        IFC( pDispCopyStart->PositionMarkupPointer(spMarkup) );
        IFC( _ptVirtualCaret.UpdatePosition(spMarkup, ptLoc) );
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MovePointersToTrueStartAndEnd(
    IMarkupPointer* pTrueStart,
    IMarkupPointer* pTrueEnd,
    BOOL *pfSwap ,
    BOOL *pfEqual /*= NULL*/ )
{
    HRESULT hr = S_OK;
    int iWherePointer = SAME;
    BOOL fSwap = FALSE;

    IFC( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & iWherePointer ));
    if ( iWherePointer == LEFT )
    {
        IFC( _pDispEndPointer->PositionMarkupPointer(pTrueStart) );
        IFC( _pDispStartPointer->PositionMarkupPointer(pTrueEnd) );
        fSwap = TRUE;
    }
    else
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(pTrueStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(pTrueEnd) );
    }
Cleanup:
    if ( pfSwap )
        *pfSwap = fSwap;
    if ( pfEqual )
        *pfEqual = ( iWherePointer == 0);

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsBetweenBlocks
//
// Synopsis: Look for the Selection being in the "magic place" at the end of a block.
//
//------------------------------------------------------------------------------------

//
// Ignore BR's !
//
BOOL
CSelectTracker::IsBetweenBlocks( IDisplayPointer* pDispPointer )
{
    HRESULT hr;
    BOOL    fBetween = FALSE;
    DWORD   dwBreakCondition = BREAK_CONDITION_Content;
    DWORD   dwFoundLeft;
    DWORD   dwFoundRight;

    ED_PTR( scanPointer );

    IFC( pDispPointer->PositionMarkupPointer(scanPointer) );
    IFC( scanPointer.Scan( LEFT, dwBreakCondition, &dwFoundLeft ));

    IFC( pDispPointer->PositionMarkupPointer(scanPointer) );
    IFC( scanPointer.Scan( RIGHT, dwBreakCondition, &dwFoundRight ) );

    if( (scanPointer.CheckFlag( dwFoundLeft, BREAK_CONDITION_EnterBlock ) &&
         scanPointer.CheckFlag( dwFoundRight, BREAK_CONDITION_EnterBlock ) ) )
    {
        fBetween = TRUE;
    }

Cleanup:
    return fBetween;
}


//+====================================================================================
//
// Method: IsAtEdgeOfTable
//
// Synopsis: Are we at the edge of the table ( ie. by scanning left/right do we hit a TD ?)
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAtEdgeOfTable( Direction iDirection, IMarkupPointer* pPointer )
{
    HRESULT hr;
    BOOL fAtEdge = FALSE;
    DWORD dwBreakCondition = 0;
    IHTMLElement* pIElement = NULL;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    ED_PTR( scanPointer );
    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.Scan( iDirection,
                           BREAK_CONDITION_Content - BREAK_CONDITION_Block ,
                           & dwBreakCondition,
                           & pIElement));

    if ( scanPointer.CheckFlag( dwBreakCondition,
                                BREAK_CONDITION_Site ) )
    {
        IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));

        if ( IsTablePart( eTag ) || eTag == TAGID_TABLE  )
        {
            fAtEdge = TRUE;
        }
    }

Cleanup:
    ReleaseInterface( pIElement );

    return fAtEdge;
}

//+====================================================================================
//
// Method: MoveSelection
//
// Synopsis: Adjust a Selection's start/end points based on the CaretMoveUnit ( used
//           for keyboard navigation in shift selection).
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::MoveSelection(  CARET_MOVE_UNIT inCaretMove )
{
    HRESULT             hr = S_OK;
    POINT               ptLoc;
    BOOL                fBetweenBlocks = FALSE;     // Was the shift ptr in between blocks before the move?
    BOOL                fBlockEmpty = FALSE;        // Is the block where shift ptr is at empty?
    SP_IMarkupPointer   spEndPointer;               // IMarkupPointer based shift ptr
    SP_ILineInfo        spLineInfo;
    CPoint              ptMouse;
    CBlockPointer       ptrBlock( GetEditor() );    // Block where shift ptr ended up


    //
    // Move end of selection
    //
    GetLocation(&ptLoc, TRUE);

    fBetweenBlocks = IsBetweenBlocks( _pDispShiftPointer );

    if ( FAILED( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc)) &&
        ( ! fBetweenBlocks  || inCaretMove == CARET_MOVE_PREVIOUSLINE || inCaretMove == CARET_MOVE_NEXTLINE ) )
    {
        //
        // Ignore HR code here - we still want to constrain, adjust and update.
        //
        if (GetPointerDirection(inCaretMove) == RIGHT)
        {
            IGNORE_HR(MovePointer(CARET_MOVE_LINEEND, _pDispShiftPointer, &ptLoc));
        }
        else
        {
            IGNORE_HR(MovePointer(CARET_MOVE_LINESTART, _pDispShiftPointer, &ptLoc));
        }
    }

    //
    // Before we call AdjustSelection, we should try and do major adjustments here.
    //
    // A major adjustment includes selecting additional words or characters during
    // a single selection move.
    //
    // For example, If we were between blocks and we tried to move forward, then
    // we need to call MovePointer() again to select the first character in the next block.
    //
    // Likewise, if we were moving forwards or backwards by one character or
    // on word, and we ended up on a table boundary with content in that
    // boundary, we need to select the content.  This fixes VID issues like
    // bug 71907.
    //
    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
    IFC( _pDispShiftPointer->PositionMarkupPointer(spEndPointer) );

    if( inCaretMove == CARET_MOVE_FORWARD     || inCaretMove == CARET_MOVE_BACKWARD ||
        inCaretMove == CARET_MOVE_WORDFORWARD || inCaretMove == CARET_MOVE_WORDBACKWARD )
    {
        IFC( ptrBlock.MoveTo( spEndPointer, GetPointerDirection(inCaretMove) ) );
        IFC( ptrBlock.IsEmpty( &fBlockEmpty ) );

        if( ( IsAtEdgeOfTable( Reverse( GetPointerDirection(inCaretMove)), spEndPointer) &&
              !fBlockEmpty ) )
        {
            IFC( MovePointer(inCaretMove, _pDispShiftPointer, &ptLoc));
        }
    }

    //
    // Constrain and scroll
    //
    IFC( _pDispEndPointer->MoveToPointer( _pDispShiftPointer ) );
    IFC( ConstrainSelection() );
    SetLastCaretMove( inCaretMove );
    IFC( AdjustSelection(NULL));
    IFC( _pDispEndPointer->ScrollIntoView() );

    //
    // Update _curMouseX/Y
    //
    if (CARET_XPOS_UNDEFINED == ptLoc.x || CARET_XPOS_UNDEFINED == ptLoc.y)
    {
        //
        //  ??? I don't know why it needs to be FALSE
        //  but it is the only way for the program to
        //  pass DRT  (Zhenbinx)
        //
        GetLocation(&_ptCurMouseXY, FALSE);
    }

    //
    // Update segment list
    //
    IFC( UpdateSelectionSegments() );

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: MoveEndToPointer
//
// Synopsis: Wrapper To MoveToPointer. Allowing better debugging validation.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::MoveEndToPointer( IDisplayPointer* pDispPointer, BOOL fInSelection /*=FALSE*/ )
{
    HRESULT hr = S_OK;

#if DBG == 1
    int oldEndCp = 0;
    int startCp = 0;
    int endCp = 0;

    if ( IsTagEnabled( tagSelectionValidate ))
    {
        oldEndCp = GetCp( _pDispEndPointer );
        startCp = GetCp( _pDispStartPointer );
    }
    endCp = GetCp( pDispPointer );

#endif

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispEndPointer, pDispPointer) );

    hr = THR ( _pDispEndPointer->MoveToPointer( pDispPointer ));

    if (fInSelection)
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope(_pDispEndPointer, &spElement) );
        if (_pManager->CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spPointer;
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtStartOfElement = FALSE;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( _pDispEndPointer->PositionMarkupPointer(spPointer) );

            IFC( spTestPointer->MoveAdjacentToElement( spElement,
                                                GetMoveDirection() ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd) );

            IFC( spTestPointer->IsEqualTo(spPointer, &fAtStartOfElement) );

            if (!fAtStartOfElement)
            {
                IFC( spPointer->MoveAdjacentToElement( spElement,
                                                    GetMoveDirection() ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );
            }
        }
    }

#if DBG == 1
    if ( IsTagEnabled( tagSelectionValidate))
    {
        endCp = GetCp( _pDispEndPointer );
        if ( endCp != 0 &&
             oldEndCp != -1 &&
            ( endCp - startCp == 0 ) &&
            ( oldEndCp - startCp != 0 ) )
        {
            DumpTree(_pDispEndPointer);
            AssertSz(0,"Selection jumpted to zero");
        }
    }
#endif

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::MoveEndToMarkupPointer( IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext, BOOL fInSelection /*=FALSE*/)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pPointer, pDispLineContext) );
    IFC( MoveEndToPointer(spDispPointer, fInSelection) );

Cleanup:
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: MoveEndToPointer
//
// Synopsis: Wrapper To MoveToPointer. Allowing better debugging validation.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::MoveStartToPointer( IDisplayPointer* pDispPointer, BOOL fInSelection /*=FALSE*/ )
{
    HRESULT hr = S_OK;

#if DBG==1
    int oldStartCp = 0;
    int startCp = 0;

    oldStartCp = GetCp( _pDispStartPointer );
    startCp = GetCp( pDispPointer );
#endif

    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, pDispPointer) );

    hr = THR ( _pDispStartPointer->MoveToPointer( pDispPointer ));

    if (fInSelection)
    {
        SP_IHTMLElement     spElement;

        IFC( GetCurrentScope(_pDispStartPointer, &spElement) );
        if (_pManager->CheckAtomic( spElement ) == S_OK )
        {
            SP_IMarkupPointer   spPointer;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( spPointer->MoveAdjacentToElement( spElement,
                                                GetMoveDirection() ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
            IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );
        }
    }

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::MoveStartToMarkupPointer( IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext, BOOL fInSelection /*=FALSE*/)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pPointer, pDispLineContext) );
    IFC( MoveStartToPointer(spDispPointer, fInSelection) );

Cleanup:
    RRETURN ( hr );
}


VOID
CSelectTracker::BecomePassive(BOOL fPositionCaret )
{
    SetState( ST_PASSIVE );

    if ( _pManager->IsInTimer() )
        StopTimer();
    if (  _pManager->IsInCapture()  )
        ReleaseCapture();

    if ( _fInSelTimer )
    {
        StopSelTimer();
        Assert( ! _fInSelTimer );
    }

    if ( ! _pManager->IsInFireOnSelectStart() && !CheckSelectionWasReallyMade() )
    {
        if ( fPositionCaret )
        {
            _pManager->PositionCaret( _pDispStartPointer );
        }
    }
}


//+====================================================================================
//
// Method: ScrollMessageIntoView.
//
// Synopsis: Wrapper to ScrollPointIntoView
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScrollMessageIntoView(
            CEditEvent* pEvent,
            BOOL fScrollSelectAnchorElement /*=FALSE*/)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    WHEN_DBG( _ctScrollMessageIntoView++);
    POINT pt;
    IFC( pEvent->GetPoint( & pt ));
    RECT rect;

    rect.left = pt.x - scrollSize;
    rect.right = pt.x + scrollSize;
    rect.top = pt.y - scrollSize;
    rect.bottom = pt.y + scrollSize;

    spElement = (fScrollSelectAnchorElement && _pIScrollingAnchorElement) ? _pIScrollingAnchorElement : _pManager->GetEditableElement();

    // Can't pass a null element to ScrollRectIntoView, so make sure we have one first.
    if (spElement)
    {
        IFC( GetDisplayServices()->ScrollRectIntoView(spElement , rect) );
    }

Cleanup:
    RRETURN ( hr );

}

//+====================================================================================
//
// Method: GetStartSelectionForSpringLoader
//
// Synopsis: Seek out Font Tags to fall into for the spring loader.
//
//------------------------------------------------------------------------------------


HRESULT
CSelectTracker::GetStartSelectionForSpringLoader( IMarkupPointer* pPointerStart)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE eRightContext = CONTEXT_TYPE_None;
    BOOL fHitText = FALSE;
    SP_IMarkupPointer spBoundary;
    BOOL fFurtherInStory = GetMoveDirection();

    IFC( GetEditor()->CreateMarkupPointer(&spBoundary) );

    if ( fFurtherInStory )
    {
        IFC( _pDispStartPointer->PositionMarkupPointer(pPointerStart) );
        IFC( _pDispEndPointer->PositionMarkupPointer(spBoundary) );
    }
    else
    {
        IFC( _pDispEndPointer->PositionMarkupPointer(pPointerStart) );
        IFC( _pDispStartPointer->PositionMarkupPointer(spBoundary) );
    }
    IFC( pPointerStart->Right( FALSE, & eRightContext, NULL, NULL, NULL));

    //
    // Don't do anything if we're already in Text
    //
    if ( eRightContext != CONTEXT_TYPE_Text )
    {
        IFC( MovePointerToText(
                    GetEditor(),
                    pPointerStart,
                    RIGHT,
                    spBoundary,
                    &fHitText,
                    FALSE ) );
    }
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsAdjacentToBlock
//
// Synopsis: Scan in a given direction - looking for a block.
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAdjacentToBlock(
                    IMarkupPointer* pPointer,
                    Direction iDirection,
                    DWORD* pdwBreakCondition)
{
    BOOL fHasBlock = FALSE ;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    HRESULT hr;
    ED_PTR( pEditPointer );
    DWORD dwBreakCondition = 0;

    Assert( iDirection == LEFT || iDirection == RIGHT );

    if ( iDirection == LEFT )
    {
        IFC( pPointer->Left( FALSE, &eContext, NULL, NULL, NULL ));
    }
    else
    {
        IFC( pPointer->Right( FALSE, &eContext, NULL, NULL, NULL ));
    }
    if ( eContext == CONTEXT_TYPE_Text )
        goto Cleanup;

    IFC( pEditPointer.MoveToPointer( pPointer ));
    if ( iDirection == LEFT )
    {
        IFC( pEditPointer.SetBoundary( _pManager->GetStartEditContext() , pPointer  ));
    }
    else
    {
        IFC( pEditPointer.SetBoundary( pPointer, _pManager->GetEndEditContext() ));
    }

    //
    // Scan for the End of the Boundary
    //
    IGNORE_HR( pEditPointer.Scan(
                                 iDirection ,
                                 BREAK_CONDITION_Text           |
                                 BREAK_CONDITION_NoScopeSite    |
                                 BREAK_CONDITION_NoScopeBlock   |
                                 BREAK_CONDITION_Site           |
                                 BREAK_CONDITION_Block          |
                                 BREAK_CONDITION_BlockPhrase    |
                                 BREAK_CONDITION_Phrase         |
                                 BREAK_CONDITION_Anchor         |
                                 BREAK_CONDITION_Control ,
                                 & dwBreakCondition,
                                 NULL,
                                 NULL,
                                 NULL ));

    if ( pEditPointer.CheckFlag( dwBreakCondition,  BREAK_CONDITION_Block |
                                                    BREAK_CONDITION_Site |
                                                    BREAK_CONDITION_Control |
                                                    BREAK_CONDITION_NoScopeBlock ) )
    {
        fHasBlock = TRUE;
    }

Cleanup:
    if ( pdwBreakCondition )
        *pdwBreakCondition = dwBreakCondition;

    return fHasBlock;
}




//+====================================================================================
//
// Method: IsAtWordBoundary
//
// Synopsis: Check to see if we're already at the start of a word boundary
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::IsAtWordBoundary(
                IMarkupPointer* pPointer,
                BOOL * pfAtStart, /*= NULL */
                BOOL *pfAtEnd /*= NULL */,
                BOOL fAlwaysTestIfAtEnd /* = FALSE*/ )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartTest;
    SP_IMarkupPointer2  spPointer2;   
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                fAtStart = FALSE;
    BOOL                fAtEnd = FALSE;
    BOOL                fAtWordBreak;
    BOOL                fAtEditWordBreak = FALSE;
    MARKUP_CONTEXT_TYPE pContext;
    //
    // Quick word boundary test (perf optimization)
    // If pointer is in an Anchor, do not call is at word break
    // because we consider Anchors word breaks.
    //

    IFC( pPointer->CurrentScope( &spElement ) );
    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
    if ( tagId != TAGID_A )
    {
        //
        // IE Bug #28647 (mharper) need to also test for the case
        // where the pointer is immediately before the anchor.
        //
        // IE Bug #28830 (mharper) added check to see if we are entering scope
        // on a <SELECT> as well due to a problem where ClassifyNodePos() believes
        // that a select is NODECLASS_NONE.  It would be better to fix that, but
        // that would be too fundamental a change this late (RC1)
        //
        
        IFC( pPointer->Right(FALSE, &pContext, &spElement, NULL, NULL) );
        if ( pContext == CONTEXT_TYPE_EnterScope )
        {
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if( tagId == TAGID_A || tagId == TAGID_SELECT )
            {
                fAtEditWordBreak = TRUE;
            }
        }

        if( !fAtEditWordBreak )
        {
            IFC( pPointer->Left(FALSE, &pContext, &spElement, NULL, NULL) );
            if ( pContext == CONTEXT_TYPE_EnterScope )
            {
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId));
                if( tagId == TAGID_SELECT )
                {
                    fAtEditWordBreak = TRUE;
                }
            }
        }

        if ( !fAtEditWordBreak )
        {

            IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
        
            IFC( spPointer2->IsAtWordBreak(&fAtWordBreak) );
            if (!fAtWordBreak)
                goto Cleanup;

        }

    }
    
    //
    // Check to see if we're at a word boundary
    //
    
    IFC( GetEditor()->CreateMarkupPointer(& spStartTest ));
    IFC( spStartTest->MoveToPointer( pPointer ));


    //
    // Start of Word Case
    //

    //
    // We don't call MoveWord here - as we really want to go to NextWordEnd.
    //

    IFC( MoveWord( spStartTest, MOVEUNIT_NEXTWORDBEGIN ));
    IFC( MoveWord( spStartTest, MOVEUNIT_PREVWORDBEGIN ));
    IFC( spStartTest->IsEqualTo( pPointer, & fAtStart ));

    //
    // End of Word case
    //
    if ( !fAtStart || fAlwaysTestIfAtEnd )
    {
        IFC( spStartTest->MoveToPointer( pPointer ));
        IFC( MoveWord( spStartTest, MOVEUNIT_PREVWORDBEGIN ));
        IFC( MoveWord( spStartTest, MOVEUNIT_NEXTWORDBEGIN ));
        IFC( spStartTest->IsEqualTo( pPointer, & fAtEnd ));
    }


Cleanup:
    AssertSz(!FAILED(hr), "Failure in IsAtWordBoundary");

    if ( pfAtStart )
        *pfAtStart = fAtStart;
    if ( pfAtEnd )
        *pfAtEnd = fAtEnd;

    return ( fAtStart || fAtEnd );
}



HRESULT
CSelectTracker::ScanForLastExitBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            BOOL *pfFoundBlock /* = NULL */  )
{
    RRETURN( ScanForLastEnterOrExitBlock( iDirection,
                                          pPointer,
                                          BREAK_CONDITION_ExitBlock | BREAK_CONDITION_NoScopeBlock,
                                          pfFoundBlock ));
}

//+====================================================================================
//
// Method: IsAtWordBoundary
//
// Synopsis: Check to see if we're already at the start of a word boundary
//
//------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsAtWordBoundary( IDisplayPointer* pDispPointer, BOOL * pfAtStart, BOOL* pfAtEnd, BOOL fAlwaysTestIfAtEnd)
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    return IsAtWordBoundary(spPointer, pfAtStart, pfAtEnd, fAlwaysTestIfAtEnd);

Cleanup:
    return FALSE;
}

HRESULT
CSelectTracker::ScanForLastEnterBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            BOOL* pfFoundBlock  )
{
    RRETURN( ScanForLastEnterOrExitBlock( iDirection,
                                          pPointer,
                                          BREAK_CONDITION_EnterBlock | BREAK_CONDITION_NoScopeBlock,
                                          pfFoundBlock ));
}

//+====================================================================================
//
// Method: ScanForLastEnterOrExitBlock
//
// Synopsis: While you have ExitBlock - keep scanning. Return the markup pointer after the last
//           exit block.
//
//           Although this routine has a very big similarity to ScanForEnterBlock - I have
//           split it into two routines as it's less error prone.
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScanForLastEnterOrExitBlock(
            Direction iDirection,
            IMarkupPointer* pPointer,
            DWORD dwTerminateCondition ,
            BOOL *pfFoundBlock /*=NULL*/ )
{
    HRESULT hr = S_OK;
    BOOL fFoundBlock = FALSE;
    ED_PTR( scanPointer);
    ED_PTR( beforeScanPointer );

    DWORD dwBreakCondition = 0;

    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));
    IFC( beforeScanPointer.MoveToPointer( scanPointer ));

    IFC( scanPointer.Scan( iDirection,
                      BREAK_CONDITION_Content ,
                      & dwBreakCondition ));

    while ( scanPointer.CheckFlag( dwBreakCondition, dwTerminateCondition ))
    {
        fFoundBlock = TRUE;

        IFC( beforeScanPointer.MoveToPointer( scanPointer ));

        IFC( scanPointer.Scan( iDirection,
                          BREAK_CONDITION_Content ,
                          & dwBreakCondition ));
    }

    if ( ! scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary)  )
    {
        //
        // Go back to where you were.
        //
        IFC( scanPointer.MoveToPointer( beforeScanPointer ));
    }

    IFC( pPointer->MoveToPointer( scanPointer ));

Cleanup:
    if ( pfFoundBlock )
        *pfFoundBlock = fFoundBlock ;

    RRETURN( hr );
}


//+====================================================================================
//
// Method: ScanForLayout
//
// Synopsis: Scan in the given direction - for a given layout
//
//           We try to scan until we are inside a given layout.
//           We break on BlockEnter or Text (anything that's not BLOCK_Enter or ExitSite).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ScanForLayout(
                    Direction iDirection,
                    IMarkupPointer* pPointer,
                    IHTMLElement* pILayoutElement,
                    BOOL* pfFoundLayout /*=NULL*/,
                    IHTMLElement** ppILayoutElementEnd /* = NULL */ )
{
    HRESULT         hr = S_OK;
    BOOL            fFoundLayout = FALSE;
    SP_IHTMLElement spCurElement;
    DWORD           dwBreakCondition = 0;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

    ED_PTR( scanPointer);

    IFC( scanPointer.MoveToPointer( pPointer ));
    IFC( scanPointer.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()));

    //
    // Scan for layout sites.  We don't want to treat tables as layouts in this scan if we
    // are doing a ScanForLayout() as a result of a shift selection.
    //
    IFC( scanPointer.Scan(  iDirection,
                            BREAK_CONDITION_Content - BREAK_CONDITION_ExitSite - BREAK_CONDITION_ExitBlock,
                            &dwBreakCondition,
                            &spCurElement ) );

    if( spCurElement )
    {
        IFC( GetMarkupServices()->GetElementTagId( spCurElement, &eTag ) );
    }

    if ( scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_EnterSite ) &&
         spCurElement &&
         SameElements( spCurElement, pILayoutElement ) &&
         (!IsTablePart( eTag ) || !_fShift) )
    {
        fFoundLayout = TRUE;
    }

    if( ( fFoundLayout ||  scanPointer.CheckFlag( dwBreakCondition, BREAK_CONDITION_EnterSite ) ) &&
        (!IsTablePart(eTag) || !_fShift) )
    {
        IFC( pPointer->MoveToPointer( scanPointer ));
    }

Cleanup:
    if ( fFoundLayout )
    {
        ReplaceInterface( ppILayoutElementEnd, (IHTMLElement *)spCurElement );
    }

    *pfFoundLayout= fFoundLayout ;

    RRETURN( hr );
}




//+====================================================================================
//
// Method: GetMoveDirection
//
// Synopsis: Get the direction in which selection is occuring.
//
//  Return True - if we're selecting further in the story (From L to R in a LTR layout).
//         False - if we're selecting earlier in the story ( From R to L in a LTR layout).
//
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::GetMoveDirection()
{
    BOOL fFurtherInStory = FALSE;
    int wherePointer = SAME;
    HRESULT hr = S_OK;

    hr = THR ( _pManager->GetEditor()->OldDispCompare( _pDispStartPointer, _pDispEndPointer, & wherePointer));
    if (( wherePointer == SAME ) || ( hr == E_INVALIDARG ))
    {
        //
        // TODO does this break under RTL ?
        //
        POINT ptGuess;
        ptGuess.x = _ptCurMouseXY.x;
        ptGuess.y = _ptCurMouseXY.y;
        fFurtherInStory = GuessDirection( & ptGuess );
    }
    else
        fFurtherInStory = ( wherePointer == RIGHT ) ? TRUE : FALSE;

    return fFurtherInStory;
}



//+====================================================================================
//
// Method: GetDirection
//
// Synopsis: our _pDispTestPointer is equal to our previous test. So we use the Point
//           to guess the direction. The "guess" is actually ok once there is some delta
//           from _anchorMouseX and _anchorMouseY
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::GuessDirection(POINT* ppt)
{
    if ( ppt && ppt->x != _anchorMouseX )
    {
        return ppt->x >= _anchorMouseX ;    // did we go past _anchorMouseX ?
    }
    else if ( ppt && ppt->y != _anchorMouseX)
    {
        return ppt->y >= _anchorMouseY;  // did we go past _anchorMouseY ?
    }
    else if (_lastCaretMove != CARET_MOVE_NONE)
    {
        return (GetPointerDirection(_lastCaretMove) == RIGHT);
    }

    return TRUE ; // we're really and truly in the same place. Default to TRUE.

}




//+==========================================================================================
//
//  Method: IsValidMove
//
// Synopsis: Check the Mouse has moved by at least _sizeDragMin - to be considered a "valid move"
//
//----------------------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsValidMove ( const POINT*  ppt )
{
    return ((abs(ppt->x - _anchorMouseX ) > GetMinDragSizeX() ) ||
        (abs( ppt->y - _anchorMouseY) > GetMinDragSizeY() )) ;

}


//+====================================================================================
//
// Method: VeriyOkToStartSelection
//
// Synopsis: Verify that it is ok to start the selection now. If not we will Assert
//
//          The Selection manager should have inially called ShouldBeginSelection
//          before starting a given tracker. This method checks that this is so.
//
//------------------------------------------------------------------------------------

#if DBG == 1

VOID
CSelectTracker::VerifyOkToStartSelection( CEditEvent* pEvent )
{

    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    IHTMLElement* pElement = NULL;
    SST_RESULT eResult = SST_NO_CHANGE;

    if ( _fState == ST_WAIT2 ) // it is always ok to start a selection in the middle of a selection
    {
        //
        // Examine the Context of the thing we started dragging in.
        //


        IFC( pEvent->GetElementAndTagId( & pElement, & eTag ));

        ShouldStartTracker( pEvent, eTag , pElement, &eResult);
        Assert( eResult == SST_NO_CHANGE || eResult == SST_CHANGE || eResult == SST_NO_BUBBLE );
    }
Cleanup:

    ReleaseInterface( pElement );

}

#endif

//+====================================================================================
//
// Method: ClearSelection
//
// Synopsis: Clear the current IHighlightRenderingServices
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::ClearSelection()
{
    HRESULT         hr = S_OK;

    if ( _pManager && _pISegment )
    {
        IFC( GetSelectionServices()->RemoveSegment( _pISegment ) );
        ClearInterface( & _pISegment );
    }
    if( _pIRenderSegment && GetHighlightServices() )
    {
        IFC( GetHighlightServices()->RemoveSegment( _pIRenderSegment ) );
        ClearInterface( &_pIRenderSegment );
    }


Cleanup:

    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: CheckSelectionWasReallyMade
//
// Synopsis: Verify that a Selection Was really made, ie start and End aren't in same point
//
//------------------------------------------------------------------------------------


BOOL
CSelectTracker::CheckSelectionWasReallyMade()
{
    BOOL fEqual = TRUE;

    IGNORE_HR( _pDispStartPointer->IsEqualTo(_pDispEndPointer, &fEqual) );

    return !fEqual;
}

//+====================================================================================
//
// Method:  Is Jumpover AtBrowse
// Synopsis: If we start a selection outside one of these
//              Do we want to Jump Over this tag at browse time ?
//
//
// Note that this is almost the same as IsSiteSelectable EXCEPT for Marquee
//
//------------------------------------------------------------------------------------

BOOL
CSelectTracker::IsJumpOverAtBrowse( IHTMLElement* pIElement, ELEMENT_TAG_ID eTag )
{
    switch ( eTag )
    {

        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_OBJECT:
        case TAGID_TEXTAREA:
        case TAGID_IMG:
        case TAGID_APPLET:
        case TAGID_SELECT:
        case TAGID_HR:
        case TAGID_OPTION:
        case TAGID_IFRAME:
        case TAGID_LEGEND:

            return TRUE;

        default:
            return FALSE;
    }
}

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

void
CSelectTracker::StateToString(TCHAR* pAryMsg, SELECT_STATES inState )
{
    switch ( inState )
    {
    case ST_START:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_START"));
        break;

    case ST_WAIT1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT1"));
        break;

    case ST_DRAGOP:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DRAGOP"));
        break;

    case ST_MAYDRAG:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYDRAG"));
        break;

    case ST_WAITBTNDOWN1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITBTNDOWN1"));
        break;

    case ST_WAIT2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT2"));
        break;

    case ST_DOSELECTION:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DOSELECTION"));
        break;

    case ST_WAITBTNDOWN2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITBTNDOWN2"));
        break;

    case ST_WAITCLICK:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAITCLICK"));
        break;

    case ST_SELECTEDWORD:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_SELECTEDWORD"));
        break;

    case ST_SELECTEDPARA:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_SELECTEDPARA"));
        break;

    case ST_WAIT3RDBTNDOWN:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_WAIT3RDBTNDOWN"));
        break;

    case ST_MAYSELECT1:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYSELECT1"));
        break;

    case ST_MAYSELECT2:
        edWsprintf( pAryMsg , _T("%s"), _T("ST_MAYSELECT2"));
        break;

    case ST_STOP :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_STOP"));
        break;

    case ST_PASSIVE :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_PASSIVE"));
        break;

    case ST_DORMANT :
        edWsprintf( pAryMsg , _T("%s"), _T("ST_DORMANT"));
        break;

    default:
        AssertSz(0,"Unknown State");
    }
}


void
CSelectTracker::ActionToString(TCHAR* pAryMsg, ACTIONS inState )
{
    switch ( inState )
    {

    case A_UNK:
        edWsprintf( pAryMsg , _T("%s"), _T("A_UNK"));
        break;

    case A_ERR:
        edWsprintf( pAryMsg , _T("%s"), _T("A_ERR"));
        break;

    case A_DIS:
        edWsprintf( pAryMsg , _T("%s"), _T("A_DIS"));
        break;

    case A_IGN:
        edWsprintf( pAryMsg , _T("%s"), _T("A_IGN"));
        break;

    case A_1_2:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_2"));
        break;

    case A_1_4:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_4"));
        break;

    case A_1_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_14"));
        break;

    case A_2_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_2_14"));
        break;

    case A_2_14r:
        edWsprintf( pAryMsg , _T("%s"), _T("A_2_14r"));
        break;

    case A_3_2:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_2"));
        break;

    case A_3_2m:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_2m"));
        break;

    case A_3_14:
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_14"));
        break;

    case A_4_8:
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_8"));
        break;

    case A_4_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_14"));
        break;

    case A_4_14m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_14m"));
        break;

    case A_5_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_6"));
        break;
    case A_6_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_6"));
        break;
    case A_6_6m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_6m"));
        break;
    case A_6_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_6_14"));
        break;

    case A_7_7 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_7"));
        break;

    case A_7_8 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_8"));
        break;

    case A_16_8 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_8"));
        break;

    case A_7_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_14"));
        break;

    case A_8_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_6"));
        break;
    case A_8_10 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_10"));
        break;
    case A_9_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_6"));
        break;
    case A_9_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_14"));
        break;
    case A_10_9 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_9"));
        break;
    case A_10_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_14"));
        break;
    case A_10_14m :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_14m"));
        break;
    case A_11_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_11_6"));
        break;
    case A_11_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_11_14"));
        break;
    case A_12_6 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_6"));
        break;
    case A_12_14 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_14"));
        break;

    case A_1_15:
        edWsprintf( pAryMsg , _T("%s"), _T("A_1_15"));
        break;
    case A_4_15:
        edWsprintf( pAryMsg , _T("%s"), _T("A_4_15"));
        break;

    case A_3_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_3_15"));
        break;

    case A_5_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_15"));
        break;

    case A_7_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_7_15"));
        break;

    case A_8_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_8_15"));
        break;

    case A_9_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_9_15"));
        break;

    case A_10_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_10_15"));
        break;

    case A_12_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_12_15"));
        break;

    case A_5_16 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_5_16"));
        break;

    case A_16_7 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_7"));
        break;

    case A_16_15 :
        edWsprintf( pAryMsg , _T("%s"), _T("A_16_15"));
        break;

    default:
        AssertSz(0,"Unknown State");
    }
}

void
CSelectTracker::DumpSelectState(
                        CEditEvent* pEvent ,
                        ACTIONS inAction,
                        BOOL fInTimer /*=FALSE*/ )
{
    TCHAR sSelectState[20];
    CHAR sMessageType[50];
    TCHAR sAction[20];
    CHAR        achBuf[4096];

    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //

    StateToString( sSelectState, _fState );
    if ( pEvent )
    {
        pEvent->toString( sMessageType );
    }

    if ( ! fInTimer )
        ActionToString( sAction, inAction);

    if ( ! fInTimer )
    {
        wsprintfA(
            achBuf,
            "Tracker State: %ls Action:%ls Event:%s ",
            sSelectState,sAction, sMessageType);
    }
    else
    {
        wsprintfA(
            achBuf,
            "\n. Tracker State: %ls ",
            sSelectState,sAction );
    }

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");
}

#endif


HRESULT
CSelectTracker::StartTimer()
{
    HRESULT hr = S_OK;
    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pManager->GetActiveTracker() == this )
    {
        Assert( ! _pManager->IsInTimer() );
        TraceTag(( tagSelectionTrackerState, "Starting Timer"));
        hr = THR(GetEditor()->StartDblClickTimer());
#if DBG==1  /* Keeps PREfix happy */
        if ( hr )
            AssertSz(0, "Error starting timer");
#endif
        if (!hr)
        {
            _pManager->SetInTimer( TRUE);
        }
    }
    
    RRETURN( hr );
}

HRESULT
CSelectTracker::StopTimer()
{
    HRESULT hr = S_OK;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pManager->GetActiveTracker() == this )
    {
        Assert( _pManager->IsInTimer() );

        TraceTag(( tagSelectionTrackerState, "Stopping Timer"));

        IFC(GetEditor()->StopDblClickTimer());

        //
        // If a Fire On Select Start failed - it is valid for the timer to fail
        // the Doc may have unloaded.
        //
#if DBG == 1
        if ( ! _pManager->IsFailFireOnSelectStart() )
        {
            AssertSz( hr == S_OK || hr == S_FALSE  , "Error stopping timer");
        }
#endif
        _pManager->SetInTimer( FALSE );
    }

Cleanup:
    RRETURN( hr );
}

BOOL
CSelectTracker::EndPointsInSameFlowLayout()
{
    return GetEditor()->PointersInSameFlowLayout( _pDispStartPointer, _pDispEndPointer, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   An element is leaving the tree.  We may have to nix our selection
//              if the element encompasses the entire selection.
//
//-------------------------------------------------------------------- --------
HRESULT
CSelectTracker::OnExitTree(
                            IMarkupPointer* pIStart,
                            IMarkupPointer* pIEnd ,
                            IMarkupPointer* pIContentStart,
                            IMarkupPointer* pIContentEnd )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    CEditPointer            startPointer( GetEditor() );
    CEditPointer            endPointer( GetEditor())  ;
    SP_IDisplayPointer      spDispPointer;
    BOOL fPositioned, fPositionedEnd;

    // Retrieve the segment list

    if( _pISegment != NULL )
    {
        //
        // We only get called - if our segment contained the element leaving the tree
        //
        //
        // A layout is leaving the tree. Does this completely contain selection ?
        //
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer2 ));

        hr = _pISegment->GetPointers(startPointer, endPointer );
        if (hr == E_INVALIDARG)
        {
           //
           // Review-2000/07/26-zhenbinx: we should fix this in Blackcomb. 
           //
           // TODO:  (chandras): possible case is pointers are wacked from tree. 
           //                    gracefully exit as the code below makes no sense 
           //                    when the pointers are not valid. Code in Segment.cxx 
           //                    needs to be well-written to handle these cases
           hr = S_OK;
           goto Cleanup;
        }
        
        IFC( pIContentStart->IsPositioned( & fPositioned ));
        IFC( pIContentEnd->IsPositioned( & fPositionedEnd ));

        if ( fPositioned && fPositionedEnd )
        {
            IFC( spPointer->MoveToPointer( pIContentStart ));
            IFC( spPointer2->MoveToPointer( pIContentEnd ));
        }
        else
        {
            IFC( spPointer->MoveToPointer( pIStart ));
            IFC( spPointer2->MoveToPointer( pIEnd ));
        }

        if ( startPointer.Between( spPointer, spPointer2) &&
             endPointer.Between( spPointer, spPointer2))
        {
            SP_IDisplayPointer spDispPointer;
            SP_IHTMLElement spElement;
            SP_IHTMLElement spNewElement;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );

            hr = THR( spDispPointer->MoveToMarkupPointer( pIEnd , NULL) );
            if (hr != CTL_E_INVALIDLINE)
            {
                IFC(hr);
            }
            else
            {
                IFC( pIEnd->CurrentScope( & spElement ));

                while ( spElement != NULL)
                {
                    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                    if (hr != CTL_E_INVALIDLINE)
                    {
                        IFC(hr);
                        break;
                    }

                    IFC( GetEditor()->GetParentElement(spElement, &spNewElement) );
                    spElement = spNewElement;
                }
            }

            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            hr = THR( _pManager->SetCurrentTracker( TRACKER_TYPE_Caret, spDispPointer, spDispPointer ) );
            Assert( IsDormant());
        }
    }

Cleanup:

    RRETURN ( hr );
}

HRESULT
CSelectTracker::EmptySelection( BOOL fChangeTrackerAndSetRange /*=TRUE*/)
{
    HRESULT         hr = S_OK;

    if( _pISegment )
    {
        IFC( GetSelectionServices()->RemoveSegment( _pISegment) );
        IFC( GetHighlightServices()->RemoveSegment( _pIRenderSegment ));

        ClearInterface( & _pISegment );
        ClearInterface( & _pIRenderSegment );
    }

    if ( ! fChangeTrackerAndSetRange )
    {
        IFC( _pManager->EnsureDefaultTrackerPassive());
    }

Cleanup:
    RRETURN ( hr );

}

//+====================================================================================
//
// Method:  DeleteSelection
//
// Synopsis: Do the deletion of the Selection by firing IDM_DELETE
//
//------------------------------------------------------------------------------------

HRESULT
CSelectTracker::DeleteSelection(BOOL fAdjustPointersBeforeDeletion )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    CEdUndoHelper       undoUnit(GetEditor());

    //
    // Do the prep work.  Check to see if we have a segment.  It is possible
    // for an external host to get into DeleteSelection() without there
    // actually being a selection on the screen, yet the select tracker
    // is active.  See IE bug 98881 for more details.
    //
    if( _pISegment )
    {
        IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
        IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

        IFC( undoUnit.Begin( IDS_EDUNDOTEXTDELETE) );

        //
        // Delete our segment
        //
        IFC( _pISegment->GetPointers( spStart, spEnd) );

        //
        // Cannot delete or cut unless the range is in the same flow layout
        //
        if ( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            IFC( GetEditor()->Delete( spStart, spEnd, fAdjustPointersBeforeDeletion ));
        }


        IFC( _pManager->EmptySelection());
    }

Cleanup:

    RRETURN( hr );
}

//+===================================================================================
// Method:  IsMessageInSelection
//
// Synopsis: Check to see if the given message is in the current selection segment
//
//------------------------------------------------------------------------------------
BOOL
CSelectTracker::IsMessageInSelection( CEditEvent* pEvent )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointerMsg;               // Display pointer where event occured
    SP_IMarkupPointer   spPointerStartSel;              // Start of selection
    SP_IMarkupPointer   spPointerEndSel;                // End of selection
    POINT               ptContent;                      // Point transformed to content coords
    POINT               pt;                             // Point where event occured
    BOOL                fIsInSelection = FALSE;
    int                 wherePointer = SAME;            // For comparing pointers
    BOOL                fEqual = FALSE;
    SP_IMarkupContainer spIContainer1;                  // Container of event
    SP_IMarkupContainer spIContainer2;                  // Container of start of selection
    SP_IMarkupPointer   spPointerMsg;                   // Markup pointer where event occured
    LONG                lXPosition;                     // Width of element where event occured
    SP_ILineInfo        spLineInfo;
    SP_IHTMLElement     spEventElement;                 // Event element

    //
    // Get the point, and the element where the event occured
    //
    IFC( pEvent->GetPoint( & pt ));
    IFC( pEvent->GetElement( &spEventElement ) );

    if ( _pISegment )
    {
        //
        // Create the pointers we need, and position them around selection
        //
        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointerMsg ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerStartSel ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerEndSel));
        IFC( GetEditor()->CreateMarkupPointer( &spPointerMsg) );

        IFC( _pISegment->GetPointers(spPointerStartSel, spPointerEndSel ) );
        IFC( spPointerStartSel->IsEqualTo( spPointerEndSel, &fEqual ));

        if ( ! fEqual )
        {
            IFC( pEvent->MoveDisplayPointerToEvent( spDispPointerMsg ,
                                                    _pManager->IsInEditableClientRect( pt) == S_OK ?
                                                                        NULL :
                                                                        GetEditableElement() ) );

            //
            // See if we're in different containers. If we are - we adjust.
            //
            IFC( GetEditor()->CreateMarkupPointer(&spPointerMsg) );
            IFC( spDispPointerMsg->PositionMarkupPointer(spPointerMsg) );
            IFC( spPointerMsg->GetContainer( &spIContainer1 ));
            IFC( spPointerStartSel->GetContainer( &spIContainer2 ));
            if ( !EqualContainers( spIContainer1, spIContainer2))
            {
                //
                // IFC is ok - if we can't be adjusted into the same containers , we will
                // return S_FALSE - and we will bail.
                //
                IFC( GetEditor()->MovePointersToEqualContainers( spPointerMsg, spPointerStartSel ));
            }

            IFC( spDispPointerMsg->PositionMarkupPointer(spPointerMsg) );
            IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );

            IFC( OldCompare( spPointerStartSel, spPointerMsg, & wherePointer));

            if ( wherePointer == LEFT )
                goto Cleanup;

            else if ( wherePointer == SAME )
            {
                //
                // Verify we are truly to the left of the point. As at EOL/BOL the fRightOfCp
                // test above may be insufficient
                //
                IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_x(&lXPosition) );
                IFC( pEvent->GetPoint( & ptContent ));
                IFC( GetDisplayServices()->TransformPoint(  &ptContent,
                                                            COORD_SYSTEM_GLOBAL,
                                                            COORD_SYSTEM_CONTENT,
                                                            spEventElement) );
                if ( lXPosition > ptContent.x )
                    goto Cleanup;

            }

            IFC( OldCompare( spPointerEndSel, spPointerMsg, & wherePointer ));

            if ( wherePointer == RIGHT )
                goto Cleanup;

            else if ( wherePointer == SAME )
            {
                //
                // Verify we are truly to the right of the point. As at EOL/BOL the fRightOfCp
                // test above may be insufficient
                //

                IFC( spDispPointerMsg->GetLineInfo(&spLineInfo) );
                IFC( spLineInfo->get_x(&lXPosition) );

                IFC( pEvent->GetPoint( & ptContent ));
                IFC( GetDisplayServices()->TransformPoint( & ptContent,
                                                        COORD_SYSTEM_GLOBAL,
                                                        COORD_SYSTEM_CONTENT,
                                                        spEventElement ));

                if ( lXPosition < ptContent.x )
                    goto Cleanup;
            }


            //
            //  We're between the start and end - ergo we're inside
            //
            fIsInSelection = TRUE;
        }
    }

Cleanup:

    return fIsInSelection;
}

//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on selection
//
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spLeft;
    SP_IMarkupPointer   spRight;
    SP_IHTMLElement     spElementCaret;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

    Assert( pfFindNext );
    Assert( pElement );

    //
    // Do the prep work.  Check to see if we have a segment.  It is possible
    // for an external host to get into DeleteSelection() without there
    // actually being a selection on the screen, yet the select tracker
    // is active.  See IE bug 98881 for more details.
    //
    if( _pISegment )
    {
        IFC( GetEditor()->CreateMarkupPointer( &spLeft ));
        IFC( GetEditor()->CreateMarkupPointer( &spRight ));

        // Currently we only have one selection, so fForward does not matter.  For multiple selection,
        // we would have to select the appropriate selection (first or last)
        IFC( _pISegment->GetPointers(spLeft, spRight ) );

        // First find the element where selection would contains caret
        IFC( spRight->CurrentScope( &spElementCaret ));
        if (!spElementCaret)
            goto Cleanup;

        // Now, scan upto the first scope boundary
        for(;;)
        {
            if (fForward)
            {
                IFC( spRight->Right(TRUE, &context, pElement, NULL, NULL));
            }
            else
            {
                IFC( spRight->Left(TRUE, &context, pElement, NULL, NULL));
            }

            Assert( context != CONTEXT_TYPE_None );

            if(     (context == CONTEXT_TYPE_EnterScope)    ||
                    (context == CONTEXT_TYPE_ExitScope)     ||
                    (context == CONTEXT_TYPE_NoScope) )
            {
                break;
            }

            ClearInterface(pElement);
        }

        if( pElement != &spElementCaret)
        {
            *pfFindNext = FALSE;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::MoveWord(IDisplayPointer* pDispPointer, MOVEUNIT_ACTION muAction)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( MoveWord(spPointer, muAction) );

    IFC( pDispPointer->MoveToMarkupPointer(spPointer, pDispPointer) );

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::UpdateSelectionSegments(BOOL fFireOM /*=TRUE*/)
{
    HRESULT hr = S_OK;
    BOOL    fEqual;

    //
    // Fire the message to notify other instances of trident that we are
    // doing selection
    //
    if( !_fFiredNotify )
    {
        IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, &fEqual ) );
        if( !fEqual )
        {
            IFC( _pManager->NotifyBeginSelection( START_TEXT_SELECTION ) );
            _fFiredNotify = TRUE;
        }
    }
    
    //
    // Update highlight rendering if it changed
    //
    if ( !_pIRenderSegment || SelectionSegmentDidntChange(_pIRenderSegment, _pDispStartPointer, _pDispEndPointer) !=  S_OK)
    {
        IFC( GetHighlightServices()->MoveSegmentToPointers(_pIRenderSegment, _pDispStartPointer, _pDispEndPointer ));

        
        //
        // Update markup pointers for selection rendering services
        //

        IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
        IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

        IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
        IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

         // fire the selectionchange event
        {
            CSelectionChangeCounter selCounter(_pManager);
            selCounter.SelectionChanged();
        }

        if ( IsDormant() ) // happens if OnSelectionChange tore us down.
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if ( fFireOM )
        {
            IFC( FireOnSelect());
        }

        if ( IsDormant() ) // happens if OnSelect tore us down.
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::SelectionSegmentDidntChange(IHighlightSegment *pISegment, IDisplayPointer *pDispStart, IDisplayPointer *pDispEnd)
{
    HRESULT             hr = S_FALSE;
    SP_IMarkupPointer   spOldStart;
    SP_IMarkupPointer   spOldEnd;
    SP_IMarkupPointer   spNewStart;
    SP_IMarkupPointer   spNewEnd;
    BOOL                fResult;

    Assert(pISegment && pDispStart && pDispEnd);

    IFC( GetEditor()->CreateMarkupPointer(&spOldStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spOldEnd) );
    IFC( GetEditor()->CreateMarkupPointer(&spNewStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spNewEnd) );

    IFC( pISegment->GetPointers(spOldStart, spOldEnd) );

    IFC( pDispStart->PositionMarkupPointer(spNewStart) );
    IFC( pDispEnd->PositionMarkupPointer(spNewEnd) );

    hr = THR_NOTRACE( spOldStart->IsEqualTo( spNewStart, &fResult ) );
    if (fResult)
    {
        hr = THR_NOTRACE( spOldEnd->IsEqualTo( spNewEnd, &fResult ) );
    }
    else
    {
        //  Pointers may be swapped.  GetPointers always returns us start
        //  and end as left to right.  We should not have swapped these
        //  since we can't really determine whether the segment changed
        //  due to a swap in start/end pointers.  Visually the segment
        //  hasn't changed, but internally it has.

        hr = THR_NOTRACE( spOldStart->IsEqualTo( spNewEnd, &fResult ) );
        if (fResult)
        {
            hr = THR_NOTRACE( spOldEnd->IsEqualTo( spNewStart, &fResult ) );
        }
    }

    hr = fResult ? S_OK : S_FALSE;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectTracker::FireOnSelect()
{
    HRESULT hr;
    SP_IHTMLElement spLayoutElement;
    SP_IHTMLElement spScopeElement;
    ELEMENT_TAG_ID eTag;

    IFC( _pSelServEnd->CurrentScope( & spScopeElement ));
    IFC( GetLayoutElement( GetMarkupServices(), spScopeElement, & spLayoutElement ));

    IFC( GetMarkupServices()->GetElementTagId( spLayoutElement, & eTag ));

    //
    // IE4 semantics are just to fire this on body, input & textarea.
    //
    switch ( eTag )
    {
        case TAGID_BODY:
        case TAGID_TEXTAREA:
        case TAGID_INPUT:
            IFC( _pManager->FireOnSelect( spLayoutElement ));

        default:
            break;
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::CreateSelectionSegments()
{
    HRESULT hr;
    BOOL    fEqual;

    //
    // Determine if the pointers have content between them.  If there is actual content, notify 
    // other trident instances that selection has begun
    //
    IFC( _pDispStartPointer->IsEqualTo( _pDispEndPointer, &fEqual ) );

    Assert( !_fFiredNotify );
    
    if( !fEqual )
    {
        IFC( _pManager->NotifyBeginSelection(START_TEXT_SELECTION) );
        _fFiredNotify = TRUE;
    }
    
    //
    // Create selection services pointers and pass to selection services
    //
    _fAddedSegment = FALSE;

    IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
    IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

    IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
    IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

    IFC( GetSelectionServices()->AddSegment(_pSelServStart, _pSelServEnd, &_pISegment ));

    //
    // Add to highlight rendering services
    //
    IFC( GetHighlightServices()->AddSegment( _pDispStartPointer, _pDispEndPointer, GetSelectionManager()->GetSelRenderStyle(), &_pIRenderSegment ));
    _fAddedSegment = TRUE;

     // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(_pManager);
        selCounter.SelectionChanged();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::StartSelTimer()
{
    HRESULT hr = S_OK;
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;

    Assert( !_fInSelTimer && ! _pITimerWindow );

    IFC( _pManager->GetDoc()->get_parentWindow(&_pITimerWindow));
    IFC(_pITimerWindow->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)_pSelectionTimer;

    IFC(spWindow3->setInterval(&varCallBack,
                               SEL_TIMER_INTERVAL ,
                               &varLang, &_lTimerID));

    _fInSelTimer = TRUE;

Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectTracker::StopSelTimer()
{
    HRESULT hr = S_OK ;

    Assert( _fInSelTimer && _pITimerWindow );

    IFC( _pITimerWindow->clearInterval(_lTimerID));

    // Release the cached'd window
    ReleaseInterface( _pITimerWindow );
    _pITimerWindow = NULL;

    _fInSelTimer = FALSE;
Cleanup:
    RRETURN (hr);
}

HRESULT
CSelectionTimer::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    POINT pt;

    if ( !_pSelTrack )
        goto Cleanup;

    //  We may get a timer event after becoming dormant if we failed to stop the timer for
    //  any reason before becoming dormant.  I've seen this occur when we switch docs while
    //  a timer is set.  This is because the doc maintains the timer event ids (_TimerEvents)
    //  and so attempting to kill a timer after switching docs will fail since the current doc
    //  won't have the timer id.  We will think we killed the timer, but in fact we didn't.
    //  So, we need to keep this check here to make sure that the seltracker are not dormant.

    if ( !_pSelTrack->IsDormant() )
    {
        CSynthEditEvent evt( _pSelTrack->GetEditor() );
        _pSelTrack->GetMousePoint( & pt, TRUE );
        IFC( evt.Init( & pt, EVT_TIMER ));

        TraceTag( ( tagSelectionTrackerState, "CSelectTimer::Invoke"));

        IGNORE_HR( _pSelTrack->HandleEvent( & evt ));
    }

 Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: MoveWord
//
// Synopsis: Provide IE 4 level word moving.
//             MoveWord() is a wrapper for MoveUnit(). It stops at IE4 word breaks
//              that MoveUnit() ignores such as:
//              <BR>, Block Break, TSB, TSE, and Intrinsics
//              The only muActions supported are MOVEUNIT_PREVWORDBEGIN and
//              MOVEUNIT_NEXTWORDBEGIN
//------------------------------------------------------------------------------------
HRESULT
CSelectTracker::MoveWord(
    IMarkupPointer * pPointerToMove,
    MOVEUNIT_ACTION  muAction)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    DWORD               dwBreaks;
    BOOL                fResult;
    BOOL                fPassedText;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointerSource;
    SP_IMarkupPointer   spPointerDestination;
    IMarkupPointer      *pLeftBoundary;
    IMarkupPointer      *pRightBoundary;
    ELEMENT_TAG_ID      tagId;

    Assert ( muAction == MOVEUNIT_PREVWORDBEGIN ||
             muAction == MOVEUNIT_NEXTWORDBEGIN );

    if (  muAction != MOVEUNIT_PREVWORDBEGIN &&
          muAction != MOVEUNIT_NEXTWORDBEGIN )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( GetEditor()->CreateMarkupPointer(&spPointerSource) );
    IFC( GetEditor()->CreateMarkupPointer(&spPointerDestination) );

    pLeftBoundary = _pManager->GetStartEditContext();
    pRightBoundary = _pManager->GetEndEditContext();

    //
    // pPointerDestination is where MoveUnit() would have positioned us, however,
    // since MoveUnit() does not account for IE4 word breaks like intrinsics,
    // Block Breaks, text site begin/ends, and Line breaks, we use another pointer
    // called pPointerSource. This pointer walks towards pPointerDestination
    // to detect IE4 word breaking characters that MoveUnit() does not catch.
    //


    IFC( spPointerSource->MoveToPointer(pPointerToMove) );
    IFC( spPointerDestination->MoveToPointer(pPointerToMove) );

    IFC( spPointerDestination->MoveUnit(muAction) );

    //
    // MoveUnit() may place the destination outside the range boundary.
    // First make sure that the destination is within range boundaries.
    //
    if ( pLeftBoundary && muAction == MOVEUNIT_PREVWORDBEGIN )
    {
        IFC( spPointerDestination->IsLeftOf(pLeftBoundary, &fResult) );

        if ( fResult )
        {
            IFC( spPointerDestination->MoveToPointer(pLeftBoundary) );
        }
    }
    else if( pRightBoundary && muAction == MOVEUNIT_NEXTWORDBEGIN )
    {
        IFC( spPointerDestination->IsRightOf(pRightBoundary, &fResult) );

        if ( fResult )
        {
            IFC( spPointerDestination->MoveToPointer(pRightBoundary) );
        }
    }

    //
    // Walk pointerSource towards pointerDestination, looking
    // for word breaks that MoveUnit() might have missed.
    //

    fPassedText = FALSE;

    for ( ; ; )
    {
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            IFC( spPointerSource->Left( TRUE, &context, &spElement, NULL, NULL ));
        }
        else
        {
            IFC( spPointerSource->Right( TRUE, &context, &spElement, NULL, NULL ));
        }

        switch( context )
        {
        case CONTEXT_TYPE_Text:
            fPassedText = TRUE;
            break;

        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if ( !spElement )
                break;

            if ( IsIntrinsic( GetMarkupServices(), spElement ) )
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've travelled over text before.

                if ( muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( spElement,
                                fPassedText ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( spElement,
                                fPassedText ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                }
                //
                // We're done
                //
                goto Cleanup;
            }

            //
            // Special case Anchors - treat them as word breaks.
            //
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if ( tagId == TAGID_A )
            {
                if ( fPassedText && muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    // If we're travelling right and have passed some text, backup
                    // before the last BR, we've gone too far.
                    hr = THR( spPointerSource->Left(TRUE, NULL, NULL, NULL, NULL));
                    goto Done;
                }
                else if ( fPassedText && muAction == MOVEUNIT_PREVWORDBEGIN )
                {
                    // Travelling left we are at the right place: we're at the beginning of <BR>
                    // which is a valid word break.
                    goto Done;
                }
            }

            if (context == CONTEXT_TYPE_NoScope)
            {
                fPassedText = TRUE;
            }
            else
            {
                BOOL fBlock, fLayout;

                IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );

                fPassedText = (fBlock || fLayout);
            }
            break;

        }

        //
        // If we are at or beyond the destination point where MoveUnit() took us,
        // set the passed in pointer to the destination and we're outta here
        //
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            BOOL fLeftOrEqual;

            IFC( spPointerSource->IsLeftOfOrEqualTo(spPointerDestination, &fLeftOrEqual) );
            if (fLeftOrEqual)
            {
                hr = THR(
                        pPointerToMove->MoveToPointer( spPointerDestination ) );
                goto Cleanup;
            }
        }
        else
        {
            BOOL fRightOrEqual;

            IFC( spPointerSource->IsRightOfOrEqualTo(spPointerDestination, &fRightOrEqual) );
            if (fRightOrEqual)
            {
                hr = THR(
                        pPointerToMove->MoveToPointer( spPointerDestination ) );
                goto Cleanup;
            }
        }

        //
        // Detect Block break, Text site begin or text site end
        //
        {
            SP_IDisplayPointer spDispPointer;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            hr = THR( spDispPointer->MoveToMarkupPointer(spPointerSource, NULL) );
            if (hr == CTL_E_INVALIDLINE)
            {
                dwBreaks = 0;
            }
            else
            {
                IFC( hr );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( spDispPointer->QueryBreaks(&dwBreaks) );
            }
        }

        // We hit a break before reaching our destination, time to stop...
        if (dwBreaks)
        {
            if ( fPassedText )
            {
                goto Done;
            }
            else
            {
                fPassedText = TRUE;
            }
        }
    }

Done:
    IFC( pPointerToMove->MoveToPointer(spPointerSource) );

Cleanup:
    RRETURN( hr );
}

BOOL
CSelectTracker::SameLayoutForJumpOver( IHTMLElement* pIFlowElement,
                                       IHTMLElement* pIElement )
{
    HRESULT             hr;
    SP_IObjectIdentity  spIdent;
    BOOL                fSameFlow = FALSE;
    ELEMENT_TAG_ID      eTag;
    SP_IHTMLElement     spTableElement;
    SP_IHTMLElement     spParent;
    SP_IHTMLElement     spLayoutElement;

    Assert( pIFlowElement && pIElement );

    IFC( GetMarkupServices()->GetElementTagId( pIFlowElement , & eTag ));

    //
    // Tables are special - we don't jump over them, except in certain cases.
    // If a table is completed contained within selection, it is basically text
    // selected, and in this case, we want to adjust for site selection based on
    // the table's different layout, so we return FALSE.
    //
    // If the table has have atomic selection, we also return FALSE
    //
    if( IsTablePart( eTag ) )
    {
        //
        // Retrieve the layout above the table, and see if it is text selected
        //
        IFC( GetEditor()->GetTableFromTablePart( pIFlowElement, &spTableElement ) );
        IFC( GetEditor()->GetParentElement( spTableElement, &spParent ) );
        IFC( EdUtil::GetLayoutElement( GetMarkupServices(), spParent, &spLayoutElement ) );

        if( !IsInOrContainsSelection( spParent ) &&
            _pManager->CheckAtomic( pIFlowElement ) == S_FALSE )
        {
            fSameFlow = TRUE;
        }
    }
    else
    {
        IFC( pIFlowElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
        fSameFlow = (spIdent->IsEqualObject(pIElement) == S_OK);
    }

Cleanup:
    Assert( SUCCEEDED(hr));
    return fSameFlow;
}


HRESULT
CSelectTracker::AttachPropertyChangeHandler(IHTMLElement* pIElement )
{
    HRESULT          hr = S_OK ;
    VARIANT_BOOL     varAttach = VB_TRUE;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( ! _pISelectStartElement );

    ReplaceInterface( & _pISelectStartElement , pIElement );

    IFC( _pPropChangeListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pISelectStartElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->attachEvent(_T("onpropertychange"), spDisp, & varAttach ));
    Assert( varAttach == VB_TRUE );

Cleanup:
    RRETURN( hr );
}


HRESULT
CSelectTracker::DetachPropertyChangeHandler()
{
    HRESULT          hr = S_OK;
    SP_IDispatch     spDisp;
    SP_IHTMLElement2 spElement2;

    Assert( _pISelectStartElement );

    IFC( _pPropChangeListener->QueryInterface( IID_IDispatch, ( void**) & spDisp));
    IFC( _pISelectStartElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
    IFC( spElement2->detachEvent(_T("onpropertychange"), spDisp ));

    ClearInterface( & _pISelectStartElement );

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::OnPropertyChange( CEditEvent * pEvt )
{
    HRESULT hr = S_OK;
    BSTR bstrPropChange;

    IFC( DYNCAST( CHTMLEditEvent, pEvt)->GetPropertyChange( & bstrPropChange ));
    if( !StrCmpICW (bstrPropChange, L"atomicSelection") )
    {
        Assert( _pISelectStartElement );
        if ( ! _fStartIsAtomic  && _pManager->CheckAtomic( _pISelectStartElement ) == S_OK )
        {
            _fStartIsAtomic = TRUE;
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CPropertyChangeListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if (!_pSelTrack)
        goto Cleanup;

    if ( _pSelTrack->IsDormant() )
        goto Cleanup;
    
    if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH)
    {
        IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
        if ( spObj )
        {
            CHTMLEditEvent evt( _pSelTrack->GetEditor());
            IFC( evt.Init(  spObj , dispidMember));
            Assert( evt.GetType() == EVT_PROPERTYCHANGE );
            if( evt.GetType() == EVT_PROPERTYCHANGE )
            {
                IFC( _pSelTrack->OnPropertyChange( & evt ));
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionAnchor( IMarkupPointer* pAnchor )
{
    HRESULT hr;

    Assert( _pDispStartPointer );

    IFC( _pDispStartPointer->PositionMarkupPointer( pAnchor ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionEnd( IMarkupPointer* pEnd )
{
    HRESULT hr;

    Assert( _pDispEndPointer );

    IFC( _pDispEndPointer->PositionMarkupPointer( pEnd ));

Cleanup:
    RRETURN( hr );

}

HRESULT
CSelectTracker::MoveToSelectionAnchor( IDisplayPointer* pAnchor )
{
    HRESULT hr;

    Assert( _pDispStartPointer );

    IFC( pAnchor->MoveToPointer( _pDispStartPointer ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::MoveToSelectionEnd( IDisplayPointer* pEnd )
{
    HRESULT hr;

    Assert( _pDispEndPointer );

    IFC( pEnd ->MoveToPointer(_pDispEndPointer));

Cleanup:
    RRETURN( hr );

}

HRESULT
CSelectTracker::DoSelectGlyph( CEditEvent* pEvent )
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointer;

    //
    // Get the glyph element
    //

    IFC( pEvent->GetElement(&spElement) );

    //
    // Position the selection
    //

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
    IFC( _pDispStartPointer->MoveToMarkupPointer(spPointer, NULL) );

    IFC( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
    IFC( _pDispEndPointer->MoveToMarkupPointer(spPointer, NULL) );

    if ( _fAddedSegment )
    {
        IFC( UpdateSelectionSegments() );
    }
    else
    {
        IFC( CreateSelectionSegments() );

        IFC( FireOnSelect() );
    }

    SetMadeSelection( TRUE );

Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectTracker::AdjustForAtomic(
                IDisplayPointer* pDisp,
                IHTMLElement* pElement,
                BOOL fStartOfSelection,
                POINT* ppt,
                BOOL* pfDidSelection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartPointer;
    SP_IMarkupPointer   spEndPointer;
    int                 iWherePointer = 0;
    BOOL                fDirection = TRUE;

    //  Which direction is the selection going?

    //  NOTE: _pDispPrevTestPointer and _pDispTestPointer may be NULL here
    //  when called from CSelectTracker::Position.
    if (_pDispPrevTestPointer && _pDispTestPointer)
    {
        IGNORE_HR( _pManager->GetEditor()->OldDispCompare( _pDispPrevTestPointer, _pDispTestPointer, & iWherePointer));
    }
    fDirection = (iWherePointer == SAME ) ?
                        ( _fInWordSel ? !!_fWordSelDirection : GuessDirection( ppt )) : // if in word sel. use _fWordSelDirection, otherwise use mouse direction.
                        ( iWherePointer == RIGHT ) ;

    IFC( GetEditor()->CreateMarkupPointer(&spStartPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spEndPointer) );
    IFC( CEditTracker::AdjustForAtomic(pDisp, pElement, fStartOfSelection, ppt, pfDidSelection,
            fDirection, SELECTION_TYPE_Text, &spStartPointer, &spEndPointer) );

    if (*pfDidSelection)
    {
        //  We are now in passive mode.  We need to go active now.
        if ( _fState == ST_DOSELECTION && *pfDidSelection )
        {
            IFC( GoActiveFromPassive(spStartPointer, spEndPointer) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::GoActiveFromPassive(IMarkupPointer* pSelStartPointer, IMarkupPointer* pSelEndPointer)
{
    HRESULT     hr = S_OK;

    //  Set our markup pointers.
    IFC ( _pDispPrevTestPointer->MoveToMarkupPointer( pSelStartPointer, NULL ));
    IFC ( _pDispTestPointer->MoveToMarkupPointer( pSelEndPointer, NULL ));
    IFC ( _pDispWordPointer->MoveToMarkupPointer( pSelEndPointer, NULL ));

    //  Set our current state.
    SetState( ST_DOSELECTION, TRUE );
    if ( !_fTookCapture )
    {
        TakeCapture();
        _fTookCapture = TRUE;
    }

    //  Reset our timers.
    // StartTimer();
    StartSelTimer();

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::UpdateShiftPointer(IDisplayPointer *pIDispPtr)
{
    HRESULT hr;

    if( pIDispPtr )
    {
        //
        // Update markup pointers for shift selection
        //
        IFC( _pDispShiftPointer->MoveToPointer( pIDispPtr ) );
        IFC( CopyPointerGravity( pIDispPtr, _pDispShiftPointer) );
    }
    else
    {
        IFC( _pDispShiftPointer->Unposition() );
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CSelectTracker::HasShiftPointer()
{
    BOOL    fPositioned = FALSE;
    HRESULT hr;

    Assert( _pDispShiftPointer );

    IFC( _pDispShiftPointer->IsPositioned(&fPositioned) );

Cleanup:

    return fPositioned;
}
BOOL
CSelectTracker::IsInOrContainsSelection(   IHTMLElement    *pIElement )
{
    HRESULT             hr = S_OK;
    BOOL                fWithin = FALSE;                // Within selection?
    BOOL                fIsLeft;                        // Comparison
    BOOL                fIsRight;
    BOOL                fSwap;
    SP_IMarkupPointer   spElemStart;                    // Positioned before element start
    SP_IMarkupPointer   spElemEnd;                      // Positioned after element end
    SP_IMarkupPointer   spSelStart;                     // True start of selection
    SP_IMarkupPointer   spSelEnd;                       // True end of selection

    // Check if selection is even active
    if ( _fState == ST_WAIT2 )
    {
        goto Cleanup;
    }

    //
    // Create some markup pointers, and position them around the
    // element.
    //
    IFC( GetEditor()->CreateMarkupPointer(&spElemStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spElemEnd) );
    IFC( GetEditor()->CreateMarkupPointer(&spSelStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spSelEnd) );

    IFC( spElemStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ) );
    IFC( spElemEnd->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ) );

    //
    // Get our true start and end selection pointers
    //
    IFC( MovePointersToTrueStartAndEnd( spSelStart, spSelEnd, &fSwap ) );

    //
    // Compare
    //
    IFC( spElemEnd->IsLeftOfOrEqualTo( spSelEnd, &fIsLeft ) );
    IFC( spElemStart->IsRightOfOrEqualTo( spSelStart, &fIsRight ) );

    fWithin = (fIsLeft && fIsRight);

Cleanup:

    return ( fWithin );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectTracker::AdjustLineSelection
//
//  Synopsis:   Adjusts the shift pointer of selection before we call
//              MovePointer to adjust the end of selection.  This is
//              useful for situations when shift-selection
//              differs from regular caret navigation.  An example is bug
//              91420.
//
//  Arguments:  pIDispPointer = Pointer to IDisplayPointer to adjust
//              inCaretMove = How the selection is supposed to move
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectTracker::AdjustLineSelection(CARET_MOVE_UNIT inCaretMove)
{
    HRESULT         hr = S_OK;
    BOOL            fBOL;       // Is the end pointer at the BOL?
    BOOL            fBetween;
    DISPLAY_GRAVITY eGravity;

    //
    // Always make sure that when we do a SHIFT-HOME or SHIFT-END that
    // we select the previous or next line.  Otherwise, selection would
    // get stuck when we did a SHIFT-HOME or SHIFT-END.
    //
    if( inCaretMove == CARET_MOVE_LINEEND || inCaretMove == CARET_MOVE_LINESTART )
    {
        IFC( _pDispShiftPointer->MoveToPointer( _pDispEndPointer ) );
        IFC( _pDispShiftPointer->IsAtBOL(&fBOL) );

        fBetween = IsBetweenBlocks( _pDispShiftPointer );

        IFC( _pDispShiftPointer->GetDisplayGravity( &eGravity ) );

        if( fBOL )
        {
            if( inCaretMove == CARET_MOVE_LINEEND )
                eGravity = DISPLAY_GRAVITY_NextLine;
            else
                eGravity = DISPLAY_GRAVITY_PreviousLine;
        }
        else if( fBetween )
        {
            if( inCaretMove == CARET_MOVE_LINEEND )
                eGravity = DISPLAY_GRAVITY_NextLine;
            else
                eGravity = DISPLAY_GRAVITY_PreviousLine;
        }

        IFC( _pDispShiftPointer->SetDisplayGravity(eGravity) );
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::AdjustStartForAtomic( BOOL fFurtherInStory )
{
    //  Bug 102482, 103785: If we positioned the end pointer such that our initial selection
    //  hit point is outside of the current selection, readjust the start so that it
    //  will contain the selection hit point.

    HRESULT     hr = S_OK;

    if (_fStartIsAtomic)
    {
        BOOL        fBetween = FALSE;

        if (fFurtherInStory)
        {
            IFC( _pDispEndPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
            if (fBetween)
            {
                IFC( _pDispStartPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
            }
        }
        else
        {
            IFC( _pDispEndPointer->IsLeftOf(_pDispSelectionAnchorPointer, &fBetween) );
            if (fBetween)
            {
                IFC( _pDispStartPointer->IsRightOf(_pDispSelectionAnchorPointer, &fBetween) );
            }
        }

        if (!fBetween)
        {
            //  Okay, we need to readjust our start pointer
            IFC( MoveStartToPointer(_pDispSelectionAnchorPointer, TRUE) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::AdjustEndForAtomic(IHTMLElement *spAtomicElement,
                                   POINT pt,
                                   BOOL  fDirection,
                                   BOOL *pfDidSelection,
                                   BOOL *pfAdjustedSel)
{
    HRESULT             hr;
    SP_IDisplayPointer  spDispPointer;
    BOOL                fBetween = FALSE;

    // We adjust the end pointer for atomic selection.  We must make sure that
    // if the cursor is within the selection, we don't position the end pointer
    // such that the cursor is no longer in the selection.

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToPointer(_pDispEndPointer) );
    IFC( AdjustForAtomic( spDispPointer, spAtomicElement, FALSE , & pt, pfDidSelection));

    if (fDirection)
    {
        _pDispStartPointer->IsLeftOf(_pDispTestPointer, &fBetween);
        if (fBetween)
        {
            spDispPointer->IsRightOf(_pDispTestPointer, &fBetween);
        }
    }
    else
    {
        _pDispStartPointer->IsRightOf(_pDispTestPointer, &fBetween);
        if (fBetween)
        {
            spDispPointer->IsLeftOf(_pDispTestPointer, &fBetween);
        }
    }

    if (fBetween)
    {
        IFC( _pDispEndPointer->MoveToPointer(spDispPointer) );
        if (*pfDidSelection)
            goto Cleanup;
    }

    *pfAdjustedSel = TRUE;

Cleanup:
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispEndPointer) );
    WHEN_DBG( AssertSameMarkup(_pManager->GetEditor(), _pDispStartPointer, _pDispTestPointer) );

    RRETURN( hr );
}

HRESULT
CSelectTracker::RetrieveDragElement(CEditEvent *pEvent)
{
    HRESULT hr;

    Assert( pEvent != NULL );

    IFC( pEvent->GetElement( &_pIDragElement ) );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectTracker::EnsureAtomicSelection(CEditEvent *pEvent)
{
    HRESULT     hr = S_OK;

    if ( IsSelectionEmpty() )
    {
        SP_IHTMLElement     spElement;
        SP_IHTMLElement     spAtomicElement;
        SP_IDisplayPointer  spEventPtr;
        
        IFC( GetDisplayServices()->CreateDisplayPointer( &spEventPtr ) );
        IFC( pEvent->MoveDisplayPointerToEvent ( spEventPtr, NULL ));
        IFC( GetCurrentScope( spEventPtr, &spElement ) );
        if ( _pManager->FindAtomicElement(spElement, &spAtomicElement) == S_OK )
        {
            IFC( _pDispStartPointer->MoveToPointer(spEventPtr) );
            IFC( _pDispEndPointer->MoveToPointer(spEventPtr) );

            IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispStartPointer, spAtomicElement, TRUE, RIGHT) );
            IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispEndPointer, spAtomicElement, FALSE, RIGHT) );

            _fAddedSegment = FALSE;

            IFC( _pDispStartPointer->PositionMarkupPointer(_pSelServStart) );
            IFC( CopyPointerGravity(_pDispStartPointer, _pSelServStart) );

            IFC( _pDispEndPointer->PositionMarkupPointer(_pSelServEnd) );
            IFC( CopyPointerGravity(_pDispEndPointer, _pSelServEnd) );

            IFC( GetSelectionServices()->AddSegment(_pSelServStart, _pSelServEnd, &_pISegment ));
            IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Text, (ISelectionServicesListener*) _pManager ) );
            IFC( GetHighlightServices()->AddSegment( _pDispStartPointer, _pDispEndPointer, GetSelectionManager()->GetSelRenderStyle(), &_pIRenderSegment ));

            _fAddedSegment = TRUE;

            IFC( UpdateShiftPointer(NULL) );
            IFC( _pDispPrevTestPointer->Unposition() );
            IFC( _pDispTestPointer->MoveToPointer(spEventPtr) );

            _fDragDrop = FALSE;
            _fShift = FALSE;

            if (_fState == ST_WAITBTNDOWN1 && pEvent->GetType() == EVT_LMOUSEUP)
                _fMouseClickedInAtomicSelection = TRUE;
        }
    }
    else
    {
        IFC( EnsureStartAndEndPointersAreAtomicallyCorrect() );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectTracker::EnsureStartAndEndPointersAreAtomicallyCorrect()
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spStartElement;
    SP_IHTMLElement     spStartAtomicElement;
    SP_IHTMLElement     spEndElement;
    SP_IHTMLElement     spEndAtomicElement;
    int                 iDirection;
    BOOL                fUpdate = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( _pDispStartPointer->PositionMarkupPointer(spStart) );
    IFC( _pDispEndPointer->PositionMarkupPointer(spEnd) );

    IFC( OldCompare(spStart, spEnd, &iDirection) );

    IFC( GetCurrentScope(_pDispStartPointer, &spStartElement) );
    if ( _pManager->FindAtomicElement(spStartElement, &spStartAtomicElement) == S_OK )
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispStartPointer, spStartAtomicElement, TRUE, iDirection) );
        fUpdate = TRUE;
    }

    IFC( GetCurrentScope(_pDispEndPointer, &spEndElement) );
    if ( _pManager->FindAtomicElement(spEndElement, &spEndAtomicElement) == S_OK )
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), _pDispEndPointer, spEndAtomicElement, FALSE, iDirection) );
        fUpdate = TRUE;
    }

    if (fUpdate)
    {
        IFC( UpdateSelectionSegments() );
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\editres\libmain.cxx ===
#include <windows.h>

#ifdef MARKCODE
#include "..\core\include\markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#endif
 
extern "C"
BOOL WINAPI DllMain( HINSTANCE, DWORD, LPVOID )
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\sload.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       SLOAD.CXX
//
//  Contents:   Implementation of CSpringLoader class.
//
//  Classes:    CSpringLoader
//
//  History:    07-13-98 - OliverSe - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

using namespace EdUtil;

MtDefine(CSpringLoader, Utilities, "CSpringLoader")

DeclareTag(tagDisableSpringLoader, "Springloader", "Disable Spring Loader")


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::Get(*)Command
//
//  Synopsis:   Inline accessors for commands.
//
//-----------------------------------------------------------------------------

inline IMarkupServices2 *
CSpringLoader::GetMarkupServices()
{
    return _pCommandTarget->GetEditor()->GetMarkupServices();
}

inline IDisplayServices *
CSpringLoader::GetDisplayServices()
{
    return _pCommandTarget->GetEditor()->GetDisplayServices();
}

inline CCommand *
CSpringLoader::GetCommand(DWORD cmdID)
{
    return _pCommandTarget->GetEditor()->GetCommandTable()->Get(cmdID);
}

inline CBaseCharCommand *
CSpringLoader::GetBaseCharCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_BOLD || cmdID == IDM_ITALIC || cmdID == IDM_UNDERLINE || cmdID == IDM_SUBSCRIPT || cmdID == IDM_SUPERSCRIPT || 
           cmdID == IDM_FONTSIZE || cmdID == IDM_FONTNAME || cmdID == IDM_FORECOLOR || cmdID == IDM_BACKCOLOR || 
           cmdID == IDM_STRIKETHROUGH);
    return ((CBaseCharCommand *) GetCommand(cmdID));
}

inline CCharCommand *
CSpringLoader::GetCharCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_BOLD || cmdID == IDM_ITALIC || cmdID == IDM_UNDERLINE || cmdID == IDM_SUBSCRIPT || cmdID == IDM_SUPERSCRIPT ||
           cmdID == IDM_STRIKETHROUGH);
    return ((CCharCommand *) GetCommand(cmdID));
}

inline CFontCommand *
CSpringLoader::GetFontCommand(DWORD cmdID)
{
    Assert(cmdID == IDM_FONTSIZE || cmdID == IDM_FONTNAME || cmdID == IDM_FORECOLOR || cmdID == IDM_BACKCOLOR);
    return ((CFontCommand *) GetCommand(cmdID));
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::CSpringLoader, ~CSpringLoader
//
//  Synopsis:   Constructor and destructor.
//
//-----------------------------------------------------------------------------

CSpringLoader::CSpringLoader(CMshtmlEd * pCommandTarget)
{
    _grfFlags() = 0;
    _pCommandTarget = pCommandTarget;
    _pmpPosition = NULL;

    Assert(_pCommandTarget);
}

CSpringLoader::~CSpringLoader()
{
    // Free springload cache.
    Reset();

    ReleaseInterface(_pmpPosition);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoad
//
//  Synopsis:   Loads the spring loader by copying the formats found found
//              at the position passed in.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoad(IMarkupPointer * pmpPosition, DWORD dwMode /* =0 */)
{
    CSelectionManager * pSelMan;
    SP_IMarkupPointer   spmpSpringLoadFormatting;
    SP_IHTMLComputedStyle spComputedStyle;
    CVariant            varName, varSize, varColor, varBackColor;
    HRESULT             hr = S_OK;
    VARIANT_BOOL        fBold, fItalic, fUnderline, fSuperscript, fSubscript, fStrikeThrough;

    Assert(GetMarkupServices() && pmpPosition);

    // Save off the mode
    _dwMode = dwMode;
    
    // Reset springloader if requested.
    if (dwMode & SL_RESET)
        Reset();

    if (_fSpringLoaded)
        goto Cleanup;

    pSelMan = _pCommandTarget->GetEditor()->GetSelectionManager();
    Assert(pSelMan);
    if (!pSelMan->CanContextAcceptHTML())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(CopyMarkupPointer(_pCommandTarget->GetEditor(), pmpPosition, &spmpSpringLoadFormatting));
    if (S_OK != hr)
        goto Cleanup;

    // Handle AdjustForInsert modes.

    if (dwMode & SL_ADJUST_FOR_INSERT_LEFT)
        IGNORE_HR(AdjustPointerForInsert(spmpSpringLoadFormatting, LEFT, LEFT));
    else if (dwMode & SL_ADJUST_FOR_INSERT_RIGHT)
        IGNORE_HR(AdjustPointerForInsert(spmpSpringLoadFormatting, RIGHT, RIGHT));
    
    // Handle compose settings mode.
    if (dwMode & SL_TRY_COMPOSE_SETTINGS)
    {
        // Attempt to springload compose settings if there is no formatting.
        hr = THR(SpringLoadComposeSettings(spmpSpringLoadFormatting));
        if (hr != S_FALSE)
            goto Cleanup;
    }
    //
    // Obtain current formats.
    //

    IFC( GetDisplayServices()->GetComputedStyle(spmpSpringLoadFormatting, &spComputedStyle) );

    //
    // Convert font formats to variants.
    //

    IFC(GetFontCommand(IDM_FONTNAME)->ConvertFormatDataToVariant(spComputedStyle, &varName));
    IFC(GetFontCommand(IDM_FONTSIZE)->ConvertFormatDataToVariant(spComputedStyle, &varSize));
    IFC(GetFontCommand(IDM_FORECOLOR)->ConvertFormatDataToVariant(spComputedStyle, &varColor));
    IFC(GetFontCommand(IDM_BACKCOLOR)->ConvertFormatDataToVariant(spComputedStyle, &varBackColor));

    //
    // Copy the formats into the spring loader.
    //

    IFC( spComputedStyle->get_bold(&fBold) );
    IFC( spComputedStyle->get_italic(&fItalic) );
    IFC( spComputedStyle->get_underline(&fUnderline) );
    IFC( spComputedStyle->get_superScript(&fSuperscript) );
    IFC( spComputedStyle->get_subScript(&fSubscript) );
    IFC( spComputedStyle->get_strikeOut(&fStrikeThrough) );
    
    SetFormats(BOOL_FROM_VARIANT_BOOL(fBold),
               BOOL_FROM_VARIANT_BOOL(fItalic),
               BOOL_FROM_VARIANT_BOOL(fUnderline),
               BOOL_FROM_VARIANT_BOOL(fSuperscript),
               BOOL_FROM_VARIANT_BOOL(fSubscript),
               BOOL_FROM_VARIANT_BOOL(fStrikeThrough),
               &varName,
               &varSize,
               &varColor,
               &varBackColor);
 
    // We are now springloaded.
    MarkSpringLoaded(spmpSpringLoadFormatting);

Cleanup:

    VariantClear(&varName);
    VariantClear(&varSize);
    VariantClear(&varColor);
    VariantClear(&varBackColor);

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::Fire
//
//  Synopsis:   Applies the springloaded formats information
//              as long as it is valid and wherever it differs
//              from the existing format at the caret.
//
//----------------------------------------------------------------------------

HRESULT
CSpringLoader::Fire(IMarkupPointer * pmpStart, IMarkupPointer * pmpEnd /*=NULL*/, BOOL fMoveCaretToStart /*=TRUE*/ )
{
    IMarkupPointer    * pmpCaret = NULL;
    IHTMLCaret        * pCaret = NULL;
    IHTMLElement      * pElemBlock = NULL;
    CFontCommand      * pFontCommand;
    SP_IHTMLComputedStyle spComputedStyle;
    VARIANT             var;
    BOOL                fFontPropertyChange, fHasEnd = pmpEnd != NULL;
    HRESULT             hr = S_OK;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Max;
    VARIANT_BOOL        fAttribute;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    if (!_fSpringLoaded)
        goto Cleanup;

    Assert(GetMarkupServices() && pmpStart);
    VariantInit(&var);

    //
    // Obtain current formats.
    //

    IFC( GetDisplayServices()->GetComputedStyle(pmpStart, &spComputedStyle) );

    //
    // Create ending markup pointer if one wasn't passed in, and position it next to pmpStart.
    //

    if (!fHasEnd)
    {
        hr = THR(GetEditor()->CreateMarkupPointer(&pmpEnd));
        if (hr)
            goto Cleanup;

        hr = THR(pmpEnd->MoveToPointer(pmpStart));
        if (S_OK != hr)
            goto Cleanup;
    }

    //
    // Before we add any elements, make sure our segment pointers pmpStart
    // and pmpEnd have opposite gravity so that they move outward as we
    // insert or split elements. 
    //

    hr = THR(EnsureCaretPointers(fMoveCaretToStart?pmpStart:pmpEnd, &pCaret, &pmpCaret));

    if (FAILED(hr))
        goto Cleanup;

    // Remember the gravity so we can restore it at Cleanup
    hr = THR(pmpStart->Gravity(& eGravity));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpStart->SetGravity(POINTER_GRAVITY_Left));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpEnd->SetGravity(POINTER_GRAVITY_Right));
    if (S_OK != hr)
        goto Cleanup;

    //
    // If there is any difference between the springloaded formats and the
    // current formats, apply the necessary commands.
    //

    //
    // Span class.
    //

    if (V_VT(&_varSpanClass) != VT_NULL && V_VT(&_varSpanClass) != VT_EMPTY)
    {
        Assert(V_VT(&_varSpanClass) == VT_BSTR);

        BOOL fInSpanScope = InSpanScope(pmpStart);

        if (!fInSpanScope)
        {
            CInsertCommand * pInsertSpanCommand = DYNCAST(CInsertCommand, GetCommand(IDM_INSERTSPAN));

            pInsertSpanCommand->SetAttributeValue(V_BSTR(&_varSpanClass));

            hr = THR(pInsertSpanCommand->ApplyCommandToSegment(pmpStart, pmpEnd, NULL, FALSE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SPAN, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    IFC( spComputedStyle->get_bold(&fAttribute) );

    if (_fBold ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fBold)
            hr = THR(GetCharCommand(IDM_BOLD)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_BOLD)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_STRONG, _fBold));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_italic(&fAttribute) );
    
    if (_fItalic ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fItalic)
            hr = THR(GetCharCommand(IDM_ITALIC)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_ITALIC)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_EM, _fItalic));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_underline(&fAttribute) );
    
    if (_fUnderline ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fUnderline)
            hr = THR(GetCharCommand(IDM_UNDERLINE)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_UNDERLINE)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_U, _fUnderline));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_subScript(&fAttribute) );
    
    if (_fSubscript ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fSubscript)
            hr = THR(GetCharCommand(IDM_SUBSCRIPT)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_SUBSCRIPT)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SUB, _fSubscript));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_superScript(&fAttribute) );
    
    if (_fSuperscript ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fSuperscript)
            hr = THR(GetCharCommand(IDM_SUPERSCRIPT)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE));
        else
            hr = THR(GetCharCommand(IDM_SUPERSCRIPT)->Remove(_pCommandTarget, pmpStart, pmpEnd));

        if (S_OK != hr)
            goto Cleanup;

        hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_SUP, _fSuperscript));
        if (S_OK != hr)
            goto Cleanup;
    }

    IFC( spComputedStyle->get_strikeOut(&fAttribute) );
    
    if (_fStrikeThrough ^ BOOL_FROM_VARIANT_BOOL(fAttribute))
    {
        if (_fStrikeThrough)
        {
            IFC( GetCharCommand(IDM_STRIKETHROUGH)->Apply(_pCommandTarget, pmpStart, pmpEnd, NULL, TRUE) )
        }
        else
        {
            IFC( GetCharCommand(IDM_STRIKETHROUGH)->Remove(_pCommandTarget, pmpStart, pmpEnd) );
        }

        IFC( UpdatePointerPositions(pmpStart, pmpEnd, TAGID_STRIKE, _fStrikeThrough) );
    }

    //
    // Font name.
    //

    Assert(V_VT(&_varName) == VT_BSTR || V_VT(&_varName) == VT_NULL);

    if (V_VT(&_varName) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FONTNAME);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varName);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varName, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Font size.
    //

    if (V_VT(&_varSize) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FONTSIZE);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varSize);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varSize, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Fore color.
    //

    if (V_VT(&_varColor) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_FORECOLOR);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varColor);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varColor, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Back color.
    //

    if (V_VT(&_varBackColor) != VT_NULL)
    {
        pFontCommand = GetFontCommand(IDM_BACKCOLOR);
        hr = THR(pFontCommand->ConvertFormatDataToVariant(spComputedStyle, &var));
        if (S_OK != hr)
            goto Cleanup;

        fFontPropertyChange = !pFontCommand->IsVariantEqual(&var, &_varBackColor);
        VariantClear(&var);

        if (fFontPropertyChange)
        {
            hr = THR(pFontCommand->Apply(_pCommandTarget, pmpStart, pmpEnd, &_varBackColor, TRUE));
            if (S_OK != hr)
                goto Cleanup;

            hr = THR(UpdatePointerPositions(pmpStart, pmpEnd, TAGID_FONT, TRUE));
            if (S_OK != hr)
                goto Cleanup;
        }
    }

    //
    // Move the caret to the position of the segment.
    //

    if (pCaret)
    {
        SP_IDisplayPointer spDispPointer;
    
        IFC( pmpCaret->MoveToPointer(fMoveCaretToStart?pmpStart:pmpEnd) );

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( spDispPointer->MoveToMarkupPointer(pmpCaret, NULL) )

        IFC( pCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE) );
    }
    
Cleanup:

    // Always reset when we are done firing
    Reset();
    
    if (!fHasEnd)
    {
        ReleaseInterface(pmpEnd);
    }

    ReleaseInterface(pmpCaret);
    ReleaseInterface(pCaret);
    ReleaseInterface(pElemBlock);

    // 
    // Restore the gravity for pmpStart
    //
    if (eGravity != POINTER_GRAVITY_Max)
        IGNORE_HR(pmpStart->SetGravity(eGravity));

    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSpringLoader::FireOnEmptyLine
//
//  Synopsis:   Fires the spring loader on empty lines.  Handles the 
//              determination of whether the block pointed to by pmpStart 
//              (or the caret) is empty.  If the caret or the parameter 
//              points to an empty block the spring loader is fired.
//
//  Arguments:  pmpStart = optional param for start pointer
//              fMoveCaret = should we move the caret after the fire?
//
//  Returns:    HRESULT indicating whether the function was successful
//
//--------------------------------------------------------------------------
HRESULT
CSpringLoader::FireOnEmptyLine(IMarkupPointer *pmpStart /* =NULL */, BOOL fMoveCaret /*= FALSE */)
{
    HRESULT             hr = S_OK;
    CBlockPointer       bpBlock(_pCommandTarget->GetEditor());
    BOOL                bEmpty = FALSE;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spCaretPos;
    BOOL                fHasStart = (pmpStart != NULL);

    Assert(GetMarkupServices());

    if( IsSpringLoaded() )
    {
        if( !fHasStart )
        {  
            GetEditor()->CreateMarkupPointer( &pmpStart );
            IFC( GetDisplayServices()->GetCaret( &spCaret ));
            IFC( spCaret->MoveMarkupPointerToCaret( pmpStart ) );
        }

        // Position our block pointer and check if it is empty
        IFC( bpBlock.MoveTo( pmpStart, LEFT ) );
        IFC( bpBlock.IsEmpty( &bEmpty ) );

        // TODO - Make sure we are not firing the compose settings
        if( bEmpty == TRUE )
        {
            IFC( Fire( pmpStart, NULL, fMoveCaret ) );
        }
    }
    
Cleanup:
    if( !fHasStart )
    {
        ReleaseInterface( pmpStart );
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::Reset
//
//  Synopsis:   Resets the springloaded format information.
//
//----------------------------------------------------------------------------

void
CSpringLoader::Reset(IMarkupPointer * pmpPosition)
{   
    // Don't reset springloader at the same position it was loaded.
    if (IsSpringLoadedAt(pmpPosition))
        return;
        
    ClearInterface(&_pmpPosition);

    _grfFlags() = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::IsSpringLoadedAt
//
//  Synopsis:   Returns TRUE iff springloader is loaded at spec markup pointer.
//
//----------------------------------------------------------------------------

BOOL
CSpringLoader::IsSpringLoadedAt(IMarkupPointer * pmpPosition)
{
    HRESULT hr;
    int iPosition;

    if (!_fSpringLoaded || !_pmpPosition || !pmpPosition)
        return FALSE;

    hr = THR(OldCompare( _pmpPosition, pmpPosition, &iPosition));
    if (S_OK != hr)
        return FALSE;
    
    return iPosition == SAME
        || (   iPosition == RIGHT
            && IsSeparatedOnlyByPhraseScopes(_pmpPosition, pmpPosition));
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SetFormats
//
//  Synopsis:   Saves the format info passed in.
//
//-----------------------------------------------------------------------------

void
CSpringLoader::SetFormats( BOOL       fBold,
                           BOOL       fItalic,
                           BOOL       fUnderline,
                           BOOL       fSuperscript,
                           BOOL       fSubscript,
                           BOOL       fStrikeThrough,
                           CVariant * pvarName,
                           CVariant * pvarSize,
                           CVariant * pvarColor,
                           CVariant * pvarBackColor)
{
    HRESULT hr = S_OK;
    _fSuperscript = fSuperscript;
    _fSubscript = fSubscript;
    _fBold = fBold;
    _fItalic = fItalic;
    _fUnderline = fUnderline;
    _fStrikeThrough = fStrikeThrough;
    
    hr = VariantCopy(&_varName, pvarName);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = VariantCopy(&_varSize, pvarSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = VariantCopy(&_varColor, pvarColor);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr  = VariantCopy(&_varBackColor, pvarBackColor);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
Cleanup:
    return;
}


void
CSpringLoader::MarkSpringLoaded(IMarkupPointer * pmpPosition)
{
    HRESULT hr;

    // Remember the position we are being springloaded at.
    ClearInterface(&_pmpPosition);

    if (pmpPosition)
    {
        hr = THR(GetEditor()->CreateMarkupPointer(&_pmpPosition));
        if (S_OK != hr)
            goto Cleanup;

        hr = THR(_pmpPosition->MoveToPointer(pmpPosition));
        if (S_OK != hr)
            goto Cleanup;

        Assert(_pmpPosition);
    }

    _fSpringLoaded = TRUE;

Cleanup:
    return;
}


HRESULT
CSpringLoader::EnsureCaretPointers( IMarkupPointer  * pmpPosition,
                                    IHTMLCaret     ** ppCaret,
                                    IMarkupPointer ** ppmpCaret )
{
    IMarkupPointer    * pmpCaret = NULL;
    IHTMLCaret        * pCaret = NULL;
    BOOL                fEqual = FALSE;
    HRESULT             hr;

    Assert(_fSpringLoaded && pmpPosition && GetMarkupServices());

    hr = THR(GetDisplayServices()->GetCaret(&pCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pCaret->MoveMarkupPointerToCaret(pmpCaret));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(pmpCaret->IsEqualTo(pmpPosition, &fEqual));
    if (S_OK != hr)
        goto Cleanup;

    if (!fEqual)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(pmpCaret->SetGravity(POINTER_GRAVITY_Right));

Cleanup:

    if (S_OK != hr)
    {
        hr = S_FALSE;
        ReleaseInterface(pmpCaret);
        ReleaseInterface(pCaret);
    }
    else
    {
        *ppmpCaret = pmpCaret;
        *ppCaret = pCaret;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSpringLoader::UpdatePointerPositions
//
//  Synopsis:   Moves springloader pointers into newly created, empty scope.
//
//----------------------------------------------------------------------------

HRESULT
CSpringLoader::UpdatePointerPositions( IMarkupPointer * pmpStart,
                                       IMarkupPointer * pmpEnd,
                                       ELEMENT_TAG_ID   tagIdScope,
                                       BOOL             fApplyElement )
{
    MARKUP_CONTEXT_TYPE mctContext;
    IHTMLElement      * pElemScope = NULL;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    ELEMENT_TAG_ID      tagId;
    HRESULT             hr = S_OK;
    BOOL                bEqual;

    Assert(_fSpringLoaded && pmpStart && pmpEnd && pMarkupServices);

    IFC( pmpStart->IsEqualTo(pmpEnd, &bEqual) );
    if (bEqual)
        return S_OK; // done - already in correct position

    //
    // Move start pointer.
    //

    hr = THR(pmpStart->Right(FALSE, &mctContext, &pElemScope, NULL, NULL));
    if (S_OK != hr)
        goto Cleanup;

    if (!pElemScope)
        goto MoveEndPointer;

    hr = THR(pMarkupServices->GetElementTagId(pElemScope, &tagId));
    if (S_OK != hr)
        goto Cleanup;

    // If we are entering/exiting a scope as expected, go ahead and walk all pointers.
    if (   mctContext == (fApplyElement?CONTEXT_TYPE_EnterScope:CONTEXT_TYPE_ExitScope)
        && tagId == tagIdScope )
    {
        hr = THR(pmpStart->Right(TRUE, NULL, NULL, NULL, NULL));
        if (S_OK != hr)
            goto Cleanup;
    } // else an optimization prevented us from creating any gaps

MoveEndPointer:

    ClearInterface(&pElemScope);

    //
    // Move end pointer.
    //

    hr = THR( pmpEnd->Left(FALSE, &mctContext, &pElemScope, NULL, NULL));
    if (hr || !pElemScope)
        goto Cleanup;

    hr = THR(pMarkupServices->GetElementTagId(pElemScope, &tagId));
    if (S_OK != hr)
        goto Cleanup;

    // If we are entering/exiting a scope as expected, go ahead and walk all pointers.
    if (   mctContext == (fApplyElement?CONTEXT_TYPE_EnterScope:CONTEXT_TYPE_ExitScope)
        && tagId == tagIdScope )
    {
        hr = THR(pmpEnd->Left(TRUE, NULL, NULL, NULL, NULL));
        if (S_OK != hr)
            goto Cleanup;
    }

Cleanup:

    ReleaseInterface(pElemScope);
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::PrivateExec
//
//  Synopsis:   Opportunity for spring loader to intercept a command and - if
//              it hasn't already - prime itself.
//
//              This is only done for a selected number of IDM commands and
//              if the selection / range is empty (caret).
//
//  Returns:    S_OK if the command was handled.  S_FALSE if the command
//              has not been handled.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::PrivateExec( DWORD             nCmdID,
                            VARIANTARG      * pvarargIn,
                            VARIANTARG      * pvarargOut,
                            ISegmentList    * pSegmentList )
{
    IMarkupPointer      *pmpPosition = NULL;
    HRESULT             hr;
    CSelectionManager   *pSelMan;

    Assert(GetMarkupServices());
    Assert(pSegmentList || _fSpringLoaded);

    
    //
    // Determine whether the spring loader can handle this command
    // and if so return start and end markup pointers.
    //

    hr = THR(CanHandleCommand(nCmdID, pSegmentList, &pmpPosition, pvarargIn));
    if (S_OK != hr)
        goto Cleanup;

    //
    // Springload if we haven't already.
    //

    if (!_fSpringLoaded)
    {

        // Retrieve the current selection manager
        pSelMan = _pCommandTarget->GetEditor()->GetSelectionManager();
        Assert(pSelMan);

        // Terminate any IME compositions
#ifndef NO_IME
        if( pSelMan->IsIMEComposition() )
        {
            pSelMan->TerminateIMEComposition(TERMINATE_NORMAL);
        }
#endif // NO_IME        
        
        hr = THR(SpringLoad(pmpPosition));
        if (S_OK != hr)
            goto Cleanup;
    }

    //
    // Cache / handle the command.
    //

    switch (nCmdID)
    {
    case IDM_BOLD:
        _fBold = !_fBold;
        break;
    case IDM_ITALIC:
        _fItalic = !_fItalic;
        break;
    case IDM_UNDERLINE:
        _fUnderline = !_fUnderline;
        break;
    case IDM_SUBSCRIPT:
        _fSubscript = !_fSubscript;
        break;
    case IDM_SUPERSCRIPT:
        _fSuperscript = !_fSuperscript;
        break;
    case IDM_STRIKETHROUGH:
        _fStrikeThrough = !_fStrikeThrough;
        break;
    case IDM_FONTNAME:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varName, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varName);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    case IDM_FONTSIZE:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varSize, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            // Some apps assume VT_I4 is coming back (eg. Home Publisher)
            if (V_VT(&_varSize) == VT_BSTR)
            {
                if (FAILED(VariantChangeTypeSpecial(pvarargOut, &_varSize,  VT_I4)))
                {
                    hr = VariantCopy(pvarargOut, &_varSize);                    
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                hr = VariantCopy(pvarargOut, &_varSize);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
        
            }
        }
        break;
    case IDM_FORECOLOR:
        if (pvarargIn)
        {
            hr = VariantCopy(&_varColor, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varColor);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    case IDM_BACKCOLOR:
        if (pvarargIn)
        {    
            hr = VariantCopy(&_varBackColor, pvarargIn);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        if (pvarargOut)
        {
            hr = VariantCopy(pvarargOut, &_varBackColor);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        break;
    }

    if (pvarargOut && V_VT(pvarargOut)==VT_NULL)
    {
        // If the springloader couldn't answer, let the command answer.
        Assert(IDM_FONTNAME == nCmdID || IDM_FONTSIZE == nCmdID || IDM_FORECOLOR == nCmdID || IDM_BACKCOLOR == nCmdID);
        Assert(!pvarargIn);
        hr = S_FALSE;
    }

Cleanup:

    ReleaseInterface(pmpPosition);

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::PrivateQueryStatus
//
//  Synopsis:   Opportunity for spring loader to intercept a query status
//              request that has been cached in the spring loader, but hasn't
//              been applied to (or removed from) the selection / range.
//
//              This is only done for a selected number of IDM commands and if
//              the springloader is loaded.
//
//  Returns:    S_OK if the query was handled.  S_FALSE if the query
//              has not been handled.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::PrivateQueryStatus(DWORD nCmdID, OLECMD rgCmds[])
{
    OLECMD * pCmd = &rgCmds[0];
    HRESULT  hr = S_FALSE;

    Assert(pCmd);

    if (!_fSpringLoaded)
        goto Cleanup;

    //
    // Query the spring loader for the command state.
    //

    hr = S_OK;

    switch (nCmdID)
    {
    case IDM_BOLD:
    case IDM_TRISTATEBOLD:
        pCmd->cmdf = _fBold ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_ITALIC:
    case IDM_TRISTATEITALIC:
        pCmd->cmdf = _fItalic ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_UNDERLINE:
    case IDM_TRISTATEUNDERLINE:
        pCmd->cmdf = _fUnderline ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_SUBSCRIPT:
        pCmd->cmdf = _fSubscript ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_SUPERSCRIPT:
        pCmd->cmdf = _fSuperscript ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_STRIKETHROUGH:
        pCmd->cmdf = _fStrikeThrough ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
        break;
    case IDM_FONTNAME:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_FONTSIZE:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_FORECOLOR:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_BACKCOLOR:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    default:
        hr = S_FALSE;
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::CanHandleCommand
//
//  Synopsis:   Determines whether the selection passed in is empty and the
//              command is supported.
//
//  Returns:    S_OK if the command can be handled by the springloader.
//              S_FALSE if the command cannot been handled.
//
//              If S_OK, also return pmpPosition markup pointer.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::CanHandleCommand( DWORD             nCmdID,
                                 ISegmentList    * pSegmentList,
                                 IMarkupPointer ** ppmpPosition,
                                 VARIANTARG      * pvarargIn )
{
    IMarkupPointer    * pmpStart, * pmpEnd;
    CSegmentListIter    iter;
    BOOL                fEmpty = FALSE;
    int                 iPosition;
    HRESULT             hr = S_OK;
    int                 nLength = 0;

    Assert(GetMarkupServices());

    switch (nCmdID)
    {
    case IDM_BOLD:
    case IDM_ITALIC:
    case IDM_UNDERLINE:
    case IDM_SUBSCRIPT:
    case IDM_SUPERSCRIPT:
    case IDM_STRIKETHROUGH:
        break;

    case IDM_FONTNAME:
    case IDM_FONTSIZE:
    case IDM_FORECOLOR:
    case IDM_BACKCOLOR:
    case IDM_INSERTSPAN:

        if (_fSpringLoaded || pvarargIn)
            break;

        // fall through
    default:
        hr = S_FALSE;
        goto Cleanup;
    }

    if (!pSegmentList)
    {
        Assert(_fSpringLoaded);
        goto Cleanup;
    }

    //
    // Make sure we have an only one segment in our selection.    
    //

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    IFC( GetSegmentCount( pSegmentList, &nLength ) );

    if( fEmpty == TRUE || nLength > 1 )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = iter.Init(GetEditor(), pSegmentList);
    if (FAILED(hr))
        goto Cleanup;

    hr = iter.Next(&pmpStart, &pmpEnd);
    if (FAILED(hr))
        goto Cleanup;

    if (!pmpStart || !pmpEnd)
    {
        hr = S_FALSE;
        goto Cleanup;
    }


    if (ppmpPosition)
    {
        // APPCOMPAT: Outlook is creating an "nbsp" selection before the user
        // can type in a new line.  Thus the pmpStart and pmpEnd pointers are
        // temporarily in different positions, and that is why we perform
        // the following comparison only when we are actually springloading
        // (ppmpStart not NULL) and not when we are already springloaded.

        hr = THR(OldCompare( pmpStart, pmpEnd, &iPosition));
        if (S_OK != hr)
            goto Cleanup;

        // If the position is different, selection 6is not empty.
        if (iPosition)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        //
        // At this point we know, we have an empty selection (range).
        //

        *ppmpPosition = pmpStart;
        pmpStart->AddRef();
    }

    hr = S_OK;

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadComposeSettings
//
//  Synopsis:   Loads the default font settings made by the host into the spring
//              loader.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoadComposeSettings(IMarkupPointer * pmpNewPosition, BOOL fReset, BOOL fOutsideSpan)
{
    Assert(_pCommandTarget && _pCommandTarget->GetEditor());
    struct COMPOSE_SETTINGS * pComposeSettings = _pCommandTarget->GetEditor()->GetComposeSettings();
    BOOL                      fSpringLoadAcrossLayout = FALSE;
    HRESULT                   hr = S_OK;

    if (fReset)
        Reset();

    // Determine whether we are allowed to springload compose settings at the
    // position specified.

    if (   !pComposeSettings
        || !pComposeSettings->_fComposeSettings
        || _fSpringLoaded) // don't springload again
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Check whether we can springload compose settings at the position passed in.
    //

    hr = THR(CanSpringLoadComposeSettings(pmpNewPosition, &fSpringLoadAcrossLayout, fOutsideSpan));
    if (hr || fSpringLoadAcrossLayout)
        goto Cleanup;


    //
    // Check if there is already some paragraph formatting associated with the empty line.
    // If so, spring load it instead of the compose font.
    //
    hr = THR(SpringLoadParagraphFormatting(pmpNewPosition));
    if (hr != S_FALSE)
        goto Cleanup;

    //
    // Finally, springload compose settings.
    //

    Assert(pComposeSettings && pComposeSettings->_fComposeSettings);

    _fBold        = pComposeSettings->_fBold;
    _fItalic      = pComposeSettings->_fItalic;
    _fUnderline   = pComposeSettings->_fUnderline;
    _fSuperscript = pComposeSettings->_fSuperscript;
    _fSubscript   = pComposeSettings->_fSubscript;
    _fStrikeThrough = FALSE; // no compose font support for strikethrough 

    hr = VariantCopy(&_varName, &pComposeSettings->_varFont);
    if (FAILED(hr))
        goto Cleanup;
    hr = VariantCopy(&_varSpanClass, &pComposeSettings->_varSpanClass);
    if (FAILED(hr))
        goto Cleanup;
    
    if (pComposeSettings->_color & CColorValue::MASK_FLAG)
        V_VT(&_varColor)= VT_NULL;
    else
    {
        V_VT(&_varColor)    = VT_I4;
        V_I4(&_varColor)    = pComposeSettings->_color;
    }

    if (pComposeSettings->_colorBg & CColorValue::MASK_FLAG)
        V_VT(&_varBackColor)= VT_NULL;
    else
    {
        V_VT(&_varBackColor)= VT_I4;
        V_I4(&_varBackColor)= pComposeSettings->_colorBg;
    }

    if (pComposeSettings->_lSize == -1)
        V_VT(&_varSize)     = VT_NULL;
    else
    {
        V_VT(&_varSize)     = VT_I4;
        // Sizes in this spring loader are in the 1..7 range
        V_I4(&_varSize)     = pComposeSettings->_lSize;
    }

    // We are now springloaded.
    MarkSpringLoaded(pmpNewPosition);
    hr = S_OK;

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CSpringLoader::CanSpringLoadComposeSettings(IMarkupPointer * pmpNewPosition, BOOL * pfCanOverrideSpringLoad, BOOL fOutsideSpan, BOOL fDontJump)
{
    IHTMLElement      * pElemWalk = NULL;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    BOOL                fInHTMLEditMode = IsDocumentInHTMLEditMode();
    HRESULT             hr;

    Assert(pMarkupServices);

    // Not passing in a position pretty much means a free ticket to springloading.
    if (fInHTMLEditMode && !pmpNewPosition)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // If we are not in html edit mode, don't springload compose settings.
    if ( !fInHTMLEditMode )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get our nearest parent element (scope).
    hr = THR(pmpNewPosition->CurrentScope(&pElemWalk));
    if (S_OK != hr)
        goto Cleanup;

    // If we are not in a body container, don't springload.
    if( !pElemWalk || HasNonBodyContainer(pMarkupServices, pElemWalk))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (fOutsideSpan)
    {
        // If we are in "format text outside any of our span tags in compose settings" mode, and
        // we are outside one of our span tags, allow springloading occur next to text.
        Assert(_pCommandTarget && _pCommandTarget->GetEditor());
        struct COMPOSE_SETTINGS * pComposeSettings = _pCommandTarget->GetEditor()->GetComposeSettings();
        if (pComposeSettings && pComposeSettings->_fUseOutsideSpan && !InSpanScope(pmpNewPosition))
            goto Cleanup;
    }

    // Walk up the parent element chain in search of the first block elemnent.  If it is
    // empty, allow springloading of compose settings.  If it isn't, don't allow it.
    while (pElemWalk)
    {
        IHTMLElement * pElemParent;
        BOOL           fBlockElement;

        // Look for a block element.
        hr = THR(IsBlockOrLayoutOrScrollable(pElemWalk, &fBlockElement));
        if (hr)
            goto Cleanup;

        // If we find a block element, we are making the decision now.
        if (fBlockElement)
        {
            // Blocks that already have formats associated with them
            // don't allow compose settings.
            if (IsCharFormatBlock(pElemWalk))
            {
                hr = S_FALSE;
            }
            else if (!IsBlockEmptyForSpringLoading(pmpNewPosition, pElemWalk, fDontJump))
            {
                if (!fDontJump)
                {
                    // If the position doesn't have formatting, attempt to springload
                    // formatting from text found nearby.
                    BOOL fSpringLoaded = SpringLoadFormatsAcrossLayout(pmpNewPosition, pElemWalk, pfCanOverrideSpringLoad!=NULL);
                    if (fSpringLoaded)
                    {
                        if (pfCanOverrideSpringLoad)
                            *pfCanOverrideSpringLoad = TRUE;
                        goto Cleanup;
                    }
                }

                hr = S_FALSE;
            }

            goto Cleanup;
        }

        hr = THR(GetEditor()->GetParentElement(pElemWalk, &pElemParent));
        if (hr)
            goto Cleanup;

        ReleaseInterface(pElemWalk);
        pElemWalk = pElemParent;
    }

    hr = S_FALSE;

Cleanup:

    ReleaseInterface(pElemWalk);

    RRETURN1(hr, S_FALSE);
}


BOOL
CSpringLoader::IsCharFormatBlock(IHTMLElement * pElem)
{
    IMarkupServices * pMarkupServices = GetMarkupServices();
    BOOL              fResult = FALSE;
    ELEMENT_TAG_ID    tagid;
    HRESULT           hr;

    Assert(pMarkupServices);

    hr = THR(pMarkupServices->GetElementTagId(pElem, &tagid));
    if (hr || !pElem)
        goto Cleanup;

    fResult = tagid >= TAGID_H1 && tagid <= TAGID_H6 || tagid == TAGID_PRE;

Cleanup:

    return fResult;
}


BOOL
CSpringLoader::CanJumpOverElement(IHTMLElement * pElem)
{
    BOOL fCanJump = IsCharFormatBlock(pElem);

    if (!fCanJump)
    {
        ELEMENT_TAG_ID tagid;
        HRESULT hr = THR(GetMarkupServices()->GetElementTagId(pElem, &tagid));
        if (!hr && pElem && tagid == TAGID_A)
            fCanJump = TRUE;
    }

    if (!fCanJump)
        IGNORE_HR(IsBlockOrLayoutOrScrollable(pElem, NULL, &fCanJump));

    return fCanJump;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::InSpanScope
//
//  Synopsis:   Checks whether the FIRST (!) span encountered up the parent
//              chain has the springloaded class.
//              loader.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::InSpanScope(IMarkupPointer * pmpPosition)
{
    IMarkupServices * pMarkupServices = GetMarkupServices();
    IHTMLElement    * pElem = NULL;
    ELEMENT_TAG_ID    tagId = TAGID_NULL;
    BOOL              fInSpanScope = FALSE;
    CVariant          varSpanClass;
    HRESULT           hr;

    Assert(pmpPosition && V_VT(&_varSpanClass) == VT_BSTR);

    //
    // Look for span on parent chain.
    //

    IFC( pmpPosition->CurrentScope( &pElem ) );

    while (tagId != TAGID_SPAN)
    {
        IHTMLElement * pElemParent = NULL;

        if (!pElem)
            goto Cleanup;

        hr = THR(pMarkupServices->GetElementTagId(pElem, &tagId));
        if (hr)
            goto Cleanup;

        if (tagId == TAGID_SPAN)
            break;
        else if (tagId == TAGID_BODY)
            goto Cleanup;

        hr = THR(GetEditor()->GetParentElement(pElem, &pElemParent));
        if (hr)
            goto Cleanup;

        ReleaseInterface(pElem);
        pElem = pElemParent;
    }

    // Found span.
    Assert(tagId == TAGID_SPAN && pElem);

    //
    // Check class name.
    //

    hr = THR(pElem->getAttribute(_T("class"), 0, &varSpanClass));
    if (hr)
        goto Cleanup;

    if (   V_VT(&varSpanClass) == VT_BSTR
        && !_tcscmp(V_BSTR(&varSpanClass), V_BSTR(&_varSpanClass)) )
    {
        fInSpanScope = TRUE;
    }

    if (!fInSpanScope)
    {
        hr = THR(pElem->getAttribute(_T("className"), 0, &varSpanClass));
        if (hr)
            goto Cleanup;

        if (   V_VT(&varSpanClass) == VT_BSTR
            && !_tcscmp(V_BSTR(&varSpanClass), V_BSTR(&_varSpanClass)) )
        {
            fInSpanScope = TRUE;
        }
    }

Cleanup:

    ReleaseInterface(pElem);
    return fInSpanScope;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsSeparatedOnlyByPhraseScopes
//
//  Synopsis:   Checks if the two markup pointers are only separated by phrase
//              or span element enter scopes.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsSeparatedOnlyByPhraseScopes(IMarkupPointer * pmpLeft, IMarkupPointer * pmpRight)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    SP_IHTMLElement     spElemWalk;
    SP_IMarkupPointer   spmpWalk;
    MARKUP_CONTEXT_TYPE mctContext;
    int                 iPosition = RIGHT;
    BOOL                fRet = FALSE;
    ELEMENT_TAG_ID      tagId;
    HRESULT             hr;

    Assert(pMarkupServices && pmpLeft && pmpRight);
    Assert(S_OK == THR(OldCompare( pmpLeft, pmpRight, &iPosition)) && iPosition == RIGHT);

    IFC(CopyMarkupPointer(_pCommandTarget->GetEditor(), pmpLeft, &spmpWalk));

    while (S_OK == THR(OldCompare( spmpWalk, pmpRight, &iPosition)) && iPosition == RIGHT)
    {
        IFC(spmpWalk->Right(TRUE, &mctContext, &spElemWalk, NULL, NULL));

        if (   (mctContext != CONTEXT_TYPE_EnterScope && mctContext != CONTEXT_TYPE_ExitScope)
            || !spElemWalk
            || S_OK != THR(pMarkupServices->GetElementTagId(spElemWalk, &tagId))
            || (!_pCommandTarget->GetEditor()->IsPhraseElement(spElemWalk) &&
                tagId != TAGID_DIV) // APPCOMPAT: 57834 Outlook 98 - allow going through DIVs
           )
        {
            goto Cleanup;
        }
    }

    fRet = iPosition == SAME;

Cleanup:

    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsDocumentInHTMLEditMode
//
//  Synopsis:   Checks if the document is in HTML edit mode for compose font.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsDocumentInHTMLEditMode()
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IOleCommandTarget * pDoc = NULL;
    OLECMD              cmd;
    BOOL                fDocumentInHTMLEditMode = TRUE;
    HRESULT             hr;

    hr = THR(pMarkupServices->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &pDoc));
    if (hr || !pDoc)
        goto Cleanup;

    cmd.cmdID = IDM_HTMLEDITMODE;
    hr = THR(pDoc->QueryStatus((GUID *)&CGID_MSHTML, 1, &cmd, NULL));
    fDocumentInHTMLEditMode = hr != S_OK || MSOCMDSTATE_DOWN == cmd.cmdf;

Cleanup:

    ReleaseInterface(pDoc);

    return fDocumentInHTMLEditMode;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::IsBlockEmptyForSpringLoading
//
//  Synopsis:   Checks if the block element passed in is empty for spring
//              loading purposes. It is empty if it contains no chars or if
//              all the chars that it contains are synthetic chars.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::IsBlockEmptyForSpringLoading(IMarkupPointer * pmpStart, IHTMLElement * pElemBlock, BOOL fDontJump)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pmpBlockDelimiter = NULL;
    IMarkupPointer    * pmpWalk = NULL;
    IHTMLElement      * pElemWalk = NULL;
    ELEMENT_TAG_ID      tagId;
    MARKUP_CONTEXT_TYPE mctContext;
    long                cch;
    TCHAR               ch;
    BOOL                fEmpty = FALSE;
    int                 iResult, cNBSP = 0, iDirection;
    HRESULT             hr;
    BOOL                fAllowWhitespace = TRUE;

#if DBG==1
    BOOL fBlockElement;
    Assert(pMarkupServices);
    Assert(pElemBlock && (S_OK == THR(IsBlockOrLayoutOrScrollable(pElemBlock, &fBlockElement))) && fBlockElement);
#endif // DBG==1

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpBlockDelimiter));
    if (hr)
        goto Cleanup;

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpWalk));
    if (hr)
        goto Cleanup;

    //
    // Look to the left and right in search for text.
    //

    for (iDirection = -1 ; iDirection <= 1 ; iDirection += 2)
    {
        hr = THR(pmpWalk->MoveToPointer(pmpStart));
        if (hr)
            goto Cleanup;

        if (iDirection == -1)
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_AfterBegin));
        else
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_BeforeEnd));
        if (hr)
            goto Cleanup;

        // Search left or right.
        while (S_OK == THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult)) && (iResult*iDirection) < 0)
        {
            BOOL fStopLooking = FALSE;

            // Walk one character at a time.
            ClearInterface(&pElemWalk);
            cch = 1;
            if (iDirection == -1)
                hr = THR(pmpWalk->Left(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            else
                hr = THR(pmpWalk->Right(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            if (hr)
                goto Cleanup;

            switch (mctContext)
            {
            case CONTEXT_TYPE_EnterScope:
                // We can jump over layouts (TABLE, nested DIV, BUTTON, etc).
                if (!fDontJump && pElemWalk && CanJumpOverElement(pElemWalk))
                {
                    IGNORE_HR(pmpWalk->MoveAdjacentToElement(pElemWalk, ((iDirection==-1)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd)));
                    fAllowWhitespace = FALSE;
                }
                break;

            case CONTEXT_TYPE_NoScope:
                // BRs mean we're done looking in that direction.
                if (pElemWalk && S_OK == THR(pMarkupServices->GetElementTagId(pElemWalk, &tagId)) && TAGID_BR == tagId)
                    fStopLooking = TRUE;
                break;

            case CONTEXT_TYPE_Text:
                // If we find non-whitespace text, the search is over.
                if (cch && (!fAllowWhitespace || !IsWhiteSpace(ch)) && (WCH_NBSP != ch || ++cNBSP >= 4))
                    goto Cleanup;
                break;
            }

            if (fStopLooking)
                break;
        }
    }

    // If we make it here, the blockelement is empty (has no text).
    fEmpty = TRUE;

Cleanup:

    ReleaseInterface(pmpBlockDelimiter);
    ReleaseInterface(pmpWalk);
    ReleaseInterface(pElemWalk);

    return fEmpty;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadFormatsAcrossLayout
//
//  Synopsis:   If the markup ptr is next to a site, then springload using
//              formats copied from the other side of the site.
//
//-----------------------------------------------------------------------------

BOOL
CSpringLoader::SpringLoadFormatsAcrossLayout(IMarkupPointer * pmpPosition, IHTMLElement * pElemBlock, BOOL fActuallySpringLoad)
{
    IMarkupPointer    * pmpBlockDelimiter = NULL;
    IMarkupPointer    * pmpWalk = NULL;
    IMarkupPointer    * pmpAcrossLayout = NULL;
    IHTMLElement      * pElemWalk = NULL;
    IHTMLElement      * pElemToLeft = NULL, * pElemToRight = NULL;
    MARKUP_CONTEXT_TYPE mctContext;
    long                cch;
    TCHAR               ch;
    DWORD               dwSpringLoad = 0;
    int                 iResult, iDirection, cNBSP = 0;
    HRESULT             hr;

    Assert(GetMarkupServices() && pmpPosition && pElemBlock);

    //
    // 1. Optimization and important first cut:  If we are directly next to real (formatted) text, don't override formatting.
    //

    cch = 1;
    if (   S_OK != THR(pmpPosition->Left(FALSE, &mctContext, &pElemToLeft, &cch, &ch))
        || (mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch))
        goto Cleanup;
    cch = 1;
    if (   S_OK != THR(pmpPosition->Right(FALSE, &mctContext, &pElemToRight, &cch, &ch))
        || (mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch))
        goto Cleanup;

    //
    // 2. Next see if an adjust for insert gets us next to text: First left, then right.
    //

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpWalk));
    if (hr)
        goto Cleanup;

    // Check on the left side.
    // Only if we don't have a jumpable element.  This assumes adjust for insert doesn't leave tags.
    if (!pElemToLeft || !CanJumpOverElement(pElemToLeft))
    {
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;
    
        cch = 1;
        if (   S_OK == THR(AdjustPointerForInsert(pmpWalk, LEFT, LEFT))
            && S_OK == THR(pmpWalk->Left(FALSE, &mctContext, NULL, &cch, &ch))
            && mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch)
        {
            dwSpringLoad = SL_ADJUST_FOR_INSERT_LEFT;
            pmpAcrossLayout = pmpWalk;
            pmpWalk = NULL;
            goto SpringLoad;
        }
    }

    // Check on the right side.
    // Only if we don't have a jumpable element.  This assumes adjust for insert doesn't leave tags.
    if (!pElemToRight || !CanJumpOverElement(pElemToRight))
    {
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;

        cch = 1;
        if (   S_OK == THR(AdjustPointerForInsert(pmpWalk, RIGHT, RIGHT))
            && S_OK == THR(pmpWalk->Right(FALSE, &mctContext, NULL, &cch, &ch))
            && mctContext == CONTEXT_TYPE_Text && cch == 1 && !IsWhiteSpace(ch) && WCH_NBSP != ch)
        {
            dwSpringLoad = SL_ADJUST_FOR_INSERT_RIGHT;
            pmpAcrossLayout = pmpWalk;
            pmpWalk = NULL;
            goto SpringLoad;
        }
    }

    //
    // 3. Look for formatted text on the other side of elements: First left then right.
    //

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpBlockDelimiter));
    if (hr)
        goto Cleanup;

    for (iDirection = -1 ; iDirection <= 1 ; iDirection += 2)
    {
        // Start out walk pointer at position specified.
        hr = THR(pmpWalk->MoveToPointer(pmpPosition));
        if (hr)
            goto Cleanup;

        // Set up pointer on block element start or end.
        if (iDirection == -1)
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_AfterBegin));
        else
            hr = THR(pmpBlockDelimiter->MoveAdjacentToElement(pElemBlock, ELEM_ADJ_BeforeEnd));
        if (hr)
            goto Cleanup;

        // Start walking.
        while (S_OK == THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult)) && (iResult*iDirection) < 0)
        {
            BOOL fFoundRealText = FALSE;
            BOOL fOutOfBounds = FALSE;

            // Walk one character at a time.
            ClearInterface(&pElemWalk);
            cch = 1;
            if (iDirection == -1)
                hr = THR(pmpWalk->Left(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            else
                hr = THR(pmpWalk->Right(TRUE, &mctContext, &pElemWalk, &cch, &ch));
            if (hr)
                goto Cleanup;

            // If we find an element, see if we can jump over it in order to find the formatted text
            // on its other side.
            switch (mctContext)
            {
            case CONTEXT_TYPE_EnterScope:
                // Can jump over layouts (TABLE, nested DIV, BUTTON, etc), charformat blockelements and anchors.
                if (pElemWalk && CanJumpOverElement(pElemWalk))
                {
                    hr = THR(pmpWalk->MoveAdjacentToElement(pElemWalk, ((iDirection==-1)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd)));
                    if (hr)
                        goto Cleanup;

                    hr = THR(OldCompare(pmpWalk, pmpBlockDelimiter, &iResult));
                    if (hr)
                        goto Cleanup;

                    fOutOfBounds = (iResult*iDirection) >= 0;
                }
                // fall through

            case CONTEXT_TYPE_NoScope:
                if (   pElemWalk
                    && !pmpAcrossLayout)
                {
                    hr = THR(GetEditor()->CreateMarkupPointer(&pmpAcrossLayout));
                    if (hr)
                        goto Cleanup;
                }
                break;

            case CONTEXT_TYPE_Text:
                // Check if we found REAL text (ignore spaces).
                fFoundRealText = cch && !IsWhiteSpace(ch) && (WCH_NBSP != ch || ++cNBSP >= 2);
                break;
            }

            if (fOutOfBounds)
                break;
            
            if (fFoundRealText)
            {
                if (pmpAcrossLayout)
                    dwSpringLoad = ((iDirection==-1) ? SL_ADJUST_FOR_INSERT_LEFT : SL_ADJUST_FOR_INSERT_RIGHT);

                Assert(pmpAcrossLayout || !dwSpringLoad);
                goto SpringLoad;
            }

            if (pmpAcrossLayout)
            {
                // Remember the position in front of the LEFTMOST element.
                hr = THR(pmpAcrossLayout->MoveToPointer(pmpWalk));
                if (hr)
                    goto Cleanup;
            }
        }

        ClearInterface(&pmpAcrossLayout);
    }

SpringLoad:

    if (dwSpringLoad && fActuallySpringLoad)
    {
        Assert(pmpAcrossLayout);

        // Load springloader with format settings found at pmpAcrossLayout.
        // Given that we are here, we know we have found text, and therefore no AdjustForInsert is necessary.
        hr = THR(SpringLoad(pmpAcrossLayout, 0));
        if (hr)
            goto Cleanup;

        Reposition(pmpPosition);
    }

Cleanup:

    ReleaseInterface(pmpWalk);
    ReleaseInterface(pmpBlockDelimiter);
    ReleaseInterface(pmpAcrossLayout);
    ReleaseInterface(pElemWalk);
    ReleaseInterface(pElemToLeft);
    ReleaseInterface(pElemToRight);
    
    return dwSpringLoad != 0;
}


// Springloader copy of adjust pointer for insert (in case no tracker is around).

HRESULT
CSpringLoader::AdjustPointerForInsert(IMarkupPointer * pWhereIThinkIAm, INT inBlockcDir, INT inTextDir)
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spLeftEdge;
    SP_IMarkupPointer spRightEdge;    
    CHTMLEditor * pEd = _pCommandTarget->GetEditor();
    CSelectionManager * pSelMan = pEd->GetSelectionManager();
    SP_IDisplayPointer spDispPointer;

    IFC( pSelMan->GetEditor()->CreateMarkupPointer( &spLeftEdge ));
    IFC( pSelMan->GetEditor()->CreateMarkupPointer( &spRightEdge ));
    IFC( pSelMan->MovePointersToContext( spLeftEdge, spRightEdge ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispPointer->MoveToMarkupPointer(pWhereIThinkIAm, NULL) )
    
    IFC( pEd->AdjustPointer( spDispPointer, inBlockcDir, inTextDir, spLeftEdge, spRightEdge, ADJPTROPT_AdjustIntoURL));
    IFC( spDispPointer->PositionMarkupPointer(pWhereIThinkIAm) );

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method:     CSpringLoader::SpringLoadParagraphFormatting
//
//  Synopsis:   Loads the default font settings made by the host into the spring
//              loader.
//
//-----------------------------------------------------------------------------

HRESULT
CSpringLoader::SpringLoadParagraphFormatting(IMarkupPointer *pPosition)
{
    HRESULT                 hr = S_FALSE;
    CEditPointer            epTest(_pCommandTarget->GetEditor());
    CEditPointer            epTestBR(_pCommandTarget->GetEditor());   
    BOOL                    fFoundBR;
    DWORD                   dwFound;
    SP_IHTMLComputedStyle   spComputedStyle1;
    SP_IHTMLComputedStyle   spComputedStyle2;
    BOOL                    fEqual;

    //
    // Check for the NULL case
    //
    if( !pPosition )
        goto Cleanup;
        
    IFC( epTest->MoveToPointer(pPosition) );

    //
    // Move to end of block
    //

    IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    fFoundBR = epTest.CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock);
    
    if (fFoundBR)
    {
        IFC( epTestBR->MoveToPointer(epTest) );
        IFC( epTestBR.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

        IFC( epTest.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

        if( !epTest.CheckFlag( dwFound, BREAK_CONDITION_Site ) &&
            !epTest.CheckFlag( dwFound, BREAK_CONDITION_Block ))
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        
    }
    
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    

    //
    // Get format cache info for comparison [TODO: current style]
    //

    IFC( GetDisplayServices()->GetComputedStyle(epTest, &spComputedStyle1) );

    //
    // Compare format data with that in inner most phrase element
    //

    if (fFoundBR)
        IFC( epTest->MoveToPointer(epTestBR) );
    
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_ExitPhrase, &dwFound) );
    if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitPhrase)
        && !epTest.CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_EnterPhrase, &dwFound) );
    Assert(dwFound == BREAK_CONDITION_EnterPhrase
           || dwFound == BREAK_CONDITION_NoScopeBlock);

    IFC( GetDisplayServices()->GetComputedStyle(epTest, &spComputedStyle2) );
    IFC( ComputedStylesEqual( spComputedStyle1, spComputedStyle2, &fEqual) );

    if (fEqual)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    //
    // Some formatting exists, so spring load at this position [TODO: use format data above]
    //

    IFC( SpringLoad(epTest) );

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSpringLoader::ComputedStylesEqual(IHTMLComputedStyle *pIStyle1, IHTMLComputedStyle *pIStyle2, BOOL *pfEqual)
{
    HRESULT         hr = S_OK;
    TCHAR           szFont1[LF_FACESIZE + 1];
    TCHAR           szFont2[LF_FACESIZE + 1];
    long            lSize1, lSize2;
    DWORD           dwColor1, dwColor2;
    DWORD           dwBackColor1, dwBackColor2;
    VARIANT_BOOL    bBold1, bBold2;
    VARIANT_BOOL    bUnderline1, bUnderline2;
    VARIANT_BOOL    bItalic1, bItalic2;
    VARIANT_BOOL    bSuperscript1, bSuperscript2;
    VARIANT_BOOL    bSubscript1, bSubscript2;
    
    Assert( pIStyle1 && pIStyle2 && pfEqual );

    *pfEqual = FALSE;

    //
    // Foreground color
    //
    IFC( pIStyle1->get_textColor( &dwColor1) );
    IFC( pIStyle2->get_textColor( &dwColor2) );

    if( dwColor1 != dwColor2 )
        goto Cleanup;

    //
    // Background color
    //
    IFC( pIStyle1->get_backgroundColor( &dwBackColor1) );
    IFC( pIStyle2->get_backgroundColor( &dwBackColor2) );

    if( dwBackColor1 != dwBackColor2 )
        goto Cleanup;

    //
    // Font size
    //
    IFC( pIStyle1->get_fontSize( &lSize1 ) );
    IFC( pIStyle2->get_fontSize( &lSize2 ) );
    
    if( lSize1 != lSize2 )
        goto Cleanup;

    //
    // Bold
    //
    IFC( pIStyle1->get_bold( &bBold1 ) );
    IFC( pIStyle2->get_bold( &bBold2 ) );

    if( bBold1 != bBold2 )
        goto Cleanup;

    //
    // Underline
    //
    IFC( pIStyle1->get_underline( &bUnderline1 ) );
    IFC( pIStyle2->get_underline( &bUnderline2 ) );

    if( bUnderline1 != bUnderline2 )
        goto Cleanup;

    //
    // Italic
    //
    IFC( pIStyle1->get_italic( &bItalic1 ) );
    IFC( pIStyle2->get_italic( &bItalic2 ) );

    if( bItalic1 != bItalic2 )
        goto Cleanup;

    //
    // Superscript
    //
    IFC( pIStyle1->get_superScript( &bSuperscript1 ) );
    IFC( pIStyle2->get_superScript( &bSuperscript2 ) );

    if( bSuperscript1 != bSuperscript2 )
        goto Cleanup;

    //
    // Subscript
    //
    IFC( pIStyle1->get_subScript( &bSubscript1 ) );
    IFC( pIStyle2->get_subScript( &bSubscript2 ) );

    if( bSubscript1 != bSubscript2 )
        goto Cleanup;
        
    //
    // Font name
    //
    IFC( pIStyle1->get_fontName((TCHAR *)&szFont1) );
    IFC( pIStyle2->get_fontName((TCHAR *)&szFont2) );

    if( _tcscmp(szFont1, szFont2) != 0 )
        goto Cleanup;

    *pfEqual = TRUE;
    
Cleanup:
    RRETURN(hr);
}


CHTMLEditor *
CSpringLoader::GetEditor()
{
    return _pCommandTarget->GetEditor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\editres\makefile.inc ===
# Run the HTML dialogs though the preprocessor to remove comments
# then through a sed script to reomave extra whitespace.

$O\forchar.dls : forchar.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP forchar.dlg > $@

$O\forchar.dlx : $O\forchar.dls dlg.pl
    perl dlg.pl < $O\forchar.dls > $@

$O\insimage.dls : insimage.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP insimage.dlg > $@

$O\insimage.dlx : $O\insimage.dls dlg.pl
    perl dlg.pl < $O\insimage.dls > $@

$O\edlink.dls : edlink.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP edlink.dlg > $@

$O\edlink.dlx : $O\edlink.dls dlg.pl
    perl dlg.pl < $O\edlink.dls > $@

$O\edbook.dls : edbook.dlg dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP edlink.dlg > $@

$O\edbook.dlx : $O\edbook.dls dlg.pl
    perl dlg.pl < $O\edbook.dls > $@

# Run the HTML property pages through a sed
# script to remove extra whitespaces.

MSHTMLER_DEP = \
    $O\forchar.dlx \
    $O\insimage.dlx \
    $O\edlink.dlx

mshtmler.rc : $(MSHTMLER_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\edcom.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_FLATPTR_HXX_
#define X_FLATPTR_HXX_
#include "flatptr.hxx"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

MtDefine(CEditXform, Utilities, "CEditXform")

using namespace EdUtil;

HRESULT
OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi )
{
    HRESULT hr = S_OK;
    BOOL    fResult;
    
    hr = THR_NOTRACE( p1->IsEqualTo( p2, & fResult ) );
    if ( FAILED( hr ) )
        goto Cleanup;
        
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }

    hr = THR_NOTRACE( p1->IsLeftOf( p2, & fResult ) );
    if ( FAILED( hr ) )
        goto Cleanup;
        
    *pi = fResult ? -1 : 1;

Cleanup:

    RRETURN( hr );
}

HRESULT
EdUtil::CopyMarkupPointer(CEditorDoc      *pEditorDoc,
                          IMarkupPointer  *pSource,
                          IMarkupPointer  **ppDest )
{
    HRESULT hr;

    hr = THR(CreateMarkupPointer2(pEditorDoc, ppDest));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR((*ppDest)->MoveToPointer(pSource));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareColor, local helper
//  Synopsis:   compares color
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareColor(VARIANT * pvarColor1, VARIANT * pvarColor2)
{
    BOOL        fResult;
    CVariant    var;
    COLORREF    color1;
    COLORREF    color2;

    if (   V_VT(pvarColor1) == VT_NULL
        || V_VT(pvarColor2) == VT_NULL
       )
    {
        fResult = V_VT(pvarColor1) == V_VT(pvarColor2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&var, pvarColor1,  VT_I4))
        goto Error;

    color1 = (COLORREF)V_I4(&var);

    if (VariantChangeTypeSpecial(&var, pvarColor2, VT_I4))
        goto Error;

    color2 = (COLORREF)V_I4(&var);

    fResult = color1 == color2;

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareBSTRS, local helper
//  Synopsis:   compares 2 btrs
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareBSTRS(VARIANT * pvar1, VARIANT * pvar2)
{
    BOOL    fResult;
    TCHAR  *pStr1;
    TCHAR  *pStr2;
    TCHAR  ach[1] = {0};

    if (V_VT(pvar1) == VT_BSTR && V_VT(pvar2) == VT_BSTR)
    {
        pStr1 = V_BSTR(pvar1) ? V_BSTR(pvar1) : ach;
        pStr2 = V_BSTR(pvar2) ? V_BSTR(pvar2) : ach;

        fResult = StrCmpC(pStr1, pStr2) == 0;
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
EdUtil::FormsAllocStringW(LPCWSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

#if defined(_MAC) || defined(WIN16)
HRESULT
EdUtil::FormsAllocStringA(LPCSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

#ifndef WIN16
HRESULT
EdUtil::FormsAllocStringA(LPCWSTR pwch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pwch || !*pwch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    CStr str;
    str.Set(pwch);
    *pBSTR = SysAllocString(str.GetAltStr());

    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}
#endif // !WIN16
#endif //_MAC

//+----------------------------------------------------------------------------
//  Method:     VariantCompareFontName, local helper
//  Synopsis:   compares font names
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareFontName(VARIANT * pvarName1, VARIANT * pvarName2)
{
    return VariantCompareBSTRS(pvarName1, pvarName2);
}

//+----------------------------------------------------------------------------
//  Method:     VariantCompareFontSize, local helper
//  Synopsis:   compares font size
//-----------------------------------------------------------------------------

BOOL
EdUtil::VariantCompareFontSize(VARIANT * pvarSize1, VARIANT * pvarSize2)
{
    CVariant    convVar1;
    CVariant    convVar2;
    BOOL        fResult;

    Assert(pvarSize1);
    Assert(pvarSize2);

    if (   V_VT(pvarSize1) == VT_NULL
        || V_VT(pvarSize2) == VT_NULL
       )
    {
        fResult = V_VT(pvarSize1) == V_VT(pvarSize2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&convVar1, pvarSize1, VT_I4))
        goto Error;

    if (VariantChangeTypeSpecial(&convVar2, pvarSize2, VT_I4))
        goto Error;

    fResult = V_I4(&convVar1) == V_I4(&convVar2);

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


DWORD 
EdUtil::ConvertRGBColorToOleColor(DWORD dwColor)
{
    return ((dwColor & 0xff) << 16) | (dwColor & 0xff00) | ((dwColor & 0xff0000) >> 16);
}

HRESULT
EdUtil::ConvertOLEColorToRGB(VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;
    DWORD   dwColor;

    if (V_VT(pvarargIn) != VT_BSTR)
    {
        hr = THR(VariantChangeTypeSpecial(pvarargIn, pvarargIn, VT_I4));

        if (!hr && V_VT(pvarargIn) == VT_I4)
        {
            //
            // Note SujalP and TerryLu:
            //
            // If the color coming in is not a string type, then it is assumed
            // to be in a numeric format which is BBGGRR. However, FormatRange
            // (actually put_color()) expects a RRGGBB. For this reason, whenever
            // we get a VT_I4, we convert it to a RRGGBB. To do this we use
            // then helper on CColorValue, SetFromRGB() wto which we pass an
            // ****BBGGRR**** value. It just flips the bytes around and ends
            // up with a RRGGBB value, which we retrieve from GetColorRef().
            //
            V_VT(pvarargIn) = VT_I4;
            dwColor = V_I4(pvarargIn);

            V_I4(pvarargIn) = ((dwColor & 0xff) << 16)
                             | (dwColor & 0xff00)
                             | ((dwColor & 0xff0000) >> 16);

        }
    }

    RRETURN(hr);
}

HRESULT
EdUtil::ConvertRGBToOLEColor(VARIANT *pvarargIn)
{
    //
    // It just flips the byte order so this is a valid implementation
    //
    return ConvertOLEColorToRGB(pvarargIn);
}

BOOL
EdUtil::IsListContainer(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
    case TAGID_OL:
    case TAGID_UL:
    case TAGID_MENU:
    case TAGID_DIR:
    case TAGID_DL:
        return TRUE;

    default:
        return FALSE;
    }
}

BOOL
EdUtil::IsListItem(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
    case TAGID_LI:
    case TAGID_DD:
    case TAGID_DT:
        return TRUE;

    default:
        return FALSE;
    }
}

// Font height conversion data.  Valid HTML font sizes ares [1..7]
// NB (cthrash) These are in twips, and are in the 'smallest' font
// size.  The scaling takes place in CFontCache::GetCcs().

// TODO (IE6 track bug 20)
// TODO (cthrash) We will need to get these values from the registry
// when we internationalize this product, so as to get sizing appropriate
// for the target locale.
// NOTE (johnv): Where did these old numbers come from?  The new ones now correspond to
// TwipsFromHtmlSize[2] defined above.
// static const int aiSizesInTwips[7] = { 100, 130, 160, 200, 240, 320, 480 };

// scale fonts up for TV
#ifdef NTSC
static const int aiSizesInTwips[7] = { 200, 240, 280, 320, 400, 560, 840 };
#else
static const int aiSizesInTwips[7] = { 151, 200, 240, 271, 360, 480, 720 };
#endif

int
EdUtil::ConvertHtmlSizeToTwips(int nHtmlSize)
{
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [1..7]
    nHtmlSize = max( 1, min( 7, nHtmlSize ) );

    return aiSizesInTwips[ nHtmlSize - 1 ];
}

int
EdUtil::ConvertTwipsToHtmlSize(int nFontSize)
{
    int nNumElem = ARRAY_SIZE(aiSizesInTwips);

    // Now convert the point size to size units used by HTML
    // Valid HTML font sizes ares [1..7]
    for(int i = 0; i < nNumElem; i++)
    {
        if(nFontSize <= aiSizesInTwips[i])
            break;
    }

    return i + 1;
}

#define LF          10
#define CR          13
#define FF          TEXT('\f')
#define TAB         TEXT('\t')
#define VT          TEXT('\v')
#define PS          0x2029

BOOL
EdUtil::IsWhiteSpace(TCHAR ch)
{
    return (    ch == L' '
             || InRange( ch, TAB, CR ));
}

//+---------------------------------------------------------------------------
//
//  Method:       CopyAttributes.
//
//  Synopsis:     Wrapper to IHTMLDocument2::mergeAttributes
//
//----------------------------------------------------------------------------
HRESULT
EdUtil::CopyAttributes(IHTMLElement * pSrcElement, IHTMLElement * pDestElement, BOOL fCopyId)
{
    HRESULT hr = E_POINTER;
    VARIANT var;
    SP_IHTMLElement3 spElement3;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fCopyId ? VARIANT_FALSE : VARIANT_TRUE; // if CopyID == TRUE, then don't preserve id!
    
    IFC(pDestElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->mergeAttributes(pSrcElement, &var));

Cleanup:
    RRETURN( hr );
}

HRESULT EdUtil::ReplaceElement( CEditorDoc      *pEditorDoc,
                                IHTMLElement    *pOldElement,
                                IHTMLElement    *pNewElement,
                                IMarkupPointer  *pUserStart,
                                IMarkupPointer  *pUserEnd)
{
    HRESULT        hr;
    IMarkupPointer *pStart = NULL;
    IMarkupPointer *pEnd = NULL;
    //
    // Set up markup pointers
    //

    if (pUserStart)
    {
        pStart = pUserStart;
        pStart->AddRef();
    }
    else
    {
        hr = THR(CreateMarkupPointer2(pEditorDoc, &pStart));
        if (FAILED(hr))
            goto Cleanup;
    }

    if (pUserEnd)
    {
        pEnd = pUserEnd;
        pEnd->AddRef();
    }
    else
    {
        hr = THR(CreateMarkupPointer2(pEditorDoc, &pEnd));
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Replace the element
    //

    hr = THR(pEnd->MoveAdjacentToElement(pOldElement, ELEM_ADJ_AfterEnd));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pStart->MoveAdjacentToElement(pOldElement, ELEM_ADJ_BeforeBegin));
    if (FAILED(hr))
        goto Cleanup;
    
    hr = THR(CopyAttributes(pOldElement, pNewElement, TRUE));
    if (FAILED(hr))
        goto Cleanup;
        
    hr = THR(InsertElement(pEditorDoc->GetMarkupServices(), pNewElement, 
pStart, pEnd));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pEditorDoc->GetMarkupServices()->RemoveElement(pOldElement));
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    RRETURN(hr);
}
//+====================================================================================
//
// Method: IsElementPositioned
//
// Synopsis: Does this element have a Relative/Absolute Position.
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::IsElementPositioned(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;

    IHTMLElement2 * pElement2 = NULL;
    IHTMLCurrentStyle * pCurStyle = NULL;
    BSTR bsPosition = NULL;
    
    BOOL fIsPosition = FALSE;

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pElement->QueryInterface( IID_IHTMLElement2, ( void** ) & pElement2 ));
    if ( hr )
        goto Cleanup;

    hr = THR( pElement2->get_currentStyle( & pCurStyle ));
    if ( hr || pCurStyle == NULL )
        goto Cleanup;

    hr = THR( pCurStyle->get_position( & bsPosition));
    if ( hr ) 
        goto Cleanup;

    if ( StrCmpIW(_T("absolute"), bsPosition ) == 0)
    {
        fIsPosition = TRUE;
    }
    else if ( StrCmpIW(_T("relative"), bsPosition ) == 0)
    {
        fIsPosition = TRUE;
    }

    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pElement2 );
    ReleaseInterface( pCurStyle );
    
    return ( fIsPosition );
}

BOOL
EdUtil::IsElementVisible(IHTMLElement *pElement)
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLCurrentStyle    spCurStyle;
    BSTR                    bsVisible = NULL;   
    BOOL                    fVisible = TRUE;

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pElement->QueryInterface( IID_IHTMLElement2, (void **)&spElement2 ));

    IFC( spElement2->get_currentStyle( &spCurStyle ) );
    if( spCurStyle == NULL )
        goto Cleanup;

    IFC( spCurStyle->get_visibility( &bsVisible ));

    if ( StrCmpIW(_T("hidden"), bsVisible ) == 0)
    {
        fVisible = FALSE;
    }
    
Cleanup:
    SysFreeString( bsVisible );
    
    return ( fVisible );
}

//+====================================================================================
//
// Method: IsElementSized
//
// Synopsis: Does this element have a width/height style.
//
//------------------------------------------------------------------------------------


HRESULT
EdUtil::IsElementSized(IHTMLElement* pElement, BOOL *pfSized)
{

    HRESULT hr;
    BSTR bstrSize = NULL;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    VARIANT varSize;
    BOOL fWidth = FALSE;
    BOOL fHeight = FALSE;
    VariantInit(&varSize);

    Assert(pfSized);
    Assert(pElement);

    *pfSized = FALSE;
    

    IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;

    IFC(spCurrStyle->get_width(&varSize));
    bstrSize = V_BSTR(&varSize);
    // (sramani) Temporary hack to compare the string for "auto" which is what will be returned by 
    // the OM for width and height of 0. This will go away when enums are exposed on a new CurrentStyle
    // object on the display pointer.
    fWidth = (V_VT(&varSize) == VT_BSTR) && bstrSize && *bstrSize && _tcscmp(bstrSize, _T("auto"));
    
    VariantClear(&varSize);
    IFC(spCurrStyle->get_height(&varSize));    
    bstrSize = V_BSTR(&varSize);
    // (sramani) Temporary hack to compare the string for "auto" which is what will be returned by 
    // the OM for width and height of 0. This will go away when enums are exposed on a new CurrentStyle
    // object on the display pointer.
    fHeight = (V_VT(&varSize) == VT_BSTR) && bstrSize && *bstrSize && _tcscmp(bstrSize, _T("auto"));
    
    *pfSized = fWidth || fHeight;

Cleanup:
    VariantClear(&varSize);
    return hr;
}

//+====================================================================================
//
// Method: Is1DElement
//
// Synopsis: Does this element a 1D Element.
//
//------------------------------------------------------------------------------------

HRESULT 
EdUtil::Is1DElement(IHTMLElement* pElement, BOOL* pf1D)
{
    BOOL b2D ;
    HRESULT hr = Is2DElement(pElement , &b2D ) ;
    if (!hr)
        *pf1D = !b2D ;
    return ( hr);
}

//+====================================================================================
//
// Method: Is2DElement
//
// Synopsis: Does this element a 2D Element.
// Return:
//       *pf2D = TRUE if the element is 2D positioned.
//       *pf2D = FALSE if the element is not 2D positioned.
//------------------------------------------------------------------------------------

HRESULT
EdUtil::Is2DElement(IHTMLElement* pElement, BOOL* pf2D)
{
    HRESULT hr = S_OK;

    IHTMLElement2 * pElement2 = NULL;
    IHTMLCurrentStyle * pCurStyle = NULL;
    BSTR bsPosition = NULL;
    
    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC(pElement->QueryInterface( IID_IHTMLElement2, ( void** ) & pElement2 ));
    IFC (pElement2->get_currentStyle( & pCurStyle ));
    if ( pCurStyle == NULL )
        goto Cleanup;

    IFC ( pCurStyle->get_position( & bsPosition));

    *pf2D = (StrCmpIW(_T("absolute"), bsPosition ) == 0);
    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pElement2 );
    ReleaseInterface( pCurStyle );
    
    return ( hr);
}

///////////////////////////////////////////////////////////////////////////////
//
// EdUtil::Make1DElement
//
// Set the given HTML element to layout in the flow.  Return S_OK if all goes
// well; .
//

HRESULT 
EdUtil::Make1DElement(IHTMLElement* pElement)
{
    SP_IHTMLStyle pStyle ;
    HRESULT hr = S_OK;
    VARIANT var_zIndex;
    
    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pElement->get_style(&pStyle);
    if (pStyle == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }


    VariantInit(&var_zIndex);
    var_zIndex.vt = VT_I4;
    var_zIndex.lVal = 0; 
    IFC (pStyle->put_zIndex(var_zIndex));
    IFC (pStyle->removeAttribute(L"position", 0, NULL));

Cleanup :
    VariantClear( & var_zIndex );
    return (hr);
}

///////////////////////////////////////////////////////////////////////////////
//
// EdUtil::Make2DElement
//
// Set the given HTML element to absolute position .  Return S_OK if all goes well; .
////////////////////////////////////////////////////////////////////////////////

HRESULT 
EdUtil::Make2DElement(IHTMLElement* pElement)
{
    SP_IHTMLStyle   pStyle ;
    IHTMLStyle2* pStyle2 = NULL;
    HRESULT hr = S_OK;

    BSTR bsPosition = SysAllocString( _T("absolute"));
    if (bsPosition == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if( pElement == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
 
    IFC(pElement->get_style(&pStyle ));

    if (pStyle == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pStyle->QueryInterface( IID_IHTMLStyle2, (void**) & pStyle2));
    
    if ( pStyle2 == NULL )
    {
        hr = S_FALSE ;
        goto Cleanup;
    }
    IFC ( pStyle2->put_position(bsPosition));   
    
Cleanup:
    SysFreeString( bsPosition );
    ReleaseInterface( pStyle2 );
    RRETURN (hr);
}


//+====================================================================================
//
// Method: MakeAbsolutePosition
// Synopsis: Make this Absolute Positioned Element.
//
//------------------------------------------------------------------------------------

HRESULT 
EdUtil::MakeAbsolutePosition(IHTMLElement* pElement, BOOL bTrue)
{
    HRESULT hr = S_OK;
    
    hr = ( bTrue ?  Make2DElement(pElement) : Make1DElement(pElement) ); 
     
    RRETURN (hr);
}

BOOL 
EdUtil::IsShiftKeyDown()
{
    return (GetKeyState(VK_SHIFT) & 0x8000) ;
}

BOOL 
EdUtil::IsControlKeyDown()
{
    return (GetKeyState(VK_CONTROL) & 0x8000) ;
}


HRESULT EdUtil::MoveAdjacentToElementHelper(IMarkupPointer *pMarkupPointer, IHTMLElement *pElement, ELEMENT_ADJACENCY elemAdj)
{
    HRESULT hr;
    
    hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, elemAdj));
    if (hr)
    {
        if (elemAdj == ELEM_ADJ_AfterBegin)
            hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin));
        else if (elemAdj == ELEM_ADJ_BeforeEnd)
            hr = THR(pMarkupPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd));
    }
    RRETURN(hr);
}

HRESULT
EdUtil::FindBlockLimit(
    CEditorDoc          *pEditorDoc, 
    Direction           direction, 
    IMarkupPointer      *pPointer, 
    IHTMLElement        **ppElement, 
    MARKUP_CONTEXT_TYPE *pContext,
    BOOL                fExpanded,
    BOOL                fLeaveInside,
    BOOL                fCanCrossLayout)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                fFoundExitScope = FALSE;
    BOOL                bLayout = FALSE;

    if (ppElement)
        *ppElement = NULL; 

    // Find the block
    for (;;)
    {
        // Move to next scope change (note we only get enter/exit scope for blocks)
        IFR( BlockMove( pEditorDoc, pPointer, direction, TRUE, &context, &spElement) );

        switch (context)
        {
            case CONTEXT_TYPE_ExitScope:
                if (!spElement || !fExpanded)
                    goto FoundBlockLimit; // went too far
                
                // Make sure we didn't exit the body
                IFR( pEditorDoc->GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_BODY)
                {
                    fLeaveInside = FALSE; // force adjustment
                    goto FoundBlockLimit;
                }

                // Check for flow layout
                IFR(IsBlockOrLayoutOrScrollable(spElement, NULL, &bLayout));
                if (bLayout)
                    goto FoundBlockLimit;
                
                fFoundExitScope = TRUE;                
                break;

            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                if (fFoundExitScope)
                    goto FoundBlockLimit;
                break;

            case CONTEXT_TYPE_EnterScope:
                Assert(IsBlockCommandLimit( pEditorDoc->GetMarkupServices(), spElement, context)); 
                IFR(IsBlockOrLayoutOrScrollable(spElement, NULL, &bLayout));
                goto FoundBlockLimit;
        }
    }
    
FoundBlockLimit:
    
    if (fLeaveInside || (bLayout && !fCanCrossLayout))
        IFR( BlockMoveBack( pEditorDoc, pPointer, direction, TRUE, pContext, ppElement) );    

    RRETURN(hr);
}

BOOL 
EdUtil::IsBlockCommandLimit( IMarkupServices* pMarkupServices, 
                             IHTMLElement *pElement, 
                             MARKUP_CONTEXT_TYPE context) 
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BOOL            fBlock, fLayout;

    switch (context)
    {
        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_Text:
            return FALSE;
    }

    //
    // Check exceptions
    //
    
    IFR( pMarkupServices->GetElementTagId(pElement, &tagId) );
    switch (tagId)     
    {
        case TAGID_BUTTON:
        case TAGID_COL:
        case TAGID_COLGROUP:
        case TAGID_TBODY:
        case TAGID_TFOOT:
        case TAGID_TH:
        case TAGID_THEAD:
        case TAGID_TR:
            return FALSE;            
    }

    //
    // Otherwise, return IsBlockElement || IsLayoutElement
    //
    
    IFR(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    return (fBlock || fLayout);    
}

HRESULT 
EdUtil::BlockMove(
    CEditorDoc              *pEditorDoc,
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    HRESULT                 hr;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;
    SP_IMarkupPointer       spPointer;

    Assert(direction == LEFT || direction == RIGHT);

    if (!fMove)
    {
        IFR( CreateMarkupPointer2(pEditorDoc, &spPointer) );
        IFR( spPointer->MoveToPointer(pMarkupPointer) );
        
        pMarkupPointer = spPointer; // weak ref 
    }
    
    for (;;)
    {
        if (direction == LEFT)
            IFC( pMarkupPointer->Left( TRUE, &context, &spElement, NULL, NULL) )
        else
            IFC( pMarkupPointer->Right( TRUE, &context, &spElement, NULL, NULL) );

        switch (context)
        {
            case CONTEXT_TYPE_Text:
                goto Cleanup; // done

            case CONTEXT_TYPE_EnterScope:
                if (IsIntrinsic(pEditorDoc->GetMarkupServices(), spElement))
                {
                    if (direction == LEFT)
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement
, ELEM_ADJ_BeforeBegin ) )
                    else
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement
, ELEM_ADJ_AfterEnd ) ); 

                    continue;    
                }
                // fall through
                
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_NoScope:
                        if (!spElement || IsBlockCommandLimit( pEditorDoc->GetMarkupServices(), spElement, context))
                    goto Cleanup; // done;
                break;  

            default:
                hr = E_FAIL; // CONTEXT_TYPE_None
                goto Cleanup;
        }
    }
    
Cleanup:
    if (ppElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppElement = spElement;
            if (*ppElement)
                (*ppElement)->AddRef();
        }
        else
        {
            *ppElement = NULL;
        }
    }
        
    if (pContext)
    {
        *pContext = (SUCCEEDED(hr)) ? context : CONTEXT_TYPE_None;
    }    

    RRETURN(hr);
}

HRESULT 
EdUtil::BlockMoveBack(
    CEditorDoc              *pEditorDoc,
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    if (direction == RIGHT)
    {
        RRETURN(BlockMove( pEditorDoc, pMarkupPointer, LEFT, fMove, pContext, ppElement));
    }
    else
    {
        Assert(direction == LEFT);
        RRETURN(BlockMove(pEditorDoc, pMarkupPointer, RIGHT, fMove, pContext, ppElement));
    }
}

BOOL
EdUtil::IsIntrinsic( IMarkupServices* pMarkupServices,
                     IHTMLElement* pIHTMLElement )
{                     
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fIntrinsic = FALSE;
    
    IFC( pMarkupServices->GetElementTagId( pIHTMLElement, &eTag ));

    switch( eTag )
    {
        case TAGID_BUTTON:
        case TAGID_TEXTAREA:
        case TAGID_INPUT:
//        case TAGID_HTMLAREA:
        case TAGID_FIELDSET:
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_SELECT:
            fIntrinsic = TRUE;
            break;

        default:
            fIntrinsic = IsMasterElement( pMarkupServices, pIHTMLElement) == S_OK ;            
    }
    
Cleanup:
    return fIntrinsic;
}   

//+==============================================================================
//
//  Method:     MovePointerToText
//
//  Synopsis:   This routine moves the passed in markup pointer until in the 
//              specified direction until it hits either text or a layout 
//              boundary.
//
//+==============================================================================

HRESULT
EdUtil::MovePointerToText( 
    CEditorDoc *        pEditorDoc,
    IMarkupPointer *    pOrigin, 
    Direction           eDir,
    IMarkupPointer *    pBoundary,
    BOOL *              pfHitText,
    BOOL fStopAtBlock ) 
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fDone = FALSE;
    INT                 iResult = 0;
    ELEMENT_TAG_ID      eTag;
    LONG                cch = 1;
    
    // Interface Pointers
    IHTMLElement      * pHTMLElement = NULL;
    IMarkupPointer    * pTemp = NULL;

    *pfHitText = FALSE;

    hr = THR( CreateMarkupPointer2( pEditorDoc, & pTemp ) );
    if (! hr)   hr = THR( pTemp->MoveToPointer( pOrigin ) );
    if (hr)
        goto Cleanup;
    
    // Rule #2 - walk in the appropriate direction looking for text or a noscope.
    // If we happen to enter the scope of another element, fine. If we try to leave
    // the scope of an element, bail.
    
    while ( ! fDone )
    {
        ClearInterface( & pHTMLElement );

        //
        // Check to see if we hit the boundary of our search
        //
        // If the pointer is beyond the boundary, fall out
        // boundary left of pointer =  -1
        // boundary equals pointer =    0
        // boundary right of pointer =  1
        //
        
        IGNORE_HR( OldCompare( pBoundary, pTemp , &iResult ));

        if((     eDir == LEFT && iResult > -1 ) 
            || ( eDir == RIGHT && iResult < 1 ))
        {
            goto Cleanup;    // this is okay since CR_Boundary does not move the pointer
        }
        
        //    
        // Move in the appropriate direction...
        //
        
        if( eDir == LEFT )
            hr = THR( pTemp->Left( TRUE, & ct, & pHTMLElement, &cch, NULL ) );
        else
            hr = THR( pTemp->Right(TRUE, & ct, & pHTMLElement, &cch, NULL ) );
        if( hr )
            goto Cleanup;
            
        switch( ct )
        {
            case CONTEXT_TYPE_Text:

                //
                // Hit text - done
                //
                
                *pfHitText = TRUE;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_NoScope:

                //
                // Only stop if we hit a renderable (layout-ness) noscope
                // TODO : figure out if this is a glyph boundary
                //
                
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;
                    BOOL fIsBlock = FALSE;
                    
                    IFC( pEditorDoc->GetMarkupServices()->GetElementTagId( pHTMLElement, &eTag ));
                    IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, &fIsBlock, &fHasLayout));

                    if( fHasLayout || 
                        ( fIsBlock && fStopAtBlock ) || 
                        eTag == TAGID_BR )
                    {
                        *pfHitText = TRUE;
                        fDone = TRUE;
                    }
                }
                
                break;
            
            case CONTEXT_TYPE_EnterScope:
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;

                    //
                    // Only stop for intrinsics, otherwise pass on through
                    // TODO: Figure out if this is a glyph boundary
                    //
                    //  Also, it seems wrong to not stop for layout boundaries
                    //
                    BOOL fIntrinsic  = IsIntrinsic( pEditorDoc->
GetMarkupServices(), pHTMLElement);
                    if ( fIntrinsic )
                    {
                        *pfHitText = fDone;
                        fDone = TRUE;
                    }
                    else
                    {
                        IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, NULL, &fHasLayout));
                        if (fHasLayout)
                        {
                            *pfHitText = fDone;
                            fDone = TRUE;
                        }
                    }

                }

                break;

            // TODO : Figure out if the range needs this or if we don't need this

            case CONTEXT_TYPE_ExitScope:
                if( pHTMLElement )
                {
                    BOOL fHasLayout = FALSE;
                    BOOL fIsBlock = FALSE;
                    
                    IFC( pEditorDoc->GetMarkupServices()->GetElementTagId( pHTMLElement, &eTag ));
                    IFC(IsBlockOrLayoutOrScrollable(pHTMLElement, &fIsBlock, &
fHasLayout));

                    if( fHasLayout || 
                      ( fIsBlock && fStopAtBlock ) || 
                      eTag == TAGID_BR )
                    {
                        fDone = TRUE;
                    }
                }
                
                break;                 

            case CONTEXT_TYPE_None:
                fDone = TRUE;
                break;
        }        
    }

    //
    // If we found text, move our pointer
    //
    
    if( *pfHitText )
    {
        //
        // We have inevitably gone one move too far, back up one move
        //
    
        if( eDir == LEFT )
            hr = THR( pTemp->Right(TRUE, & ct, NULL, &cch, NULL ) );
        else
            hr = THR( pTemp->Left( TRUE, & ct, NULL, &cch, NULL ) );
        if( hr )
            goto Cleanup;
            
        hr = THR( pOrigin->MoveToPointer( pTemp ));
    }
    
Cleanup:
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pTemp );
    RRETURN( hr );
}


HRESULT 
EdUtil::FindListContainer( IMarkupServices *pMarkupServices,
                           IHTMLElement    *pElement,
                           IHTMLElement    **ppListContainer )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;    
    BOOL                            bLayout;

    *ppListContainer = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (IsListContainer(tagId)) // found container
        {
            *ppListContainer = spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            

        IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &bLayout));
        if (bLayout)
            return S_OK; // done - don't cross layout
            
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
}

BOOL
EdUtil::HasNonBodyContainer( IMarkupServices *pMarkupServices,
                             IHTMLElement    *pElement )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;    

    spCurrentElement = pElement;
    do
    {
        IFC( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (TAGID_INPUT == tagId ||
            TAGID_TEXTAREA == tagId ||
            TAGID_BUTTON == tagId ||
            TAGID_LEGEND == tagId ||
            TAGID_MARQUEE == tagId)
        {
            return TRUE;
        }            

        IFC( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

Cleanup:
    return FALSE;        
}

HRESULT 
EdUtil::FindListItem( IMarkupServices *pMarkupServices,
                      IHTMLElement    *pElement,
                      IHTMLElement    **ppListContainer )
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;
    BOOL                            bLayout;

    *ppListContainer = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (IsListItem(tagId)) // found container
        {
            *ppListContainer = spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            
            
        IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &bLayout));
        if (bLayout)
            return S_OK; // done - don't cross layout
            
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
}

HRESULT 
EdUtil::InsertBlockElement(
    IMarkupServices *pMarkupServices, 
    IHTMLElement    *pElement, 
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd, 
    IMarkupPointer  *pCaret)
{
    HRESULT             hr;
    BOOL                bAdjustStart = FALSE;
    BOOL                bAdjustEnd = FALSE;
    

    //
    // Do we need to adjust the pointer after insiertion?
    //

    IFR( pCaret->IsEqualTo(pStart, &bAdjustStart) );    
    if (!bAdjustStart)
    {
        IFR( pCaret->IsEqualTo(pEnd, &bAdjustEnd) );    
    }

    //
    // Insert the element
    //
    
    IFR( InsertElement(pMarkupServices, pElement, pStart, pEnd) );

    //
    // Fixup the pointer
    //
    
    if (bAdjustStart)
    {
        IFR( pCaret->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterBegin) );
    }
    else if (bAdjustEnd)
    {
        IFR( pCaret->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeEnd) );
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NextEventTime
//
//  Synopsis:   Returns a value which can be use to determine when a given
//              number of milliseconds has passed.
//
//  Arguments:  [ulDelta] -- Number of milliseconds after which IsTimePassed
//                           will return TRUE.
//
//  Returns:    A timer value.  Guaranteed not to be zero.
//
//  Notes:      Due to the algorithm used in IsTimePassed, [ulDelta] cannot
//              be greater than ULONG_MAX/2.
//
//----------------------------------------------------------------------------

ULONG
EdUtil::NextEventTime(ULONG ulDelta)
{
    ULONG ulCur;
    ULONG ulRet;

    Assert(ulDelta < ULONG_MAX/2);

    ulCur = GetTickCount();

    if ((ULONG_MAX - ulCur) < ulDelta)
        ulRet = ulDelta - (ULONG_MAX - ulCur);
    else
        ulRet = ulCur + ulDelta;

    if (ulRet == 0)
        ulRet = 1;

    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsTimePassed
//
//  Synopsis:   Returns TRUE if the current time is later than the given time.
//
//  Arguments:  [ulTime] -- Timer value returned from NextEventTime().
//
//  Returns:    TRUE if the current time is later than the given time.
//
//----------------------------------------------------------------------------

BOOL
EdUtil::IsTimePassed(ULONG ulTime)
{
    ULONG ulCur = GetTickCount();

    if ((ulCur > ulTime) && (ulCur - ulTime < ULONG_MAX/2))
        return TRUE;

    return FALSE;
}


            
BOOL
EdUtil::SameElements(
    IHTMLElement *      pElement1,
    IHTMLElement *      pElement2 )
{
    HRESULT hr = S_OK;
    BOOL fEqual = FALSE;

    IObjectIdentity * pId1 = NULL;

    if( pElement1 == NULL || pElement2 == NULL )
        goto Cleanup;
        
    IFC( pElement1->QueryInterface( IID_IObjectIdentity , (LPVOID *) & pId1 ));
    hr = pId1->IsEqualObject( pElement2 );
    fEqual = ( hr == S_OK );
    
Cleanup:
    ReleaseInterface( pId1 );
    return fEqual;
}


//+====================================================================================
//
// Method: EquivalentElements
//
// Synopsis: Test elements for 'equivalency' - ie if they are the same element type,
//           and have the same class, id , and style.
//
//------------------------------------------------------------------------------------

BOOL 
EdUtil::EquivalentElements( 
            IMarkupServices* pMarkupServices, IHTMLElement* pIElement1, IHTMLElement* pIElement2 )
{
    ELEMENT_TAG_ID eTag1 = TAGID_NULL;
    ELEMENT_TAG_ID eTag2 = TAGID_NULL;
    BOOL fEquivalent = FALSE;
    HRESULT hr = S_OK;
    IHTMLStyle * pIStyle1 = NULL;
    IHTMLStyle * pIStyle2 = NULL;
    BSTR id1 = NULL;
    BSTR id2 = NULL;
    BSTR class1 = NULL;
    BSTR class2 = NULL;
    BSTR style1 = NULL;
    BSTR style2 = NULL;
    
    IFC( pMarkupServices->GetElementTagId( pIElement1, & eTag1 ));
    IFC( pMarkupServices->GetElementTagId( pIElement2, & eTag2 ));

    //
    // Compare Tag Id's
    //
    if ( eTag1 != eTag2 )
        goto Cleanup;

    //
    // Compare Id's
    //
    IFC( pIElement1->get_id( & id1 ));
    IFC( pIElement2->get_id( & id2 ));

    if ((( id1 != NULL ) || ( id2 != NULL )) && 
        ( StrCmpIW( id1, id2) != 0))
        goto Cleanup;

    //
    // Compare Class
    //
    IFC( pIElement1->get_className( & class1 ));
    IFC( pIElement2->get_className( & class2 ));

        
    if ((( class1 != NULL ) || ( class2 != NULL )) &&
        ( StrCmpIW( class1, class2) != 0 ) )
        goto Cleanup;

    //
    // Compare Style's
    //        
    IFC( pIElement1->get_style( & pIStyle1 ));
    IFC( pIElement2->get_style( & pIStyle2 ));
    IFC( pIStyle1->toString( & style1 ));
    IFC( pIStyle2->toString( & style2 ));
       
    if ((( style1 != NULL ) || ( style2 != NULL )) &&
        ( StrCmpIW( style1, style2) != 0 ))
        goto Cleanup;

    fEquivalent = TRUE;        
Cleanup:
    SysFreeString( id1 );
    SysFreeString( id2 );
    SysFreeString( class1 );
    SysFreeString( class2 );
    SysFreeString( style1 );
    SysFreeString( style2 );
    ReleaseInterface( pIStyle1 );
    ReleaseInterface( pIStyle2 );
    
    AssertSz(!FAILED(hr), "Unexpected failure in Equivalent Elements");

    return ( fEquivalent );
}

HRESULT 
EdUtil::InsertElement(IMarkupServices *pMarkupServices, IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT                         hr;
    BOOL                            bBlock, bLayout;
    ELEMENT_TAG_ID                  tagId;
    
    IFR( pMarkupServices->InsertElement(pElement, pStart, pEnd) );

    //
    // Set additional attributes
    //

    IFR(IsBlockOrLayoutOrScrollable(pElement, &bBlock, &bLayout));

    if (bBlock && !bLayout)
    {
        IFR( pMarkupServices->GetElementTagId(pElement, &tagId) );
        if (!IsListContainer(tagId) && tagId != TAGID_LI)
        {
            SP_IHTMLElement3 spElement3;
            IFR( pElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
            IFR( spElement3->put_inflateBlock( VARIANT_TRUE ) );
        }
    }

    return S_OK;
}

HRESULT 
EdUtil::FindTagAbove( IMarkupServices *pMarkupServices,
                      IHTMLElement    *pElement,
                      ELEMENT_TAG_ID  tagIdGoal,
                      IHTMLElement    **ppElement,
                      BOOL            fStopAtLayout)
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    ELEMENT_TAG_ID                  tagId;
    BOOL                            fSite;
    
    *ppElement = NULL;

    spCurrentElement = pElement;
    do
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &tagId) ); 

        if (tagId == tagIdGoal) // found container
        {
            *ppElement= spCurrentElement;
            spCurrentElement->AddRef();
            break;
        }            

        if (fStopAtLayout)
        {
            IFR(IsBlockOrLayoutOrScrollable(spCurrentElement, NULL, &fSite));
            if (fSite)
                break;                
        }
        
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    RRETURN(hr);        
    
}


//
// Review-2000/07/25-zhenbinx: 
//      We should make sure this func is always in sync with Trident!!!
//
#define lcidKashmiri 0x0860
#define lcidUrduIndia     0x0820
BOOL
EdUtil::IsBidiEnabled(VOID)
{
    HKL aHKL[32];
    UINT uKeyboards = GetKeyboardLayoutList(32, aHKL);
    // check all keyboard layouts for existance of a RTL language.
    // bounce out when the first one is encountered.
    for(UINT i = 0; i < uKeyboards; i++)
    {
        LCID lcid = LOWORD(aHKL[i]);
        switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
        {
            case LANG_ARABIC:
            case LANG_FARSI:
            case LANG_HEBREW:
            case LANG_KASHMIRI:
                if (lcid == lcidKashmiri)
                    return FALSE;
            case LANG_PASHTO:
            case LANG_SINDHI:
            case LANG_SYRIAC:
            case LANG_URDU:
                if (lcid == lcidUrduIndia)
                    return FALSE;
            case LANG_YIDDISH:
                return TRUE;
        }
    }

    /*
    //
    // We don't want this as of now. 
    //
    {
        //
        // If there is no Bidi keyboard present. Check to see
        // if Bidi is enabled (Mirroring API enabled)
        // Should we check for existence of Bidi language pack
        // instead???
        //
        OSVERSIONINFOA osvi;
        osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);

        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion >= 5)
        {
            // NT 5
            s_fEnabled = TRUE;
        }
        else if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId &&
                 (osvi.dwMajorVersion > 4 || osvi.dwMajorVersion == 4 && osvi.dwMinorVersion >= 10)
                )
        {
            if (::GetSystemMertics(SM_MIDEASTENABLED))
            {
                s_fEnabled = TRUE;
            }
        }
    }
    */
    return FALSE;
}



BOOL 
EdUtil::IsRtfConverterEnabled(IDocHostUIHandler *pDocHostUIHandler)
{
    BOOL   fConvf = FALSE;
#ifndef NO_RTF
    static TCHAR pchKeyPath[] = _T("Software\\Microsoft\\Internet Explorer");

    CPINFO cpinfo;
    LONG   lRet;
    HKEY   hKeyRoot = NULL;
    HKEY   hKeySub  = NULL;
    DWORD  dwConvf = RTFCONVF_ENABLED;
    DWORD  dwType;
    DWORD  dwData;
    DWORD  dwSize = sizeof(DWORD);
    TCHAR *pstr = NULL;

    if (pDocHostUIHandler)
        pDocHostUIHandler->GetOptionKeyPath(&pstr, 0);

    if (!pstr)
        pstr = pchKeyPath;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, pstr, 0, KEY_READ, &hKeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Cleanup;

    lRet = RegOpenKeyEx(hKeyRoot, NULL, 0, KEY_READ, &hKeySub);
    if (lRet != ERROR_SUCCESS)
        goto Cleanup;

    Assert(hKeySub != hKeyRoot);
    
    lRet = RegQueryValueEx(hKeySub, _T("RtfConverterFlags"), 0, &dwType, (BYTE*)&dwData, &dwSize);
    if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
        dwConvf = dwData;
    //
    // Rtf conversions can be disabled on an sbcs-dbcs basis, or even
    // completely.  See the RTFCONVF flags in formkrnl.hxx.
    //
    fConvf = (dwConvf & RTFCONVF_ENABLED) &&
             ((dwConvf & RTFCONVF_DBCSENABLED) ||
              (GetCPInfo(GetACP(), &cpinfo) && cpinfo.MaxCharSize == 1));

Cleanup:
    if (pstr != pchKeyPath)
        CoTaskMemFree(pstr);

    if (hKeySub)
        RegCloseKey(hKeySub);

    if (hKeyRoot)
        RegCloseKey(hKeyRoot);
#endif

    return fConvf;
}

HRESULT 
EdUtil::IsBlockOrLayoutOrScrollable(IHTMLElement* pIElement, BOOL *pfBlock, BOOL *pfLayout, BOOL *pfScrollable)
{
    HRESULT hr;
    VARIANT_BOOL fBlock = VB_FALSE;
    VARIANT_BOOL fLayout = VB_FALSE;
    BOOL fScrollable = FALSE;
    BSTR bstrDisplay = NULL;
    BSTR bstrOverflow = NULL;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    SP_IHTMLCurrentStyle2 spCurrStyle2;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;

    IFC( spCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&spCurrStyle2) );

    if (pfBlock)
    {
        IFC( spCurrStyle2->get_isBlock(&fBlock) );
    }

    if (pfLayout || pfScrollable)
    {
        IFC(spCurrStyle2->get_hasLayout(&fLayout));
    }

    if (pfScrollable)
    {
        IFC( spCurrStyle->get_overflow(&bstrOverflow) );
        if (_tcscmp(bstrOverflow, _T("scroll")) == 0)
        {
            fScrollable = TRUE;
        }
        else if (fLayout && _tcscmp(bstrOverflow, _T("auto")) == 0)
        {
            LONG lClientHeight;
            LONG lScrollHeight;

            IFC( spElement2->get_clientHeight(&lClientHeight) );
            IFC( spElement2->get_scrollHeight(&lScrollHeight) );

            fScrollable = (lClientHeight < lScrollHeight);
        }
    }
    
Cleanup:
    if (pfBlock)
        *pfBlock = fBlock ? TRUE : FALSE;

    if (pfScrollable)
        *pfScrollable = fScrollable;

    if (pfLayout)
        *pfLayout = fLayout ? TRUE : FALSE;
    
    SysFreeString(bstrDisplay);
    SysFreeString(bstrOverflow);
    RRETURN(hr);
}

HRESULT
EdUtil::GetScrollingElement(IMarkupServices *pMarkupServices, IMarkupPointer *pPosition, IHTMLElement *pIBoundary, IHTMLElement **ppElement, BOOL fTreatInputsAsScrollable /*=FALSE*/)
{
    HRESULT hr;
    BOOL fScrollable = FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spParent;
    SP_IObjectIdentity spIdent;

    *ppElement = NULL;

    if (pIBoundary)
        IFC(pIBoundary->QueryInterface(IID_IObjectIdentity, (void **)&spIdent));
    IFC(pPosition->CurrentScope(&spElement));

    if (fTreatInputsAsScrollable)
    {
        ELEMENT_TAG_ID  eTag;

        IFC( pMarkupServices->GetElementTagId( spElement, &eTag ) );
        if (eTag == TAGID_INPUT)
        {
            *ppElement = spElement;
            spElement->AddRef();
            goto Cleanup;
        }
    }

    while( spElement )
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, NULL, &fScrollable));
        if (fScrollable)
        {
            *ppElement = spElement;
            spElement->AddRef();
            break;
        }

        //  Make sure we do not go beyond our boundary, if we are given one.
        if ( spIdent )
        {
            hr = THR(spIdent->IsEqualObject(spElement));
            if (hr == S_OK)
                break;
        }

        IFC(GetParentElement(pMarkupServices, spElement, &spParent));
        spElement = spParent;
    }

Cleanup:
    RRETURN(hr);
}




BOOL 
EdUtil::IsTablePart( ELEMENT_TAG_ID eTag )
{
    return ( ( eTag == TAGID_TD ) ||
       ( eTag == TAGID_TR ) ||
       ( eTag == TAGID_TBODY ) || 
       ( eTag == TAGID_TFOOT ) || 
       ( eTag == TAGID_TH ) ||
       ( eTag == TAGID_THEAD ) ||
       ( eTag == TAGID_CAPTION ) ||
       ( eTag == TAGID_TC )  ||        
       ( eTag == TAGID_COL ) || 
       ( eTag == TAGID_COLGROUP )); 
}

//+----------------------------------------------------------------------------
//
//  Functions:  ParentElement
//
//  Synopsis:   Gets parent element using param as in/out.
//
//-----------------------------------------------------------------------------
HRESULT
EdUtil::ParentElement(IMarkupServices *pMarkupServices, IHTMLElement **ppElement)
{
    HRESULT         hr;
    IHTMLElement    *pOldElement;
    
    Assert(ppElement && *ppElement);

    pOldElement = *ppElement;
    hr = THR( GetParentElement(pMarkupServices, pOldElement, ppElement) );
    pOldElement->Release();

    RRETURN(hr);
}


HRESULT 
EdUtil::CopyPointerGravity(IDisplayPointer *pDispPointerSource, IMarkupPointer *pPointerTarget)
{
    HRESULT hr;
    POINTER_GRAVITY eGravity;

    IFC( pDispPointerSource->GetPointerGravity(&eGravity) );
    IFC( pPointerTarget->SetGravity(eGravity) );

Cleanup:
    RRETURN(hr);
}    

HRESULT 
EdUtil::CopyPointerGravity(IDisplayPointer *pDispPointerSource, IDisplayPointer *pDispPointerTarget)
{
    HRESULT hr;
    POINTER_GRAVITY eGravity;

    IFC( pDispPointerSource->GetPointerGravity(&eGravity) );
    IFC( pDispPointerTarget->SetPointerGravity(eGravity) );

Cleanup:
    RRETURN(hr);
}    

HRESULT
EdUtil::IsLayout( IHTMLElement* pIElement )
{

    HRESULT hr ;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLCurrentStyle spCurrStyle;
    SP_IHTMLCurrentStyle2 spCurrStyle2;
    VARIANT_BOOL fLayout = VB_FALSE;
    
    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurrStyle));
    if (!spCurrStyle)
        goto Cleanup;    

    IFC(spCurrStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&spCurrStyle2));
    IFC(spCurrStyle2->get_hasLayout(&fLayout));

    hr = fLayout ? S_OK : S_FALSE ; 

Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT
EdUtil::GetLayoutElement(IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement)
{
    HRESULT hr = S_OK ;
    SP_IHTMLElement spCurElement ;
    SP_IHTMLElement spNextElement;
    BOOL fLayout = FALSE;
    
    Assert( pIElement && ppILayoutElement );
    
    ReplaceInterface( & spCurElement,(IHTMLElement*) pIElement);

    fLayout = IsLayout( spCurElement) == S_OK ;
    
    while( ! fLayout )
    {
        IFC( GetParentElement(pMarkupServices, spCurElement, &spNextElement) );
        if ( ! spNextElement.IsNull() )
        {
            spCurElement = (IHTMLElement*) spNextElement ;
            fLayout = IsLayout( spCurElement) == S_OK ;
        }   
        else
            break;
    }

    if ( fLayout )
    {
        *ppILayoutElement = spCurElement;
        (*ppILayoutElement)->AddRef();
    }
    else
    {
        hr = S_FALSE;
    }
    
Cleanup:
    RRETURN1( hr , S_FALSE );
}


HRESULT
EdUtil::GetParentLayoutElement(IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement)
{
    HRESULT hr;
    SP_IHTMLElement spCurLayout;
    SP_IHTMLElement spParentLayout;
    
    Assert( pIElement && ppILayoutElement );
    
    IFHRC( GetLayoutElement( pMarkupServices, pIElement, &spCurLayout)); 
    IFC( GetParentElement(pMarkupServices, spCurLayout, &spParentLayout) );
    if ( ! spParentLayout.IsNull() ) 
    {
        spCurLayout = (IHTMLElement*) spParentLayout ;
        IFHRC( GetLayoutElement( pMarkupServices, spCurLayout, & spParentLayout ));    

        Assert( ! spParentLayout.IsNull() && IsLayout( spParentLayout) == S_OK );    
        *ppILayoutElement = spParentLayout;
        (*ppILayoutElement)->AddRef();
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr , S_FALSE);
}

HRESULT
EdUtil::BecomeCurrent( IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement3 spElement3;
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: fire Events
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnEvent(wchar_t *pStrEvent, IHTMLElement* pIElement, BOOL fIsContextEditable)
{
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL fRet = VB_TRUE;
   
    if ( pIElement && fIsContextEditable )
    {
        IGNORE_HR(pIElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IGNORE_HR(spElement3->fireEvent(pStrEvent, NULL, &fRet));
    }
    return !!fRet;
}



//+====================================================================================
//
// Method: fire Events
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireEvent(wchar_t *pStrEvent, IHTMLElement* pIElement )
{
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL fRet = VB_TRUE;
   
    if ( pIElement  )
    {
        IGNORE_HR(pIElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IGNORE_HR(spElement3->fireEvent(pStrEvent, NULL, &fRet));
    }
    return !!fRet;
}

//+====================================================================================
//
// Method: fire On Before Copy
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnBeforeCopy(IHTMLElement* pIElement)
{
     return FireEvent(_T("onbeforecopy"), pIElement);
}

//+====================================================================================
//
// Method: fire On Before Cut
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnBeforeCut(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onbeforecut"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before Cut
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnCut(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("oncut"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before EditFocus
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL
EdUtil::FireOnBeforeEditFocus( IHTMLElement* pIElement , BOOL fIsParentContextEditable )
{
   return FireOnEvent(_T("onbeforeeditfocus"), pIElement, fIsParentContextEditable);
}    

//+====================================================================================
//
// Method: fire On SelectStart
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnSelectStart(IHTMLElement* pIElement)
{
    return FireEvent(_T("onselectstart"), pIElement );
}

//+====================================================================================
//
// Method: fire On Control Selection 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
    EdUtil::FireOnControlSelect(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireEvent(_T("oncontrolselect"), pIElement );
}

//+====================================================================================
//
// Method: fire On Resize
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResize(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresize"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire while its moving
//
// Synopsis:
//
//------------------------------------------------------------------------------------

BOOL 
EdUtil::FireOnMove(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmove"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On Before Resizing starts 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResizeStart(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresizestart"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On after resizing is done
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnResizeEnd(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onresizeend"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On move starting 
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnMoveStart(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmovestart"), pIElement, fIsContextEditable);
}

//+====================================================================================
//
// Method: fire On move ending
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
EdUtil::FireOnMoveEnd(IHTMLElement* pIElement , BOOL fIsContextEditable)
{
    return FireOnEvent(_T("onmoveend"), pIElement, fIsContextEditable);
}

HRESULT
EdUtil::IsEditable( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbEditable ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_isContentEditable( & vbEditable ));

    hr = vbEditable == VB_TRUE ? S_OK : S_FALSE;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsParentEditable(IMarkupServices *pMarkupServices,  IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spParentElement = pIElement;

    IFC( GetParentElement(pMarkupServices, pIElement, &spParentElement ));
    if( spParentElement )
    {
        hr = THR( IsEditable( spParentElement ));
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsMasterParentEditable(IMarkupServices *pMarkupServices,  IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement spParentElement = pIElement;

    IFC( GetParentElement(pMarkupServices, pIElement, &spParentElement ));
    if( spParentElement )
    {
        if (IsMasterElement( pMarkupServices, spParentElement ) == S_OK)
        {
            hr = THR( IsMasterParentEditable(pMarkupServices, spParentElement) );
        }
        else
        {
            hr = THR( IsEditable( spParentElement ));
        }
    }
    else
        hr = S_FALSE;
        
Cleanup:

    RRETURN1( hr, S_FALSE );
}

//
// Check to see if jsut a given element is editable
//
HRESULT
EdUtil::IsContentEditable( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    BSTR bstrContentEditable = NULL;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_contentEditable( & bstrContentEditable ));

    if( ! StrCmpICW ( bstrContentEditable, L"true"))
        hr = S_OK;
    else
        hr = S_FALSE; 
    
Cleanup:
    ::SysFreeString( bstrContentEditable);
    RRETURN1( hr , S_FALSE );
}


HRESULT
EdUtil::IsNoScopeElement(IHTMLElement* pIElement, ELEMENT_TAG_ID eTag)
{
    HRESULT hr;
    VARIANT_BOOL vbCanHaveChildren;
    SP_IHTMLElement2 spElement2;
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));
    IFC( spElement2->get_canHaveChildren( & vbCanHaveChildren));

    //
    // Select elements cannot have TEXT children.. only OPTION children
    // the editor needs to treat them as no-scopes
    //
    hr = ( vbCanHaveChildren == VB_TRUE && eTag != TAGID_SELECT ) ? S_FALSE : S_OK;

Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
EdUtil::GetOutermostLayout( IMarkupServices *pMarkupServices, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    HRESULT hr;
    SP_IHTMLElement spCurLayout;
    SP_IHTMLElement spNextElement;
    Assert( pIElement && ppILayoutElement );

    IFHRC( GetLayoutElement( pMarkupServices, pIElement, & spCurLayout ));
    
    while( ! spCurLayout.IsNull() )
    {
        if ( GetParentLayoutElement( pMarkupServices, spCurLayout, & spNextElement) == S_OK )
        {
            spCurLayout = spNextElement;
        }
        else
            break;
    }

    if ( ! spCurLayout.IsNull() &&
         IsLayout( spCurLayout ) == S_OK )
    {
        hr = S_OK;
        *ppILayoutElement = spCurLayout;
        (*ppILayoutElement)->AddRef();
    }
    else
    {
        hr = S_FALSE;
    }
Cleanup:   
    RRETURN1( hr, S_FALSE );
}   


HRESULT
EdUtil::IsEnabled(IHTMLElement* pIElement)
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL vbDisabled ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->get_disabled( & vbDisabled ));

    hr = vbDisabled == VB_TRUE ? S_FALSE : S_OK;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}



HRESULT
EdUtil::BecomeCurrent( IHTMLDocument2 * pIDoc, IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement spActiveElement;
    SP_IObjectIdentity spIdent;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;            
    
    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());

    //
    // workaround until bug 100033 is fixed - we want setActive to return a result code
    // indicating success or failure
    // 
    IFC( pIElement->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
    IFC( spElemDoc->get_activeElement( & spActiveElement ));

    if( spActiveElement )
    {
        IFC( spActiveElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));
        hr = THR( spIdent->IsEqualObject( pIElement ));        
    }
    else
        hr = S_FALSE;
    
 
Cleanup:
    RRETURN1( hr, S_FALSE );
}




//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::IsContentElement
//
//  Synopsis:   See's if this elmenet is a 'content element' - ie a slave
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------

HRESULT
EdUtil::IsContentElement( IMarkupServices *pMS, IHTMLElement * pIElement )
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;
    SP_IHTMLElement spElement;
    
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spPointer ));
    IFC( spPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));        
    IFC( spPointer->CurrentScope( & spElement ));    

    hr =  spElement.IsNull() ? S_OK : S_FALSE; // the element responsible for laying me out isn't me.

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::IsMasterElement
//
//  Synopsis:   See's if this elmeent is a master
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------
HRESULT
EdUtil::IsMasterElement( IMarkupServices* pMS, IHTMLElement* pIElement )
{   
    HRESULT hr ;
    ELEMENT_TAG_ID eTag;
    SP_IMarkupPointer spPointer;
    SP_IMarkupPointer2 spPointer2;
    SP_IMarkupPointer spElemPointer;
    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer spContainer2;
    IUnknown* pUnk1 = NULL ;
    IUnknown* pUnk2 = NULL ;
        
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spPointer ));
    IFC( MarkupServices_CreateMarkupPointer( pMS, & spElemPointer ));
    
    IFC( spPointer->QueryInterface( IID_IMarkupPointer2, (void**) & spPointer2));
    hr = THR( spPointer2->MoveToContent( pIElement, TRUE ));

    if ( hr == E_INVALIDARG )
    {
        IFC( pMS->GetElementTagId( pIElement, &eTag ) );
        
        if ( IsNoScopeElement( pIElement, eTag ) == S_OK  )
        {
            hr = S_FALSE; // No scopes are assumed not to be master elements if MoveToContent fails.           
        }
        goto Cleanup;
    }
    
    IFC( spElemPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin));

    IFC( spPointer->GetContainer( & spContainer ));
    IFC( spElemPointer->GetContainer( & spContainer2 ));

    IFC( spContainer->QueryInterface( IID_IUnknown, (void**) & pUnk1 ));
    IFC( spContainer2->QueryInterface( IID_IUnknown, (void**) & pUnk2 ));

    hr = ( pUnk1 != pUnk2 ) ? S_OK : S_FALSE ; // is a master if content is in different markup than myself

Cleanup:
    ReleaseInterface( pUnk1 );
    ReleaseInterface( pUnk2 );

    RRETURN1( hr , S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     EdUtil::GetMasterElement
//
//  Synopsis:   Gets the Master Element
//
//----------------------------------------------------------------------------
HRESULT 
EdUtil::GetMasterElement( IMarkupServices *pMS, IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPtr;          // Pointer to be positioned at content
    SP_IMarkupPointer2      spPtr2;         // IMarkupPointer2 interface
    SP_IMarkupContainer     spContainer;    // Container of pointer
    SP_IMarkupContainer2    spContainer2;
    
    Assert( ppILayoutElement && pIElement && pMS );
    
    IFC( MarkupServices_CreateMarkupPointer( pMS, &spPtr));
    IFC( spPtr->QueryInterface( IID_IMarkupPointer2, (void**) & spPtr2));

    hr = THR( spPtr2->MoveToContent( pIElement, TRUE ));
    if( FAILED(hr) )
    {
        // possible for images, and other noscopes.
        hr = THR( spPtr->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    }

    IFC( spPtr2->GetContainer( &spContainer ));
    IFC( spContainer->QueryInterface (IID_IMarkupContainer2, (void **)&spContainer2 ));
    IFC( spContainer2->GetMasterElement( ppILayoutElement ));

    if( !*ppILayoutElement )
    {
        hr = S_FALSE;
    }
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
EdUtil::IsPointerInMasterElementShadow( CEditorDoc *pEditor, IMarkupPointer* pPointer )
{
    HRESULT             hr = S_FALSE;
    BOOL                fInMasterShadow = FALSE;
    SP_IDisplayPointer     spDispPointer;
    SP_IHTMLElement      spStartElement;
    SP_IHTMLElement      spScopeElement;
    BOOL                 fPositioned = FALSE;
    if (pPointer == NULL)
    {
        Assert(pPointer);
        goto Cleanup;
    }

    IFC (pPointer->IsPositioned(&fPositioned));
    if (fPositioned)
    {
        IFC( pPointer->CurrentScope(&spScopeElement) );
        if (spScopeElement != NULL)
        {
            IFC( GetLayoutElement(pEditor->GetMarkupServices(), spScopeElement, &spStartElement) );
            if ( spStartElement && ( IsMasterElement(pEditor->GetMarkupServices(), spStartElement) == S_OK ) )
            {
                SP_IMarkupPointer       spMasterStartPointer;
                SP_IMarkupContainer     spMasterContainer;
                SP_IMarkupContainer     spStartContainer;

                //  If the markup container of the master element is the same as the markup container of
                //  pStart, then pStart is not in the master element's slave markup.  So, pStart is not
                //  in a position to be selected.  We bail.

                IFC( pEditor->CreateMarkupPointer( &spMasterStartPointer ));
                IFC( spMasterStartPointer->MoveAdjacentToElement( spStartElement, ELEM_ADJ_BeforeBegin ) );

                IFC( spMasterStartPointer->GetContainer( &spMasterContainer ) );
                IFC( pPointer->GetContainer( &spStartContainer ) );

                if ( IsEqual(spMasterContainer, spStartContainer) )
                {
                    fInMasterShadow = TRUE;
                }
            }
        }
    }

Cleanup:

    if ( SUCCEEDED(hr) )
        hr = (fInMasterShadow) ? S_OK : S_FALSE;
        
    RRETURN1(hr, S_FALSE);
}


//+====================================================================================
//
// Method: Between
//
// Synopsis: Am I in - between the 2 given pointers ?
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::Between( 
    IMarkupPointer* pTest,
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( pTest->IsRightOfOrEqualTo( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( pTest->IsLeftOfOrEqualTo( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}

//
// Same as between, but equality with endpoints returns false.
//
BOOL
EdUtil::BetweenExclusive( 
    IMarkupPointer* pTest,
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( pTest->IsRightOf( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( pTest->IsLeftOf( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}

//+---------------------------------------------------------------------
//
// Method: SegmentContainsElement
//
// Synopsis: Does this segment in anyway intersect a given element ?
//
//+---------------------------------------------------------------------

HRESULT
EdUtil::SegmentIntersectsElement(
                    CEditorDoc   *pEditor,
                    ISegmentList *pISegmentList, 
                    IHTMLElement *pIElement )
{
    HRESULT  hr;
    SP_ISegmentListIterator spIter;
    SP_ISegment       spSegment;
    SP_IMarkupPointer spStart, spEnd;               // segment boundaries
    SP_IMarkupPointer spStartElem, spEndElem;       // element boundaries
    BOOL fDoesNotIntersect = FALSE ;
    
    IFC( pEditor->CreateMarkupPointer( & spStart ));
    IFC( pEditor->CreateMarkupPointer( & spEnd ));
    IFC( pEditor->CreateMarkupPointer( & spStartElem ));
    IFC( pEditor->CreateMarkupPointer( & spEndElem ));

    IFC( spStartElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEndElem->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ));
    
    IFC( pISegmentList->CreateIterator( & spIter ));

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( spStart, spEnd ));

        IFC( spStartElem->IsRightOf( spEnd , & fDoesNotIntersect ));

        if ( ! fDoesNotIntersect )
        {
            IFC( spEndElem->IsLeftOf( spStart , & fDoesNotIntersect ));
        }

        if ( ! fDoesNotIntersect )
            break;
            
        IFC( spIter->Advance() );
    }

Cleanup:
    if ( ! FAILED(hr ))
    {
        hr = ! fDoesNotIntersect ? S_OK : S_FALSE;
    }
    
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     ArePointersInSameMarkup
//
//  Synopsis:   Determines the if the two markup pointers are in the same
//              container.
//
//  Arguments:  pIFirst = First markup pointer
//              pISecond = Second markup pointer
//              pfInSame = OUTPUT - Same container
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
EdUtil::ArePointersInSameMarkup( IMarkupPointer* pIFirst, IMarkupPointer * pISecond , BOOL* pfInSame)
{
    HRESULT hr = S_OK;
    SP_IMarkupContainer spContainer;
    SP_IMarkupContainer spContainer2;
    IUnknown *pUnk1 = NULL;
    IUnknown *pUnk2 = NULL;

    Assert(pIFirst && pISecond);
    Assert(pfInSame);

    if (pfInSame)
        *pfInSame = FALSE;
    
    if (pIFirst && pISecond)
    {
        IFC( pIFirst->GetContainer(& spContainer ));
        IFC( pISecond->GetContainer( & spContainer2 ));

        if ( spContainer && spContainer2 )
        {
            IFC( spContainer->QueryInterface( IID_IUnknown, (void**) & pUnk1 ));
            IFC( spContainer2->QueryInterface( IID_IUnknown, (void**) & pUnk2 ));

            *pfInSame = ( pUnk1 == pUnk2 );
        }
    }

Cleanup: 
    ReleaseInterface( pUnk1 );
    ReleaseInterface( pUnk2 );
    RRETURN( hr );
}

HRESULT
EdUtil::ArePointersInSameMarkup(CEditorDoc      *pEd,
                                IDisplayPointer *pIFirst, 
                                IDisplayPointer *pISecond, 
                                BOOL            *pfInSame)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spFirst;
    SP_IMarkupPointer   spSecond;

    Assert( pEd && pIFirst && pISecond && pfInSame );

    if (pfInSame)
        *pfInSame = FALSE;

    if (pIFirst && pISecond)
    {
        IFC( pEd->CreateMarkupPointer( &spFirst ) );
        IFC( pEd->CreateMarkupPointer( &spSecond ) );

        IFC( pIFirst->PositionMarkupPointer( spFirst ) );
        IFC( pISecond->PositionMarkupPointer( spSecond ) );

        IFC( EdUtil::ArePointersInSameMarkup( spFirst, spSecond, pfInSame ) );
    }

Cleanup:

    RRETURN(hr);
}

#if DBG == 1
HRESULT
EdUtil::AssertSameMarkup(CEditorDoc     *pEd,
                        IDisplayPointer *pDispPointer1,
                        IDisplayPointer *pDispPointer2)
{
    HRESULT             hr = S_OK;
    BOOL                fSameMarkup = TRUE;

    if (pDispPointer1 && pDispPointer2)
    {
        hr = THR( ArePointersInSameMarkup(pEd, pDispPointer1, pDispPointer2, &fSameMarkup) );

        if (!fSameMarkup)
        {
            BOOL                fPositioned1;
            BOOL                fPositioned2;

            IGNORE_HR( pDispPointer1->IsPositioned(&fPositioned1) );
            IGNORE_HR( pDispPointer2->IsPositioned(&fPositioned2) );

            if (fPositioned1 && fPositioned2)
            {
                AssertSz(false, "Display pointers are in different markups");
            }
        }
    }

    RRETURN( hr );
}

HRESULT
EdUtil::AssertSameMarkup(CEditorDoc     *pEd,
                        IDisplayPointer *pDispPointer1,
                        IMarkupPointer  *pPointer2)
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer2;
    
    if (pDispPointer1 && pPointer2)
    {
        IFC( pEd->GetDisplayServices()->CreateDisplayPointer(&spDispPointer2) );
        IFC( spDispPointer2->MoveToMarkupPointer(pPointer2, NULL) );
        hr = THR( AssertSameMarkup(pEd, pDispPointer1, spDispPointer2) );
    }

Cleanup:
    RRETURN( hr );
}
#endif

// We don't want to include the CRuntime so we've built the routine here.

// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              of legacy browser compatibility).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, VARIANT *pvarg, VARTYPE vt,IServiceProvider *pSrvProvider, DWORD dwFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = THR(pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType));
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
        hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);

        //Assert(!hr && "IVariantChangeType::ChangeType failure");
        if (!hr)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
        // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( _T("null") );           
        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( _T("undefined") );
        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = ( V_BSTR(pvarg) && SysStringLen( V_BSTR(pvarg) ) ) ? VB_TRUE : VB_FALSE ;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( V_BOOL(pvarg) == VB_TRUE ? _T("true") : _T("false") );     
        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                V_BSTR(pVArgDest) = SysAllocString(_T("NaN") );
            }
            else
            {
                // Infinity
                V_BSTR(pVArgDest) = SysAllocString((dblValue < 0) ? _T("-Infinity") : _T("Infinity"));
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = THR(VariantChangeTypeEx(pVArgDest, pvarg, LCID_SCRIPTING, dwFlags|VARIANT_NOUSEROVERRIDE, vt));

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_I4(pVArgDest)=0;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            V_BSTR(pVArgDest) = SysAllocString ( (V_DISPATCH(pvarg)) ? _T("[object]") : _T("null"));
        }
        else if ( V_VT(pvarg) == VT_BSTR && V_BSTRREF(pvarg)  &&
            ( (V_BSTR(pvarg))[0] == _T('\0')) && (  vt == VT_I4 || vt == VT_I2 || vt == VT_UI2 || vt == VT_UI4 || vt == VT_I8 ||
                vt == VT_UI8 || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

    // To match Navigator change any scientific notation E to e.
    if (!hr && (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4)))
    {
        TCHAR *pENotation;

        pENotation = _tcschr(V_BSTR(pVArgDest), _T('E'));
        if (pENotation)
            *pENotation = _T('e');
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::ComputeParentChain, private
//
//  Synopsis:   Compute the markup parent chain using pPointer as a helper
//
//----------------------------------------------------------------------------

//
// Make sure and release all pointers in the array you're passed in in this function.
//
HRESULT
EdUtil::ComputeParentChain(
    IMarkupPointer *pPointer, 
    CPtrAry<IMarkupContainer *> &aryParentChain)
{
    HRESULT                 hr;
    //
    // Don't change the below to a smart pointer - should be released by the caller of this function
    //
    IMarkupContainer        *pContainer=NULL;
    SP_IMarkupContainer2    spContainer2;
    SP_IHTMLElement         spElement;

    for (;;)
    {
        IFC( pPointer->GetContainer(&pContainer) );
        IFC( aryParentChain.Append( pContainer) );

        IFC( pContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(&spElement) );

        if (spElement == NULL)
            break;

        hr = THR( pPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );

        if( FAILED(hr) )
        {
            aryParentChain.Append( NULL );
            hr = S_OK;
            break;
        }                   
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsEqual, private
//
//  Synopsis:   Compare markup containers
//
//----------------------------------------------------------------------------
BOOL
EdUtil::IsEqual(IMarkupContainer *pContainer1, IMarkupContainer *pContainer2)
{
    HRESULT     hr;
    SP_IUnknown spUnk1, spUnk2;

    if( pContainer1 == NULL )
        return pContainer2 == NULL;
    else if( pContainer2 == NULL )
        return FALSE;
        
    IFC( pContainer1->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk1) );
    IFC( pContainer2->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk2) );

    return (spUnk1 == spUnk2);

Cleanup:
    return FALSE;
}

HRESULT 
EdUtil::ClipToElement( CEditorDoc* pDoc, 
                        IHTMLElement* pIElementActive,
                        IHTMLElement* pIElement,
                        IHTMLElement** ppIClippedElement )
{
    HRESULT hr;
    SP_IMarkupPointer spActPointer;
    SP_IMarkupPointer spElemPointer;
    BOOL fSame;
    ELEMENT_TAG_ID eTag;
    int i;
    CPtrAry<IMarkupContainer *>  aryParentChain1(Mt(Mem));
    CPtrAry<IMarkupContainer *>  aryParentChain2(Mt(Mem));    
    Assert( pIElementActive && pIElement && ppIClippedElement );
    
    IFC( pDoc->CreateMarkupPointer( & spActPointer ));
    IFC( pDoc->CreateMarkupPointer( & spElemPointer ));

    //
    // Find a good place to be for Master/Slave specialness.
    //

    //
    // special case input. It is a master element - but we don't want to drill in.
    // otherwise we'll start handing out the txtslave as the element.
    //
    IFC( pDoc->GetMarkupServices()->GetElementTagId( pIElementActive, & eTag ));    
    if ( IsMasterElement( pDoc->GetMarkupServices(), pIElementActive ) == S_OK &&
         eTag != TAGID_INPUT )
    {
        IFC( PositionPointersInMaster( pIElementActive, spActPointer, NULL ));
    }
    else
    {
        IFC( spActPointer->MoveAdjacentToElement( pIElementActive, ELEM_ADJ_BeforeBegin ));
    }
    
    IFC( spElemPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));

    IFC( ArePointersInSameMarkup ( spActPointer, spElemPointer, & fSame ));

    if( fSame )
    {
        *ppIClippedElement = pIElement;
        (*ppIClippedElement)->AddRef();
    }
    else
    {
        SP_IMarkupPointer            spPointer1;
        SP_IMarkupPointer            spPointer2;
        INT                          iChain1, iChain2;
        SP_IMarkupContainer2         spContainer2;
        
        IFC( MarkupServices_CreateMarkupPointer( pDoc->GetMarkupServices(), &spPointer1) );
        IFC( MarkupServices_CreateMarkupPointer( pDoc->GetMarkupServices(), &spPointer2) );

        //
        // Compute the markup parent chain for each pointer
        //

        IFC( spPointer1->MoveToPointer( spActPointer ) );
        IFC( ComputeParentChain(spPointer1, aryParentChain1) );
        
        IFC( spPointer2->MoveToPointer(spElemPointer) );
        IFC( ComputeParentChain(spPointer2, aryParentChain2) );

        iChain1 = aryParentChain1.Size()-1;
        iChain2 = aryParentChain2.Size()-1;

        Assert(iChain1 >= 0 && iChain2 >= 0);

        //
        // Make sure the top markups are the same
        //

        if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
        {
            //
            // possible if clicking in a different frame - with a current elem in another frame.
            //
            hr = E_FAIL ;
            goto Cleanup;
        }

        for (;;)
        {
            iChain1--;
            iChain2--;

            //
            // Check if one markup is contained within another
            //
            if (iChain1 < 0 || iChain2 < 0)
            {
                // (iChain1 < 0 && iChain2 < 0) implies same markup.  This function should not be
                // called in this case
                Assert(iChain1 >= 0 || iChain2 >= 0);

                if (iChain1 < 0)
                {
                    //
                    // pIElement's markup is deeper than active. ClipElement is 
                    // master of pIElement's markup
                    //
                    if( aryParentChain2[iChain2] )
                    {
                        IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                        IFC( spContainer2->GetMasterElement( ppIClippedElement) );
                    }
                }
                else
                {
                    //
                    // ActiveEleemnt's markup is deeper. No need to clip.
                    //
                    *ppIClippedElement = pIElement;
                    (*ppIClippedElement)->AddRef();
                }                
                break;
            }

            //
            // Check if we've found the first different markup in the chain
            //
                    
            if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
            {
                if( aryParentChain2[iChain2] )
                {
                    IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement( ppIClippedElement) );
                }

                break;
            }
        }            
    }
    
Cleanup:
    for (i = 0; i < aryParentChain1.Size(); i++)
        ReleaseInterface(aryParentChain1[i]);

    for (i = 0; i < aryParentChain2.Size(); i++)
        ReleaseInterface(aryParentChain2[i]);
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: PositionPointersInMaster
//
// Synopsis: Move to content in master + some clinging to find an element with layout
//
//+---------------------------------------------------------------------

HRESULT
EdUtil::PositionPointersInMaster( IHTMLElement* pIElement, IMarkupPointer* pIStart, IMarkupPointer* pIEnd )
{
    HRESULT hr;
    
    SP_IMarkupPointer2 spStart2;
    SP_IMarkupPointer2 spEnd2;
    
    SP_IMarkupContainer spContainer;
    SP_IHTMLDocument2 spDoc;
    SP_IHTMLElement spBody;

    if ( pIStart )
    {
        IFC( pIStart->QueryInterface( IID_IMarkupPointer2, (void**) &  spStart2 ));
        IFC( spStart2->MoveToContent( pIElement, TRUE ));
    }    

    if ( pIEnd )
    {
        IFC( pIEnd->QueryInterface( IID_IMarkupPointer2, (void**) &  spEnd2 ));
        IFC( spEnd2->MoveToContent( pIElement, FALSE ));
    }

    IFC( pIStart->GetContainer( & spContainer ));
    if ( spContainer->QueryInterface( IID_IHTMLDocument2, (void**) & spDoc ) == S_OK )
    {
        IFC( spDoc->get_body( & spBody ));
        if ( spBody )
        {
            if ( pIStart )
            {
                IFC( pIStart->MoveAdjacentToElement( spBody, ELEM_ADJ_AfterBegin ));
            }

            if ( pIEnd )
            {
                IFC( pIEnd->MoveAdjacentToElement( spBody, ELEM_ADJ_BeforeEnd ));
            }                
        }
    }
    
Cleanup:
    RRETURN( hr );

}

HRESULT 
EdUtil::CheckAttribute(IHTMLElement* pElement,BOOL *pfSet, BSTR bStrAtribute, BSTR bStrAtributeVal )
{
    HRESULT hr = S_OK;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var)   = VT_BSTR ;
    V_BSTR(&var) =  NULL ;

    *pfSet = FALSE;

    //  Bug 102306: Make sure the var was a BSTR before checking value.  If the var was a BOOL
    //  just get the BOOL value.

    IFC( pElement->getAttribute(bStrAtribute, 0, &var) );
    if (V_VT(&var) == VT_BSTR)
    {
        *pfSet = !!(_tcsicmp(var.bstrVal, bStrAtributeVal) == 0);
    }
    else if (V_VT(&var) == VT_BOOL)
    {
        *pfSet = !!(V_BOOL(&var));
    }

Cleanup:
    VariantClear(&var);
    RRETURN (hr);
}

//+====================================================================================
//
// Method:      EqualDocuments
//
// Synopsis:    Check for equality on 2 IHTMLDocument
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::EqualDocuments( IHTMLDocument2 *pIDoc1, IHTMLDocument2 *pIDoc2 )
{
    HRESULT     hr = S_OK;
    SP_IUnknown spIObj1;
    SP_IUnknown spIObj2;
    BOOL        fSame = FALSE;
    
    IFC( pIDoc1->QueryInterface( IID_IUnknown, (void**)&spIObj1));
    IFC( pIDoc2->QueryInterface( IID_IUnknown, (void**)&spIObj2));

    fSame = (spIObj1.p == spIObj2.p);
    
Cleanup:
    return fSame;
}


//+====================================================================================
//
// Method: EqualContainers
//
// Synopsis: Check for equality on 2 MarkupContainers
//
//------------------------------------------------------------------------------------

BOOL
EdUtil::EqualContainers( IMarkupContainer* pIMarkup1, IMarkupContainer* pIMarkup2 )
{
    HRESULT             hr = S_OK;
    SP_IUnknown         spUnk1;
    SP_IUnknown         spUnk2;
    BOOL                fSame = FALSE;

    Assert( pIMarkup1 && pIMarkup2 );

    if(!pIMarkup1 || !pIMarkup2) 
        return (pIMarkup1 == pIMarkup2);
    
    IFC( pIMarkup1->QueryInterface( IID_IUnknown, (void **)&spUnk1));
    IFC( pIMarkup2->QueryInterface( IID_IUnknown, (void **)&spUnk2))

    fSame = ( spUnk1.p == spUnk2.p );
    
Cleanup:

    return fSame;
}

#if DBG==1

#undef CreateMarkupPointer

HRESULT 
MarkupServices_CreateMarkupPointer(IMarkupServices *pMarkupServices, IMarkupPointer **ppPointer)
{
    return pMarkupServices->CreateMarkupPointer(ppPointer);
}

#endif

VOID 
CEditXform::TransformPoint( POINT* pPt )
{
    Assert( pPt );

    if ( _pXform )
    {
        LONG inX = pPt->x ;

        //  chandras : rotation, zooming and displacement applying thru transformation matrix
        //  matrix multiplication 1x2 * 2x2  = 1x2
        //  (x y) * (a11 a12)   = (x * a11 + y * a21   x*a12 + y * a22)
        //          (a21 a22)  
        //  where (x y) is initial point
        //        transformation matrix - (a11 a12)
        //                                (a21 a22)
        //        the product - (x * a11 + y * a21   x*a12 + y * a22)
        //
        pPt->x =  inX * _pXform->eM11 + pPt->y * _pXform->eM21 + _pXform->eDx;
        pPt->y =  inX * _pXform->eM12 + pPt->y * _pXform->eM22 + _pXform->eDy;
    }
}

VOID
CEditXform::TransformRect( RECT* pRect )
{
    POINT ptTopLeft;
    POINT ptBottomRight;

    Assert( pRect );

    if ( _pXform )
    {
        ptTopLeft.x = pRect->left;
        ptTopLeft.y = pRect->top;

        ptBottomRight.x = pRect->right;
        ptBottomRight.y = pRect->bottom;

        TransformPoint( & ptTopLeft );
        TransformPoint( & ptBottomRight );

        //  chandras : rotation, zooming and displacement applying
        //  high possibility of the rectangle is roatated (Vetical layout case)
        //  so get the corners normalized.
        if (ptTopLeft.x >= ptBottomRight.x)
        {
            pRect->left  = ptBottomRight.x;
            pRect->right = ptTopLeft.x;
        }
        else
        {
            pRect->left  = ptTopLeft.x;
            pRect->right = ptBottomRight.x;
        }
        
        if (ptTopLeft.y >= ptBottomRight.y)
        {        
            pRect->top    = ptBottomRight.y;
            pRect->bottom = ptTopLeft.y;
        }
        else
        {
            pRect->top    = ptTopLeft.y;
            pRect->bottom = ptBottomRight.y;
        }         
    }    
}

HRESULT 
EdUtil::GetOffsetTopLeft(IHTMLElement* pIElement, POINT* ptTopLeft)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElemNext;

    IFC (pIElement->get_offsetLeft(&(ptTopLeft->x)));
    IFC (pIElement->get_offsetTop(&(ptTopLeft->y)));

    IFC (pIElement->get_offsetParent(&spElemNext));

    while (SUCCEEDED(hr) && spElemNext)
    {
        SP_IHTMLElement spElem;

        POINT pt;

        IFC (spElemNext->get_offsetLeft(&pt.x));
        IFC (spElemNext->get_offsetTop(&pt.y));

        ptTopLeft->x += pt.x;
        ptTopLeft->y += pt.y;

        spElem = spElemNext;
        hr = spElem->get_offsetParent(&spElemNext);
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
EdUtil::GetElementRect(IHTMLElement* pIElement, LPRECT prc)
{
    POINT   ptExtent;
    HRESULT hr = S_OK;
    POINT   ptLeftTop ;

    IFC(GetOffsetTopLeft(pIElement, &ptLeftTop));
    prc->left = ptLeftTop.x;
    prc->top  = ptLeftTop.y;

    IFC(GetPixelWidth (pIElement, &ptExtent.x));
    IFC(GetPixelHeight(pIElement, &ptExtent.y));

    prc->right  = prc->left + ptExtent.x;
    prc->bottom = prc->top  + ptExtent.y;

Cleanup:
    RRETURN(hr);
}

HRESULT 
EdUtil::GetPixelWidth(IHTMLElement* pIElement, long* lWidth)
{
   RRETURN(pIElement->get_offsetWidth(lWidth));
}

HRESULT
EdUtil::GetPixelHeight(IHTMLElement* pIElement, long* lHeight)
{
   RRETURN(pIElement->get_offsetHeight(lHeight));
}

LONG
EdUtil::GetCaptionHeight(IHTMLElement* pIElement)
{
    LONG               lHeightCaption = 0;
    IHTMLTableCaption *pICaption = NULL;
    IHTMLElement      *pICaptionElement = NULL;
    IHTMLTable        *pITable = NULL  ;

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable , (void**)&pITable)))
    {
        if (SUCCEEDED(pITable->get_caption(&pICaption)))
        {
            if (pICaption != NULL)
            {   
                if (SUCCEEDED(pICaption->QueryInterface(IID_IHTMLElement, (void**)&pICaptionElement)))
                {
                    pICaptionElement->get_offsetHeight(&lHeightCaption);
                }
                ReleaseInterface(pICaptionElement);
            }
        }            
        ReleaseInterface(pICaption);
    }          
    ReleaseInterface(pITable);
    
    return (lHeightCaption);
}

HRESULT
EdUtil::GetClientOrigin(CEditorDoc *pEd, IHTMLElement *pElement, POINT * ppt)
{
    HRESULT hr;
    
    Assert( pElement && ppt && pEd );
    
    ppt->x = 0;
    ppt->y = 0;

    //
    // Transform our point from Frame to Global coordinate systems
    //
    IFC( pEd->GetDisplayServices()->TransformPoint( ppt,
                                                    COORD_SYSTEM_FRAME,
                                                    COORD_SYSTEM_GLOBAL,
                                                    pElement ) );
                                                    
Cleanup:
    RRETURN( hr );
}


HRESULT
EdUtil::GetFrameOrIFrame(CEditorDoc *pEd, IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT             hr = S_OK;
    SP_IDispatch        spDispDoc;
    SP_IHTMLDocument2   spDoc; 
    SP_IHTMLWindow2     spWindow2;
    SP_IHTMLWindow4     spWindow4;
    SP_IHTMLFrameBase   spFrameBase;
    SP_IUnknown         spUnkDoc;
    SP_IUnknown         spUnkTopDoc;
    ELEMENT_TAG_ID      tagId;

    Assert(pIElement && ppIElement && pEd);

    *ppIElement = NULL;

    //
    // Check for frame
    //

    IFC( pEd->GetMarkupServices()->GetElementTagId(pIElement, &tagId) );
    if (tagId == TAGID_FRAME || tagId == TAGID_IFRAME)
    {
        *ppIElement = pIElement;
        pIElement->AddRef();
        goto Cleanup;
    }

    //
    // Makes sure we don't go past the top document
    //

    IFC( pIElement->get_document(&spDispDoc) );
    Assert(spDispDoc != NULL);

    IFC( spDispDoc->QueryInterface(IID_IUnknown, (LPVOID *)&spUnkDoc) );
    IFC( pEd->GetTopDoc()->QueryInterface(IID_IUnknown, (LPVOID *)&spUnkTopDoc) );

    if (spUnkDoc == spUnkTopDoc)
    {
        hr = S_FALSE; // don't go past the top doc
        goto Cleanup;
    }

    //
    // Check for parent frame
    //


    IFC( spDispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&spDoc) );
    IFC( spDoc->get_parentWindow(&spWindow2) );

    IFC( spWindow2->QueryInterface(IID_IHTMLWindow4, (LPVOID *)&spWindow4) );    
    if (SUCCEEDED(spWindow4->get_frameElement(&spFrameBase)) && spFrameBase)
    {
        IFC( spFrameBase->QueryInterface(IID_IHTMLElement, (LPVOID *)ppIElement) );
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


HRESULT 
EdUtil::GetActiveElement( 
                            CEditorDoc *pEd, 
                            IHTMLElement* pIElement, 
                            IHTMLElement** ppIActive, 
                            BOOL fSeeCurrentInIframe /*=FALSE*/ )
{
    HRESULT hr;

    Assert( ppIActive );
    if ( ! ppIActive )
    {
        return E_FAIL;
    }
    SP_IHTMLElement spFrameElement;
    BOOL fValidFrame = FALSE;

    //
    // Get the "real" active element - catering for frameset pages.
    //
    
    if ( EdUtil::GetFrameOrIFrame( pEd , pIElement, & spFrameElement ) == S_OK )
    {
        ELEMENT_TAG_ID eTag;
        
        IFC( pEd->GetMarkupServices()->GetElementTagId(spFrameElement, & eTag));
        fValidFrame = (eTag != TAGID_IFRAME) || fSeeCurrentInIframe ;
        Assert( eTag == TAGID_FRAME || eTag == TAGID_IFRAME );
    }
        
    if ( fValidFrame )
    {
        SP_IDispatch spElemDocDisp;
        SP_IHTMLDocument2 spElemDoc;            

        IFC( pIElement->get_document(& spElemDocDisp ));
        IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
        IFC( spElemDoc->get_activeElement( ppIActive ));
    }
    else
    {
        IFC( pEd->GetDoc()->get_activeElement ( ppIActive ));
    }
    
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     IsDropDownList
//
//  Synopsis:   Determines if the specified element is a drop down list
//
//  Arguments:  pIElement = Element to determine if it is a drop down
//
//  Returns:    BOOLEAN indicating whether it is a dropdown
//
//--------------------------------------------------------------------------
BOOL
EdUtil::IsDropDownList( IHTMLElement *pIElement )
{
    SP_IHTMLSelectElement   spSelectElement;
    BOOL                    fIsDropDown = FALSE;
    HRESULT                 hr = S_OK;
    long                    lSize;
    VARIANT_BOOL            vbMultiple;
    
    if( !pIElement )
        goto Cleanup;

    //
    // A drop down list is defined as a select element, with MULTIPLE set to FALSE
    // and SIZE set to 1
    //
    IFC( pIElement->QueryInterface( IID_IHTMLSelectElement, (void **)&spSelectElement ) );   
    IFC( spSelectElement->get_size(&lSize) );
    IFC( spSelectElement->get_multiple( &vbMultiple ) );

    fIsDropDown = (lSize <= 1) && (vbMultiple == VB_FALSE);

Cleanup:
    return fIsDropDown;
}

//+-------------------------------------------------------------------------
//
//  Method:     GetSegmentCount
//
//  Synopsis:   Retrieves the length of the segment list
//
//  Arguments:  pISegmentList = Pointer to segment list
//              piCount = OUTPUT - Length of list
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
EdUtil::GetSegmentCount(ISegmentList *pISegmentList, int *piCount )
{
    HRESULT                 hr;
    SP_ISegmentListIterator spIter;
    int                     nSize = 0;
    
    Assert( pISegmentList && piCount );

    IFC( pISegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        nSize++;
        IFC( spIter->Advance() );
    }

    *piCount = nSize;

Cleanup:
    RRETURN(hr);
}

BOOL
EdUtil::IsVMLElement(IHTMLElement* pIElement)
{
    BSTR bstrUrn ;
    SP_IHTMLElement2 spElement2;

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2, (void**)&spElement2)) &&
        SUCCEEDED(spElement2->get_tagUrn(&bstrUrn)))
    {
         if ((bstrUrn != NULL) &&
             (StrCmpIW(bstrUrn, L"urn:schemas-microsoft-com:vml") == 0))
         {
            return TRUE;
         }
    }

    return FALSE;
}

//+====================================================================================
//
// Method: IsTridentHWND
//
// Synopsis: Helper to check to see if a given HWND belongs to a trident window
//
//------------------------------------------------------------------------------------
BOOL
EdUtil::IsTridentHwnd( HWND hwnd )
{
    TCHAR strClassName[100] ;

    ::GetClassName( hwnd, strClassName, 100 );

    if ( StrCmpIW( strClassName, _T("Internet Explorer_Server") ) == 0 )
    {
        return TRUE;
    }
    else
        return FALSE;
}






//+====================================================================================
//
// Method: EqualPointers 
//
// Synopsis: Check to see if there is no text in between pMarkup1 and pMarkup2
//           If fIgnoreBlock is FALSE, text between two block element are not considered
//           equal.
//
//------------------------------------------------------------------------------------
HRESULT 
EdUtil::EqualPointers(  IMarkupServices *pMarkupServices, 
                        IMarkupPointer *pMarkup1, 
                        IMarkupPointer *pMarkup2, 
                        BOOL *pfEqual,
                        BOOL fIgnoreBlock
                        )
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE ctx;
    BOOL                fResult;    
    long                lcchTemp;
    IMarkupPointer      *pMarkupScan = NULL;
    SP_IHTMLElement     spElement;
    BOOL                fDone;

    Assert (pMarkupServices);
    Assert (pMarkup1);
    Assert (pMarkup2);
    
    IFC( pMarkup1->IsEqualTo(pMarkup2, pfEqual) );
    if(*pfEqual)
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( pMarkup1->IsLeftOf(pMarkup2, &fResult));
    if (!fResult)
    {
        //
        // pMarkupScan is not ref-counted here
        //
        pMarkupScan = pMarkup1;
        pMarkup1    = pMarkup2;
        pMarkup2    = pMarkupScan;
        pMarkupScan = NULL; 
    }

    IFC( pMarkupServices->CreateMarkupPointer(&pMarkupScan) );
    IFC( pMarkupScan->MoveToPointer(pMarkup1) );
    *pfEqual = TRUE;
    fDone    = FALSE;
    while (!fDone)
    {
        lcchTemp = -1;

        // Move the temp pointer ahead
        IFC(pMarkupScan->Right(TRUE, &ctx, &spElement, &lcchTemp, NULL));

        // If the temp pointer movement went over text,
        // then there is some text between pPtr1 and pPtr2 and so
        // they are not equal
        switch (ctx)
        {
        case CONTEXT_TYPE_Text:
            *pfEqual = FALSE;
            fDone    = TRUE;
            break;
            
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
        case CONTEXT_TYPE_NoScope:
            if (!fIgnoreBlock)
            {
                BOOL  fBlock, fLayout;
                Assert(!(spElement == NULL));
                IFC( EdUtil::IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );
                if (fBlock || fLayout)  
                {
                    *pfEqual = FALSE;
                    fDone    = TRUE;
                }
                else
                {
                    ELEMENT_TAG_ID eTag = TAGID_NULL;
                    IFC( pMarkupServices->GetElementTagId(spElement, &eTag) );
                    if (eTag == TAGID_BR)
                    {
                        *pfEqual = FALSE;
                        fDone    = TRUE;
                    }
                }
            }
            //
            // Skip phrase elements /and block elements if fIgnoreBlock
            //
            break;
            

        case CONTEXT_TYPE_None:
            fDone = TRUE;
            break;
        }
        
        
        IFC( pMarkupScan->IsLeftOf(pMarkup2, &fResult));
        if (!fResult)
        {   
            // Done
            break;
        }
    }

Cleanup:
    ReleaseInterface(pMarkupScan);
    RRETURN (hr);
}



HRESULT
EdUtil::GetDisplayLocation(
            CEditorDoc      *pEd,
            IDisplayPointer *pDispPointer,
            POINT           *pPoint,
            BOOL            fTranslate
            )
{
    HRESULT             hr;
    SP_ILineInfo        spLineInfo;
    SP_IMarkupPointer   spPointer;
    IHTMLElement        *pIFlowElement = NULL;

    Assert( pEd );
    Assert( pDispPointer );
    Assert( pPoint );

    IFR( pDispPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if( fTranslate )
    {
        IFC( pEd->GetMarkupServices()->CreateMarkupPointer(&spPointer) );
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( pDispPointer->GetFlowElement(&pIFlowElement) );
        IFC( pEd->GetDisplayServices()->TransformPoint(pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, pIFlowElement) );
    }

Cleanup:
    ReleaseInterface(pIFlowElement);
    return S_OK;
}



//
// Check to see if pIContainer1 contains pIContainer2
//
HRESULT 
EdUtil::CheckContainment(IMarkupServices *pMarkupServices, 
                         IMarkupContainer *pIContainer1, 
                         IMarkupContainer *pIContainer2, 
                         BOOL *pfContained
                         )
{
    HRESULT  hr = S_OK;
    SP_IMarkupPointer    spPointer;
    SP_IMarkupContainer  spContainer;

    Assert( pMarkupServices );
    Assert( pIContainer1 );
    Assert( pIContainer2 );
    Assert( pfContained );
    *pfContained = FALSE;

    if ( IsEqual(pIContainer1, pIContainer2) )
    {
        *pfContained = TRUE;
        goto Cleanup;
    }

    IFC( pMarkupServices->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveToContainer(pIContainer2, TRUE) );
    spContainer = pIContainer2; 
    for (; ;)
    {
        SP_IMarkupContainer2 spContainer2;
        SP_IHTMLElement      spElement;
        
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (void **)&spContainer2) );
        IFC( spContainer2->GetMasterElement(&spElement) );

        if (spElement == NULL)
            break;

        hr = THR( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
        if (FAILED(hr))
        {
            hr = S_OK;
            break;
        }

        IFC( spPointer->GetContainer(&spContainer) );
        if (IsEqual(pIContainer1, spContainer))
        {
            *pfContained = TRUE;
            break;
        }
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT
EdUtil::AdjustForAtomic(CEditorDoc      *pEd,
                        IDisplayPointer *pDispPointer,
                        IHTMLElement    *pAtomicElement,
                        BOOL            fStartOfSelection,
                        int             iDirection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spElemPointer;

    Assert(pEd);
    Assert(pDispPointer);
    Assert(pAtomicElement);

    IFC( pEd->GetMarkupServices()->CreateMarkupPointer(&spElemPointer) );
    if (fStartOfSelection)
    {
        IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
    }
    else
    {
        IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
    }

    hr = THR( pDispPointer->MoveToMarkupPointer(spElemPointer, NULL) );
    if (hr == CTL_E_INVALIDLINE)
    {
        ELEMENT_TAG_ID eTag = TAGID_NULL;
        
        IFC( pEd->GetMarkupServices()->GetElementTagId( pAtomicElement, &eTag ));
        if (eTag == TAGID_TD)
        {
            if (fStartOfSelection)
            {
                IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                        ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterBegin ) );
            }
            else
            {
                IFC( spElemPointer->MoveAdjacentToElement( pAtomicElement, (iDirection == LEFT) ?
                                                        ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );
            }
            IFC( pDispPointer->MoveToMarkupPointer(spElemPointer, NULL) );
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
EdUtil::GetBlockContainerAlignment( IMarkupServices *pMarkupServices, IHTMLElement *pElement, BSTR *pbstrAlign )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement         spBlockContainer;
    SP_IHTMLElement         spCurrentElement;
    SP_IHTMLElement         spNewElement;
    ELEMENT_TAG_ID          eTag = TAGID_NULL;

    Assert(pMarkupServices);
    if (!pMarkupServices)
        goto Cleanup;

    Assert(pElement);
    if (!pElement)
        goto Cleanup;

    Assert(pbstrAlign);
    if (!pbstrAlign)
        goto Cleanup;

    *pbstrAlign = NULL;

    IFR( GetParentElement(pMarkupServices, pElement, &spCurrentElement) );
    while (spCurrentElement != NULL)
    {
        IFR( pMarkupServices->GetElementTagId(spCurrentElement, &eTag) ); 

        if (eTag == TAGID_P ||
            eTag == TAGID_DIV)
        {
            spBlockContainer= spCurrentElement;
            break;
        }            
    
        IFR( GetParentElement(pMarkupServices, spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }

    if (spBlockContainer)
    {
        SP_IHTMLParaElement     spParaElement;
        SP_IHTMLDivElement      spDivElement;

        if ( spBlockContainer->QueryInterface(IID_IHTMLParaElement, (void **)&spParaElement) == S_OK )
        {
             if ( spParaElement )
             {
                 spParaElement->get_align(pbstrAlign);
             }
        }
        else if ( spBlockContainer->QueryInterface(IID_IHTMLDivElement, (void **)&spDivElement) == S_OK )
        {
             if ( spDivElement )
             {
                 spDivElement->get_align(pbstrAlign);
             }
        }
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\edptr.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDPTR.CXX
//
//  Contents:   CEditPointer implementation
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif 

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif 

#ifndef X_EDPTR_HXX_
#define X_EDPTR_HXX_
#include "edptr.hxx"
#endif 

#ifndef X_FLATPTR_HXX_
#define X_FLATPTR_HXX_
#include "flatptr.hxx"
#endif 

using namespace EdUtil;

extern HRESULT OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi );

//////////////////////////////////////////////////////////////////////////
//
//  CEditPointer's Constructor/Destructor Implementation
//
//////////////////////////////////////////////////////////////////////////

CEditPointer::CEditPointer(
    CEditorDoc *        pEd,
    IMarkupPointer *    pPointer /* = NULL */
#if DBG == 1 
    , LPCTSTR strDebugName /*=NULL*/
#endif 
)
{
    _pEd = pEd;
    _pPointer = NULL;
    _pLeftBoundary = NULL;
    _pRightBoundary = NULL;
    _fBound = FALSE;
    

    if( pPointer != NULL )
    {
        _pPointer = pPointer;
        _pPointer->AddRef();
    }
    else
    {
        IGNORE_HR( CreateMarkupPointer2( _pEd, & _pPointer ));
    }


#if DBG ==1 
    if ( strDebugName != NULL )
    {
        IEditDebugServices *pEditDebugServices = NULL;
        
        if (SUCCEEDED( _pEd->GetDoc()->QueryInterface( IID_IEditDebugServices, (LPVOID *) &pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(_pPointer, strDebugName) );
            
            pEditDebugServices->Release();            
        }
    }
#endif    
}
    

CEditPointer::CEditPointer(
    const CEditPointer& lp )
{
    _pEd = lp._pEd;
    
    if ((_pPointer = lp._pPointer) != NULL)
        _pPointer->AddRef();

    if ((_pLeftBoundary = lp._pLeftBoundary) != NULL)
        _pLeftBoundary->AddRef();

    if ((_pRightBoundary = lp._pRightBoundary) != NULL)
        _pRightBoundary->AddRef();

    _fBound = lp._fBound;
}


CEditPointer::~CEditPointer()
{
    ReleaseInterface( _pPointer );
    ReleaseInterface( _pLeftBoundary );
    ReleaseInterface( _pRightBoundary );
}



//////////////////////////////////////////////////////////////////////////
//
//  CEditPointer's Method Implementations
//
//////////////////////////////////////////////////////////////////////////



HRESULT
CEditPointer::SetBoundary(
    IMarkupPointer *    pLeftBoundary,
    IMarkupPointer *    pRightBoundary )
{
    HRESULT hr = S_OK;
#if DBG == 1
    BOOL fPositioned = FALSE;

    if( pLeftBoundary )
    {
        IGNORE_HR( pLeftBoundary->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer::SetBoundary passed unpositioned left boundary" );
    }

    if( pRightBoundary )
    {
        IGNORE_HR( pRightBoundary->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer::SetBoundary passed unpositioned right boundary" );
    }
#endif

    ReplaceInterface( & _pLeftBoundary , pLeftBoundary );
    ReplaceInterface( & _pRightBoundary , pRightBoundary );
    _fBound = TRUE;
    
    RRETURN( hr );
}

HRESULT
CEditPointer::SetBoundaryForDirection(
    Direction       eDir,
    IMarkupPointer* pBoundary )
{
    HRESULT hr = S_OK;

    if( eDir == LEFT )
        hr = THR( SetBoundary( pBoundary, NULL ));
    else
        hr = THR( SetBoundary( NULL, pBoundary ));

    RRETURN( hr );
}


HRESULT
CEditPointer::ClearBoundary()
{
    HRESULT hr = S_OK;
    ClearInterface( & _pRightBoundary );
    ClearInterface( & _pLeftBoundary );
    _fBound = FALSE;
    RRETURN( hr );
}


BOOL
CEditPointer::IsPointerInLeftBoundary()
{
    BOOL fWithin = TRUE;

    if( _fBound && _pLeftBoundary )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif
        IGNORE_HR( IsRightOfOrEqualTo( _pLeftBoundary, & fWithin )); // we are within if we are to the right or equal to the left boundary
    }
    
    return fWithin;
}


BOOL
CEditPointer::IsPointerInRightBoundary()
{
    BOOL fWithin = TRUE;

    if( _fBound && _pRightBoundary )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif
        IGNORE_HR( IsLeftOfOrEqualTo( _pRightBoundary, & fWithin )); // we are within if we are to the left or equal to the left boundary
    }
    
    return fWithin;
}


BOOL 
CEditPointer::IsWithinBoundary()
{  
    BOOL fWithin = TRUE;

    if( _fBound )
    {
#if DBG == 1
        BOOL fPositioned = FALSE;
        IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
        AssertSz( fPositioned , "CEditPointer has unpositioned pointer in IsWithinBoundary" );
#endif

        if( _pLeftBoundary )    
        {
            IGNORE_HR( IsRightOfOrEqualTo( _pLeftBoundary, & fWithin ));
        }

        if( fWithin && _pRightBoundary )
        {
            IGNORE_HR( IsLeftOfOrEqualTo( _pRightBoundary, & fWithin ));
        }
    }
    
    return fWithin;
}


BOOL
CEditPointer::IsWithinBoundary( 
    Direction               inDir )
{
    if( ! _fBound )
        return TRUE;
        
    if( inDir == LEFT )
    {
        return( IsPointerInRightBoundary() );       
    }
    else
    {
        return( IsPointerInLeftBoundary() );
    }
}


HRESULT
CEditPointer::Constrain()
{
    HRESULT hr = S_OK;

    if( _fBound )
    {
        if( ! IsPointerInLeftBoundary() )
        {
            Assert( _pLeftBoundary );
            IFC( _pPointer->MoveToPointer( _pLeftBoundary ));
        }

        if( ! IsPointerInRightBoundary() )
        {
            Assert( _pRightBoundary );
            IFC( _pPointer->MoveToPointer( _pRightBoundary ));
        }
    }
    
Cleanup:
    RRETURN( hr );
}



HRESULT
CEditPointer::Scan(
    Direction               eDir,
    DWORD                   eBreakCondition,
    DWORD *                 peBreakConditionFound,
    IHTMLElement **         ppElement,
    ELEMENT_TAG_ID *        peTagId,
    TCHAR *                 pChar,
    DWORD                   eScanOptions)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    BOOL fBlock = FALSE, fLayout = FALSE, fLayoutCalled;
    LONG lChars;
    TCHAR tChar = 0;
    DWORD dwContextAdjustment;
    MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;
    DWORD eBreakFound = BREAK_CONDITION_None;
    DWORD dwTest = BREAK_CONDITION_None;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID eTagId = TAGID_NULL;
    BOOL fIgnoreGlyphs = FALSE;
        
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pPointer->IsPositioned( & fPositioned ));
    AssertSz( fPositioned , "CEditPointer has unpositioned pointer in Scan" );
    AssertSz( eDir == LEFT || eDir == RIGHT , "CEditPointer is confused. The developer told it to scan in no particular direction." );
#endif


    // NOTE: (krisma) Despite how backwards this seems, 
    // we want to ignore glyphs if BREAK_CONDITION_Glyph is set,
    // otherwise we get the glyph's "text" instead of its
    // element
    if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph))
    {
        fIgnoreGlyphs = _pEd->IgnoreGlyphs(TRUE);
    }

    IFC( Constrain() );
    
    while( ! fDone )
    {
        lChars = 1;
        tChar = 0;
        dwContextAdjustment = 1;
        fLayoutCalled = FALSE;

        if(    ( eBreakCondition & BREAK_CONDITION_Text && ( ! CheckFlag( eScanOptions , SCAN_OPTION_ChunkifyText )))
            || ( eBreakCondition & BREAK_CONDITION_NoScopeBlock ))
        {
            hr = Move( eDir, TRUE, & eCtxt, & spElement, & lChars, &tChar );
        }
        else
        {
            hr = Move( eDir, TRUE, & eCtxt, & spElement, NULL, NULL) ;
        }
        
        if( hr == E_HITBOUNDARY )
        {
            fDone = TRUE;
            eBreakFound = BREAK_CONDITION_Boundary;
            hr = S_OK;
            break;
        }
        
        switch( eCtxt )
        {
            case CONTEXT_TYPE_ExitScope:
                dwContextAdjustment = 2;
                // FALL THROUGH
            case CONTEXT_TYPE_EnterScope:
            {
                IFC( _pEd->GetMarkupServices()->GetElementTagId( spElement, &eTagId ));
            
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Site ))
                {
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                    fLayoutCalled = TRUE;
                    if( fLayout )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterSite;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_TextSite ))
                {
                    BOOL fText = FALSE;
                    
                    if (!fLayoutCalled)
                    {
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                        fLayoutCalled = TRUE;
                    }

                    IFC(_pEd->GetDisplayServices()->HasFlowLayout(spElement, &fText));
                    
                    if( fLayout && fText )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterTextSite;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Block ))
                {
                    if (!fLayoutCalled)
                    {
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock));
                        fLayoutCalled = TRUE;
                    }

                    if ( fBlock && CheckFlag( eScanOptions, SCAN_OPTION_TablesNotBlocks ))
                    {
                        ELEMENT_TAG_ID eTag = TAGID_NULL; 
                        IFC( _pEd->GetMarkupServices()->GetElementTagId(spElement, & eTag));
                        if ( eTag == TAGID_TD || eTag == TAGID_TR || eTag == TAGID_TABLE )
                        {
                            fBlock = FALSE;
                        }
                    }
                    
                    if( fBlock )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterBlock;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_BlockPhrase ))
                {
                    if( eTagId == TAGID_RT || eTagId == TAGID_RP )
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterBlockPhrase;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Control ) )
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ))
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterControl;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                else if (eScanOptions & SCAN_OPTION_SkipControls)
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ) )
                    {
                        IFC( _pPointer->MoveAdjacentToElement(spElement, (eDir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                        continue;
                    }                    
                }
                
                            
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Anchor ))
                {
                    if( eBreakFound == BREAK_CONDITION_None && eTagId == TAGID_A ) // we didn't hit layout, block, intrinsic or no-scope
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterAnchor;
                        if( CheckFlag( eBreakCondition, dwTest ))
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Phrase ))
                {
                    if( eBreakFound == BREAK_CONDITION_None ) // we didn't hit layout, block, intrinsic, no-scope or anchor
                    {
                        dwTest = dwContextAdjustment * BREAK_CONDITION_EnterPhrase;

                        //
                        // AppHack:IE6 31832 (mharper) VS does drag-drop for Element Behaviors for which there is no IMPORT in the 
                        // Source document, nor a peerfactory in the target.  This causes us to treat them as phrase
                        // elements in FixupPhraseElements.  So we will break anyway if this is the case.
                        //
                        if( CheckFlag( eBreakCondition, dwTest ) || 
                            (eTagId == TAGID_GENERIC && eScanOptions & SCAN_OPTION_BreakOnGenericPhrase) ) 
                        {
                            eBreakFound |= dwTest;
                            fDone = TRUE;
                        }
                    }
                }
                
                if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph) )
                {
                    SP_IHTMLElement3    spElement3;
                    LONG                lGlyphMode;

                    IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                    IFC( spElement3->get_glyphMode(&lGlyphMode) );

                    if (lGlyphMode)
                    {
                        BOOL fHasGlyph = FALSE;
                        
                        switch (eCtxt)
                        {
                            case CONTEXT_TYPE_EnterScope:
                                fHasGlyph = (lGlyphMode & ((eDir == RIGHT) ? htmlGlyphModeBegin : htmlGlyphModeEnd));
                                break;
                                
                            case CONTEXT_TYPE_ExitScope:
                                fHasGlyph = (lGlyphMode & ((eDir == RIGHT) ? htmlGlyphModeEnd : htmlGlyphModeBegin));
                                break;
                        }
                        
                        if (fHasGlyph)
                        {
                            eBreakFound |= BREAK_CONDITION_Glyph;
                            fDone = TRUE;
                        }
                    }
                    
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoLayoutSpan ))
                {
                    if( eBreakFound == BREAK_CONDITION_None ) // we didn't hit layout, block, intrinsic, no-scope or anchor
                    {
                        if ( eTagId == TAGID_SPAN )
                        {
                            dwTest = dwContextAdjustment * BREAK_CONDITION_EnterNoLayoutSpan;
                            if( CheckFlag( eBreakCondition, dwTest ))
                            {
                                eBreakFound |= dwTest;
                                fDone = TRUE;
                            }
                        }
                    }
                }
                
                break;
            }

            case CONTEXT_TYPE_NoScope:
            {
                IFC( _pEd->GetMarkupServices()->GetElementTagId( spElement, &eTagId ));
            
                
                // this only looks a bit strange because there is no begin/end NoScope
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScope ))
                {
                    if( eCtxt == CONTEXT_TYPE_NoScope )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScope;
                        fDone = TRUE;
                    }
                }

                // Could be a noscope with layout. For example, an image.
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScopeSite ))
                {
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));
                    fLayoutCalled = TRUE;

                    if( fLayout )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScopeSite;
                        fDone = TRUE;
                    }
                }
                
                if( CheckFlag( eBreakCondition , BREAK_CONDITION_NoScopeBlock ))
                {
                    if (!fLayoutCalled)
                        IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock));

                    if( fBlock || eTagId == TAGID_BR )
                    {
                        eBreakFound |= BREAK_CONDITION_NoScopeBlock;
                        fDone = TRUE;
                    }
                }                

                if( CheckFlag( eBreakCondition , BREAK_CONDITION_Control ))
                {
                    if( IsIntrinsic( _pEd->GetMarkupServices(), spElement ))
                    {
                        eBreakFound |= BREAK_CONDITION_Control;
                        fDone = TRUE;
                    }
                }

                if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph) )
                {
                    SP_IHTMLElement3    spElement3;
                    LONG                lGlyphMode;

                    IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                    IFC( spElement3->get_glyphMode(&lGlyphMode) );

                    if (lGlyphMode)
                    {
                        eBreakFound |= BREAK_CONDITION_Glyph;
                        fDone = TRUE;
                    }
                    
                }

                break;                            
            }
            
            case CONTEXT_TYPE_Text:
            {
                if (CheckFlag( eBreakCondition , BREAK_CONDITION_Text )
                    && (   (   (eScanOptions & SCAN_OPTION_SkipWhitespace) 
                            && IsWhiteSpace(tChar))
                        || (   (eScanOptions & SCAN_OPTION_SkipNBSP) 
                            && tChar == WCH_NBSP)))
                {
                    continue; 
                }
                else if( CheckFlag( eBreakCondition , BREAK_CONDITION_Text ) && tChar != _T('\r') )
                {
                    eBreakFound |= BREAK_CONDITION_Text;
                    fDone = TRUE;
                }
                else if( CheckFlag( eBreakCondition, BREAK_CONDITION_NoScopeBlock ) && tChar == _T('\r'))
                {
                    eBreakFound |= BREAK_CONDITION_NoScopeBlock;
                    fDone = TRUE;
                }

                break;
            }

            case CONTEXT_TYPE_None:
            {
                // An error has occured
                eBreakFound |= BREAK_CONDITION_Error;
                fDone = TRUE;
                break;
            }
        }
    }
    
Cleanup:

    if (CheckFlag(eBreakCondition, BREAK_CONDITION_Glyph))
    {
        _pEd->IgnoreGlyphs(fIgnoreGlyphs);
    }
    
    if( peBreakConditionFound )
        *peBreakConditionFound = eBreakFound;
        
    if( ppElement )
    {
        ReplaceInterface( ppElement, spElement.p );
    }

    if( peTagId )
        *peTagId = eTagId;

    if( pChar )
        *pChar = tChar;
    
    RRETURN( hr );
}


HRESULT 
CEditPointer::Move(                                     // Directional Wrapper for Left or Right
    Direction               inDir,                      //      [in]     Direction of travel
    BOOL                    fMove,                      //      [in]     Should we actually move the pointer
    MARKUP_CONTEXT_TYPE*    pContext,                   //      [out]    Context change
    IHTMLElement**          ppElement,                  //      [out]    Element we pass over
    long*                   pcch,                       //      [in,out] number of characters to read back
    OLECHAR*                pchText )                   //      [out]    characters
{
    HRESULT hr = E_FAIL;
    
    Assert( _pPointer );
    
    if( inDir == LEFT )
    {
        IFC( _pPointer->Left( fMove, pContext, ppElement, pcch, pchText ));
    }
    else
    {
        IFC( _pPointer->Right( fMove, pContext, ppElement, pcch, pchText ));
    }

    if( ! IsWithinBoundary() )
    {
        Constrain();
        hr = E_HITBOUNDARY;
    }

Cleanup:
    RRETURN( hr );
}



//+====================================================================================
//
// Method: IsEqualTo
//
// Synopsis: Am I in the same place as the passed in pointer if I ignore dwIgnoreBreaks?
//
//------------------------------------------------------------------------------------

HRESULT 
CEditPointer::IsEqualTo( 
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    HRESULT hr = S_OK;
    BOOL fEqual = FALSE;
    Assert( pPointer );
    Assert( pfEqual );
    Direction dwWhichWayToPointer = SAME;

    IFC( OldCompare( this, pPointer, &dwWhichWayToPointer ));

    if( dwWhichWayToPointer == SAME )
    {
        // quick out - same exact place
        fEqual = TRUE;
    }
    else
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;
        dwSearch = ClearFlag( dwSearch , dwIgnore );

        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( dwWhichWayToPointer, pPointer ));
        IFC( ep.Scan( dwWhichWayToPointer, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;
        
    RRETURN( hr );
}


HRESULT
CEditPointer::IsLeftOfOrEqualTo(
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    BOOL fEqual;
    HRESULT hr = S_OK;

    IFC( this->IsLeftOfOrEqualTo( pPointer, &fEqual ));

    if( ! fEqual )
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;

        dwSearch = ClearFlag( dwSearch , dwIgnore );
        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( LEFT, pPointer ));
        IFC( ep.Scan( LEFT, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;

    RRETURN( hr );
}



HRESULT
CEditPointer::IsRightOfOrEqualTo(
    IMarkupPointer *        pPointer,
    DWORD                   dwIgnore,
    BOOL *                  pfEqual )
{
    BOOL fEqual;
    HRESULT hr = S_OK;

    IFC( this->IsRightOfOrEqualTo( pPointer, &fEqual ));

    if( ! fEqual )
    {
        CEditPointer ep( _pEd );
        DWORD dwSearch = BREAK_CONDITION_ANYTHING;
        DWORD dwFound = BREAK_CONDITION_None;
        
        dwSearch = ClearFlag( dwSearch , dwIgnore );
        IFC( ep->MoveToPointer( this ));
        IFC( ep.SetBoundaryForDirection( RIGHT, pPointer ));
        IFC( ep.Scan( RIGHT, dwSearch, & dwFound ));
        fEqual = dwFound == BREAK_CONDITION_Boundary;
    }
    
Cleanup:
    if( pfEqual )
        *pfEqual = fEqual;

    RRETURN( hr );
}



//+====================================================================================
//
// Method: Between
//
// Synopsis: Am I in - between the 2 given pointers ?
//
//------------------------------------------------------------------------------------

BOOL
CEditPointer::Between( 
    IMarkupPointer* pStart, 
    IMarkupPointer * pEnd )
{
    BOOL fBetween = FALSE;
    HRESULT hr;
#if DBG == 1
    BOOL fPositioned;
    IGNORE_HR( pStart->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pEnd->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( pStart->IsLeftOfOrEqualTo( pEnd, & fPositioned ));
    AssertSz( fPositioned, "Start not left of or equal to End" );
#endif

     IFC( IsRightOfOrEqualTo( pStart, & fBetween ));
     if ( fBetween )
     {
        IFC( IsLeftOfOrEqualTo( pEnd, & fBetween ));    // CTL_E_INCOMPATIBLE will bail - but this is ok              
     }
        
Cleanup:
    return fBetween;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\edevent.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

using namespace EdUtil;

#if DBG==1
#define CreateMarkupPointer(ppPointer)                      CreateMarkupPointer(ppPointer, L#ppPointer)
#define CreateMarkupPointer2(pMarkupServices, ppPointer)    CreateMarkupPointer2(pMarkupServices, ppPointer, L#ppPointer)
#endif

extern HRESULT 
GetParentElement(IMarkupServices *pMarkupServices, IHTMLElement *pSrcElement, IHTMLElement **ppParentElement);

const int GRAB_SIZE = 7 ;

MtDefine(CEditEvent, Utilities, "CEditEvent")
MtDefine(CHTMLEditEvent, Utilities, "CEditEvent")
MtDefine(CSynthEditEvent, Utilities, "CEditEvent")

CEditEvent::CEditEvent(CEditorDoc* pEditor) :
    _pEditor( pEditor ),
    _eType( EVT_UNKNOWN )
{
    _pEditor->AddRef();
    _fCancel = FALSE;
    _fCancelReturn = FALSE;     
    _fTransformedPoint = FALSE;
    _dwHitTestResult = 0;
    _fDoneHitTest = FALSE;

    _pDispCache = NULL;
    _dwCacheCounter = 0;
}

CEditEvent::CEditEvent( const CEditEvent* pEvent )
{
    if ( pEvent )
    {
        memcpy( this, pEvent, sizeof( *this ));
        _pEditor->AddRef();
    }

   _pDispCache = NULL;
   _fDoneHitTest = FALSE;
    
}

CEditEvent::~CEditEvent()
{
    Assert( _pEditor );
    _pEditor->Release();
    ReleaseInterface( _pDispCache );
    _pDispCache = NULL;
}

HRESULT 
CEditEvent::MoveDisplayPointerToEvent( 
                        IDisplayPointer* pDispPointer,
                        IHTMLElement* pIElement /*=NULL*/, 
                        BOOL fHitTestEndOfLine /*= FALSE */)                        
{
    HRESULT             hr;
    DWORD               dwOptions = 0;
    SP_IHTMLElement     spLayoutElement;
    POINT               pt;

    if ( pDispPointer == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if( _fDoneHitTest                   && 
        _fCacheEOL == fHitTestEndOfLine && 
        _dwCacheCounter == _pEditor->GetEventCacheCounter() )
    {
        Assert( _pDispCache );
        IFC( pDispPointer->MoveToPointer( _pDispCache ) );
    }
    else
    {       
        IFC( GetPoint( & pt ));
        if (fHitTestEndOfLine)
        {
            dwOptions |= HT_OPT_AllowAfterEOL;
        }

        //
        // Hit test, and cache the results of the hit test in a locally stored pointer
        //
        if( !_pDispCache )
            IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer( &_pDispCache ) );
        
        IFC( pDispPointer->MoveToPoint( pt, COORD_SYSTEM_GLOBAL, pIElement, dwOptions, &_dwHitTestResult) );
        IFC( _pDispCache->MoveToPointer( pDispPointer ) );

        _dwCacheCounter = _pEditor->GetEventCacheCounter();
        _fDoneHitTest = TRUE;
        _fCacheEOL = fHitTestEndOfLine;
    }

Cleanup:
    RRETURN(hr);
}


HRESULT 
CEditEvent::GetElementAndTagId( IHTMLElement** ppIElement, ELEMENT_TAG_ID *peTag )
{
    HRESULT hr = S_OK;

    Assert( ppIElement && peTag );

    IFC( GetElement( ppIElement ));
    if ( *ppIElement )
    {
        IFC( _pEditor->GetMarkupServices()->GetElementTagId( *ppIElement, peTag ));
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CEditEvent::GetTagId( ELEMENT_TAG_ID *peTag )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    Assert(  peTag );

    IFC( GetElement( & spElement  ));
    if ( spElement )
    {
        IFC( _pEditor->GetMarkupServices()->GetElementTagId( spElement, peTag ));
    }
    
Cleanup:
    RRETURN( hr );
}

IHTMLDocument2*
CEditEvent::GetDoc()
{
    Assert( _pEditor);
    
    return _pEditor->GetDoc();
}



#if DBG == 1

#define PRINT(Y) case EVT_##Y: wsprintfA(paryChar, "Type: EVT_%ls pt:%d,%d", _T(#Y) , pt.x, pt.y  );break;


VOID
CEditEvent::toString( char* paryChar )
{
    POINT pt;
    GetPoint( & pt );
    
    switch( GetType())
    {
        PRINT( MOUSEOVER );
        PRINT( LMOUSEDOWN );
        PRINT( LMOUSEUP );
        PRINT( RMOUSEDOWN );
        PRINT( RMOUSEUP );
        PRINT( MMOUSEDOWN );
        PRINT( MMOUSEUP );
        PRINT( INTDBLCLK );
        
        PRINT( MOUSEMOVE );
        PRINT( MOUSEOUT );
        PRINT( KEYUP );
        PRINT( KEYDOWN );
        PRINT( KEYPRESS );
        PRINT( DBLCLICK ); 
        PRINT( CONTEXTMENU );
        PRINT( TIMER );
        PRINT( CLICK );
        PRINT( LOSECAPTURE);
        
        default:
            AssertSz(0,"Unknown event");

            wsprintfA(
                paryChar,
                "UNKNOWN EVENT");        
    }
        
}

#undef PRINT 

#endif

//----------------------------------------------------------------------------------------
//
//              CHTMLEditEvent
//
//
//
//----------------------------------------------------------------------------------------

//
// ctors, and dtor
//
//

CHTMLEditEvent::CHTMLEditEvent( CEditorDoc* pEditor  )
    : CEditEvent( pEditor )
{
    _pEvent = NULL;
}

CHTMLEditEvent::~CHTMLEditEvent()
{
    ReleaseInterface( _pEvent );
}

CHTMLEditEvent::CHTMLEditEvent( const CHTMLEditEvent* pHTMLEditEvent )
    : CEditEvent( pHTMLEditEvent )
{
    if ( pHTMLEditEvent && pHTMLEditEvent->_pEvent )
    {
        _pEvent = pHTMLEditEvent->_pEvent ; 
        _pEvent->AddRef();
    }
    else
    {
        _pEvent = NULL;
    }
}

//
// Init
//

HRESULT
CHTMLEditEvent::Init( IHTMLEventObj * pObj , DISPID inDispId /*=0*/)
{
    HRESULT hr = S_OK ;

    ReplaceInterface( &_pEvent, pObj );

    if ( inDispId == 0 )
    {
        hr = THR( SetType());
    }
    else
        SetType( inDispId );

    RRETURN(hr);
}


//
// Virtuals
//
//

HRESULT 
CHTMLEditEvent::GetElement( IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;

    Assert(ppIElement);
    
    switch( _eType )
    {
        case EVT_MOUSEOVER:
        case EVT_MOUSEOUT:
            IFC( _pEvent->get_toElement( ppIElement ));
            
            break;
        case EVT_KILLFOCUS:
        case EVT_SETFOCUS:
            AssertSz(0,"GetElement invalid on killfocus/setfocus");
            hr = E_FAIL;
            break;
            
        default:
            SP_IHTMLElement spSrcElement;
            SP_IHTMLElement spActiveElement;
            IFC( _pEvent->get_srcElement( & spSrcElement ));            
            if ( spSrcElement.IsNull() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }        
            //
            //
            // Special case area's on top of img tags - as the OM chooses to return Area's here.
            //
            //
            ELEMENT_TAG_ID eTag ;
            IFC( _pEditor->GetMarkupServices()->GetElementTagId( spSrcElement, & eTag ));
            if ( eTag == TAGID_AREA )
            {
                SP_IHTMLElement spNewElement;
                if( GetImgElementForArea( spSrcElement, & spNewElement ) == S_OK )
                {
                    spSrcElement = spNewElement;
                }                    
            }

            //
            // Get the ActiveElement for the frame the doc is in.
            //

            IGNORE_HR( _pEditor->GetDoc()->get_activeElement ( & spActiveElement ));
            if ( spActiveElement )
            {
                IFC( ClipToElement( _pEditor, spActiveElement, spSrcElement, ppIElement ));
            }   
            else
            {   
                *ppIElement = spSrcElement;
                (*ppIElement)->AddRef();
            }

    }
    
Cleanup:
    if ( hr == S_OK && ( ! *ppIElement ))
    {
        hr = E_FAIL;
        AssertSz(0, "GetElement Failed");
    }
    RRETURN( hr );
}

//
// OM chooses to give us an AREA tag for an IMG element
// We prefer the IMG tag.
// Find it by BRUTE force
//

//
//
// A potential future work item - is to 
// expose getting an element collection from a rect.
//
// but brute force works ok. 
//

HRESULT
CHTMLEditEvent::GetImgElementForArea(IHTMLElement* pIElement, IHTMLElement** ppISrcElement )
{
    HRESULT hr;
    POINT pt;
    BOOL fFound = FALSE ;
    SP_IHTMLElement spSrcElement;    
    SP_IHTMLElementCollection spCollect;   
    long ctImages;
    VARIANT varIndex, varDummy;
    SP_IDispatch spDisp;
    SP_IHTMLElement spElement;
    SP_IHTMLElement2 spElement2;
    SP_IHTMLRect    spRect;
    SP_ISelectionServices spSelServ;
    SP_ISegmentList spSegList;
    int i;
    IFC( _pEditor->GetDoc()->get_images( & spCollect ));
    IFC( spCollect->get_length( & ctImages ));
    
    ::VariantInit( & varIndex );
    ::VariantInit( & varDummy );
    V_VT( &varDummy ) = VT_EMPTY;                
    V_VT( &varIndex) = VT_I4;
    IFC( GetPointInternal( pIElement, & pt )); // dont call getpoint - or you'll die a recursive death.                
    IFC( _pEditor->GetSelectionServices(&spSelServ) );
    IFC( spSelServ->QueryInterface( IID_ISegmentList, (void**)  & spSegList ));
    SELECTION_TYPE eType;
    IFC( spSegList->GetType(& eType ));
    
    for ( i = 0; i < ctImages; i ++ )
    {   
        V_I4( &varIndex) = i;                   
        IFC( spCollect->item( varIndex, varIndex  , & spDisp));
        IFC( spDisp->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
        IFC( spDisp->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));

        RECT rect; 
        IFC( spElement2->getBoundingClientRect(&spRect) );

        IFC( spRect->get_top(& rect.top ) );
        IFC( spRect->get_bottom(&rect.bottom) );
        IFC( spRect->get_left(&rect.left) );
        IFC( spRect->get_right(&rect.right) );
        if ( ::PtInRect(& rect, pt ))
        {
            spSrcElement = spElement;
            fFound = TRUE;
            break;
        }

        //
        // TODO this is heinous. we're going to guess what the size of the rect is
        // by using adorner size
        // we should either expose a GetElementReally on dispserv
        // or have a way in the OM to deduce the adorner size.
        //
        else if ( eType == SELECTION_TYPE_Control )
        {
            SP_ISegment spSegment;
            SP_IElementSegment spElementSegment;
            SP_IHTMLElement spCurElement;
            SP_IObjectIdentity spIdent;
            SP_ISegmentListIterator spIter;
            
            IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));                        
            IFC( spSegList->CreateIterator( & spIter ));

            while( spIter->IsDone() == S_FALSE )
            {
                IFC( spIter->Current( & spSegment ));
                IFC( spSegment->QueryInterface( IID_IElementSegment, (void**) & spElementSegment));
                IFC( spElementSegment->GetElement( & spCurElement));

                if ( spIdent->IsEqualObject( spCurElement ) == S_OK )
                {
                    InflateRect( & rect, GRAB_SIZE, GRAB_SIZE );

                    if ( ::PtInRect(& rect, pt ))
                    {
                        spSrcElement = spElement;
                        fFound = TRUE;
                        break;
                    }
                }
                IFC( spIter->Advance());
            }
        }                        
    }

Cleanup:

    if ( fFound )
    {
        *ppISrcElement = spElement;
        (*ppISrcElement)->AddRef();
    }

    if ( SUCCEEDED( hr ))
    {
        hr = fFound ? S_OK : S_FALSE;
    }
    
    RRETURN1( hr , S_FALSE );
}


HRESULT
CHTMLEditEvent::GetPoint( POINT * ppt)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;

    Assert( ppt );
        
    IFC( _pEvent->get_srcElement(&spElement) );
    Assert(spElement != NULL);

    IFC( GetPointInternal( spElement, ppt ));
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetPointInternal( IHTMLElement* pIElement, POINT * ppt )
{
    HRESULT hr;
    POINT           ptOrigin;
    Assert( ppt );
    IFC( EdUtil::GetClientOrigin( _pEditor, pIElement, &ptOrigin) );

    IFC( _pEvent->get_clientX( &_ptGlobal.x));
    IFC( _pEvent->get_clientY( &_ptGlobal.y));

    _ptGlobal.x += ptOrigin.x;
    _ptGlobal.y += ptOrigin.y;

    _fTransformedPoint = TRUE;

    *ppt = _ptGlobal;
    
Cleanup:
    RRETURN( hr );
}

BOOL
CHTMLEditEvent::IsShiftKeyDown()
{
    HRESULT hr;
    VARIANT_BOOL vbool;
    hr = THR( _pEvent->get_shiftKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}

BOOL
CHTMLEditEvent::IsControlKeyDown()
{
    VARIANT_BOOL vbool;
    HRESULT hr ;
    
    hr = THR( _pEvent->get_ctrlKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}


BOOL
CHTMLEditEvent::IsAltKeyDown()
{
    VARIANT_BOOL vbool;
    HRESULT hr ;
    
    hr = THR( _pEvent->get_altKey( & vbool ));

    Assert( SUCCEEDED( hr ));

    return ( BOOL_FROM_VARIANT_BOOL( vbool ) ); 
}

HRESULT 
CHTMLEditEvent::GetKeyCode(LONG* pkeyCode)
{
    HRESULT hr ;
    IFC( _pEvent->get_keyCode( pkeyCode ));
    Assert( SUCCEEDED( hr ));
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::SetType()
{
    HRESULT hr;
    BSTR bstrEvent=NULL;

    IFC( _pEvent->get_type(&bstrEvent));
    _eType = TypeFromString( bstrEvent );
    ::SysFreeString( bstrEvent );
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Cancel
//
// Synopsis: Cancel this OM Event.
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditEvent::Cancel()
{
    HRESULT hr = S_OK;

    VARIANT vboolCancel;
    vboolCancel.vt = VT_BOOL;
    vboolCancel.boolVal = FALSE;
    hr = THR( _pEvent->put_returnValue(vboolCancel));

    _fCancel = TRUE ;
    
    RRETURN( hr );

}
//+====================================================================================
//
// Method: CancelBubble
//
// Synopsis: Cancel the bubbling of this OM event.
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditEvent::CancelBubble()
{
    HRESULT hr ;
    VARIANT_BOOL varCancel = VB_TRUE;

    IFC( _pEvent->put_cancelBubble( varCancel ));

Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditEvent::SetType( DISPID inDispId )
{
    HRESULT hr = S_OK;

    _eType = TypeFromDispId( inDispId );
    
    RRETURN( hr );
}

#define MAP_EVENT(Y ) case DISPID_HTMLELEMENTEVENTS_ON##Y: eType = EVT_##Y; break;

EDIT_EVENT 
CHTMLEditEvent::TypeFromDispId( DISPID inDispId )
{
    EDIT_EVENT eType = EVT_UNKNOWN;

    switch( inDispId )
    {
        //
        // convert mouse down/ mouse up to a single event
        //

        //
        // TODO - what happens if they press both buttons at once - two OM events fired ?
        //
        case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN:
        {
            if ( IsLeftButton() )
                eType = EVT_LMOUSEDOWN;
            else if ( IsRightButton() )
                eType = EVT_RMOUSEDOWN;
            else
            {
                Assert( IsMiddleButton() );
                eType = EVT_MMOUSEDOWN;            
            }
        }
        break;

        case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP:
        {
            if ( IsLeftButton() )
                eType = EVT_LMOUSEUP;
            else if ( IsRightButton() )
                eType = EVT_RMOUSEUP;
            else
            {
                Assert( IsMiddleButton() );
                eType = EVT_MMOUSEUP;      
            }                
        }
        break;

        MAP_EVENT( MOUSEOVER );
        MAP_EVENT( MOUSEMOVE );
        MAP_EVENT( MOUSEOUT );
        MAP_EVENT( KEYUP );
        MAP_EVENT( KEYDOWN );
        MAP_EVENT( KEYPRESS );
        MAP_EVENT( DBLCLICK ); 
        MAP_EVENT( CONTEXTMENU );         
        MAP_EVENT( PROPERTYCHANGE);    
        MAP_EVENT( CLICK );
        MAP_EVENT( LOSECAPTURE);
        default:
            eType = EVT_UNKNOWN;
    }
    
    return eType;
}

EDIT_EVENT 
CHTMLEditEvent::TypeFromString( BSTR bstrEvent )
{
    EDIT_EVENT eType = EVT_UNKNOWN;

    if (! StrCmpICW (bstrEvent, L"mousemove"))
    {
        eType = EVT_MOUSEMOVE;
    }
    else if (! StrCmpICW ( bstrEvent, L"mouseover"))
    {
        eType = EVT_MOUSEOVER;
    }
    else if (! StrCmpICW (bstrEvent, L"mousedown"))
    {
        if ( IsLeftButton() )
            eType = EVT_LMOUSEDOWN;
        else if ( IsRightButton() )
            eType = EVT_RMOUSEDOWN;
        else
            eType = EVT_MMOUSEDOWN;            
    }
    else if (! StrCmpICW (bstrEvent, L"mouseup"))
    {
        if ( IsLeftButton() )
            eType = EVT_LMOUSEUP;
        else if ( IsRightButton() )
            eType = EVT_RMOUSEUP;
        else
            eType = EVT_MMOUSEUP; 
    }
    else if (! StrCmpICW (bstrEvent, L"intrnlDblClick"))
    {
        eType = EVT_INTDBLCLK;
    }
    else if (! StrCmpICW (bstrEvent, L"propertychange"))
    {
        eType = EVT_PROPERTYCHANGE;
    }         
    else if (! StrCmpICW (bstrEvent, L"focus"))
    {
        eType = EVT_SETFOCUS;
    }
    else if (! StrCmpICW (bstrEvent, L"blur"))
    {
        eType = EVT_KILLFOCUS ;
    }    
    else if (! StrCmpICW (bstrEvent, L"startComposition"))
    {
        eType = EVT_IME_STARTCOMPOSITION ;
    } 
    else if (! StrCmpICW (bstrEvent, L"endComposition"))
    {
        eType = EVT_IME_ENDCOMPOSITION ;
    } 
    else if (! StrCmpICW (bstrEvent, L"compositionFull"))
    {
        eType = EVT_IME_COMPOSITIONFULL;
    } 
    else if (! StrCmpICW (bstrEvent, L"char"))
    {
        eType = EVT_IME_CHAR;
    } 
    else if (! StrCmpICW (bstrEvent, L"composition"))
    {
        eType = EVT_IME_COMPOSITION;
    } 
    else if (! StrCmpICW (bstrEvent, L"notify"))
    {
        eType = EVT_IME_NOTIFY;
    } 
    else if (! StrCmpICW (bstrEvent, L"inputLangChange"))
    {
        eType = EVT_INPUTLANGCHANGE;
    } 
    else if (! StrCmpICW (bstrEvent, L"imeRequest"))
    {
        eType = EVT_IME_REQUEST;
    } 
    else if (! StrCmpICW (bstrEvent, L"click"))
    {
        eType = EVT_CLICK;
    } 
    else if (! StrCmpICW (bstrEvent, L"losecapture"))
    {
        eType = EVT_LOSECAPTURE;
    }
    else if (! StrCmpICW (bstrEvent, L"imeReconversion"))
    {
        Assert( FALSE );    // this has not been implemented yet
        eType = EVT_IME_RECONVERSION;
    }
    return eType;
}


BOOL 
CHTMLEditEvent::IsLeftButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( (b & 1) != 0 );
}

BOOL 
CHTMLEditEvent::IsRightButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( (b & 2) != 0 );

}

BOOL 
CHTMLEditEvent::IsMiddleButton()
{
    HRESULT hr ;
    LONG b;

    hr = THR( _pEvent->get_button( & b ));
    Assert( SUCCEEDED( hr ));

    return ( ( b & 4 ) != 0 );

}

HRESULT
CHTMLEditEvent::GetShiftLeft(BOOL* pfShiftLeft)
{
    VARIANT_BOOL vbShift;
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    Assert( pfShiftLeft );
    
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));
    
    hr = THR( spObj3->get_shiftLeft ( & vbShift));
    Assert( SUCCEEDED( hr ));

    *pfShiftLeft =  vbShift == VB_TRUE ;
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetCompositionChange( LONG_PTR * plParam )
{
    Assert( GetType() == EVT_IME_COMPOSITION );
    Assert( plParam );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeCompositionChange( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetNotifyCommand( LONG_PTR* pLong)
{
    Assert( GetType() == EVT_IME_NOTIFY );
    HRESULT hr;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));
    
    hr = THR( spObj3->get_imeNotifyCommand( pLong ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetNotifyData(LONG_PTR* plParam)
{
    Assert( GetType() == EVT_IME_NOTIFY );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeNotifyData( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetIMERequest(LONG_PTR *pwParam)
{
    Assert( GetType() == EVT_IME_REQUEST );
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeRequest( pwParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetIMERequestData(LONG_PTR *plParam)
{
    Assert( GetType() == EVT_IME_REQUEST );
    HRESULT hr;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_imeRequestData( plParam ));
    Assert( SUCCEEDED(hr));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::GetKeyboardLayout(LONG_PTR *plParam)
{
    Assert( GetType() == EVT_INPUTLANGCHANGE);
    HRESULT hr ;
    SP_IHTMLEventObj3 spObj3;
    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj3, (void**)&spObj3));

    hr = THR( spObj3->get_keyboardLayout( plParam ));

Cleanup:
    RRETURN( hr );
}    

HRESULT
CHTMLEditEvent::GetFlowElement(IHTMLElement** ppIElement)
{
    HRESULT hr ;
    SP_IDisplayPointer spDisplayPointer;

    if( _fDoneHitTest )
    {
        IFC( _pDispCache->GetFlowElement( ppIElement ) );
    }
    else
    {
        IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer( & spDisplayPointer ));
        IFC( MoveDisplayPointerToEvent( spDisplayPointer));
        IFC( spDisplayPointer->GetFlowElement( ppIElement));
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditEvent::IsInScrollbar()
{
    HRESULT hr = S_FALSE;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spParent;
    SP_IHTMLElement2 spElement2;
    BSTR bstrScroller = NULL;
    POINT pt;
    BOOL fScrollable;

    //  Need to bubble this up.  The scrolling element may be a parent of the
    //  element where the event occurred.

    IFC( GetFlowElement( & spElement ));
    while (spElement)
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, NULL, &fScrollable));

        if (fScrollable)
        {
            IFC( spElement->QueryInterface( IID_IHTMLElement2, ( void**) & spElement2 ));
            IFC( GetPoint( & pt ));
            
            IFC( spElement2->componentFromPoint( pt.x, pt.y, & bstrScroller ));

            if (IsScrollerPart(bstrScroller))
            {
                hr = S_OK;
                break;
            }
        }

        IFC(GetParentElement(_pEditor->GetMarkupServices(), spElement, &spParent));
        spElement = spParent;
    }

    hr = (spElement != NULL) ? S_OK : S_FALSE;
    
Cleanup:

    ::SysFreeString( bstrScroller );
    RRETURN1( hr, S_FALSE );
}

HRESULT
CHTMLEditEvent::GetPropertyChange( BSTR* pBstr )
{
    HRESULT hr ;
    SP_IHTMLEventObj2 spObj2;

    IFC( _pEvent->QueryInterface( IID_IHTMLEventObj2, ( void**) & spObj2 ));
    IFC( spObj2->get_propertyName( pBstr ));
Cleanup:
    RRETURN( hr );
}

BOOL
CHTMLEditEvent::IsScrollerPart(BSTR inBstrPart )
{
    BOOL fScroller = FALSE;
    BSTR bstrPart = ::SysAllocStringLen( inBstrPart, 9 );

    if (!bstrPart)
        goto Cleanup;

    if (!StrCmpICW (bstrPart, L"scrollbar"))
    {
        fScroller = TRUE;
    }
    ::SysFreeString( bstrPart );

Cleanup:
    return fScroller;
}

HRESULT 
CHTMLEditEvent::GetMasterElement(IHTMLElement *pSrcElement, IHTMLElement **ppMasterElement)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;    
    SP_IMarkupPointer   spPointer;    
    SP_IDisplayPointer  spDispPointer;

    Assert(ppMasterElement);
    *ppMasterElement = NULL;

    IFC( pSrcElement->get_parentElement(&spElement) );

    // If we have a parent, we are not a txt slave or root element, so return
    // the current element

    if (spElement != NULL)
    {
        *ppMasterElement = pSrcElement;
        pSrcElement->AddRef();
        goto Cleanup;
    }

    //
    // Otherwise, return the flow element
    //

    IFC( _pEditor->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pSrcElement, ELEM_ADJ_AfterBegin) );

    IFC( _pEditor->GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
    IFC( spDispPointer->GetFlowElement(ppMasterElement) );

Cleanup:
    RRETURN(hr);    
}

//----------------------------------------------------------------------------------------
//
//              CHTMLEditEvent
//
//
//
//----------------------------------------------------------------------------------------

//
// ctors, and dtor
//
//

CSynthEditEvent::CSynthEditEvent( CEditorDoc* pEditor  )
                    : CEditEvent( pEditor )
{
    _pt.x = -1;
    _pt.y = -1;
}

CSynthEditEvent::~CSynthEditEvent()
{

}

CSynthEditEvent::CSynthEditEvent( const CSynthEditEvent* pEvent )
                    : CEditEvent( pEvent )
{
    if ( pEvent)
    {
        _pt.x = pEvent->_pt.x;
        _pt.y = pEvent->_pt.y;
    }
    else
    {
        _pt.x = -1;
        _pt.y = -1;
    }
}
    
HRESULT 
CSynthEditEvent::Init( const POINT* pt, EDIT_EVENT eType )
{    
    _pt = *pt;
    _eType = eType;

    return S_OK;
}

HRESULT 
CSynthEditEvent::GetElement( IHTMLElement** ppIElement ) 
{
    AssertSz( 0, "Invalid call to CSynthEditEvent::GetElement()" );
    return E_NOTIMPL;
}



HRESULT 
CSynthEditEvent::GetPoint( POINT * ppt )  
{
    Assert( ppt );
    ppt->x = _pt.x;
    ppt->y = _pt.y;

    return S_OK;
}

BOOL 
CSynthEditEvent::IsShiftKeyDown()  
{
    return ( GetKeyState(VK_SHIFT) & 0x8000) ;
}

BOOL 
CSynthEditEvent::IsControlKeyDown()  
{
    return (GetKeyState(VK_CONTROL) & 0x8000) ;
}

BOOL 
CSynthEditEvent::IsAltKeyDown()  
{
   // return (GetKeyState(VK_ALT) & 0x8000) ;
   return FALSE;
}

HRESULT 
CSynthEditEvent::GetKeyCode(LONG * pkeyCode)  
{
    return E_FAIL;
}

HRESULT 
CSynthEditEvent::Cancel()
{
    return E_FAIL; // cancelling won't do anything let the person who called this know
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\edunits.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MALLOC_H_
#define X_MALLOC_H_
#include "malloc.h"
#endif

#ifndef X_EDUNITS_HXX_
#define X_EDUNITS_HXX_
#include "edunits.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

using namespace EdUtil;

extern BOOL g_fInVizAct2000  ;

/////////////////////////////////////////////////////////////////////////////
static const WCHAR* s_pwszPixUnits = L"px";
#define EDU_THOUSANDTHS_OF_PIXEL 1000
/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetLeft
// Sets new Left of the positioned element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetLeft(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT hr = S_OK;

    IFC(GetPixelLeft(pIElement));

    AdjustLeftDimensions(pIElement, &lNewValue);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtLeft;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtLeft );
        V_VT( & vtLeft ) = VT_I4;
        V_I4( & vtLeft ) = lNewValue ;
        hr = spStyle->put_left( vtLeft );
        VariantClear (&vtLeft);

        goto Cleanup;
    }

    IFC (ExtractCurrentLeft(pIElement));

    IFC (SetLeftValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetTop
// Sets new Top of the positioned element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetTop(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT hr = S_OK;

    IFC(GetPixelTop(pIElement));

    AdjustTopDimensions(pIElement, &lNewValue);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtTop;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtTop );

        V_VT( & vtTop ) = VT_I4;
        V_I4( & vtTop ) = lNewValue ;

        hr = spStyle->put_top( vtTop );
        VariantClear (&vtTop);

        goto Cleanup;
    }
    
    IFC (ExtractCurrentTop(pIElement));

    IFC (SetTopValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetHeight
// Sets new height of the element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetHeight(IHTMLElement* pIElement, long lNewValue, ELEMENT_TAG_ID eTag)
{
    HRESULT hr = S_OK;

    if (lNewValue <= 0)
        goto Cleanup; // just ignore it. Negative values may come from mouse movements

    if (_lPixValue <= 0)
    {
        IFC(GetPixelHeight(pIElement));
    }
    
    AdjustHeightDimensions(pIElement, &lNewValue,eTag);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtHeight;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtHeight );
        V_VT( & vtHeight ) = VT_I4;
        V_I4( & vtHeight ) = lNewValue ;
        hr = spStyle->put_height( vtHeight );
        VariantClear (&vtHeight);

        goto Cleanup;
    }

    IFC (ExtractCurrentHeight(pIElement));

    IFC (SetHeightValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::SetWidth
// Sets new width of the element using new value in pixels, 
// the stored units, previous value in units and previous value in pixels
//
HRESULT 
CEdUnits::SetWidth(IHTMLElement* pIElement, long lNewValue, ELEMENT_TAG_ID eTag)
{
    HRESULT hr = S_OK;

    if (lNewValue <= 0)
        goto Cleanup; // just ignore it. Negative values may come from mouse movements

    if (_lPixValue <= 0)
    {
       IFC (GetPixelWidth(pIElement));
    }
    AdjustWidthDimensions(pIElement, &lNewValue,eTag);

    // appcompat fix for vizact and other apps
    if (g_fInVizAct2000)    
    {
        SP_IHTMLStyle spStyle ;
        VARIANT vtWidth;
        
        IFC(pIElement->get_style(&spStyle));

        VariantInit( & vtWidth );

        V_VT( & vtWidth ) = VT_I4;
        V_I4( & vtWidth ) = lNewValue ;

        hr = spStyle->put_width( vtWidth );

        VariantClear( &vtWidth );

        goto Cleanup;
    }


    IFC (ExtractCurrentWidth(pIElement));

    IFC (SetWidthValue(pIElement,lNewValue));

Cleanup:
    RRETURN (hr);
}   

////////////////////////////////////////////////////////////////////
//
// CEdUnits::ExtractValueFromVariant
//
// Extracts value in units and the unit designator from a VARIANT (V_BSTR)
// The string looks like Xu where X is a floating point number
// and u is a unit designator ("px", "mm", etc).
//
HRESULT CEdUnits::ExtractValueFromVariant(VARIANT v)
{
    // VARIANT must be V_BSTR, otherwise there is no information on units
    if (V_VT(&v) == VT_BSTR)
    {
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {    
            return ExtractUnitValueFromString(V_BSTR(&v));
        }
        // if the string is empty, the fall down to default units
    }
    else 
    { 
        Assert(V_VT(&v) == VT_EMPTY);    
    } // if the VARIANT is not string, then it must be VT_EMPTY

     _rUnitValue = (double)_lPixValue;
     
    if(_bstrUnits)
        ::SysFreeString(_bstrUnits);

    _bstrUnits = ::SysAllocString(s_pwszPixUnits);
    return NULL != _bstrUnits ? S_OK : E_OUTOFMEMORY;
}

/////////////////////////////////////////////////////////////////////////////
//
// CEdUnits::ExtractUnitValueFromString
//
// Extracts value in units and the unit designator from a string
// The string looks like Xu where X is a floating point number
// and u is a unit designator ("px", "mm", etc).
//
// NOTE: The method does no accept scientific notation like .5E+6
// Also I don't attempt to handle something like "width=A08@#$%"
// This will end up as width = 0 units A08@#$% 
//
HRESULT CEdUnits::ExtractUnitValueFromString(WCHAR* pwszValue)
{
    HRESULT hr = E_FAIL;
    WCHAR*  pwsz = NULL;
    WCHAR*  pwszUnits = NULL;
    int iSign = 0;
    
    pwszUnits = pwszValue;

    // skip spaces if any
    while(*pwszUnits && ::iswspace(*pwszUnits))
        pwszUnits++;

    if (_tcslen(pwszUnits) > 0)
    {
        if ( pwszUnits[0] == _T('+') || pwszUnits[0] == _T('-') )
        {
            iSign = (pwszUnits[0] == _T('+')) ? +1 : -1 ;
            pwszUnits++;
        }

        // First get the integer part of the value in units     
        _rUnitValue = (double)::_wtoi(pwszUnits);
    
        // skip up to the decimal point, if any 
        pwsz = pwszValue;
        while(*pwsz && '.' != *pwsz)
            pwsz++;

        // if the dot is found then there is a fractional part
        if(0 != *pwsz)
        {    
            double div = 10;
            int count = 0;

            pwsz++;    // skip the decimal point
            // Convert fractional part (up to 4 digits)
            while(*pwsz && *pwsz >= L'0' && *pwsz <= L'9' && count < 4)
            {    // convert fractional part
                _rUnitValue += ((double) (*pwsz - L'0'))/div;

                div *= 10;
                count++;
                pwsz++;
            }
        }
        else // if there is no decimal point, then units follow (possibly prepended by tab and/or spaces)
            pwsz = pwszUnits;

        // skip numerical part (either the value when it is like "809px" or the remaining 
        // part of the fraction if value looks like "70.123456 mm"
        while(*pwsz && *pwsz >= L'0' && *pwsz <= L'9')
            pwsz++;

        // now skip spaces...
        while(*pwsz && ::iswspace(*pwsz))
            pwsz++;

        if (iSign != 0)
            _rUnitValue *= iSign ;
  
        // and what remains is the unit designator
        if (_tcsicmp(pwsz, s_pwszPixUnits) == 0)
        {
            _rUnitValue = (double)_lPixValue ;
        }
    }
    else
    {
        _rUnitValue = (double)_lPixValue ;
    }
    if (_bstrUnits)
        ::SysFreeString(_bstrUnits);

    _bstrUnits = ::SysAllocString(*pwsz ? pwsz : s_pwszPixUnits); 
    hr = NULL != _bstrUnits ? S_OK : E_OUTOFMEMORY; 

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// CEdUnits::MakeVariant
//
// Constructs VARIANT (VT_BSTR) from pixel value.
// The pixel value gets converted into value in units.
//
HRESULT CEdUnits::MakeVariant(long lNewPixValue, VARIANT* pv, BOOL fOverrideAuto /*=TRUE*/)
{
    double rNewValue;
    WCHAR* pwsz;
    int    iValue = 0;
    BOOL   fNeedToCalculateValue=TRUE;
    
    Assert(_bstrUnits);
    Assert(V_VT(pv) == VT_EMPTY);

    pwsz = (WCHAR*)::_alloca(sizeof(WCHAR)*::wcslen(_bstrUnits) + 64); // should be sufficient to print out double value

    if ( StrCmpIW(_T("auto"), _bstrUnits ) == 0)
    {
        if (fOverrideAuto)
        {
            _tcscpy(_bstrUnits, s_pwszPixUnits);
            _rUnitValue = (double)_lPixValue;
        }
        else
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%ls",_bstrUnits);
            fNeedToCalculateValue = FALSE;
        }
    }

    if (fNeedToCalculateValue)
    {
        // Simple proportion to calculate new value in units
        if (_rUnitValue == 0)
            _rUnitValue = 0.01;

        if (_lPixValue != 0)
        {
            rNewValue = (double)lNewPixValue/(double)_lPixValue * _rUnitValue;
        }
        else
        {
            rNewValue = (double)lNewPixValue;
        }

        if (rNewValue >= 0)
            iValue = (int)(rNewValue + 0.5);
        else
            iValue = (int)(rNewValue - 0.5);

        // If the value has fractional part, round it to 3 digits after period
        // If it does no have fractional part, print it out as an integer
        // The append units designator
        if (((rNewValue - (double)iValue) < 0.001 && (rNewValue - (double)iValue) > -0.001)  ||
             0 == ::_wcsicmp(_bstrUnits, s_pwszPixUnits))
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%2d%ls",iValue, _bstrUnits);
        }
        else if (rNewValue < 0)
        {
            //  rNewValue could be between 0 and -1, in which case the fractional part
            //  calculations will give a negative number.  We need to make rNewValue
            //  positive and then do our calculations and generate a negative output.

            rNewValue *= -1;
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"-%d.%03d%ls", (int)rNewValue, (int)(1000*rNewValue) - 1000*((int)rNewValue), _bstrUnits);
            rNewValue *= -1;
        }
        else
        {
            StringCchPrintfW(pwsz,wcslen(_bstrUnits)+(64/sizeof(WCHAR)),L"%3d.%03d%ls", (int)rNewValue, (int)(1000*rNewValue) - 1000*((int)rNewValue), _bstrUnits);
        }
    }
            
    
    V_VT(pv)   = VT_BSTR;
    V_BSTR(pv) = ::SysAllocString(pwsz) ;
    
    if (NULL == V_BSTR(pv))
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT 
CEdUnits::ExtractLeftFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_left(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
        else
        {
            IFC(GetCurrentStyleLeft(pIElement));
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractTopFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_top(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
        else
        {
            IFC (GetCurrentStyleTop(pIElement));
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractHeightFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT hr = S_OK ;
    VARIANT v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_height(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}

HRESULT 
CEdUnits::ExtractWidthFromElementStyle(IHTMLElement* pIElement)
{
    SP_IHTMLStyle  spStyle;
    HRESULT        hr = S_OK ;
    VARIANT        v;

    VariantInit(&v);

    _fChangeStyle = FALSE;

    // Check if style is present. It is always present in IE4 and IE5, but can be empty
    IFC(pIElement->get_style(&spStyle));
    if (spStyle != NULL)
    {
        // Get value specified in the style. This value is V_BSTR and can be empty
        // Also get pixel value - always exists and meaningful
        spStyle->get_width(&v);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&v) == VT_BSTR);
        if (NULL != V_BSTR(&v) && ::wcslen(V_BSTR(&v)) > 0)
        {   
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(v)))
                _fChangeStyle = TRUE;
        }
    }
    else
    { 
        Assert(FALSE); 
    } // The element always has a style

Cleanup:
    VariantClear(&v);
    return _fChangeStyle ? S_OK : S_FALSE;
}


HRESULT
CEdUnits::ExtractCurrentLeft(IHTMLElement* pIElement)
{
    HRESULT         hr = S_OK ;
    SP_IHTMLStyle   spStyle;

    // First try to extract value from element's style first. 
    // This method will NOT set default (pixel) units, if the style is not present
    hr = ExtractLeftFromElementStyle(pIElement);
    if (S_FALSE == hr) // the style is not present
    {
        // The style is not present.
        // Try to get left or top from the element tag. This valid only for certain elements:
        // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea
        _fChangeStyle = TRUE;
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
    }
    RRETURN (S_OK); 
}

HRESULT
CEdUnits::ExtractCurrentTop(IHTMLElement* pIElement)
{
    HRESULT         hr = S_OK ;
    SP_IHTMLStyle   spStyle;

    // First try to extract value from element's style first. 
    // This method will NOT set default (pixel) units, if the style is not present
    hr = ExtractTopFromElementStyle(pIElement);
    if (S_FALSE == hr) // the style is not present
    {
        // The style is not present.
        // Try to get left or top from the element tag. This valid only for certain elements:
        // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea
        _fChangeStyle = TRUE;
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
    }

    RRETURN (S_OK); 
}

HRESULT
CEdUnits::ExtractCurrentHeight(IHTMLElement* pIElement)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtOldHeight ;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    SP_IHTMLSelectElement   spSelectElement;
    LONG                    lDimension = 0 ;

    VariantInit( &vtOldHeight);

    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
    {
        if (SUCCEEDED(spTextAreaElement->get_rows(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue) /lDimension ;   // for rows of text area
            }
        }
    }
    //
    // IE #13629 : Adding the case for the Size of the Select Element ( for the select element, the 
    // size signifies the number of rows) 
    //
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLSelectElement, (void**)&spSelectElement)) )
    {
        if ( SUCCEEDED(spSelectElement->get_size(&lDimension)) )
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension; 
            }
        }
    }


    //
    // IE #13629 : If the CSS Editing Level is 0 then we shouldn't care about
    // either the style or the currentStyle, so if the CSS level is 0, we
    // skip these.
    //

    if ( GetCSSEditingLevel() )
    {
        // First try to extract value from element's style first. 
        // This method will NOT set default (pixel) units, if the style is not present
        hr = ExtractHeightFromElementStyle(pIElement);

        if (S_FALSE == hr) // the inline style is not present
        {
            // try to get the style from style sheet rules, look for currentstyle documentation 
            // see whether the stylesheet rules values 
            hr = GetCurrentStyleHeight(pIElement);
        }        
    }

    _fChangeHTMLAttribute = FALSE;

    // Try to get width or height from the element tag. This valid only for certain elements:
    // table, table cell, control (<OBJECT>), embed, marquee, select(size), input(size), applet, textarea

    //
    //  check to see whether the element attribute needs an update
    //
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
    {
        if (SUCCEEDED(spTable->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
    {
        if (SUCCEEDED(spTableCell->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        if (SUCCEEDED(spImageElement->get_height(&_lPixValue)))
        {
            _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
    {
        if ( (SUCCEEDED(spHRElement->get_size(&vtOldHeight))) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0)
            || !_fChangeStyle)
        {
            _fChangeHTMLAttribute = TRUE;
 
            if (SUCCEEDED(pIElement->get_offsetHeight(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
    {
        if (SUCCEEDED(spEmbedElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
    {
        if (SUCCEEDED(spMarqueeElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
    {
        if (SUCCEEDED(spObjectElement->get_height(&vtOldHeight)) &&
            (NULL != V_BSTR(&vtOldHeight) && ::wcslen(V_BSTR(&vtOldHeight)) > 0))
        {
            if (SUCCEEDED(ExtractValueFromVariant(vtOldHeight)))
                _fChangeHTMLAttribute = TRUE;
        }
    }

    //
	// If we have no indication so var as to whether we will be changing the 
	// style or the attribute, we would apply this value to the the style
	// *if and only if* the CSS editing level is not 0
	//
		
    if (!_fChangeHTMLAttribute && !_fChangeStyle && GetCSSEditingLevel())
    {
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
        _fChangeStyle    = TRUE ;
        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;    // don't care, if you come here, means you will live long 
    }    

Cleanup :
    VariantClear(&vtOldHeight);
    RRETURN (hr); 
}

HRESULT
CEdUnits::SetLeftValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT        hr = S_OK ;
    VARIANT        vtLeft; 
    SP_IHTMLStyle  spStyle;

    // Create a VARIANT (BSTR with value in units) out of the value in pixels
    VariantInit(&vtLeft);
    IFC (MakeVariant(lNewValue, &vtLeft));

    // If the original value was in a style, apply new to the style
    if (_fChangeStyle && GetCSSEditingLevel())
    {
        // Check if style is present. It is always present in IE4 and IE5, but can be empty
        IFC(pIElement->get_style(&spStyle));
        IFC (spStyle->put_left(vtLeft));
    }

 Cleanup :
    VariantClear (&vtLeft);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::SetTopValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT        hr = S_OK ;
    VARIANT        vtTop ; 
    SP_IHTMLStyle  spStyle;

    // Create a VARIANT (BSTR with value in units) out of the value in pixels
    VariantInit(&vtTop);
    IFC (MakeVariant(lNewValue, &vtTop));

    // If the original value was in a style, apply new to the style
    if (_fChangeStyle && GetCSSEditingLevel())
    {
        // Check if style is present. It is always present in IE4 and IE5, but can be empty
        IFC(pIElement->get_style(&spStyle));
        IFC (spStyle->put_top(vtTop));
    }

 Cleanup :
    VariantClear (&vtTop);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::SetHeightValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtHeight ; 
    VARIANT                 vtNull;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    SP_IHTMLSelectElement   spSelectElement;
    LONG                    lDimension = 0 ;

    VariantInit(&vtHeight);
    
    // IE# 18704 If CSSEditingLevel is Zero, then we need to make sure that there are no in-line 
    // styles that will mess us up
    if ( !GetCSSEditingLevel() )
    {

        VariantInit(&vtNull);
        V_VT(&vtNull) = VT_BSTR;
        V_BSTR(&vtNull) = NULL;
        IFC (pIElement->get_style(&spStyle) );
        IFC (spStyle->put_height(vtNull) );

    }

    if (!_fChangeStyle && SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        hr = spImageElement->put_height(lNewValue);
        goto Cleanup;
    }

    if (_lCharDimension > 0 )
    {
        if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;   // for rows of textarea
            hr = spTextAreaElement->put_rows(lDimension);
        }
        else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLSelectElement, (void**)&spSelectElement)))
        {
            if (GetCSSEditingLevel() == 0)
            {
                lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;
                hr = spSelectElement->put_size(lDimension);
            }
        }
    } // fall through to set the default height
    

    //
    // Because of the change in the default case in ExtractCurrentXXXX for 
    // CSS Editing Level 0, there is the possibility that this MakeVariant is not
    // necessary
    //

    if(_fChangeStyle || _fChangeHTMLAttribute)
    {
        // Create a VARIANT (BSTR with value in units) out of the value in pixels
        IFC (MakeVariant(lNewValue, &vtHeight));

        // If the original value was in a style, apply new to the style
        if (_fChangeStyle && GetCSSEditingLevel())
        {

            // Check if style is present. It is always present in IE4 and IE5, but can be empty
            IFC(pIElement->get_style(&spStyle));
            IFC (spStyle->put_height(vtHeight));
        } 

        // Not in a style - apply value depending on the element type
        if (_fChangeHTMLAttribute || GetCSSEditingLevel() == 0)
        {
            if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
            {
                hr = spTable->put_height(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
            {
                hr = spTableCell->put_height(vtHeight);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
            {
                hr = spHRElement->put_size(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
            {
                hr = spEmbedElement->put_height(vtHeight);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
            {
                hr = spMarqueeElement->put_height(vtHeight);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
            {
                hr = spObjectElement->put_height(vtHeight);
            }

    // IE #13629 - No reason why we should be blindly adding an expando here
#if 0
            else
            {
                pIElement->setAttribute(_T("HEIGHT"), vtHeight, 0);
            }
#endif 
        }
    }

 Cleanup :
    VariantClear (&vtHeight);
    RRETURN (hr) ;
}

HRESULT
CEdUnits::ExtractCurrentWidth(IHTMLElement* pIElement)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtOldWidth ;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    LONG                    lDimension = 0 ;
  
    VariantInit( &vtOldWidth );
    
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLInputElement, (void**)&spInputElement)))
    {
        if (SUCCEEDED(spInputElement->get_size(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension ;   // for size of input element
            }
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
    {
        if (SUCCEEDED(spTextAreaElement->get_cols(&lDimension)))
        {
            if (lDimension > 0 )
            {
                _lCharDimension = (EDU_THOUSANDTHS_OF_PIXEL * _lPixValue)/lDimension ;   // for cols of textarea
            }
        }
    }

    //
    // IE #13629 : If the CSS Editing Level is 0 then we shouldn't care about
    // either the style or the currentStyle, so if the CSS level is 0, we
    // skip these.
    //

    if ( GetCSSEditingLevel() )
    {
        // First try to extract value from element's style first. 
        // This method will NOT set default (pixel) units, if the style is not present
        hr = ExtractWidthFromElementStyle(pIElement);
        if (S_FALSE == hr) // the inline style is not present
        {
            // get the width from CSS style value if any.
            hr = GetCurrentStyleWidth(pIElement);
        }
    }
        
    // Try to get width or height from the element tag. This valid only for certain elements:
    // table, table cell, control (<OBJECT>)

    _fChangeHTMLAttribute = FALSE;
   
    if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
    {
        if (SUCCEEDED(spTable->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetWidth(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }
        }                           
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
    {
        if (SUCCEEDED(spTableCell->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
            _fChangeHTMLAttribute = TRUE;
            
            if (SUCCEEDED(pIElement->get_offsetWidth(&_lPixValue)))
            {
                _rUnitValue = (double)_lPixValue;
                if (_bstrUnits)
                    ::SysFreeString(_bstrUnits);
                _bstrUnits = ::SysAllocString(s_pwszPixUnits);                 
            }   
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        if (SUCCEEDED(spImageElement->get_width(&_lPixValue)))
        {
            _fChangeHTMLAttribute = TRUE;
        }
    }   
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
    {
        if (SUCCEEDED(spHRElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
    {
        if (SUCCEEDED(spEmbedElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
    {
        if (SUCCEEDED(spMarqueeElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }
    else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
    {
        if (SUCCEEDED(spObjectElement->get_width(&vtOldWidth)) &&
            (NULL != V_BSTR(&vtOldWidth) && ::wcslen(V_BSTR(&vtOldWidth)) > 0))
        {
             if (SUCCEEDED(ExtractValueFromVariant(vtOldWidth)))
                 _fChangeHTMLAttribute = TRUE;
        }
    }

    //
	// If we have no indication so var as to whether we will be changing the 
	// style or the attribute, we would apply this value to the the style
	// *if and only if* the CSS editing level is not 0
	//
		
    if (!_fChangeHTMLAttribute && !_fChangeStyle && GetCSSEditingLevel())
    {
        _rUnitValue = (double)_lPixValue;
        if (_bstrUnits)
            ::SysFreeString(_bstrUnits);
        _bstrUnits = ::SysAllocString(s_pwszPixUnits); 
        _fChangeStyle    = TRUE ;
        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;    // don't care, if you come here, means you will live long 
    }

Cleanup :
    VariantClear(&vtOldWidth);
    RRETURN (hr); 
}

HRESULT
CEdUnits::SetWidthValue(IHTMLElement* pIElement, long lNewValue)
{
    HRESULT                 hr = S_OK ;
    VARIANT                 vtWidth ; 
    VARIANT                 vtNull;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLTable           spTable;
    SP_IHTMLTableCell       spTableCell;
    SP_IHTMLInputElement    spInputElement;
    SP_IHTMLImgElement      spImageElement;
    SP_IHTMLHRElement       spHRElement;    
    SP_IHTMLEmbedElement    spEmbedElement ;
    SP_IHTMLTextAreaElement spTextAreaElement;
    SP_IHTMLMarqueeElement  spMarqueeElement ;
    SP_IHTMLObjectElement   spObjectElement;
    LONG                    lDimension = 0; 

    VariantInit(&vtWidth);

    // IE# 18704 If CSSEditingLevel is Zero, then we need to make sure that there are no in-line 
    // styles that will mess us up
    if ( !GetCSSEditingLevel() )
    {

        VariantInit(&vtNull);
        V_VT(&vtNull) = VT_BSTR;
        V_BSTR(&vtNull) = NULL;
        IFC (pIElement->get_style(&spStyle) );
        IFC (spStyle->put_width(vtNull) );

    }
    if (!_fChangeStyle && SUCCEEDED(pIElement->QueryInterface(IID_IHTMLImgElement, (void**)&spImageElement)))
    {
        hr = spImageElement->put_width(lNewValue);
        goto Cleanup;
    }
    
    if (_lCharDimension > 0 )
    {
        if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLInputElement, (void**)&spInputElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension ;   // for size of input element
            hr = spInputElement->put_size(lDimension);
        }
        else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTextAreaElement, (void**)&spTextAreaElement)))
        {
            lDimension = (lNewValue * EDU_THOUSANDTHS_OF_PIXEL) / _lCharDimension;   // for cols of textarea
            hr = spTextAreaElement->put_cols(lDimension);
        }
    } // fall through to set the default width
    
    // Create a VARIANT (BSTR with value in units) out of the value in pixels

    //
    // Because of the change in the default case in ExtractCurrentXXXX for 
    // CSS Editing Level 0, there is the possibility that this MakeVariant is not
    // necessary
    //

    if(_fChangeStyle || _fChangeHTMLAttribute)
    {
        IFC (MakeVariant(lNewValue, &vtWidth));

        // If the original value was in a style, apply new to the style
        if (_fChangeStyle && GetCSSEditingLevel())
        {

            // Check if style is present. It is always present in IE4 and IE5, but can be empty
            IFC(pIElement->get_style(&spStyle));
            IFC (spStyle->put_width(vtWidth));

        } 


        if (_fChangeHTMLAttribute )
        {
            // Not in a style - apply value depending on the element type
            if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTable, (void**)&spTable)))
            {
                IFC (spTable->put_width(vtWidth));
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLTableCell, (void**)&spTableCell)))
            {
                IFC (spTableCell->put_width(vtWidth));
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLHRElement, (void**)&spHRElement)))
            {
                hr = spHRElement->put_width(vtWidth);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLEmbedElement, (void**)&spEmbedElement)))
            {
                hr = spEmbedElement->put_width(vtWidth);
            }
            else if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLMarqueeElement, (void**)&spMarqueeElement)))
            {
                hr = spMarqueeElement->put_width(vtWidth);
            }
            else if(SUCCEEDED(pIElement->QueryInterface(IID_IHTMLObjectElement, (void**)&spObjectElement)))
            {
                hr = spObjectElement->put_width(vtWidth);
            }   

            //
            // IE #13629 - No reason why we should be blindly adding an expando here
            // 
#if 0
            else
            {
                pIElement->setAttribute(_T("WIDTH"), vtWidth, 0);
            }
#endif 
       }
    }

 Cleanup :
    VariantClear (&vtWidth);
    RRETURN (hr) ;
}

HRESULT CEdUnits::GetPixelLeft(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetLeft(&_lPixValue));
}

HRESULT CEdUnits::GetPixelTop(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetTop(&_lPixValue));
}

HRESULT CEdUnits::GetPixelWidth(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetWidth(&_lPixValue));
}

HRESULT CEdUnits::GetPixelHeight(IHTMLElement* pIElement)
{
   RRETURN(pIElement->get_offsetHeight(&_lPixValue));
}

VOID
CEdUnits::AdjustLeftDimensions(IHTMLElement* pIElement, LONG* lNewValue)
{
    POINT ptOldPosition ;
    
    if (SUCCEEDED(EdUtil::GetOffsetTopLeft(pIElement, &ptOldPosition)))
    {
        // apply only the change : chandras : 02/15/2000
        *lNewValue = _lPixValue + (*lNewValue - ptOldPosition.x) ;
    }    
}

VOID
CEdUnits::AdjustTopDimensions(IHTMLElement* pIElement, LONG* lNewValue)
{
    POINT ptOldPosition;
    
    if (SUCCEEDED(EdUtil::GetOffsetTopLeft(pIElement, &ptOldPosition)))
    {
        // apply only the change : chandras : 02/15/2000
        *lNewValue = _lPixValue + (*lNewValue - ptOldPosition.y) ;
    }    
}

VOID
CEdUnits::AdjustHeightDimensions(IHTMLElement* pIElement, LONG* lNewHeight,ELEMENT_TAG_ID eTag)
{
    // table caption handling after resizing 
    // Caption gets adjusted(wrap, if any) after width setting, so calculate the height now
    switch (eTag)
    {
        case TAGID_TABLE :
        {
            *lNewHeight -= EdUtil::GetCaptionHeight(pIElement) ;
        }
        break;

        case TAGID_IMG:
        {    
            // calculating the width and height without borders to set on style
            LONG cyOldHeight=0 , cyHeight=0 ;

            if (SUCCEEDED(pIElement->get_offsetHeight(&cyOldHeight)))
            {
                SP_IHTMLElement2 spElement2;
                if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2 , (void **)& spElement2 )))
                {
                    if (SUCCEEDED(spElement2->get_clientHeight(&cyHeight)))
                    {
                        *lNewHeight = cyHeight + (*lNewHeight - cyOldHeight) ;
                    }
                }
            }
         }
         break;
    }
}

VOID
CEdUnits::AdjustWidthDimensions(IHTMLElement* pIElement, LONG* lNewWidth,ELEMENT_TAG_ID eTag)
{
    if (eTag == TAGID_IMG)
    {   // calculating the width and height without borders to set on style
        LONG cxOldWidth=0, cxWidth=0;

        if (SUCCEEDED(pIElement->get_offsetWidth(&cxOldWidth)))
        {
           SP_IHTMLElement2 spElement2;

           if (SUCCEEDED(pIElement->QueryInterface(IID_IHTMLElement2 , (void **)& spElement2 )))
           {
                if (SUCCEEDED(spElement2->get_clientWidth(&cxWidth)))
                {
                    *lNewWidth  = cxWidth  + (*lNewWidth  - cxOldWidth) ;
                }
           }
        }
    }
}

HRESULT
CEdUnits::GetCurrentStyleHeight(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleHeight;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;

    VariantInit(&vtCurStyleHeight);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_height(&vtCurStyleHeight);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleHeight) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleHeight) && ::wcslen(V_BSTR(&vtCurStyleHeight)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleHeight)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleHeight)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleHeight);
    return _fChangeStyle ? S_OK : S_FALSE ;
}

HRESULT
CEdUnits::GetCurrentStyleWidth(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleWidth;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleWidth);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_width(&vtCurStyleWidth);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleWidth) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleWidth) && ::wcslen(V_BSTR(&vtCurStyleWidth)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleWidth)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleWidth)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleWidth);
    return _fChangeStyle ? S_OK : S_FALSE ;
}

HRESULT
CEdUnits::GetCurrentStyleTop(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleTop;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleTop);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_top(&vtCurStyleTop);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleTop) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleTop) && ::wcslen(V_BSTR(&vtCurStyleTop)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleTop)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleTop)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleTop);
    return _fChangeStyle ? S_OK : S_FALSE ;
}


HRESULT
CEdUnits::GetCurrentStyleLeft(IHTMLElement* pIElement)
{
    VARIANT               vtCurStyleLeft;
    SP_IHTMLCurrentStyle  spCurStyle;
    SP_IHTMLElement2      spElement2;
    HRESULT               hr = S_OK;
    
    VariantInit(&vtCurStyleLeft);
    IFC(pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC(spElement2->get_currentStyle(&spCurStyle));

    if (spCurStyle != NULL)
    {
        // Get value specified in the currentstyle. This value is V_BSTR and can be empty
        spCurStyle->get_left(&vtCurStyleLeft);

        // The height value MUST be a string. Otherwise how do I know what the units are?
        Assert(V_VT(&vtCurStyleLeft) == VT_BSTR);
        if (NULL != V_BSTR(&vtCurStyleLeft) && ::wcslen(V_BSTR(&vtCurStyleLeft)) > 0 && 
            (StrCmpIW(_T("auto"), V_BSTR(&vtCurStyleLeft)) != 0))
        {    
            // Non-empty string means that the dimensions is specified in the element's style.
            // Now extract the units designator and value in units from the string
            if (SUCCEEDED(ExtractValueFromVariant(vtCurStyleLeft)))
                _fChangeStyle = TRUE;
        }
    }
Cleanup:
    VariantClear (&vtCurStyleLeft);
    return _fChangeStyle ? S_OK : S_FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\edunhlpr.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

//+====================================================================================
//
// Method: CreateAndSubmit
//
// Synopsis: Calls create to create an Undo Unit and add it to the UndoManager.
//
//------------------------------------------------------------------------------------


HRESULT 
CUndoHelper::CreateAndSubmit( )
{
    HRESULT         hr = S_OK;
    IOleUndoUnit *  pUU = NULL;
    SP_IOleUndoManager spUndoMgr;
    
    IFC( CreateUnit(& pUU));
    if( !pUU )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( _pEd->GetUndoManager( & spUndoMgr ));
    IFC( spUndoMgr->Add( pUU ) ) ;

Cleanup:
    if( pUU )
        pUU->Release();

    RRETURN( hr );
}


//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CUndoBase::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CUndoUnitBase::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this , IUnknown )
        QI_INHERITS( this , IOleUndoUnit )
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

HRESULT 
CUndoUnitBase::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr;

    //
    // marka - the units in trident set the state
    // as our selection undo units are added underneath another parent unit
    // the state should be set for us. 
    //
    
    hr = PrivateDo( pUndoManager );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\stdafx.h ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.H
//
//  Contents:   Include file for standard ATL include files
//
//-------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_)
#define AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED_

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_MIN_CRT
//#define _ATL_MIN_CRT
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

//
// NOTE: ATL depends on the *presence* of _DEBUG to switch into DEBUG mode.
// Trident *always* sets _DEBUG to some value. This causes a problem when
// building a retail build in the Trident tree. 
// undef'ing _DEBUG when _DEBUG is zero solves the problem.
//
#if _DEBUG == 0
# undef _DEBUG
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void  ATL_free(void *);
void *ATL_malloc(size_t);
void *ATL_realloc(void *, size_t);

#define lstrlenW _tcslen
#define lstrcmpiW StrCmpIW
#define lstrcpynW StrCpyNW
#define lstrcpyW StrCpyW
#define lstrcatW StrCatW

#undef HIMETRIC_PER_INCH

#undef SubclassWindow
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

typedef INT Direction;

#pragma warning( disable : 4510 4610 )  

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#undef malloc
#undef free
#undef realloc

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E3820655_B95E_11D1_A8BB_00C04FB6C702__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edutil\flatptr.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       flatptr.cxx
//
//  Contents:   Implementation of CFlatMarkupPointer
//
//  Classes:    CFlatMarkupPointer
//
//  History:    09-14-98 - ashrafm - created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNHLPR_HXX_
#define X_EDUNHLPR_HXX_
#include "edunhlpr.hxx"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

using namespace EdUtil;

DeclareTag(tagEditShowMarkupPointerNames, "Edit","Show MarkupPointer names")

#define WCH_GLYPH WCHAR(0xfffe)

HRESULT
ConvertPointerToInternal( CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal);

HRESULT
CreateMarkupPointer2( 
    CEditorDoc* pDoc, 
    IMarkupPointer** ppPointer 
#if DBG == 1
    , LPCTSTR szDebugName
#endif
);

#if DBG==1
#define CreateMarkupPointer(ppPointer)                      CreateMarkupPointer(ppPointer, L#ppPointer)
#define CreateMarkupPointer2(pEditor, ppPointer)            CreateMarkupPointer2(pEditor, ppPointer, L#ppPointer)
#endif

//+---------------------------------------------------------------------------
//
//  Class:      CFlatMarkupPointer 
//
//  Purpose:    Provide a flat view of the document tree
//
//----------------------------------------------------------------------------

class CFlatMarkupPointer : public IMarkupPointer2
{
public:
    CFlatMarkupPointer(CEditorDoc *pEditorDoc, IMarkupPointer2 *pPointer);
    ~CFlatMarkupPointer();

    //
    // IUnknown methods
    //
    
    STDMETHOD(QueryInterface) (REFIID, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    //
    // IMarkupPointer methods
    //
    
    STDMETHODIMP OwningDoc ( IHTMLDocument2 **ppDoc );
    STDMETHODIMP Gravity ( POINTER_GRAVITY *peGravity );
    STDMETHODIMP SetGravity ( POINTER_GRAVITY eGravity );
    STDMETHODIMP Cling ( BOOL *pfCling );
    STDMETHODIMP SetCling ( BOOL fCling );
    STDMETHODIMP MoveAdjacentToElement ( IHTMLElement *pElement, ELEMENT_ADJACENCY eAdj );
    STDMETHODIMP MoveToPointer ( IMarkupPointer *pPointer );
    STDMETHODIMP MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart );
    STDMETHODIMP Unposition ( );
    STDMETHODIMP IsPositioned ( BOOL * );
    STDMETHODIMP GetContainer ( IMarkupContainer * * );

    STDMETHODIMP Left (
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );
                       
    STDMETHODIMP Right (
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );

    STDMETHODIMP MoveUnit (
        MOVEUNIT_ACTION muAction );
                       
    STDMETHODIMP CurrentScope ( IHTMLElement * * ppElemCurrent );
    
    STDMETHODIMP FindText( 
        OLECHAR *        pchFindText, 
        DWORD            dwFlags,
        IMarkupPointer * pIEndMatch = NULL,
        IMarkupPointer * pIEndSearch = NULL
    );
    
    STDMETHODIMP IsLeftOf           ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsLeftOfOrEqualTo  ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsRightOf          ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsRightOfOrEqualTo ( IMarkupPointer * pPointer,     BOOL * pfResult );
    STDMETHODIMP IsEqualTo          ( IMarkupPointer * pPointerThat, BOOL * pfAreEqual );

    ///////////////////////////////////////////////
    // IMarkupPointer2 methods

    STDMETHODIMP IsAtWordBreak( BOOL * pfAtBreak );
    STDMETHODIMP GetMarkupPosition( long * plMP );
    STDMETHODIMP MoveToMarkupPosition( IMarkupContainer * pContainer, long lMP );
    STDMETHODIMP MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound );
    STDMETHODIMP IsInsideURL ( IMarkupPointer *pRight, BOOL *pfResult );
    STDMETHODIMP MoveToContent( IHTMLElement* pIElement, BOOL fAtStart);

private:
    IMarkupServices *GetMarkupServices() {return _pEditorDoc->GetMarkupServices();}

    STDMETHODIMP There(
        Direction             dir,
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText );
    
    STDMETHODIMP IsMarkupLeftOf(
        IMarkupPointer  *pPointer1, 
        IMarkupPointer  *pPointer2, 
        BOOL            *pfResult);    

    STDMETHODIMP SnapToGlyph(
        MOVEUNIT_ACTION muAction,
        IMarkupPointer *pStart,
        IMarkupPointer *pEnd);

private:    
    CEditorDoc       *_pEditorDoc;
    IMarkupPointer2  *_pPointer;
    LONG             _cRefs;
};

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CFlatMarkupPointer, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CFlatMarkupPointer::CFlatMarkupPointer(CEditorDoc *pEditorDoc, IMarkupPointer2 *pPointer)
{
    Assert(pPointer && pEditorDoc);
    _pPointer = pPointer;
    _pPointer->AddRef();
    _pEditorDoc = pEditorDoc;
    _cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CFlatMarkupPointer, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CFlatMarkupPointer::~CFlatMarkupPointer()
{
    Assert(_pPointer);
    _pPointer->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CFlatMarkupPointer::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CFlatMarkupPointer::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CFlatMarkupPointer::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown 
        || iid == IID_IMarkupPointer 
        || iid == IID_IMarkupPointer2)
    {
        *ppvObj = (IMarkupPointer2 *)this;
        AddRef();    
        return S_OK;
    }

    RRETURN( _pPointer->QueryInterface(iid, ppvObj) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::OwningDoc, public
//
//  Synopsis:   IMarkupPointer::OwningDoc implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::OwningDoc ( IHTMLDocument2 ** ppDoc )
{
    RRETURN( _pPointer->OwningDoc(ppDoc) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Gravity, public
//
//  Synopsis:   IMarkupPointer::Gravity implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Gravity ( POINTER_GRAVITY *peGravity )
{
    RRETURN( _pPointer->Gravity(peGravity) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::SetGravity, public
//
//  Synopsis:   IMarkupPointer::SetGravity implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::SetGravity ( POINTER_GRAVITY eGravity )
{
    RRETURN( _pPointer->SetGravity(eGravity) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Cling, public
//
//  Synopsis:   IMarkupPointer::Cling implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Cling ( BOOL * pfCling )
{
    RRETURN( _pPointer->Cling(pfCling) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::SetCling, public
//
//  Synopsis:   IMarkupPointer::SetCling implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::SetCling ( BOOL fCling )
{
    RRETURN( _pPointer->SetCling(fCling) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveAdjacentToElement, public
//
//  Synopsis:   IMarkupPointer::MoveAdjacentToElement.  
//
//              If pElement is a noscope element, then move to the containing 
//              markup if one exists.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveAdjacentToElement ( IHTMLElement *pElement, ELEMENT_ADJACENCY eAdj )
{
    HRESULT hr;

    //
    // Do a move to content if AfterBegin/BeforeEnd
    //

    switch (eAdj)
    {
        case ELEM_ADJ_AfterBegin:
        case ELEM_ADJ_BeforeEnd:
        {
            hr = THR( _pPointer->MoveToContent(pElement, (eAdj == ELEM_ADJ_AfterBegin) /* fStart */) );
            break;
        }

	default:
        {
            //
            // Do the normal move
            //
    
            hr = THR( _pPointer->MoveAdjacentToElement(pElement, eAdj) );
            break;
        }
    }
    
#if DBG==1
    //
    // We should never get the root element in the editor
    //
    
    ELEMENT_TAG_ID tagId;

    IGNORE_HR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    Assert(tagId != TAGID_NULL);
#endif
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToPointer, public
//
//  Synopsis:   IMarkupPointer::MoveToPointer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveToPointer ( IMarkupPointer * pIPointer )
{
    RRETURN( _pPointer->MoveToPointer(pIPointer) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToContainer, public
//
//  Synopsis:   IMarkupPointer::MoveToContainer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart )
{
    RRETURN( _pPointer->MoveToContainer(pContainer, fAtStart) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsPositioned, public
//
//  Synopsis:   IMarkupPointer::IsPositioned implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::IsPositioned ( BOOL * pfPositioned )
{
    RRETURN( _pPointer->IsPositioned(pfPositioned) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::GetContainer, public
//
//  Synopsis:   IMarkupPointer::GetContainer implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::GetContainer ( IMarkupContainer * * ppContainer )
{
    RRETURN( _pPointer->GetContainer(ppContainer) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Unposition, public
//
//  Synopsis:   IMarkupPointer::Unposition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Unposition ( )
{
    RRETURN( _pPointer->Unposition() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Left, public
//
//  Synopsis:   IMarkupPointer::Left implementation that will hide
//              markup boundaries.  See CFlatMarkupPointer::There.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Left (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchtext )
{
    RRETURN( There(LEFT, fMove, pContext, ppElement, pcch, pchtext) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::Right, public
//
//  Synopsis:   IMarkupPointer::Right implementation that will hide
//              markup boundaries.  See CFlatMarkupPointer::There.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::Right (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText )
{
    RRETURN( There(RIGHT, fMove, pContext, ppElement, pcch, pchText) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveUnit, public
//
//  Synopsis:   IMarkupPointer::MoveUnit implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CFlatMarkupPointer::MoveUnit( MOVEUNIT_ACTION muAction )
{
    HRESULT     hr;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTEREND:
        {
            SP_IMarkupPointer   spStart;

            IFC( CreateMarkupPointer2(_pEditorDoc, &spStart) );
            IFC( spStart->MoveToPointer(_pPointer) );    
            IFC( _pPointer->MoveUnit(muAction) );
            
            IFC( SnapToGlyph(muAction, spStart, _pPointer) );
            break;
        }

        default:
            IFC( _pPointer->MoveUnit(muAction) );
    }

Cleanup:        
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::CurrentScope, public
//
//  Synopsis:   IMarkupPointer::CurrentScope implementation 
//
//              If current scope is NULL, we get the master element
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::CurrentScope ( IHTMLElement ** ppElemCurrent )
{
    HRESULT hr;

    IFC( _pPointer->CurrentScope(ppElemCurrent) );
    if ((*ppElemCurrent) == NULL)
    {
        SP_IMarkupContainer  spContainer;
        SP_IMarkupContainer2 spContainer2;
        
        //
        // Get the master element
        //

        IFC( _pPointer->GetContainer(&spContainer) );
        if (spContainer == NULL)
            goto Cleanup; // same behavior as CurrentScope
        
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(ppElemCurrent) );
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::FindText, public
//
//  Synopsis:   IMarkupPointer::FindText implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::FindText (
    OLECHAR *        pchFindText, 
    DWORD            dwFlags,
    IMarkupPointer * pIEndMatch, /* =NULL */
    IMarkupPointer * pIEndSearch /* =NULL */)
{
    RRETURN( _pPointer->FindText(pchFindText, dwFlags, pIEndMatch, pIEndSearch) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToContent, public
//
//  Synopsis:   IMarkupPointer::MoveToContent implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
HRESULT
CFlatMarkupPointer::MoveToContent( IHTMLElement* pIElement, BOOL fAtStart )
{
    RRETURN( _pPointer->MoveToContent(pIElement, fAtStart) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveUnitBounded, public
//
//  Synopsis:   IMarkupPointer::MoveUnitBounded implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFlatMarkupPointer::MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound )
{
    HRESULT             hr;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
        case MOVEUNIT_NEXTCLUSTEREND:
        {
            SP_IMarkupPointer   spStart;

            IFC( CreateMarkupPointer2(_pEditorDoc, &spStart) );
            IFC( spStart->MoveToPointer(_pPointer) );    
            IFC( _pPointer->MoveUnitBounded(muAction, pmpBound) );
            
            IFC( SnapToGlyph(muAction, spStart, _pPointer) );
            break;
        }

        default:
            IFC( _pPointer->MoveUnitBounded(muAction, pmpBound) );
    }

Cleanup:        
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsAtWordBreak, public
//
//  Synopsis:   IMarkupPointer::IsAtWordBreak implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsAtWordBreak( BOOL * pfAtBreak )
{
    RRETURN( _pPointer->IsAtWordBreak(pfAtBreak) );
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::GetMarkupPosition, public
//
//  Synopsis:   IMarkupPointer::GetMarkupPosition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::GetMarkupPosition( long * plMP )
{
    RRETURN( _pPointer->GetMarkupPosition(plMP) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::MoveToMarkupPosition, public
//
//  Synopsis:   IMarkupPointer::MoveToMarkupPosition implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::MoveToMarkupPosition(IMarkupContainer * pContainer, long lMP)
{
    RRETURN( _pPointer->MoveToMarkupPosition(pContainer, lMP) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsInsideURL, public
//
//  Synopsis:   IMarkupPointer::IsInsideURL implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsInsideURL(IMarkupPointer *pRight, BOOL *pfResult)
{
    RRETURN( _pPointer->IsInsideURL(pRight, pfResult) );
}
  

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsLeftOf, public
//
//  Synopsis:   IMarkupPointer::IsLeftOf.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::IsLeftOf( IMarkupPointer * pPointer, BOOL * pfResult )
{
    HRESULT hr;

    hr = _pPointer->IsLeftOf(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
        IFC( IsMarkupLeftOf(_pPointer, pPointer, pfResult) );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsRightOf, public
//
//  Synopsis:   IMarkupPointer::IsRightOf.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsRightOf( IMarkupPointer * pPointer, BOOL * pfResult )
{
    HRESULT hr;

    hr = _pPointer->IsRightOf(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
        IFC( IsMarkupLeftOf(pPointer, _pPointer, pfResult) );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsEqualTo implementation that delegates
//              to _pPointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsEqualTo( IMarkupPointer * pPointerThat, BOOL * pfAreEqual )
{
    HRESULT hr;

    hr = _pPointer->IsEqualTo(pPointerThat, pfAreEqual);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	*pfAreEqual = FALSE;
	hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsLeftOfOrEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsLeftOfOrEqualTo.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsLeftOfOrEqualTo  (IMarkupPointer *pPointer, BOOL * pfResult)
{
    HRESULT hr;

    hr = _pPointer->IsLeftOfOrEqualTo(pPointer, pfResult);

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	// If they are equal, we won't get CTL_E_INCOMPATIBLEPOINTERS
        IFC( IsMarkupLeftOf(_pPointer, pPointer, pfResult) );        
    }
    
Cleanup:    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsRightOfOrEqualTo, public
//
//  Synopsis:   IMarkupPointer::IsRightOfOrEqualTo.
//
//              If the pointers are in different markup's, do a markup
//              aware compare.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CFlatMarkupPointer::IsRightOfOrEqualTo  (IMarkupPointer *pPointer, BOOL * pfResult)
{
    HRESULT hr;

    hr = THR( _pPointer->IsRightOfOrEqualTo(pPointer, pfResult) );

    if (hr == CTL_E_INCOMPATIBLEPOINTERS)
    {
	// If they are equal, we won't get CTL_E_INCOMPATIBLEPOINTERS
        IFC( IsMarkupLeftOf(pPointer, _pPointer, pfResult) );        
    }
    
Cleanup:    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::IsMarkupLeftOf, private
//
//  Synopsis:   IMarkupPointer::IsMarkupLeftOf.
//
//              Do markup aware IsLeftOf comparison.
//
//----------------------------------------------------------------------------
HRESULT
CFlatMarkupPointer::IsMarkupLeftOf(
    IMarkupPointer  *pPointer1, 
    IMarkupPointer  *pPointer2, 
    BOOL            *pfResult)
{
    HRESULT                      hr;
    CPtrAry<IMarkupContainer *>  aryParentChain1(Mt(Mem));
    CPtrAry<IMarkupContainer *>  aryParentChain2(Mt(Mem));
    SP_IMarkupPointer            spPointer1;
    SP_IMarkupPointer            spPointer2;
    INT                          iChain1, iChain2;
    SP_IHTMLElement              spElement;
    SP_IMarkupContainer2         spContainer2;
    BOOL                         fPointer2MovedMarkups = FALSE;
    INT                          i;

    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer1) );
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer2) );

    //
    // Compute the markup parent chain for each pointer
    //

    IFC( spPointer1->MoveToPointer(pPointer1) );
    IFC( ComputeParentChain(spPointer1, aryParentChain1) );
    IFC( spPointer1->MoveToPointer(pPointer1) );
    
    IFC( spPointer2->MoveToPointer(pPointer2) );
    IFC( ComputeParentChain(spPointer2, aryParentChain2) );
    IFC( spPointer2->MoveToPointer(pPointer2) );

    iChain1 = aryParentChain1.Size()-1;
    iChain2 = aryParentChain2.Size()-1;

    //
    // Must have positioned pointers because we call the markup services
    // compare first before IsMarkupLeftOf.  If the pointers are unpositioned,
    // we'll fail before we get here
    //

    Assert(iChain1 >= 0 && iChain2 >= 0);

    //
    // Make sure the top markups are the same
    //

    if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    for (;;)
    {
        iChain1--;
        iChain2--;

        //
        // Check if one markup is contained within another
        //
        if (iChain1 < 0 || iChain2 < 0)
        {
            // (iChain1 < 0 && iChain2 < 0) implies same markup.  This function should not be
            // called in this case
            Assert(iChain1 >= 0 || iChain2 >= 0);

            if (iChain1 < 0)
            {
                Assert( aryParentChain2[iChain2] );
                if( aryParentChain2[iChain2] )
                {
                    IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement(&spElement) );
                    IFC( spPointer2->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    fPointer2MovedMarkups = TRUE;
                }
            }
            else
            {
                Assert( aryParentChain1[iChain1] );
                if( aryParentChain1[iChain1] )
                {
                    IFC( aryParentChain1[iChain1]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                    IFC( spContainer2->GetMasterElement(&spElement) );
                    IFC( spPointer1->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                }
            }
            break;
        }

        //
        // Check if we've found the first different markup in the chain
        //
                
        if (!IsEqual(aryParentChain1[iChain1], aryParentChain2[iChain2]))
        {
            Assert( aryParentChain1[iChain1] && aryParentChain2[iChain2] );
            
            if( aryParentChain1[iChain1] && aryParentChain2[iChain2] )
            {
                IFC( aryParentChain1[iChain1]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );
                IFC( spPointer1->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );

                IFC( aryParentChain2[iChain2]->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );
                IFC( spPointer2->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                fPointer2MovedMarkups = TRUE;
            }
            break;
        }
    }

    if (fPointer2MovedMarkups)
        IFC( spPointer1->IsLeftOfOrEqualTo(spPointer2, pfResult) )
    else
        IFC( spPointer1->IsLeftOf(spPointer2, pfResult) );
    
Cleanup:
    for (i = 0; i < aryParentChain1.Size(); i++)
        ReleaseInterface(aryParentChain1[i]);

    for (i = 0; i < aryParentChain2.Size(); i++)
        ReleaseInterface(aryParentChain2[i]);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlatMarkupPointer::There, private
//
//  Synopsis:   Do markup aware IsLeftOf comparison.
//
//----------------------------------------------------------------------------

STDMETHODIMP 
CFlatMarkupPointer::There(
        Direction             dir,
        BOOL                  fMove,
        MARKUP_CONTEXT_TYPE * pContext,
        IHTMLElement * *      ppElement,
        long *                pcch,
        OLECHAR *             pchText )
{
    HRESULT                 hr = S_OK;
    MARKUP_CONTEXT_TYPE     context;
    IHTMLElement            *pElementInternal = NULL;
    BOOL                    fCheckGlyphs = !_pEditorDoc->ShouldIgnoreGlyphs() && (pContext != NULL);

    if (!pContext)
        pContext = &context;

    if (!ppElement)
        ppElement= &pElementInternal;

    *ppElement = NULL;       

    //
    // Try to move
    //

    switch (dir)
    {
        case LEFT:
            IFC( _pPointer->Left(fMove, pContext, ppElement, pcch, pchText) );
            break;

        case RIGHT:
            IFC( _pPointer->Right(fMove, pContext, ppElement, pcch, pchText) );
            break;

        default:
            AssertSz(0, "CFlatMarkupPointer::There - Unhandled move direction");
    }

    switch (*pContext)
    {
        case CONTEXT_TYPE_NoScope:
        {
            //
            // Flatten noscope elements
            //

            if (SUCCEEDED( _pPointer->MoveToContent(*ppElement, (dir == RIGHT) /* fStart */) ))
            {
                *pContext = CONTEXT_TYPE_EnterScope;
            }
            else if (fMove)
            {
                IFC( _pPointer->MoveAdjacentToElement(*ppElement, (dir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
            }

            if (!fMove)
            {
                IFC( _pPointer->MoveAdjacentToElement(*ppElement, (dir == LEFT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
            }
            break;
        }

        case CONTEXT_TYPE_EnterScope:
        {
            //
            // Check for entering an element that is view-linked
            //
            
            if (fMove)
            {
                IFC( _pPointer->MoveToContent(*ppElement, (dir == RIGHT) /* fStart */) );
            }
                
            break;
        }
        
        case CONTEXT_TYPE_None:
        {
            SP_IMarkupContainer     spContainer;
            SP_IMarkupContainer2    spContainer2;
            SP_IHTMLElement         spElement;

            //
            // Check for master element.  If found, flatten
            //

            IFC( _pPointer->GetContainer(&spContainer) );

            if (spContainer != NULL)
            {
                IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
                IFC( spContainer2->GetMasterElement(&spElement) );

                if (spElement != NULL)
                {
                    if (fMove)
                    {
                        IFC( _pPointer->MoveAdjacentToElement(spElement, (dir == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin) );
                    }   
                    if (ppElement)
                    {
                        ReplaceInterface(ppElement, spElement.p);                
                    }
                    *pContext = CONTEXT_TYPE_ExitScope;
                }
            }
            break;
        }
    }

    if (fCheckGlyphs && (*ppElement))
    {
        switch (*pContext)
        {
            case CONTEXT_TYPE_NoScope:
            {
                SP_IHTMLElement3    spElement3;
                LONG                lGlyphMode;

                IFC( (*ppElement)->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                IFC( spElement3->get_glyphMode(&lGlyphMode) );

                if (lGlyphMode)
                {
                    if (pcch)
                        *pcch = 1;

                    if (pchText)
                        *pchText = WCH_GLYPH;

                    *pContext = CONTEXT_TYPE_Text;
                }
                break;
            }

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            {
                SP_IHTMLElement3    spElement3;
                LONG                lGlyphMode;

                IFC( (*ppElement)->QueryInterface(IID_IHTMLElement3, (LPVOID *)&spElement3) );
                IFC( spElement3->get_glyphMode(&lGlyphMode) );

                if (lGlyphMode)
                {
                    BOOL fHasGlyph = FALSE;
                    
                    switch (*pContext)
                    {
                        case CONTEXT_TYPE_EnterScope:
                            fHasGlyph = (lGlyphMode & ((dir == RIGHT) ? htmlGlyphModeBegin : htmlGlyphModeEnd));
                            break;

                        case CONTEXT_TYPE_ExitScope:
                            fHasGlyph = (lGlyphMode & ((dir == RIGHT) ? htmlGlyphModeEnd : htmlGlyphModeBegin));
                            break;                        
                    }

                    if (fHasGlyph)
                    {
                        ELEMENT_TAG_ID tagId;
                        
                        IFC( GetMarkupServices()->GetElementTagId(*ppElement, &tagId) );

                        if (!EdUtil::IsListItem(tagId) 
                            && !EdUtil::IsListContainer(tagId) 
                            && EdUtil::IsLayout(*ppElement) == S_FALSE)
                        {    
                            if (pcch)
                                *pcch = 1;

                            if (pchText)
                                *pchText = WCH_GLYPH;

                            *pContext = CONTEXT_TYPE_Text;
                        }
                    }

                }
                break;
            }
        }
    }
    
Cleanup:    
    ReleaseInterface(pElementInternal);
    
    RRETURN(hr);    
}



//+---------------------------------------------------------------------------
//
//  Member:     GetParentElement, public
//
//  Synopsis:   Get the parent element.  If it is NULL, then get the 
//              master element
//
//----------------------------------------------------------------------------
HRESULT 
GetParentElement(IMarkupServices *pMarkupServices, IHTMLElement *pSrcElement, IHTMLElement **ppParentElement)
{
    HRESULT hr;

    Assert(ppParentElement && pSrcElement);

    IFC( pSrcElement->get_parentElement(ppParentElement) );

    if ((*ppParentElement) == NULL)
    {
        SP_IMarkupPointer       spPointer;
        SP_IMarkupContainer     spContainer;
        SP_IMarkupContainer2    spContainer2;

        IFC( MarkupServices_CreateMarkupPointer(pMarkupServices, &spPointer) );
        
        hr = THR( spPointer->MoveAdjacentToElement(pSrcElement, ELEM_ADJ_BeforeBegin) );
        Assert(hr == S_OK);
        IFC(hr);

        IFC( spPointer->GetContainer(&spContainer) );
        IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
        IFC( spContainer2->GetMasterElement(ppParentElement) );
    }

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CFlatMarkupPointer::SnapToGlyph(MOVEUNIT_ACTION muAction, IMarkupPointer *
pStart, IMarkupPointer *pAdjust)
{
    HRESULT                 hr;
    Direction               dir = RIGHT;
    WCHAR                   ch;
    MARKUP_CONTEXT_TYPE     context;
    LONG                    cch;
    BOOL                    fDone;

    switch (muAction)
    {
        case MOVEUNIT_PREVCHAR: 
        case MOVEUNIT_PREVCLUSTERBEGIN:
        case MOVEUNIT_PREVCLUSTEREND:
            dir = LEFT;
            break;

        case MOVEUNIT_NEXTCHAR:
        case MOVEUNIT_NEXTCLUSTERBEGIN:
        case MOVEUNIT_NEXTCLUSTEREND:
            dir = RIGHT;
            break;

        default:
            AssertSz(0, "Unsupported muAction in SnapToGlyph ");
    }            

    for (;;)
    {
        cch = 1;
        if (dir == RIGHT)
        {
            IFC( pStart->Right(TRUE, &context, NULL, &cch, &ch) );
            IFC( pStart->IsRightOfOrEqualTo(pAdjust, &fDone) );
        }
        else
        {
            IFC( pStart->Left(TRUE, &context, NULL, &cch, &ch) );
            IFC( pStart->IsLeftOfOrEqualTo(pAdjust, &fDone) );
        }

        if (fDone)
            break;

        if (context == CONTEXT_TYPE_Text && ch == WCH_GLYPH)
        {
            IFC( pAdjust->MoveToPointer(pStart) );
            break;
        }                    
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::ConvertPointerToInternal, public
//
//  Synopsis:   Convert an external markup pointer to a flat markup pointer
//
//----------------------------------------------------------------------------
HRESULT
ConvertPointerToInternal( CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal)
{
    HRESULT                 hr;
    CFlatMarkupPointer      *pPointerInternal = NULL;
    SP_IMarkupPointer2      spPointer2;

    if (ppInternal == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pPointer == NULL)
    {
        hr = S_OK;
        *ppInternal = NULL;
        goto Cleanup;
    }

    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) ) ;

    pPointerInternal = new CFlatMarkupPointer(pDoc, spPointer2);
    if (!pPointerInternal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( pPointerInternal->QueryInterface(IID_IMarkupPointer, (LPVOID *)ppInternal) );

Cleanup:
    ReleaseInterface(pPointerInternal);
    RRETURN(hr);
}


#undef CreateMarkupPointer
#undef CreateMarkupPointer2

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::CreateMarkupPointer, public
//
//  Synopsis:   Create a flat markup pointer
//
//----------------------------------------------------------------------------

HRESULT 
CEditorDoc::CreateMarkupPointer(
    IMarkupPointer **ppPointer
#if DBG==1
    ,LPCTSTR szDebugName
#endif    
    )
{
#if DBG==1
    RRETURN(CreateMarkupPointer2(this, ppPointer, szDebugName));
#else
    RRETURN(CreateMarkupPointer2(this, ppPointer));
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CreateMarkupPointer2
//
//  Synopsis:   Create a flat markup pointer
//
//----------------------------------------------------------------------------
HRESULT
CreateMarkupPointer2(
    CEditorDoc      *pEditorDoc,
    IMarkupPointer  **ppPointer
#if DBG==1
    ,LPCTSTR szDebugName
#endif    
)
{
    HRESULT                 hr;
    CFlatMarkupPointer      *pPointerInternal = NULL;
    SP_IMarkupPointer       spMarkupPointer;
    SP_IMarkupPointer2      spMarkupPointer2;

    if (ppPointer == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pEditorDoc->GetMarkupServices()->CreateMarkupPointer(&spMarkupPointer) );
    IFC( spMarkupPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spMarkupPointer2) );

    pPointerInternal = new CFlatMarkupPointer(pEditorDoc, spMarkupPointer2);
    if (!pPointerInternal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    IFC( pPointerInternal->QueryInterface(IID_IMarkupPointer, (LPVOID *)ppPointer) );

#if DBG==1
    //
    // Set the debug name so that all pointers have some default name    
    //

    if (IsTagEnabled(tagEditShowMarkupPointerNames))
    {
        Assert(szDebugName);

        IEditDebugServices *pEditDebugServices;
        
        if (SUCCEEDED(pEditorDoc->GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(spMarkupPointer2, szDebugName) );
        ReleaseInterface(pEditDebugServices);
        }
    }
#endif
    
Cleanup:
    ReleaseInterface(pPointerInternal);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed

#ifndef DLOAD1
#error dllmap.c should not be used when DLOAD1 is not defined
#endif

// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
DECLARE_ORDINAL_MAP(comctl32)
DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
DECLARE_ORDINAL_MAP(hlink)
DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
DECLARE_PROCNAME_MAP(msjava)
DECLARE_PROCNAME_MAP(msrating)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
DECLARE_PROCNAME_MAP(usp10)
// DECLARE_PROCNAME_MAP(utildll)
DECLARE_PROCNAME_MAP(uxtheme)
DECLARE_PROCNAME_MAP(version)
DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
    DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
    DLDENTRYO(hlink)
    DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
    DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
    DLDENTRYP(msjava)
    DLDENTRYP(msrating)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
    DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
    DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
    DLDENTRYP(usp10)
//     DLDENTRYP(utildll)
    DLDENTRYP(uxtheme)
    DLDENTRYP(version)
    DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#else
#pragma warning( disable : 4206 )
#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\dllreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllreg.cxx
//
//  Contents:   DllRegisterServer, DllUnRegisterServer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_IIMGCTX_H_
#define X_IIMGCTX_H_
#include "iimgctx.h"
#endif

#ifndef X_ADVPUB_H_
#define X_ADVPUB_H_
#include <advpub.h>     // for RegInstall
#endif

//+------------------------------------------------------------------------
//
//  Prototypes
//
//+------------------------------------------------------------------------

HRESULT UnregisterServer(TCHAR *);

#ifndef WIN16
static DYNLIB s_dynlibADVPACK = { 0, 0, "ADVPACK.DLL" };
static DYNPROC s_dynprocREGINSTALL = { 0, &s_dynlibADVPACK, achREGINSTALL };
char g_achIEPath[MAX_PATH];     // path to iexplore.exe
#endif // ndef WIN16


//+------------------------------------------------------------------------
//
//  Function:   RegisterTypeLibraries
//
//  Synopsis:   Register the forms type libraries.
//
//-------------------------------------------------------------------------

static HRESULT
RegisterTypeLibraries()
{
    HRESULT     hr = E_FAIL;
    ITypeLib *  pTL = NULL;
    TCHAR       ach[MAX_PATH];
    TCHAR *     pchName;

    // register the msdatsrc.tlb (databinding)
    int iLen = GetSystemDirectory(ach, MAX_PATH);
    if (iLen > 0 && 
    	iLen+ _tcslen(_T("\\msdatsrc.tlb")) < MAX_PATH-1) // make sure there will be enough space in ach to strcat
    {
        _tcscat(ach, _T("\\msdatsrc.tlb"));
        hr = THR(LoadTypeLib(ach, &pTL));
        if (!hr && pTL)
        {
            hr = THR(RegisterTypeLib(pTL, ach, 0));
            pTL->Release();
        }
    }

    GetFormsTypeLibPath(ach);
    pchName = _tcsrchr(ach, '.');
    Assert(pchName);

    if (pchName+1+_tcslen(_T("tlb")) < ach+MAX_PATH-1) // proceed only if there space left in ach for  _tcscpy 
    {
	_tcscpy(pchName + 1, _T("tlb"));

	hr = THR(LoadTypeLib(ach, &pTL));
	if (!hr && pTL)
	{
	    hr = THR(RegisterTypeLib(pTL, ach, 0));
	    pTL->Release();
	}
    }
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   UnregisterTypeLibraries
//
//  Synopsis:   Unregister the registered type libraries.
//
//-------------------------------------------------------------------------
static void
UnregisterTypeLibraries( )
{
    ITypeLib *  pTL;
    TLIBATTR *  ptla;

    if (!THR(GetFormsTypeLib(&pTL, TRUE)))
    {
        if (!THR(pTL->GetLibAttr(&ptla)))
        {
            UnRegisterTypeLib(ptla->guid,
                    ptla->wMajorVerNum,
                    ptla->wMinorVerNum,
                    ptla->lcid,
                    ptla->syskind);
            pTL->ReleaseTLibAttr(ptla);
        }
        pTL->Release();
    }
}

#ifndef WIN16
const CHAR  c_szIexploreKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

//+------------------------------------------------------------------------
//
// Function:    GetIEPath
//
// Synopsis:    Queries the registry for the location of the path
//              of Internet Explorer and returns it in pszBuf.
//
// Returns:     TRUE on success
//              FALSE if path cannot be determined
//-------------------------------------------------------------------------

void
GetIEPath()
{
    BOOL fSuccess = FALSE;
    HKEY hkey;

    if (lstrlenA(g_achIEPath))
        return;

    g_achIEPath[0] = '\0';

    // Get the path of Internet Explorer
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))
    {
        TraceTag((tagError, "InstallRegSet(): RegOpenKey( %s ) Failed", c_szIexploreKey)) ;
    }
    else
    {
        DWORD cbData = MAX_PATH-1;
        DWORD dwType;

        if (NO_ERROR !=RegQueryValueExA(
                hkey,
                "",
                NULL,
                &dwType,
                (LPBYTE)g_achIEPath,
                &cbData))
        {
            TraceTag((tagError, "InstallRegSet(): RegQueryValueEx() for Iexplore path failed"));
        }
        else
        {
            g_achIEPath[cbData] = '\0'; // ensure path is a null terminated string
            fSuccess = TRUE;
        }

        RegCloseKey(hkey);
    }

    if (!fSuccess)
    {
        // Failed, just say "iexplore"
       lstrcpyA(g_achIEPath, "iexplore.exe");
    }
}

//+------------------------------------------------------------------------
//
// Function:    CallRegInstall
//
// Synopsis:    Calls the ADVPACK entry-point which executes an inf
//              file section.
//
//-------------------------------------------------------------------------

HRESULT
CallRegInstall(LPSTR szSection)
{
    HRESULT     hr = S_OK;
    STRENTRY    seReg[] = {{ "IEXPLORE", g_achIEPath} };
    STRTABLE    stReg = { 1, seReg };

    hr = THR(LoadProcedure(&s_dynprocREGINSTALL));
    if (hr)
        goto Cleanup;

    // Get the location of iexplore from the registry
    GetIEPath();

    hr = THR( ((REGINSTALL)s_dynprocREGINSTALL.pfn)(g_hInstCore, szSection, &stReg));

    {
        //Kill-bit IELabel control here, since we cannot change selfreg.inx now.
        HKEY hKeyCompat, hKeyGuid;
        HRESULT hr;
        DWORD dwData=0x400;
        const char *GuidList[] = {
            "{99B42120-6EC7-11CF-A6C7-00AA00A47DD2}", 
            "{43F8F289-7A20-11D0-8F06-00C04FC295E1}",
            "{80CB7887-20DE-11D2-8D5C-00C04FC29D45}"
        };
        
        hr = RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
            "Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility",
            0, KEY_CREATE_SUB_KEY, &hKeyCompat);
        if (hr == ERROR_SUCCESS)
        {
            for (int i = 0; i < sizeof(GuidList)/sizeof(GuidList[0]); i++)
            {
                hr = RegCreateKeyExA(hKeyCompat, GuidList[i], 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE, NULL, &hKeyGuid, NULL);
                if (hr == ERROR_SUCCESS)
                {
                    RegSetValueExA(hKeyGuid, "Compatibility Flags", 0, REG_DWORD, (LPBYTE)&dwData, sizeof(dwData));
                    RegCloseKey(hKeyGuid);
                }
            }
            RegCloseKey(hKeyCompat);
        }
    }
            
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    UnregisterServer
//
// Synopsis:    Delete everything from the registry that looks like ours.
//
//-------------------------------------------------------------------------

HRESULT
UnregisterServer(TCHAR *pstrDLL)
{
    RRETURN(CallRegInstall("Unreg"));
}
#endif // ndef WIN16


//+------------------------------------------------------------------------
//
// Function:    TestVersion
//
// Synopsis:    Check whether the  InprocServer32 points to a existing file
//              if not return true, otherwise check the version, if the
//              version is greater than current want to register , return
//              false, else return true
// Arguments:   [clsaaID] - specifies the class ID to register
//              [pstrExpectedVersion] - the expected version value.
//
//-------------------------------------------------------------------------
#if 0
BOOL
TestVersion(CLSID classID , TCHAR *pstrExpectedVersion)
{
    TCHAR strKey[128];
    TCHAR strValue[MAX_PATH];
    long cb;

    TCHAR *pstrFmtServer =
#ifndef _MAC
        TEXT("CLSID\\<0g>\\InprocServer32");
#else
        TEXT("CLSID\\<0g>\\InprocServer");
#endif

    TCHAR *pstrFmtVersion = TEXT("CLSID\\<0g>\\Version");

    Verify(Format(0, strKey, ARRAY_SIZE(strKey),
            pstrFmtServer, &classID) == S_OK);

    cb = sizeof(strValue);

    // If Can not Find InprocServer32 We should do register so return true
    if (#_#_RegQueryValue(HKEY_CLASSES_ROOT, strKey, strValue, &cb)
            != ERROR_SUCCESS)
        return TRUE;

    // Otherwise the server exists, Check whether it really exists

    TCHAR achPath[MAX_PATH];
    LPTSTR  lpszFilename;

    //Since the strValue includes full path, it ok to use searchpath here
    if (!#_#_SearchPath(NULL, strValue, NULL, MAX_PATH, achPath, &lpszFilename ))
        return TRUE;

    //otherwise check version
    Verify(Format(0, strKey, ARRAY_SIZE(strKey),
            pstrFmtVersion, &classID) == S_OK);

    cb = sizeof(strValue);

    // No Version Stamp also Return Success
    if (#_#_RegQueryValue(HKEY_CLASSES_ROOT, strKey, strValue, &cb)
        != ERROR_SUCCESS)
        return TRUE;

    //Otherwise compare the version
    if ( _tcsicmp(strValue, pstrExpectedVersion) <= 0)
        return TRUE;
    else
        return FALSE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegister
//
//  Synopsis:   Determine whether would should register a particular pic format
//
//  Returns:    TRUE - yes
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegister(TCHAR *szFormat, TCHAR *szFileExt)
{
    TCHAR   aBuffer[MAX_PATH];
    LONG    lRet;
    HKEY    hkey = NULL;
    DWORD   cb=MAX_PATH -sizeof(TCHAR);
    TCHAR   *lptszCmdName;

    lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                        szFileExt,
                        0,
                        KEY_READ,
                        &hkey);
    if( lRet == ERROR_SUCCESS )
    {
	memset(aBuffer,0,MAX_PATH);
        lRet = RegQueryValueEx(hkey, NULL, 0, NULL, (LPBYTE)aBuffer, &cb);
        RegCloseKey(hkey);
        if (    lRet == ERROR_SUCCESS
            &&  cb != 0
            &&  lstrlen(aBuffer) != 0
            &&  _tcsicmp(aBuffer, szFormat) != 0)
        {
            return(FALSE);
        }
    }

    // note: by desing aBuffer will have enough space to accomodate szFormat and \\shell\\open... added bellow
    Assert ( _tcslen(szFormat)+_tcslen(_T("\\shell\\open\\command")) < MAX_PATH);
    _tcscpy(aBuffer, szFormat); 
    _tcscat(aBuffer, _T("\\shell\\open\\command"));
    lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                        aBuffer,
                        0,
                        KEY_READ,
                        &hkey);
    if( lRet != ERROR_SUCCESS )
        return(TRUE);

    // check if the key value is empty or has IEXplore already
    cb = MAX_PATH;
    lRet = RegQueryValueEx(hkey, NULL, 0, NULL, (LPBYTE)aBuffer, &cb);

    RegCloseKey(hkey);
    if (cb == 0 || lstrlen(aBuffer) == 0 || lRet != ERROR_SUCCESS)
        return(TRUE);

    PathRemoveArgs(aBuffer);
    lptszCmdName = PathFindFileName(aBuffer);
    if ( _tcsnicmp(lptszCmdName, 12, _T("iexplore.exe"), 12) == 0)
        return(TRUE);
    return( FALSE );
}


//+------------------------------------------------------------------------
//
// Function:    DllRegisterServer
//
// Synopsis:    Register objects and type libraries for this server
//              as described in the OLE Controls specification.
//
//-------------------------------------------------------------------------

extern BOOL ShouldWeRegisterCompatibilityTable();
extern BOOL ShouldWeRegisterUrlCompatibilityTable();

typedef struct
{
    TCHAR *tszName;
    LPSTR szSection;
    TCHAR *tszExt;
} PICFORMATREG;

static const PICFORMATREG aImgReg[] =
            {
                {_T("jpegfile"), "RegJPEG"  ,_T(".jpeg")},
                {_T("jpegfile"), "RegJPE"   ,_T(".jpe")},
                {_T("jpegfile"), "RegJPG"   ,_T(".jpg")},
                {_T("pngfile"),  "RegPNG"   ,_T(".png")},
                {_T("pjpegfile"),"RegPJPG"  ,_T(".jfif")},
                {_T("xbmfile"),  "RegXBM"   ,_T(".xbm")},
                {_T("giffile"),  "RegGIF"   ,_T(".gif")}
            };

STDAPI
DllRegisterServer()
{
    HRESULT hr;

    Assert(0 != _tcslen(g_achDLLCore));

    CEnsureThreadState ets;
    hr = ets._hr;
#ifndef UNIX  // CallRegInstall("Reg") has to be excuted
    if (FAILED(hr))
        return hr;
#endif

    hr = RegisterTypeLibraries();
#ifndef UNIX  // CallRegInstall("Reg") has to be excuted
    if (hr)
        goto Cleanup;
#endif

#ifndef WIN16
    hr = THR(CallRegInstall("Reg"));
    if (FAILED(hr))
        goto Cleanup;

    // The test to determine if we should register our compatibility table
    // is non trivial, so we allow clstab.cxx to implement the test since it
    // is the expert on the issue.
    if( ShouldWeRegisterCompatibilityTable() )
    {
        hr = THR(CallRegInstall("RegCompatTable"));
    }

    if (ShouldWeRegisterUrlCompatibilityTable())
    {
        hr = THR(CallRegInstall("RegUrlCompatTable"));
    }
#endif // ndef WIN16

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Function:    DllUnregisterServer
//
// Synopsis:    Undo the actions of DllRegisterServer.
//
//-------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    HRESULT hr;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        return hr;

    UnregisterTypeLibraries();

#ifdef WIN16
    return hr;
#else
    Assert(_tcslen(g_achDLLCore));
    return UnregisterServer(g_achDLLCore);
#endif
}


#ifndef WIN16
//+------------------------------------------------------------------------
//
// Function:    DllInstall
//
// Synopsis:    Install/uninstall user settings
//
//-------------------------------------------------------------------------

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT     hr = S_OK;
    BOOL        fPerUser = (pszCmdLine &&
                            (*pszCmdLine == L'u' || *pszCmdLine == L'U'));
    int     i;
    int     l = ARRAY_SIZE(aImgReg);

    if (fPerUser)
    {
        return S_FALSE;
    }

    if (bInstall)
    {
        hr = THR(CallRegInstall("Install"));

        for (i = 0; i < l; i ++)
        {
            if (ShouldWeRegister(aImgReg[i].tszName, aImgReg[i].tszExt))
            {
                HRESULT hr2;

                hr2 = THR(CallRegInstall(aImgReg[i].szSection));
                if (FAILED(hr2))
                {
                    hr = hr2;
                }
            }
        }
    }
    else
    {
        hr = THR(CallRegInstall("Uninstall"));
    }

    RRETURN(hr);
}
#endif // ndef WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\hook.cxx ===
//+------------------------------------------------------------------------
//
//  File:       hook.cxx
//
//  Contents:   Hook interfaces used for debugging
//
//  History:    09-Jul-97   JohnV Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HOOK_HXX_
#define X_HOOK_HXX_
#include "hook.hxx"
#endif

#ifndef NO_DEBUG_HOOK

MtDefine(CHook, Utilities, "CHook")

CHook *
CreateHook()
{
    return new CHook;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\makefile.inc ===
$(O)\forms3.def: forms3.def
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\forms3p.def: forms3.def
    $(C_PREPROCESSOR_NAME) -DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $*.dfp
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $*.dfp > $@

$(O)\mshtmlp.lib: $(O)\forms3p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\forms3p.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\libmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   DllMain for Forms3
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

extern HRESULT  InitializeDownloadGlobals();

#if DBG == 1
// used for assert to fool the compiler
DWORD g_dwFALSE = 0;
#endif

//  WARNING -- Do not put any global objects with constructors or destructors
//  in this file due to the presence of the init_seg directive below.
//

//+------------------------------------------------------------------------
//
//  External intialization functions
//
//-------------------------------------------------------------------------

// Process attach/detach routines
#ifdef WIN16
// InitUnicodeWrappers initializes this, so when that
// gets fixed get rid of this line.
DWORD g_dwPlatformID = VER_PLATFORM_WIN16;
void InitHeap();
void DeinitHeap();
#else
extern void     InitUnicodeWrappers();
#endif // !WIN16

#ifdef PRODUCT_96
extern HRESULT  InitDynamicVtable();
extern void     DeinitDynamicVtable();
#endif
extern void     DeinitTearOffCache();
extern void     DeinitWindowClasses();
extern void     InitFormClipFormats();
extern void     DeinitForm();
extern void     InitColorTranslation();
extern void     ClearFaceCache();
extern void     InitDefaultControlSizes();
extern HRESULT  InitPalette();
extern BOOL     InitImageUtil();
extern HRESULT  InitICM();
extern HRESULT  InitUrlCompatTable();
extern void     DeinitPalette();
extern void     DeinitSurface();
extern void     DeinitTheme();

#ifdef _MAC
extern void     InitMacDrawing();
extern void     DeinitMacDrawing();
extern "C" pascal void TermRoutine(void);
#endif

extern HRESULT  InitFontCache();
extern void     DeinitTextSubSystem();
extern void     DeinitDownload();
extern void     KillDwnTaskExec();
extern void     KillImgTaskExec();
extern void     DeinitDynamicLibraries();
extern void     DeinitImageSizeCache();

// Thread attach/passivate/detach routines
typedef HRESULT (*PFN_HRESULT_INIT)(THREADSTATE * pts);
typedef void    (*PFN_VOID_DEINIT)(THREADSTATE * pts);

extern HRESULT InitScrollbar(THREADSTATE * pts);
extern void    DeinitScrollbar(THREADSTATE * pts);
extern void    LSDeinitUnderlinePens(THREADSTATE * pts);
extern HRESULT InitBrushCache(THREADSTATE * pts);
extern void    DeinitBrushCache(THREADSTATE * pts);
extern HRESULT InitBmpBrushCache(THREADSTATE * pts);
extern void    DeinitBmpBrushCache(THREADSTATE * pts);
extern HRESULT InitGlobalWindow(THREADSTATE * pts);
extern void    DeinitGlobalWindow(THREADSTATE * pts);
extern HRESULT InitSystemMetricValues(THREADSTATE * pts);
extern void    DeinitSystemMetricValues(THREADSTATE * pts);
extern void    DeinitTimerCtx(THREADSTATE * pts);
extern void    DeinitTooltip(THREADSTATE * pts);
extern void    DeinitTypeLibCache(THREADSTATE * pts);
extern void    DeinitCommitHolder(THREADSTATE *pts);
extern HRESULT InitTaskManager(THREADSTATE * pts);
extern void    DeinitTaskManager(THREADSTATE * pts);
extern void    DeinitFormatCache(THREADSTATE * pts);
//extern void    DeinitSpooler(THREADSTATE * pts);
extern void    DeinitPostMan(THREADSTATE * pts);
extern void    DeinitMultiLanguage();
extern void    DeinitUniscribe();
extern void    DeinitFontLinking();

#ifndef WIN16
extern void    DeinitScriptDebugging();
#endif //!WIN16
extern void    DeinitOptionSettings(THREADSTATE *pts);
extern void    DeinitUserAgentString(THREADSTATE *pts);
extern void    OnSettingsChangeAllDocs(BOOL fNeedLayout);
extern void    DeinitWindowInfo(THREADSTATE *pts);
extern void    DeinitUserStyleSheets(THREADSTATE *pts);
extern void    DeinitImgAnim(THREADSTATE *pts);
extern void    DeinitCategoryInfo(THREADSTATE *pts);
#ifndef NO_IME
extern void    DeinitDIMM();
#endif // ndef NO_IME

extern void    DeinitMLangFontLinking(THREADSTATE * pts);
extern class   CResProtocolCF g_cfResProtocol;
extern class   CAboutProtocolCF g_cfAboutProtocol;
extern class   CViewSourceProtocolCF g_cfViewSourceProtocol;
extern void    DeinitHTMLDialogs();
extern HRESULT InitClassTable();

extern void    DeinitGlobalVersions();

extern HRESULT InitLSCache(THREADSTATE * pts);
extern void    DeinitLSCache(THREADSTATE * pts);

extern void    DeinitVTblDescDispIDCaches(THREADSTATE * pts);

#if DBG == 1
HINSTANCE g_hinstF3Debug = NULL;
#endif

#if defined(DEBUG_TEAROFFS) && !defined(WIN16)
void DebugCheckAllTearoffTables();
#endif

BOOL  SetDLLName(  void  );


//+---------------------------------------------------------------------------
//
//  Class:      CUnloadLibraries
//
//  Purpose:    Special class with a destructor that will be called after
//              all other static destructors are called. This ensures that
//              we don't free any of the libraries we loaded until we're
//              completely cleaned up. Win95 apparently likes to clean up
//              DLLs a little too aggressively when you call FreeLibrary
//              inside DLL_PROCESS_DETACH handlers.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4073) // warning about the following init_seg statement
#pragma init_seg(lib)
class CUnloadLibraries
{
public:
    ~CUnloadLibraries();
};

#ifndef WIN16
// put into WEP for win16 (it doesn't get called otherwise for some reason.)
CUnloadLibraries g_CUnloadLibs;
#endif // ndef WIN16

//+---------------------------------------------------------------------------
//
//  Member:     CUnloadLibraries::~CUnloadLibraries, public
//
//  Synopsis:   class dtor
//
//  Notes:      The init_seg pragma ensures this dtor is called after all
//              others.
//
//----------------------------------------------------------------------------
CUnloadLibraries::~CUnloadLibraries()
{
    DeinitDynamicLibraries();

#if DBG == 1
    if (g_hinstF3Debug)
        FreeLibrary(g_hinstF3Debug);
#endif

}
#pragma warning(default:4073)


#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

//+------------------------------------------------------------------------
//
//  Misc globals
//
//  WARNING -- Do not put any global objects with constructors or destructors
//  in this file due to the presence of the init_seg directive above.
//
//-------------------------------------------------------------------------

static const DWORD  TLS_NULL = ((DWORD)-1);                 // NULL TLS value (defined as 0xFFFFFFFF)

LONG g_lSecondaryObjCount = 0;

#if DBG==1
int g_lSecondaryObjCountCallers[15] = { 0 };
#endif

EXTERN_C HANDLE     g_hProcessHeap = NULL;
HINSTANCE           g_hInstCore = NULL;
HINSTANCE           g_hInstResource = NULL;
TCHAR               g_achDLLCore[MAX_PATH];                 //  Review: Could this be unified
#ifndef WIN16
TCHAR               g_achDLLResource[MAX_PATH];             //          with g_szCodeFragName of the Mac build?
#endif
TCHAR               g_achHelpFileName[MAX_PATH];            // Help file name
DWORD               g_dwTls = TLS_NULL;                     // TLS index associated with THREADSTATEs
THREADSTATE *       g_pts = NULL;                           // Head of THREADSTATE chain
DWORD               g_cThreadStates = 0;                    // Number of THREADSTATEs on the chain

ULONG               g_ulLcl;

#if !defined(WIN16)
CRITICAL_SECTION    CGlobalLock::g_cs;                      // Critical section to protect globals
BOOL                CGlobalLock::g_fInit = FALSE;           // Init flag to protect Critical Section
#if DBG==1
DWORD               CGlobalLock::g_dwThreadID = 0;          // Thread ID which owns the critical section
LONG                CGlobalLock::g_cNesting = 0;            // Enter/LeaveCriticalSection nesting level (DEBUG only)
#endif
#endif

HANDLE              g_hMapHtmPerfCtl = NULL;                // Perf control block memory map handle
HTMPERFCTL *        g_pHtmPerfCtl = NULL;                   // Perf control block (typically NULL)

HRESULT DllThreadAttach();
void    DllThreadDetach(THREADSTATE * pts);
void    DllThreadPassivate(THREADSTATE * pts);
BOOL    DllProcessAttach();
void    DllProcessDetach();


#ifdef WIN16
//+---------------------------------------------------------------------------
//
//  Function:   (De)InitWin16TaskGlobals
//
//  Synopsis:   (De)Inits the pTaskGlobals member of the thread state.
//              Called at threadattach time.
//              Some variables are stored for each HTASK; we should
//              create separate threads for each HTASK; we'll store the
//              HTASK information in the threadstate.
//
//              These functions could be moved to another file.
//
//----------------------------------------------------------------------------

HRESULT InitWin16TaskGlobals(THREADSTATE * pts)
{
    THREADSTATE * pts2;
    HTASK hTask = GetCurrentTask();
    LOCK_GLOBALS;

    // search every pts for an appropriate task global.
    // Expensive but happens infrequently.
    for (pts2 = g_pts;
         pts2 && (!pts2->pTaskGlobals || pts2->pTaskGlobals->hTask != hTask);
         pts2 = pts2->ptsNext);
    if (pts2)
    {
        pts->pTaskGlobals = pts2->pTaskGlobals;
    }
    else
    {
        // create a new set of task globals.
        pts->pTaskGlobals = (WIN16_TASK_GLOBALS *) MemAllocClear(sizeof(WIN16_TASK_GLOBALS));
        if (!pts->pTaskGlobals)
        {
            return E_OUTOFMEMORY;
        }
        pts->pTaskGlobals->hTask = hTask;
    }
    pts->pTaskGlobals->cAttachedThreads++;

    return S_OK;
}

void    DeinitWin16TaskGlobals(THREADSTATE * pts)
{
    if (pts->pTaskGlobals)
    {
        pts->pTaskGlobals->cAttachedThreads--;
        if (!pts->pTaskGlobals->cAttachedThreads)
        {
            MemFree(pts->pTaskGlobals);
        }
    }
}

#endif




//+---------------------------------------------------------------------------
//
//  Function:   DllUpdateSettings
//
//  Synopsis:   Updated cached system settings.  Called when the DLL is
//              attached and in response to WM_WININICHANGE, WM_DEVMODECHANGE,
//              and so on.
//
//----------------------------------------------------------------------------
#ifdef _MAC
    //ISSUE:  ReinitStdTypes should be called regardless of fulldebug or not.
    //        The ReinitStdTypes needs to be in oa and always called.
#  ifdef _MAC_FULLDEBUG
void ReinitStdTypes(void);
#  endif
#endif

extern BOOL g_fSystemFontsNeedRefreshing;

void
DllUpdateSettings(UINT msg)
{
    g_fSystemFontsNeedRefreshing = TRUE;

    if (msg == WM_SYSCOLORCHANGE || msg == WM_DISPLAYCHANGE)
    {
        // On syscolor change, we need to update color table
        InitColorTranslation();
        InitPalette();
        InitImageUtil();
    }

    if (msg == WM_THEMECHANGED)
    {
        //
        // On theme change, we clear our internal theme table
        //

        DeinitTheme();
    }

    // When the fonts available have changed, we need to
    // recheck the system for font faces.
    else if (msg == WM_FONTCHANGE)
    {
        ClearFaceCache();
    }

#ifdef _MAC
    //ISSUE:  ReinitStdTypes should be called regardless of fulldebug or not.
    //        The ReinitStdTypes needs to be in oa and always called.

    //      We need to recreate the hdcDesktop on a WM_SYSCOLORCHANGE
    //      Should this call be in direct response to that message or a general
    //      response to any display setting change?
#  ifdef _MAC_FULLDEBUG
    ReinitStdTypes();
#  endif
    DeinitSystemMetricValues(GetThreadState());
#endif
    InitSystemMetricValues(GetThreadState());

    OnSettingsChangeAllDocs(WM_SYSCOLORCHANGE == msg ||
                            WM_THEMECHANGED == msg ||
                            WM_FONTCHANGE == msg ||
                            (WM_USER + 338) == msg);

}


//+---------------------------------------------------------------------------
//
//  Function:   DllThreadPassivate
//
//  Synopsis:   This function is called when the per-thread object count,
//              dll.lObjCount, transitions to zero.  Deinit things here that
//              cannot be handled at process detach time.
//
//              This function can be called zero, one, or more times during
//              the time the DLL is loaded. Every function called from here
//              here should be prepared to handle this.
//
//----------------------------------------------------------------------------
void
DllThreadPassivate(
    THREADSTATE *   pts)
{
    // Passivate per-thread objects
    // These include:
    //  a) Per-thread OLE error object (held by OLE automation)
    //  b) OLE clipboard object (only one thread should have anything on the clipboard)
    //  c) Per-thread ITypeInfo caches
    //  d) Per-thread picture helper
    //  e) Per-thread default IFont objects
    //
    // NOTE: This code contains one possible race condition: It is possible for
    //       the contents of the clipboard to be changed between the call to
    //       OleIsCurrentClipboard and OleFlushClipboard. If that occurs, this
    //       will flush the wrong object.
    //       GaryBu and I (BrendanD) discussed this case and felt it was not
    //       sufficiently important to warrent implementing a more complete
    //       (and costly) solution.
    Assert(pts);
    TraceTag((tagThread, "DllThreadPassivate called - TID 0x%08x", GetCurrentThreadId()));

    //
    // Tell ole to clear its error info object if one exists.  If we
    // did not load OLEAUT32 then one could not exist.
    //

#ifdef DLOAD1
    if (GetModuleHandleA("OLEAUT32"))
#else
    extern DYNLIB g_dynlibOLEAUT32;

    if (g_dynlibOLEAUT32.hinst)
#endif
    {
        Verify(OK(SetErrorInfo(NULL, NULL)));
    }

    // We actually do this when the last CDoc on the thread goes from running to loaded, 
    // but we also do it here to be safe.  If there actually is something here, we might
    // want to just let it leak instead of calling into COM at this point.
    FormClearClipboard(pts);

    DeinitTypeLibCache(pts);
//    DeinitSpooler(pts);
    if (pts->pInetSess)
    {
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfViewSourceProtocol, _T("view-source"));
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfResProtocol, _T("res"));
        pts->pInetSess->UnregisterNameSpace((IClassFactory *) &g_cfAboutProtocol, _T("about"));

    }
    ClearInterface(&pts->pInetSess);
}

#ifndef WIN16
//+----------------------------------------------------------------------------
//
//  Function:   DllAllThreadsDetach
//
//  Synopsis:   Cleanup when all Trident threads go away.
//
//-----------------------------------------------------------------------------
void
DllAllThreadsDetach()
{
#ifndef NO_SCRIPT_DEBUGGER  //IEUNIX: UNIX macro.
    IF_NOT_WIN16(DeinitScriptDebugging());
#endif
    DeinitHTMLDialogs();
    DeinitSurface();
    KillDwnTaskExec();
    KillImgTaskExec();
#ifndef NO_IME
    DeinitDIMM();
#endif
    DeinitMultiLanguage();
    DeinitUniscribe();
    DeinitFontLinking();
    DeinitGlobalVersions();

    DeinitTheme();

    if (g_hInstResource)
    {
        MLFreeLibrary(g_hInstResource);
        g_hInstResource = NULL;
    }

    DeinitWindowClasses();
}

#endif // ndef WIN16

//+----------------------------------------------------------------------------
//
//  Function:   DllThreadDetach
//
//  Synopsis:   Release/clean-up per-thread variables
//
//  NOTE:   Since DllThreadDetach is called when DllThreadAttach fails
//          all Deinitxxxx routines must be robust. They must work correctly
//          even if the corresponding Initxxxx routine was not first called.
//
//-----------------------------------------------------------------------------
void
DllThreadDetach(
    THREADSTATE *   pts)
{
    //  Deinitialization routines (called in order)
    static const PFN_VOID_DEINIT s_apfnDeinit[] =
                    {
                    DeinitOptionSettings,
                    DeinitUserAgentString,
                    DeinitPostMan,
                    DeinitTaskManager,
                    DeinitCommitHolder,
                    DeinitWindowInfo,
                    DeinitCategoryInfo,
                    DeinitTooltip,
                    LSDeinitUnderlinePens,
                    DeinitBrushCache,
                    DeinitBmpBrushCache,
                    DeinitScrollbar,
                    DeinitTimerCtx,
                    DeinitSystemMetricValues,
                    DeinitFormatCache,
                    DeinitUserStyleSheets,
                    DeinitImgAnim,
                    DeinitMLangFontLinking,
#ifdef WIN16
                    DeinitWin16TaskGlobals,
#endif
                    DeinitLSCache,
                    DeinitVTblDescDispIDCaches,
                    DeinitGlobalWindow  // Must occur last
                    };
    THREADSTATE **  ppts;
    int             cDeinit;

    if (!pts)
        return;

    Assert(pts->dll.idThread == GetCurrentThreadId());

#ifdef OBJCNTCHK
#if DBG==1
    AssertSz(pts->dll.cLockServer == 0, "DllThreadDetach called with cLockServer count non-zero");
#else
    if (pts->dll.cLockServer != 0)
        F3DebugBreak();
#endif
#endif

#if DBG==1
    TraceTag((tagThread, "DllThreadDetach called - TID 0x%08x", GetCurrentThreadId()));
    if (pts->dll.lObjCount)
    {
        TraceTag((tagError,
                "Thread (TID=0x%08x) terminated with primary object count=%d",
                GetCurrentThreadId(), pts->dll.lObjCount));
    }
#endif

#ifdef _MAC
    // The MAC has only one thread, so no THREADSTATE is explicitly passed
    DeinitMacDrawing();
#endif

    // Deinitialize the per-thread variables
    for (cDeinit = 0; cDeinit < ARRAY_SIZE(s_apfnDeinit); cDeinit++)
    {
        (*s_apfnDeinit[cDeinit])(pts);
    }

    ClearErrorInfo(pts);

    // Remove the per-thread structure from the global list
    LOCK_GLOBALS;
    for (ppts = &g_pts; *ppts && *ppts != pts; ppts = &((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;

        // NOTE: (jbeda) It is important to decrement this after we fix up the global chain
        // because setting this to 1 kicks in the global TS access trick in
        // GetThreadState
        g_cThreadStates--;
    }
#if DBG==1
    else
    {
        TraceTag((tagThread,
                "THREADSTATE not on global chain - TID=0x%08x",
                GetCurrentThreadId()));
    }
#endif

    // Disconnect the memory from the thread and delete it
    TlsSetValue(g_dwTls, NULL);
    delete pts;

    return;
}

void
DllThreadEmergencyDetach()
{
    // This gets called by DLL_THREAD_DETACH.  We need to be careful to only do the
    // absolute minimum here to make sure we don't crash in the future.

    THREADSTATE * pts = (THREADSTATE *)TlsGetValue(g_dwTls);

    if (    pts
        &&  pts->dll.idThread == GetCurrentThreadId()
        &&  pts->gwnd.hwndGlobalWindow)
    {
        EnterCriticalSection(&pts->gwnd.cs);
        DestroyWindow(pts->gwnd.hwndGlobalWindow);
        pts->gwnd.hwndGlobalWindow = NULL;
        LeaveCriticalSection(&pts->gwnd.cs);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   _AddRefThreadState
//
//  Synopsis:   Prepare per-thread variables
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
#ifdef OBJCNTCHK
_AddRefThreadState(DWORD * pdwObjCnt)
#else
_AddRefThreadState()
#endif
{
#ifdef OBJCNTCHK
    if (pdwObjCnt)
    {
        *pdwObjCnt = 0;
    }
#endif

    extern HRESULT DllThreadAttach();
    extern DWORD g_dwTls;
    HRESULT hr;
    if (TlsGetValue(g_dwTls) == 0)
    {
        hr = DllThreadAttach();
        if (hr)
            RRETURN(hr);
    }

    IncrementObjectCount(pdwObjCnt);

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllThreadAttach
//
//  Synopsis:   Prepare per-thread variables
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
DllThreadAttach()
{
    // Note: We need to LOCK_GLOBALS for this entire function as we don't want
    //       to init anything while we are in the middle of DllAllThreadsDetach
    LOCK_GLOBALS;

    //  Initialization routines (called in order)
    static const PFN_HRESULT_INIT s_apfnInit[] =
                    {
                    InitGlobalWindow,       // Must occur first
                    InitSystemMetricValues,
                    InitBrushCache,
                    InitBmpBrushCache,
                    InitScrollbar,
                    InitTaskManager,
#ifdef WIN16
                    InitWin16TaskGlobals,
#endif
                    InitLSCache,
                    };
    THREADSTATE *   pts;
    int             cInit;
    HRESULT         hr = S_OK;

    TraceTag((tagThread, "DllThreadAttach called - TID 0x%08x", GetCurrentThreadId()));

    // Allocate per-thread variables
    Assert(!TlsGetValue(g_dwTls));
    pts = new THREADSTATE;
    if (!pts || !TlsSetValue(g_dwTls, pts))
    {
        if (pts)
        {
            delete pts;
            pts = NULL;
        }
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    MemSetName((pts, "THREADSTATE %08x", GetCurrentThreadId()));

    // Initialize the structure
    pts->dll.idThread = GetCurrentThreadId();

    // Run thread initialization routines
    for (cInit = 0; cInit < ARRAY_SIZE(s_apfnInit); cInit++)
    {
        hr = THR((*s_apfnInit[cInit])(pts));
        if (FAILED(hr))
            goto Error;
    }

#ifdef _MAC
    // The MAC has only one thread, so no THREADSTATE is explicitly passed
    InitMacDrawing();
#endif

Cleanup:
    // If successful, insert the per-thread state structure into the global chain
    if (!hr)
    {
        Assert(pts);

        // NOTE: (jbeda) Insert us into the chain, but leave the first one 
        // intact so we don't have a race condition with the global access trick
        // in GetThreadState
        if (g_pts)
        {
            pts->ptsNext = g_pts->ptsNext;
            g_pts->ptsNext = pts;
        }
        else
        {
            pts->ptsNext = g_pts;
            g_pts = pts;
        }

        g_cThreadStates++;
    }

    if (g_fThemedPlatform)
    {
        SHFusionInitialize();
    }

#if DBG==1
    if( FAILED(hr) )
    {
        TraceTag((tagError, "Thread initialization failed - HRESULT = %hr", hr));
    }
#endif
    return hr;

Error:
    DllThreadDetach(pts);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllProcessDetach
//
//  Synopsis:   Deinitialize the DLL.
//
//              This function can be called on partial initialization
//              of the DLL.  Every function called from here must be
//              capable being called without a corresponding call to
//              an initialization function.
//
//----------------------------------------------------------------------------
void
DllProcessDetach()
{
#if DBG==1
    char szModule[MAX_PATH];
    GetModuleFileNameA(NULL, szModule, MAX_PATH);
#endif

#if DBG==1
    for (int i = 0; i < sizeof(g_Zero); i++)
    {
        if (((BYTE *)&g_Zero)[i] != 0)
        {
            TraceTag((tagError, "g_Zero is non-zero at offset %d", i));
            Assert(0 && "g_Zero is not zero!");
            break;
        }
    }
#endif

	if (g_pts)
	{	
		// Our last, best hope for avoiding a crash it to try to take down the global
		// window on this thread and pray it was the last one.

		DllThreadEmergencyDetach();
	}

    DeinitTextSubSystem();
    DeinitDownload();
    DeinitPalette();    
    CRtfToHtmlConverter::Deinit();
#ifndef WIN16
    DeinitImageSizeCache();
#endif // ndef WIN16

#if defined(PRODUCT_PROF) && defined(_MAC)
    _FDisableMeas();
//    _UnHookGlue();
#endif // define(PRODUCT_PROF) && !defined(_MAC)

    DeinitTearOffCache();

#if DBG==1
    if (g_lSecondaryObjCount)
    {
        TraceTag((tagError, "Secondary object count=%d on DLL unload.", g_lSecondaryObjCount));
    }

    if (g_pts != NULL)
    {
        TraceTag((tagError, "One or more THREADSTATE's exist on DLL unload."));
    }
#endif

#ifndef WIN16
    // Delete global variable's critical section
    CGlobalLock::Deinit();
#endif // !WIN16

    // Free per-thread storage index
    if (g_dwTls != TLS_NULL)
    {
        TlsFree(g_dwTls);
    }
#ifdef WIN16
#if DBG==1
    if (g_hinstF3Debug > HINSTANCE_ERROR)
    {
        FreeLibrary(g_hinstF3Debug);
        g_hinstF3Debug = NULL;
    }
#endif
    DeinitHeap();
#endif

    if (g_pHtmPerfCtl)
        Verify(UnmapViewOfFile(g_pHtmPerfCtl));
    if (g_hMapHtmPerfCtl)
        Verify(CloseHandle(g_hMapHtmPerfCtl));
}

BOOL bCallCoInternetCombineUrl = FALSE;

void CheckOutllib()
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    HKEY        hKey;
    TCHAR szOutllibPath[MAX_PATH];
    DWORD cbData = sizeof(szOutllibPath)-sizeof(TCHAR);
        
    //Get App path of outlook.exe
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\OUTLOOK.EXE"), 
            0, KEY_QUERY_VALUE, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("Path"), NULL, NULL, (LPBYTE)szOutllibPath, &cbData))
        {
            szOutllibPath[cbData/sizeof(TCHAR)] = _T('\0');

            if ( MAX_PATH > _tcslen(szOutllibPath)+_tcslen(TEXT("outllib.dll")))
            {
                _tcscat(szOutllibPath, TEXT("outllib.dll"));
    
                dwVerInfoSize = GetFileVersionInfoSize(szOutllibPath, &dwHandle);
                if (dwVerInfoSize)
                {
                    // Alloc the memory for the version stamping
                    lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
                    if (lpBuffer)
                    {
                        // Read version stamping info
                        if (GetFileVersionInfo(szOutllibPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            // Get the value for Translation
                            if (VerQueryValue(lpBuffer, TEXT("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
                            {
                                DWORD dwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                                DWORD dwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                                //Needs version 9.0.0.5205 or higher
                                if (dwMSVer > 0x90000 || (dwMSVer == 0x90000 && dwLSVer >= 5205))
                                    bCallCoInternetCombineUrl = TRUE;
                            }
                        }
                        LocalFree(lpBuffer);
                    }
               }
            }
        }
        RegCloseKey(hKey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DllProcessAttach
//
//  Synopsis:   Initialize the DLL.
//
//  NOTE:       Even though DllMain is *not* called with DLL_THREAD_ATTACH
//              for the primary thread (since it is assumed during
//              DLL_PROCESS_ATTACH processing), this routines does not call
//              DllThreadAttach. Instead, all entry points are protected by a
//              call to EnsureThreadState which will, if necessary, call
//              DllThreadAttach. To call DllThreadAttach from here, might create
//              an unnecessary instance of the per-thread state structure.
//
//----------------------------------------------------------------------------

BOOL
DllProcessAttach()
{
    TCHAR *     pch = NULL;

#if DBG==1
    char szModule[MAX_PATH];
    GetModuleFileNameA(NULL, szModule, MAX_PATH);
#endif

#ifdef WIN16
    InitHeap();
#endif

    // Allocate per-thread storage index
    g_dwTls = TlsAlloc();
    if (g_dwTls == TLS_NULL)
        goto Error;

#ifndef WIN16
    // Prepare global variable's critical section
    if (CGlobalLock::Init() != S_OK)
        goto Error;
#endif // !WIN16

    if (CGlobalCriticalSection::InitializeAll() != S_OK)
        goto Error;
    else if (InitializeDownloadGlobals() != S_OK)
        goto Error;
    else if (CRtfToHtmlConverter::Init() != S_OK)
        goto Error;
        
    // TODO: Move initialization to C-runtime dll0crt.c
    //g_hProcessHeap = GetProcessHeap();

#if DBG==1

    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif // DBG==1

#if defined(DEBUG_TEAROFFS) && !defined(WIN16)
    DebugCheckAllTearoffTables();
#endif

    InitUnicodeWrappers();

    if (!SetDLLName())
    {
        TraceTag((tagError, "Could not SetDLLName! (%d)", GetLastError()));
        goto Error;
    }

    // Register common clipboard formats used in Forms^3.  These are
    // available in the g_acfCommon array.

    RegisterClipFormats();

    // Now that the g_acfCommon are registered, we can initialize
    // the clip format array for the form and all the controls.

#ifndef WIN16
    InitFormClipFormats();
#endif // ndef WIN16

    // Initialize the global halftone palette
    if (FAILED(InitPalette()))
        goto Error;


    // Build help file name

    _tcscpy(g_achHelpFileName, g_achDLLCore);

#ifndef _MAC
    pch = _tcsrchr(g_achHelpFileName, _T('.'));

    Assert(pch);
    Assert(pch+_tcslen(TEXT(".hlp")) < g_achHelpFileName+sizeof(g_achHelpFileName) / sizeof(g_achHelpFileName[0]) ); // assert there is space to add ".hlp"
    _tcscpy(pch, TEXT(".hlp"));
#endif

    IGNORE_HR(InitUrlCompatTable());

    IGNORE_HR(InitClassTable());

#ifdef SWITCHES_ENABLED
    InitRuntimeSwitches();
#endif

    // Initialize the font cache. We do this here instead
    // of in the InitTextSubSystem() function because that
    // is very slow and we don't want to do it until
    // we know we're loading text. We need to do this here
    // because the registry loading code will initialize
    // the font face atom table.
    if (InitFontCache() != S_OK)
        goto Error;

    // Hook into the htmperfctl block created by our host, if any

    char achName[sizeof(HTMPERFCTL_NAME) + 8 + 1];
    wsprintfA(achName, "%s%08lX", HTMPERFCTL_NAME, GetCurrentProcessId());

#ifndef UNIX // A hack to prevent Unix printing crash.
    g_hMapHtmPerfCtl = OpenFileMappingA(FILE_MAP_WRITE, FALSE, achName);
#else
    g_hMapHtmPerfCtl = NULL;
#endif

    if (g_hMapHtmPerfCtl)
    {
        // If MapViewOfFile fails then g_pHtmPerfCtl will be NULL, which is fine.  We just won't
        // have control of perf for this process.

        g_pHtmPerfCtl = (HTMPERFCTL *)MapViewOfFile(g_hMapHtmPerfCtl, FILE_MAP_WRITE, 0, 0, 0);

        Assert(g_pHtmPerfCtl);
    }
   
    //Haitaoli: 20736 [WinSERaid] Test if the version of outllib.dll >= 9.0.0.5205
    CheckOutllib();

    return TRUE;

Error:
    DllProcessDetach();
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//----------------------------------------------------------------------------
#ifndef WIN16

#if defined(UNIX) || defined(_MAC)
extern "C"
#endif
BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore = (HINSTANCE)hDll;
#ifdef DLOAD1
    BaseDllHandle = (HINSTANCE)hDll;    // for DelayLoadFailureHook
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fOk = DllProcessAttach();
        break;
    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        break;
    case DLL_THREAD_DETACH:
        DllThreadEmergencyDetach();
        break;
    }

    AssertThreadDisable(FALSE);

    return fOk;
}


#else // win16
BOOL FAR PASCAL __loadds
LibMain(
    HINSTANCE hDll,
    WORD wDataSeg,
    WORD cbHeapSize,
    LPSTR lpszCmdLine )
{
    BOOL fOk = TRUE;

    AssertThreadDisable(TRUE);

    g_hInstCore = hDll;

    fOk = DllProcessAttach();

    AssertThreadDisable(FALSE);

    return fOk;
}

extern "C" int CALLBACK _WEP(int nExitType)
//int __export WINAPI WEP(int nExitType)
{
    DllProcessDetach();

    // this isn't being called properly, so do it here.
    CUnloadLibraries CUnloadLibs;

    return 1;
}
#endif // !win16 else win16

#ifndef WIN16
//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//              (Only the secondary object count need be checked since it
//               contains the total secondary object count and the sum of
//               primary object counts maintained by each thread.)
//
//---------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
    if (g_lSecondaryObjCount == 0 && g_pts == NULL)
        return(S_OK);

    return(S_FALSE);
}
#endif // ndef WIN16

//+---------------------------------------------------------------------------
//
//  Function:   _IncrementObjectCount
//
//  Synopsis:   Increment the per-thread object count
//
//----------------------------------------------------------------------------

void
_IncrementObjectCount()
{
    TLS(dll.lObjCount)++;
    IncrementSecondaryObjectCount( 9 );
}

//+---------------------------------------------------------------------------
//
//  Function:   IncrementObjectCountChk
//
//  Synopsis:   Increment the per-thread object count, and remember the thread
//              id of the thread which did it.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
IncrementObjectCountChk(DWORD * pdwObjCnt)
{
    _IncrementObjectCount();

    if (pdwObjCnt)
    {
        *pdwObjCnt = GetCurrentThreadId();
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   _DecrementObjectCount
//
//  Synopsis:   Decrement the per-thread object count and passivate the
//              thread when it transitions to zero.
//
//----------------------------------------------------------------------------
void
_DecrementObjectCount()
{
    THREADSTATE * pts = GetThreadState();

    Assert(pts->dll.lObjCount > 0);

    if (--pts->dll.lObjCount == 0)
    {
        pts->dll.lObjCount += ULREF_IN_DESTRUCTOR;
        DllThreadPassivate(pts);
        pts->dll.lObjCount -= ULREF_IN_DESTRUCTOR;
        Assert(pts->dll.lObjCount == 0);
        DllThreadDetach(pts);
        LOCK_GLOBALS;
#ifndef WIN16
        if (g_pts == NULL)
        {
            DllAllThreadsDetach();
        }
#endif // ndef WIN16
    }
    DecrementSecondaryObjectCount( 9 );
}

//+---------------------------------------------------------------------------
//
//  Function:   DecrementObjectCountChk
//
//  Synopsis:   Verify that the thread which incremented the object count is
//              the same as the current thread, then decrement the object count.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
DecrementObjectCountChk(DWORD * pdwObjCnt)
{
    if (pdwObjCnt && *pdwObjCnt != GetCurrentThreadId())
    {
        char ach[512];
        wsprintfA(ach, "Attempt to DecrementObjectCount on the wrong thread.  The matching "
                 "IncrementObjectCount call happened on thread 0x%08lX; attemping release "
                 "on thread 0x%08lX.", *pdwObjCnt, GetCurrentThreadId());
#if DBG==1
        AssertSz(0, ach);
#else
        F3DebugBreak();
#endif
    }
    else
    {
        _DecrementObjectCount();
    }

    if (pdwObjCnt)
    {
        *pdwObjCnt = 0;
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   SetDLLName ()
//
//  Synopsis:   Get the fm20.dll
//
//----------------------------------------------------------------------------

#ifdef _MAC
TCHAR g_szMacBase[32];
#endif

BOOL  SetDLLName(  void )
{



    //  ISSUE:  Win95 has a known bug: If you specify the
    //          LOAD_LIBRARY_AS_DATAFILE flag, all subsequent Load<Resource>
    //          calls could fail. That's why we use a straight LoadLibrary to
    //          load the resource DLL. This is due to the differences between
    //          instance handles and module handles in Windows.
    //  Fix:    When a fix for Win95 is issued be sure to insert the flag here.
    //          When the change happens, the following Windows calls need to
    //          be reviewed:
    //          CreateDialog, CreateDialogParam, DialogBox, DialogBoxParam,
    //          MessageBox, MessageBoxIndirect.
    //  Note:   DONT_RESOLVE_DLL_REFERENCES is specified as "NT only"
#ifndef _MAC
    if ((GetModuleFileName(g_hInstCore,
                           g_achDLLCore,
                           ARRAY_SIZE(g_achDLLCore)) == 0)
                           || (_tcslen(g_achDLLCore) == 0))
        return( FALSE );
#else
    TCHAR    achAppLoc[MAX_PATH];

    if (GetModuleFileName(g_hInstCore, achAppLoc, MAX_PATH) == 0)

    if (GetFileTitle(achAppLoc,g_szMacBase,MAX_PATH))
            return( FALSE );

    if (_tcslen(g_szMacBase) == 0)
            return( FALSE );

    _tcscpy(g_achDLLCore,_T("MSHTM"));

#endif

    return (TRUE);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\comdlg32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <commdlg.h>

static
SHORT
APIENTRY
GetFileTitleW (
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL 
APIENTRY
ChooseColorA(
    LPCHOOSECOLORA lpcc
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
ChooseColorW(
    LPCHOOSECOLORW pccw
    )
{
    return FALSE;
}

static
BOOL APIENTRY
ChooseFontW(LPCHOOSEFONTW lpcf)
{
    return FALSE;
}

static
BOOL APIENTRY
ChooseFontA(LPCHOOSEFONTA lpcf)
{
    return FALSE;
}

static
DWORD APIENTRY
CommDlgExtendedError()
{
    return CDERR_INITIALIZATION;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comdlg32)
{
    DLPENTRY(ChooseColorA)
    DLPENTRY(ChooseColorW)
    DLPENTRY(ChooseFontA)
    DLPENTRY(ChooseFontW)
    DLPENTRY(CommDlgExtendedError)
    DLPENTRY(GetFileTitleW)
    DLPENTRY(GetOpenFileNameW)
    DLPENTRY(GetSaveFileNameW)
};

DEFINE_PROCNAME_MAP(comdlg32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\dload.h ===
#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;


#if DBG

//
// DelayLoadAssertFailed/MYASSERT used instead of RtlAssert/ASSERT
// as dload is also compiled to run on Win95
//

VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    );

VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    );

#define MYASSERT(x)     if(!(x)) { DelayLoadAssertFailed(#x,__FILE__,__LINE__,NULL); }

#else

#define MYASSERT(x)

#endif

FARPROC
LookupHandler (
    PDelayLoadInfo  pDelayInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\comctl32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _COMCTL32_
#include <commctrl.h>
#include <comctrlp.h>

static
WINCOMMCTRLAPI
HPROPSHEETPAGE
WINAPI
CreatePropertySheetPageW (
    LPCPROPSHEETPAGEW psp
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HWND
WINAPI
CreateUpDownControl (
    DWORD dwStyle, int x, int y, int cx, int cy,
    HWND hParent, int nID, HINSTANCE hInst,
    HWND hBuddy,
    int nUpper, int nLower, int nPos
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DestroyPropertySheetPage (
    HPROPSHEETPAGE hpage
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI DoReaderMode(PREADERMODEINFO prmi)
{
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_Add (
    HIMAGELIST himl,
    HBITMAP hbmImage,
    HBITMAP hbmMask
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Create (
    int cx, int cy, UINT flags, int cInitial, int cGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Destroy (
    HIMAGELIST himl
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Draw (
    HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Duplicate (
    HIMAGELIST himl
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HICON
WINAPI
ImageList_GetIcon (
    HIMAGELIST himl, int i, UINT flags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_GetIconSize (
    HIMAGELIST himl, int FAR *cx, int FAR *cy
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageW (
    HINSTANCE hi,
    LPCWSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_ReplaceIcon (
    HIMAGELIST himl, int i, HICON hicon
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
COLORREF
WINAPI
ImageList_SetBkColor (
    HIMAGELIST himl,
    COLORREF clrBk
    )
{
    return CLR_NONE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_SetOverlayImage (
    HIMAGELIST himl,
    int iImage,
    int iOverlay
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI InitCommonControls (
    void
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
InitCommonControlsEx (
    LPINITCOMMONCONTROLSEX icce
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetW (
    LPCPROPSHEETHEADERW psh
    )
{
    return -1;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(comctl32)
{
//     DLOENTRY(16, CreateUpDownControl)
    DLOENTRY(17, InitCommonControls)
    DLOENTRY(383, DoReaderMode)
};

DEFINE_ORDINAL_MAP(comctl32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comctl32)
{
//     DLPENTRY(CreatePropertySheetPageW)
//     DLPENTRY(DestroyPropertySheetPage)
//     DLPENTRY(ImageList_Add)
//     DLPENTRY(ImageList_Create)
//     DLPENTRY(ImageList_Destroy)
//     DLPENTRY(ImageList_Draw)
//     DLPENTRY(ImageList_Duplicate)
    DLPENTRY(ImageList_GetIcon)
//     DLPENTRY(ImageList_GetIconSize)
//     DLPENTRY(ImageList_LoadImageW)
//     DLPENTRY(ImageList_ReplaceIcon)
//     DLPENTRY(ImageList_SetBkColor)
//     DLPENTRY(ImageList_SetOverlayImage)
//     DLPENTRY(InitCommonControlsEx)
//     DLPENTRY(PropertySheetW)
};

DEFINE_PROCNAME_MAP(comctl32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\hlink.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <hlink.h>

static 
STDMETHODIMP HlinkCreateFromMoniker(
             IMoniker * pimkTrgt,
             LPCWSTR pwzLocation,
             LPCWSTR pwzFriendlyName,
             IHlinkSite * pihlsite,
             DWORD dwSiteData,
             IUnknown * piunkOuter,
             REFIID riid,
             void ** ppvObj)
               
{
    *ppvObj = NULL;
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(hlink)
{
    DLOENTRY(3, HlinkCreateFromMoniker)
};

DEFINE_ORDINAL_MAP(hlink)


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\imgutil.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <ddraw.h>
#include <imgutil.h>

static
HRESULT
WINAPI
CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
    return E_FAIL;
}

static
HRESULT
WINAPI
DecodeImage(
    IStream* pStream,
    IMapMIMEToCLSID* pMap,
    IUnknown* pEventSink
    )
{
    return E_FAIL;
}

static
HRESULT
WINAPI
IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, UINT* pnFormat )
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imgutil)
{
    DLPENTRY(CreateDDrawSurfaceOnDIB)
    DLPENTRY(DecodeImage)
    DLPENTRY(IdentifyMIMEType)
};

DEFINE_PROCNAME_MAP(imgutil)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dll\factory.cxx ===
//+------------------------------------------------------------------------
//
//  File:       factory.cxx
//
//  Contents:   Class factories.
//
//  History:    20-Dec-94   GaryBu Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include <ocmm.h>
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifdef WIN16
#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h>
#endif

#define NO_DEBUG_HOOK
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_IIMGCTX_H_
#define X_IIMGCTX_H_
#include "iimgctx.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include <htmldlg.hxx>
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include <htmlpop.hxx>
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_CLSFAC3_HXX_
#define X_CLSFAC3_HXX_
#include "clsfac3.hxx"
#endif

#ifndef X_OPTARY_H_
#define X_OPTARY_H_
#include <optary.h>
#endif

#ifndef X_SHLGUIDP_H_
#define X_SHLGUIDP_H_
#include <shlguidp.h>
#endif

#ifdef UNIX
EXTERN_C const CLSID CLSID_CRowPosition;
extern CBaseCF::FNCREATE CreateRowPosition;
#endif

#pragma warning(disable: 4041)

EXTERN_C const GUID CLSID_DataObject;
EXTERN_C const GUID CLSID_HTMLWindowProxy;
EXTERN_C const GUID CLSID_HTMLServerDoc;
EXTERN_C const GUID CLSID_Scriptlet;
EXTERN_C const GUID CLSID_MHTMLDocument;
EXTERN_C const GUID CLSID_HTMLPluginDocument;
EXTERN_C const GUID CLSID_HTADoc;
EXTERN_C const GUID CLSID_HTMLPopupDoc;

//+------------------------------------------------------------------------
//
//  Create instance functions
//
//-------------------------------------------------------------------------

extern CBaseCF::FNCREATE CreateDoc;
extern CBaseCF::FNCREATE CreateScriptlet;
extern CBaseCF::FNCREATE CreateMhtmlDoc;
extern CBaseCF::FNINITCLASS InitDocClass;
extern CBaseCF::FNCREATE CreateDocFullWindowEmbed;  // ref to plugin handle file mechanism.
extern CBaseCF::FNCREATE CreateHTADoc;
extern CBaseCF::FNCREATE CreatePopupDoc;
extern CBaseCF::FNCREATE CreatePropertyFrame;

#ifndef NO_PROPERTY_PAGE
extern CStaticCF::FNCREATE CreateGenericPropertyPage;
extern CStaticCF::FNCREATE CreateInlineStylePropertyPage;
#endif // NO_PROPERTY_PAGE
extern CStaticCF::FNCREATE CreateDwnBindInfo;
extern CStaticCF::FNCREATE CreateIImgCtx;
extern CStaticCF::FNCREATE CreateIImageDecodeFilter;
extern CStaticCF::FNCREATE CreateIIntDitherer;
extern CStaticCF::FNCREATE CreateSecurityProxy;
extern CStaticCF::FNCREATE CreateHtmlLoadOptions;
extern CStaticCF::FNCREATE CreateRecalcEngine;
extern CStaticCF::FNCREATE CreateTridentAPI;
extern CStaticCF::FNCREATE CreateExternalFrameworkSite;

#ifndef NO_DEBUG_HOOK
class CHook;

extern CHook * CreateHook();
#endif

//+------------------------------------------------------------------------
//
//  Class factories
//
//-------------------------------------------------------------------------

// Use CBaseLockCF for documents so that clients can addref thread state
// without holding on to an instance of the document.
CBaseLockCF g_cfDoc                     (CreateDoc, InitDocClass);
CBaseLockCF g_cfHTADoc                  (CreateHTADoc, InitDocClass);
CBaseLockCF g_cfHTMLPopupDoc            (CreatePopupDoc, InitDocClass);
CBaseLockCF g_cfScriptlet               (CreateScriptlet, InitDocClass);

CBaseCF     g_cfMhtmlDoc                (CreateMhtmlDoc, InitDocClass);
CBaseCF     g_cfDocFullWindowEmbed      (CreateDocFullWindowEmbed, InitDocClass);

#if !defined(NO_PROPERTY_PAGE) && (DBG==1)
CStaticCF   g_cfGenericPropertyPage     (CreateGenericPropertyPage);
CStaticCF   g_cfInlineStylePropertyPage (CreateInlineStylePropertyPage);
#endif // NO_PROPERTY_PAGE

CStaticCF   g_cfCDwnBindInfo            (CreateDwnBindInfo);
CStaticCF   g_cfIImgCtx                 (CreateIImgCtx);
CStaticCF   g_cfIImageDecodeFilter      (CreateIImageDecodeFilter);
CStaticCF   g_cfIIntDitherer            (CreateIIntDitherer);
CStaticCF   g_cfSecurityProxy           (CreateSecurityProxy);
CStaticCF   g_cfHtmlLoadOptions         (CreateHtmlLoadOptions);
CStaticCF   g_cfRecalcEngine            (CreateRecalcEngine);
CStaticCF   g_cfTridentAPI              (CreateTridentAPI);

  
  


#ifdef UNIX
CBaseCF     g_cfRowPosition             (CreateRowPosition);
#endif

extern class CResProtocolCF g_cfResProtocol;
extern class CJSProtocolCF  g_cfJSProtocol;
extern class CSysimageProtocolCF  g_cfSysimageProtocol;
extern class CHTMLPopupFactory g_cfHTMLPopup;
#ifndef WIN16
extern class CMailtoFactory g_cfMailtoProtocol;
#endif

// HTC Constructor Constructor - see comments in peerfact.cxx
extern const CLSID CLSID_CHtmlComponentConstructorFactory;

class CHtmlComponentConstructorFactory;
extern CHtmlComponentConstructorFactory g_cfHtmlComponentConstructorFactory;

extern class CAboutProtocolCF g_cfAboutProtocol;
//+------------------------------------------------------------------------
//
//  Class factory cache
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};

const CLSCACHE g_aclscache[] =
{
    &CLSID_HTMLDocument,                        &g_cfDoc,
    &CLSID_Scriptlet,                           &g_cfScriptlet,
    &CLSID_MHTMLDocument,                       &g_cfMhtmlDoc,
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,              &g_cfGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,            &g_cfInlineStylePropertyPage,
#endif //  DBG==1
    &CLSID_CDwnBindInfo,                        &g_cfCDwnBindInfo,
    &CLSID_IImgCtx,                             &g_cfIImgCtx,
    &CLSID_IImageDecodeFilter,                  &g_cfIImageDecodeFilter,
    &CLSID_IntDitherer,                         &g_cfIIntDitherer,
    &CLSID_JSProtocol,                          (IClassFactory *)(void *)&g_cfJSProtocol,
    &CLSID_ResProtocol,                         (IClassFactory *)(void *)&g_cfResProtocol,
    &CLSID_SysimageProtocol,                    (IClassFactory *)(void *)&g_cfSysimageProtocol,
    &CLSID_HTMLPopup,                          (IClassFactory *)(void *)&g_cfHTMLPopup,
#ifndef WIN16
    &CLSID_MailtoProtocol,                      (IClassFactory *)(void *)&g_cfMailtoProtocol,
#endif // ndef WIN16
    &CLSID_AboutProtocol,                       (IClassFactory *)(void *)&g_cfAboutProtocol,
    &CLSID_HTMLWindowProxy,                     &g_cfSecurityProxy,

    // Special way to create a CDoc based on this alternative magic clsid:
    &CLSID_HTMLPluginDocument,                  &g_cfDocFullWindowEmbed,
    &CLSID_HTMLLoadOptions,                     &g_cfHtmlLoadOptions,
    &CLSID_CRecalcEngine,                       &g_cfRecalcEngine,
    &CLSID_HTADoc,                              &g_cfHTADoc,
    &CLSID_HTMLPopupDoc,                        &g_cfHTMLPopupDoc,

    &CLSID_HostDialogHelper,                    &g_cfTridentAPI,
    &CLSID_CHtmlComponentConstructorFactory,    (CStaticCF*)&g_cfHtmlComponentConstructorFactory,

  

#ifdef UNIX
    &CLSID_CRowPosition,                        &g_cfRowPosition,
#endif
};

//+---------------------------------------------------------------
//
//  Function:   LocalGetClassObject
//
//  Synopsis:   Local function for locating class factories
//
//----------------------------------------------------------------

HRESULT
LocalGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    int             i;
    const CLSCACHE * pcc;    

    //
    // First try the class cache.
    //

    for (i = ARRAY_SIZE(g_aclscache) - 1, pcc = g_aclscache;
         i >= 0;
         i--, pcc++)
    {
        Assert(pcc->pclsid && pcc->pCF);
        if (IsEqualCLSID(clsid, *pcc->pclsid))
        {
            hr = pcc->pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    //
    // Second, check of it is a Property Page CLSID shdocvw understands, if so
    // we create a CPropPageCF specific to the resource moniker identified
    // by the CLSID
    //

#ifndef NO_HTML_DIALOG         
    IOleCommandTarget * pCommandTarget = NULL;
    IMoniker          * pmk = NULL;
    CHTMLPropPageCF   * pHTMLPropPageCF = NULL;
    VARIANT             varIn;
    VARIANT             varOut;
    BOOL                fIsPropPageClsid = FALSE;
    
    VariantInit(&varOut);

    // co-create shdocvw
    hr = THR(CoCreateInstance(
            CLSID_DocHostUIHandler,                              
            NULL,            
            CLSCTX_INPROC_SERVER,            
            IID_IOleCommandTarget,            
            (void**)&pCommandTarget));
    if (hr)
        goto PropPageCleanup;
    
    // check if the clsid is a property page supported by shdocvw

    V_VT(&varIn) = VT_UINT_PTR;
    V_BYREF(&varIn) = (void *)&clsid;
    hr = pCommandTarget->Exec(
            &CGID_DocHostCommandHandler, 
            SHDVID_CLSIDTOMONIKER, 
            0, 
            &varIn, 
            &varOut);       
    fIsPropPageClsid = !hr;
    if (hr)
        goto PropPageCleanup;   

    // extract the IMoniker *
    if (V_VT(&varOut) == VT_UNKNOWN)
        hr = V_UNKNOWN(&varOut)->QueryInterface(IID_IMoniker, (void**)&pmk);
    else
        hr = E_FAIL;
    if (hr)
        goto PropPageCleanup;

    // create a class factory specific to the moniker
    pHTMLPropPageCF = new CHTMLPropPageCF(pmk);
    hr = pHTMLPropPageCF->QueryInterface(iid, ppv);
    if (hr)
        goto PropPageCleanup;

PropPageCleanup:
    ReleaseInterface(pHTMLPropPageCF);
    ReleaseInterface(pmk);
    ReleaseInterface(pCommandTarget);
    VariantClear(&varOut);

    // stop if the clsid was a prop page's clsid
    if (fIsPropPageClsid)
        RRETURN(hr);

#endif // NO_HTML_DIALOG


#ifndef NO_DEBUG_HOOK
    //
    // Maybe its a debug hook request
    //
    if (IsEqualCLSID(clsid, CLSID_CHook))
    {
        *ppv = CreateHook();

        RRETURN(*ppv ? S_OK : E_OUTOFMEMORY);
    }
#endif // NO_DEBUG_HOOK

    *ppv = NULL;
    RRETURN(CLASS_E_CLASSNOTAVAILABLE);
}


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    RRETURN_NOTRACE(LocalGetClassObject(clsid, iid, ppv));
}


//+---------------------------------------------------------------
//
//  Function:   DllEnumClassObjects
//
//  Synopsis:   
//
//----------------------------------------------------------------

STDAPI
DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if ((UINT)i >= ARRAY_SIZE(g_aclscache))
        return S_FALSE;

    *pclsid = *g_aclscache[i].pclsid;
    *ppUnk = g_aclscache[i].pCF;
    (*ppUnk)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\mpr.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <winnetwk.h>

static
DWORD
APIENTRY
WNetAddConnection2W(
     IN LPNETRESOURCEW lpNetResource,
     IN LPCWSTR       lpPassword,
     IN LPCWSTR       lpUserName,
     IN DWORD          dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
WNetAddConnection3W(
    IN HWND             hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR          lpPassword,
    IN LPCWSTR          lpUserName,
    IN DWORD            dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCancelConnection2W(
    IN LPCWSTR  lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCloseEnum(
    IN HANDLE   hEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetEnumResourceW(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUniversalNameW(
     IN LPCWSTR lpLocalPath,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpBufferSize
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationW(
    IN LPNETRESOURCEW   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPWSTR         *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumA(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumW(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}


DEFINE_PROCNAME_ENTRIES(mpr)
{
//     DLPENTRY(WNetAddConnection2W)
//     DLPENTRY(WNetAddConnection3W)
//     DLPENTRY(WNetCancelConnection2W)
    DLPENTRY(WNetCloseEnum)
//     DLPENTRY(WNetEnumResourceW)
//     DLPENTRY(WNetGetResourceInformationW)
//     DLPENTRY(WNetGetUniversalNameW)
    DLPENTRY(WNetOpenEnumA)
    DLPENTRY(WNetOpenEnumW)
};

DEFINE_PROCNAME_MAP(mpr)


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\imm32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <imm.h>

static 
UINT WINAPI ImmGetVirtualKey(IN HWND a)
{
    return 0;
}

static
BOOL WINAPI ImmSetOpenStatusDIMM(HIMC hIMC, BOOL fOpen)
{
    return FALSE;
}

static
BOOL WINAPI ImmSetConversionStatus(IN HIMC hIMC, IN DWORD dw1, IN DWORD dw2)
{
    return FALSE;
}

static
HIMC WINAPI ImmGetContext(IN HWND hwnd)
{
    return 0;
}

static
HIMC WINAPI ImmAssociateContext(IN HWND hwnd, IN HIMC hIMC)
{
    return 0;
}

static
BOOL WINAPI ImmGetConversionStatus(IN HIMC hIMC, OUT LPDWORD lpdw1, OUT LPDWORD lpdw2)
{
    return FALSE;
}

static
LONG  WINAPI ImmGetCompositionStringW(IN HIMC hIMC, IN DWORD dw1, OUT LPVOID pv, IN DWORD dw2)
{
    return 0;
}

static
BOOL  WINAPI ImmSetCompositionStringA(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dw1, IN LPVOID lpRead, IN DWORD dw2)
{
    return FALSE;
}

static
LRESULT WINAPI ImmEscapeW(IN HKL hkl, IN HIMC hIMC, IN UINT ui, IN LPVOID pv)
{
    return 0;
}

static
LRESULT WINAPI ImmEscapeA(IN HKL hkl, IN HIMC hIMC, IN UINT ui, IN LPVOID pv)
{
    return 0;
}

static
BOOL WINAPI ImmSetCandidateWindow(IN HIMC hIMC, IN LPCANDIDATEFORM lpcf)
{
    return FALSE;
}

static
BOOL WINAPI ImmReleaseContext(IN HWND hwnd, IN HIMC hIMC)
{
    return FALSE;
}

static
DWORD WINAPI ImmGetProperty(IN HKL hkl, IN DWORD dw)
{
    return 0;
}

static
BOOL WINAPI ImmSetCompositionWindow(IN HIMC hIMC, IN LPCOMPOSITIONFORM lpcf)
{
    return FALSE;
}

static
LONG  WINAPI ImmGetCompositionStringA(IN HIMC hIMC, IN DWORD dw1, OUT LPVOID lpv, IN DWORD dw2)
{
    return 0;
}

static
BOOL WINAPI ImmGetCandidateWindow(IN HIMC hIMC, IN DWORD dw, OUT LPCANDIDATEFORM lpcf)
{
    return FALSE;
}

static
BOOL    WINAPI ImmNotifyIME(IN HIMC hIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue)
{
    return FALSE;
}

static
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dw1, IN LPVOID lpRead, IN DWORD dw2)
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imm32)
{
    DLPENTRY(ImmAssociateContext)
    DLPENTRY(ImmEscapeA)
    DLPENTRY(ImmEscapeW)
    DLPENTRY(ImmGetCandidateWindow)
    DLPENTRY(ImmGetCompositionStringA)
    DLPENTRY(ImmGetCompositionStringW)
    DLPENTRY(ImmGetContext)
    DLPENTRY(ImmGetConversionStatus)
    DLPENTRY(ImmGetProperty)
    DLPENTRY(ImmGetVirtualKey)
    DLPENTRY(ImmNotifyIME)
    DLPENTRY(ImmReleaseContext)
    DLPENTRY(ImmSetCandidateWindow)
    DLPENTRY(ImmSetCompositionStringA)
    DLPENTRY(ImmSetCompositionStringW)
    DLPENTRY(ImmSetCompositionWindow)
    DLPENTRY(ImmSetConversionStatus)
    DLPENTRY(ImmSetOpenStatus)
};

DEFINE_PROCNAME_MAP(imm32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\msrating.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <ratings.h>

static 
STDMETHODIMP RatingEnabledQuery()
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msrating)
{
    DLPENTRY(RatingEnabledQuery)
};

DEFINE_PROCNAME_MAP(msrating)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\msjava.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define JAVAVMAPI
#include <native.h>

static
JAVAVMAPI
long
__cdecl
execute_java_dynamic_method(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...                             
    )
{
    return 0;
}

static
JAVAVMAPI
int64_t
__cdecl
execute_java_dynamic_method64(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...
    )
{
    return 0;
}

static
JAVAVMAPI
void
__cdecl
GCFramePush(
    PVOID pGCFrame,
    PVOID pObjects,
    DWORD cbObjectStructSize
    )
{
}

static
JAVAVMAPI
BOOL
__cdecl
is_instance_of(
    HObject    *phObj,
    ClassClass *pClass,
    ExecEnv    *Unused
    )
{
    return FALSE;
}

static
JAVAVMAPI
void
__cdecl
GCFramePop(
    PVOID pGCFrame
    )
{
}

static
JAVAVMAPI
HObject*
__cdecl
execute_java_constructor(
    ExecEnv *Unused,
    PCUTF8 putfClassName,
    ClassClass *pClass,
    PCUTF8 putfSignature,
    ...
    )
{
    return NULL;
}

static
JAVAVMAPI
HString *
__cdecl
makeJavaStringW(
    LPCWSTR pcwsz,
    int cch
    )
{
    return NULL;
}

static
JAVAVMAPI
HObject *
__cdecl
convert_IUnknown_to_Java_Object(
    IUnknown *punk,
    HObject *phJavaClass,
    int fAssumeThreadSafe
    )
{
    return NULL;
}

static
JAVAVMAPI
ClassClass*
__cdecl
FindClass(
    ExecEnv *Unused,
    PCUTF8   putfClassName,
    bool_t   fResolve
    )
{
    return NULL;
}

static
JAVAVMAPI
void*
__cdecl
jcdwGetData(
    HObject *phJCDW
    )
{
    return NULL;
}

static
JAVAVMAPI
IUnknown *
__cdecl
convert_Java_Object_to_IUnknown(
    HObject *phJavaObject,
    const IID *pIID
    )
{
    return NULL;
}

static
JAVAVMAPI
LPWSTR
__cdecl
javaStringStart(
    HString *phString
    )
{
    return NULL;
}

static
JAVAVMAPI
int
__cdecl
javaStringLength(
    HString *phString
    )
{
    return 0;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msjava)
{
    DLPENTRY(FindClass)
    DLPENTRY(GCFramePop)
    DLPENTRY(GCFramePush)
    DLPENTRY(convert_IUnknown_to_Java_Object)
    DLPENTRY(convert_Java_Object_to_IUnknown)
    DLPENTRY(execute_java_constructor)
    DLPENTRY(execute_java_dynamic_method)
    DLPENTRY(execute_java_dynamic_method64)
    DLPENTRY(is_instance_of)
    DLPENTRY(javaStringLength)    
    DLPENTRY(javaStringStart)
    DLPENTRY(jcdwGetData)
    DLPENTRY(makeJavaStringW)
};

DEFINE_PROCNAME_MAP(msjava)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\oleaut32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _OLEAUT32_
#include <oleauto.h>
#include <ocidl.h>
#include <olectl.h>

#define NOTIMPV(func)       { OutputDebugStringA("OLEAUT32: Delayload stub called: " #func "\r\n"); }
#define NOTIMP_(ret, func)  { OutputDebugStringA("OLEAUT32: Delayload stub called: " #func "\r\n"); return(ret); }
#define NOTIMP(func)        NOTIMP_(E_NOTIMPL, func)

static STDMETHODIMP_(BSTR) SysAllocString(const OLECHAR * sz)
{
    NOTIMP_(NULL, SysAllocString);
}

static STDMETHODIMP_(INT) SysReAllocString(BSTR * pbstr, const OLECHAR * sz)
{
    NOTIMP_(FALSE, SysReAllocString);
}

static STDMETHODIMP_(BSTR) SysAllocStringLen(const OLECHAR * szIn, UINT cch)
{
    NOTIMP_(NULL, SysAllocStringLen);
}

static STDMETHODIMP_(INT) SysReAllocStringLen(BSTR * pbstr, const OLECHAR * sz, UINT cch)
{
    NOTIMP_(FALSE, SysReAllocStringLen);
}

static STDMETHODIMP_(void) SysFreeString(BSTR bstr)
{
    NOTIMPV(SysFreeString);
}

static STDMETHODIMP_(UINT) SysStringLen(BSTR bstr)
{
    NOTIMP_(0, SysStringLen);
}

static STDMETHODIMP_(UINT) SysStringByteLen(BSTR bstr)
{
    NOTIMP_(0, SysStringByteLen);
}

static STDMETHODIMP_(BSTR) SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    NOTIMP_(NULL, SysAllocStringByteLen);
}

static STDMETHODIMP_(INT) DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime)
{
    NOTIMP_(0, DosDateTimeToVariantTime);
}

static STDMETHODIMP_(INT) VariantTimeToDosDateTime(DOUBLE vtime, USHORT * pwDosDate, USHORT * pwDosTime)
{
    NOTIMP_(0, VariantTimeToDosDateTime);
}

static STDMETHODIMP_(INT) SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, DOUBLE *pvtime)
{
    NOTIMP_(0, SystemTimeToVariantTime);
}

static STDMETHODIMP_(INT) VariantTimeToSystemTime(DOUBLE vtime, LPSYSTEMTIME lpSystemTime)
{
    NOTIMP_(0, VariantTimeToSystemTime);
}

static STDMETHODIMP SafeArrayAllocDescriptor(UINT cDims, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayAllocDescriptor);
}

static STDMETHODIMP SafeArrayAllocDescriptorEx(VARTYPE vt, UINT cDims, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayAllocDescriptorEx);
}

static STDMETHODIMP SafeArrayAllocData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayAllocData);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreate(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound)
{
    NOTIMP_(NULL, SafeArrayCreate);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateEx(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra)
{
    NOTIMP_(NULL, SafeArrayCreateEx);
}

static STDMETHODIMP SafeArrayCopyData(SAFEARRAY *psaSource, SAFEARRAY *psaTarget)
{
    NOTIMP(SafeArrayCopyData);
}

static STDMETHODIMP SafeArrayDestroyDescriptor(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroyDescriptor);
}

static STDMETHODIMP SafeArrayDestroyData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroyData);
}

static STDMETHODIMP SafeArrayDestroy(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayDestroy);
}

static STDMETHODIMP SafeArrayRedim(SAFEARRAY * psa, SAFEARRAYBOUND * psaboundNew)
{
    NOTIMP(SafeArrayRedim);
}

static STDMETHODIMP_(UINT) SafeArrayGetDim(SAFEARRAY * psa)
{
    NOTIMP_(0, SafeArrayGetDim);
}

static STDMETHODIMP_(UINT) SafeArrayGetElemsize(SAFEARRAY * psa)
{
    NOTIMP_(0, SafeArrayGetElemsize);
}

static STDMETHODIMP SafeArrayGetUBound(SAFEARRAY * psa, UINT nDim, LONG * plUbound)
{
    NOTIMP(SafeArrayGetUBound);
}

static STDMETHODIMP SafeArrayGetLBound(SAFEARRAY * psa, UINT nDim, LONG * plLbound)
{
    NOTIMP(SafeArrayGetLBound);
}

static STDMETHODIMP SafeArrayLock(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayLock);
}

static STDMETHODIMP SafeArrayUnlock(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayUnlock);
}

static STDMETHODIMP SafeArrayAccessData(SAFEARRAY * psa, void HUGEP** ppvData)
{
    NOTIMP(SafeArrayAccessData);
}

static STDMETHODIMP SafeArrayUnaccessData(SAFEARRAY * psa)
{
    NOTIMP(SafeArrayUnaccessData);
}

static STDMETHODIMP SafeArrayGetElement(SAFEARRAY * psa, LONG * rgIndices, void * pv)
{
    NOTIMP(SafeArrayGetElement);
}

static STDMETHODIMP SafeArrayPutElement(SAFEARRAY * psa, LONG * rgIndices, void * pv)
{
    NOTIMP(SafeArrayPutElement);
}

static STDMETHODIMP SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    NOTIMP(SafeArrayCopy);
}

static STDMETHODIMP SafeArrayPtrOfIndex(SAFEARRAY * psa, LONG * rgIndices, void ** ppvData)
{
    NOTIMP(SafeArrayPtrOfIndex);
}

static STDMETHODIMP SafeArraySetRecordInfo(SAFEARRAY * psa, IRecordInfo * prinfo)
{
    NOTIMP(SafeArraySetRecordInfo);
}

static STDMETHODIMP SafeArrayGetRecordInfo(SAFEARRAY * psa, IRecordInfo ** prinfo)
{
    NOTIMP(SafeArrayGetRecordInfo);
}

static STDMETHODIMP SafeArraySetIID(SAFEARRAY * psa, REFGUID guid)
{
    NOTIMP(SafeArraySetIID);
}

static STDMETHODIMP SafeArrayGetIID(SAFEARRAY * psa, GUID * pguid)
{
    NOTIMP(SafeArrayGetIID);
}

static STDMETHODIMP SafeArrayGetVartype(SAFEARRAY * psa, VARTYPE * pvt)
{
    NOTIMP(SafeArrayGetVartype);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateVector(VARTYPE vt, LONG lLbound, ULONG cElements)
{
    NOTIMP_(NULL, SafeArrayCreateVector);
}

static STDMETHODIMP_(SAFEARRAY *) SafeArrayCreateVectorEx(VARTYPE vt, LONG lLbound, ULONG cElements, PVOID pvExtra)
{
    NOTIMP_(NULL, SafeArrayCreateVectorEx);
}

static STDMETHODIMP_(void) VariantInit(VARIANTARG * pvarg)
{
    pvarg->vt = VT_EMPTY;
}

static STDMETHODIMP VariantClear(VARIANTARG * pvarg)
{
    pvarg->vt = VT_EMPTY;
    return E_NOTIMPL;
}

static STDMETHODIMP VariantCopy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    NOTIMP(VariantCopy);
}

static STDMETHODIMP VariantCopyInd(VARIANT * pvarDest, VARIANTARG * pvargSrc)
{
    NOTIMP(VariantCopyInd);
}

static STDMETHODIMP VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt)
{
    NOTIMP(VariantChangeType);
}

static STDMETHODIMP VariantChangeTypeEx(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt)
{
    NOTIMP(VariantChangeTypeEx);
}

static STDMETHODIMP VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    NOTIMP(VectorFromBstr);
}

static STDMETHODIMP BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    NOTIMP(BstrFromVector);
}

static STDMETHODIMP VarUI1FromI2(SHORT sIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromI2);
}

static STDMETHODIMP VarUI1FromI4(LONG lIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromI4);
}

static STDMETHODIMP VarUI1FromR4(FLOAT fltIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromR4);
}

static STDMETHODIMP VarUI1FromR8(DOUBLE dblIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromR8);
}

static STDMETHODIMP VarUI1FromCy(CY cyIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromCy);
}

static STDMETHODIMP VarUI1FromDate(DATE dateIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromDate);
}

static STDMETHODIMP VarUI1FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, BYTE * pbOut)
{
    NOTIMP(VarUI1FromStr);
}

static STDMETHODIMP VarUI1FromDisp(IDispatch * pdispIn, LCID lcid, BYTE * pbOut)
{
    NOTIMP(VarUI1FromDisp);
}

static STDMETHODIMP VarUI1FromBool(VARIANT_BOOL boolIn, BYTE * pbOut)
{
    NOTIMP(VarUI1FromBool);
}

static STDMETHODIMP VarUI1FromI1(CHAR cIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromI1);
}

static STDMETHODIMP VarUI1FromUI2(USHORT uiIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromUI2);
}

static STDMETHODIMP VarUI1FromUI4(ULONG ulIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromUI4);
}

static STDMETHODIMP VarUI1FromDec(DECIMAL *pdecIn, BYTE *pbOut)
{
    NOTIMP(VarUI1FromDec);
}

static STDMETHODIMP VarI2FromUI1(BYTE bIn, SHORT * psOut)
{
    NOTIMP(VarI2FromUI1);
}

static STDMETHODIMP VarI2FromI4(LONG lIn, SHORT * psOut)
{
    NOTIMP(VarI2FromI4);
}

static STDMETHODIMP VarI2FromR4(FLOAT fltIn, SHORT * psOut)
{
    NOTIMP(VarI2FromR4);
}

static STDMETHODIMP VarI2FromR8(DOUBLE dblIn, SHORT * psOut)
{
    NOTIMP(VarI2FromR8);
}

static STDMETHODIMP VarI2FromCy(CY cyIn, SHORT * psOut)
{
    NOTIMP(VarI2FromCy);
}

static STDMETHODIMP VarI2FromDate(DATE dateIn, SHORT * psOut)
{
    NOTIMP(VarI2FromDate);
}

static STDMETHODIMP VarI2FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, SHORT * psOut)
{
    NOTIMP(VarI2FromStr);
}

static STDMETHODIMP VarI2FromDisp(IDispatch * pdispIn, LCID lcid, SHORT * psOut)
{
    NOTIMP(VarI2FromDisp);
}

static STDMETHODIMP VarI2FromBool(VARIANT_BOOL boolIn, SHORT * psOut)
{
    NOTIMP(VarI2FromBool);
}

static STDMETHODIMP VarI2FromI1(CHAR cIn, SHORT *psOut)
{
    NOTIMP(VarI2FromI1);
}

static STDMETHODIMP VarI2FromUI2(USHORT uiIn, SHORT *psOut)
{
    NOTIMP(VarI2FromUI2);
}

static STDMETHODIMP VarI2FromUI4(ULONG ulIn, SHORT *psOut)
{
    NOTIMP(VarI2FromUI4);
}

static STDMETHODIMP VarI2FromDec(DECIMAL *pdecIn, SHORT *psOut)
{
    NOTIMP(VarI2FromDec);
}

static STDMETHODIMP VarI4FromUI1(BYTE bIn, LONG * plOut)
{
    NOTIMP(VarI4FromUI1);
}

static STDMETHODIMP VarI4FromI2(SHORT sIn, LONG * plOut)
{
    NOTIMP(VarI4FromI2);
}

static STDMETHODIMP VarI4FromR4(FLOAT fltIn, LONG * plOut)
{
    NOTIMP(VarI4FromR4);
}

static STDMETHODIMP VarI4FromR8(DOUBLE dblIn, LONG * plOut)
{
    NOTIMP(VarI4FromR8);
}

static STDMETHODIMP VarI4FromCy(CY cyIn, LONG * plOut)
{
    NOTIMP(VarI4FromCy);
}

static STDMETHODIMP VarI4FromDate(DATE dateIn, LONG * plOut)
{
    NOTIMP(VarI4FromDate);
}

static STDMETHODIMP VarI4FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, LONG * plOut)
{
    NOTIMP(VarI4FromStr);
}

static STDMETHODIMP VarI4FromDisp(IDispatch * pdispIn, LCID lcid, LONG * plOut)
{
    NOTIMP(VarI4FromDisp);
}

static STDMETHODIMP VarI4FromBool(VARIANT_BOOL boolIn, LONG * plOut)
{
    NOTIMP(VarI4FromBool);
}

static STDMETHODIMP VarI4FromI1(CHAR cIn, LONG *plOut)
{
    NOTIMP(VarI4FromI1);
}

static STDMETHODIMP VarI4FromUI2(USHORT uiIn, LONG *plOut)
{
    NOTIMP(VarI4FromUI2);
}

static STDMETHODIMP VarI4FromUI4(ULONG ulIn, LONG *plOut)
{
    NOTIMP(VarI4FromUI4);
}

static STDMETHODIMP VarI4FromDec(DECIMAL *pdecIn, LONG *plOut)
{
    NOTIMP(VarI4FromDec);
}

static STDMETHODIMP VarR4FromUI1(BYTE bIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromUI1);
}

static STDMETHODIMP VarR4FromI2(SHORT sIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromI2);
}

static STDMETHODIMP VarR4FromI4(LONG lIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromI4);
}

static STDMETHODIMP VarR4FromR8(DOUBLE dblIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromR8);
}

static STDMETHODIMP VarR4FromCy(CY cyIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromCy);
}

static STDMETHODIMP VarR4FromDate(DATE dateIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromDate);
}

static STDMETHODIMP VarR4FromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromStr);
}

static STDMETHODIMP VarR4FromDisp(IDispatch * pdispIn, LCID lcid, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromDisp);
}

static STDMETHODIMP VarR4FromBool(VARIANT_BOOL boolIn, FLOAT * pfltOut)
{
    NOTIMP(VarR4FromBool);
}

static STDMETHODIMP VarR4FromI1(CHAR cIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromI1);
}

static STDMETHODIMP VarR4FromUI2(USHORT uiIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromUI2);
}

static STDMETHODIMP VarR4FromUI4(ULONG ulIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromUI4);
}

static STDMETHODIMP VarR4FromDec(DECIMAL *pdecIn, FLOAT *pfltOut)
{
    NOTIMP(VarR4FromDec);
}

static STDMETHODIMP VarR8FromUI1(BYTE bIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromUI1);
}

static STDMETHODIMP VarR8FromI2(SHORT sIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromI2);
}

static STDMETHODIMP VarR8FromI4(LONG lIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromI4);
}

static STDMETHODIMP VarR8FromR4(FLOAT fltIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromR4);
}

static STDMETHODIMP VarR8FromCy(CY cyIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromCy);
}

static STDMETHODIMP VarR8FromDate(DATE dateIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromDate);
}

static STDMETHODIMP VarR8FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromStr);
}

static STDMETHODIMP VarR8FromDisp(IDispatch * pdispIn, LCID lcid, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromDisp);
}

static STDMETHODIMP VarR8FromBool(VARIANT_BOOL boolIn, DOUBLE * pdblOut)
{
    NOTIMP(VarR8FromBool);
}

static STDMETHODIMP VarR8FromI1(CHAR cIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromI1);
}

static STDMETHODIMP VarR8FromUI2(USHORT uiIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromUI2);
}

static STDMETHODIMP VarR8FromUI4(ULONG ulIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromUI4);
}

static STDMETHODIMP VarR8FromDec(DECIMAL *pdecIn, DOUBLE *pdblOut)
{
    NOTIMP(VarR8FromDec);
}

static STDMETHODIMP VarDateFromUI1(BYTE bIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromUI1);
}

static STDMETHODIMP VarDateFromI2(SHORT sIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromI2);
}

static STDMETHODIMP VarDateFromI4(LONG lIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromI4);
}

static STDMETHODIMP VarDateFromR4(FLOAT fltIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromR4);
}

static STDMETHODIMP VarDateFromR8(DOUBLE dblIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromR8);
}

static STDMETHODIMP VarDateFromCy(CY cyIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromCy);
}

static STDMETHODIMP VarDateFromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromStr);
}

static STDMETHODIMP VarDateFromDisp(IDispatch * pdispIn, LCID lcid, DATE * pdateOut)
{
    NOTIMP(VarDateFromDisp);
}

static STDMETHODIMP VarDateFromBool(VARIANT_BOOL boolIn, DATE * pdateOut)
{
    NOTIMP(VarDateFromBool);
}

static STDMETHODIMP VarDateFromI1(CHAR cIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromI1);
}

static STDMETHODIMP VarDateFromUI2(USHORT uiIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromUI2);
}

static STDMETHODIMP VarDateFromUI4(ULONG ulIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromUI4);
}

static STDMETHODIMP VarDateFromDec(DECIMAL *pdecIn, DATE *pdateOut)
{
    NOTIMP(VarDateFromDec);
}

static STDMETHODIMP VarCyFromUI1(BYTE bIn, CY * pcyOut)
{
    NOTIMP(VarCyFromUI1);
}

static STDMETHODIMP VarCyFromI2(SHORT sIn, CY * pcyOut)
{
    NOTIMP(VarCyFromI2);
}

static STDMETHODIMP VarCyFromI4(LONG lIn, CY * pcyOut)
{
    NOTIMP(VarCyFromI4);
}

static STDMETHODIMP VarCyFromR4(FLOAT fltIn, CY * pcyOut)
{
    NOTIMP(VarCyFromR4);
}

static STDMETHODIMP VarCyFromR8(DOUBLE dblIn, CY * pcyOut)
{
    NOTIMP(VarCyFromR8);
}

static STDMETHODIMP VarCyFromDate(DATE dateIn, CY * pcyOut)
{
    NOTIMP(VarCyFromDate);
}

static STDMETHODIMP VarCyFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, CY * pcyOut)
{
    NOTIMP(VarCyFromStr);
}

static STDMETHODIMP VarCyFromDisp(IDispatch * pdispIn, LCID lcid, CY * pcyOut)
{
    NOTIMP(VarCyFromDisp);
}

static STDMETHODIMP VarCyFromBool(VARIANT_BOOL boolIn, CY * pcyOut)
{
    NOTIMP(VarCyFromBool);
}

static STDMETHODIMP VarCyFromI1(CHAR cIn, CY *pcyOut)
{
    NOTIMP(VarCyFromI1);
}

static STDMETHODIMP VarCyFromUI2(USHORT uiIn, CY *pcyOut)
{
    NOTIMP(VarCyFromUI2);
}

static STDMETHODIMP VarCyFromUI4(ULONG ulIn, CY *pcyOut)
{
    NOTIMP(VarCyFromUI4);
}

static STDMETHODIMP VarCyFromDec(DECIMAL *pdecIn, CY *pcyOut)
{
    NOTIMP(VarCyFromDec);
}

static STDMETHODIMP VarBstrFromUI1(BYTE bVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromUI1);
}

static STDMETHODIMP VarBstrFromI2(SHORT iVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromI2);
}

static STDMETHODIMP VarBstrFromI4(LONG lIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromI4);
}

static STDMETHODIMP VarBstrFromR4(FLOAT fltIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromR4);
}

static STDMETHODIMP VarBstrFromR8(DOUBLE dblIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromR8);
}

static STDMETHODIMP VarBstrFromCy(CY cyIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromCy);
}

static STDMETHODIMP VarBstrFromDate(DATE dateIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromDate);
}

static STDMETHODIMP VarBstrFromDisp(IDispatch * pdispIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromDisp);
}

static STDMETHODIMP VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut)
{
    NOTIMP(VarBstrFromBool);
}

static STDMETHODIMP VarBstrFromI1(CHAR cIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromI1);
}

static STDMETHODIMP VarBstrFromUI2(USHORT uiIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromUI2);
}

static STDMETHODIMP VarBstrFromUI4(ULONG ulIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromUI4);
}

static STDMETHODIMP VarBstrFromDec(DECIMAL *pdecIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarBstrFromDec);
}

static STDMETHODIMP VarBoolFromUI1(BYTE bIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromUI1);
}

static STDMETHODIMP VarBoolFromI2(SHORT sIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromI2);
}

static STDMETHODIMP VarBoolFromI4(LONG lIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromI4);
}

static STDMETHODIMP VarBoolFromR4(FLOAT fltIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromR4);
}

static STDMETHODIMP VarBoolFromR8(DOUBLE dblIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromR8);
}

static STDMETHODIMP VarBoolFromDate(DATE dateIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromDate);
}

static STDMETHODIMP VarBoolFromCy(CY cyIn, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromCy);
}

static STDMETHODIMP VarBoolFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromStr);
}

static STDMETHODIMP VarBoolFromDisp(IDispatch * pdispIn, LCID lcid, VARIANT_BOOL * pboolOut)
{
    NOTIMP(VarBoolFromDisp);
}

static STDMETHODIMP VarBoolFromI1(CHAR cIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromI1);
}

static STDMETHODIMP VarBoolFromUI2(USHORT uiIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromUI2);
}

static STDMETHODIMP VarBoolFromUI4(ULONG ulIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromUI4);
}

static STDMETHODIMP VarBoolFromDec(DECIMAL *pdecIn, VARIANT_BOOL *pboolOut)
{
    NOTIMP(VarBoolFromDec);
}

static STDMETHODIMP VarI1FromUI1(BYTE bIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI1);
}

static STDMETHODIMP VarI1FromI2(SHORT uiIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromI2);
}

static STDMETHODIMP VarI1FromI4(LONG lIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromI4);
}

static STDMETHODIMP VarI1FromR4(FLOAT fltIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromR4);
}

static STDMETHODIMP VarI1FromR8(DOUBLE dblIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromR8);
}

static STDMETHODIMP VarI1FromDate(DATE dateIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromDate);
}

static STDMETHODIMP VarI1FromCy(CY cyIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromCy);
}

static STDMETHODIMP VarI1FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, CHAR *pcOut)
{
    NOTIMP(VarI1FromStr);
}

static STDMETHODIMP VarI1FromDisp(IDispatch *pdispIn, LCID lcid, CHAR *pcOut)
{
    NOTIMP(VarI1FromDisp);
}

static STDMETHODIMP VarI1FromBool(VARIANT_BOOL boolIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromBool);
}

static STDMETHODIMP VarI1FromUI2(USHORT uiIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI2);
}

static STDMETHODIMP VarI1FromUI4(ULONG ulIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromUI4);
}

static STDMETHODIMP VarI1FromDec(DECIMAL *pdecIn, CHAR *pcOut)
{
    NOTIMP(VarI1FromDec);
}

static STDMETHODIMP VarUI2FromUI1(BYTE bIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromUI1);
}

static STDMETHODIMP VarUI2FromI2(SHORT uiIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI2);
}

static STDMETHODIMP VarUI2FromI4(LONG lIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI4);
}

static STDMETHODIMP VarUI2FromR4(FLOAT fltIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromR4);
}

static STDMETHODIMP VarUI2FromR8(DOUBLE dblIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromR8);
}

static STDMETHODIMP VarUI2FromDate(DATE dateIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDate);
}

static STDMETHODIMP VarUI2FromCy(CY cyIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromCy);
}

static STDMETHODIMP VarUI2FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, USHORT *puiOut)
{
    NOTIMP(VarUI2FromStr);
}

static STDMETHODIMP VarUI2FromDisp(IDispatch *pdispIn, LCID lcid, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDisp);
}

static STDMETHODIMP VarUI2FromBool(VARIANT_BOOL boolIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromBool);
}

static STDMETHODIMP VarUI2FromI1(CHAR cIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromI1);
}

static STDMETHODIMP VarUI2FromUI4(ULONG ulIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromUI4);
}

static STDMETHODIMP VarUI2FromDec(DECIMAL *pdecIn, USHORT *puiOut)
{
    NOTIMP(VarUI2FromDec);
}

static STDMETHODIMP VarUI4FromUI1(BYTE bIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromUI1);
}

static STDMETHODIMP VarUI4FromI2(SHORT uiIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI2);
}

static STDMETHODIMP VarUI4FromI4(LONG lIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI4);
}

static STDMETHODIMP VarUI4FromR4(FLOAT fltIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromR4);
}

static STDMETHODIMP VarUI4FromR8(DOUBLE dblIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromR8);
}

static STDMETHODIMP VarUI4FromDate(DATE dateIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDate);
}

static STDMETHODIMP VarUI4FromCy(CY cyIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromCy);
}

static STDMETHODIMP VarUI4FromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, ULONG *pulOut)
{
    NOTIMP(VarUI4FromStr);
}

static STDMETHODIMP VarUI4FromDisp(IDispatch *pdispIn, LCID lcid, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDisp);
}

static STDMETHODIMP VarUI4FromBool(VARIANT_BOOL boolIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromBool);
}

static STDMETHODIMP VarUI4FromI1(CHAR cIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromI1);
}

static STDMETHODIMP VarUI4FromUI2(USHORT uiIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromUI2);
}

static STDMETHODIMP VarUI4FromDec(DECIMAL *pdecIn, ULONG *pulOut)
{
    NOTIMP(VarUI4FromDec);
}

static STDMETHODIMP VarDecFromUI1(BYTE bIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI1);
}

static STDMETHODIMP VarDecFromI2(SHORT uiIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI2);
}

static STDMETHODIMP VarDecFromI4(LONG lIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI4);
}

static STDMETHODIMP VarDecFromR4(FLOAT fltIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromR4);
}

static STDMETHODIMP VarDecFromR8(DOUBLE dblIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromR8);
}

static STDMETHODIMP VarDecFromDate(DATE dateIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromDate);
}

static STDMETHODIMP VarDecFromCy(CY cyIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromCy);
}

static STDMETHODIMP VarDecFromStr(OLECHAR *strIn, LCID lcid, ULONG dwFlags, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromStr);
}

static STDMETHODIMP VarDecFromDisp(IDispatch *pdispIn, LCID lcid, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromDisp);
}

static STDMETHODIMP VarDecFromBool(VARIANT_BOOL boolIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromBool);
}

static STDMETHODIMP VarDecFromI1(CHAR cIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromI1);
}

static STDMETHODIMP VarDecFromUI2(USHORT uiIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI2);
}

static STDMETHODIMP VarDecFromUI4(ULONG ulIn, DECIMAL *pdecOut)
{
    NOTIMP(VarDecFromUI4);
}

static STDMETHODIMP VarParseNumFromStr(OLECHAR * strIn, LCID lcid, ULONG dwFlags, NUMPARSE * pnumprs, BYTE * rgbDig)
{
    NOTIMP(VarParseNumFromStr);
}

static STDMETHODIMP VarNumFromParseNum(NUMPARSE * pnumprs, BYTE * rgbDig, ULONG dwVtBits, VARIANT * pvar)
{
    NOTIMP(VarNumFromParseNum);
}

static STDMETHODIMP VarDateFromUdate(UDATE *pudateIn, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromUdate);
}

static STDMETHODIMP VarDateFromUdateEx(UDATE *pudateIn, LCID lcid, ULONG dwFlags, DATE *pdateOut)
{
    NOTIMP(VarDateFromUdateEx);
}

static STDMETHODIMP VarUdateFromDate(DATE dateIn, ULONG dwFlags, UDATE *pudateOut)
{
    NOTIMP(VarUdateFromDate);
}

static STDMETHODIMP GetAltMonthNames(LCID lcid, LPOLESTR * * prgp)
{
    NOTIMP(GetAltMonthNames);
}

static STDMETHODIMP VarFormat(LPVARIANT pvarIn, LPOLESTR pstrFormat, int iFirstDay, int iFirstWeek, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormat);
}

static STDMETHODIMP VarFormatDateTime(LPVARIANT pvarIn, int iNamedFormat, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatDateTime);
}

static STDMETHODIMP VarFormatNumber(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatNumber);
}

static STDMETHODIMP VarFormatPercent(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatPercent);
}

static STDMETHODIMP VarFormatCurrency(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarFormatCurrency);
}

static STDMETHODIMP VarWeekdayName(int iWeekday, int fAbbrev, int iFirstDay, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarWeekdayName);
}

static STDMETHODIMP VarMonthName(int iMonth, int fAbbrev, ULONG dwFlags, BSTR *pbstrOut)
{
    NOTIMP(VarMonthName);
}

static STDMETHODIMP VarFormatFromTokens(LPVARIANT pvarIn, LPOLESTR pstrFormat, LPBYTE pbTokCur, ULONG dwFlags, BSTR *pbstrOut, LCID lcid)
{
    NOTIMP(VarFormatFromTokens);
}

static STDMETHODIMP VarTokenizeFormatString(LPOLESTR pstrFormat, LPBYTE rgbTok, int cbTok, int iFirstDay, int iFirstWeek, LCID lcid, int *pcbActual)
{
    NOTIMP(VarTokenizeFormatString);
}

static STDMETHODIMP_(ULONG) LHashValOfNameSysA(SYSKIND syskind, LCID lcid, LPCSTR szName)
{
    NOTIMP_(0, LHashValOfNameSysA);
}

static STDMETHODIMP_(ULONG) LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR * szName)
{
    NOTIMP_(0, LHashValOfNameSys);
}

static STDMETHODIMP LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib)
{
    NOTIMP(LoadTypeLib);
}

static STDMETHODIMP LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib)
{
    NOTIMP(LoadTypeLibEx);
}

static STDMETHODIMP LoadRegTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib ** pptlib)
{
    NOTIMP(LoadRegTypeLib);
}

static STDMETHODIMP QueryPathOfRegTypeLib(REFGUID guid, USHORT wMaj, USHORT wMin, LCID lcid, LPBSTR lpbstrPathName)
{
    NOTIMP(QueryPathOfRegTypeLib);
}

static STDMETHODIMP RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir)
{
    NOTIMP(RegisterTypeLib);
}

static STDMETHODIMP UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind)
{
    NOTIMP(UnRegisterTypeLib);
}

static STDMETHODIMP CreateTypeLib(SYSKIND syskind, const OLECHAR  *szFile, ICreateTypeLib ** ppctlib)
{
    NOTIMP(CreateTypeLib);
}

static STDMETHODIMP CreateTypeLib2(SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib2 **ppctlib)
{
    NOTIMP(CreateTypeLib2);
}

static STDMETHODIMP DispGetParam(DISPPARAMS * pdispparams, UINT position, VARTYPE vtTarg, VARIANT * pvarResult, UINT * puArgErr)
{
    NOTIMP(DispGetParam);
}

static STDMETHODIMP DispGetIDsOfNames(ITypeInfo * ptinfo, OLECHAR ** rgszNames, UINT cNames, DISPID * rgdispid)
{
    NOTIMP(DispGetIDsOfNames);
}

static STDMETHODIMP DispInvoke(void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags,
                        DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    NOTIMP(DispInvoke);
}

static STDMETHODIMP CreateDispTypeInfo(INTERFACEDATA * pidata, LCID lcid, ITypeInfo ** pptinfo)
{
    NOTIMP(CreateDispTypeInfo);
}

static STDMETHODIMP CreateStdDispatch(IUnknown * punkOuter, void * pvThis, ITypeInfo * ptinfo, IUnknown ** ppunkStdDisp)
{
    NOTIMP(CreateStdDispatch);
}

static STDMETHODIMP DispCallFunc(void * pvInstance, ULONG oVft, CALLCONV cc, VARTYPE vtReturn, UINT  cActuals,
                          VARTYPE * prgvt, VARIANTARG ** prgpvarg, VARIANT * pvargResult)
{
    NOTIMP(DispCallFunc);
}

static STDMETHODIMP RegisterActiveObject(IUnknown * punk, REFCLSID rclsid, DWORD dwFlags, DWORD * pdwRegister)
{
    NOTIMP(RegisterActiveObject);
}

static STDMETHODIMP RevokeActiveObject(DWORD dwRegister, void * pvReserved)
{
    NOTIMP(RevokeActiveObject);
}

static STDMETHODIMP GetActiveObject(REFCLSID rclsid, void * pvReserved, IUnknown ** ppunk)
{
    NOTIMP(GetActiveObject);
}

static STDMETHODIMP SetErrorInfo(ULONG dwReserved, IErrorInfo * perrinfo)
{
    NOTIMP(SetErrorInfo);
}

static STDMETHODIMP GetErrorInfo(ULONG dwReserved, IErrorInfo ** pperrinfo)
{
    NOTIMP(GetErrorInfo);
}

static STDMETHODIMP CreateErrorInfo(ICreateErrorInfo ** pperrinfo)
{
    NOTIMP(CreateErrorInfo);
}

static STDMETHODIMP GetRecordInfoFromTypeInfo(ITypeInfo * pTypeInfo, IRecordInfo ** ppRecInfo)
{
    NOTIMP(GetRecordInfoFromTypeInfo);
}

static STDMETHODIMP GetRecordInfoFromGuids(REFGUID rGuidTypeLib, ULONG uVerMajor, ULONG uVerMinor, LCID lcid,
                                    REFGUID rGuidTypeInfo, IRecordInfo ** ppRecInfo)
{
    NOTIMP(GetRecordInfoFromGuids);
}

static STDMETHODIMP_(ULONG) OaBuildVersion(void)
{
    NOTIMP_(0, OaBuildVersion);
}

static STDMETHODIMP_(void) ClearCustData(LPCUSTDATA pCustData)
{
    NOTIMPV(ClearCustData);
}

unsigned long __stdcall BSTR_UserSize(unsigned long  *a, unsigned long b, BSTR  *c )
{
    NOTIMP_(0, BSTR_UserSize);
}

unsigned char * __stdcall BSTR_UserMarshal(unsigned long *a, unsigned char *b, BSTR *c )
{
    NOTIMP_(NULL, BSTR_UserMarshal);
}

unsigned char * __stdcall BSTR_UserUnmarshal(unsigned long *a, unsigned char *b, BSTR *c )
{
    NOTIMP_(NULL, BSTR_UserUnmarshal);
}

void __stdcall BSTR_UserFree(unsigned long *a, BSTR *b )
{
    NOTIMPV(BSTR_UserFree);
}

unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long *a, unsigned long b, LPSAFEARRAY *c)
{
    NOTIMP_(0, LPSAFEARRAY_UserSize);
}

unsigned long __stdcall LPSAFEARRAY_Size(unsigned long *a, unsigned long b, LPSAFEARRAY *c)
{
    NOTIMP_(0, LPSAFEARRAY_Size);
}

unsigned char * __stdcall LPSAFEARRAY_UserMarshal(unsigned long *a, unsigned char *b, LPSAFEARRAY *c)
{
    NOTIMP_(NULL, LPSAFEARRAY_UserMarshal);
}

unsigned char * __stdcall LPSAFEARRAY_Marshal(unsigned long *a, unsigned char *b, LPSAFEARRAY *c)
{
    NOTIMP_(NULL, LPSAFEARRAY_Marshal);
}

unsigned char * __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long *q, unsigned char *w, LPSAFEARRAY *e)
{
    NOTIMP_(NULL, LPSAFEARRAY_UserUnmarshal);
}

unsigned char * __stdcall LPSAFEARRAY_Unmarshal(unsigned long *a, unsigned char *s, LPSAFEARRAY *d)
{
    NOTIMP_(NULL, LPSAFEARRAY_Unmarshal);
}

void __stdcall LPSAFEARRAY_UserFree(unsigned long *a, LPSAFEARRAY *x)
{
    NOTIMPV(LPSAFEARRAY_UserFree);
}

unsigned long __stdcall VARIANT_UserSize(unsigned long *a, unsigned long b, VARIANT *x)
{
    NOTIMP_(0, VARIANT_UserSize);
}

unsigned char * __stdcall VARIANT_UserMarshal(unsigned long *a, unsigned char *b, VARIANT *x)
{
    NOTIMP_(NULL, VARIANT_UserMarshal);
}

unsigned char * __stdcall VARIANT_UserUnmarshal(unsigned long *a, unsigned char *b, VARIANT *x)
{
    NOTIMP_(NULL, VARIANT_UserUnmarshal);
}

void __stdcall VARIANT_UserFree(unsigned long *a, VARIANT *x)
{
    NOTIMPV(VARIANT_UserFree);
}

static STDMETHODIMP OleTranslateColor(OLE_COLOR clr, HPALETTE hpal, COLORREF* lpcolorref)
{
    NOTIMP(OleTranslateColor);
}


static STDMETHODIMP OleCreateFontIndirect(LPFONTDESC lpFontDesc, REFIID riid, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleCreateFontIndirect);
}

static STDMETHODIMP OleCreatePictureIndirect(LPPICTDESC lpPictDesc, REFIID riid, BOOL fOwn, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleCreatePictureIndirect);
}

static STDMETHODIMP OleLoadPicture(LPSTREAM lpstream, LONG lSize, BOOL fRunmode, REFIID riid, LPVOID FAR* lplpvObj)
{
    NOTIMP(OleLoadPicture);
}

static STDMETHODIMP_(HCURSOR) OleIconToCursor(HINSTANCE hinstExe, HICON hIcon)
{
    NOTIMP_(NULL, OleIconToCursor);
}

static STDMETHODIMP OleCreatePropertyFrame(HWND hwndOwner, UINT x, UINT y,
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages,
    LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved)
{
    NOTIMP(OleCreatePropertyFrame);
}

static STDMETHODIMP OleCreatePropertyFrameIndirect(LPOCPFIPARAMS lpParams)
{
    NOTIMP(OleCreatePropertyFrameIndirect);
}

DEFINE_ORDINAL_ENTRIES(oleaut32)
{
    DLOENTRY(  2	, SysAllocString)
    DLOENTRY(  3	, SysReAllocString)
    DLOENTRY(  4	, SysAllocStringLen)
    DLOENTRY(  5	, SysReAllocStringLen)
    DLOENTRY(  6	, SysFreeString)
    DLOENTRY(  7	, SysStringLen)
    DLOENTRY(  8	, VariantInit)
    DLOENTRY(  9	, VariantClear)
    DLOENTRY(  10	, VariantCopy)
    DLOENTRY(  11	, VariantCopyInd)
    DLOENTRY(  12	, VariantChangeType)
    DLOENTRY(  13	, VariantTimeToDosDateTime)
    DLOENTRY(  14	, DosDateTimeToVariantTime)
    DLOENTRY(  15	, SafeArrayCreate)
    DLOENTRY(  16	, SafeArrayDestroy)
    DLOENTRY(  17	, SafeArrayGetDim)
    DLOENTRY(  18	, SafeArrayGetElemsize)
    DLOENTRY(  19	, SafeArrayGetUBound)
    DLOENTRY(  20	, SafeArrayGetLBound)
    DLOENTRY(  21	, SafeArrayLock)
    DLOENTRY(  22	, SafeArrayUnlock)
    DLOENTRY(  23	, SafeArrayAccessData)
    DLOENTRY(  24	, SafeArrayUnaccessData)
    DLOENTRY(  25	, SafeArrayGetElement)
    DLOENTRY(  26	, SafeArrayPutElement)
    DLOENTRY(  27	, SafeArrayCopy)
    DLOENTRY(  28	, DispGetParam)
    DLOENTRY(  29	, DispGetIDsOfNames)
    DLOENTRY(  30	, DispInvoke)
    DLOENTRY(  31	, CreateDispTypeInfo)
    DLOENTRY(  32	, CreateStdDispatch)
    DLOENTRY(  33	, RegisterActiveObject)
    DLOENTRY(  34	, RevokeActiveObject)
    DLOENTRY(  35	, GetActiveObject)
    DLOENTRY(  36	, SafeArrayAllocDescriptor)
    DLOENTRY(  37	, SafeArrayAllocData)
    DLOENTRY(  38	, SafeArrayDestroyDescriptor)
    DLOENTRY(  39	, SafeArrayDestroyData)
    DLOENTRY(  40	, SafeArrayRedim)
    DLOENTRY(  41	, SafeArrayAllocDescriptorEx)
    DLOENTRY(  42	, SafeArrayCreateEx)
    DLOENTRY(  43	, SafeArrayCreateVectorEx)
    DLOENTRY(  44	, SafeArraySetRecordInfo)
    DLOENTRY(  45	, SafeArrayGetRecordInfo)
    DLOENTRY(  46	, VarParseNumFromStr)
    DLOENTRY(  47	, VarNumFromParseNum)
    DLOENTRY(  48	, VarI2FromUI1)
    DLOENTRY(  49	, VarI2FromI4)
    DLOENTRY(  50	, VarI2FromR4)
    DLOENTRY(  51	, VarI2FromR8)
    DLOENTRY(  52	, VarI2FromCy)
    DLOENTRY(  53	, VarI2FromDate)
    DLOENTRY(  54	, VarI2FromStr)
    DLOENTRY(  55	, VarI2FromDisp)
    DLOENTRY(  56	, VarI2FromBool)
    DLOENTRY(  57	, SafeArraySetIID)
    DLOENTRY(  58	, VarI4FromUI1)
    DLOENTRY(  59	, VarI4FromI2)
    DLOENTRY(  60	, VarI4FromR4)
    DLOENTRY(  61	, VarI4FromR8)
    DLOENTRY(  62	, VarI4FromCy)
    DLOENTRY(  63	, VarI4FromDate)
    DLOENTRY(  64	, VarI4FromStr)
    DLOENTRY(  65	, VarI4FromDisp)
    DLOENTRY(  66	, VarI4FromBool)
    DLOENTRY(  67	, SafeArrayGetIID)
    DLOENTRY(  68	, VarR4FromUI1)
    DLOENTRY(  69	, VarR4FromI2)
    DLOENTRY(  70	, VarR4FromI4)
    DLOENTRY(  71	, VarR4FromR8)
    DLOENTRY(  72	, VarR4FromCy)
    DLOENTRY(  73	, VarR4FromDate)
    DLOENTRY(  74	, VarR4FromStr)
    DLOENTRY(  75	, VarR4FromDisp)
    DLOENTRY(  76	, VarR4FromBool)
    DLOENTRY(  77	, SafeArrayGetVartype)
    DLOENTRY(  78	, VarR8FromUI1)
    DLOENTRY(  79	, VarR8FromI2)
    DLOENTRY(  80	, VarR8FromI4)
    DLOENTRY(  81	, VarR8FromR4)
    DLOENTRY(  82	, VarR8FromCy)
    DLOENTRY(  83	, VarR8FromDate)
    DLOENTRY(  84	, VarR8FromStr)
    DLOENTRY(  85	, VarR8FromDisp)
    DLOENTRY(  86	, VarR8FromBool)
    DLOENTRY(  87	, VarFormat)
    DLOENTRY(  88	, VarDateFromUI1)
    DLOENTRY(  89	, VarDateFromI2)
    DLOENTRY(  90	, VarDateFromI4)
    DLOENTRY(  91	, VarDateFromR4)
    DLOENTRY(  92	, VarDateFromR8)
    DLOENTRY(  93	, VarDateFromCy)
    DLOENTRY(  94	, VarDateFromStr)
    DLOENTRY(  95	, VarDateFromDisp)
    DLOENTRY(  96	, VarDateFromBool)
    DLOENTRY(  97	, VarFormatDateTime)
    DLOENTRY(  98	, VarCyFromUI1)
    DLOENTRY(  99	, VarCyFromI2)
    DLOENTRY(  100	, VarCyFromI4)
    DLOENTRY(  101	, VarCyFromR4)
    DLOENTRY(  102	, VarCyFromR8)
    DLOENTRY(  103	, VarCyFromDate)
    DLOENTRY(  104	, VarCyFromStr)
    DLOENTRY(  105	, VarCyFromDisp)
    DLOENTRY(  106	, VarCyFromBool)
    DLOENTRY(  107	, VarFormatNumber)
    DLOENTRY(  108	, VarBstrFromUI1)
    DLOENTRY(  109	, VarBstrFromI2)
    DLOENTRY(  110	, VarBstrFromI4)
    DLOENTRY(  111	, VarBstrFromR4)
    DLOENTRY(  112	, VarBstrFromR8)
    DLOENTRY(  113	, VarBstrFromCy)
    DLOENTRY(  114	, VarBstrFromDate)
    DLOENTRY(  115	, VarBstrFromDisp)
    DLOENTRY(  116	, VarBstrFromBool)
    DLOENTRY(  117	, VarFormatPercent)
    DLOENTRY(  118	, VarBoolFromUI1)
    DLOENTRY(  119	, VarBoolFromI2)
    DLOENTRY(  120	, VarBoolFromI4)
    DLOENTRY(  121	, VarBoolFromR4)
    DLOENTRY(  122	, VarBoolFromR8)
    DLOENTRY(  123	, VarBoolFromDate)
    DLOENTRY(  124	, VarBoolFromCy)
    DLOENTRY(  125	, VarBoolFromStr)
    DLOENTRY(  126	, VarBoolFromDisp)
    DLOENTRY(  127	, VarFormatCurrency)
    DLOENTRY(  128	, VarWeekdayName)
    DLOENTRY(  129	, VarMonthName)
    DLOENTRY(  130	, VarUI1FromI2)
    DLOENTRY(  131	, VarUI1FromI4)
    DLOENTRY(  132	, VarUI1FromR4)
    DLOENTRY(  133	, VarUI1FromR8)
    DLOENTRY(  134	, VarUI1FromCy)
    DLOENTRY(  135	, VarUI1FromDate)
    DLOENTRY(  136	, VarUI1FromStr)
    DLOENTRY(  137	, VarUI1FromDisp)
    DLOENTRY(  138	, VarUI1FromBool)
    DLOENTRY(  139	, VarFormatFromTokens)
    DLOENTRY(  140	, VarTokenizeFormatString)
    DLOENTRY(  141	, VarAdd)
    DLOENTRY(  142	, VarAnd)
    DLOENTRY(  143	, VarDiv)
    DLOENTRY(  146	, DispCallFunc)
    DLOENTRY(  147	, VariantChangeTypeEx)
    DLOENTRY(  148	, SafeArrayPtrOfIndex)
    DLOENTRY(  149	, SysStringByteLen)
    DLOENTRY(  150	, SysAllocStringByteLen)
    DLOENTRY(  152	, VarEqv)
    DLOENTRY(  153	, VarIdiv)
    DLOENTRY(  154	, VarImp)
    DLOENTRY(  155	, VarMod)
    DLOENTRY(  156	, VarMul)
    DLOENTRY(  157	, VarOr)
    DLOENTRY(  158	, VarPow)
    DLOENTRY(  159	, VarSub)
    DLOENTRY(  160	, CreateTypeLib)
    DLOENTRY(  161	, LoadTypeLib)
    DLOENTRY(  162	, LoadRegTypeLib)
    DLOENTRY(  163	, RegisterTypeLib)
    DLOENTRY(  164	, QueryPathOfRegTypeLib)
    DLOENTRY(  165	, LHashValOfNameSys)
    DLOENTRY(  166	, LHashValOfNameSysA)
    DLOENTRY(  167	, VarXor)
    DLOENTRY(  168	, VarAbs)
    DLOENTRY(  169	, VarFix)
    DLOENTRY(  170	, OaBuildVersion)
    DLOENTRY(  171	, ClearCustData)
    DLOENTRY(  172	, VarInt)
    DLOENTRY(  173	, VarNeg)
    DLOENTRY(  174	, VarNot)
    DLOENTRY(  175	, VarRound)
    DLOENTRY(  176	, VarCmp)
    DLOENTRY(  177	, VarDecAdd)
    DLOENTRY(  178	, VarDecDiv)
    DLOENTRY(  179	, VarDecMul)
    DLOENTRY(  180	, CreateTypeLib2)
    DLOENTRY(  181	, VarDecSub)
    DLOENTRY(  182	, VarDecAbs)
    DLOENTRY(  183	, LoadTypeLibEx)
    DLOENTRY(  184	, SystemTimeToVariantTime)
    DLOENTRY(  185	, VariantTimeToSystemTime)
    DLOENTRY(  186	, UnRegisterTypeLib)
    DLOENTRY(  187	, VarDecFix)
    DLOENTRY(  188	, VarDecInt)
    DLOENTRY(  189	, VarDecNeg)
    DLOENTRY(  190	, VarDecFromUI1)
    DLOENTRY(  191	, VarDecFromI2)
    DLOENTRY(  192	, VarDecFromI4)
    DLOENTRY(  193	, VarDecFromR4)
    DLOENTRY(  194	, VarDecFromR8)
    DLOENTRY(  195	, VarDecFromDate)
    DLOENTRY(  196	, VarDecFromCy)
    DLOENTRY(  197	, VarDecFromStr)
    DLOENTRY(  198	, VarDecFromDisp)
    DLOENTRY(  199	, VarDecFromBool)
    DLOENTRY(  200	, GetErrorInfo)
    DLOENTRY(  201	, SetErrorInfo)
    DLOENTRY(  202	, CreateErrorInfo)
    DLOENTRY(  203	, VarDecRound)
    DLOENTRY(  204	, VarDecCmp)
    DLOENTRY(  205	, VarI2FromI1)
    DLOENTRY(  206	, VarI2FromUI2)
    DLOENTRY(  207	, VarI2FromUI4)
    DLOENTRY(  208	, VarI2FromDec)
    DLOENTRY(  209	, VarI4FromI1)
    DLOENTRY(  210	, VarI4FromUI2)
    DLOENTRY(  211	, VarI4FromUI4)
    DLOENTRY(  212	, VarI4FromDec)
    DLOENTRY(  213	, VarR4FromI1)
    DLOENTRY(  214	, VarR4FromUI2)
    DLOENTRY(  215	, VarR4FromUI4)
    DLOENTRY(  216	, VarR4FromDec)
    DLOENTRY(  217	, VarR8FromI1)
    DLOENTRY(  218	, VarR8FromUI2)
    DLOENTRY(  219	, VarR8FromUI4)
    DLOENTRY(  220	, VarR8FromDec)
    DLOENTRY(  221	, VarDateFromI1)
    DLOENTRY(  222	, VarDateFromUI2)
    DLOENTRY(  223	, VarDateFromUI4)
    DLOENTRY(  224	, VarDateFromDec)
    DLOENTRY(  225	, VarCyFromI1)
    DLOENTRY(  226	, VarCyFromUI2)
    DLOENTRY(  227	, VarCyFromUI4)
    DLOENTRY(  228	, VarCyFromDec)
    DLOENTRY(  229	, VarBstrFromI1)
    DLOENTRY(  230	, VarBstrFromUI2)
    DLOENTRY(  231	, VarBstrFromUI4)
    DLOENTRY(  232	, VarBstrFromDec)
    DLOENTRY(  233	, VarBoolFromI1)
    DLOENTRY(  234	, VarBoolFromUI2)
    DLOENTRY(  235	, VarBoolFromUI4)
    DLOENTRY(  236	, VarBoolFromDec)
    DLOENTRY(  237	, VarUI1FromI1)
    DLOENTRY(  238	, VarUI1FromUI2)
    DLOENTRY(  239	, VarUI1FromUI4)
    DLOENTRY(  240	, VarUI1FromDec)
    DLOENTRY(  241	, VarDecFromI1)
    DLOENTRY(  242	, VarDecFromUI2)
    DLOENTRY(  243	, VarDecFromUI4)
    DLOENTRY(  244	, VarI1FromUI1)
    DLOENTRY(  245	, VarI1FromI2)
    DLOENTRY(  246	, VarI1FromI4)
    DLOENTRY(  247	, VarI1FromR4)
    DLOENTRY(  248	, VarI1FromR8)
    DLOENTRY(  249	, VarI1FromDate)
    DLOENTRY(  250	, VarI1FromCy)
    DLOENTRY(  251	, VarI1FromStr)
    DLOENTRY(  252	, VarI1FromDisp)
    DLOENTRY(  253	, VarI1FromBool)
    DLOENTRY(  254	, VarI1FromUI2)
    DLOENTRY(  255	, VarI1FromUI4)
    DLOENTRY(  256	, VarI1FromDec)
    DLOENTRY(  257	, VarUI2FromUI1)
    DLOENTRY(  258	, VarUI2FromI2)
    DLOENTRY(  259	, VarUI2FromI4)
    DLOENTRY(  260	, VarUI2FromR4)
    DLOENTRY(  261	, VarUI2FromR8)
    DLOENTRY(  262	, VarUI2FromDate)
    DLOENTRY(  263	, VarUI2FromCy)
    DLOENTRY(  264	, VarUI2FromStr)
    DLOENTRY(  265	, VarUI2FromDisp)
    DLOENTRY(  266	, VarUI2FromBool)
    DLOENTRY(  267	, VarUI2FromI1)
    DLOENTRY(  268	, VarUI2FromUI4)
    DLOENTRY(  269	, VarUI2FromDec)
    DLOENTRY(  270	, VarUI4FromUI1)
    DLOENTRY(  271	, VarUI4FromI2)
    DLOENTRY(  272	, VarUI4FromI4)
    DLOENTRY(  273	, VarUI4FromR4)
    DLOENTRY(  274	, VarUI4FromR8)
    DLOENTRY(  275	, VarUI4FromDate)
    DLOENTRY(  276	, VarUI4FromCy)
    DLOENTRY(  277	, VarUI4FromStr)
    DLOENTRY(  278	, VarUI4FromDisp)
    DLOENTRY(  279	, VarUI4FromBool)
    DLOENTRY(  280	, VarUI4FromI1)
    DLOENTRY(  281	, VarUI4FromUI2)
    DLOENTRY(  282	, VarUI4FromDec)
    DLOENTRY(  298	, VarDecCmpR8)
    DLOENTRY(  299	, VarCyAdd)
    DLOENTRY(  303	, VarCyMul)
    DLOENTRY(  304	, VarCyMulI4)
    DLOENTRY(  305	, VarCySub)
    DLOENTRY(  306	, VarCyAbs)
    DLOENTRY(  307	, VarCyFix)
    DLOENTRY(  308	, VarCyInt)
    DLOENTRY(  309	, VarCyNeg)
    DLOENTRY(  310	, VarCyRound)
    DLOENTRY(  311	, VarCyCmp)
    DLOENTRY(  312	, VarCyCmpR8)
    DLOENTRY(  313	, VarBstrCat)
    DLOENTRY(  314	, VarBstrCmp)
    DLOENTRY(  315	, VarR8Pow)
    DLOENTRY(  316	, VarR4CmpR8)
    DLOENTRY(  317	, VarR8Round)
    DLOENTRY(  318	, VarCat)
    DLOENTRY(  319	, VarDateFromUdateEx)
    DLOENTRY(  322	, GetRecordInfoFromGuids)
    DLOENTRY(  323	, GetRecordInfoFromTypeInfo)
    DLOENTRY(  329	, VarCyMulI8)
    DLOENTRY(  330	, VarDateFromUdate)
    DLOENTRY(  331	, VarUdateFromDate)
    DLOENTRY(  332	, GetAltMonthNames)
    DLOENTRY(  333	, VarI8FromUI1)
    DLOENTRY(  334	, VarI8FromI2)
    DLOENTRY(  335	, VarI8FromR4)
    DLOENTRY(  336	, VarI8FromR8)
    DLOENTRY(  337	, VarI8FromCy)
    DLOENTRY(  338	, VarI8FromDate)
    DLOENTRY(  339	, VarI8FromStr)
    DLOENTRY(  340	, VarI8FromDisp)
    DLOENTRY(  341	, VarI8FromBool)
    DLOENTRY(  342	, VarI8FromI1)
    DLOENTRY(  343	, VarI8FromUI2)
    DLOENTRY(  344	, VarI8FromUI4)
    DLOENTRY(  345	, VarI8FromDec)
    DLOENTRY(  346	, VarI2FromI8)
    DLOENTRY(  347	, VarI2FromUI8)
    DLOENTRY(  348	, VarI4FromI8)
    DLOENTRY(  349	, VarI4FromUI8)
    DLOENTRY(  360	, VarR4FromI8)
    DLOENTRY(  361	, VarR4FromUI8)
    DLOENTRY(  362	, VarR8FromI8)
    DLOENTRY(  363	, VarR8FromUI8)
    DLOENTRY(  364	, VarDateFromI8)
    DLOENTRY(  365	, VarDateFromUI8)
    DLOENTRY(  366	, VarCyFromI8)
    DLOENTRY(  367	, VarCyFromUI8)
    DLOENTRY(  368	, VarBstrFromI8)
    DLOENTRY(  369	, VarBstrFromUI8)
    DLOENTRY(  370	, VarBoolFromI8)
    DLOENTRY(  371	, VarBoolFromUI8)
    DLOENTRY(  372	, VarUI1FromI8)
    DLOENTRY(  373	, VarUI1FromUI8)
    DLOENTRY(  374	, VarDecFromI8)
    DLOENTRY(  375	, VarDecFromUI8)
    DLOENTRY(  376	, VarI1FromI8)
    DLOENTRY(  377	, VarI1FromUI8)
    DLOENTRY(  378	, VarUI2FromI8)
    DLOENTRY(  379	, VarUI2FromUI8)
    DLOENTRY(  401	, OleLoadPictureEx)
    DLOENTRY(  402	, OleLoadPictureFileEx)
    DLOENTRY(  411	, SafeArrayCreateVector)
    DLOENTRY(  412	, SafeArrayCopyData)
    DLOENTRY(  413	, VectorFromBstr)
    DLOENTRY(  414	, BstrFromVector)
    DLOENTRY(  415	, OleIconToCursor)
    DLOENTRY(  416	, OleCreatePropertyFrameIndirect)
    DLOENTRY(  417	, OleCreatePropertyFrame)
    DLOENTRY(  418	, OleLoadPicture)
    DLOENTRY(  419	, OleCreatePictureIndirect)
    DLOENTRY(  420	, OleCreateFontIndirect)
    DLOENTRY(  421	, OleTranslateColor)
    DLOENTRY(  422	, OleLoadPictureFile)
    DLOENTRY(  423	, OleSavePictureFile)
    DLOENTRY(  424	, OleLoadPicturePath)
    DLOENTRY(  425	, VarUI4FromI8)
    DLOENTRY(  426	, VarUI4FromUI8)
    DLOENTRY(  427	, VarI8FromUI8)
    DLOENTRY(  428	, VarUI8FromI8)
    DLOENTRY(  429	, VarUI8FromUI1)
    DLOENTRY(  430	, VarUI8FromI2)
    DLOENTRY(  431	, VarUI8FromR4)
    DLOENTRY(  432	, VarUI8FromR8)
    DLOENTRY(  433	, VarUI8FromCy)
    DLOENTRY(  434	, VarUI8FromDate)
    DLOENTRY(  435	, VarUI8FromStr)
    DLOENTRY(  436	, VarUI8FromDisp)
    DLOENTRY(  437	, VarUI8FromBool)
    DLOENTRY(  438	, VarUI8FromI1)
    DLOENTRY(  439	, VarUI8FromUI2)
    DLOENTRY(  441	, VarUI8FromDec)

};

DEFINE_ORDINAL_MAP(oleaut32);

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\pch.h ===
#pragma once

#ifdef DLOAD1

// to avoid import declarations
#define _COMCTL32_ 
#define _SHELL32_
#define _OLEAUT32_

#include <dloadexcept.h>
#include "dload.h"

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\shell32.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _SHELL32_
#include <shellapi.h>
#include <shlobj.h>

static
WINSHELLAPI
HICON
WINAPI
ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	return 0;
}

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExW (
    LPCWSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
int
WINAPI
RestartDialog (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn
    )
{
    return IDNO;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderW (
    LPBROWSEINFOW lpbi
    )
{
    return NULL;
}

static
void
STDAPICALLTYPE
SHChangeNotify(
    LONG wEventId,
    UINT uFlags,
    LPCVOID dwItem1,
    LPCVOID dwItem2)
{
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathA (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathW (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetMalloc (
    LPMALLOC * ppMalloc
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListW (
    LPCITEMIDLIST   pidl,
    LPWSTR          pszPath
    )
{
    return FALSE;
}

static
HRESULT
STDAPICALLTYPE
SHGetSpecialFolderLocation (
    HWND hwnd,
    int csidl,
    LPITEMIDLIST *ppidl
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetSpecialFolderPathW(
    HWND hwnd,
    LPWSTR pszPath,
    int csidl,
    BOOL fCreate)
{
    return FALSE;
}

static
LPITEMIDLIST 
SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    return NULL;
}

static
WINSHELLAPI
INT
WINAPI
ShellAboutW(
    HWND hwnd,
    LPCWSTR szApp,
    LPCWSTR szOtherStuff,
    HICON hIcon
    )
{
    return FALSE;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteA (
    HWND hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteW (
    HWND hwnd,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shell32)
{
//     DLOENTRY(59, RestartDialog)
    DLOENTRY(162, SHSimpleIDListFromPath)
};

DEFINE_ORDINAL_MAP(shell32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shell32)
{
    DLPENTRY(ExtractAssociatedIconW)
//     DLPENTRY(ExtractIconExW)
//     DLPENTRY(SHBrowseForFolderW)
//     DLPENTRY(SHChangeNotify)
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
//     DLPENTRY(SHGetMalloc)
//     DLPENTRY(SHGetPathFromIDListW)
//     DLPENTRY(SHGetSpecialFolderLocation)
//     DLPENTRY(SHGetSpecialFolderPathW)
//     DLPENTRY(ShellAboutW)
//     DLPENTRY(ShellExecuteExW)
    DLPENTRY(ShellExecuteA)
    DLPENTRY(ShellExecuteW)
};

DEFINE_PROCNAME_MAP(shell32)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\urlmon.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <urlmon.h>

static
HRESULT WINAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv)
{
    return E_FAIL;
}
            
static 
HRESULT WINAPI CoInternetCombineUrl(             
    LPCWSTR     pwzBaseUrl,              
    LPCWSTR     pwzRelativeUrl,          
    DWORD       dwCombineFlags,          
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    )
{
    return E_FAIL;
}
    
static 
HRESULT WINAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved)
{
    return E_FAIL;
}

static 
HRESULT WINAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI CoInternetGetSession(DWORD dwSessionMode,
                                    IInternetSession **ppIInternetSession,
                                    DWORD dwReserved)
{
    *ppIInternetSession = NULL;
    return E_OUTOFMEMORY;
}

static HRESULT WINAPI CoInternetParseUrl(               
    LPCWSTR     pwzUrl,                  
    PARSEACTION ParseAction,             
    DWORD       dwFlags,                 
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    )
{
    return E_FAIL;
}
    
static HRESULT WINAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    LPVOID      pvBuffer,                
    DWORD       cbBuffer,                
    DWORD      *pcbBuffer,               
    DWORD       dwReserved               
    )                                  
{
    return E_FAIL;
}

static HRESULT WINAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC)
{
    return E_FAIL;
}

static HRESULT WINAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI CreateURLMoniker(LPMONIKER pMkCtx,
                                LPCWSTR szURL,
                                LPMONIKER FAR * ppmk)
{
    *ppmk = NULL;
    return E_OUTOFMEMORY;
}

static 
HRESULT WINAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags)
{
    return E_FAIL;
}

static HRESULT WINAPI FaultInIEFeature( HWND hWnd,
            uCLSSPEC *pClassSpec,
            QUERYCONTEXT *pQuery, DWORD dwFlags)
{
    return E_FAIL;
}

static HRESULT WINAPI FindMimeFromData(                                       
                        LPBC pBC,                              
                        LPCWSTR pwzUrl,                        
                        LPVOID pBuffer,                       
                        DWORD cbSize,                          
                        LPCWSTR pwzMimeProposed,               
                        DWORD dwMimeFlags,                     
                        LPWSTR *ppwzMimeOut,                   
                        DWORD dwReserved)                      
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid)
{
    return E_FAIL;
}


static
HRESULT WINAPI HlinkNavigateString(IUnknown *pUnk,
                                   LPCWSTR szTarget)
{
    return E_FAIL;
}

static 
HRESULT WINAPI IsAsyncMoniker(IMoniker* pmk)
{
    return E_FAIL;
}

static 
HRESULT WINAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk)
{
    return E_FAIL;
}

static 
HRESULT WINAPI ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize)
{
    return E_FAIL;
}


static
HRESULT WINAPI RegisterBindStatusCallback(LPBC pBC,
                                          IBindStatusCallback *pBSCb,
                                          IBindStatusCallback** ppBSCBPrev,
                                          DWORD dwReserved)
{
    return E_OUTOFMEMORY;
}

static 
void WINAPI ReleaseBindInfo( BINDINFO * pbindinfo )
{
}


static
HRESULT WINAPI RevokeBindStatusCallback(LPBC pBC,
                                        IBindStatusCallback *pBSCb)
{
    return E_FAIL;
}

static 
HRESULT WINAPI URLOpenBlockingStreamW(LPUNKNOWN a,LPCWSTR b,LPSTREAM* c,DWORD d,LPBINDSTATUSCALLBACK e)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(urlmon)
{
    DLPENTRY(CoGetClassObjectFromURL)
    DLPENTRY(CoInternetCombineUrl)
    DLPENTRY(CoInternetCreateSecurityManager)
    DLPENTRY(CoInternetCreateZoneManager)
    DLPENTRY(CoInternetGetSession)
    DLPENTRY(CoInternetParseUrl)
    DLPENTRY(CoInternetQueryInfo)
    DLPENTRY(CreateAsyncBindCtx)
    DLPENTRY(CreateAsyncBindCtxEx)
    DLPENTRY(CreateURLMoniker)
    DLPENTRY(CreateURLMonikerEx)
    DLPENTRY(FaultInIEFeature)
    DLPENTRY(FindMimeFromData)
    DLPENTRY(GetClassFileOrMime)
    DLPENTRY(HlinkNavigateString)
    DLPENTRY(IsAsyncMoniker)
    DLPENTRY(MkParseDisplayNameEx)
    DLPENTRY(ObtainUserAgentString)
    DLPENTRY(RegisterBindStatusCallback)
    DLPENTRY(ReleaseBindInfo)
    DLPENTRY(RevokeBindStatusCallback)
    DLPENTRY(URLOpenBlockingStreamW)
};

DEFINE_PROCNAME_MAP(urlmon)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\wininet.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _WINX32_
#include <wininet.h>

static
BOOLAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )
{
    return FALSE;
}


static
BOOLAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    return FALSE;
}


static
BOOLAPI
CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    return FALSE;
}

static
BOOLAPI
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetAlgIdToStringW(
    IN ALG_ID                         ai,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    return FALSE;
}


static
BOOLAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    return FALSE;
}

static
INTERNETAPI
DWORD
WINAPI
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    return E_FAIL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetCrackUrlW(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )
{
    return FALSE;
}

static
INTERNETAPI
DWORD
WINAPI
InternetErrorDlg(IN HWND hWnd,
                 IN OUT HINTERNET hRequest,
                 IN DWORD dwError,
                 IN DWORD dwFlags,
                 IN OUT LPVOID *lppvData
                 )
{
    return E_FAIL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetGetCertByURL(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved)
{
    return FALSE;
}

static
INTERNETAPI 
BOOL 
WINAPI
InternetGetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPWSTR   lpszCookieData,
    LPDWORD lpdwSize
    )
{
    return FALSE;
}

static
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    return FALSE;
}

static
BOOLAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    *lpdwNumberOfBytesRead = 0;
    return FALSE;
}

static
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}


static
INTERNETAPI
BOOL
WINAPI
InternetSecurityProtocolToStringW(
    IN DWORD                          dwProtocol,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetShowSecurityInfoByURLW(
    IN       LPWSTR    lpszURL,
    IN       HWND     hwndParent
    )
{
    return FALSE;
}

static
INTERNETAPI
BOOL
WINAPI
InternetUnlockRequestFile(
    IN HANDLE hLockHandle
    )
{
    return FALSE;
}

static
BOOLAPI
IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    return FALSE;
}

static
BOOLAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
BOOLAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    return FALSE;
}

static
BOOLAPI
UnlockUrlCacheEntryFileA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wininet)
{
    DLPENTRY(CommitUrlCacheEntryA)
    DLPENTRY(CommitUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheEntryA)
    DLPENTRY(CreateUrlCacheEntryW)
    DLPENTRY(DeleteUrlCacheEntryA)
    DLPENTRY(HttpQueryInfoW)
    DLPENTRY(InternetAlgIdToStringW)
    DLPENTRY(InternetCanonicalizeUrlW)
    DLPENTRY(InternetCloseHandle)
    DLPENTRY(InternetConfirmZoneCrossingW)
    DLPENTRY(InternetCrackUrlW)
    DLPENTRY(InternetErrorDlg)
    DLPENTRY(InternetGetCertByURL)
    DLPENTRY(InternetGetConnectedState)
    DLPENTRY(InternetGetCookieW)
    DLPENTRY(InternetOpenUrlW)
    DLPENTRY(InternetOpenW)
    DLPENTRY(InternetQueryOptionA)
    DLPENTRY(InternetReadFile)
    DLPENTRY(InternetSecurityProtocolToStringW)
    DLPENTRY(InternetSetCookieW)
    DLPENTRY(InternetSetOptionW)
    DLPENTRY(InternetShowSecurityInfoByURLW)
    DLPENTRY(InternetTimeToSystemTimeW)
    DLPENTRY(InternetUnlockRequestFile)
    DLPENTRY(IsUrlCacheEntryExpiredW)
    DLPENTRY(RetrieveUrlCacheEntryFileA)
    DLPENTRY(SetUrlCacheEntryInfoA)
    DLPENTRY(UnlockUrlCacheEntryFileA)

};

DEFINE_PROCNAME_MAP(wininet)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\uxtheme.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#define _UXTHEME_
#include <uxtheme.h>

static 
HRESULT WINAPI CloseThemeData(HTHEME hTheme)
{
    return E_FAIL;
}

static 
HRESULT WINAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect)
{
    return E_FAIL;
}

static
HRESULT WINAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, 
    OUT RECT *pExtentRect)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemeColor(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT COLORREF *pColor)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemeFont(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LOGFONT *pFont)
{
    return E_FAIL;
}

static 
HRESULT WINAPI GetThemePartSize(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, enum THEMESIZE eSize, OUT SIZE *psz)
{
    return E_FAIL;
}

static 
HRESULT WINAPI HitTestThemeBackground(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, DWORD dwOptions, const RECT *pRect, OPTIONAL HRGN hrgn, 
    POINT ptTest, OUT WORD *pwHitTestCode)
{
    return E_FAIL;
}

static 
BOOL WINAPI IsAppThemed()
{
    return E_FAIL;
}

static 
HTHEME WINAPI OpenThemeData(HWND hwnd, LPCWSTR pszClassList)
{
    return E_FAIL;
}

static 
HRESULT WINAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList)
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(uxtheme)
{
    DLPENTRY(CloseThemeData)
    DLPENTRY(DrawThemeBackground)
    DLPENTRY(GetThemeBackgroundExtent)
    DLPENTRY(GetThemeColor)
    DLPENTRY(GetThemeFont)
    DLPENTRY(GetThemePartSize)
    DLPENTRY(HitTestThemeBackground)
    DLPENTRY(IsAppThemed)
    DLPENTRY(OpenThemeData)
    DLPENTRY(SetWindowTheme)
};

DEFINE_PROCNAME_MAP(uxtheme)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\dload\usp10.c ===
#include "pch.h"
#pragma hdrstop

#ifdef DLOAD1

#include <usp10.h>


static
HRESULT WINAPI ScriptStringAnalyse(
    HDC                      hdc,       
    const void              *pString,   
    int                      cString,   
    int                      cGlyphs,   
    int                      iCharset,  
    DWORD                    dwFlags,   
    int                      iReqWidth, 
    SCRIPT_CONTROL          *psControl, 
    SCRIPT_STATE            *psState,   
    const int               *piDx,      
    SCRIPT_TABDEF           *pTabdef,   
    const BYTE              *pbInClass, 

    SCRIPT_STRING_ANALYSIS  *pssa)
{
    return E_FAIL;
}

static
HRESULT WINAPI ScriptTextOut(
    const HDC               hdc,        
    SCRIPT_CACHE           *psc,        
    int                     x,          
    int                     y,          
    UINT                    fuOptions,  
    const RECT             *lprc,       
    const SCRIPT_ANALYSIS  *psa,        
    const WCHAR            *pwcReserved,
    int                     iReserved,  
    const WORD             *pwGlyphs,   
    int                     cGlyphs,    
    const int              *piAdvance,  
    const int              *piJustify,  
    const GOFFSET          *pGoffset)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptFreeCache(
    SCRIPT_CACHE   *psc)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptStringOut(
    SCRIPT_STRING_ANALYSIS ssa,         
    int              iX,                
    int              iY,                
    UINT             uOptions,          
    const RECT      *prc,               
    int              iMinSel,           
    int              iMaxSel,           
    BOOL             fDisabled)
{
    return E_FAIL;
}


static
const SIZE* WINAPI ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptStringFree(
    SCRIPT_STRING_ANALYSIS *pssa)
{
    return E_FAIL;
}


static
const int* WINAPI ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptBreak(
    const WCHAR            *pwcChars,  
    int                     cChars,    
    const SCRIPT_ANALYSIS  *psa,       
    SCRIPT_LOGATTR         *psla)
{
    return E_FAIL;
}


static
const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa)
{
    return NULL;
}


static
HRESULT WINAPI ScriptItemize(
    const WCHAR           *pwcInChars,  
    int                    cInChars,    
    int                    cMaxItems,   
    const SCRIPT_CONTROL  *psControl,   
    const SCRIPT_STATE    *psState,     
    SCRIPT_ITEM           *pItems,      
    int                   *pcItems)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptGetProperties(
    const SCRIPT_PROPERTIES ***ppSp,             
    int                       *piNumScripts)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptShape(
    HDC                 hdc,            
    SCRIPT_CACHE       *psc,            
    const WCHAR        *pwcChars,       
    int                 cChars,         
    int                 cMaxGlyphs,     
    SCRIPT_ANALYSIS    *psa,            
    WORD               *pwOutGlyphs,    
    WORD               *pwLogClust,     
    SCRIPT_VISATTR     *psva,           
    int                *pcGlyphs)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptPlace(
    HDC                     hdc,        
    SCRIPT_CACHE           *psc,        
    const WORD             *pwGlyphs,   
    int                     cGlyphs,    
    const SCRIPT_VISATTR   *psva,       
    SCRIPT_ANALYSIS        *psa,        
    int                    *piAdvance,  
    GOFFSET                *pGoffset,   
    ABC                    *pABC)
{
    return E_FAIL;
}


static
HRESULT WINAPI ScriptGetFontProperties(
    HDC                     hdc,    
    SCRIPT_CACHE           *psc,    
    SCRIPT_FONTPROPERTIES  *sfp)
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(usp10)
{
    DLPENTRY(ScriptBreak)
    DLPENTRY(ScriptFreeCache)
    DLPENTRY(ScriptGetFontProperties)
    DLPENTRY(ScriptGetProperties)
    DLPENTRY(ScriptItemize)
    DLPENTRY(ScriptPlace)
    DLPENTRY(ScriptShape)
    DLPENTRY(ScriptStringAnalyse)
    DLPENTRY(ScriptStringFree)
    DLPENTRY(ScriptStringOut)
    DLPENTRY(ScriptString_pLogAttr)
    DLPENTRY(ScriptString_pSize)
    DLPENTRY(ScriptString_pcOutChars)
    DLPENTRY(ScriptTextOut)
};

DEFINE_PROCNAME_MAP(usp10)

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from forms directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include <padhead.hxx>

MtDefine(CEnumGenericPad, Pad, "CEnumGeneric")
MtDefine(CEnumVARIANTPad, Pad, "CEnumVARIANT")

//  TODO: reconcile with CEnumXX in stdenum.cxx


// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(paryCopy->Copy(_cb, *pary, _fAddRef));
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    IncrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    IncrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    IUnknown ** ppUnk;
    int         i;

    if (_pary && _fDelete)
    {
        if (_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < _pary->Size();
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DecrementObjectCount();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//----------------------------------------------------------------------------

class CEnumGeneric : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumGenericPad))
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    //  CEnumGeneric methods
    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            REFIID          iid,
            BOOL            fAddRef,
            BOOL            fCopy,
            BOOL            fDelete,
            CEnumGeneric ** ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CImplAry *      pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    Assert(pary);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef));
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    Assert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **) ppv);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

class CEnumVARIANT : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumVARIANTPad))
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            VARTYPE         vt,
            BOOL            fCopy,
            BOOL            fDelete,
            IEnumVARIANT ** ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     _vt;                    // type of element enumerated
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CImplAry *      pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    Assert(pary);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!ppenum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == _cb);
            hr = THR((*(IUnknown **) pb)->QueryInterface(
                    IID_IDispatch, (void **) &V_DISPATCH(pvar)));
            if (hr)
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ((IDispatch **) reelt)[j]->Release();
                }

                RRETURN(hr);
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum));
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    Assert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\afxres.h ===
#include <windows.h>
#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\f3\htmlpad\chsfld.cpp ===
////////////////////////////////////////////////////////////////////////////
//
//      CHSFLD.CPP
//
//
//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
///////////////////////////////////////////////////////////////////////


#include <padhead.hxx>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>
#endif

#ifndef X_MSG_HXX_
#define X_MSG_HXX_
#include "msg.hxx"
#endif

#ifndef X_TVDLG_H_
#define X_TVDLG_H_
#include "tvdlg.h"
#endif

#ifndef X_PADRC_H_
#define X_PADRC_H_
#include "padrc.h"
#endif

#ifndef X_TVSTACK_H_
#define X_TVSTACK_H_
#include "tvstack.h"
#endif

#define cImageHeight    16
#define cImageWidth     16
#define cImages         4

//globals
LPSTR g_szAllStoresA = "All Message Stores";
LPTSTR g_szModuleName = TEXT("Choose Folder Dialog");

//functions used only in this file
BOOL CALLBACK
ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPTSTR * pszNewName);

BOOL CALLBACK
NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


//
//  HrPickFolder
//
//  
STDAPI
HrPickFolder(HINSTANCE hInst, HWND hWnd, LPMAPISESSION pses, LPMAPIFOLDER * ppfld,
                LPMDB *ppmdb, ULONG * pcb, LPBYTE * ppb)
{
    HRESULT hr;
    
    Assert(hInst);
    
    if((hWnd && !IsWindow(hWnd)) || (!pses) || (!ppfld) || (!ppmdb))
    { 
        //DebugTraceResult(HrPickFolder, E_INVALIDARG);
        return E_INVALIDARG;
    }

    if(pcb && IsBadWritePtr(pcb, sizeof(ULONG)))
    {
        //DebugTraceArg(HrPickFolder, "pcb not writable");
        return E_INVALIDARG;
    }

    if(pcb && (*pcb & 0x3))
    {
        //DebugTraceArg(HrPickFolder, "pcb not multiple of 4");
        return E_INVALIDARG;
    }
    
    if(ppb && IsBadWritePtr(ppb, sizeof(LPBYTE)))
    {
        //DebugTraceArg(HrPickFolder, "ppb not writable");
        return E_INVALIDARG;
    }

    if(ppb && pcb && IsBadWritePtr(*ppb, *pcb))
    {
        //DebugTraceArg(HrPickFolder, "*pcb or *ppb");
        return E_INVALIDARG;
    }

    //////////////////////////////////////////////////////////////////////
    // if you incorporate this code into you app, remove this and pass in
    // the right hInst
    // Start remove
    //hInst = GetModuleHandle("chsfld32.dll");
    //if(!hInst)
    // {
    //    DebugTrace("GetModuleHandel failed\n");
    //    DebugTraceResult(HrPickFolder, E_FAIL);
    //    return E_FAIL;
    //}
    // End remove
    ///////////////////////////////////////////////////////////////////////

    //ULONG cb = 0;
    //LPBYTE pb = NULL;
    
    CChsFldDlg PickDlg(pses, hInst, pcb, ppb);

    InitCommonControls();

    hr = PickDlg.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd,
                        (DLGPROC)ChsFldDlgProc, ppfld, ppmdb);

/*  if(SUCCEEDED(hr))
    {
        (*ppfld)->Release();
        (*ppmdb)->Release();
    }
    
    CChsFldDlg PickDlg1(pses, hInst, pcb, ppb);

    hr = PickDlg1.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd,
                        (DLGPROC)ChsFldDlgProc, ppfld, ppmdb);*/

//  if(!hr)
    //  MAPIFreeBuffer(pb);
        
    //DebugTraceResult(HrPickFolder, hr);
    return hr;
}


//
//  CChsFldDlg::CChsFldDlg
//
inline
CChsFldDlg::CChsFldDlg(LPMAPISESSION pses, HINSTANCE hInst, ULONG * pcb,
                        LPBYTE * ppb)
{
    Assert(pses);
    Assert(hInst);
    
    _pses = pses;
    pses->AddRef();

    _hr = hrSuccess;
    _pfld = NULL;
    _pmdb = NULL;
    _hiRoot = NULL;
    _hInst = hInst;
    _hIml = NULL;
    _hDlg = NULL;
    _hwTreeCtl = NULL;
    _pcbState = pcb;
    _ppbState = ppb;
}       

//
//  CChsFldDlg::~CChsFldDlg
//
CChsFldDlg::~CChsFldDlg()
{
    ReleaseInterface(_pses);
    ReleaseInterface(_pfld);
    ReleaseInterface(_pmdb);

    if(_hIml)
        ImageList_Destroy(_hIml);
}


//
//  CChsFldDlg::SetFolder
//
//  Store the folder chosen by the user
//
inline void CChsFldDlg::SetFolder(LPMAPIFOLDER pfld, LPMDB pmdb)
{
    ReleaseInterface(_pfld);

    _pfld = pfld;
    
    if(pfld)
        pfld->AddRef();

    ReleaseInterface(_pmdb);

    _pmdb = pmdb;
    if(pmdb)
        pmdb->AddRef();
}


//
//  CChsFldDlg::HrPick
//
// The outmost method.
//
HRESULT CChsFldDlg::HrPick(LPCTSTR lpTemplateName, HWND hWnd,
                DLGPROC pfnDlgProc, LPMAPIFOLDER * ppfld, LPMDB *ppmdb)
{
    if(-1 == DialogBoxParam(_hInst, lpTemplateName, hWnd, pfnDlgProc, (LPARAM) this))
    {
        //DebugTraceSc(CChsDldDlg::HrPick, MAPI_E_NOT_ENOUGH_MEMORY);
        return MAPI_E_NOT_ENOUGH_MEMORY;
    }

    //_hr is set inside the dialog
    if(HR_SUCCEEDED(_hr))
    {
        Assert(_pfld);
        _pfld->AddRef();
        *ppfld = _pfld;

        Assert(_pmdb);
        _pmdb->AddRef();
        *ppmdb = _pmdb;
    }

    return _hr;
}

//
//  CChsFldDlg::HrInitTree
//
// Called from WM_INITDIALOG. Opens all message stores in the profile and
// puts the IPM subtrees in the tree control
//
HRESULT CChsFldDlg::HrInitTree(HWND hDlg, HWND hwTreeCtl)
{
    HRESULT     hr;
    LPSPropValue pval = NULL;
    LPTVNODE    pNode = NULL;
    HTREEITEM   hiRoot = NULL;
    HICON       hIcon = NULL;
    
    Assert(hDlg);
    Assert(hwTreeCtl);

    _hwTreeCtl = hwTreeCtl;
    _hDlg      = hDlg;
    

    //
    // Set up the image list
    //
    _hIml = ImageList_Create(cImageWidth, cImageHeight, ILC_MASK, 
                            cImages, 0);
    if(!_hIml)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }

    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_ALLSTORES));
    _iIconAllStores = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_ROOTFLD));
    _iIconRootFld = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_OPENFLD));
    _iIconOpenFld = ImageList_AddIcon(_hIml, hIcon);
    
    hIcon = LoadIcon(_hInst, MAKEINTRESOURCE(IDI_CLSDFLD));
    _iIconClsdFld = ImageList_AddIcon(_hIml, hIcon);

    if(ImageList_GetImageCount(_hIml) < cImages)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }


    TreeView_SetImageList(hwTreeCtl, _hIml, TVSIL_NORMAL);
    
    //
    // create the root tree node
    // (fake a GetProps)
    //
    hr = MAPIAllocateBuffer(nhtProps * sizeof(SPropValue),
                        (LPVOID *)&pval);
    if(hr)
    {
        g_LastError.SetLastError(hr);
        g_LastError.ShowError(hDlg);
            
        goto err;
    }
    

    ZeroMemory(pval, nhtProps * sizeof(SPropValue));

    //Set  proptags to make CNode constructor happy
    pval[iEID].ulPropTag = PR_ENTRYID;
    pval[iDispName].ulPropTag = PR_DISPLAY_NAME_A;
    pval[iDispName].Value.lpszA = g_szAllStoresA;
    pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;

    hr = HrCreateNode(pval, nhtProps, NULL, &pNode);
    if(hr)
        goto err;

    Assert(pNode);
    
    pval = NULL; //will be freed in ~CTVNode

    hiRoot = AddOneItem(NULL, TVI_ROOT, _iIconAllStores, _iIconAllStores,
                            hwTreeCtl, pNode, 1);
    if(!hiRoot)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }
    
    pNode->SetKidsLoaded(TRUE);
    
    _hiRoot = hiRoot;
    
    //
    //  Put the IPM subtrees of all the message stores in
    //
    hr = HrLoadRoots();
    if(HR_FAILED(hr))
        goto err;

    (void)HrRestoreTreeState();
        
err:
    MAPIFreeBuffer(pval);

    //DebugTraceResult(CChsFldDlg::HrInitTree, hr);
    return hr;
}


//
//  CChsFldDlg::HrLoadRoots
//
HRESULT CChsFldDlg::HrLoadRoots(void)
{
    HRESULT hr;
    LPMAPITABLE ptblMStrs = NULL;
    UINT ind;
    LPSRowSet pRows = NULL;
    static SSortOrderSet sosName;

    sosName.cSorts = 1;
    sosName.cCategories = 0;
    sosName.cExpanded = 0;
    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME_A;
    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND;

        
    //Get Message Store Table
    hr = _pses->GetMsgStoresTable(0, &ptblMStrs);
    if(hr)
    {
        g_LastError.SetLastError(hr, _pses);
        g_LastError.ShowError(_hDlg);

        goto err;
    }

    //For each msg store insert a node corresponding to PR_IPM_SUBTREE

    hr = HrQueryAllRows(ptblMStrs, (LPSPropTagArray) &spthtProps, NULL,
                        &sosName, 0, &pRows);
                        
    if(HR_FAILED(hr))
        goto err;

    if(0 ==  pRows->cRows)  //$ No stores
    {
        MessageBox(_hDlg,
                    TEXT("No message stores in the profile"),
                    g_szModuleName,
                    MB_OK);
        hr = E_FAIL;
    }
    
    for(ind = 0; ind < pRows->cRows; ++ind)
    {
        LPSPropValue pval = pRows->aRow[ind].lpProps;
        Assert(pRows->aRow[ind].cValues == nhtProps);
        Assert(pval[iEID].ulPropTag == PR_ENTRYID);

        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS;
        pval[iSubfldrs].Value.b = TRUE;

        //pval is consumed by this function
        hr = HrInsertRoot(pval);
        pRows->aRow[ind].cValues = 0;
        pRows->aRow[ind].lpProps = NULL;
        if(FAILED(hr))
            goto err;
        
    }

    
        
err:
    FreeProws(pRows);
    ReleaseInterface(ptblMStrs);

    //DebugTraceResult(CChsFldDlg::HrLoadRoots, hr);
    return hr;
}

//
//  CChsFldDlg::HrInsertRoot
//
// Put the IPM subtree of the msg store in the tree control
//  pval is consumed
//
HRESULT CChsFldDlg::HrInsertRoot(LPSPropValue pval)
{
    HRESULT hr;
    HTREEITEM hItem;


    Assert(_hiRoot);
    
    
    LPTVNODE pNode = NULL;
    hr = HrCreateNode(pval, nhtProps, NULL, &pNode);
    if(hr)
    {
        MAPIFreeBuffer(pval);
        goto err;
    }

    Assert(pNode);
    pval = NULL;

        
    hItem = AddOneItem(_hiRoot, TVI_LAST, _iIconRootFld, _iIconRootFld,
                            _hwTreeCtl, pNode, 1);
    if(!hItem)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto err;
    }
            
        
err:

    //DebugTraceResult(CChsFldDlg::HrInsertRoots, hr);
    return hr;
}


//
//  CChsFldDlg::HrSaveTreeState
//
// Save expand - collapse state of the tree control
//
HRESULT CChsFldDlg::HrSaveTreeState(void)
{
    HRESULT hr;

    if(!_pcbState || !_ppbState)
        return hrSuccess;

    MAPIFreeBuffer(*_ppbState);
    *_ppbState = NULL;
    *_pcbState = 0;
    
    hr = HrSaveTreeStateEx(FALSE, _pcbState, NULL);
    if(hr)
        goto err;

    //DebugTrace("ChsFld: size of state data: %ld\n", *_pcbState);
    
    hr = HrSaveTreeStateEx(TRUE, _pcbState, _ppbState);
    
err:
    //DebugTraceResult(CChsFldDlg::HrSaveTreeState, hr);
    return hr;
}

//
//  CChsFldDlg::HrSaveTreeStateEx
//
// Save expand - collapse state of the tree control
//
HRESULT CChsFldDlg::HrSaveTreeStateEx(BOOL fWrite, ULONG * pcb, LPBYTE * ppb)
{
    HRESULT hr = hrSuccess;
    CTIStack tiStack;
    HTREEITEM hti;
    LPBYTE pb = NULL;
    LPBYTE pBuffer = NULL;
    LONG iLevel;

    if(fWrite)
    {
        if(*pcb == 0)
        {
            *ppb = NULL;
            return hrSuccess;
        }
        else
        {
            hr = MAPIAllocateBuffer(*pcb, (LPVOID *) &pBuffer);
            if (hr)
            {
                *pcb = 0;
                return hr;
            }
            pb = pBuffer;
        }
    }

    hti = TreeView_GetRoot(_hwTreeCtl);
    iLevel = 0;
    tiStack.Push(NULL);

    while(hti)
    {
        Assert(iLevel >= 0);
        
        while(hti)
        {
            TV_ITEM tvi;
            
            tvi.hItem = hti;
            tvi.mask = TVIF_STATE | TVIF_PARAM;
            tvi.lParam = 0;
            tvi.state = 0;
            tvi.stateMask = TVIS_EXPANDED;

            if(!TreeView_GetItem(_hwTreeCtl, &tvi))
            {
                hr = E_FAIL;
                goto err;
            }

            if(tvi.state & TVIS_EXPANDED)
            {
                HTREEITEM htiChild = TreeView_GetChild(_hwTreeCtl, hti);

                if(htiChild)
                {
                    LPTVNODE pNode = (LPTVNODE) tvi.lParam;
                    Assert(pNode);

                    pNode->Write(fWrite, iLevel, &pb);

                    HTREEITEM htiNextSibl = TreeView_GetNextSibling(_hwTreeCtl, hti);

                    tiStack.Push(htiNextSibl);

                    hti = htiChild;
                    ++iLevel;

                    continue;
                }

            }

            hti = TreeView_GetNextSibling(_hwTreeCtl, hti);
        }

        do
        {
            hti = tiStack.Pop();
            --iLevel;
            
        }while(!tiStack.IsEmpty() && hti == NULL);
    }

    Assert(iLevel == -1);

    *pcb = pb - pBuffer;
    if(pBuffer)
        *ppb = pBuffer;
    
err:
    //DebugTraceResult(CChsFldDlg::HrSaveTreeStateEx, hr);
    return hr;
}

inline LONG GetLevel(LPBYTE * ppb)
{
    LONG level = *((LONG *) *ppb);

    *ppb += sizeof(LONG);

    return level;
}

inline ULONG GetCb(LPBYTE * ppb)
{
    ULONG cb = *((ULONG *) *ppb);

    *ppb += sizeof(ULONG);

    return cb;
}

HTREEITEM HtiFindChild(HWND hwTreeCtl, HTREEITEM hti, ULONG cb,
                    LPENTRYID pbEID, CChsFldDlg *pCFDlg, LPTVNOD