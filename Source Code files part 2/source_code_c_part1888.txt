//
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeW (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumFirstFileRoot enumerates the first root that matches caller's conditions

Arguments:

    FileEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PSTR root = NULL;
    BOOL ignore;

    if (FileEnum->FileEnumInfo.PathPattern->ExactRoot) {
		root = pFileAllocateMemory (SizeOfStringA (FileEnum->FileEnumInfo.PathPattern->ExactRoot));
		ObsDecodeStringA (root, FileEnum->FileEnumInfo.PathPattern->ExactRoot);
	}

    if (root) {

        if (!BfPathIsDirectoryA (root)) {
            DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Invalid root spec: %s", root));
			pFileFreeMemory (root);
            return FALSE;
        }

        if (pCreateDirNodeA (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
			pFileFreeMemory (root);
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveA (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGA ((DBG_FILEENUM, "pEnumFirstFileRootA: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveA (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PWSTR root = NULL;
    BOOL ignore;

    if (FileEnum->FileEnumInfo.PathPattern->ExactRoot) {
		root = pFileAllocateMemory (SizeOfStringW (FileEnum->FileEnumInfo.PathPattern->ExactRoot));
		ObsDecodeStringW (root, FileEnum->FileEnumInfo.PathPattern->ExactRoot);
	}

    if (root) {

        if (!BfPathIsDirectoryW (root)) {
            DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Invalid root spec: %s", root));
			pFileFreeMemory (root);
            return FALSE;
        }

        if (pCreateDirNodeW (FileEnum, root, NULL, NULL)) {
            FileEnum->RootState = FES_ROOT_DONE;
			pFileFreeMemory (root);
            return TRUE;
        }
    } else {
        FileEnum->DriveEnum = pFileAllocateMemory (DWSIZEOF (DRIVE_ENUMA));

        if (!EnumFirstDriveW (FileEnum->DriveEnum, FileEnum->DriveEnumTypes)) {
            return FALSE;
        }

        do {
            if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_FILE, FileEnum->DriveEnum->DriveName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {
                    DEBUGMSGW ((DBG_FILEENUM, "pEnumFirstFileRootW: Root is excluded: %s", FileEnum->DriveEnum->DriveName));
                    continue;
                }
            }
            if (!pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            FileEnum->RootState = FES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextDriveW (FileEnum->DriveEnum));

        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }

    return FALSE;
}


BOOL
pEnumNextFileRootA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveA (FileEnum->DriveEnum)) {
        if (pCreateDirNodeA (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextFileRootW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    BOOL ignore;

    while (EnumNextDriveW (FileEnum->DriveEnum)) {
        if (pCreateDirNodeW (FileEnum, FileEnum->DriveEnum->DriveName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    FileEnum->RootState = FES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    EnumFirstFileInTreeEx enumerates file system dirs, and optionally files, that match the
    specified criteria

Arguments:

    FileEnum - Receives the enum context info; this will be used in subsequent calls to
               EnumNextFileInTree
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedFilePattern - Specifies the encoded file pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no files
                          should be returned (only look for dirs)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern)
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                  this parameter decides the enum order between files and subdirs
                  for each dir
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a subdir that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoA (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExA: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeA (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootA (FileEnum)) {
        AbortEnumFileInTreeA (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeA (FileEnum);
}

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError    OPTIONAL
    )
{
    MYASSERT (FileEnum && EncodedPathPattern && *EncodedPathPattern);
    MYASSERT (g_FileEnumPool);

    ZeroMemory (FileEnum, DWSIZEOF (*FileEnum));    //lint !e613 !e668

    FileEnum->DriveEnumTypes = DriveEnumTypes;

    //
    // first try to get dir enum info in internal format
    //
    if (!pGetFileEnumInfoW (
            /*lint -e(613)*/&FileEnum->FileEnumInfo,
            EncodedPathPattern,
            EnumDirs,
            ContainersFirst,
            FilesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions
            )) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }
    if (UseExclusions) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_FILE, /*lint -e(613)*/FileEnum->FileEnumInfo.PathPattern)) {
            DEBUGMSGW ((
                DBG_FILEENUM,
                "EnumFirstFileInTreeExW: Root is excluded: %s",
                EncodedPathPattern
                ));
            AbortEnumFileInTreeW (FileEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstFileRootW (FileEnum)) {
        AbortEnumFileInTreeW (FileEnum);
        return FALSE;
    }

    /*lint -e(613)*/FileEnum->FileEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextFileInTreeW (FileEnum);
}


BOOL
pTestLeafPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR LeafToTest
    )
{
    PSTR newLeaf;
    BOOL result = TRUE;

    if (!TestParsedPatternA (ParsedPattern, LeafToTest)) {
        newLeaf = JoinTextA (LeafToTest, ".");
        result = TestParsedPatternA (ParsedPattern, newLeaf);
        FreeTextA (newLeaf);
    }
    return result;
}

BOOL
pTestLeafPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR LeafToTest
    )
{
    PWSTR newLeaf;
    BOOL result = TRUE;

    if (!TestParsedPatternW (ParsedPattern, LeafToTest)) {
        newLeaf = JoinTextW (LeafToTest, L".");
        result = TestParsedPatternW (ParsedPattern, newLeaf);
        FreeTextW (newLeaf);
    }
    return result;
}


/*++

Routine Description:

    EnumNextFileInTree enumerates the next node matching the criteria specified in
    FileEnum; this is filled on the call to EnumFirstFileInTreeEx;

Arguments:

    FileEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    PDIRNODEA currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeA (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {  //lint !e506

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = '\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeA (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = _mbsrchr (FileEnum->Location, '\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = _mbsinc (FileEnum->LastWackPtr);
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }
                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;
                //
                // prepare full path buffer
                //
                StringCopyA (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                FileEnum->Location,
                                                NULL,
                                                TRUE
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !pTestLeafPatternA (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatA (FileEnum->NativeFullName, FileEnum->Location);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = '\\';
                    }
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringA (FileEnum->NativeFullName);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = '\\';
                    }
                }

                if (FileEnum->FileNameAppendPos + SizeOfStringA (FileEnum->Name) / DWSIZEOF(CHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(CHAR)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "File %s\\%s was found, but it's path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyA (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2A (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                FileEnum->Location,
                                                FileEnum->Name,
                                                TRUE
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootA (FileEnum);

    } while (success);

    AbortEnumFileInTreeA (FileEnum);

    return FALSE;
}

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    PDIRNODEW currentNode;
    BOOL success;

    MYASSERT (FileEnum);

    do {
        if (FileEnum->EncodedFullName) {
            ObsFreeW (FileEnum->EncodedFullName);
            FileEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = L'\\';
                FileEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextFileInTreeW (FileEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->DirName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & DNF_DIRNAME_MATCHES)) {   //lint !e613
                continue;
            }

            if (/*lint -e(613)*/currentNode->FindData.cFileName[0] == 0) {
                MYASSERT (/*lint -e(613)*/currentNode->DirAttributes & FILE_ATTRIBUTE_DIRECTORY);

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->LastWackPtr = wcsrchr (FileEnum->Location, L'\\');
                if (!FileEnum->LastWackPtr) {
                    FileEnum->Name = FileEnum->Location;
                } else {
                    FileEnum->Name = FileEnum->LastWackPtr + 1;
                    if (!FileEnum->Name) {
                        FileEnum->Name = FileEnum->Location;
                    }
                }
                FileEnum->Attributes = /*lint -e(613)*/currentNode->DirAttributes;
                //
                // prepare full path buffer
                //
                StringCopyW (FileEnum->NativeFullName, FileEnum->Location);
                FileEnum->LastNode = currentNode;
                FileEnum->FileNameAppendPos = NULL;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                FileEnum->Location,
                                                NULL,
                                                TRUE
                                                );
            } else {

                FileEnum->Location = /*lint -e(613)*/currentNode->DirName;
                FileEnum->Name = /*lint -e(613)*/currentNode->FindData.cFileName;

                //
                // test if the filename matches
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !pTestLeafPatternW (
                            FileEnum->FileEnumInfo.PathPattern->LeafPattern,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            )
                   ) {
                    continue;
                }

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_FILE, NULL, /*lint -e(613)*/currentNode->FindData.cFileName)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "File %s\\%s was found, but it's excluded by filename",
                            FileEnum->Location,
                            /*lint -e(613)*/currentNode->FindData.cFileName
                            ));
                        continue;
                    }
                }

                if (FileEnum->LastNode != currentNode) {
                    FileEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    FileEnum->NativeFullName[0] = 0;
                    FileEnum->FileNameAppendPos = StringCatW (FileEnum->NativeFullName, FileEnum->Location);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = L'\\';
                    }
                } else if (!FileEnum->FileNameAppendPos) {
                    FileEnum->FileNameAppendPos = GetEndOfStringW (FileEnum->NativeFullName);
                    if (FileEnum->FileNameAppendPos) {
                        *FileEnum->FileNameAppendPos++ = L'\\';
                    }
                }
                MYASSERT (FileEnum->Name && *FileEnum->Name);

                if (FileEnum->FileNameAppendPos + SizeOfStringW (FileEnum->Name) / DWSIZEOF(WCHAR)>
                    FileEnum->NativeFullName + DWSIZEOF (FileEnum->NativeFullName) / DWSIZEOF(WCHAR)) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "File %s\\%s was found, but it's path is too long",
                        FileEnum->Location,
                        FileEnum->Name
                        ));
                    continue;
                }

                StringCopyW (FileEnum->FileNameAppendPos, FileEnum->Name);
                FileEnum->Attributes = /*lint -e(613)*/currentNode->FindData.dwFileAttributes;

                if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (ElIsExcluded2W (ELT_FILE, FileEnum->Location, FileEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_FILEENUM,
                            "Object %s was found, but it's excluded",
                            FileEnum->NativeFullName
                            ));
                        continue;
                    }
                }

                FileEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                FileEnum->Location,
                                                FileEnum->Name,
                                                TRUE
                                                );
            }

            if (FileEnum->LastWackPtr) {
                *FileEnum->LastWackPtr = 0;
            }

            FileEnum->CurrentLevel = FileEnum->FileEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            return TRUE;
        }

        //
        // try the next root
        //
        if (FileEnum->RootState == FES_ROOT_DONE) {
            break;
        }

        MYASSERT (FileEnum->RootState == FES_ROOT_NEXT);
        MYASSERT (FileEnum->DriveEnum);
        success = pEnumNextFileRootW (FileEnum);

    } while (success);

    AbortEnumFileInTreeW (FileEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortEnumFileInTree aborts the enumeration, freeing all resources allocated

Arguments:

    FileEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    )
{
    while (pDeleteDirNodeA (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeA (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternA (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    )
{
    while (pDeleteDirNodeW (FileEnum, TRUE)) {
    }
    GbFree (&FileEnum->FileNodes);

    if (FileEnum->EncodedFullName) {
        ObsFreeW (FileEnum->EncodedFullName);
        FileEnum->EncodedFullName = NULL;
    }

    if (FileEnum->FileEnumInfo.PathPattern) {
        ObsDestroyParsedPatternW (FileEnum->FileEnumInfo.PathPattern);
        FileEnum->FileEnumInfo.PathPattern = NULL;
    }

    if (FileEnum->DriveEnum) {
        pFileFreeMemory (FileEnum->DriveEnum);
        FileEnum->DriveEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\cablib\cablib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.c

Abstract:

    Implements wrappers for cabinet APIs

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include <cablib.h>
#include <fci.h>
#include <fdi.h>
#include <fcntl.h>
#include <crt\sys\stat.h>

//
// Includes
//

// None

#define DBG_CABLIB  "CabLib"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR CabPath;
    PCSTR CabFileFormat;
    PCSTR CabDiskFormat;
    PCABGETCABINETNAMESA CabGetCabinetNames;
    PCABGETTEMPFILEA CabGetTempFile;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFileFormat;
    PCWSTR CabDiskFormat;
    PCABGETCABINETNAMESW CabGetCabinetNames;
    PCABGETTEMPFILEW CabGetTempFile;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW;

typedef struct {
    PCSTR CabPath;
    PCSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW;

typedef struct {
    PCSTR ExtractPath;
    PCABNOTIFICATIONA CabNotification;
} CAB_DATAA, *PCAB_DATAA;

typedef struct {
    PCWSTR ExtractPath;
    PCABNOTIFICATIONW CabNotification;
} CAB_DATAW, *PCAB_DATAW;

//
// Globals
//

HASHTABLE g_UnicodeTable = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

INT
DIAMONDAPI
pCabFilePlacedA (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


INT
DIAMONDAPI
pCabFilePlacedW (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}

VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    if (Memory) {
        MemFree (g_hHeap, 0, Memory);
    }
}

INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    MYASSERT (pMode == (_S_IREAD | _S_IWRITE));

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1W (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR fileName = NULL;
    PSTR fileNamePtr = NULL;
    PCWSTR fileNameW = NULL;
    PCWSTR fullFileName = NULL;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    if (g_UnicodeTable) {
        fileName = DuplicatePathStringA (FileName, 0);
        if (fileName) {
            fileNamePtr = (PSTR)GetFileNameFromPathA (fileName);
            if (fileNamePtr) {
                *fileNamePtr = 0;
                if ((HtFindStringAndDataA (g_UnicodeTable, fileName, &cabHandle) != NULL) &&
                    (cabHandle != NULL)
                    ) {
                    fileNamePtr = (PSTR)GetFileNameFromPathA (FileName);
                    if (fileNamePtr) {
                        fileNameW = ConvertAtoW (fileNamePtr);
                        if (fileNameW) {
                            fullFileName = JoinPathsW (cabHandle->CabPath, fileNameW);
                            if (fullFileName) {
                                fileHandle = CreateFileW (
                                                fullFileName,
                                                GENERIC_READ,
                                                FILE_SHARE_READ,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_ATTRIBUTE_ARCHIVE,
                                                NULL
                                                );
                                FreePathStringW (fullFileName);
                                fullFileName = NULL;
                            }
                            FreeConvertedStr (fileNameW);
                            fileNameW = NULL;
                        }
                    }
                }
            }
            FreePathStringA (fileName);
            fileName = NULL;
        }
    }

    if (fileHandle == INVALID_HANDLE_VALUE) {
        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_ARCHIVE,
                        NULL
                        );
    }

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }

    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return bytesRead;
}

UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;

    result = BfWriteFile ((HANDLE)FileHandle, Buffer, Size);
    if (!result) {
        *Error = GetLastError ();
        return ((UINT)(-1));
    }
    *Error = 0;
    return Size;
}

UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;

    result = BfWriteFile ((HANDLE)FileHandle, Buffer, Size);
    if (!result) {
        return ((UINT)(-1));
    }
    return Size;
}

INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    *Error = 0;
    return 0;
}

INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return ((LONG)(result));
}

LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    if (!DeleteFileA (FileName)) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) Context;

    if (cabHandle && cabHandle->CabGetTempFile) {
        return cabHandle->CabGetTempFile (FileName, FileNameLen);
    }

    return BfGetTempFileNameA (FileName, FileNameLen);
}

BOOL
DIAMONDAPI
pCabGetTempFileW (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR tempFileNameW [MAX_PATH];
    PCSTR tempFileNameA = NULL;

    cabHandle = (PFCI_CAB_HANDLEW) Context;

    if (cabHandle && cabHandle->CabGetTempFile) {
        if (cabHandle->CabGetTempFile (tempFileNameW, MAX_PATH)) {
            tempFileNameA = ConvertWtoA (tempFileNameW);
            if (tempFileNameA) {
                StringCopyTcharCountA (FileName, tempFileNameA, FileNameLen);
                FreeConvertedStr (tempFileNameA);
                return TRUE;
            }
        }
        return FALSE;
    }

    return BfGetTempFileNameA (FileName, FileNameLen);
}

BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        return cabHandle->CabGetCabinetNames (
                            FciCabParams->szCabPath,
                            CB_MAX_CAB_PATH,
                            FciCabParams->szCab,
                            CB_MAX_CABINET_NAME,
                            FciCabParams->szDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfA (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            StringCopyByteCountA (FciCabParams->szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfA (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            StringCopyByteCountA (FciCabParams->szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
        }
    }
    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];
    BOOL result;

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        result = cabHandle->CabGetCabinetNames (
                            cabPath,
                            CB_MAX_CAB_PATH,
                            cabFile,
                            CB_MAX_CABINET_NAME,
                            cabDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
        if (result) {
            KnownSizeUnicodeToDbcsN (FciCabParams->szCabPath, cabPath, min (CB_MAX_CAB_PATH, CharCountW (cabPath)));
            KnownSizeUnicodeToDbcsN (FciCabParams->szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
            KnownSizeUnicodeToDbcsN (FciCabParams->szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
            return TRUE;
        }
        return FALSE;
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            wsprintfW (cabFile, cabHandle->CabFileFormat, FciCabParams->iCab);
            KnownSizeUnicodeToDbcsN (FciCabParams->szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
        }
        if (cabHandle->CabDiskFormat) {
            wsprintfW (cabDisk, cabHandle->CabDiskFormat, FciCabParams->iDisk);
            KnownSizeUnicodeToDbcsN (FciCabParams->szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
        }
    }
    return TRUE;
}

LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEA) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    if (StatusType == statusCabinet) {

        cabHandle = (PFCI_CAB_HANDLEW) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    WIN32_FIND_DATAA findData;
    FILETIME fileTime;
    HANDLE fileHandle;

    if (DoesFileExistExA (FileName, &findData)) {

        FileTimeToLocalFileTime (&findData.ftLastWriteTime, &fileTime);
        FileTimeToDosDateTime (&fileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (findData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (fileHandle == INVALID_HANDLE_VALUE) {
            *Error = GetLastError ();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)fileHandle;
    } else {
        *Error = GetLastError ();
        return -1;
    }
}

INT_PTR
DIAMONDAPI
pCabNotificationA (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAA cabData;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied
        cabData = (PCAB_DATAA)FdiNotification->pv;
        destFile = JoinPathsA (cabData->ExtractPath, FdiNotification->psz1);
        if (cabData->CabNotification) {
            if (cabData->CabNotification (destFile)) {
                destHandle = BfCreateFileA (destFile);
            }
        } else {
            destHandle = BfCreateFileA (destFile);
        }
        FreePathStringA (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAA)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        destFile = JoinPathsA (cabData->ExtractPath, FdiNotification->psz1);
        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesA (destFile, attributes);
        FreePathStringA (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        // sometimes, in a corrupted cabinet file, the cabinet APIs can ask
        // for the next cabinet but nothing more exists. If we don't fail here
        // in this case, we are going to infinite loop, so do some checking
        if (!FdiNotification) {
            return -1;
        }
        if (FdiNotification->psz1[0] == 0) {
            return -1;
        }
        return 0;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabNotificationW (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCWSTR destFile = NULL;
    PCWSTR destFileW = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAW cabData;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied
        cabData = (PCAB_DATAW)FdiNotification->pv;
        destFileW = ConvertAtoW (FdiNotification->psz1);
        if (destFileW) {
            destFile = JoinPathsW (cabData->ExtractPath, destFileW);
            if (destFile) {
                if (cabData->CabNotification) {
                    if (cabData->CabNotification (destFile)) {
                        destHandle = BfCreateFileW (destFile);
                    }
                } else {
                    destHandle = BfCreateFileW (destFile);
                }
                FreePathStringW (destFile);
            }
            FreeConvertedStr (destFileW);
        }
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAW)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        destFileW = ConvertAtoW (FdiNotification->psz1);
        if (destFileW) {
            destFile = JoinPathsW (cabData->ExtractPath, destFileW);
            if (destFile) {
                CloseHandle ((HANDLE)FdiNotification->hf);
                attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
                SetFileAttributesW (destFile, attributes);
                FreePathStringW (destFile);
            }
            FreeConvertedStr (destFileW);
        }
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        // sometimes, in a corrupted cabinet file, the cabinet APIs can ask
        // for the next cabinet but nothing more exists. If we don't fail here
        // in this case, we are going to infinite loop, so do some checking
        if (!FdiNotification) {
            return -1;
        }
        if (FdiNotification->psz1[0] == 0) {
            return -1;
        }
        return 0;
    }
    return 0;
}

CCABHANDLE
CabCreateCabinetByIndexA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      PCABGETTEMPFILEA CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [1024];
    CHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringA (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringA (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringA (CabDiskFormat, 0);
    }
    cabHandle->CabGetTempFile = CabGetTempFile;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = InitialIndex;
    cabHandle->FciCabParams.iDisk = InitialIndex;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        StringCopyByteCountA (cabHandle->FciCabParams.szCabPath, CabPath, CB_MAX_CAB_PATH - 1);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfA (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        StringCopyByteCountA (cabHandle->FciCabParams.szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
    }
    wsprintfA (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    StringCopyByteCountA (cabHandle->FciCabParams.szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetByIndexW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      PCABGETTEMPFILEW CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringW (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringW (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringW (CabDiskFormat, 0);
    }
    cabHandle->CabGetTempFile = CabGetTempFile;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = InitialIndex;
    cabHandle->FciCabParams.iDisk = InitialIndex;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCabPath, CabPath, min (CB_MAX_CAB_PATH - 1, CharCountW (CabPath)));
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        wsprintfW (cabDisk, CabDiskFormat, cabHandle->FciCabParams.iDisk);
        KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
    }
    wsprintfW (cabFile, CabFileFormat, cabHandle->FciCabParams.iCab);
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileW,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabHandle->FciCabParams.szCabPath,
            CB_MAX_CAB_PATH,
            cabHandle->FciCabParams.szCab,
            CB_MAX_CABINET_NAME,
            cabHandle->FciCabParams.szDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [1024];
    WCHAR cabFile [1024];
    WCHAR cabDisk [1024];

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabPath,
            CB_MAX_CAB_PATH,
            cabFile,
            CB_MAX_CABINET_NAME,
            cabDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCabPath, cabPath, min (CB_MAX_CAB_PATH, CharCountW (cabPath)));
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szCab, cabFile, min (CB_MAX_CABINET_NAME, CharCountW (cabFile)));
    KnownSizeUnicodeToDbcsN (cabHandle->FciCabParams.szDisk, cabDisk, min (CB_MAX_DISK_NAME, CharCountW (cabDisk)));
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileW,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }

    return FCIAddFile (
                cabHandle->FciHandle,
                (PSTR)FileName,
                (PSTR)StoredName,
                FALSE,
                pCabGetNextCabinetA,
                pCabStatusA,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    CHAR ansiFileName [1024];
    CHAR ansiStoredName [1024];

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    KnownSizeUnicodeToDbcsN (ansiFileName, FileName, min (CB_MAX_CABINET_NAME, CharCountW (FileName)));
    KnownSizeUnicodeToDbcsN (ansiStoredName, StoredName, min (CB_MAX_CABINET_NAME, CharCountW (StoredName)));

    return FCIAddFile (
                cabHandle->FciHandle,
                ansiFileName,
                ansiStoredName,
                FALSE,
                pCabGetNextCabinetW,
                pCabStatusW,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetA,
            pCabStatusA
            )) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }

    return result;
}

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetW,
            pCabStatusW
            )) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }
    return result;
}

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    PSTR filePtr;
    HANDLE fileHandle;
    PCSTR fileName;

    cabHandle = (PFDI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEA));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringA (FileName, 0);
    fileHandle = BfOpenReadFileA (fileName);
    if (!fileHandle) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringA (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PSTR)GetFileNameFromPathA (fileName);
    if (!filePtr) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringA (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringA (fileName, 0);
    FreePathStringA (fileName);
    return ((CCABHANDLE)(cabHandle));
}

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PWSTR filePtr;
    HANDLE fileHandle;
    PCWSTR fileName;
    PCSTR filePathA = NULL;

    cabHandle = (PFDI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEW));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1W,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringW (FileName, 0);
    fileHandle = BfOpenReadFileW (fileName);
    if (!fileHandle) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringW (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PWSTR)GetFileNameFromPathW (fileName);
    if (!filePtr) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringW (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringW (fileName, 0);
    FreePathStringW (fileName);
    if (!g_UnicodeTable) {
        g_UnicodeTable = HtAllocWithDataA (sizeof (PFDI_CAB_HANDLEW));
    }
    if (g_UnicodeTable) {
        filePathA = ConvertWtoA (cabHandle->CabPath);
        if (filePathA) {
            HtAddStringAndDataA (g_UnicodeTable, filePathA, &cabHandle);
            FreeConvertedStr (filePathA);
            filePathA = NULL;
        }
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    CAB_DATAA cabData;

    cabHandle = (PFDI_CAB_HANDLEA)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotification = CabNotification;
    return FDICopy (
                cabHandle->FdiHandle,
                (PSTR)cabHandle->CabFile,
                (PSTR)cabHandle->CabPath,
                0,
                pCabNotificationA,
                NULL,
                (PVOID)(&cabData)
                );
}


BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    CAB_DATAW cabData;
    PCSTR cabFileA = NULL;
    PCSTR cabPathA = NULL;
    BOOL result = FALSE;

    cabHandle = (PFDI_CAB_HANDLEW)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotification = CabNotification;
    cabFileA = ConvertWtoA (cabHandle->CabFile);
    cabPathA = ConvertWtoA (cabHandle->CabPath);
    if (cabFileA && cabPathA) {
        result = FDICopy (
                    cabHandle->FdiHandle,
                    (PSTR)cabFileA,
                    (PSTR)cabPathA,
                    0,
                    pCabNotificationW,
                    NULL,
                    (PVOID)(&cabData)
                    );
    }
    if (cabPathA) {
        FreeConvertedStr (cabPathA);
        cabPathA = NULL;
    }
    if (cabFileA) {
        FreeConvertedStr (cabFileA);
        cabFileA = NULL;
    }
    return result;
}

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;

    cabHandle = (PFDI_CAB_HANDLEA) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringA (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PCSTR filePathA = NULL;

    cabHandle = (PFDI_CAB_HANDLEW) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            if (g_UnicodeTable) {
                filePathA = ConvertWtoA (cabHandle->CabPath);
                if (filePathA) {
                    HtRemoveStringA (g_UnicodeTable, filePathA);
                    FreeConvertedStr (filePathA);
                    filePathA = NULL;
                }
            }
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringW (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\file\fileutil.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileutil.c

Abstract:

    Implements utility routines for files, file paths, etc.

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FILEUTIL    "FileUtil"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pDefaultFindFileA (
    IN      PCSTR FileName
    )
{
    return (GetFileAttributesA (FileName) != INVALID_ATTRIBUTES);
}

BOOL
pDefaultFindFileW (
    IN      PCWSTR FileName
    )
{
    return (GetFileAttributesW (FileName) != INVALID_ATTRIBUTES);
}

BOOL
pDefaultSearchPathA (
    IN      PCSTR FileName,
    IN      DWORD BufferLength,
    OUT     PSTR Buffer
    )
{
    PSTR dontCare;
    return SearchPathA (NULL, FileName, NULL, BufferLength, Buffer, &dontCare);
}

BOOL
pDefaultSearchPathW (
    IN      PCWSTR FileName,
    IN      DWORD BufferLength,
    OUT     PWSTR Buffer
    )
{
    PWSTR dontCare;
    return SearchPathW (NULL, FileName, NULL, BufferLength, Buffer, &dontCare);
}

PCMDLINEA
ParseCmdLineExA (
    IN      PCSTR CmdLine,
    IN      PCSTR Separators,                   OPTIONAL
    IN      PFINDFILEA FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHA SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    )
{
    PFINDFILEA findFileCallback = FindFileCallback;
    PSEARCHPATHA searchPathCallback = SearchPathCallback;
    GROWBUFFER SpacePtrs = INIT_GROWBUFFER;
    PCSTR p;
    PSTR q;
    INT Count;
    INT i;
    INT j;
    PSTR *Array;
    PCSTR Start;
    CHAR OldChar = 0;
    GROWBUFFER StringBuf = INIT_GROWBUFFER;
    PBYTE CopyBuf;
    PCMDLINEA CmdLineTable;
    PCMDLINEARGA CmdLineArg;
    ULONG_PTR Base;
    PSTR Path = NULL;
    PSTR UnquotedPath = NULL;
    PSTR FixedFileName = NULL;
    PSTR FirstArgPath = NULL;
    DWORD pathSize = 0;
    PCSTR FullPath = NULL;
    BOOL fileExists = FALSE;
    PSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PSTR End;

    if (!Separators) {
        Separators = " =,;";
    }

    if (!findFileCallback) {
        findFileCallback = pDefaultFindFileA;
    }

    if (!searchPathCallback) {
        searchPathCallback = pDefaultSearchPathA;
    }

    pathSize = SizeOfStringA (CmdLine) * 2;
    if (pathSize < MAX_MBCHAR_PATH) {
        pathSize = MAX_MBCHAR_PATH;
    }

    Path = AllocTextA (pathSize);
    UnquotedPath = AllocTextA (pathSize);
    FixedFileName = AllocTextA (pathSize);
    FirstArgPath = AllocTextA (pathSize);
    CmdLineCopy = DuplicateTextA (CmdLine);

    if (!Path ||
        !UnquotedPath ||
        !FixedFileName ||
        !FirstArgPath ||
        !CmdLineCopy
        ) {
        return NULL;
    }

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p = _mbsinc (p)) {

        if (_mbsnextc (p) == '\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode &&
                   _mbschr (Separators, _mbsnextc (p))
                   ) {

            //
            // Remove excess spaces
            //

            q = (PSTR) p + 1;
            while (_mbsnextc (q) == ' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (CHAR), q, SizeOfStringA (q));
            }

            GbAppendPvoid (&SpacePtrs, p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEA) GbGrow (Buffer, sizeof (CMDLINEA));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCSTR) (ULONG_PTR) StringBuf.End;
    GbMultiSzAppendA (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (PVOID);
    Array = (PSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (_mbsnextc (Start) != '/') {

            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (_mbsnextc (Start) == '\"') {

                    StringCopyByteCountA (UnquotedPath, Start + 1, pathSize);
                    q = _mbschr (UnquotedPath, '\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    fileExists = findFileCallback (FullPath);

                    if (!fileExists && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountA (
                            EndOfFirstArg,
                            FullPath,
                            pathSize - (HALF_PTR) ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (!fileExists && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountA (
                            FixedFileName,
                            FullPath,
                            pathSize - sizeof (".exe")
                            );

                        q = GetEndOfStringA (FixedFileName);
                        q = _mbsdec (FixedFileName, q);
                        MYASSERT (q);

                        if (_mbsnextc (q) != '.') {
                            q = _mbsinc (q);
                        }

                        StringCopyA (q, ".exe");

                        FullPath = FixedFileName;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (fileExists) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        GbMultiSzAppendA (&StringBuf, Start);

                        if (!StringMatchA (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            GbMultiSzAppendA (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (_mbschr (Start, '\\')) {
#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGA ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // searchPathCallback.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (_mbsnextc (Start) == '\"') {

                            StringCopyByteCountA (UnquotedPath, Start + 1, pathSize);
                            q = _mbschr (UnquotedPath, '\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (searchPathCallback (
                                    FullPath,
                                    pathSize / sizeof (Path[0]),
                                    Path
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountA (
                                    FixedFileName,
                                    FullPath,
                                    pathSize - sizeof (".exe")
                                    );

                                q = GetEndOfStringA (FixedFileName);
                                q = _mbsdec (FixedFileName, q);
                                MYASSERT (q);

                                if (_mbsnextc (q) != '.') {
                                    q = _mbsinc (q);
                                }

                                StringCopyA (q, ".exe");

                                if (searchPathCallback (
                                        FixedFileName,
                                        pathSize / sizeof (Path[0]),
                                        Path
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }

                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            fileExists = findFileCallback (FullPath);
                            MYASSERT (fileExists);

                            OriginalArgOffset = StringBuf.End;
                            GbMultiSzAppendA (&StringBuf, Start);

                            if (!StringMatchA (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                GbMultiSzAppendA (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGA) GbGrow (Buffer, sizeof (CMDLINEARGA));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its existance
            // is in fileExists, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCSTR) (ULONG_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCSTR) (ULONG_PTR) CleanedUpArgOffset;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountA (
                    FirstArgPath,
                    (PCSTR) (StringBuf.Buf + (ULONG_PTR) CmdLineArg->CleanedUpArg),
                    pathSize
                    );
                q = (PSTR) GetFileNameFromPathA (FirstArgPath);
                if (q) {
                    q = _mbsdec (FirstArgPath, q);
                    if (q) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackA (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCSTR) (ULONG_PTR) StringBuf.End;
                GbMultiSzAppendA (&StringBuf, Start);

                Quoted = FALSE;

                if (_mbschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PSTR) ((PBYTE) UnquotedPath + pathSize - sizeof (CHAR));

                    while (*p && q < End) {
                        if (IsLeadByte (p)) {
                            *q++ = *p++;
                            *q++ = *p++;
                        } else {
                            if (*p == '\"') {
                                p++;
                            } else {
                                *q++ = *p++;
                            }
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCSTR) (ULONG_PTR) StringBuf.End;
                    GbMultiSzAppendA (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GbGrow (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (ULONG_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    // Earlier GbGrow may have moved the buffer in memory.  We need to repoint CmdLineTable
    CmdLineTable = (PCMDLINEA)Buffer->Buf;
    CmdLineTable->CmdLine = (PCSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    GbFree (&StringBuf);
    GbFree (&SpacePtrs);

    FreeTextA (CmdLineCopy);
    FreeTextA (FirstArgPath);
    FreeTextA (FixedFileName);
    FreeTextA (UnquotedPath);
    FreeTextA (Path);

    return (PCMDLINEA) Buffer->Buf;
}


PCMDLINEW
ParseCmdLineExW (
    IN      PCWSTR CmdLine,
    IN      PCWSTR Separators,                  OPTIONAL
    IN      PFINDFILEW FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHW SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    )
{
    PFINDFILEW findFileCallback = FindFileCallback;
    PSEARCHPATHW searchPathCallback = SearchPathCallback;
    GROWBUFFER SpacePtrs = INIT_GROWBUFFER;
    PCWSTR p;
    PWSTR q;
    INT Count;
    INT i;
    INT j;
    PWSTR *Array;
    PCWSTR Start;
    WCHAR OldChar = 0;
    GROWBUFFER StringBuf = INIT_GROWBUFFER;
    PBYTE CopyBuf;
    PCMDLINEW CmdLineTable;
    PCMDLINEARGW CmdLineArg;
    ULONG_PTR Base;
    PWSTR Path = NULL;
    PWSTR UnquotedPath = NULL;
    PWSTR FixedFileName = NULL;
    PWSTR FirstArgPath = NULL;
    DWORD pathSize = 0;
    PCWSTR FullPath = NULL;
    BOOL fileExists = FALSE;
    PWSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PWSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PWSTR End;

    if (!Separators) {
        Separators = L" =,;";
    }

    if (!findFileCallback) {
        findFileCallback = pDefaultFindFileW;
    }

    if (!searchPathCallback) {
        searchPathCallback = pDefaultSearchPathW;
    }

    pathSize = SizeOfStringW (CmdLine);
    if (pathSize < MAX_WCHAR_PATH) {
        pathSize = MAX_WCHAR_PATH;
    }

    Path = AllocTextW (pathSize);
    UnquotedPath = AllocTextW (pathSize);
    FixedFileName = AllocTextW (pathSize);
    FirstArgPath = AllocTextW (pathSize);
    CmdLineCopy = DuplicateTextW (CmdLine);

    if (!Path ||
        !UnquotedPath ||
        !FixedFileName ||
        !FirstArgPath ||
        !CmdLineCopy
        ) {
        return NULL;
    }

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p++) {
        if (*p == L'\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode &&
                   wcschr (Separators, *p)
                   ) {

            //
            // Remove excess spaces
            //

            q = (PWSTR) p + 1;
            while (*q == L' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (WCHAR), q, SizeOfStringW (q));
            }

            GbAppendPvoid (&SpacePtrs, p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEW) GbGrow (Buffer, sizeof (CMDLINEW));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCWSTR) (ULONG_PTR) StringBuf.End;
    GbMultiSzAppendW (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (PVOID);
    Array = (PWSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (*Start != L'/') {
            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (*Start == L'\"') {

                    StringCopyByteCountW (UnquotedPath, Start + 1, pathSize);
                    q = wcschr (UnquotedPath, L'\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    fileExists = findFileCallback (FullPath);

                    if (!fileExists && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountW (
                            EndOfFirstArg,
                            FullPath,
                            pathSize - (HALF_PTR) ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (!fileExists && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountW (
                            FixedFileName,
                            FullPath,
                            pathSize - sizeof (L".exe")
                            );

                        q = GetEndOfStringW (FixedFileName);
                        q--;
                        MYASSERT (q >= FixedFileName);

                        if (*q != L'.') {
                            q++;
                        }

                        StringCopyW (q, L".exe");

                        FullPath = FixedFileName;
                        fileExists = findFileCallback (FullPath);
                    }

                    if (fileExists) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        GbMultiSzAppendW (&StringBuf, Start);

                        if (!StringMatchW (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            GbMultiSzAppendW (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (wcschr (Start, L'\\')) {

#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGW ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // searchPathCallback.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (*Start == L'\"') {

                            StringCopyByteCountW (UnquotedPath, Start + 1, pathSize);
                            q = wcschr (UnquotedPath, L'\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (searchPathCallback (
                                    FullPath,
                                    pathSize / sizeof (Path[0]),
                                    Path
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountW (
                                    FixedFileName,
                                    FullPath,
                                    pathSize - sizeof (L".exe")
                                    );

                                q = GetEndOfStringW (FixedFileName);
                                q--;
                                MYASSERT (q >= FixedFileName);

                                if (*q != L'.') {
                                    q++;
                                }

                                StringCopyW (q, L".exe");

                                if (searchPathCallback (
                                        FixedFileName,
                                        pathSize / sizeof (Path[0]),
                                        Path
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }
                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            fileExists = findFileCallback (FullPath);
                            MYASSERT (fileExists);

                            OriginalArgOffset = StringBuf.End;
                            GbMultiSzAppendW (&StringBuf, Start);

                            if (!StringMatchW (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                GbMultiSzAppendW (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGW) GbGrow (Buffer, sizeof (CMDLINEARGW));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its existance
            // is in fileExists, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCWSTR) (ULONG_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCWSTR) (ULONG_PTR) CleanedUpArgOffset;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountW (
                    FirstArgPath,
                    (PCWSTR) (StringBuf.Buf + (ULONG_PTR) CmdLineArg->CleanedUpArg),
                    pathSize
                    );

                q = (PWSTR) GetFileNameFromPathW (FirstArgPath);
                if (q) {
                    q--;
                    if (q >= FirstArgPath) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackW (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCWSTR) (ULONG_PTR) StringBuf.End;
                GbMultiSzAppendW (&StringBuf, Start);

                Quoted = FALSE;
                if (wcschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PWSTR) ((PBYTE) UnquotedPath + pathSize - sizeof (WCHAR));

                    while (*p && q < End) {
                        if (*p == L'\"') {
                            p++;
                        } else {
                            *q++ = *p++;
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCWSTR) (ULONG_PTR) StringBuf.End;
                    GbMultiSzAppendW (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GbGrow (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (ULONG_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    // Earlier GbGrow may have moved the buffer in memory.  We need to repoint CmdLineTable
    CmdLineTable = (PCMDLINEW)Buffer->Buf;
    CmdLineTable->CmdLine = (PCWSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCWSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCWSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    GbFree (&StringBuf);
    GbFree (&SpacePtrs);

    FreeTextW (CmdLineCopy);
    FreeTextW (FirstArgPath);
    FreeTextW (FixedFileName);
    FreeTextW (UnquotedPath);
    FreeTextW (Path);

    return (PCMDLINEW) Buffer->Buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\compress\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\basefile.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#define INVALID_ATTRIBUTES      0xFFFFFFFF

BOOL
DoesFileExistExA (
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW (
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

BOOL
BfPathIsDirectoryA (
    IN      PCSTR PathSpec
    );

BOOL
BfPathIsDirectoryW (
    IN      PCWSTR PathSpec
    );

BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );

BOOL
BfGetTempFileNameExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    );

#define BfGetTempFileNameA(b,c) BfGetTempFileNameExA(b,c,"temp")

BOOL
BfGetTempFileNameExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    );

#define BfGetTempFileNameW(b,c) BfGetTempFileNameExW(b,c,L"temp")

BOOL
BfGetTempDirectoryExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    );

#define BfGetTempDirectoryA(b,c) BfGetTempDirectoryExA(b,c,"dir")

BOOL
BfGetTempDirectoryExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    );

#define BfGetTempDirectoryW(b,c) BfGetTempDirectoryExW(b,c,L"dir")

HANDLE
BfGetTempFile (
    VOID
    );

BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    );

HANDLE
BfOpenReadFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenReadFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    );

HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    );

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    );

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    );

BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    );

BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    );

BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    );

BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    );

BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    );


BOOL
BfCreateDirectoryExA (
    IN      PCSTR FullPath,
    IN      BOOL CreateLastSegment
    );
#define BfCreateDirectoryA(d) BfCreateDirectoryExA(d,TRUE)

BOOL
BfCreateDirectoryExW (
    IN      PCWSTR FullPath,
    IN      BOOL CreateLastSegment
    );
#define BfCreateDirectoryW(d) BfCreateDirectoryExW(d,TRUE)

LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    );

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    );

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    );

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    );

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    );

BOOL
BfCopyAndFlushFileA (
    IN      PCSTR SrcFileName,
    IN      PCSTR DestFileName,
    IN      BOOL FailIfExists
    );

BOOL
BfCopyAndFlushFileW (
    IN      PCWSTR SrcFileName,
    IN      PCWSTR DestFileName,
    IN      BOOL FailIfExists
    );

#ifdef UNICODE

#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define BfPathIsDirectory               BfPathIsDirectoryW
#define WriteFileString                 WriteFileStringW
#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW
#define BfGetTempFileName               BfGetTempFileNameW
#define BfGetTempFileNameEx             BfGetTempFileNameExW
#define BfGetTempDirectory              BfGetTempDirectoryW
#define BfGetTempDirectoryEx            BfGetTempDirectoryExW
#define BfOpenReadFile                  BfOpenReadFileW
#define BfOpenFile                      BfOpenFileW
#define BfCreateFile                    BfCreateFileW
#define BfCreateSharedFile              BfCreateSharedFileW
#define BfCreateDirectoryEx             BfCreateDirectoryExW
#define BfCreateDirectory               BfCreateDirectoryW
#define BfGetFileSize                   BfGetFileSizeW
#define BfGetLongFileName               BfGetLongFileNameW
#define BfGetLongFileNameEx             BfGetLongFileNameExW
#define BfCopyAndFlushFile              BfCopyAndFlushFileW

#else

#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define BfPathIsDirectory               BfPathIsDirectoryA
#define WriteFileString                 WriteFileStringA
#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA
#define BfGetTempFileName               BfGetTempFileNameA
#define BfGetTempFileNameEx             BfGetTempFileNameExA
#define BfGetTempDirectory              BfGetTempDirectoryA
#define BfGetTempDirectoryEx            BfGetTempDirectoryExA
#define BfOpenReadFile                  BfOpenReadFileA
#define BfOpenFile                      BfOpenFileA
#define BfCreateFile                    BfCreateFileA
#define BfCreateSharedFile              BfCreateSharedFileA
#define BfCreateDirectoryEx             BfCreateDirectoryExA
#define BfCreateDirectory               BfCreateDirectoryA
#define BfGetFileSize                   BfGetFileSizeA
#define BfGetLongFileName               BfGetLongFileNameA
#define BfGetLongFileNameEx             BfGetLongFileNameExA
#define BfCopyAndFlushFile              BfCopyAndFlushFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\cablib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef BOOL(WINAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(WINAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(WINAPI CABGETTEMPFILEA)(
                        OUT     PSTR Buffer,
                        IN      UINT BufferTchars
                        );
typedef CABGETTEMPFILEA *PCABGETTEMPFILEA;

typedef BOOL(WINAPI CABGETTEMPFILEW)(
                        OUT     PWSTR Buffer,
                        IN      UINT BufferTchars
                        );
typedef CABGETTEMPFILEW *PCABGETTEMPFILEW;

typedef BOOL(WINAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(WINAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID CCABHANDLE;

typedef PVOID OCABHANDLE;

//
// API
//

CCABHANDLE
CabCreateCabinetByIndexA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      PCABGETTEMPFILEA CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    );
#define CabCreateCabinetA(p,f,d,t,s) CabCreateCabinetByIndexA(p,f,d,t,s,1)

CCABHANDLE
CabCreateCabinetByIndexW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      PCABGETTEMPFILEW CabGetTempFile, // OPTIONAL
    IN      LONG MaxFileSize,
    IN      INT InitialIndex
    );
#define CabCreateCabinetW(p,f,d,t,s) CabCreateCabinetByIndexW(p,f,d,t,s,1)

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    );

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetA(h)         CabFlushAndCloseCabinetExA(h,NULL,NULL,NULL,NULL)

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetW(h)         CabFlushAndCloseCabinetExW(h,NULL,NULL,NULL,NULL)

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    );

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    );

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

#define CabExtractAllFilesA(h,p) CabExtractAllFilesExA(h,p,NULL)

BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

#define CabExtractAllFilesW(h,p) CabExtractAllFilesExW(h,p,NULL)

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    );

//
// Macros
//

#ifdef UNICODE

#define CABGETCABINETNAMES          CABGETCABINETNAMESW
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESW
#define CABNOTIFICATION             CABNOTIFICATIONW
#define PCABNOTIFICATION            PCABNOTIFICATIONW
#define CABGETTEMPFILE              CABGETTEMPFILEW
#define PCABGETTEMPFILE             PCABGETTEMPFILEW
#define CabCreateCabinet            CabCreateCabinetW
#define CabCreateCabinetByIndex     CabCreateCabinetByIndexW
#define CabCreateCabinetEx          CabCreateCabinetExW
#define CabAddFileToCabinet         CabAddFileToCabinetW
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetW
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExW
#define CabOpenCabinet              CabOpenCabinetW
#define CabExtractAllFilesEx        CabExtractAllFilesExW
#define CabExtractAllFiles          CabExtractAllFilesW
#define CabCloseCabinet             CabCloseCabinetW

#else

#define CABGETCABINETNAMES          CABGETCABINETNAMESA
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESA
#define CABNOTIFICATION             CABNOTIFICATIONA
#define PCABNOTIFICATION            PCABNOTIFICATIONA
#define CABGETTEMPFILE              CABGETTEMPFILEA
#define PCABGETTEMPFILE             PCABGETTEMPFILEA
#define CabCreateCabinet            CabCreateCabinetA
#define CabCreateCabinetByIndex     CabCreateCabinetByIndexA
#define CabCreateCabinetEx          CabCreateCabinetExA
#define CabAddFileToCabinet         CabAddFileToCabinetA
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetA
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExA
#define CabOpenCabinet              CabOpenCabinetA
#define CabExtractAllFilesEx        CabExtractAllFilesExA
#define CabExtractAllFiles          CabExtractAllFilesA
#define CabCloseCabinet             CabCloseCabinetA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\blobs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    blobs.h

Abstract:

    Declares the interface functions to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef enum {
    BDT_NONE        = 0,
    BDT_SZW,
    BDT_SZA,
    BDT_MULTISZW,
    BDT_MULTISZA,
    BDT_DWORD,
    BDT_QWORD,
    BDT_BINARY,
    BDT_LAST
} BLOB_DATA_TYPE;

typedef enum {
    BF_RECORDDATATYPE   = 0x0001,
    BF_RECORDDATASIZE   = 0x0002,
    BF_UNICODESTRINGS   = 0x0004,
} BLOB_FLAGS;

typedef struct {
    PBYTE       Data;
    DWORD       End;
    DWORD       AllocSize;
    DWORD       GrowSize;
    DWORD       Index;
    DWORD       Flags;
    DWORD       UserIndex;
} OURBLOB, *POURBLOB;

typedef struct {
    DWORD       Signature;
    POURBLOB*   Blobs;
    DWORD       BlobsCount;
    DWORD       BlobsAllocated;
    DWORD       BlobsGrowCount;
} BLOBS, *PBLOBS;


typedef struct {
    POURBLOB    CurrentBlob;
    PBLOBS      Array;
    DWORD       Index;
} BLOB_ENUM, *PBLOB_ENUM;


//
// Macros
//

#define OURBLOB_INIT    { NULL, 0, 0, 0, 0, 0, 0 }
#define BLOBS_INIT      { 0, NULL, 0, 0, 0 }


//
// Blob APIs
//

__inline
BOOL
BlobRecordsDataType (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATATYPE;
}

__inline
BOOL
BlobRecordsDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_RECORDDATASIZE;
}

__inline
BOOL
BlobRecordsUnicodeStrings (
    IN      POURBLOB Blob
    )
{
    return Blob->Flags & BF_UNICODESTRINGS;
}

__inline
BOOL
BlobIsEOF (
    IN      POURBLOB Blob
    )
{
    return !Blob->Data || Blob->Index == Blob->End;
}

__inline
PBYTE
BlobGetPointer (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->Index : NULL;
}

__inline
PBYTE
BlobGetEOF (
    IN      POURBLOB Blob
    )
{
    return Blob->Data ? Blob->Data + Blob->End : NULL;
}

__inline
DWORD
BlobGetIndex (
    IN      POURBLOB Blob
    )
{
    return Blob->Index;
}


__inline
DWORD
BlobGetDataSize (
    IN      POURBLOB Blob
    )
{
    return Blob->End;
}

POURBLOB
BlobCreate (
    VOID
    );

POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    );

VOID
BlobClear (
    IN OUT  POURBLOB Blob
    );

VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    );

BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    );

DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    );

BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    );

PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    );

BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    );

BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    );

BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    );

BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    );

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    );

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    );

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    );

BOOL
BlobWriteBinary (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size
    );

BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool
    );

BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    );

BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    );

//
// Blob Array APIs
//

__inline
DWORD
BlobsGetCount (
    IN      PBLOBS BlobsArray
    )
{
    return BlobsArray->BlobsCount;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    );


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    );

BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    );

BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    );

BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    );

BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    );

//
// Macros
//

#ifdef UNICODE

#define BlobWriteString         BlobWriteStringW
#define BlobReadString          BlobReadStringW
#define BlobWriteMultiSz        BlobWriteMultiSzW
#define BlobReadMultiSz         BlobReadMultiSzW

#else

#define BlobWriteString         BlobWriteStringA
#define BlobReadString          BlobReadStringA
#define BlobWriteMultiSz        BlobWriteMultiSzA
#define BlobReadMultiSz         BlobReadMultiSzA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\icons\icons.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icons.c

Abstract:

    Implements a set of routines for handling icons in ICO, PE and NE files

Author:

    Calin Negreanu (calinn) 16-Jum-2000

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_ICONS   "Icons"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
IcoReleaseResourceIdA (
    PCSTR ResourceId
    )
/*++

Routine Description:

  IcoReleaseResourceId will either do nothing if the resource ID has the high WORD 0 or will
  release the string from the paths pool.

Arguments:

  ResourceId - Specifies the resource ID to be released.

Return value:

  None

--*/
{
    if ((ULONG_PTR) ResourceId > 0xffff) {
        FreePathStringA (ResourceId);
    }
}

VOID
IcoReleaseResourceIdW (
    PCWSTR ResourceId
    )
/*++

Routine Description:

  IcoReleaseResourceId will either do nothing if the resource ID has the high WORD 0 or will
  release the string from the paths pool.

Arguments:

  ResourceId - Specifies the resource ID to be released.

Return value:

  None

--*/
{
    if ((ULONG_PTR) ResourceId > 0xffff) {
        FreePathStringW (ResourceId);
    }
}

VOID
IcoReleaseIconGroup (
    IN      PICON_GROUP IconGroup
    )
/*++

Routine Description:

  IcoReleaseIconGroup releases a previously allocated icon group.

Arguments:

  IconGroup - Specifies the icon group to be released.

Return value:

  None

--*/
{
    if (IconGroup && IconGroup->Pool) {
        PmEmptyPool (IconGroup->Pool);
        PmDestroyPool (IconGroup->Pool);
    }
}

VOID
IcoReleaseIconSGroup (
    IN OUT  PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoReleaseIconSGroup releases a previously allocated serialized icon group.

Arguments:

  IconSGroup - Specifies the serialized icon group to be released.

Return value:

  None

--*/
{
    if (IconSGroup->DataSize && IconSGroup->Data) {
        MemFree (g_hHeap, 0, IconSGroup->Data);
    }
    ZeroMemory (IconSGroup, sizeof (ICON_SGROUP));
}

BOOL
IcoSerializeIconGroup (
    IN      PICON_GROUP IconGroup,
    OUT     PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoSerializeIconGroup transforms a ICON_GROUP structure into a ICON_SGROUP structure.

Arguments:

  IconGroup - Specifies the icon group to be serialized.

Return value:

  None

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    DWORD iconsCount;
    DWORD index;
    DWORD size;
    PICON_IMAGE iconImage;

    if (IconGroup == NULL) {
        return FALSE;
    }
    if (IconSGroup == NULL) {
        return FALSE;
    }
    iconsCount = IconGroup->IconsCount;
    GbAppendDword (&buffer, iconsCount);
    size = sizeof (ICON_IMAGE) - sizeof (PBYTE);
    index = 0;
    while (index < iconsCount) {
        iconImage = IconGroup->Icons[index];
        CopyMemory (GbGrow (&buffer, size), iconImage, size);
        CopyMemory (GbGrow (&buffer, iconImage->Size), iconImage->Image, iconImage->Size);
        index ++;
    }
    MYASSERT (buffer.End);
    IconSGroup->DataSize = buffer.End;
    IconSGroup->Data = MemAlloc (g_hHeap, 0, buffer.End);
    CopyMemory (IconSGroup->Data, buffer.Buf, buffer.End);
    GbFree (&buffer);
    return TRUE;
}

PICON_GROUP
IcoDeSerializeIconGroup (
    IN      PICON_SGROUP IconSGroup
    )
/*++

Routine Description:

  IcoDeSerializeIconGroup transforms a ICON_SGROUP structure into a ICON_GROUP structure.

Arguments:

  IconSGroup - Specifies the icon sgroup to be transformed.

Return value:

  None

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PICON_IMAGE iconSImage = NULL;
    PDWORD iconsCount;
    PBYTE currPtr = NULL;
    DWORD i;

    if (IconSGroup == NULL) {
        return NULL;
    }
    currPtr = IconSGroup->Data;
    iconsCount = (PDWORD) currPtr;
    currPtr += sizeof (DWORD);
    iconPool = PmCreateNamedPool ("Icon");
    if (!iconPool) {
        return NULL;
    }
    iconGroupSize = sizeof (ICON_GROUP) + *iconsCount * sizeof (PICON_IMAGE);
    iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
    ZeroMemory (iconGroup, iconGroupSize);
    iconGroup->Pool = iconPool;
    iconGroup->IconsCount = (WORD) (*iconsCount);
    for (i = 0; i < *iconsCount; i ++) {
        iconSImage = (PICON_IMAGE) currPtr;
        currPtr += (sizeof (ICON_IMAGE) - sizeof (PBYTE));
        iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
        ZeroMemory (iconImage, sizeof (ICON_IMAGE));
        iconImage->Width = iconSImage->Width;
        iconImage->Height = iconSImage->Height;
        iconImage->ColorCount = iconSImage->ColorCount;
        iconImage->Planes = iconSImage->Planes;
        iconImage->BitCount = iconSImage->BitCount;
        iconImage->Size = iconSImage->Size;
        iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
        CopyMemory (iconImage->Image, currPtr, iconImage->Size);
        currPtr += iconImage->Size;
        iconGroup->Icons [i] = iconImage;
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileEx (
    IN      HANDLE IcoFileHandle
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFileEx extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.
  IcoFileHandle - Specifies the handle to the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    LONGLONG fileSize;
    DWORD fileOffset;
    ICONDIRBASE iconDirBase;
    PICONDIR iconDir = NULL;
    DWORD iconDirSize = 0;
    PICONDIRENTRY iconDirEntry;
    DWORD i;
    BOOL result = FALSE;

    __try {
        fileSize = GetFileSize (IcoFileHandle, NULL);
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        if (!BfReadFile (IcoFileHandle, (PBYTE)(&iconDirBase), sizeof (ICONDIRBASE))) {
            __leave;
        }
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        iconDirSize = sizeof (ICONDIRBASE) + iconDirBase.Count * sizeof (ICONDIRENTRY);
        // validation
        if (iconDirBase.Count == 0) {
            __leave;
        }
        if (iconDirSize > fileSize) {
            __leave;
        }
        iconDir = (PICONDIR) MemAlloc (g_hHeap, 0, iconDirSize);
        if (!BfReadFile (IcoFileHandle, (PBYTE)iconDir, iconDirSize)) {
            __leave;
        }
        // validation
        for (i = 0; i < iconDirBase.Count; i ++) {
            iconDirEntry = &iconDir->Entries[i];
            fileOffset = iconDirEntry->ImageOffset & 0x0fffffff;
            if (fileOffset > fileSize) {
                __leave;
            }
            if (iconDirEntry->Width == 0) {
                __leave;
            }
            if (iconDirEntry->Height == 0) {
                __leave;
            }
            if (iconDirEntry->BytesInRes == 0) {
                __leave;
            }
        }
        if (iconDirEntry->BytesInRes + fileOffset != fileSize) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }
        iconGroupSize = sizeof (ICON_GROUP) + iconDirBase.Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = iconDirBase.Count;
        for (i = 0; i < iconDirBase.Count; i ++) {
            iconDirEntry = &iconDir->Entries[i];
            fileOffset = iconDirEntry->ImageOffset & 0x0fffffff;
            if (!BfSetFilePointer (IcoFileHandle, fileOffset)) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            if (!BfReadFile (IcoFileHandle, iconImage->Image, iconImage->Size)) {
                __leave;
            }
            iconGroup->Icons [i] = iconImage;
        }
        result = TRUE;
    }
    __finally {
        if (iconDir) {
            MemFree (g_hHeap, 0, iconDir);
            iconDir = NULL;
        }
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
        BfSetFilePointer (IcoFileHandle, 0);
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileA (
    IN      PCSTR IcoFile
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFile extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE icoFileHandle;
    PICON_GROUP result = NULL;

    icoFileHandle = BfOpenReadFileA (IcoFile);
    if (!icoFileHandle) {
        return NULL;
    }
    result = IcoExtractIconGroupFromIcoFileEx (icoFileHandle);
    CloseHandle (icoFileHandle);
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromIcoFileW (
    IN      PCWSTR IcoFile
    )
/*++

Routine Description:

  IcoExtractIconGroupFromIcoFile extracts the icon group from an ICO file.

Arguments:

  IcoFile - Specifies the name of the ICO file to be processed.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE icoFileHandle;
    PICON_GROUP result = NULL;

    icoFileHandle = BfOpenReadFileW (IcoFile);
    if (!icoFileHandle) {
        return NULL;
    }
    result = IcoExtractIconGroupFromIcoFileEx (icoFileHandle);
    CloseHandle (icoFileHandle);
    return result;
}

BOOL
IcoWriteIconGroupToIcoFileEx (
    IN      HANDLE IcoFileHandle,
    IN      PICON_GROUP IconGroup
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFileEx writes an icon group to an ICO file. The file has to exist and it's
  content will be overwritten.

Arguments:

  IcoFileHandle - Specifies the handle of the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    PICONDIR iconDir = NULL;
    DWORD iconDirSize = 0;
    DWORD elapsedSize = 0;
    WORD i;
    BOOL result = FALSE;

    __try {
        if (!BfSetFilePointer (IcoFileHandle, 0)) {
            __leave;
        }
        iconDirSize = sizeof (ICONDIRBASE) + IconGroup->IconsCount * sizeof (ICONDIRENTRY);
        iconDir = (PICONDIR) MemAlloc (g_hHeap, 0, iconDirSize);
        ZeroMemory (iconDir, iconDirSize);
        iconDir->Type = 1;
        iconDir->Count = IconGroup->IconsCount;
        elapsedSize = iconDirSize;
        for (i = 0; i < IconGroup->IconsCount; i ++) {
            iconDir->Entries[i].Width = (IconGroup->Icons [i])->Width;
            iconDir->Entries[i].Height = (IconGroup->Icons [i])->Height;
            iconDir->Entries[i].ColorCount = (IconGroup->Icons [i])->ColorCount;
            iconDir->Entries[i].Planes = (IconGroup->Icons [i])->Planes;
            iconDir->Entries[i].BitCount = (IconGroup->Icons [i])->BitCount;
            iconDir->Entries[i].BytesInRes = (IconGroup->Icons [i])->Size;
            iconDir->Entries[i].ImageOffset = elapsedSize;
            elapsedSize += (IconGroup->Icons [i])->Size;
        }
        if (!BfWriteFile (IcoFileHandle, (PBYTE)iconDir, iconDirSize)) {
            __leave;
        }
        for (i = 0; i < IconGroup->IconsCount; i ++) {
            if (!BfWriteFile (IcoFileHandle, (IconGroup->Icons [i])->Image, (IconGroup->Icons [i])->Size)) {
                __leave;
            }
        }
        result = TRUE;
    }
    __finally {
    }

    return result;
}

BOOL
IcoWriteIconGroupToIcoFileA (
    IN      PCSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFile writes an icon group to an ICO file. The file is either created if
  does not exist or it is overwritten if OverwriteExisting is TRUE.

Arguments:

  IcoFile - Specifies the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.
  OverwriteExisting - if TRUE and the IcoFile exists, it will be overwritten

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE icoFileHandle;
    BOOL result = FALSE;

    if (DoesFileExistA (IcoFile)) {
        if (!OverwriteExisting) {
            return FALSE;
        }
    }
    icoFileHandle = BfCreateFileA (IcoFile);
    if (!icoFileHandle) {
        return FALSE;
    }
    result = IcoWriteIconGroupToIcoFileEx (icoFileHandle, IconGroup);
    CloseHandle (icoFileHandle);
    if (!result) {
        DeleteFileA (IcoFile);
    }
    return result;
}

BOOL
IcoWriteIconGroupToIcoFileW (
    IN      PCWSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    )
/*++

Routine Description:

  IcoWriteIconGroupToIcoFile writes an icon group to an ICO file. The file is either created if
  does not exist or it is overwritten if OverwriteExisting is TRUE.

Arguments:

  IcoFile - Specifies the ICO file to be processed.
  IconGroup - Specifies the icon group to be written.
  OverwriteExisting - if TRUE and the IcoFile exists, it will be overwritten

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE icoFileHandle;
    BOOL result = FALSE;

    if (DoesFileExistW (IcoFile)) {
        if (!OverwriteExisting) {
            return FALSE;
        }
    }
    icoFileHandle = BfCreateFileW (IcoFile);
    if (!icoFileHandle) {
        return FALSE;
    }
    result = IcoWriteIconGroupToIcoFileEx (icoFileHandle, IconGroup);
    CloseHandle (icoFileHandle);
    if (!result) {
        DeleteFileW (IcoFile);
    }
    return result;
}

BOOL
CALLBACK
pPeEnumIconGroupA (
    HANDLE ModuleHandle,
    PCSTR Type,
    PSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", Name);
    }

    GbMultiSzAppendA (Buf, Num);
    return TRUE;
}

BOOL
CALLBACK
pPeEnumIconGroupW (
    HANDLE ModuleHandle,
    PCWSTR Type,
    PWSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", Name);
    }

    GbMultiSzAppendW (Buf, Num);
    return TRUE;
}

INT
IcoGetIndexFromPeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMA multiSzEnum;
    CHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfA (NumBuf, "#%u", GroupIconId);
        GroupIconId = NumBuf;
    }
    if (EnumResourceNamesA (ModuleHandle, (PCSTR) RT_GROUP_ICON, pPeEnumIconGroupA, (LONG_PTR) (&buffer))) {
        GbMultiSzAppendA (&buffer, "");
        if (EnumFirstMultiSzA (&multiSzEnum, (PCSTR)(buffer.Buf))) {
            do {
                if (StringIMatchA (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzA (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromPeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMW multiSzEnum;
    WCHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfW (NumBuf, L"#%u", GroupIconId);
        GroupIconId = NumBuf;
    }
    if (EnumResourceNamesW (
            ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pPeEnumIconGroupW,
            (LONG_PTR) (&buffer)
            )) {
        GbMultiSzAppendW (&buffer, L"");
        if (EnumFirstMultiSzW (&multiSzEnum, (PCWSTR)(buffer.Buf))) {
            do {
                if (StringIMatchW (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzW (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromPeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoGetIndexFromPeResourceIdExA (moduleHandle, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

INT
IcoGetIndexFromPeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromPeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only PE files.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoGetIndexFromPeResourceIdExW (moduleHandle, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFileEx extracts an icon group from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    HRSRC resourceHandle;
    HGLOBAL resourceBlock;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD groupIconDirCount;
    WORD gap;
    WORD i;
    BOOL result = FALSE;

    __try {
        resourceHandle = FindResourceA (ModuleHandle, GroupIconId, (PCSTR) RT_GROUP_ICON);
        if (!resourceHandle) {
            __leave;
        }

        resourceBlock = LoadResource (ModuleHandle, resourceHandle);
        if (!resourceBlock) {
            __leave;
        }

        groupIconDir = (PGRPICONDIR) LockResource (resourceBlock);
        if (!groupIconDir) {
            __leave;
        }

        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        // First let's do some validation of all the icons from this icon group
        groupIconDirCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceA (ModuleHandle, (PCSTR) (groupIconDir->Entries[i].ID), (PCSTR) RT_ICON);
            if (!resourceHandle) {
                groupIconDirCount --;
                continue;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                groupIconDirCount --;
                continue;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                FreeResource (resourceBlock);
                groupIconDirCount --;
                continue;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                FreeResource (resourceBlock);
                groupIconDirCount --;
                continue;
            }
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDirCount * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDirCount;
        gap = 0;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceA (ModuleHandle, (PCSTR) (groupIconDir->Entries[i].ID), (PCSTR) RT_ICON);
            if (!resourceHandle) {
                gap ++;
                continue;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                gap ++;
                continue;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                FreeResource (resourceBlock);
                gap ++;
                continue;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                FreeResource (resourceBlock);
                gap ++;
                continue;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i - gap] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromPeResourceIdExA (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFileEx extracts an icon group from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    HRSRC resourceHandle;
    HGLOBAL resourceBlock;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        resourceHandle = FindResourceW (ModuleHandle, GroupIconId, (PCWSTR) RT_GROUP_ICON);
        if (!resourceHandle) {
            __leave;
        }

        resourceBlock = LoadResource (ModuleHandle, resourceHandle);
        if (!resourceBlock) {
            __leave;
        }

        groupIconDir = (PGRPICONDIR) LockResource (resourceBlock);
        if (!groupIconDir) {
            __leave;
        }

        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceHandle = FindResourceW (ModuleHandle, (PCWSTR) (groupIconDir->Entries[i].ID), (PCWSTR) RT_ICON);
            if (!resourceHandle) {
                __leave;
            }
            resourceBlock = LoadResource (ModuleHandle, resourceHandle);
            if (!resourceBlock) {
                __leave;
            }
            resourceData = (PBYTE) LockResource (resourceBlock);
            if (!resourceData) {
                __leave;
            }
            resourceSize = SizeofResource (ModuleHandle, resourceHandle);
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromPeResourceIdExW (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromPeFileExA (moduleHandle, GroupIconId, Index);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromPeFileExW (moduleHandle, GroupIconId, Index);
        FreeLibrary (moduleHandle);
    }
    return result;
}

VOID
IcoAbortPeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortPeEnumIconGroup terminates the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        FreeLibrary (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortPeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortPeEnumIconGroup terminates the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        FreeLibrary (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
}

BOOL
pEnumFirstIconGroupInPeFileExA (
    IN OUT  PICON_ENUMA IconEnum
    )
{
    BOOL result = FALSE;

    if (EnumResourceNamesA (
            IconEnum->ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pPeEnumIconGroupA,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendA (&IconEnum->Buffer, "");
        if (EnumFirstMultiSzA (&IconEnum->MultiSzEnum, (PCSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
pEnumFirstIconGroupInPeFileExW (
    IN OUT  PICON_ENUMW IconEnum
    )
{
    BOOL result = FALSE;

    if (EnumResourceNamesW (
            IconEnum->ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pPeEnumIconGroupW,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendW (&IconEnum->Buffer, L"");
        if (EnumFirstMultiSzW (&IconEnum->MultiSzEnum, (PCWSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFileEx starts the icon group enumeration from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFileEx starts the icon group enumeration from a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFile starts the icon group enumeration from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInPeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInPeFile starts the icon group enumeration from a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInPeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInPeFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInPeFile continues the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzA (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInPeFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInPeFile continues the icon group enumeration from a PE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzW (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortPeEnumIconGroupW (IconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromPeFileEx extracts an icon group from a PE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMA iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInPeFileExA (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInPeFileA (&iconEnum));
        IcoAbortPeEnumIconGroupA (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromPeFileEx extracts an icon group from a PE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMW iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInPeFileExW (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInPeFileW (&iconEnum));
        IcoAbortPeEnumIconGroupW (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file
  using the Index

Arguments:

  ModuleName - Specifies the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromPeFileExA (moduleHandle, Index, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromPeFile extracts an icon group from a PE file
  using the Index

Arguments:

  ModuleName - Specifies the PE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromPeFileExW (moduleHandle, Index, GroupIconId);
        FreeLibrary (moduleHandle);
    }
    return result;
}

WORD
pGetAvailableResourceA (
    IN      HANDLE ModuleHandle,
    IN      WORD StartIndex,
    IN      PCSTR ResourceType
    )
{
    WORD lastIndex = StartIndex;
    HRSRC resourceHandle;
    BOOL result = FALSE;

    if (lastIndex == 0) {
        lastIndex ++;
    }

    do {
        resourceHandle = FindResourceA (ModuleHandle, MAKEINTRESOURCEA (lastIndex), ResourceType);
        if (!resourceHandle) {
            break;
        }
        lastIndex ++;
        if (lastIndex == 0) {
            break;
        }
    } while (TRUE);

    return lastIndex;
}

WORD
pGetAvailableResourceW (
    IN      HANDLE ModuleHandle,
    IN      WORD StartIndex,
    IN      PCWSTR ResourceType
    )
{
    WORD lastIndex = StartIndex;
    HRSRC resourceHandle;
    BOOL result = FALSE;

    if (lastIndex == 0) {
        lastIndex ++;
    }

    do {
        resourceHandle = FindResourceW (ModuleHandle, MAKEINTRESOURCEW (lastIndex), ResourceType);
        if (!resourceHandle) {
            break;
        }
        lastIndex ++;
        if (lastIndex == 0) {
            break;
        }
    } while (TRUE);

    return lastIndex;
}

BOOL
IcoWriteIconGroupToPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId       OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFileEx writes an icon group resource to a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  UpdateHandle - Specifies the resource update handle (returned by BeginUpdateResource).
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    WORD lastIndex = 0;
    WORD lastIconIndex = 0;
    PGRPICONDIR groupIconDir = NULL;
    DWORD groupIconDirSize;
    WORD i;
    BOOL result = FALSE;

    __try {
        lastIndex = pGetAvailableResourceA (ModuleHandle, lastIndex, (PCSTR) RT_GROUP_ICON);
        if (lastIndex == 0) {
            // no more room for resources
            __leave;
        }
        groupIconDirSize = sizeof (GRPICONDIRBASE) + IconGroup->IconsCount * sizeof (GRPICONDIRENTRY);
        groupIconDir = MemAlloc (g_hHeap, 0, groupIconDirSize);
        ZeroMemory (groupIconDir, groupIconDirSize);
        groupIconDir->Type = 1;
        groupIconDir->Count = IconGroup->IconsCount;
        for (i = 0; i < groupIconDir->Count; i ++) {
            groupIconDir->Entries[i].Width = IconGroup->Icons[i]->Width;
            groupIconDir->Entries[i].Height = IconGroup->Icons[i]->Height;
            groupIconDir->Entries[i].ColorCount = IconGroup->Icons[i]->ColorCount;
            groupIconDir->Entries[i].Planes = IconGroup->Icons[i]->Planes;
            groupIconDir->Entries[i].BitCount = IconGroup->Icons[i]->BitCount;
            groupIconDir->Entries[i].BytesInRes = IconGroup->Icons[i]->Size;
            lastIconIndex = pGetAvailableResourceA (ModuleHandle, lastIconIndex, (PCSTR) RT_ICON);
            groupIconDir->Entries[i].ID = lastIconIndex;
            lastIconIndex ++;
        }
        for (i = 0; i < groupIconDir->Count; i ++) {
            if (!UpdateResourceA (
                    UpdateHandle,
                    (PCSTR) RT_ICON,
                    MAKEINTRESOURCEA (groupIconDir->Entries[i].ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    IconGroup->Icons[i]->Image,
                    IconGroup->Icons[i]->Size
                    )) {
                __leave;
            }
        }
        if (!UpdateResourceA (
                UpdateHandle,
                (PCSTR) RT_GROUP_ICON,
                MAKEINTRESOURCEA (lastIndex),
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                groupIconDir,
                groupIconDirSize
                )) {
            __leave;
        }
        if (ResourceId) {
            *ResourceId = MAKEINTRESOURCEA (lastIndex);
        }
        result = TRUE;
    }
    __finally {
        if (groupIconDir) {
            MemFree (g_hHeap, 0, groupIconDir);
        }
    }
    return result;
}


BOOL
IcoWriteIconGroupToPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId      OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFileEx writes an icon group resource to a PE file.

Arguments:

  ModuleHandle - Specifies the handle to the PE file to be processed.
  UpdateHandle - Specifies the resource update handle (returned by BeginUpdateResource).
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    WORD lastIndex = 0;
    WORD lastIconIndex = 0;
    PGRPICONDIR groupIconDir = NULL;
    DWORD groupIconDirSize;
    WORD i;
    BOOL result = FALSE;

    __try {
        lastIndex = pGetAvailableResourceW (ModuleHandle, lastIndex, (PCWSTR) RT_GROUP_ICON);
        if (lastIndex == 0) {
            // no more room for resources
            __leave;
        }
        groupIconDirSize = sizeof (GRPICONDIRBASE) + IconGroup->IconsCount * sizeof (GRPICONDIRENTRY);
        groupIconDir = MemAlloc (g_hHeap, 0, groupIconDirSize);
        ZeroMemory (groupIconDir, groupIconDirSize);
        groupIconDir->Type = 1;
        groupIconDir->Count = IconGroup->IconsCount;
        for (i = 0; i < groupIconDir->Count; i ++) {
            groupIconDir->Entries[i].Width = IconGroup->Icons[i]->Width;
            groupIconDir->Entries[i].Height = IconGroup->Icons[i]->Height;
            groupIconDir->Entries[i].ColorCount = IconGroup->Icons[i]->ColorCount;
            groupIconDir->Entries[i].Planes = IconGroup->Icons[i]->Planes;
            groupIconDir->Entries[i].BitCount = IconGroup->Icons[i]->BitCount;
            groupIconDir->Entries[i].BytesInRes = IconGroup->Icons[i]->Size;
            lastIconIndex = pGetAvailableResourceW (ModuleHandle, lastIconIndex, (PCWSTR) RT_ICON);
            groupIconDir->Entries[i].ID = lastIconIndex;
            lastIconIndex ++;
        }
        for (i = 0; i < groupIconDir->Count; i ++) {
            if (!UpdateResourceW (
                    UpdateHandle,
                    (PCWSTR) RT_ICON,
                    MAKEINTRESOURCEW (groupIconDir->Entries[i].ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    IconGroup->Icons[i]->Image,
                    IconGroup->Icons[i]->Size
                    )) {
                __leave;
            }
        }
        if (!UpdateResourceW (
                UpdateHandle,
                (PCWSTR) RT_GROUP_ICON,
                MAKEINTRESOURCEW (lastIndex),
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                groupIconDir,
                groupIconDirSize
                )) {
            __leave;
        }
        if (ResourceId) {
            *ResourceId = MAKEINTRESOURCEW (lastIndex);
        }
        result = TRUE;
    }
    __finally {
        if (groupIconDir) {
            MemFree (g_hHeap, 0, groupIconDir);
        }
    }
    return result;
}

BOOL
IcoWriteIconGroupToPeFileA (
    IN      PCSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId,      OPTIONAL
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFile writes an icon group resource to a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.
  Index - Receives the index of the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE moduleHandle = NULL;
    HANDLE updateHandle = NULL;
    PCSTR resourceId;
    BOOL result = FALSE;

    updateHandle = BeginUpdateResourceA (ModuleName, FALSE);
    if (updateHandle) {
        //printf ("BeginUpdateResource\n");
        moduleHandle = LoadLibraryExA (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (moduleHandle) {
            //printf ("IcoWriteIconGroupToPeFileExA\n");
            result = IcoWriteIconGroupToPeFileExA (moduleHandle, updateHandle, IconGroup, &resourceId);
            FreeLibrary (moduleHandle);
        }
        if (result) {
            //printf ("EndUpdateResource\n");
            result = EndUpdateResource (updateHandle, FALSE);
            if (result) {
                if (ResourceId) {
                    *ResourceId = resourceId;
                } else {
                    IcoReleaseResourceIdA (resourceId);
                }
                if (Index) {
                    *Index = IcoGetIndexFromPeResourceIdA (ModuleName, resourceId);
                }
            }
        } else {
            EndUpdateResource (updateHandle, TRUE);
        }
    }
    //printf ("return\n");
    return result;
}

BOOL
IcoWriteIconGroupToPeFileW (
    IN      PCWSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId,     OPTIONAL
    OUT     PINT Index              OPTIONAL
    )
/*++

Routine Description:

  IcoWriteIconGroupToPeFile writes an icon group resource to a PE file.

Arguments:

  ModuleName - Specifies the PE file to be processed.
  IconGroup - Specifies the icon group to be inserted.
  ResourceId - Receives the resource ID allocated for the newly inserted icon group.
  Index - Receives the index of the newly inserted icon group.

Return value:

  TRUE if successfull, FALSE otherwise.

--*/
{
    HANDLE moduleHandle = NULL;
    HANDLE updateHandle = NULL;
    PCWSTR resourceId;
    BOOL result = FALSE;

    updateHandle = BeginUpdateResourceW (ModuleName, FALSE);
    if (updateHandle) {
        moduleHandle = LoadLibraryExW (ModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (moduleHandle) {
            result = IcoWriteIconGroupToPeFileExW (moduleHandle, updateHandle, IconGroup, &resourceId);
            FreeLibrary (moduleHandle);
        }
        if (result) {
            result = EndUpdateResource (updateHandle, FALSE);
            if (result) {
                if (ResourceId) {
                    *ResourceId = resourceId;
                } else {
                    IcoReleaseResourceIdW (resourceId);
                }
                if (Index) {
                    *Index = IcoGetIndexFromPeResourceIdW (ModuleName, resourceId);
                }
            }
        } else {
            EndUpdateResource (updateHandle, TRUE);
        }
    }
    return result;
}

BOOL
pNeEnumIconGroupA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", Name);
    }

    GbMultiSzAppendA (Buf, Num);
    return TRUE;
}

BOOL
pNeEnumIconGroupW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name,
    IN      LPARAM lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    Buf = (PGROWBUFFER) lParam;

    if ((ULONG_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", Name);
    }

    GbMultiSzAppendW (Buf, Num);
    return TRUE;
}

INT
IcoGetIndexFromNeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMA multiSzEnum;
    CHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfA (NumBuf, "#%u", GroupIconId);
        GroupIconId = NumBuf;
    }

    if (NeEnumResourceNamesA (
            ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pNeEnumIconGroupA,
            (LONG_PTR) (&buffer)
            )) {

        GbMultiSzAppendA (&buffer, "");
        if (EnumFirstMultiSzA (&multiSzEnum, (PCSTR)(buffer.Buf))) {
            do {
                if (StringIMatchA (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzA (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromNeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceIdEx returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    MULTISZ_ENUMW multiSzEnum;
    WCHAR NumBuf[32];
    INT index = 0;
    BOOL result = FALSE;

    if ((ULONG_PTR) GroupIconId < 0x10000) {
        wsprintfW (NumBuf, L"#%u", GroupIconId);
        GroupIconId = NumBuf;
    }

    if (NeEnumResourceNamesW (
            ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pNeEnumIconGroupW,
            (LONG_PTR) (&buffer)
            )) {

        GbMultiSzAppendW (&buffer, L"");
        if (EnumFirstMultiSzW (&multiSzEnum, (PCWSTR)(buffer.Buf))) {
            do {
                if (StringIMatchW (multiSzEnum.CurrentString, GroupIconId)) {
                    result = TRUE;
                    break;
                }
                index ++;
            } while (EnumNextMultiSzW (&multiSzEnum));
        }
    }
    if (!result) {
        index = -1;
    }
    return index;
}

INT
IcoGetIndexFromNeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoGetIndexFromNeResourceIdExA (moduleHandle, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

INT
IcoGetIndexFromNeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    )
/*++

Routine Description:

  IcoGetIndexFromNeResourceId returns the index of an icon group resource given the
  resource ID. It knows how to process only NE files.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID.

Return value:

  The index of GroupIconId resource if existent, -1 if not.

--*/
{
    HANDLE moduleHandle;
    INT result = -1;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoGetIndexFromNeResourceIdExW (moduleHandle, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFileEx extracts an icon group from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        groupIconDir = (PGRPICONDIR) NeFindResourceExA (ModuleHandle, (PCSTR) RT_GROUP_ICON, GroupIconId);
        if (!groupIconDir) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceData = NeFindResourceExA (
                                ModuleHandle,
                                (PCSTR) RT_ICON,
                                (PCSTR) groupIconDir->Entries[i].ID
                                );

            if (!resourceData) {
                __leave;
            }

            resourceSize = NeSizeofResourceA (
                                ModuleHandle,
                                (PCSTR) RT_ICON,
                                (PCSTR) groupIconDir->Entries[i].ID
                                );
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromNeResourceIdExA (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFileEx extracts an icon group from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PMHANDLE iconPool = NULL;
    PICON_GROUP iconGroup = NULL;
    DWORD iconGroupSize = 0;
    PICON_IMAGE iconImage = NULL;
    PGRPICONDIRENTRY iconDirEntry;
    PBYTE resourceData;
    DWORD resourceSize;
    PGRPICONDIR groupIconDir;
    WORD i;
    BOOL result = FALSE;

    __try {
        groupIconDir = (PGRPICONDIR) NeFindResourceExW (ModuleHandle, (PCWSTR) RT_GROUP_ICON, GroupIconId);
        if (!groupIconDir) {
            __leave;
        }
        iconPool = PmCreateNamedPool ("Icon");
        if (!iconPool) {
            __leave;
        }

        iconGroupSize = sizeof (ICON_GROUP) + groupIconDir->Count * sizeof (PICON_IMAGE);
        iconGroup = (PICON_GROUP) PmGetAlignedMemory (iconPool, iconGroupSize);
        ZeroMemory (iconGroup, iconGroupSize);
        iconGroup->Pool = iconPool;
        iconGroup->IconsCount = groupIconDir->Count;
        for (i = 0; i < groupIconDir->Count; i ++) {
            resourceData = NeFindResourceExW (
                                ModuleHandle,
                                (PCWSTR) RT_ICON,
                                (PCWSTR) groupIconDir->Entries[i].ID
                                );

            if (!resourceData) {
                __leave;
            }

            resourceSize = NeSizeofResourceW (
                                ModuleHandle,
                                (PCWSTR) RT_ICON,
                                (PCWSTR) groupIconDir->Entries[i].ID
                                );
            if (!resourceSize) {
                __leave;
            }
            iconImage = (PICON_IMAGE) PmGetAlignedMemory (iconPool, sizeof (ICON_IMAGE));
            ZeroMemory (iconImage, sizeof (ICON_IMAGE));
            iconDirEntry = &groupIconDir->Entries[i];
            iconImage->Width = iconDirEntry->Width;
            iconImage->Height = iconDirEntry->Height;
            iconImage->ColorCount = iconDirEntry->ColorCount;
            iconImage->Planes = iconDirEntry->Planes;
            iconImage->BitCount = iconDirEntry->BitCount;
            iconImage->Size = iconDirEntry->BytesInRes;
            if (iconImage->Size > resourceSize) {
                iconImage->Size = resourceSize;
            }
            iconImage->Id = iconDirEntry->ID;
            iconImage->Image = PmGetAlignedMemory (iconPool, iconImage->Size);
            CopyMemory (iconImage->Image, resourceData, iconImage->Size);
            iconGroup->Icons [i] = iconImage;
        }
        if (Index) {
            *Index = IcoGetIndexFromNeResourceIdExW (ModuleHandle, GroupIconId);
        }
        result = TRUE;
    }
    __finally {
        if (!result) {
            if (iconPool) {
                PmEmptyPool (iconPool);
                PmDestroyPool (iconPool);
                iconPool = NULL;
            }
            iconGroup = NULL;
        }
    }
    return iconGroup;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromNeFileExA (moduleHandle, GroupIconId, Index);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupFromNeFileExW (moduleHandle, GroupIconId, Index);
        NeCloseFile (moduleHandle);
    }
    return result;
}

VOID
IcoAbortNeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortNeEnumIconGroup terminates the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        NeCloseFile (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortNeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortNeEnumIconGroup terminates the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        NeCloseFile (IconEnum->ModuleHandle);
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
}

BOOL
pEnumFirstIconGroupInNeFileExA (
    IN OUT  PICON_ENUMA IconEnum
    )
{
    BOOL result = FALSE;

    if (NeEnumResourceNamesA (
            IconEnum->ModuleHandle,
            (PCSTR) RT_GROUP_ICON,
            pNeEnumIconGroupA,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {
        GbMultiSzAppendA (&IconEnum->Buffer, "");
        if (EnumFirstMultiSzA (&IconEnum->MultiSzEnum, (PCSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExA (
                                        IconEnum->ModuleHandle,
                                        IconEnum->MultiSzEnum.CurrentString,
                                        NULL
                                        );
            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
pEnumFirstIconGroupInNeFileExW (
    IN OUT  PICON_ENUMW IconEnum
    )
{
    BOOL result = FALSE;

    if (NeEnumResourceNamesW (
            IconEnum->ModuleHandle,
            (PCWSTR) RT_GROUP_ICON,
            pNeEnumIconGroupW,
            (LONG_PTR) (&IconEnum->Buffer)
            )) {

        GbMultiSzAppendW (&IconEnum->Buffer, L"");
        if (EnumFirstMultiSzW (&IconEnum->MultiSzEnum, (PCWSTR)(IconEnum->Buffer.Buf))) {
            IconEnum->IconGroup = IcoExtractIconGroupFromPeFileExW (
                                        IconEnum->ModuleHandle,
                                        IconEnum->MultiSzEnum.CurrentString,
                                        NULL
                                        );

            result = (IconEnum->IconGroup != NULL);
            if (result) {
                IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            }
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFileEx starts the icon group enumeration from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFileEx starts the icon group enumeration from a NE file.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = FALSE;
    IconEnum->ModuleHandle = ModuleHandle;
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFile starts the icon group enumeration from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = NeOpenFileA (ModuleName);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumFirstIconGroupInNeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInNeFile starts the icon group enumeration from a NE file.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    IconEnum->FreeHandle = TRUE;
    IconEnum->ModuleHandle = NeOpenFileW (ModuleName);
    if (IconEnum->ModuleHandle) {
        result = pEnumFirstIconGroupInNeFileExW (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInNeFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInNeFile continues the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzA (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExA (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringA (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupA (IconEnum);
    }
    return result;
}

BOOL
IcoEnumNextIconGroupInNeFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInNeFile continues the icon group enumeration from a NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    BOOL result = FALSE;

    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
        IconEnum->IconGroup = NULL;
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    if (EnumNextMultiSzW (&IconEnum->MultiSzEnum)) {
        IconEnum->IconGroup = IcoExtractIconGroupFromNeFileExW (IconEnum->ModuleHandle, IconEnum->MultiSzEnum.CurrentString, NULL);
        result = (IconEnum->IconGroup != NULL);
        if (result) {
            IconEnum->ResourceId = DuplicatePathStringW (IconEnum->MultiSzEnum.CurrentString, 0);
            IconEnum->Index ++;
        }
    }
    if (!result) {
        IcoAbortNeEnumIconGroupW (IconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromNeFileEx extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMA iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInNeFileExA (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInNeFileA (&iconEnum));
        IcoAbortNeEnumIconGroupA (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromNeFileEx extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleHandle - Specifies the handle to the NE file to be processed (use NeOpenFile to get it).
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    ICON_ENUMW iconEnum;
    PICON_GROUP result = NULL;

    if (IcoEnumFirstIconGroupInNeFileExW (ModuleHandle, &iconEnum)) {
        do {
            if (iconEnum.Index == Index) {
                result = iconEnum.IconGroup;
                iconEnum.IconGroup = NULL;
                if (GroupIconId) {
                    *GroupIconId = iconEnum.ResourceId;
                    iconEnum.ResourceId = NULL;
                }
                break;
            }
        } while (IcoEnumNextIconGroupInNeFileW (&iconEnum));
        IcoAbortNeEnumIconGroupW (&iconEnum);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileA (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromNeFileExA (moduleHandle, Index, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromNeFile extracts an icon group from a NE file
  using the Index.

Arguments:

  ModuleName - Specifies the NE file to be processed.
  Index - Specifies the index of the icon group to be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    HANDLE moduleHandle;
    PICON_GROUP result = NULL;

    moduleHandle = NeOpenFileW (ModuleName);
    if (moduleHandle) {
        result = IcoExtractIconGroupByIndexFromNeFileExW (moduleHandle, Index, GroupIconId);
        NeCloseFile (moduleHandle);
    }
    return result;
}

VOID
IcoAbortEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoAbortEnumIconGroup terminates the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        if (IconEnum->FileType == ICON_PEFILE) {
            FreeLibrary (IconEnum->ModuleHandle);
        }
        if (IconEnum->FileType == ICON_NEFILE) {
            NeCloseFile (IconEnum->ModuleHandle);
        }
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringA (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

VOID
IcoAbortEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoAbortEnumIconGroup terminates the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies the icon group enumeration structure. It is emptied during this function.

Return value:

  None

--*/
{
    GbFree (&IconEnum->Buffer);
    if (IconEnum->FreeHandle && IconEnum->ModuleHandle) {
        if (IconEnum->FileType == ICON_PEFILE) {
            FreeLibrary (IconEnum->ModuleHandle);
        }
        if (IconEnum->FileType == ICON_NEFILE) {
            NeCloseFile (IconEnum->ModuleHandle);
        }
    }
    if (IconEnum->IconGroup) {
        IcoReleaseIconGroup (IconEnum->IconGroup);
    }
    if (IconEnum->ResourceId) {
        FreePathStringW (IconEnum->ResourceId);
        IconEnum->ResourceId = NULL;
    }
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
}

BOOL
IcoEnumFirstIconGroupInFileA (
    IN      PCSTR FileName,
    OUT     PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInFile starts the icon group enumeration from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the ICO, PE or NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    ZeroMemory (IconEnum, sizeof (ICON_ENUMA));
    if (IcoEnumFirstIconGroupInPeFileA (FileName, IconEnum)) {
        IconEnum->FileType = ICON_PEFILE;
        return TRUE;
    }
    if (IcoEnumFirstIconGroupInNeFileA (FileName, IconEnum)) {
        IconEnum->FileType = ICON_NEFILE;
        return TRUE;
    }
    IconEnum->IconGroup = IcoExtractIconGroupFromIcoFileA (FileName);
    if (IconEnum->IconGroup) {
        IconEnum->FileType = ICON_ICOFILE;
        return TRUE;
    }
    return FALSE;
}

BOOL
IcoEnumFirstIconGroupInFileW (
    IN      PCWSTR FileName,
    OUT     PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumFirstIconGroupInFile starts the icon group enumeration from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the ICO, PE or NE file to be processed.
  IconEnum - Receives the icon group enumeration structure.

Return value:

  TRUE if at least one icon group exists, FALSE otherwise.

--*/
{
    ZeroMemory (IconEnum, sizeof (ICON_ENUMW));
    if (IcoEnumFirstIconGroupInPeFileW (FileName, IconEnum)) {
        IconEnum->FileType = ICON_PEFILE;
        return TRUE;
    }
    if (IcoEnumFirstIconGroupInNeFileW (FileName, IconEnum)) {
        IconEnum->FileType = ICON_NEFILE;
        return TRUE;
    }
    IconEnum->IconGroup = IcoExtractIconGroupFromIcoFileW (FileName);
    if (IconEnum->IconGroup) {
        IconEnum->FileType = ICON_ICOFILE;
        return TRUE;
    }
    return FALSE;
}

BOOL
IcoEnumNextIconGroupInFileA (
    IN OUT  PICON_ENUMA IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInFile continues the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    if (IconEnum->FileType == ICON_ICOFILE) {
        IcoAbortEnumIconGroupA (IconEnum);
        return FALSE;
    }
    if (IconEnum->FileType == ICON_PEFILE) {
        return IcoEnumNextIconGroupInPeFileA (IconEnum);
    }
    if (IconEnum->FileType == ICON_NEFILE) {
        return IcoEnumNextIconGroupInNeFileA (IconEnum);
    }
    return FALSE;
}

BOOL
IcoEnumNextIconGroupInFileW (
    IN OUT  PICON_ENUMW IconEnum
    )
/*++

Routine Description:

  IcoEnumNextIconGroupInFile continues the icon group enumeration from a ICO, PE or NE file.

Arguments:

  IconEnum - Specifies and receives the icon group enumeration structure.

Return value:

  TRUE if one more icon group exists, FALSE otherwise.

--*/
{
    if (IconEnum->FileType == ICON_ICOFILE) {
        IcoAbortEnumIconGroupW (IconEnum);
        return FALSE;
    }
    if (IconEnum->FileType == ICON_PEFILE) {
        return IcoEnumNextIconGroupInPeFileW (IconEnum);
    }
    if (IconEnum->FileType == ICON_NEFILE) {
        return IcoEnumNextIconGroupInNeFileW (IconEnum);
    }
    return FALSE;
}

PICON_GROUP
IcoExtractIconGroupFromFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromFile extracts an icon group from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupFromPeFileA (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupFromNeFileA (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the GroupIconId is zero
    if (GroupIconId == NULL) {
        result = IcoExtractIconGroupFromIcoFileA (ModuleName);
        if (result && Index) {
            *Index = 0;
        }
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupFromFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    )
/*++

Routine Description:

  IcoExtractIconGroupFromFile extracts an icon group from a ICO, PE or NE file.

Arguments:

  ModuleName - Specifies the file to be processed.
  GroupIconId - Specifies the resource ID of the icon group to be extracted.
  Index - Receives the index of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupFromPeFileW (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupFromNeFileW (ModuleName, GroupIconId, Index);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the GroupIconId is zero
    if (GroupIconId == NULL) {
        result = IcoExtractIconGroupFromIcoFileW (ModuleName);
        if (result && Index) {
            *Index = 0;
        }
        return result;
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromFile extracts an icon group from a ICO, PE or NE file
  using the Index.

Arguments:

  ModuleName - Specifies the file to be processed.
  Index - Specifies the index of the icon groupto be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupByIndexFromPeFileA (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupByIndexFromNeFileA (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the Index is zero
    if (Index == 0) {
        result = IcoExtractIconGroupFromIcoFileA (ModuleName);
        if (result && GroupIconId) {
            *GroupIconId = NULL;
        }
        return result;
    }
    return result;
}

PICON_GROUP
IcoExtractIconGroupByIndexFromFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId
    )
/*++

Routine Description:

  IcoExtractIconGroupByIndexFromFile extracts an icon group from a ICO, PE or NE file
  using the Index.

Arguments:

  ModuleName - Specifies the file to be processed.
  Index - Specifies the index of the icon groupto be extracted.
  GroupIconId - Receives the resource ID of the icon group extracted.

Return value:

  An icon group if successfull, NULL otherwise.

--*/
{
    PICON_GROUP result = NULL;

    // assume that this is a PE file
    result = IcoExtractIconGroupByIndexFromPeFileW (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // assume that this is a NE file
    result = IcoExtractIconGroupByIndexFromNeFileW (ModuleName, Index, GroupIconId);
    if (result) {
        return result;
    }
    // finally, assume that this is a ICO file, verify that
    // the Index is zero
    if (Index == 0) {
        result = IcoExtractIconGroupFromIcoFileW (ModuleName);
        if (result && GroupIconId) {
            *GroupIconId = NULL;
        }
        return result;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\basemem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    basemem.h

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.h and allutils.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:


--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

#define INVALID_PTR             ((PVOID)-1)


//
// Fail-proof memory allocators
//

PVOID SafeHeapAlloc (HANDLE g_hHeap, DWORD Flags, SIZE_T Size);
PVOID SafeHeapReAlloc (HANDLE g_hHeap, DWORD Flags, PVOID OldBlock, SIZE_T Size);

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID ReuseAlloc (HANDLE Heap, PVOID OldPtr, DWORD SizeNeeded);
VOID ReuseFree (HANDLE Heap,PVOID Ptr);





#ifdef DEBUG

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(x) DebugHeapCheck(__FILE__,__LINE__,heap)
#define FreeAlloc(ptr) DebugHeapFree(__FILE__,__LINE__,g_hHeap,0,ptr)
#define MemAllocUninit(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,0,size)
#define MemAllocZeroed(size) DebugHeapAlloc(__FILE__,__LINE__,g_hHeap,HEAP_ZERO_MEMORY,size)


LPVOID DebugHeapAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, SIZE_T dwSize);
LPVOID DebugHeapReAlloc (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem, SIZE_T dwSize);
BOOL DebugHeapFree (LPCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);
void DebugHeapCheck (LPCSTR File, DWORD Line, HANDLE hHeap);

VOID DumpHeapStats (VOID);
VOID DumpHeapLeaks (VOID);

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );

#define MemCheckPtr(heap,ptr)       (DebugHeapValidatePtr(heap,ptr,__FILE__,__LINE__) != INVALID_PTR)


#else

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(PVOID)(z))
#define MemCheck(x)
#define FreeAlloc(ptr) HeapFree(g_hHeap,0,(PVOID)(ptr))
#define MemAllocUninit(size) SafeHeapAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size) SafeHeapAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()
#define DumpHeapLeaks()

#define MemCheckPtr(heap,ptr)       (1)

#endif


#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\compress.h ===
//
// Compression stuff
//
typedef enum {
    CompressNone,
    CompressMrci1,
    CompressMrci2,
    CompressMax
} CompressionType;

typedef BOOL(WINAPI COMPRESSNOTIFICATIONA)(
                        IN      PCSTR FileName,
                        IN      LONGLONG FileSize,
                        OUT     PBOOL ExtractFile,
                        IN OUT  PCSTR *NewFileName
                        );
typedef COMPRESSNOTIFICATIONA *PCOMPRESSNOTIFICATIONA;

typedef BOOL(WINAPI COMPRESSNOTIFICATIONW)(
                        IN      PCWSTR FileName,
                        IN      LONGLONG FileSize,
                        OUT     PBOOL ExtractFile,
                        IN OUT  PCWSTR *NewFileName
                        );
typedef COMPRESSNOTIFICATIONW *PCOMPRESSNOTIFICATIONW;

typedef struct {
    HANDLE CurrFileHandle;
    UINT FirstFileIndex;
    UINT CurrFileIndex;
    LONGLONG MaxFileSize;
    LONGLONG CurrFileSize;
    LONGLONG FilesStored;
    PCSTR StorePath;
    PCSTR MainFilePattern;
    PBYTE ReadBuffer;
    PBYTE CompBuffer;
    PBYTE ExtraBuffer;
} COMPRESS_HANDLEA, *PCOMPRESS_HANDLEA;

typedef struct {
    HANDLE CurrFileHandle;
    UINT FirstFileIndex;
    UINT CurrFileIndex;
    LONGLONG MaxFileSize;
    LONGLONG CurrFileSize;
    LONGLONG FilesStored;
    PCWSTR StorePath;
    PCWSTR MainFilePattern;
    PBYTE ReadBuffer;
    PBYTE CompBuffer;
    PBYTE ExtraBuffer;
} COMPRESS_HANDLEW, *PCOMPRESS_HANDLEW;

BOOL
CompressCreateHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressCreateHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressOpenHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressOpenHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressFlushAndCloseHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressFlushAndCloseHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

VOID
CompressCleanupHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

VOID
CompressCleanupHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressAddFileToHandleA (
    IN      PCSTR FileName,
    IN      PCSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    );

BOOL
CompressAddFileToHandleW (
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    );

BOOL
CompressExtractAllFilesA (
    IN      PCSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONA CompressNotification OPTIONAL
    );

BOOL
CompressExtractAllFilesW (
    IN      PCWSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONW CompressNotification OPTIONAL
    );

BOOL
CompressSetErrorMode (
    IN      BOOL ErrorMode
    );

#ifndef UNICODE

#define COMPRESS_HANDLE             COMPRESS_HANDLEA
#define PCOMPRESS_HANDLE            PCOMPRESS_HANDLEA
#define COMPRESSNOTIFICATION        COMPRESSNOTIFICATIONA
#define PCOMPRESSNOTIFICATION       PCOMPRESSNOTIFICATIONA
#define CompressCreateHandle        CompressCreateHandleA
#define CompressOpenHandle          CompressOpenHandleA
#define CompressFlushAndCloseHandle CompressFlushAndCloseHandleA
#define CompressCleanupHandle       CompressCleanupHandleA
#define CompressAddFileToHandle     CompressAddFileToHandleA
#define CompressExtractAllFiles     CompressExtractAllFilesA

#else

#define COMPRESS_HANDLE             COMPRESS_HANDLEW
#define PCOMPRESS_HANDLE            PCOMPRESS_HANDLEW
#define COMPRESSNOTIFICATION        COMPRESSNOTIFICATIONW
#define PCOMPRESSNOTIFICATION       PCOMPRESSNOTIFICATIONW
#define CompressCreateHandle        CompressCreateHandleW
#define CompressOpenHandle          CompressOpenHandleW
#define CompressFlushAndCloseHandle CompressFlushAndCloseHandleW
#define CompressCleanupHandle       CompressCleanupHandleW
#define CompressAddFileToHandle     CompressAddFileToHandleW
#define CompressExtractAllFiles     CompressExtractAllFilesW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\file\tree.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Implements routines that do operations on entire trees

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_TREE        "Tree"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExA (Dir, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileA (e.NativeFullName)) {
                AbortEnumFileInTreeA (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;

    pattern = ObsBuildEncodedObjectStringExW (Dir, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);

            if (!DeleteFileW (e.NativeFullName)) {
                AbortEnumFileInTreeW (&e);
                result = FALSE;
                break;
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeExA (
    IN      PCSTR Dir,
    IN      BOOL RemoveRoot
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PSTR encodedStr;
    PCSTR dirPattern;

    encodedStr = DuplicatePathStringA (Dir, TcharCountA (Dir));
    ObsEncodeStringExA (encodedStr, Dir, "^");
    dirPattern = JoinPathsA (encodedStr, "*");
    FreePathStringA (encodedStr);
    pattern = ObsBuildEncodedObjectStringExA (dirPattern, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryA (e.NativeFullName);
            } else {
                SetFileAttributesA (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileA (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeA (&e);
                break;
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (result) {
        if (RemoveRoot) {
            result = RemoveDirectoryA (Dir);
        }
    }

    ObsFreeA (pattern);
    FreePathStringA (dirPattern);

    return result;
}


BOOL
FiRemoveAllFilesInTreeExW (
    IN      PCWSTR Dir,
    IN      BOOL RemoveRoot
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PWSTR encodedStr;
    PCWSTR dirPattern;

    encodedStr = DuplicatePathStringW (Dir, TcharCountW (Dir));
    ObsEncodeStringExW (encodedStr, Dir, L"^");
    dirPattern = JoinPathsW (encodedStr, L"*");
    FreePathStringW (encodedStr);
    pattern = ObsBuildEncodedObjectStringExW (dirPattern, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, TRUE, FALSE, FALSE, TRUE, FILEENUM_ALL_SUBLEVELS, FALSE, NULL)) {
        do {
            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                result = RemoveDirectoryW (e.NativeFullName);
            } else {
                SetFileAttributesW (e.NativeFullName, FILE_ATTRIBUTE_NORMAL);
                result = DeleteFileW (e.NativeFullName);
            }
            if (!result) {
                AbortEnumFileInTreeW (&e);
                break;
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (result) {
        if (RemoveRoot) {
            result = RemoveDirectoryW (Dir);
        }
    }

    ObsFreeW (pattern);
    FreePathStringW (dirPattern);

    return result;
}


BOOL
FiCopyAllFilesInDirExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PCSTR subPath;
    PCSTR destPath;
    BOOL fileResult;

    pattern = ObsBuildEncodedObjectStringExA (Source, "*", FALSE);

    if (EnumFirstFileInTreeExA (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            subPath = e.NativeFullName;
            subPath = (PCSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsA (Dest, subPath);

            SetFileAttributesA (destPath, FILE_ATTRIBUTE_NORMAL);
            fileResult = CopyFileA (e.NativeFullName, destPath, SkipExisting);
            if (fileResult) {
                fileResult = SetFileAttributesA (destPath, e.Attributes);
            }

            FreePathStringA (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGA ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
FiCopyAllFilesInDirExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PCWSTR subPath;
    PCWSTR destPath;
    BOOL fileResult;

    pattern = ObsBuildEncodedObjectStringExW (Source, L"*", FALSE);

    if (EnumFirstFileInTreeExW (&e, pattern, 0, FALSE, FALSE, TRUE, TRUE, 1, FALSE, NULL)) {
        do {
            subPath = e.NativeFullName;
            subPath = (PCWSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsW (Dest, subPath);

            SetFileAttributesW (destPath, FILE_ATTRIBUTE_NORMAL);
            fileResult = CopyFileW (e.NativeFullName, destPath, SkipExisting);
            if (fileResult) {
                fileResult = SetFileAttributesW (destPath, e.Attributes);
            }

            FreePathStringW (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGW ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
FiCopyAllFilesInTreeExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PCSTR dirPattern;
    PCSTR subPath;
    PCSTR destPath;
    BOOL fileResult;

    dirPattern = JoinPathsA (Source, "*");
    pattern = ObsBuildEncodedObjectStringExA (dirPattern, "*", FALSE);

    if (EnumFirstFileInTreeExA (
            &e,
            pattern,
            0,                          // drive enum types
            TRUE,                       // enum containers
            TRUE,                       // containers first
            FALSE,                      // files first
            FALSE,                      // depth first
            FILEENUM_ALL_SUBLEVELS,     // max sublevel
            FALSE,                      // use exclusions
            NULL                        // callback on error
            )) {

        do {

            subPath = e.NativeFullName;
            subPath = (PCSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsA (Dest, subPath);

            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                fileResult = BfCreateDirectoryA (destPath);
                if (fileResult) {
                    fileResult = SetFileAttributesA (destPath, e.Attributes);
                }
            } else {
                SetFileAttributesA (destPath, FILE_ATTRIBUTE_NORMAL);
                fileResult = CopyFileA (e.NativeFullName, destPath, SkipExisting);
                if (fileResult) {
                    fileResult = SetFileAttributesA (destPath, e.Attributes);
                }
            }

            FreePathStringA (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGA ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeA (&e));
    }

    ObsFreeA (pattern);
    FreePathStringA (dirPattern);

    return result;
}


BOOL
FiCopyAllFilesInTreeExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    )
{
    FILETREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PCWSTR dirPattern;
    PCWSTR subPath;
    PCWSTR destPath;
    BOOL fileResult;

    dirPattern = JoinPathsW (Source, L"*");
    pattern = ObsBuildEncodedObjectStringExW (dirPattern, L"*", FALSE);

    if (EnumFirstFileInTreeExW (
            &e,
            pattern,
            0,                          // drive enum types
            TRUE,                       // enum containers
            TRUE,                       // containers first
            FALSE,                      // files first
            FALSE,                      // depth first
            FILEENUM_ALL_SUBLEVELS,     // max sublevel
            FALSE,                      // use exclusions
            NULL                        // callback on error
            )) {

        do {

            subPath = e.NativeFullName;
            subPath = (PCWSTR) ((PBYTE) subPath + e.FileEnumInfo.PathPattern->ExactRootBytes);

            destPath = JoinPathsW (Dest, subPath);

            if (e.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
                fileResult = BfCreateDirectoryW (destPath);
                if (fileResult) {
                    fileResult = SetFileAttributesW (destPath, e.Attributes);
                }
            } else {
                SetFileAttributesW (destPath, FILE_ATTRIBUTE_NORMAL);
                fileResult = CopyFileW (e.NativeFullName, destPath, SkipExisting);
                if (fileResult) {
                    fileResult = SetFileAttributesW (destPath, e.Attributes);
                }
            }

            FreePathStringW (destPath);

            if (!fileResult) {
                if ((!SkipExisting) ||
                    (GetLastError() != ERROR_FILE_EXISTS)) {
                    result = FALSE;
                    DEBUGMSGW ((DBG_WARNING, "Unable to copy %s", e.NativeFullName));
                }
            }

        } while (EnumNextFileInTreeW (&e));
    }

    ObsFreeW (pattern);
    FreePathStringW (dirPattern);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\dbgtrack.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dbgtrack.h

Abstract:

    Implements macros and declares functions for resource tracking apis.
    Split from old debug.h

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:



--*/

#ifndef RC_INVOKED

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif



//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
#define MEMORY_TRACKING

#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_TRACKING_INLINE_CALL ,File,Line


#endif



//
// Macros
//

#ifdef DEBUG

#define DISABLETRACKCOMMENT()               DisableTrackComment()
#define ENABLETRACKCOMMENT()                EnableTrackComment()

#define TRACK_BEGIN(type,name)              Track##type(TrackPush(#name,__FILE__,__LINE__) ? (type) 0 : (
#define TRACK_END()                         ))

#define INVALID_POINTER(x)                  x=NULL

#else

#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define TRACK_BEGIN(type,name)
#define TRACK_END()

#define INVALID_POINTER(x)

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_TRACKING_INLINE_CALL

#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocationEx(t,p,f,l,a)
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

//
// Types
//

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;



//
// Globals
//

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;
extern BOOL g_TrackAlloc;

//
// Macro expansion list
//

#define TRACK_WRAPPERS              \
        DEFMAC(PBYTE)               \
        DEFMAC(DWORD)               \
        DEFMAC(BOOL)                \
        DEFMAC(UINT)                \
        DEFMAC(PCSTR)               \
        DEFMAC(PCWSTR)              \
        DEFMAC(PVOID)               \
        DEFMAC(PSTR)                \
        DEFMAC(PWSTR)               \
        DEFMAC(HINF)                \
        DEFMAC(PMHANDLE)            \
        DEFMAC(PGROWBUFFER)         \
        DEFMAC(PPARSEDPATTERNA)     \
        DEFMAC(PPARSEDPATTERNW)     \
        DEFMAC(POBSPARSEDPATTERNA)  \
        DEFMAC(POBSPARSEDPATTERNW)  \
        DEFMAC(HASHTABLE)           \

//
// Public function prototypes
//

#ifdef DEBUG

VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocationEx (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line, BOOL Alloc);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
VOID DisableTrackComment (VOID);
VOID EnableTrackComment (VOID);

INT TrackPush (PCSTR Name, PCSTR File, UINT Line);
INT TrackPushEx (PCSTR Name, PCSTR File, UINT Line, BOOL Alloc);
INT TrackPop (VOID);

VOID
TrackDump (
    VOID
    );

#define TRACKPUSH(n,f,l)        TrackPush(n,f,l)
#define TRACKPUSHEX(n,f,l,a)    TrackPushEx(n,f,l,a)
#define TRACKPOP()              TrackPop()
#define TRACKDUMP()             TrackDump()

//
// Macro expansion definition
//

#define DEFMAC(type)    __inline type Track##type (type Arg) {TrackPop(); return Arg;}

TRACK_WRAPPERS

#undef DEFMAC


#else       // i.e., if !DEBUG

#define TRACKPUSH(n,f,l)
#define TRACKPUSHEX(n,f,l,a)
#define TRACKPOP()
#define TRACKDUMP()

#endif

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\icons.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    icons.h

Abstract:

    Implements a set of routines for handling icons in ICO, PE and NE files

Author:

    Calin Negreanu (calinn) 16-Jum-2000

Revision History:

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define ICON_ICOFILE    0x00000001
#define ICON_PEFILE     0x00000002
#define ICON_NEFILE     0x00000003

//
// Macros
//

// None

//
// Types
//

#pragma pack(push)
#pragma pack(2)

typedef struct {
    BYTE        Width;          // Width, in pixels, of the image
    BYTE        Height;         // Height, in pixels, of the image
    BYTE        ColorCount;     // Number of colors in image (0 if >=8bpp)
    BYTE        Reserved;       // Reserved ( must be 0)
    WORD        Planes;         // Color Planes
    WORD        BitCount;       // Bits per pixel
    DWORD       BytesInRes;     // How many bytes in this resource?
    DWORD       ImageOffset;    // Where in the file is this image?
} ICONDIRENTRY, *PICONDIRENTRY;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
    ICONDIRENTRY   Entries[];  // An entry for each image (idCount of 'em)
} ICONDIR, *PICONDIR;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
} ICONDIRBASE, *PICONDIRBASE;

typedef struct {
    BYTE   Width;               // Width, in pixels, of the image
    BYTE   Height;              // Height, in pixels, of the image
    BYTE   ColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE   Reserved;            // Reserved
    WORD   Planes;              // Color Planes
    WORD   BitCount;            // Bits per pixel
    DWORD  BytesInRes;          // how many bytes in this resource?
    WORD   ID;                  // the ID
} GRPICONDIRENTRY, *PGRPICONDIRENTRY;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
    GRPICONDIRENTRY  Entries[];  // The entries for each image
} GRPICONDIR, *PGRPICONDIR;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
} GRPICONDIRBASE, *PGRPICONDIRBASE;

#pragma pack( pop )

typedef struct {
    BYTE Width;
    BYTE Height;
    BYTE ColorCount;
    WORD Planes;
    WORD BitCount;
    DWORD Size;
    WORD Id;
    PBYTE Image;
} ICON_IMAGE, *PICON_IMAGE;

typedef struct {
    PMHANDLE Pool;
    WORD IconsCount;
    PICON_IMAGE Icons[];
} ICON_GROUP, *PICON_GROUP;

typedef struct {
    DWORD DataSize;
    PBYTE Data;
} ICON_SGROUP, *PICON_SGROUP;

typedef struct {
    PICON_GROUP IconGroup;
    PCSTR ResourceId;
    WORD Index;

    // private members, do not touch
    DWORD FileType;
    BOOL FreeHandle;
    HANDLE ModuleHandle;
    GROWBUFFER Buffer;
    MULTISZ_ENUMA MultiSzEnum;
} ICON_ENUMA, *PICON_ENUMA;

typedef struct {
    PICON_GROUP IconGroup;
    PCWSTR ResourceId;
    WORD Index;

    // private members, do not touch
    DWORD FileType;
    BOOL FreeHandle;
    HANDLE ModuleHandle;
    GROWBUFFER Buffer;
    MULTISZ_ENUMW MultiSzEnum;
} ICON_ENUMW, *PICON_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

VOID
IcoReleaseResourceIdA (
    PCSTR ResourceId
    );

VOID
IcoReleaseResourceIdW (
    PCWSTR ResourceId
    );

VOID
IcoReleaseIconGroup (
    IN      PICON_GROUP IconGroup
    );

VOID
IcoReleaseIconSGroup (
    IN OUT  PICON_SGROUP IconSGroup
    );

BOOL
IcoSerializeIconGroup (
    IN      PICON_GROUP IconGroup,
    OUT     PICON_SGROUP IconSGroup
    );

PICON_GROUP
IcoDeSerializeIconGroup (
    IN      PICON_SGROUP IconSGroup
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileEx (
    IN      HANDLE IcoFileHandle
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileA (
    IN      PCSTR IcoFile
    );

PICON_GROUP
IcoExtractIconGroupFromIcoFileW (
    IN      PCWSTR IcoFile
    );

BOOL
IcoWriteIconGroupToIcoFileEx (
    IN      HANDLE IcoFileHandle,
    IN      PICON_GROUP IconGroup
    );

BOOL
IcoWriteIconGroupToIcoFileA (
    IN      PCSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    );

BOOL
IcoWriteIconGroupToIcoFileW (
    IN      PCWSTR IcoFile,
    IN      PICON_GROUP IconGroup,
    IN      BOOL OverwriteExisting
    );

INT
IcoGetIndexFromPeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromPeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index              OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

VOID
IcoAbortPeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortPeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInPeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInPeFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInPeFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromPeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileExA (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId       OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileExW (
    IN      HANDLE ModuleHandle,
    IN      HANDLE UpdateHandle,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId      OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileA (
    IN      PCSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCSTR *ResourceId,      OPTIONAL
    OUT     PINT Index              OPTIONAL
    );

BOOL
IcoWriteIconGroupToPeFileW (
    IN      PCWSTR ModuleName,
    IN      PICON_GROUP IconGroup,
    OUT     PCWSTR *ResourceId,     OPTIONAL
    OUT     PINT Index              OPTIONAL
    );

INT
IcoGetIndexFromNeResourceIdExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId
    );

INT
IcoGetIndexFromNeResourceIdW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

VOID
IcoAbortNeEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortNeEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileExA (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileExW (
    IN      HANDLE ModuleHandle,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileA (
    IN      PCSTR ModuleName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInNeFileW (
    IN      PCWSTR ModuleName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInNeFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInNeFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExA (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileExW (
    IN      HANDLE ModuleHandle,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId   OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromNeFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId   OPTIONAL
    );

VOID
IcoAbortEnumIconGroupA (
    IN OUT  PICON_ENUMA IconEnum
    );

VOID
IcoAbortEnumIconGroupW (
    IN OUT  PICON_ENUMW IconEnum
    );

BOOL
IcoEnumFirstIconGroupInFileA (
    IN      PCSTR FileName,
    OUT     PICON_ENUMA IconEnum
    );

BOOL
IcoEnumFirstIconGroupInFileW (
    IN      PCWSTR FileName,
    OUT     PICON_ENUMW IconEnum
    );

BOOL
IcoEnumNextIconGroupInFileA (
    IN OUT  PICON_ENUMA IconEnum
    );

BOOL
IcoEnumNextIconGroupInFileW (
    IN OUT  PICON_ENUMW IconEnum
    );

PICON_GROUP
IcoExtractIconGroupFromFileA (
    IN      PCSTR ModuleName,
    IN      PCSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupFromFileW (
    IN      PCWSTR ModuleName,
    IN      PCWSTR GroupIconId,
    OUT     PINT Index          OPTIONAL
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromFileA (
    IN      PCSTR ModuleName,
    IN      INT Index,
    OUT     PCSTR *GroupIconId
    );

PICON_GROUP
IcoExtractIconGroupByIndexFromFileW (
    IN      PCWSTR ModuleName,
    IN      INT Index,
    OUT     PCWSTR *GroupIconId
    );

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define ICON_ENUM                               ICON_ENUMA
#define IcoReleaseResourceId                    IcoReleaseResourceIdA
#define IcoExtractIconGroupFromIcoFile          IcoExtractIconGroupFromIcoFileA
#define IcoWriteIconGroupToIcoFile              IcoWriteIconGroupToIcoFileA
#define IcoGetIndexFromPeResourceIdEx           IcoGetIndexFromPeResourceIdExA
#define IcoGetIndexFromPeResourceId             IcoGetIndexFromPeResourceIdA
#define IcoExtractIconGroupFromPeFileEx         IcoExtractIconGroupFromPeFileExA
#define IcoExtractIconGroupFromPeFile           IcoExtractIconGroupFromPeFileA
#define IcoAbortPeEnumIconGroup                 IcoAbortPeEnumIconGroupA
#define IcoEnumFirstIconGroupInPeFileEx         IcoEnumFirstIconGroupInPeFileExA
#define IcoEnumFirstIconGroupInPeFile           IcoEnumFirstIconGroupInPeFileA
#define IcoEnumNextIconGroupInPeFile            IcoEnumNextIconGroupInPeFileA
#define IcoExtractIconGroupByIndexFromPeFileEx  IcoExtractIconGroupByIndexFromPeFileExA
#define IcoExtractIconGroupByIndexFromPeFile    IcoExtractIconGroupByIndexFromPeFileA
#define IcoWriteIconGroupToPeFileEx             IcoWriteIconGroupToPeFileExA
#define IcoWriteIconGroupToPeFile               IcoWriteIconGroupToPeFileA
#define IcoGetIndexFromNeResourceIdEx           IcoGetIndexFromNeResourceIdExA
#define IcoGetIndexFromNeResourceId             IcoGetIndexFromNeResourceIdA
#define IcoExtractIconGroupFromNeFileEx         IcoExtractIconGroupFromNeFileExA
#define IcoExtractIconGroupFromNeFile           IcoExtractIconGroupFromNeFileA
#define IcoAbortNeEnumIconGroup                 IcoAbortNeEnumIconGroupA
#define IcoEnumFirstIconGroupInNeFileEx         IcoEnumFirstIconGroupInNeFileExA
#define IcoEnumFirstIconGroupInNeFile           IcoEnumFirstIconGroupInNeFileA
#define IcoEnumNextIconGroupInNeFile            IcoEnumNextIconGroupInNeFileA
#define IcoExtractIconGroupByIndexFromNeFileEx  IcoExtractIconGroupByIndexFromNeFileExA
#define IcoExtractIconGroupByIndexFromNeFile    IcoExtractIconGroupByIndexFromNeFileA
#define IcoAbortEnumIconGroup                   IcoAbortEnumIconGroupA
#define IcoEnumFirstIconGroupInFile             IcoEnumFirstIconGroupInFileA
#define IcoEnumNextIconGroupInFile              IcoEnumNextIconGroupInFileA
#define IcoExtractIconGroupFromFile             IcoExtractIconGroupFromFileA
#define IcoExtractIconGroupByIndexFromFile      IcoExtractIconGroupByIndexFromFileA

#else

#define ICON_ENUM                               ICON_ENUMW
#define IcoReleaseResourceId                    IcoReleaseResourceIdW
#define IcoExtractIconGroupFromIcoFile          IcoExtractIconGroupFromIcoFileW
#define IcoWriteIconGroupToIcoFile              IcoWriteIconGroupToIcoFileW
#define IcoGetIndexFromPeResourceIdEx           IcoGetIndexFromPeResourceIdExW
#define IcoGetIndexFromPeResourceId             IcoGetIndexFromPeResourceIdW
#define IcoExtractIconGroupFromPeFileEx         IcoExtractIconGroupFromPeFileExW
#define IcoExtractIconGroupFromPeFile           IcoExtractIconGroupFromPeFileW
#define IcoAbortPeEnumIconGroup                 IcoAbortPeEnumIconGroupW
#define IcoEnumFirstIconGroupInPeFileEx         IcoEnumFirstIconGroupInPeFileExW
#define IcoEnumFirstIconGroupInPeFile           IcoEnumFirstIconGroupInPeFileW
#define IcoEnumNextIconGroupInPeFile            IcoEnumNextIconGroupInPeFileW
#define IcoExtractIconGroupByIndexFromPeFileEx  IcoExtractIconGroupByIndexFromPeFileExW
#define IcoExtractIconGroupByIndexFromPeFile    IcoExtractIconGroupByIndexFromPeFileW
#define IcoWriteIconGroupToPeFileEx             IcoWriteIconGroupToPeFileExW
#define IcoWriteIconGroupToPeFile               IcoWriteIconGroupToPeFileW
#define IcoGetIndexFromNeResourceIdEx           IcoGetIndexFromNeResourceIdExW
#define IcoGetIndexFromNeResourceId             IcoGetIndexFromNeResourceIdW
#define IcoExtractIconGroupFromNeFileEx         IcoExtractIconGroupFromNeFileExW
#define IcoExtractIconGroupFromNeFile           IcoExtractIconGroupFromNeFileW
#define IcoAbortNeEnumIconGroup                 IcoAbortNeEnumIconGroupW
#define IcoEnumFirstIconGroupInNeFileEx         IcoEnumFirstIconGroupInNeFileExW
#define IcoEnumFirstIconGroupInNeFile           IcoEnumFirstIconGroupInNeFileW
#define IcoEnumNextIconGroupInNeFile            IcoEnumNextIconGroupInNeFileW
#define IcoExtractIconGroupByIndexFromNeFileEx  IcoExtractIconGroupByIndexFromNeFileExW
#define IcoExtractIconGroupByIndexFromNeFile    IcoExtractIconGroupByIndexFromNeFileW
#define IcoAbortEnumIconGroup                   IcoAbortEnumIconGroupW
#define IcoEnumFirstIconGroupInFile             IcoEnumFirstIconGroupInFileW
#define IcoEnumNextIconGroupInFile              IcoEnumNextIconGroupInFileW
#define IcoExtractIconGroupFromFile             IcoExtractIconGroupFromFileW
#define IcoExtractIconGroupByIndexFromFile      IcoExtractIconGroupByIndexFromFileW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    PMHANDLE ListData;
} GROWLIST, *PGROWLIST;

#ifdef DEBUG
#define INIT_GROWLIST {NULL,0,0,0,0,0, NULL}
#else
#define INIT_GROWLIST {NULL,0,0,0,0, NULL}
#endif

#define GlGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppend(list,data,size)    TRACK_BEGIN(PBYTE, GlAppend)\
                                    RealGlAppend (list,data,size)   \
                                    TRACK_END()

PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppendAddNul(list,data,size)    TRACK_BEGIN(PBYTE, GlAppendAddNul)         \
                                          RealGlAppendAddNul (list,data,size)       \
                                          TRACK_END()

VOID
GlFree (
    IN  PGROWLIST GrowList
    );

VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    );

PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GlGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsert(list,index,data,size)      TRACK_BEGIN(PBYTE,GlInsert)   \
                                            RealGlInsert (list,index,data,size)             \
                                            TRACK_END()


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsertAddNul(list,index,data,size)    TRACK_BEGIN(PBYTE, GlInsertAddNul)           \
                                                RealGlInsertAddNul (list,index,data,size)   \
                                                TRACK_END()


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToSet,           OPTIONAL
    IN      UINT SizeOfData
    );

#define GlSetItem(list,index,data,size)     TRACK_BEGIN(PBYTE, GlSetItem)        \
                                            RealGlSetItem(list,index,data,size) \
                                            TRACK_END()

__inline
PCSTR
RealGlAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCSTR
RealGlInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

__inline
PCWSTR
RealGlInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        //cast is OK, we don't expect pointers to be that far away
                        String < End ? (UINT)((UBINT) End - (UBINT) String) : 0
                        );
}

#define GlAppendStringABA(list,a,b)         TRACK_BEGIN(PCSTR, GrowListAppendStringABA)          \
                                            RealGlAppendStringABA(list,a,b)\
                                            TRACK_END()

#define GlAppendStringABW(list,a,b)         TRACK_BEGIN(PCWSTR, GrowListAppendStringABW)         \
                                            RealGlAppendStringABW(list,a,b)\
                                            TRACK_END()

#define GlInsertStringABA(list,index,a,b)   TRACK_BEGIN(PCSTR, GrowListInsertStringABA)            \
                                            RealGlInsertStringABA(list,index,a,b)\
                                            TRACK_END()

#define GlInsertStringABW(list,index,a,b)   TRACK_BEGIN(PCWSTR, GrowListInsertStringABW)           \
                                            RealGlInsertStringABW(list,index,a,b)\
                                            TRACK_END()



#define GlAppendStringA(list,str) GlAppendStringABA(list,str,GetEndOfStringA(str))
#define GlAppendStringW(list,str) GlAppendStringABW(list,str,GetEndOfStringW(str))

#define GlInsertStringA(list,index,str) GlInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GlInsertStringW(list,index,str) GlInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GlAppendStringNA(list,str,len) GlAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GlAppendStringNW(list,str,len) GlAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GlInsertStringNA(list,index,str,len) GlInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GlInsertStringNW(list,index,str,len) GlInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GlGetStringA(list,index) (PCSTR)(GlGetItem(list,index))
#define GlGetStringW(list,index) (PCWSTR)(GlGetItem(list,index))

#define GlAppendEmptyItem(list)           GlAppend (list,NULL,0)
#define GlInsertEmptyItem(list,index)     GlInsert (list,index,NULL,0)

#ifdef UNICODE

#define GlAppendString GlAppendStringW
#define GlInsertString GlInsertStringW
#define GlAppendStringAB GlAppendStringABW
#define GlInsertStringAB GlInsertStringABW
#define GlAppendStringN GlAppendStringNW
#define GlInsertStringN GlInsertStringNW
#define GlGetString GlGetStringW
#define GlGetStringPtrArray GlGetStringPtrArrayW

#else

#define GlAppendString GlAppendStringA
#define GlInsertString GlInsertStringA
#define GlAppendStringAB GlAppendStringABA
#define GlInsertStringAB GlInsertStringABA
#define GlAppendStringN GlAppendStringNA
#define GlInsertStringN GlInsertStringNA
#define GlGetString GlGetStringA
#define GlGetStringPtrArray GlGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct TAG_GROWBUFFER {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
#ifdef DEBUG
    DWORD StatEnd;
#endif
} GROWBUFFER;

#ifdef DEBUG
#define INIT_GROWBUFFER {NULL,0,0,0,0,0}
#else
#define INIT_GROWBUFFER {NULL,0,0,0,0}
#endif

PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD SpaceNeeded
    );

#define GbGrow(buf,size)    TRACK_BEGIN(PBYTE, GbGrow)\
                            RealGbGrow(buf,size)\
                            TRACK_END()

VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    );


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbMultiSzAppendA(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendA)\
                                    RealGbMultiSzAppendA(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbMultiSzAppendW(buf,str)   TRACK_BEGIN(BOOL, GbMultiSzAppendW)\
                                    RealGbMultiSzAppendW(buf,str)\
                                    TRACK_END()

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValA(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValA)\
                                        RealGbMultiSzAppendValA(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValW(buf,k,v)    TRACK_BEGIN(BOOL, GbMultiSzAppendValW)\
                                        RealGbMultiSzAppendValW(buf,k,v)\
                                        TRACK_END()

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define GbMultiSzAppendStringA(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringA)\
                                            RealGbMultiSzAppendStringA(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define GbMultiSzAppendStringW(buf,k,v)     TRACK_BEGIN(BOOL, GbMultiSzAppendStringW)\
                                            RealGbMultiSzAppendStringW(buf,k,v)\
                                            TRACK_END()

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GbAppendDword(buf,d)        TRACK_BEGIN(BOOL, GbAppendDword)\
                                    RealGbAppendDword(buf,d)\
                                    TRACK_END()

BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID p
    );

#define GbAppendPvoid(buf,p)        TRACK_BEGIN(BOOL, GbAppendPvoid)\
                                    RealGbAppendPvoid(buf,p)\
                                    TRACK_END()


BOOL
RealGbAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbAppendStringA(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringA)\
                                    RealGbAppendStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbAppendStringW(buf,str)    TRACK_BEGIN(BOOL, GbAppendStringW)\
                                    RealGbAppendStringW(buf,str)\
                                    TRACK_END()


BOOL
RealGbAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GbAppendStringABA(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABA)\
                                        RealGbAppendStringABA(buf,a,b)\
                                        TRACK_END()

BOOL
RealGbAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GbAppendStringABW(buf,a,b)      TRACK_BEGIN(BOOL, GbAppendStringABW)\
                                        RealGbAppendStringABW(buf,a,b)\
                                        TRACK_END()



BOOL
RealGbCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyStringA(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringA)\
                                    RealGbCopyStringA(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyStringW(buf,str)      TRACK_BEGIN(BOOL, GbCopyStringW)\
                                    RealGbCopyStringW(buf,str)\
                                    TRACK_END()

BOOL
RealGbCopyQuotedStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyQuotedStringA(buf,str) TRACK_BEGIN(BOOL, GbCopyQuotedStringA)\
                                     RealGbCopyQuotedStringA(buf,str)\
                                     TRACK_END()

BOOL
RealGbCopyQuotedStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyQuotedStringW(buf,str) TRACK_BEGIN(BOOL, GbCopyQuotedStringW)\
                                     RealGbCopyQuotedStringW(buf,str)\
                                     TRACK_END()

#ifdef DEBUG
VOID
GbDumpStatistics (
    VOID
    );
#else
#define GbDumpStatistics()
#endif

#ifdef UNICODE

#define GbMultiSzAppend             GbMultiSzAppendW
#define GbMultiSzAppendVal          GbMultiSzAppendValW
#define GbMultiSzAppendString       GbMultiSzAppendStringW
#define GbAppendString              GbAppendStringW
#define GbAppendStringAB            GbAppendStringABW
#define GbCopyString                GbCopyStringW
#define GbCopyQuotedString          GbCopyQuotedStringW

#else

#define GbMultiSzAppend             GbMultiSzAppendA
#define GbMultiSzAppendVal          GbMultiSzAppendValA
#define GbMultiSzAppendString       GbMultiSzAppendStringA
#define GbAppendString              GbAppendStringA
#define GbAppendStringAB            GbAppendStringABA
#define GbCopyString                GbCopyStringA
#define GbCopyQuotedString          GbCopyQuotedStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

#define UNKNOWN_LETTER_CASE FALSE
#define ALREADY_LOWERCASE   TRUE

#define DEFAULT_BUCKET_SIZE 0

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocExAW(cs,u,s,d,b)     TRACK_BEGIN(HASHTABLE, HtAllocExAW)\
                                    RealHtAllocExAW(cs,u,s,d,b)\
                                    TRACK_END()

#define HtAllocA()                                  HtAllocExAW(FALSE,FALSE,FALSE,0,0)
#define HtAllocW()                                  HtAllocExAW(FALSE,TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                      HtAllocExAW(FALSE,FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                      HtAllocExAW(FALSE,TRUE,FALSE,size,0)

#define HtAllocExA(cs,datasize,bucketcount)         HtAllocExAW(cs,FALSE,FALSE,datasize,bucketcount)
#define HtAllocExW(cs,datasize,bucketcount)         HtAllocExAW(cs,TRUE,FALSE,datasize,bucketcount)

#define HtAllocExternStrA()                         HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrW()                         HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)             HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)             HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrExA(cs,size,bucketcount)    HtAllocExAW(cs,FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(cs,size,bucketcount)    HtAllocExAW(cs,TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringA(table,string)              HtAddStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataA(table,string,data)  HtAddStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringW(table,string)              HtAddStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataW(table,string,data)  HtAddStringExW(table,string,data,UNKNOWN_LETTER_CASE)

BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    );

BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    );

BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    );


HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringA(table,string)             HtFindStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataA(table,string,data) HtFindStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringW(table,string)             HtFindStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataW(table,string,data) HtFindStringExW(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,UNKNOWN_LETTER_CASE)

BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Index
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Index
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringAndData          HtAddStringAndDataW
#define HtAddStringEx               HtAddStringExW
#define HtRemoveString              HtRemoveStringW
#define HtFindString                HtFindStringW
#define HtFindStringAndData         HtFindStringAndDataW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringAndData          HtAddStringAndDataA
#define HtAddStringEx               HtAddStringExA
#define HtRemoveString              HtRemoveStringA
#define HtFindString                HtFindStringA
#define HtFindStringAndData         HtFindStringAndDataA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\exclist.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    exclist.h

Abstract:

    Set of APIs to manage exclusion lists of objects of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Macro expansion list
//

#define EXCLUSIONLIST_TYPES                                     \
            DEFMAC(ELT_UNUSED,          "Unused")               \
            DEFMAC(ELT_REGISTRY,        "Registry")             \
            DEFMAC(ELT_FILE,            "File")                 \
            DEFMAC(ELT_EXTRA1,          "Extra1")               \
            DEFMAC(ELT_EXTRA2,          "Extra2")               \
            DEFMAC(ELT_EXTRA3,          "Extra3")               \
            DEFMAC(ELT_EXTRA4,          "Extra4")               \
            DEFMAC(ELT_EXTRA5,          "Extra5")               \
            DEFMAC(ELT_EXTRA6,          "Extra6")               \
            DEFMAC(ELT_EXTRA7,          "Extra7")               \
            DEFMAC(ELT_EXTRA8,          "Extra8")               \

            // this needs work in order to work with extensible types

//
// Types
//

#define DEFMAC(TypeId,TypeName)     TypeId,

//
// these should map 1:1 with MIG_*_TYPE in ism.h for ease of use
//
typedef enum {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_LAST
};

#undef DEFMAC


//
// API
//

BOOL
ElInitialize (
    VOID
    );

VOID
ElTerminateA (
    VOID
    );

VOID
ElTerminateW (
    VOID
    );

DWORD
ElGetTypeId (
    IN      PCSTR TypeName
    );

PCSTR
ElGetTypeName (
    IN      DWORD TypeId
    );

BOOL
ElAddA (
    IN      DWORD ObjectType,
    IN      PCSTR ObjectName
    );

BOOL
ElAddW (
    IN      DWORD ObjectType,
    IN      PCWSTR ObjectName
    );

VOID
ElRemoveAllA (
    VOID
    );

VOID
ElRemoveAllW (
    VOID
    );

BOOL
ElIsExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR Object
    );

BOOL
ElIsExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR Object
    );

BOOL
ElIsExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Node,             OPTIONAL
    IN      PCSTR Leaf              OPTIONAL
    );

BOOL
ElIsExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Node,            OPTIONAL
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsTreeExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR TreePattern
    );

BOOL
ElIsTreeExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR TreePattern
    );

BOOL
ElIsTreeExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    );

BOOL
ElIsTreeExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR Leaf             OPTIONAL
    );

BOOL
ElIsObsPatternExcludedA (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    );

BOOL
ElIsObsPatternExcludedW (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    );

//
// Macros
//

#ifdef UNICODE

#define ElAdd                   ElAddW
#define ElTerminate             ElTerminateW
#define ElRemoveAll             ElRemoveAllW
#define ElIsExcluded            ElIsExcludedW
#define ElIsExcluded2           ElIsExcluded2W
#define ElIsTreeExcluded        ElIsTreeExcludedW
#define ElIsTreeExcluded2       ElIsTreeExcluded2W
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedW

#else

#define ElAdd                   ElAddA
#define ElTerminate             ElTerminateA
#define ElRemoveAll             ElRemoveAllA
#define ElIsExcluded            ElIsExcludedA
#define ElIsExcluded2           ElIsExcluded2A
#define ElIsTreeExcluded        ElIsTreeExcludedA
#define ElIsTreeExcluded2       ElIsTreeExcluded2A
#define ElIsObsPatternExcluded  ElIsObsPatternExcludedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\fileenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

//
// Drive enumeration structures
//

#define DRIVEENUM_NONE      0x000000
#define DRIVEENUM_UNKNOWN   0x000001
#define DRIVEENUM_NOROOTDIR 0x000002
#define DRIVEENUM_REMOVABLE 0x000004
#define DRIVEENUM_FIXED     0x000008
#define DRIVEENUM_REMOTE    0x000010
#define DRIVEENUM_CDROM     0x000020
#define DRIVEENUM_RAMDISK   0x000040
#define DRIVEENUM_ALL       (DRIVEENUM_UNKNOWN|DRIVEENUM_NOROOTDIR|DRIVEENUM_REMOVABLE|DRIVEENUM_FIXED|DRIVEENUM_REMOTE|DRIVEENUM_CDROM|DRIVEENUM_RAMDISK)
#define DRIVEENUM_ALLVALID  (DRIVEENUM_REMOVABLE|DRIVEENUM_FIXED|DRIVEENUM_REMOTE|DRIVEENUM_CDROM|DRIVEENUM_RAMDISK)

typedef struct {
    PCSTR           DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PSTR            AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMA, *PDRIVE_ENUMA;

typedef struct {
    PCWSTR          DriveName;
    UINT            DriveType;

    //
    // private members, maintained by enumeration
    //
    PWSTR           AllLogicalDrives;
    UINT            WantedDriveTypes;
} DRIVE_ENUMW, *PDRIVE_ENUMW;

//
// file enumeration structures
//

#define FILEENUM_ALL_SUBLEVELS  0xFFFFFFFF

typedef enum {
    FECF_SKIPDIR                = 0x0001,
    FECF_SKIPSUBDIRS            = 0x0002,
    FECF_SKIPFILES              = 0x0004,
} FILEENUM_CONTROLFLAGS;

typedef enum {
    FEIF_RETURN_DIRS            = 0x0001,
    FEIF_FILES_FIRST            = 0x0002,
    FEIF_DEPTH_FIRST            = 0x0004,
    FEIF_USE_EXCLUSIONS         = 0x0008,
    FEIF_CONTAINERS_FIRST       = 0x0010,
} FILEENUM_INFOFLAGS;

typedef enum {
    DNS_ENUM_INIT,
    DNS_FILE_FIRST,
    DNS_FILE_NEXT,
    DNS_FILE_DONE,
    DNS_SUBDIR_FIRST,
    DNS_SUBDIR_NEXT,
    DNS_SUBDIR_DONE,
    DNS_ENUM_DONE
} DNS_ENUM_STATE;

typedef enum {
    FES_ROOT_FIRST,
    FES_ROOT_NEXT,
    FES_ROOT_DONE
} FES_ROOT_STATE;

typedef enum {
    DNF_RETURN_DIRNAME      = 0x0001,
    DNF_DIRNAME_MATCHES     = 0x0002,
} DIRNODE_FLAGS;

typedef struct {
    PCSTR               DirName;
    DWORD               DirAttributes;
    PSTR                FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAA    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEA, *PDIRNODEA;

typedef struct {
    PCWSTR              DirName;
    DWORD               DirAttributes;
    PWSTR               FileName;
    HANDLE              FindHandle;
    WIN32_FIND_DATAW    FindData;
    DWORD               EnumState;
    DWORD               Flags;
    DWORD               SubLevel;
} DIRNODEW, *PDIRNODEW;

typedef BOOL (*FPE_ERROR_CALLBACKA)(PDIRNODEA);

typedef struct {
    POBSPARSEDPATTERNA      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKA     CallbackOnError;
} FILEENUMINFOA, *PFILEENUMINFOA;

typedef BOOL (*FPE_ERROR_CALLBACKW)(PDIRNODEW);

typedef struct {
    POBSPARSEDPATTERNW      PathPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    FPE_ERROR_CALLBACKW     CallbackOnError;
} FILEENUMINFOW, *PFILEENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[MAX_MBCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOA   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMA    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEA       LastNode;
    PSTR            FileNameAppendPos;
    PSTR            LastWackPtr;
} FILETREE_ENUMA, *PFILETREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[MAX_WCHAR_PATH];
    DWORD           Attributes;
    DWORD           CurrentLevel;

    //
    // Private members
    //
    DWORD           ControlFlags;
    FILEENUMINFOW   FileEnumInfo;
    GROWBUFFER      FileNodes;
    DWORD           RootState;
    PDRIVE_ENUMW    DriveEnum;
    UINT            DriveEnumTypes;
    PDIRNODEW       LastNode;
    PWSTR           FileNameAppendPos;
    PWSTR           LastWackPtr;
} FILETREE_ENUMW, *PFILETREE_ENUMW;

typedef struct {
    PCSTR OriginalArg;
    PCSTR CleanedUpArg;
    BOOL Quoted;
} CMDLINEARGA, *PCMDLINEARGA;

typedef struct {
    PCSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGA Args[];
} CMDLINEA, *PCMDLINEA;

typedef struct {
    PCWSTR OriginalArg;
    PCWSTR CleanedUpArg;
    BOOL Quoted;
} CMDLINEARGW, *PCMDLINEARGW;

typedef struct {
    PCWSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGW Args[];
} CMDLINEW, *PCMDLINEW;

typedef BOOL(WINAPI FINDFILEA)(
                        IN      PCSTR FileName
                        );
typedef FINDFILEA *PFINDFILEA;

typedef BOOL(WINAPI FINDFILEW)(
                        IN      PCWSTR FileName
                        );
typedef FINDFILEW *PFINDFILEW;

typedef BOOL(WINAPI SEARCHPATHA)(
                        IN      PCSTR FileName,
                        IN      DWORD BufferLength,
                        OUT     PSTR Buffer
                        );
typedef SEARCHPATHA *PSEARCHPATHA;

typedef BOOL(WINAPI SEARCHPATHW)(
                        IN      PCWSTR FileName,
                        IN      DWORD BufferLength,
                        OUT     PWSTR Buffer
                        );
typedef SEARCHPATHW *PSEARCHPATHW;


//
// API
//

BOOL
FileEnumInitialize (
    VOID
    );

VOID
FileEnumTerminate (
    VOID
    );

//
// File enumeration APIs
//

BOOL
EnumFirstFileInTreeExA (
    OUT     PFILETREE_ENUMA FileEnum,
    IN      PCSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKA CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeA(e,p)  EnumFirstFileInTreeExA(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumFirstFileInTreeExW (
    OUT     PFILETREE_ENUMW FileEnum,
    IN      PCWSTR EncodedPathPattern,
    IN      UINT DriveEnumTypes,
    IN      BOOL EnumContainers,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevels,
    IN      BOOL UseExclusions,
    IN      FPE_ERROR_CALLBACKW CallbackOnError OPTIONAL
    );

#define EnumFirstFileInTreeW(e,p)  EnumFirstFileInTreeExW(e,p,DRIVEENUM_ALLVALID,TRUE,TRUE,TRUE,TRUE,FILEENUM_ALL_SUBLEVELS,FALSE,NULL)

BOOL
EnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum
    );

//
// Drive enumeration APIs
//

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    );

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    );

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    );


//
// Routines built on enum
//

BOOL
FiRemoveAllFilesInDirA (
    IN      PCSTR Dir
    );

BOOL
FiRemoveAllFilesInDirW (
    IN      PCWSTR Dir
    );

BOOL
FiRemoveAllFilesInTreeExA (
    IN      PCSTR Dir,
    IN      BOOL RemoveRoot
    );

#define FiRemoveAllFilesInTreeA(dir) FiRemoveAllFilesInTreeExA(dir,TRUE)

BOOL
FiRemoveAllFilesInTreeExW (
    IN      PCWSTR Dir,
    IN      BOOL RemoveRoot
    );

#define FiRemoveAllFilesInTreeW(dir) FiRemoveAllFilesInTreeExW(dir,TRUE)

BOOL
FiCopyAllFilesInDirA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInDirA(source,dest) FiCopyAllFilesInDirExA(source,dest,FALSE)

BOOL
FiCopyAllFilesInDirW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInDirW(source,dest) FiCopyAllFilesInDirExW(source,dest,FALSE)

BOOL
FiCopyAllFilesInTreeExA (
    IN      PCSTR Source,
    IN      PCSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInTreeA(source,dest) FiCopyAllFilesInTreeExA(source,dest,FALSE)

BOOL
FiCopyAllFilesInTreeExW (
    IN      PCWSTR Source,
    IN      PCWSTR Dest,
    IN      BOOL SkipExisting
    );

#define FiCopyAllFilesInTreeW(source,dest) FiCopyAllFilesInTreeExW(source,dest,FALSE)

PCMDLINEA
ParseCmdLineExA (
    IN      PCSTR CmdLine,
    IN      PCSTR Separators,                   OPTIONAL
    IN      PFINDFILEA FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHA SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    );
#define ParseCmdLineA(c,b) ParseCmdLineExA(c,NULL,NULL,NULL,b)

PCMDLINEW
ParseCmdLineExW (
    IN      PCWSTR CmdLine,
    IN      PCWSTR Separators,                  OPTIONAL
    IN      PFINDFILEW FindFileCallback,        OPTIONAL
    IN      PSEARCHPATHW SearchPathCallback,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer
    );
#define ParseCmdLineW(c,b) ParseCmdLineExW(c,NULL,NULL,NULL,b)

//
// Macros
//

#ifdef UNICODE

#define DIRNODE                     DIRNODEW
#define PDIRNODE                    PDIRNODEW
#define FILENODE                    FILENODEW
#define PFILENODE                   PFILENODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define FILEENUMINFO                FILEENUMINFOW
#define PFILEENUMINFO               PFILEENUMINFOW
#define FILETREE_ENUM               FILETREE_ENUMW
#define PFILETREE_ENUM              PFILETREE_ENUMW
#define EnumFirstFileInTree         EnumFirstFileInTreeW
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExW
#define EnumNextFileInTree          EnumNextFileInTreeW
#define AbortEnumFileInTree         AbortEnumFileInTreeW

#define DRIVE_ENUM                  DRIVE_ENUMW
#define EnumFirstDrive              EnumFirstDriveW
#define EnumNextDrive               EnumNextDriveW
#define AbortEnumDrive              AbortEnumDriveW
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirW
#define FiRemoveAllFilesInTreeEx    FiRemoveAllFilesInTreeExW
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeW
#define FiCopyAllFilesInDir         FiCopyAllFilesInDirW
#define FiCopyAllFilesInDirEx       FiCopyAllFilesInDirExW
#define FiCopyAllFilesInTree        FiCopyAllFilesInTreeW
#define FiCopyAllFilesInTreeEx      FiCopyAllFilesInTreeExW

#define CMDLINE                     CMDLINEW
#define PCMDLINE                    PCMDLINEW
#define ParseCmdLineEx              ParseCmdLineExW
#define ParseCmdLine                ParseCmdLineW

#else

#define DIRNODE                     DIRNODEA
#define PDIRNODE                    PDIRNODEA
#define FILENODE                    FILENODEA
#define PFILENODE                   PFILENODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define FILEENUMINFO                FILEENUMINFOA
#define PFILEENUMINFO               PFILEENUMINFOA
#define FILETREE_ENUM               FILETREE_ENUMA
#define PFILETREE_ENUM              PFILETREE_ENUMA
#define EnumFirstFileInTree         EnumFirstFileInTreeA
#define EnumFirstFileInTreeEx       EnumFirstFileInTreeExA
#define EnumNextFileInTree          EnumNextFileInTreeA
#define AbortEnumFileInTree         AbortEnumFileInTreeA

#define DRIVE_ENUM                  DRIVE_ENUMA
#define EnumFirstDrive              EnumFirstDriveA
#define EnumNextDrive               EnumNextDriveA
#define AbortEnumDrive              AbortEnumDriveA
#define FiRemoveAllFilesInDir       FiRemoveAllFilesInDirA
#define FiRemoveAllFilesInTreeEx    FiRemoveAllFilesInTreeExA
#define FiRemoveAllFilesInTree      FiRemoveAllFilesInTreeA
#define FiCopyAllFilesInDirEx       FiCopyAllFilesInDirExA
#define FiCopyAllFilesInDir         FiCopyAllFilesInDirA
#define FiCopyAllFilesInTreeEx      FiCopyAllFilesInTreeExA
#define FiCopyAllFilesInTree        FiCopyAllFilesInTreeA

#define CMDLINE                     CMDLINEA
#define PCMDLINE                    PCMDLINEA
#define ParseCmdLineEx              ParseCmdLineExA
#define ParseCmdLine                ParseCmdLineA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_PMHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_PMHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    PMHANDLE        PoolHandle;
    ALLOCATORTYPES  Allocator;
} INFSTRUCT, *PINFSTRUCT;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_GROWBUFFER}
#define INITINFSTRUCT_PMHANDLE {INFCONTEXT_INIT,INIT_GROWBUFFER,NULL,INF_USE_PRIVATE_PMHANDLE}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile



VOID
InfGlobalInit (
    IN  BOOL Terminate
    );

VOID
InfCleanUpInfStruct (
    PINFSTRUCT Context
    );

VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()

#define InfOpenInfFileW(f)              TRACK_BEGIN(HINF, InfOpenInfFile)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        TRACK_END()



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCT
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntField (
    IN PINFSTRUCT       Context,
    IN UINT            FieldIndex,
    IN PINT             Value
    );

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT      Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCT      Context
    );

BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT   Context
    );

UINT
InfGetFieldCount (
    IN PINFSTRUCT       Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    );

VOID
InfLogContext (
    IN      PCSTR LogType,
    IN      HINF InfHandle,
    IN      PINFSTRUCT InfStruct
    );

VOID
InfNameHandle (
    IN      HINF Inf,
    IN      PCSTR NewName,
    IN      BOOL OverwriteExistingName
    );

//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW


#else

#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\ini.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.h

Abstract:

    Declares interface for INI wrapper routines. These routines simplify
    access of INIs by wrapping the Win32 APIs with routines that use pools.

Author:

    04-Nov-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef struct {
    PCSTR   IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEA, *PINIFILEA;

typedef struct {
    PCWSTR  IniFilePath;
    DWORD   OriginalAttributes;
} INIFILEW, *PINIFILEW;


typedef struct {
    PCSTR   CurrentSection;
    PCSTR   Sections;
} INISECT_ENUMA, *PINISECT_ENUMA;

typedef struct {
    PCWSTR  CurrentSection;
    PCWSTR  Sections;
} INISECT_ENUMW, *PINISECT_ENUMW;


typedef struct {
    PCSTR   CurrentKeyValuePair;
    PCSTR   KeyValuePairs;
    PCSTR   CurrentKey;
    PCSTR   CurrentValue;
    PSTR    Private;
} INIKEYVALUE_ENUMA, *PINIKEYVALUE_ENUMA;

typedef struct {
    PCWSTR  CurrentKeyValuePair;
    PCWSTR  KeyValuePairs;
    PCWSTR  CurrentKey;
    PCWSTR  CurrentValue;
    PWSTR   Private;
} INIKEYVALUE_ENUMW, *PINIKEYVALUE_ENUMW;

//
// Public function prototypes
//

BOOL
Ini_Init (
    VOID
    );

VOID
Ini_Exit (
    VOID
    );


BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenA(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenA)\
                                RealIniFileOpenA((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()

BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    );

#define IniFileOpenW(i,path,b)  TRACK_BEGIN(BOOL, IniFileOpenW)\
                                RealIniFileOpenW((i),(path),(b)/*,*/ ALLOCATION_TRACKING_CALL)\
                                TRACK_END()


VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    );

VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    );

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    );

BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    );

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    );

VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    );

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    );

BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    );

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    );

VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    );

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    );

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    );

VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    );

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    );

BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    );


//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#define INIFILE                         INIFILEW
#define INISECT_ENUM                    INISECT_ENUMW
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMW

#define IniFileOpen                     IniFileOpenW
#define IniFileClose                    IniFileCloseW
#define EnumFirstIniSection             EnumFirstIniSectionW
#define EnumNextIniSection              EnumNextIniSectionW
#define AbortIniSectionEnum             AbortIniSectionEnumW
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueW
#define EnumNextIniKeyValue             EnumNextIniKeyValueW
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumW
#define IniReadValue                    IniReadValueW
#define IniFreeReadValue                IniFreeReadValueW
#define IniWriteValue                   IniWriteValueW

#else

#define INIFILE                         INIFILEA
#define INISECT_ENUM                    INISECT_ENUMA
#define INIKEYVALUE_ENUM                INIKEYVALUE_ENUMA

#define IniFileOpen                     IniFileOpenA
#define IniFileClose                    IniFileCloseA
#define EnumFirstIniSection             EnumFirstIniSectionA
#define EnumNextIniSection              EnumNextIniSectionA
#define AbortIniSectionEnum             AbortIniSectionEnumA
#define EnumFirstIniKeyValue            EnumFirstIniKeyValueA
#define EnumNextIniKeyValue             EnumNextIniKeyValueA
#define AbortIniKeyValueEnum            AbortIniKeyValueEnumA
#define IniReadValue                    IniReadValueA
#define IniFreeReadValue                IniFreeReadValueA
#define IniWriteValue                   IniWriteValueA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\main.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    main.h

Abstract:

    Declares the interface to utils\main

Author:

    Jim Schmidt (jimschm) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/


//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

//
// Prototypes
//

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    );

VOID
UtTerminate (
    VOID
    );

HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

HANDLE
StartProcessA (
    IN      PCSTR CmdLine
    );

HANDLE
StartProcessW (
    IN      PCWSTR CmdLine
    );

#ifdef UNICODE

#define StartProcess            StartProcessW

#else

#define StartProcess            StartProcessA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    mvander     13-Aug-1999     many changes
    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000


//
// Dataflags for enuming key data
//

#define DATAFLAG_INSTANCEMASK   0x03
#define DATAFLAG_UNORDERED      0x04
#define DATAFLAG_SINGLELINK     0x08
#define DATAFLAG_DOUBLELINK     0x10
#define DATAFLAG_BINARYMASK     0x1C
#define DATAFLAG_VALUE          0x20
#define DATAFLAG_FLAGS          0x40
#define DATAFLAG_ALL            (DATAFLAG_INSTANCEMASK|DATAFLAG_UNORDERED|DATAFLAG_SINGLELINK|DATAFLAG_DOUBLELINK|DATAFLAG_VALUE|DATAFLAG_FLAGS)

//
// Constant for MemDbKeyFromHandle
//

#define MEMDB_LAST_LEVEL        0xFFFFFFFF

//
// Types
//


typedef UINT KEYHANDLE;
typedef UINT DATAHANDLE;

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Flags for enumeration routines
//
#define ENUMFLAG_INSTANCEMASK       0x0003
#define ENUMFLAG_UNORDERED          0x0004
#define ENUMFLAG_SINGLELINK         0x0008
#define ENUMFLAG_DOUBLELINK         0x0010
#define ENUMFLAG_BINARYMASK         0x001C
#define ENUMFLAG_VALUE              0x0020
#define ENUMFLAG_FLAGS              0x0040
#define ENUMFLAG_EMPTY              0x0080
#define ENUMFLAG_ENDPOINTS          0x0100
#define ENUMFLAG_NONENDPOINTS       0x0200

#define ENUMFLAG_ALLDATA        (ENUMFLAG_BINARYMASK|ENUMFLAG_VALUE|ENUMFLAG_FLAGS|ENUMFLAG_EMPTY)
#define ENUMFLAG_ALLSEGMENTS    (ENUMFLAG_ENDPOINTS|ENUMFLAG_NONENDPOINTS)

#define ENUMFLAG_ALL            (ENUMFLAG_ALLDATA|ENUMFLAG_ALLSEGMENTS)

#define ENUMFLAG_NORMAL         (ENUMFLAG_ALLDATA|ENUMFLAG_ENDPOINTS)

#define ENUMLEVEL_LASTLEVEL         0xFFFFFFFF
#define ENUMLEVEL_ALLLEVELS         0xFFFFFFFF

typedef BOOL(MEMDB_PATTERNFINDW)(PCWSTR);
typedef MEMDB_PATTERNFINDW * PMEMDB_PATTERNFINDW;

typedef BOOL(MEMDB_PATTERNMATCHW)(PCVOID, PCWSTR);
typedef MEMDB_PATTERNMATCHW * PMEMDB_PATTERNMATCHW;

typedef struct {
    PMEMDB_PATTERNFINDW PatternFind;
    PMEMDB_PATTERNMATCHW PatternMatch;
    PCVOID Data;
} MEMDB_PATTERNSTRUCTW, *PMEMDB_PATTERNSTRUCTW;

typedef struct {
    WCHAR FullKeyName[MEMDB_MAX];
    WCHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    BYTE CurrentDatabaseIndex;
    BOOL EnumerationMode;
    UINT EnumFlags;
    PWSTR KeyNameCopy;
    PWSTR PatternCopy;
    PWSTR PatternPtr;
    PWSTR PatternEndPtr;
    UINT CurrentIndex;
    UINT BeginLevel;                   // 0-based first level of keys
    UINT EndLevel;                     // 0-based last level of keys
    UINT CurrentLevel;                 // 1-based level of keys
    GROWBUFFER TreeEnumBuffer;
    UINT TreeEnumLevel;
    MEMDB_PATTERNSTRUCTW PatternStruct;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    CHAR FullKeyName[MEMDB_MAX];
    CHAR KeyName[MEMDB_MAX];
    UINT Value;
    UINT Flags;
    KEYHANDLE KeyHandle;
    BOOL EndPoint;

    // internally maintained members
    MEMDB_ENUMW UnicodeEnum;
} MEMDB_ENUMA, *PMEMDB_ENUMA;


//
// Function prototypes
//

BOOL
MemDbInitializeExA (
    IN      PCSTR DatabasePath  OPTIONAL
    );
#define MemDbInitializeA() MemDbInitializeExA(NULL)

BOOL
MemDbInitializeExW (
    IN      PCWSTR DatabasePath  OPTIONAL
    );
#define MemDbInitializeW() MemDbInitializeExW(NULL)

VOID
MemDbTerminateEx (
    IN      BOOL EraseDatabasePath
    );
#define MemDbTerminate() MemDbTerminateEx(FALSE)

PVOID
MemDbGetMemory (
    IN      UINT Size
    );

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    );

KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyName
    );

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    );

BOOL
MemDbDeleteTreeW (
    IN      PCWSTR KeyName
    );

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    );

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer          OPTIONAL
    );

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer          OPTIONAL
    );

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    );

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    );

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsW (
    IN      PCWSTR KeyName,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

BOOL
MemDbGetValueAndFlagsByHandle (
    IN      KEYHANDLE KeyHandle,
    OUT     PUINT Value,
    OUT     PUINT Flags
    );

#define MemDbSetValueAndFlagsA(k,v,s,c) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsW(k,v,s,c) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,s,c)
#define MemDbSetValueAndFlagsByHandle(h,v,s,c) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,s,c)

#define MemDbSetValueA(k,v) MemDbSetValueAndFlagsExA(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueW(k,v) MemDbSetValueAndFlagsExW(k,TRUE,v,FALSE,0,0)
#define MemDbSetValueByHandle(h,v) MemDbSetValueAndFlagsByHandleEx(h,TRUE,v,FALSE,0,0)
#define MemDbGetValueA(k,v) MemDbGetValueAndFlagsA(k,v,NULL)
#define MemDbGetValueW(k,v) MemDbGetValueAndFlagsW(k,v,NULL)
#define MemDbGetValueByHandle(h,v) MemDbGetValueAndFlagsByHandle(h,v,NULL)

#define MemDbTestKeyA(k)  MemDbGetValueAndFlagsA(k,NULL,NULL)
#define MemDbTestKeyW(k)  MemDbGetValueAndFlagsW(k,NULL,NULL)
#define MemDbTestKeyByHandle(h) MemDbGetValueAndFlagsByHandle(h,NULL,NULL)

#define MemDbSetFlagsA(k,s,c) MemDbSetValueAndFlagsExA(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsW(k,s,c) MemDbSetValueAndFlagsExW(k,FALSE,0,FALSE,s,c)
#define MemDbSetFlagsByHandle(h,s,c) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,FALSE,s,c)
#define MemDbReplaceFlagsA(k,f) MemDbSetValueAndFlagsExA(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsW(k,f) MemDbSetValueAndFlagsExW(k,FALSE,0,TRUE,f,0)
#define MemDbReplaceFlagsByHandle(h,f) MemDbSetValueAndFlagsByHandleEx(h,FALSE,0,TRUE,f,0)
#define MemDbGetFlagsA(k,f) MemDbGetValueAndFlagsA(k,NULL,f)
#define MemDbGetFlagsW(k,f) MemDbGetValueAndFlagsW(k,NULL,f)
#define MemDbGetFlagsByHandle(h,f) MemDbGetValueAndFlagsByHandle(h,NULL,f)

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN OUT  PGROWBUFFER Buffer,     OPTIONAL
    OUT     PUINT DataSize          OPTIONAL
    );

BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    );

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    );

//
// High-level BLOB functions
//
#define MemDbAddUnorderedBlobA(k,i,d,s)  MemDbAddDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobW(k,i,d,s)  MemDbAddDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbAddUnorderedBlobByKeyHandle(h,i,d,s) MemDbAddDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobA(k,i,d,s)  MemDbSetDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobW(k,i,d,s)  MemDbSetDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbSetUnorderedBlobByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,d,s)
#define MemDbSetUnorderedBlobByKeyHandle(h,i,d,s) MemDbSetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobA(k,i,d,s)  MemDbGrowDataA(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobW(k,i,d,s)  MemDbGrowDataW(k,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGrowUnorderedBlobByDataHandle(h,d,s) MemDbGrowDataByDataHandle(h,d,s)
#define MemDbGrowUnorderedBlobByKeyHandle(h,i,d,s) MemDbGrowDataByKeyHandle(h,DATAFLAG_UNORDERED,i,d,s)
#define MemDbGetUnorderedBlobHandleA(k,i) MemDbGetDataHandleA(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobHandleW(k,i) MemDbGetDataHandleW(k,DATAFLAG_UNORDERED,i)
#define MemDbGetUnorderedBlobA(k,i,s) MemDbGetDataA(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobW(k,i,s) MemDbGetDataW(k,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobExA(k,i,b,s) MemDbGetDataExA(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobExW(k,i,b,s) MemDbGetDataExW(k,DATAFLAG_UNORDERED,i,b,s)
#define MemDbGetUnorderedBlobByDataHandle(h,s) MemDbGetDataByDataHandle(h,s)
#define MemDbGetUnorderedBlobByDataHandleEx(h,b,s) MemDbGetDataByDataHandle(h,b,s)
#define MemDbGetUnorderedBlobByKeyHandle(h,i,s) MemDbGetDataByKeyHandle(h,DATAFLAG_UNORDERED,i,s)
#define MemDbGetUnorderedBlobByKeyHandleEx(h,i,b,s) MemDbGetDataByKeyHandleEx(h,DATAFLAG_UNORDERED,i,b,s)
#define MemDbDeleteUnorderedBlobA(k,i) MemDbDeleteDataA(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobW(k,i) MemDbDeleteDataW(k,DATAFLAG_UNORDERED,i);
#define MemDbDeleteUnorderedBlobByDataHandle(h) MemDbDeleteDataByDataHandle(h)
#define MemDbDeleteUnorderedBlobByKeyHandle(h,i) MemDbDeleteDataByKeyHandle(h,DATAFLAG_UNORDERED,i)

//
// low-level linkage functions
//
DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

#define MemDbSetLinkageArrayA(k,t,i,d,s) MemDbSetDataA(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayW(k,t,i,d,s) MemDbSetDataW(k,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByKeyHandle(h,t,i,d,s) MemDbSetDataByKeyHandle(h,t,i,(PCBYTE)d,s)
#define MemDbSetLinkageArrayByDataHandle(h,d,s) MemDbSetDataByDataHandle(h,(PCBYTE)d,s)
#define MemDbGetLinkageArrayA(k,t,i,s) (PUINT)MemDbGetDataA(k,t,i,s)
#define MemDbGetLinkageArrayW(k,t,i,s) (PUINT)MemDbGetDataW(k,t,i,s)
#define MemDbGetLinkageArrayByKeyHandle(h,t,i,s) (PUINT)MemDbGetDataByKeyHandle(h,t,i,s)
#define MemDbGetLinkageArrayByKeyHandleEx(h,t,i,b,s) (PUINT)MemDbGetDataByKeyHandleEx(h,t,i,b,s)
#define MemDbGetLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetDataByDataHandle(h,s)
#define MemDbGetLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetDataByDataHandleEx(h,b,s)

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    );

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    );

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    );

// high-level linkage functions
#define MemDbAddSingleLinkageValueA(k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueW(k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,a)
#define MemDbAddSingleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteSingleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_SINGLELINK,i,l,f)
#define MemDbDeleteSingleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetSingleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,d,s)
#define MemDbSetSingleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetSingleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_SINGLELINK,i,s)
#define MemDbGetSingleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_SINGLELINK,i,b,s)
#define MemDbGetSingleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetSingleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestSingleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddDoubleLinkageValueA (k,i,l,a) MemDbAddLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueW (k,i,l,a) MemDbAddLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByKeyHandle(k,i,l,a) MemDbAddLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,a)
#define MemDbAddDoubleLinkageValueByDataHandle(h,l,a) MemDbAddLinkagaValueByDataHandle(h,l,a)
#define MemDbDeleteDoubleLinkageValueA(k,i,l,f) MemDbDeleteLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueW(k,i,l,f) MemDbDeleteLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByKeyHandle(k,i,l,f) MemDbDeleteLinkageValueByKeyHandle(k,DATAFLAG_DOUBLELINK,i,l,f)
#define MemDbDeleteDoubleLinkageValueByDataHandle(h,l,f) MemDbDeleteLinkagaValueByDataHandle(h,l,f)
#define MemDbSetDoubleLinkageArrayA(k,i,d,s) MemDbSetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayW(k,i,d,s) MemDbSetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByKeyHandle(h,i,d,s) MemDbSetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,d,s)
#define MemDbSetDoubleLinkageArrayByDataHandle(h,d,s) MemDbSetLinkageArrayByDataHandle(h,d,s)
#define MemDbGetDoubleLinkageArrayA(k,i,s) (PUINT)MemDbGetLinkageArrayA(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayW(k,i,s) (PUINT)MemDbGetLinkageArrayW(k,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandle(h,i,s) (PUINT)MemDbGetLinkageArrayByKeyHandle(h,DATAFLAG_DOUBLELINK,i,s)
#define MemDbGetDoubleLinkageArrayByKeyHandleEx(h,i,b,s) (PUINT)MemDbGetLinkageArrayByKeyHandleEx(h,DATAFLAG_DOUBLELINK,i,b,s)
#define MemDbGetDoubleLinkageArrayByDataHandle(h,s) (PUINT)MemDbGetLinkageArrayByDataHandle(h,s)
#define MemDbGetDoubleLinkageArrayByDataHandleEx(h,b,s) (PUINT)MemDbGetLinkageArrayByDataHandleEx(h,b,s)
#define MemDbTestDoubleLinkageValueA(k,i,l) MemDbTestLinkageValueA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueW(k,i,l) MemDbTestLinkageValueW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByKeyHandle(h,i,l) MemDbTestLinkageValueByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageValueByDataHandle(h,l) MemDbTestLinkageValueByDataHandle(h,l)

#define MemDbAddSingleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbAddSingleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbDeleteSingleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)
#define MemDbGetSingleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_SINGLELINK,i,l)
#define MemDbGetSingleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_SINGLELINK,i,l)
#define MemDbTestSingleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_SINGLELINK,i)
#define MemDbTestSingleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_SINGLELINK,i)

#define MemDbAddDoubleLinkageA(k1,k2,i) MemDbAddLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageW(k1,k2,i) MemDbAddLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbAddDoubleLinkageByKeyHandle(h1,h2,i) MemDbAddLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageA(k1,k2,i) MemDbDeleteLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageW(k1,k2,i) MemDbDeleteLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbDeleteDoubleLinkageByKeyHandle(h1,h2,i) MemDbDeleteLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)
#define MemDbGetDoubleLinkageA(k,i,l) MemDbGetLinkageA(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageW(k,i,l) MemDbGetLinkageW(k,DATAFLAG_DOUBLELINK,i,l)
#define MemDbGetDoubleLinkageByKeyHandle(h,i,l) MemDbGetLinkageByKeyHandle(h,DATAFLAG_DOUBLELINK,i,l)
#define MemDbTestDoubleLinkageA(k1,k2,i) MemDbTestLinkageA(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageW(k1,k2,i) MemDbTestLinkageW(k1,k2,DATAFLAG_DOUBLELINK,i)
#define MemDbTestDoubleLinkageByKeyHandle(h1,h2,i) MemDbTestLinkageByKeyHandle(h1,h2,DATAFLAG_DOUBLELINK,i)

// enumeration functions
BOOL
RealMemDbEnumFirstExA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    );

#define MemDbEnumFirstExA(m,p,f,b,e,s)  TRACK_BEGIN(BOOL, MemDbEnumFirstExA)\
                                        RealMemDbEnumFirstExA(m,p,f,b,e,s)\
                                        TRACK_END()

#define MemDbEnumFirstA(e,p,f,l1,l2)    MemDbEnumFirstExA(e,p,f,l1,l2,NULL)

BOOL
RealMemDbEnumFirstExW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    );

#define MemDbEnumFirstExW(m,p,f,b,e,s)  TRACK_BEGIN(BOOL, MemDbEnumFirstExW)\
                                        RealMemDbEnumFirstExW(m,p,f,b,e,s)\
                                        TRACK_END()

#define MemDbEnumFirstW(e,p,f,l1,l2)    MemDbEnumFirstExW(e,p,f,l1,l2,NULL)

BOOL
RealMemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

#define MemDbEnumNextA(m)  TRACK_BEGIN(BOOL, MemDbEnumNextA)\
                           RealMemDbEnumNextA(m)\
                           TRACK_END()

BOOL
RealMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

#define MemDbEnumNextW(m)  TRACK_BEGIN(BOOL, MemDbEnumNextW)\
                           RealMemDbEnumNextW(m)\
                           TRACK_END()

BOOL
MemDbAbortEnumA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    );

BOOL
MemDbAbortEnumW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    );

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    );

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    );

BOOL
MemDbSetInsertionOrderedByKeyHandle (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbMoveKeyHandleToEnd (
    IN      KEYHANDLE KeyHandle
    );

BOOL
MemDbSaveA (
    IN      PCSTR szFile
    );

BOOL
MemDbSaveW (
    IN      PCWSTR szFile
    );

BOOL
MemDbLoadA (
    IN      PCSTR szFile
    );

BOOL
MemDbLoadW (
    IN      PCWSTR szFile
    );

BOOL
MemDbValidateDatabase (
    VOID
    );

BOOL
MemDbQueryVersionA (
    IN      PCSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbQueryVersionW (
    IN      PCWSTR FileName,
    OUT     PMEMDB_VERSION Version
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );

PCBYTE
MemDbGetDatabaseAddress (
    VOID
    );

UINT
MemDbGetDatabaseSize (
    VOID
    );

#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, UINT Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, UINT Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, UINT Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);


#ifdef DEBUG
extern UINT g_DatabaseCheckLevel;
#define MEMDB_CHECKLEVEL1      0x000001
#define MEMDB_CHECKLEVEL2      0x000002
#define MEMDB_CHECKLEVEL3      0x000003

BOOL MemDbCheckDatabase(UINT Level);
#else
#define MemDbCheckDatabase()
#endif

//
// A & W
//

#ifdef UNICODE

#define MemDbInitialize MemDbInitializeW
#define MemDbInitializeEx MemDbInitializeExW
#define MemDbAddKey MemDbAddKeyW
#define MemDbSetKey MemDbSetKeyW
#define MemDbTestKey MemDbTestKeyW
#define MemDbDeleteKey MemDbDeleteKeyW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleW
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExW
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyW
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetValue MemDbSetValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbSetFlags MemDbSetFlagsW
#define MemDbReplaceFlags MemDbReplaceFlagsW
#define MemDbGetFlags MemDbGetFlagsW
#define MemDbAddData MemDbAddDataW
#define MemDbSetData MemDbSetDataW
#define MemDbGrowData MemDbGrowDataW
#define MemDbGetDataHandle MemDbGetDataHandleW
#define MemDbGetData MemDbGetDataW
#define MemDbGetDataEx MemDbGetDataExW
#define MemDbDeleteData MemDbDeleteDataW
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobW
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobW
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobW
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobW
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExW
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobW
#define MemDbAddLinkageValue MemDbAddLinkageValueW
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueW
#define MemDbSetLinkageArray MemDbSetLinkageArrayW
#define MemDbGetLinkageArray MemDbGetLinkageArrayW
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueW
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueW
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayW
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayW
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueW
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueW
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayW
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayW
#define MemDbTestLinkageValue MemDbTestLinkageValueW
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueW
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueW
#define MemDbAddLinkage MemDbAddLinkageW
#define MemDbGetLinkage MemDbGetLinkageW
#define MemDbTestLinkage MemDbTestLinkageW
#define MemDbAddSingleLinkage MemDbAddSingleLinkageW
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageW
#define MemDbGetSingleLinkage MemDbGetSingleLinkageW
#define MemDbTestSingleLinkage MemDbTestSingleLinkageW
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageW
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageW
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageW
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageW
#define MemDbEnumFirst MemDbEnumFirstW
#define MemDbEnumFirstEx MemDbEnumFirstExW
#define MemDbEnumNext MemDbEnumNextW
#define MemDbAbortEnum MemDbAbortEnumW
#define MEMDB_ENUM MEMDB_ENUMW
#define PMEMDB_ENUM PMEMDB_ENUMW

#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedW


#else

#define MemDbInitialize MemDbInitializeA
#define MemDbInitializeEx MemDbInitializeExA
#define MemDbAddKey MemDbAddKeyA
#define MemDbSetKey MemDbSetKeyA
#define MemDbTestKey MemDbTestKeyA
#define MemDbDeleteKey MemDbDeleteKeyA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbGetKeyFromHandle MemDbGetKeyFromHandleA
#define MemDbGetKeyFromHandleEx MemDbGetKeyFromHandleExA
#define MemDbGetHandleFromKey MemDbGetHandleFromKeyA
#define MemDbSetValueAndFlagsEx MemDbSetValueAndFlagsExA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetValue MemDbSetValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbSetFlags MemDbSetFlagsA
#define MemDbReplaceFlags MemDbReplaceFlagsA
#define MemDbGetFlags MemDbGetFlagsA
#define MemDbAddData MemDbAddDataA
#define MemDbSetData MemDbSetDataA
#define MemDbGrowData MemDbGrowDataA
#define MemDbGetDataHandle MemDbGetDataHandleA
#define MemDbGetData MemDbGetDataA
#define MemDbGetDataEx MemDbGetDataExA
#define MemDbDeleteData MemDbDeleteDataA
#define MemDbAddUnorderedBlob MemDbAddUnorderedBlobA
#define MemDbSetUnorderedBlob MemDbSetUnorderedBlobA
#define MemDbGrowUnorderedBlob MemDbGrowUnorderedBlobA
#define MemDbGetUnorderedBlob MemDbGetUnorderedBlobA
#define MemDbGetUnorderedBlobEx MemDbGetUnorderedBlobExA
#define MemDbDeleteUnorderedBlob MemDbDeleteUnorderedBlobA
#define MemDbAddLinkageValue MemDbAddLinkageValueA
#define MemDbDeleteLinkageValue MemDbDeleteLinkageValueA
#define MemDbSetLinkageArray MemDbSetLinkageArrayA
#define MemDbGetLinkageArray MemDbGetLinkageArrayA
#define MemDbAddSingleLinkageValue MemDbAddSingleLinkageValueA
#define MemDbDeleteSingleLinkageValue MemDbDeleteSingleLinkageValueA
#define MemDbSetSingleLinkageArray MemDbSetSingleLinkageArrayA
#define MemDbGetSingleLinkageArray MemDbGetSingleLinkageArrayA
#define MemDbAddDoubleLinkageValue MemDbAddDoubleLinkageValueA
#define MemDbDeleteDoubleLinkageValue MemDbDeleteDoubleLinkageValueA
#define MemDbSetDoubleLinkageArray MemDbSetDoubleLinkageArrayA
#define MemDbGetDoubleLinkageArray MemDbGetDoubleLinkageArrayA
#define MemDbTestLinkageValue MemDbTestLinkageValueA
#define MemDbTestSingleLinkageValue MemDbTestSingleLinkageValueA
#define MemDbTestDoubleLinkageValue MemDbTestDoubleLinkageValueA
#define MemDbAddLinkage MemDbAddLinkageA
#define MemDbGetLinkage MemDbGetLinkageA
#define MemDbTestLinkage MemDbTestLinkageA
#define MemDbAddSingleLinkage MemDbAddSingleLinkageA
#define MemDbDeleteSingleLinkage MemDbDeleteSingleLinkageA
#define MemDbGetSingleLinkage MemDbGetSingleLinkageA
#define MemDbTestSingleLinkage MemDbTestSingleLinkageA
#define MemDbAddDoubleLinkage MemDbAddDoubleLinkageA
#define MemDbDeleteDoubleLinkage MemDbDeleteDoubleLinkageA
#define MemDbGetDoubleLinkage MemDbGetDoubleLinkageA
#define MemDbTestDoubleLinkage MemDbTestDoubleLinkageA
#define MemDbEnumFirst MemDbEnumFirstA
#define MemDbEnumFirstEx MemDbEnumFirstExA
#define MemDbEnumNext MemDbEnumNextA
#define MemDbAbortEnum MemDbAbortEnumA
#define MEMDB_ENUM MEMDB_ENUMA
#define PMEMDB_ENUM PMEMDB_ENUMA

#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#define MemDbSetInsertionOrdered MemDbSetInsertionOrderedA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\objstr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.h

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/


//
// Types
//

typedef PCTSTR  ENCODEDSTRHANDLE;

typedef enum {
    OBSPF_EXACTNODE             = 0x0001,
    OBSPF_NODEISROOTPLUSSTAR    = 0x0002,
    OBSPF_OPTIONALNODE          = 0x0004,
    OBSPF_NOLEAF                = 0x0008,
    OBSPF_EXACTLEAF             = 0x0010,
    OBSPF_OPTIONALLEAF          = 0x0020,
} OBSP_FLAGS;

typedef struct TAG_OBSPARSEDPATTERNA {
    PPARSEDPATTERNA     NodePattern;
    PPARSEDPATTERNA     LeafPattern;
    PSTR                ExactRoot;
    DWORD               ExactRootBytes;
    PCSTR               Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
    PMHANDLE            Pool;
} OBSPARSEDPATTERNA, *POBSPARSEDPATTERNA;

typedef struct TAG_OBSPARSEDPATTERNW {
    PPARSEDPATTERNW     NodePattern;
    PPARSEDPATTERNW     LeafPattern;
    PWSTR               ExactRoot;
    DWORD               ExactRootBytes;
    PCWSTR              Leaf;
    DWORD               MinNodeLevel;
    DWORD               MaxNodeLevel;
    DWORD               MaxSubLevel;
    DWORD               Flags;
    PMHANDLE            Pool;
} OBSPARSEDPATTERNW, *POBSPARSEDPATTERNW;

//
// APIs
//

BOOL
ObsInitialize (
    VOID
    );

VOID
ObsTerminate (
    VOID
    );

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    );

VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    );

BOOL
ObsEncodeStringExA (
    PSTR Destination,
    PCSTR Source,
    PCSTR CharsToEncode
    );

#define ObsEncodeStringA(d,s) ObsEncodeStringExA(d,s,NULL)

BOOL
ObsEncodeStringExW (
    PWSTR Destination,
    PCWSTR Source,
    PCWSTR CharsToEncode
    );

#define ObsEncodeStringW(d,s) ObsEncodeStringExW(d,s,NULL)

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    );

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    );

BOOL
RealObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PCSTR* DecodedNode,         OPTIONAL
    OUT     PCSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringExA(o,n,l,p,s)  TRACK_BEGIN(BOOL, ObsSplitObjectStringExA)\
                                            RealObsSplitObjectStringExA(o,n,l,p,s)\
                                            TRACK_END()

#define ObsSplitObjectStringA(o,n,l)    ObsSplitObjectStringExA(o,n,l,NULL,TRUE)

BOOL
RealObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PCWSTR* DecodedNode,        OPTIONAL
    OUT     PCWSTR* DecodedLeaf,        OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    );

#define ObsSplitObjectStringExW(o,n,l,p,s)  TRACK_BEGIN(BOOL, ObsSplitObjectStringExW)\
                                            RealObsSplitObjectStringExW(o,n,l,p,s)\
                                            TRACK_END()

#define ObsSplitObjectStringW(o,n,l)    ObsSplitObjectStringExW(o,n,l,NULL,TRUE)

BOOL
ObsHasNodeA (
    IN      PCSTR EncodedObject
    );

BOOL
ObsHasNodeW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsGetLeafPortionOfEncodedStringA (
    IN      PCSTR EncodedObject
    );

PCWSTR
ObsGetLeafPortionOfEncodedStringW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsGetNodeLeafDividerA (
    IN      PCSTR EncodedObject
    );

PCWSTR
ObsGetNodeLeafDividerW (
    IN      PCWSTR EncodedObject
    );

PCSTR
ObsFindNonEncodedCharInEncodedStringA (
    IN      PCSTR String,
    IN      MBCHAR Char
    );

PCWSTR
ObsFindNonEncodedCharInEncodedStringW (
    IN      PCWSTR String,
    IN      WCHAR Char
    );

PSTR
ObsBuildEncodedObjectStringFromPatternA (
    IN      POBSPARSEDPATTERNA Pattern
    );

PWSTR
ObsBuildEncodedObjectStringFromPatternW (
    IN      POBSPARSEDPATTERNW Pattern
    );

PSTR
RealObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringExA(n,l,e)   TRACK_BEGIN(PSTR, ObsBuildEncodedObjectStringExA)\
                                                RealObsBuildEncodedObjectStringExA(n,l,e)\
                                                TRACK_END()

#define ObsBuildEncodedObjectStringA(node,leaf) ObsBuildEncodedObjectStringExA(node,leaf,FALSE)

PSTR
ObsBuildPartialEncodedObjectStringExA (
    IN      PCSTR DecodedNode,
    IN      PCSTR DecodedLeaf,          OPTIONAL
    IN      BOOL EncodeString
    );

PWSTR
RealObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

#define ObsBuildEncodedObjectStringExW(n,l,e)   TRACK_BEGIN(PWSTR, ObsBuildEncodedObjectStringExW)\
                                                RealObsBuildEncodedObjectStringExW(n,l,e)\
                                                TRACK_END()

#define ObsBuildEncodedObjectStringW(node,leaf) ObsBuildEncodedObjectStringExW(node,leaf,FALSE)

PWSTR
ObsBuildPartialEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,         OPTIONAL
    IN      BOOL EncodeString
    );

POBSPARSEDPATTERNA
RealObsCreateParsedPatternExA (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternExA(p,o,m) TRACK_BEGIN(POBSPARSEDPATTERNA, ObsCreateParsedPatternExA)\
                                         RealObsCreateParsedPatternExA(p,o,m)\
                                         TRACK_END()

#define ObsCreateParsedPatternA(obj)     ObsCreateParsedPatternExA (NULL,obj,FALSE)

POBSPARSEDPATTERNW
RealObsCreateParsedPatternExW (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    );

#define ObsCreateParsedPatternExW(p,o,m) TRACK_BEGIN(POBSPARSEDPATTERNW, ObsCreateParsedPatternExW)\
                                         RealObsCreateParsedPatternExW(p,o,m)\
                                         TRACK_END()

#define ObsCreateParsedPatternW(obj)     ObsCreateParsedPatternExW (NULL,obj,FALSE)

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    );

VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    );

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    );

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    );

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,
    IN      PCWSTR Leaf                         OPTIONAL
    );

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    );

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    );

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    );

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    );

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    );

//
// Macros
//

#ifdef UNICODE

#define OBSPARSEDPATTERN                        OBSPARSEDPATTERNW
#define POBSPARSEDPATTERN                       POBSPARSEDPATTERNW

#define ObsFree                                 ObsFreeW
#define ObsEncodeStringEx                       ObsEncodeStringExW
#define ObsEncodeString                         ObsEncodeStringW
#define ObsDecodeString                         ObsDecodeStringW
#define ObsSplitObjectString                    ObsSplitObjectStringW
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExW
#define ObsHasNode                              ObsHasNodeW
#define ObsGetLeafPortionOfEncodedString        ObsGetLeafPortionOfEncodedStringW
#define ObsGetNodeLeafDivider                   ObsGetNodeLeafDividerW
#define ObsFindNonEncodedCharInEncodedString    ObsFindNonEncodedCharInEncodedStringW
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternW
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExW
#define ObsBuildPartialEncodedObjectStringEx    ObsBuildPartialEncodedObjectStringExW
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringW
#define ObsCreateParsedPattern                  ObsCreateParsedPatternW
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExW
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternW
#define ObsParsedPatternMatch                   ObsParsedPatternMatchW
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExW
#define ObsPatternMatch                         ObsPatternMatchW
#define ObsIsPatternContained                   ObsIsPatternContainedW
#define ObsGetPatternLevels                     ObsGetPatternLevelsW
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternW

#else

#define OBSPARSEDPATTERN                        OBSPARSEDPATTERNA
#define POBSPARSEDPATTERN                       POBSPARSEDPATTERNA

#define ObsFree                                 ObsFreeA
#define ObsEncodeStringEx                       ObsEncodeStringExA
#define ObsEncodeString                         ObsEncodeStringA
#define ObsDecodeString                         ObsDecodeStringA
#define ObsSplitObjectString                    ObsSplitObjectStringA
#define ObsSplitObjectStringEx                  ObsSplitObjectStringExA
#define ObsHasNode                              ObsHasNodeA
#define ObsGetLeafPortionOfEncodedString        ObsGetLeafPortionOfEncodedStringA
#define ObsGetNodeLeafDivider                   ObsGetNodeLeafDividerA
#define ObsFindNonEncodedCharInEncodedString    ObsFindNonEncodedCharInEncodedStringA
#define ObsBuildEncodedObjectStringFromPattern  ObsBuildEncodedObjectStringFromPatternA
#define ObsBuildEncodedObjectStringEx           ObsBuildEncodedObjectStringExA
#define ObsBuildPartialEncodedObjectStringEx    ObsBuildPartialEncodedObjectStringExA
#define ObsBuildEncodedObjectString             ObsBuildEncodedObjectStringA
#define ObsCreateParsedPattern                  ObsCreateParsedPatternA
#define ObsCreateParsedPatternEx                ObsCreateParsedPatternExA
#define ObsDestroyParsedPattern                 ObsDestroyParsedPatternA
#define ObsParsedPatternMatch                   ObsParsedPatternMatchA
#define ObsParsedPatternMatchEx                 ObsParsedPatternMatchExA
#define ObsPatternMatch                         ObsPatternMatchA
#define ObsIsPatternContained                   ObsIsPatternContainedA
#define ObsGetPatternLevels                     ObsGetPatternLevelsA
#define ObsPatternIncludesPattern               ObsPatternIncludesPatternA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)          LogBegin(g_hInst);                      \
                                LogIfA(                                 \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );                                      \
                                LogEnd()

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR  "Fatal Error"
#define LOG_MODULE_ERROR "Module Error"
#define LOG_ERROR        "Error"
#define LOG_WARNING      "Warning"
#define LOG_INFORMATION  "Info"
#define LOG_STATUS       "Status"
#define LOG_UPDATE       "Update"

typedef enum {
    LOGSEV_DEBUG = 0,
    LOGSEV_INFORMATION = 1,
    LOGSEV_WARNING = 2,
    LOGSEV_ERROR = 3,
    LOGSEV_FATAL_ERROR = 4
} LOGSEVERITY;

typedef struct {
    BOOL Debug;
    HMODULE ModuleInstance;
    LOGSEVERITY Severity;       // non-debug only
    PCSTR Type;
    PCSTR Message;              // debug only
    PCSTR FormattedMessage;
} LOGARGA, *PLOGARGA;

typedef struct {
    BOOL Debug;
    HMODULE ModuleInstance;
    LOGSEVERITY Severity;       // non-debug only
    PCSTR Type;                 // note ansi type
    PCWSTR Message;             // debug only
    PCWSTR FormattedMessage;
} LOGARGW, *PLOGARGW;

typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
} OUTPUT_DESTINATION;

typedef enum {
    LL_FATAL_ERROR = 0x01,
    LL_MODULE_ERROR = 0x02,
    LL_ERROR = 0x04,
    LL_WARNING = 0x08,
    LL_INFORMATION = 0x10,
    LL_STATUS = 0x20,
    LL_UPDATE = 0x40,
} LOG_LEVEL;

typedef BOOL (WINAPI LOGCALLBACKA)(PLOGARGA Args);
typedef LOGCALLBACKA * PLOGCALLBACKA;

typedef BOOL (WINAPI LOGCALLBACKW)(PLOGARGW Args);
typedef LOGCALLBACKW * PLOGCALLBACKW;

VOID
LogBegin (
    IN      HMODULE ModuleInstance
    );

VOID
LogEnd (
    VOID
    );

BOOL
LogReInitA (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallback   OPTIONAL
    );

BOOL
LogReInitW (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCWSTR LogFile,             OPTIONAL
    IN      PLOGCALLBACKW LogCallback   OPTIONAL
    );

VOID
LogSetVerboseLevel (
    IN      OUTPUT_DESTINATION Level
    );

VOID
LogSetVerboseBitmap (
    IN      LOG_LEVEL Bitmap,
    IN      LOG_LEVEL BitsToAdjustMask,
    IN      BOOL EnableDebugger
    );

#ifdef UNICODE

#define LOGARG          LOGARGW
#define LOGCALLBACK     LOGCALLBACKW
#define PLOGARG         PLOGARGW
#define PLOGCALLBACK    PLOGCALLBACKW

#define LogReInit       LogReInitW

#else

#define LOGARG          LOGARGA
#define LOGCALLBACK     LOGCALLBACKA
#define PLOGARG         PLOGARGA
#define PLOGCALLBACK    PLOGCALLBACKA

#define LogReInit       LogReInitA

#endif

VOID
LogDeleteOnNextInit(
    VOID
    );

#define SET_RESETLOG()   LogDeleteOnNextInit()

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

BOOL
LogSetErrorDest (
    IN      PCSTR Type,
    IN      OUTPUT_DESTINATION OutDest
    );

// Define W symbols

extern HMODULE g_hInst;

#define LOGW(x) LogBegin(g_hInst);LogW x;LogEnd()
#define LOGW_IF(x) LogBegin(g_hInst);LogIfW x;LogEnd()
#define ELSE_LOGW(x) else {LogBegin(g_hInst);LogW x;LogEnd();}
#define ELSE_LOGW_IF(x) else {LogBegin(g_hInst);LogIfW x;LogEnd();}
#define LOGTITLEW(type,title) LogBegin(g_hInst);LogTitleW (type,title);LogEnd()
#define LOGLINEW(title) LogBegin(g_hInst);LogLineW (title);LogEnd()
#define LOGDIRECTW(type,text) LogBegin(g_hInst);LogDirectW (type,text);LogEnd()

// Define A symbols

#define LOGA(x) LogBegin(g_hInst);LogA x;LogEnd()
#define LOGA_IF(x) LogBegin(g_hInst);LogIfA x;LogEnd()
#define ELSE_LOGA(x) else {LogBegin(g_hInst);LogA x;LogEnd();}
#define ELSE_LOGA_IF(x) else {LogBegin(g_hInst);LogIfA x;LogEnd();}
#define LOGTITLEA(type,title) LogBegin(g_hInst);LogTitleA (type,title);LogEnd()
#define LOGLINEA(line) LogBegin(g_hInst);LogLineA (line);LogEnd()
#define LOGDIRECTA(type,text) LogBegin(g_hInst);LogDirectA (type,text);LogEnd()

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"


VOID
_cdecl
DbgLogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DbgLogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
DbgDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
DbgDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );


VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

VOID
LogCopyDebugInfPathA(
    OUT     PSTR MaxPathBuffer
    );

VOID
LogCopyDebugInfPathW(
    OUT     PWSTR MaxPathBuffer
    );


// Define W symbols

#define DEBUGMSGW(x) LogBegin(g_hInst);DbgLogW x;LogEnd()
#define DEBUGMSGW_IF(x) LogBegin(g_hInst);DbgLogIfW x;LogEnd()
#define ELSE_DEBUGMSGW(x) else {LogBegin(g_hInst);DbgLogW x;LogEnd();}
#define ELSE_DEBUGMSGW_IF(x) else {LogBegin(g_hInst);DbgLogW x;LogEnd();}
#define DEBUGLOGTIMEW(x) LogBegin(g_hInst);DebugLogTimeW x;LogEnd()
#define DEBUGDIRECTW(type,text) LogBegin(g_hInst);DbgDirectW (type,text);LogEnd()


// Define A symbols

#define DEBUGMSGA(x) LogBegin(g_hInst);DbgLogA x;LogEnd()
#define DEBUGMSGA_IF(x) LogBegin(g_hInst);DbgLogIfA x;LogEnd()
#define ELSE_DEBUGMSGA(x) else {LogBegin(g_hInst);DbgLogA x;LogEnd();}
#define ELSE_DEBUGMSGA_IF(x) else {LogBegin(g_hInst);DbgLogIfA x;LogEnd();}
#define DEBUGLOGTIMEA(x) LogBegin(g_hInst);DebugLogTimeA x;LogEnd()
#define DEBUGDIRECTA(type,text) LogBegin(g_hInst);DbgDirectA (type,text);LogEnd()

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)
#define DEBUGDIRECT(type,text) DEBUGDIRECTW(type,text)
#define LogCopyDebugInfPath LogCopyDebugInfPathW

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)
#define DEBUGDIRECT(type,text) DEBUGDIRECTA(type,text)
#define LogCopyDebugInfPath LogCopyDebugInfPathA

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#define DEBUGLOGTIME(x)

#define DEBUGDIRECTA(type,text)
#define DEBUGDIRECTW(type,text)
#define DEBUGDIRECT(type,text)

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

/*++

  Create and destroy routines:

    PMHANDLE
    PmCreatePoolEx (
        IN      DWORD BlockSize     OPTIONAL
        );

    PMHANDLE
    PmCreateNamedPoolEx (
        IN      PCSTR Name,
        IN      DWORD BlockSize     OPTIONAL
        );

    VOID
    PmDestroyPool (
        IN      PMHANDLE Handle
        );

  Primitive routines:

    PVOID
    PmGetMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PmGetAlignedMemory (
        IN      PMHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PmReleaseMemory (
        IN      PMHANDLE Handle,
        IN      PCVOID Memory
        );

  Performance and debugging control:

    VOID
    PmSetMinimumGrowthSize (
        IN      PMHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PmEmptyPool (
        IN      PMHANDLE Handle
        );

    VOID
    PmDisableTracking (
        IN      PMHANDLE Handle
        );

    VOID
    PmDumpStatistics (
        VOID
        );

  Allocation and duplication of data types:

    PCTSTR
    PmCreateString (
        IN      PMHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PmCreateDword (
        IN      PMHANDLE Handle
        );

    PBYTE
    PmDuplicateMemory (
        IN      PMHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PmDuplciateDword (
        IN      PMHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PmDuplicateString (
        IN      PMHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PmDuplicateMultiSz (
        IN      PMHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PmSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PmReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

PMHANDLE
RealPmCreatePoolEx (
    IN      DWORD BlockSize         OPTIONAL
    );

#define PmCreatePoolEx(b)           TRACK_BEGIN(PMHANDLE, PmCreatePoolEx)\
                                    RealPmCreatePoolEx(b)\
                                    TRACK_END()

#define PmCreatePool()              PmCreatePoolEx(0)

#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPoolEx (
    IN      PCSTR Name,
    IN      DWORD BlockSize         OPTIONAL
    );

#define PmCreateNamedPoolEx(n,b)    TRACK_BEGIN(PMHANDLE, PmCreateNamedPoolEx)\
                                    RealPmCreateNamedPoolEx(n,b)\
                                    TRACK_END()

#define PmCreateNamedPool(n)        PmCreateNamedPoolEx(n,0)

#else

#define PmCreateNamedPoolEx(n,b)    PmCreatePoolEx(b)

#define PmCreateNamedPool(n)        PmCreatePoolEx(0)

#endif

VOID
PmDestroyPool (
    IN PMHANDLE Handle
    );


//
// Callers should use PmGetMemory or PmGetAlignedMemory. These each decay into
// RealPmGetMemory.
//

PVOID
RealPmGetMemory (
    IN      PMHANDLE Handle,
    IN      SIZE_T Size,
    IN      DWORD AlignSize
    );

#define PmGetMemory(h,s)           TRACK_BEGIN(PVOID, PmGetMemory)\
                                   RealPmGetMemory((h),(s),0)\
                                   TRACK_END()

#define PmGetAlignedMemory(h,s)    TRACK_BEGIN(PVOID, PmGetAlignedMemory)\
                                   RealPmGetMemory((h),(s),sizeof(DWORD))\
                                   TRACK_END()

VOID PmReleaseMemory (IN PMHANDLE Handle, IN PCVOID Memory);
VOID PmSetMinimumGrowthSize(IN PMHANDLE Handle, IN SIZE_T Size);


VOID
PmEmptyPool (
    IN      PMHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PmCreateString(h,x) ((LPTSTR) PmGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PmCreateDword(h)    ((PDWORD) PmGetMemory((h),sizeof(DWORD)))


__inline
PBYTE
PmDuplicateMemory (
    IN PMHANDLE Handle,
    IN PCBYTE DataToCopy,
    IN UINT SizeOfData
    )
{
    PBYTE Data;

    Data = (PBYTE) PmGetAlignedMemory (Handle, SizeOfData);
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD
PmDuplicateDword (
    IN PMHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PmGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPmDuplicateStringA (
    IN PMHANDLE Handle,
    IN PCSTR StringToCopy
    )

{
    PSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringA (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyA (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringA(h,s)    TRACK_BEGIN(PSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringA(h,s)\
                                   TRACK_END()


__inline
PWSTR
RealPmDuplicateStringW (
    IN PMHANDLE Handle,
    IN PCWSTR StringToCopy
    )

{
    PWSTR rString = RealPmGetMemory (
                        Handle,
                        SizeOfStringW (StringToCopy),
                        sizeof(WCHAR)
                        );

    if (rString) {

        StringCopyW (rString, StringToCopy);
    }

    return rString;
}

#define PmDuplicateStringW(h,s)    TRACK_BEGIN(PWSTR, PmDuplicateStringA)\
                                   RealPmDuplicateStringW(h,s)\
                                   TRACK_END()


__inline
PSTR
RealPmDuplicateStringABA (
    IN PMHANDLE Handle,
    IN PCSTR StringStart,
    IN PCSTR End
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    // cast is OK, we don't expenct pointers to be far away from each other
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (CHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABA (rString, StringStart, End);
    }

    return rString;
}

#define PmDuplicateStringABA(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABA)\
                                        RealPmDuplicateStringABA(h,s,e)\
                                        TRACK_END()



__inline
PWSTR
RealPmDuplicateStringABW (
    IN PMHANDLE Handle,
    IN PCWSTR StringStart,
    IN PCWSTR End
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = RealPmGetMemory (
                    Handle,
                    (DWORD)((UBINT) End - (UBINT) StringStart) + sizeof (WCHAR),
                    sizeof(WCHAR)
                    );

    if (rString) {

        StringCopyABW (rString,StringStart,End);
    }

    return rString;
}

#define PmDuplicateStringABW(h,s,e)     TRACK_BEGIN(PSTR, PmDuplicateStringABW)\
                                        RealPmDuplicateStringABW(h,s,e)\
                                        TRACK_END()


PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    );

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    );

#ifdef UNICODE
#define PmDuplicateString  PmDuplicateStringW
#define PmDuplicateMultiSz PmDuplicateMultiSzW
#else
#define PmDuplicateString  PmDuplicateStringA
#define PmDuplicateMultiSz PmDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    );

VOID
PmDumpStatistics (
    VOID
    );

#else

#define PmDisableTracking(x)
#define PmDumpStatistics()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\linkpif.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    linkpif.h

Abstract:

    Implements routines to manage .LNK and .PIF files.  This
    is a complete redesign from the work that MikeCo did.

Author:

    Calin Negreanu (calinn)     23-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

typedef struct _LNK_EXTRA_DATAA {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    CHAR    FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAA, *PLNK_EXTRA_DATAA;

typedef struct _LNK_EXTRA_DATAW {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    WCHAR   FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAW, *PLNK_EXTRA_DATAW;

//
// APIs
//

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
ExtractPifInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData       OPTIONAL
    );

BOOL
ExtractPifInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData       OPTIONAL
    );

BOOL
ExtractShellLinkInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShellLinkInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyShellLinkFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,               OPTIONAL
    IN      PCSTR Params,               OPTIONAL
    IN      PCSTR WorkDir,              OPTIONAL
    IN      PCSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyShellLinkFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,               OPTIONAL
    IN      PCWSTR Params,               OPTIONAL
    IN      PCWSTR WorkDir,              OPTIONAL
    IN      PCWSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ModifyPifFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,       OPTIONAL
    IN      PCSTR Params,       OPTIONAL
    IN      PCSTR WorkDir,      OPTIONAL
    IN      PCSTR IconPath,     OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyPifFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR Params,          OPTIONAL
    IN      PCWSTR WorkDir,         OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    );

BOOL
ModifyShortcutFileExA (
    IN      PCSTR FileName,
    IN      PCSTR ForcedExtension,        OPTIONAL
    IN      PCSTR Target,                 OPTIONAL
    IN      PCSTR Params,                 OPTIONAL
    IN      PCSTR WorkDir,                OPTIONAL
    IN      PCSTR IconPath,               OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData,   OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );
#define ModifyShortcutFileA(n,t,p,w,i,in,hk,ed,sl,pf) ModifyShortcutFileExA(n,NULL,t,p,w,i,in,hk,ed,sl,pf)

BOOL
ModifyShortcutFileExW (
    IN      PCWSTR FileName,
    IN      PCWSTR ForcedExtension,       OPTIONAL
    IN      PCWSTR Target,                OPTIONAL
    IN      PCWSTR Params,                OPTIONAL
    IN      PCWSTR WorkDir,               OPTIONAL
    IN      PCWSTR IconPath,              OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData,   OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );
#define ModifyShortcutFileW(n,t,p,w,i,in,hk,ed,sl,pf) ModifyShortcutFileExW(n,NULL,t,p,w,i,in,hk,ed,sl,pf)

//
// Macros
//

#ifdef UNICODE

#define InitCOMLink             InitCOMLinkW
#define FreeCOMLink             FreeCOMLinkW
#define ExtractPifInfo          ExtractPifInfoW
#define ExtractShellLinkInfo    ExtractShellLinkInfoW
#define ExtractShortcutInfo     ExtractShortcutInfoW
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAW
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAW
#define ModifyShellLinkFile     ModifyShellLinkFileW
#define ModifyPifFile           ModifyPifFileW
#define ModifyShortcutFileEx    ModifyShortcutFileExW
#define ModifyShortcutFile      ModifyShortcutFileW

#else

#define InitCOMLink             InitCOMLinkA
#define FreeCOMLink             FreeCOMLinkA
#define ExtractPifInfo          ExtractPifInfoA
#define ExtractShellLinkInfo    ExtractShellLinkInfoA
#define ExtractShortcutInfo     ExtractShortcutInfoA
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAA
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAA
#define ModifyShellLinkFile     ModifyShellLinkFileA
#define ModifyPifFile           ModifyPifFileA
#define ModifyShortcutFileEx    ModifyShortcutFileExA
#define ModifyShortcutFile      ModifyShortcutFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\modimage.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    modimage.h

Abstract:

    Implements a set of routines for examining EXE modules

Author:

    Calin Negreanu (calinn) 27-Nov-1997

Revision History:

    calinn      08-Mar-2000 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MODULETYPE_UNKNOWN      0x00000000
#define MODULETYPE_DOS          0x00000001
#define MODULETYPE_WIN16        0x00000002
#define MODULETYPE_WIN32        0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct _MD_IMPORT_ENUM16 {
    CHAR  ImportModule[MAX_MBCHAR_PATH];
    CHAR  ImportFunction[MAX_MBCHAR_PATH];
    ULONG ImportFunctionOrd;
    PVOID Handle;
} MD_IMPORT_ENUM16A, *PMD_IMPORT_ENUM16A;

typedef struct _MD_IMPORT_ENUM32 {
    PCSTR ImportModule;
    PCSTR ImportFunction;
    ULONG ImportFunctionOrd;
    PVOID Handle;
} MD_IMPORT_ENUM32A, *PMD_IMPORT_ENUM32A;

typedef struct _MD_MODULE_IMAGE {
    UINT ModuleType;
    union {
        struct {
            LOADED_IMAGE Image;
        } W32Data;
        struct {
            PBYTE Image;
            HANDLE FileHandle;
            HANDLE MapHandle;
        } W16Data;
    } ModuleData;
} MD_MODULE_IMAGE, *PMD_MODULE_IMAGE;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
MdLoadModuleDataA (
    IN      PCSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdLoadModuleDataW (
    IN      PCWSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdUnloadModuleDataA (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdUnloadModuleDataW (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    );

BOOL
MdEnumFirstImport16A (
    IN      PBYTE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdEnumNextImport16A (
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdAbortImport16EnumA (
    IN      PMD_IMPORT_ENUM16A ImportsEnum
    );

BOOL
MdEnumFirstImportModule32A (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumNextImportModule32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumFirstImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdEnumNextImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    );

BOOL
MdAbortImport32EnumA (
    IN      PMD_IMPORT_ENUM32A ImportsEnum
    );

DWORD
MdGetModuleTypeA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetModuleTypeW (
    IN      PCWSTR ModuleName
    );

PCSTR
MdGet16ModuleDescriptionA (
    IN      PCSTR ModuleName
    );

PCWSTR
MdGet16ModuleDescriptionW (
    IN      PCWSTR ModuleName
    );

ULONG
MdGetPECheckSumA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetCheckSumA (
    IN      PCSTR ModuleName
    );

DWORD
MdGetCheckSumW (
    IN      PCWSTR ModuleName
    );

//
// New Executable resource access
//

HANDLE
NeOpenFileA (
    PCSTR FileName
    );

HANDLE
NeOpenFileW (
    PCWSTR FileName
    );

VOID
NeCloseFile (
    HANDLE Handle
    );

//
// Once upon a time ENUMRESTYPEPROC was defined as a TCHAR prototype,
// which was broken.  If ENUMRESTYPEPROCA isn't defined, we'll define
// it.  (NOTE: The current winbase.h has these typedefs.)
//

#ifndef ENUMRESTYPEPROCA

typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PWSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCA)(HMODULE hModule, PCSTR lpType, PSTR lpName, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCW)(HMODULE hModule, PCWSTR lpType, PWSTR lpName, LONG_PTR lParam);

#endif

BOOL
NeEnumResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
NeEnumResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );

DWORD
NeSizeofResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

DWORD
NeSizeofResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

PBYTE
NeFindResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

PBYTE
NeFindResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

#define NeFindResourceA(h,n,t) NeFindResourceExA(h,t,n)
#define NeFindResourceW(h,n,t) NeFindResourceExW(h,t,n)

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define MD_IMPORT_ENUM16                    MD_IMPORT_ENUM16A
#define MD_IMPORT_ENUM32                    MD_IMPORT_ENUM32A
#define MdLoadModuleData                    MdLoadModuleDataA
#define MdUnloadModuleData                  MdUnloadModuleDataA
#define MdEnumFirstImport16                 MdEnumFirstImport16A
#define MdEnumNextImport16                  MdEnumNextImport16A
#define MdAbortImport16Enum                 MdAbortImport16EnumA
#define MdEnumFirstImportModule32           MdEnumFirstImportModule32A
#define MdEnumNextImportModule32            MdEnumNextImportModule32A
#define MdEnumFirstImportFunction32         MdEnumFirstImportFunction32A
#define MdEnumNextImportFunction32          MdEnumNextImportFunction32A
#define MdAbortImport32Enum                 MdAbortImport32EnumA
#define MdGetModuleType                     MdGetModuleTypeA
#define MdGet16ModuleDescription            MdGet16ModuleDescriptionA
#define MdGetPECheckSum                     MdGetPECheckSumA
#define MdGetCheckSum                       MdGetCheckSumA

#define NeOpenFile                          NeOpenFileA
#define NeEnumResourceTypes                 NeEnumResourceTypesA
#define NeEnumResourceNames                 NeEnumResourceNamesA
#define NeSizeofResource                    NeSizeofResourceA
#define NeFindResource                      NeFindResourceA
#define NeFindResourceEx                    NeFindResourceExA

#else

#define MD_IMPORT_ENUM16                    MD_IMPORT_ENUM16W
#define MD_IMPORT_ENUM32                    MD_IMPORT_ENUM32W
#define MdLoadModuleData                    MdLoadModuleDataW
#define MdUnloadModuleData                  MdUnloadModuleDataW
#define MdEnumFirstImport16                 MdEnumFirstImport16W
#define MdEnumNextImport16                  MdEnumNextImport16W
#define MdAbortImport16Enum                 MdAbortImport16EnumW
#define MdEnumFirstImportModule32           MdEnumFirstImportModule32W
#define MdEnumNextImportModule32            MdEnumNextImportModule32W
#define MdEnumFirstImportFunction32         MdEnumFirstImportFunction32W
#define MdEnumNextImportFunction32          MdEnumNextImportFunction32W
#define MdAbortImport32Enum                 MdAbortImport32EnumW
#define MdGetModuleType                     MdGetModuleTypeW
#define MdGet16ModuleDescription            MdGet16ModuleDescriptionW
#define MdGetPECheckSum                     MdGetPECheckSumW
#define MdGetCheckSum                       MdGetCheckSumW

#define NeOpenFile                          NeOpenFileW
#define NeEnumResourceTypes                 NeEnumResourceTypesW
#define NeEnumResourceNames                 NeEnumResourceNamesW
#define NeSizeofResource                    NeSizeofResourceW
#define NeFindResource                      NeFindResourceW
#define NeFindResourceEx                    NeFindResourceExW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\progbar.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progbar.h

Abstract:

    Declares the functions, variables and macros for the progress bar
    utilities.  The progress bar utilities manage a single progress bar by
    dividing it into slices.  Each slice has an initial static size.  The
    count for each slice is scaled independently, so code can dynamically
    change the slice count as an aid to help tick the progress bar more
    smoothly.

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm 01-Jul-1998     Rewrite

--*/

#pragma once

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// exposed for the macros
extern HWND    g_Component;
extern HWND    g_SubComponent;
extern HANDLE  g_ComponentCancelEvent;
extern HANDLE  g_SubComponentCancelEvent;

//
// Macro expansion list
//

// None

//
// Public function prototypes
//
// initialization and termination
//

VOID
PbInitialize (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    );

VOID
PbTerminate (
    VOID
    );

//
// registration, estimate revision and ticking
//

UINT
PbRegisterSlice (
    IN      UINT InitialEstimate
    );

VOID
PbReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    );

VOID
PbBeginSliceProcessing (
    IN      UINT SliceId
    );

VOID
PbGetSliceInfo (
    IN      UINT SliceId,
    OUT     PBOOL SliceStarted,     OPTIONAL
    OUT     PBOOL SliceFinished,    OPTIONAL
    OUT     PUINT TicksCompleted,   OPTIONAL
    OUT     PUINT TotalTicks        OPTIONAL
    );

BOOL
PbTickDelta (
    IN      UINT Ticks
    );

BOOL
PbTick (
    VOID
    );

VOID
PbEndSliceProcessing (
    VOID
    );


//
// delayed titles
//

BOOL
PbSetWindowStringA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,              OPTIONAL
    IN      DWORD MessageId             OPTIONAL
    );

BOOL
PbSetDelayedMessageA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,
    IN      DWORD MessageId,
    IN      DWORD Delay
    );

VOID
PbCancelDelayedMessage (
    IN      HANDLE CancelEvent
    );

#if 0

BOOL
PbCreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    );

BOOL
PbCancelTickThread (
    IN      HANDLE CancelEvent
    );

#endif



//
// Macro expansion definition
//

// None

//
// Macros, including ANSI/UNICODE macros
//

#define PbCancelDelayedComponent()                  PbCancelDelayedMessage(g_ComponentCancelEvent);
#define PbCancelDelayedSubComponent()               PbCancelDelayedMessage(g_SubComponentCancelEvent);

#ifndef UNICODE

#define PbSetComponent(s)                           PbSetWindowStringA(g_Component,g_ComponentCancelEvent,(s),0)

#if !defined PRERELEASE || !defined DEBUG

#define PbSetSubComponent(s)                        PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define PbSetFnName(s)
#define PbClearFnName()

#else

#define PbSetSubComponent(s)                        ((s) == NULL ? 1 : PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0))
#define PbSetFnName(s)                              PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define PbClearFnName()                             PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,0)

#endif

#define PbSetComponentById(n)                       PbSetWindowStringA(g_Component,g_ComponentCancelEvent,NULL,(n))
#define PbSetSubComponentById(n)                    PbSetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n))
#define PbSetDelayedComponent(s,d)                  PbSetDelayedMessageA(g_Component,g_ComponentCancelEvent,(s),0,(d))
#define PbSetDelayedSubComponent(s,d)               PbSetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,(s),0,(d))
#define PbSetDelayedComponentById(n,d)              PbSetDelayedMessageA(g_Component,g_ComponentCancelEvent,NULL,(n),(d))
#define PbSetDelayedSubComponentById(n,d)           PbSetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n),(d))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\sandbox.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sandbox.h

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

#define SB_CLOSE        0x0100

//
// Macros
//

// None

//
// Types
//

typedef void * SBHANDLE;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

// None

//
// Macro expansion definition
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\strmap.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strmap.h

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm) 08-May-2000       Rewrote mapping, added Flags & ex nodes
    Calin Negreanu (calinn) 02-Mar-2000     Ported from win9xupg project

--*/

//
// Constants
//

#define STRMAP_COMPLETE_MATCH_ONLY                  0x0001
#define STRMAP_FIRST_CHAR_MUST_MATCH                0x0002
#define STRMAP_RETURN_AFTER_FIRST_REPLACE           0x0004
#define STRMAP_REQUIRE_WACK_OR_NUL                  0x0008

//
// Types
//

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR BeginningOfMatch;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR BeginningOfMatch;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct TAG_CHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;

    struct TAG_CHARNODE *NextLevel;
    struct TAG_CHARNODE *NextPeer;

} CHARNODE, *PCHARNODE;

typedef struct {
    CHARNODE Node;
    REG_REPLACE_FILTER Filter;
    ULONG_PTR ExtraData;
} CHARNODEEX, *PCHARNODEEX;



typedef struct {
    PMHANDLE Pool;
    PCHARNODE FirstLevelRoot;
    BOOL UsesExNode;
    BOOL UsesFilter;
    BOOL UsesExtraData;
} MAPSTRUCT, *PMAPSTRUCT;

//
// Macros
//

// None

//
// APIs
//

PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilter,
    IN      BOOL UsesExtraData
    );

#define CreateStringMapping()   CreateStringMappingEx(FALSE,FALSE)

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL,0,0)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL,0,0)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceA(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExA(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceW(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExW(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

//
// Macros
//

#ifdef UNICODE

#define AddStringMappingPairEx                  AddStringMappingPairExW
#define AddStringMappingPair                    AddStringMappingPairW
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExW
#define MappingSearchAndReplace                 MappingSearchAndReplaceW
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExW
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceW

#else

#define AddStringMappingPairEx                  AddStringMappingPairExA
#define AddStringMappingPair                    AddStringMappingPairA
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExA
#define MappingSearchAndReplace                 MappingSearchAndReplaceA
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExA
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <tchar.h>
#include <mbstring.h>
#include <wchar.h>

typedef PVOID PMHANDLE;

#pragma once

#define MAX_ENCODED_RULE    (256*6)
#define NODE_LEVEL_MAX      ((DWORD)-1)

#define SHIFTRIGHT8(l)  (/*lint --e(506)*/sizeof(l)<=1?0:l>>8)
#define SHIFTRIGHT16(l) (/*lint --e(506)*/sizeof(l)<=2?0:l>>16)
#define SHIFTRIGHT32(l) (/*lint --e(506)*/sizeof(l)<=4?0:l>>32)

extern CHAR EscapedCharsA[];
extern WCHAR EscapedCharsW[];

//
// String sizing routines and unit conversion
//

#define CharCountA(x)   ((DWORD)_mbslen(x))
#define CharCountW(x)   ((DWORD)wcslen(x))

#define SIZEOF(x)       ((DWORD)sizeof(x))


extern BOOL g_LeadByteArray[256];

__inline
BOOL
IsLeadByte (
    IN      PCSTR BytePtr
    )
{
    return (BytePtr[0] && g_LeadByteArray[BytePtr[0]]) ? (BytePtr[1] != 0) : FALSE;
}

__inline
BOOL
IsCharLeadByte (
    BYTE ByteToTest
    )
{
    return g_LeadByteArray[ByteToTest];
}

__inline
PSTR
CharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = _mbsinc (String);
    }

    return (PSTR) String;
}

__inline
PWSTR
CharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
CharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
CharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((UBINT) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = _mbsinc (Start);
    }

    return Count;
}

__inline
UINT
CharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((UBINT) Start + Bytes);

    if (Start < EndPlusOne) {
        //cast is OK, we don't expect pointers to be that far
        return (UINT)(EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
CharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT CharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = CharCountToPointerA (Start, CharCount);
    //cast is OK, we don't expect pointers to be that far
    return (UINT)(EndPlusOne - Start);
}

__inline
UINT
CharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount * SIZEOF (WCHAR);
}

#define CharCountToTcharsA   CharCountToBytesA

__inline
UINT
CharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount;
}


#define ByteCountA(x)       ((DWORD)strlen(x))
#define ByteCountW(x)       ((DWORD)wcslen(x)*SIZEOF(WCHAR))

#define SizeOfStringA(str)  ((DWORD)ByteCountA(str) + SIZEOF (CHAR))
#define SizeOfStringW(str)  ((DWORD)ByteCountW(str) + SIZEOF (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((UBINT) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((UBINT) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * SIZEOF (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return CharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((UBINT) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / SIZEOF (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = _mbsinc (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * SIZEOF (WCHAR);
}

VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    );

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    );

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    );

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    );

#define StackStringCopyA(stackbuf,src)                  StringCopyByteCountA(stackbuf,src,SIZEOF(stackbuf))
#define StackStringCopyW(stackbuf,src)                  StringCopyByteCountW(stackbuf,src,SIZEOF(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    );

#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountA(str1,str2,bytes)        _mbsncmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          StringMatchABA(str1,str2,(PCSTR)((PBYTE)(str2) + bytes))
#define StringMatchByteCountW(str1,str2,bytes)          (wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringICompareByteCountA(str1,str2,bytes)       _mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (_mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareCharCountA(str1,str2,chars)        _mbsncmp(str1,str2,chars)
#define StringCompareCharCountW(str1,str2,chars)        wcsncmp(str1,str2,chars)

#define StringMatchCharCountA(str1,str2,chars)          (_mbsncmp(str1,str2,chars)==0)
#define StringMatchCharCountW(str1,str2,chars)          (wcsncmp(str1,str2,chars)==0)

#define StringICompareCharCountA(str1,str2,chars)       _mbsnicmp(str1,str2,chars)
#define StringICompareCharCountW(str1,str2,chars)       _wcsnicmp(str1,str2,chars)

#define StringIMatchCharCountA(str1,str2,chars)         (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchCharCountW(str1,str2,chars)         (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      StringCompareByteCountA(str1,str2,(tchars)/sizeof(CHAR))
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringMatchTcharCountA(str1,str2,tchars)        (_mbsncmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringICompareTcharCountA(str1,str2,tchars)     _mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringIMatchTcharCountA(str1,str2,tchars)       (_mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringPrefixA(string,prefix)                    StringMatchCharCountA(string,prefix,CharCountA(prefix))
#define StringPrefixW(string,prefix)                    StringMatchCharCountW(string,prefix,CharCountW(prefix))

#define StringIPrefixA(string,prefix)                   StringIMatchCharCountA(string,prefix,CharCountA(prefix))
#define StringIPrefixW(string,prefix)                   StringIMatchCharCountW(string,prefix,CharCountW(prefix))


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

BOOL
StringMatchABA (
    IN      PCSTR String1,
    IN      PCSTR Start,
    IN      PCSTR End
    );

#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines -- they return the END of the string
//

PSTR
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );

PSTR
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PSTR
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

#define StringCopyCharCountA(str1,str2,chars)           StringCopyByteCountA(str1,str2,CharCountToBytesA(str2,chars))
#define StringCopyCharCountW(str1,str2,chars)           StringCopyByteCountW(str1,str2,CharCountToBytesW(str2,chars))

#define StringCopyTcharCountA(str1,str2,tchars)         StringCopyByteCountA(str1,str2,(tchars) * sizeof (CHAR))
#define StringCopyTcharCountW(str1,str2,tchars)         StringCopyByteCountW(str1,str2,(tchars) * sizeof (WCHAR))

#define StringCopyABA(dest,stra,strb)                   StringCopyByteCountA((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(CHAR)))
#define StringCopyABW(dest,stra,strb)                   StringCopyByteCountW((dest),(stra),((UINT)((UBINT)(strb)-(UBINT)(stra))+(UINT)SIZEOF(WCHAR)))

//
// String cat routines
//

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );


//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((UBINT) MultiSz - (UBINT) Base);
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = _mbsinc (MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/SIZEOF(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   TRACK_BEGIN(PSTR, AllocTextExA)\
                            RealAllocTextExA(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextExW(p,s)   TRACK_BEGIN(PWSTR, AllocTextExW)\
                            RealAllocTextExW(p,(UINT)(s))\
                            TRACK_END()

#define AllocTextA(s)       AllocTextExA(NULL,(UINT)(s))
#define AllocTextW(s)       AllocTextExW(NULL,(UINT)(s))



VOID
FreeTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   TRACK_BEGIN(PSTR, DuplicateTextExA)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextExW(p,t,c,n)   TRACK_BEGIN(PWSTR, DuplicateTextExW)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    TRACK_END()

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PSTR, JoinTextExA)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextExW(p,s1,s2,cs,ec,nc)   TRACK_BEGIN(PWSTR, JoinTextExW)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        TRACK_END()

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    TRACK_BEGIN(PSTR, ExpandEnvironmentTextExA)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextExW(str,ev)    TRACK_BEGIN(PWSTR, ExpandEnvironmentTextExW)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            TRACK_END()

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)

//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version checks for wacks at the begin/end of each segment so they are properly joined
//
PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define JoinPathsInPoolExA(x)   TRACK_BEGIN(PSTR, JoinPathsInPoolExA)\
                                RealJoinPathsInPoolExA x\
                                TRACK_END()

#define JoinPathsInPoolExW(x)   TRACK_BEGIN(PWSTR, JoinPathsInPoolExW)\
                                RealJoinPathsInPoolExW x\
                                TRACK_END()

//
// for backwards compatibility, JoinPaths expands to JoinPathsInPoolEx
// and NOT to JoinPathsEx which uses a growbuffer instead
//
#define JoinPathsA(p1,p2)               JoinPathsInPoolExA((NULL,p1,p2,NULL))
#define JoinPathsW(p1,p2)               JoinPathsInPoolExW((NULL,p1,p2,NULL))


BOOL
_cdecl
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    );

//
// Joins any number of paths together, allocates string in g_PathsPool if not otherwise specified
// this version does NOT check for wacks at the begin/end of each segment
//
PSTR
_cdecl
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

PWSTR
_cdecl
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    );

#define BuildPathInPoolA(x)   TRACK_BEGIN(PSTR, BuildPathInPoolA)\
                              RealBuildPathInPoolA x\
                              TRACK_END()

#define BuildPathInPoolW(x)   TRACK_BEGIN(PWSTR, BuildPathInPoolW)\
                              RealBuildPathInPoolW x\
                              TRACK_END()


DWORD
_cdecl
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

DWORD
_cdecl
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    );

BOOL
_cdecl
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    );

BOOL
_cdecl
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    );


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Tchars);
PWSTR   RealAllocPathStringW (IN DWORD Tchars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     TRACK_BEGIN(PSTR, AllocPathStringA)\
                                    RealAllocPathStringA(chars)\
                                    TRACK_END()

#define AllocPathStringW(chars)     TRACK_BEGIN(PWSTR, AllocPathStringW)\
                                    RealAllocPathStringW(chars)\
                                    TRACK_END()

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathA)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    TRACK_END()

#define SplitPathW(path,dv,dir,f,e) TRACK_BEGIN_VOID (VOID, SplitPathW)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    TRACK_END()

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   TRACK_BEGIN(PSTR, DuplicatePathStringA)\
                                        RealDuplicatePathStringA(path,eb)\
                                        TRACK_END()

#define DuplicatePathStringW(path,eb)   TRACK_BEGIN(PWSTR, DuplicatePathStringW)\
                                        RealDuplicatePathStringW(path,eb)\
                                        TRACK_END()

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    );


typedef struct _PATH_ENUMW {
    PWSTR  BufferPtr;
    PWSTR  PtrNextPath;
    PWSTR  PtrCurrPath;
} PATH_ENUMW, *PPATH_ENUMW;

BOOL
EnumFirstPathExW (
    OUT     PPATH_ENUMW PathEnum,
    IN      PCWSTR AdditionalPath,
    IN      PCWSTR WinDir,
    IN      PCWSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathW(e,a,w,s) EnumFirstPathExW(e,a,w,s,TRUE)

BOOL
EnumNextPathW (
    IN OUT  PPATH_ENUMW PathEnum
    );

BOOL
AbortPathEnumW (
    IN OUT  PPATH_ENUMW PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

PCSTR
FindLastWackA (
    IN      PCSTR Str
    );

PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    );

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    );


// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR
EncodeRuleCharsExA (
    PSTR szEncRule,
    PCSTR szRule,
    PCSTR szEncChars    OPTIONAL
    );
#define EncodeRuleCharsA(e,r) EncodeRuleCharsExA(e,r,NULL)

PWSTR
EncodeRuleCharsExW (
    PWSTR szEncRule,
    PCWSTR szRule,
    PCWSTR szEncChars    OPTIONAL
    );
#define EncodeRuleCharsW(e,r) EncodeRuleCharsExW(e,r,NULL)

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

BOOL IsPatternContainedA (PCSTR Container, PCSTR Contained);
BOOL IsPatternContainedW (PCWSTR Container, PCWSTR Contained);


//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct TAG_PARSEDPATTERNA {
    UINT PatternCount;
    PMHANDLE Pool;
    BOOL ExternalPool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct TAG_PARSEDPATTERNW {
    UINT PatternCount;
    PMHANDLE Pool;
    BOOL ExternalPool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    );

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
ExplodeParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNA Pattern
    );

#define ExplodeParsedPatternA(p) ExplodeParsedPatternExA(NULL,p)

PPARSEDPATTERNW
ExplodeParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNW Pattern
    );

#define ExplodeParsedPatternW(p) ExplodeParsedPatternExW(NULL,p)

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    );

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    );

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    );

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    );

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained,
    IN      BOOL SkipDotWithStar
    );

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained,
    IN      BOOL SkipDotWithStar
    );

BOOL
DoExplodedParsedPatternsIntersectExA (
    IN      PPARSEDPATTERNA Pat1,
    IN      PPARSEDPATTERNA Pat2,
    IN      BOOL IgnoreWackAtEnd
    );
#define DoExplodedParsedPatternsIntersectA(P1,P2) DoExplodedParsedPatternsIntersectExA(P1,P2,FALSE)

BOOL
DoExplodedParsedPatternsIntersectExW (
    IN      PPARSEDPATTERNW Pat1,
    IN      PPARSEDPATTERNW Pat2,
    IN      BOOL IgnoreWackAtEnd
    );
#define DoExplodedParsedPatternsIntersectW(P1,P2) DoExplodedParsedPatternsIntersectExW(P1,P2,FALSE)

PCSTR
GetPatternBaseExA (
    IN      PCSTR Pattern,
    IN      BOOL NodePattern
    );
#define GetPatternBaseA(p) GetPatternBaseExA(p,TRUE)

PCWSTR
GetPatternBaseExW (
    IN      PCWSTR Pattern,
    IN      BOOL NodePattern
    );
#define GetPatternBaseW(p) GetPatternBaseExW(p,TRUE)

PPARSEDPATTERNA
RealCreateParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Pattern
    );

#define CreateParsedPatternExA(o,p) TRACK_BEGIN(PPARSEDPATTERNA, CreateParsedPatternExA)\
                                    RealCreateParsedPatternExA(o,p)\
                                    TRACK_END()

#define CreateParsedPatternA(p)     CreateParsedPatternExA(NULL,p)

PPARSEDPATTERNW
RealCreateParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Pattern
    );

#define CreateParsedPatternExW(o,p) TRACK_BEGIN(PPARSEDPATTERNW, CreateParsedPatternExW)\
                                    RealCreateParsedPatternExW(o,p)\
                                    TRACK_END()

#define CreateParsedPatternW(p)     CreateParsedPatternExW(NULL,p)

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    );

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    );

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    );

__inline
BOOL
ParsedPatternIsExactMatchA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternIsExactMatchW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalA (
    IN      PSEGMENTA ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternSegmentIsPureOptionalW (
    IN      PSEGMENTW ParsedPatternSegment
    )
{
    return ParsedPatternSegment->Type == SEGMENTTYPE_OPTIONAL &&
           ParsedPatternSegment->Wildcard.MaxLen == 0 &&
           ParsedPatternSegment->Wildcard.IncludeSet == NULL &&
           ParsedPatternSegment->Wildcard.ExcludeSet == NULL;
}

__inline
BOOL
ParsedPatternIsOptionalA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsOptionalW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 1 &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment);
}

__inline
BOOL
ParsedPatternIsRootPlusStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalA (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternIsRootPlusStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount == 2 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH &&
           ParsedPatternSegmentIsPureOptionalW (ParsedPattern->Pattern->Segment + 1);
}

__inline
BOOL
ParsedPatternHasRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
BOOL
ParsedPatternHasRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount > 0 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPattern->Pattern->Segment[0].Type == SEGMENTTYPE_EXACTMATCH;
}

__inline
PCSTR
ParsedPatternGetRootA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
PCWSTR
ParsedPatternGetRootW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return NULL;
    }
    return ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase;
}

__inline
BOOL
ParsedPatternEndsWithStarA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalA (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

__inline
BOOL
ParsedPatternEndsWithStarW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    return ParsedPattern->PatternCount == 1 &&
           ParsedPattern->Pattern->SegmentCount > 0 &&
           ParsedPatternSegmentIsPureOptionalW (
                ParsedPattern->Pattern->Segment + ParsedPattern->Pattern->SegmentCount - 1
                );
}

BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    );

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    );


// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER RealCreateAllocTable (VOID);

#define CreateAllocTable()      TRACK_BEGIN(PGROWBUFFER, CreateAllocTable)\
                                RealCreateAllocTable()\
                                TRACK_END()


VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) _mbsnextc(CharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *CharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (CharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *CharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return _mbsdec(base,p);
}


//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

BOOL AddInfSectionToHashTableA (PVOID, HINF, PCSTR, DWORD, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToHashTableW (PVOID, HINF, PCWSTR, DWORD, ADDINFSECTION_PROCW, PVOID);


UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );

BOOL
IsStrInMultiSzA (
    IN      PCSTR String,
    IN      PCSTR MultiSz
    );

BOOL
IsStrInMultiSzW (
    IN      PCWSTR String,
    IN      PCWSTR MultiSz
    );

VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToU64(str)     StringToUint64A(str,NULL)

ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToU64(str)     StringToUint64W(str,NULL)

LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

#define AToI64(str)     StringToInt64A(str,NULL)

LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

#define WToI64(str)     StringToInt64W(str,NULL)

BOOL
TestBuffer (
    IN      PCBYTE SrcBuff,
    IN      PCBYTE DestBuff,
    IN      UINT Size
    );

//
// TCHAR mappings
//

#ifdef UNICODE

#define EscapedChars                EscapedCharsW
#define CharCount                   CharCountW
#define CharCountToPointer          CharCountToPointerW
#define CharCountAB                 CharCountABW
#define CharCountInByteRange        CharCountInByteRangeW
#define CharCountToBytes            CharCountToBytesW
#define CharCountToTchars           CharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareCharCount      StringCompareCharCountW
#define StringMatchCharCount        StringMatchCharCountW
#define StringICompareCharCount     StringICompareCharCountW
#define StringIMatchCharCount       StringIMatchCharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringPrefix                StringPrefixW
#define StringIPrefix               StringIPrefixW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyCharCount         StringCopyCharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define _tcsctrim                   _wcsctrim

#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPaths                   JoinPathsW
#define JoinPathsInPoolEx           JoinPathsInPoolExW
#define JoinPathsEx                 JoinPathsExW
#define BuildPathInPool             BuildPathInPoolW
#define BuildPath                   BuildPathW
#define BuildPathEx                 BuildPathExW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW

#define PATH_ENUM                   PATH_ENUMW
#define PPATH_ENUM                  PPATH_ENUMW
#define EnumFirstPathEx             EnumFirstPathExW
#define EnumFirstPath               EnumFirstPathW
#define EnumNextPath                EnumNextPathW
#define AbortPathEnum               AbortPathEnumW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW
#define FindLastWack                FindLastWackW
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleCharsEx           EncodeRuleCharsExW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW
#define IsPatternContained          IsPatternContainedW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define GetPatternBaseEx            GetPatternBaseExW
#define GetPatternBase              GetPatternBaseW
#define CreateParsedPatternEx       CreateParsedPatternExW
#define CreateParsedPattern         CreateParsedPatternW
#define WildCharsPattern            WildCharsPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define IsPatternMatchExAB          IsPatternMatchExABW
#define ExplodeParsedPattern        ExplodeParsedPatternW
#define ExplodeParsedPatternEx      ExplodeParsedPatternExW
#define IsPatternContainedEx        IsPatternContainedExW
#define IsParsedPatternContainedEx  IsParsedPatternContainedExW
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExW
#define DoExplodedParsedPatternsIntersectEx DoExplodedParsedPatternsIntersectExW
#define DoExplodedParsedPatternsIntersect   DoExplodedParsedPatternsIntersectW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DestroyParsedPattern        DestroyParsedPatternW
#define DecodeParsedPattern         DecodeParsedPatternW
#define PatternIncludesPattern      PatternIncludesPatternW
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeW
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchW
#define ParsedPatternIsOptional     ParsedPatternIsOptionalW
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarW
#define ParsedPatternHasRoot        ParsedPatternHasRootW
#define ParsedPatternGetRoot        ParsedPatternGetRootW
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalW
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarW
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW
#define IsStrInMultiSz              IsStrInMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#define AddInfSectionToHashTable    AddInfSectionToHashTableW
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#define StringToUint64              StringToUint64W
#define TToU64                      WToU64
#define StringToInt64               StringToInt64W
#define TToI64                      WToI64

#else

#define EscapedChars                EscapedCharsA
#define CharCount                   CharCountA
#define CharCountToPointer          CharCountToPointerA
#define CharCountAB                 CharCountABA
#define CharCountInByteRange        CharCountInByteRangeA
#define CharCountToBytes            CharCountToBytesA
#define CharCountToTchars           CharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareCharCount      StringCompareCharCountA
#define StringMatchCharCount        StringMatchCharCountA
#define StringICompareCharCount     StringICompareCharCountA
#define StringIMatchCharCount       StringIMatchCharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA
#define StringPrefix                StringPrefixA
#define StringIPrefix               StringIPrefixA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyCharCount         StringCopyCharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    _mbsdec2
#define _copytchar                  _copymbchar
#define _settchar                   _setmbchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define _tcsctrim                   _mbsctrim

#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPaths                   JoinPathsA
#define JoinPathsInPoolEx           JoinPathsInPoolExA
#define JoinPathsEx                 JoinPathsExA
#define BuildPathInPool             BuildPathInPoolA
#define BuildPath                   BuildPathA
#define BuildPathEx                 BuildPathExA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA
#define FindLastWack                FindLastWackA
#define GetNodePatternMinMaxLevels  GetNodePatternMinMaxLevelsA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define AbortPathEnum               AbortPathEnumA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleCharsEx           EncodeRuleCharsExA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA
#define IsPatternContained          IsPatternContainedA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define GetPatternBaseEx            GetPatternBaseExA
#define GetPatternBase              GetPatternBaseA
#define CreateParsedPatternEx       CreateParsedPatternExA
#define CreateParsedPattern         CreateParsedPatternA
#define WildCharsPattern            WildCharsPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define IsPatternMatchExAB          IsPatternMatchExABA
#define ExplodeParsedPattern        ExplodeParsedPatternA
#define ExplodeParsedPatternEx      ExplodeParsedPatternExA
#define IsPatternContainedEx        IsPatternContainedExA
#define IsParsedPatternContainedEx  IsParsedPatternContainedExA
#define IsExplodedParsedPatternContainedEx  IsExplodedParsedPatternContainedExA
#define DoExplodedParsedPatternsIntersectEx DoExplodedParsedPatternsIntersectExA
#define DoExplodedParsedPatternsIntersect   DoExplodedParsedPatternsIntersectA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA
#define DecodeParsedPattern         DecodeParsedPatternA
#define PatternIncludesPattern      PatternIncludesPatternA
#define GetParsedPatternMinMaxSize  GetParsedPatternMinMaxSizeA
#define ParsedPatternIsExactMatch   ParsedPatternIsExactMatchA
#define ParsedPatternIsOptional     ParsedPatternIsOptionalA
#define ParsedPatternIsRootPlusStar ParsedPatternIsRootPlusStarA
#define ParsedPatternHasRoot        ParsedPatternHasRootA
#define ParsedPatternGetRoot        ParsedPatternGetRootA
#define ParsedPatternSegmentIsPureOptional ParsedPatternSegmentIsPureOptionalA
#define ParsedPatternEndsWithStar   ParsedPatternEndsWithStarA
#define ParsedPatternTrimLastChar   ParsedPatternTrimLastCharA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA
#define IsStrInMultiSz              IsStrInMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#define AddInfSectionToHashTable    AddInfSectionToHashTableA
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#define StringToUint64              StringToUint64A
#define TToU64                      AToU64
#define StringToInt64               StringToInt64A
#define TToI64                      AToI64

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\utiltypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    utiltypes.h

Abstract:

    Defines types used by utilities

Author:

    Jim Schmidt (jimschm) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef PVOID PMHANDLE;
typedef struct TAG_GROWBUFFER *PGROWBUFFER;
typedef struct TAG_PARSEDPATTERNA *PPARSEDPATTERNA;
typedef struct TAG_PARSEDPATTERNW *PPARSEDPATTERNW;
typedef struct TAG_OBSPARSEDPATTERNA *POBSPARSEDPATTERNA;
typedef struct TAG_OBSPARSEDPATTERNW *POBSPARSEDPATTERNW;
typedef const void *HASHTABLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    See macros at the end of this file for details! (Search for ***)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 16-Mar-2000     PTSTR<->PCSTR/PCWSTR routines
    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );

VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );

WORD
SetConversionCodePage (
    IN      WORD CodePage
    );

#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    );

#define UnicodeToDbcsN(p,s,c)       TRACK_BEGIN(PCSTR, UnicodeToDbcsN)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    TRACK_END()

#define DbcsToUnicodeN(p,s,c)       TRACK_BEGIN(PCWSTR, DbcsToUnicodeN)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    TRACK_END()

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,(DWORD)wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,CharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,(DWORD)wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,CharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD CharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD CharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

#define MaxSizeUnicodeToDbcs(out,in,c)      KnownSizeUnicodeToDbcsN(out,in,min(c,CharCountW(in)))
#define MaxSizeDbcsToUnicode(out,in,c)      KnownSizeDbcsToUnicodeN(out,in,min(c,CharCountA(in)))

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#define DuplicateDbcsW(unicode_str)         ((PSTR) ConvertWtoA(unicode_str))
#define FreeDuplicatedDbcsW(unicode_str)    FreeConvertedStr(unicode_str)
#define DuplicateUnicodeW(unicode_str)      ((PWSTR) DuplicateTextW(unicode_str))
#define FreeDuplicatedUnicodeW(unicode_str) FreeTextW(unicode_str)
#define DuplicateDbcsA(dbcs_str)            ((PSTR) DuplicateTextA(dbcs_str))
#define FreeDuplicatedDbcsA(dbcs_str)       FreeTextA(dbcs_str)
#define DuplicateUnicodeA(dbcs_str)         ((PWSTR) ConvertAtoW(dbcs_str))
#define FreeDuplicatedUnicodeA(dbcs_str)    FreeConvertedStr(dbcs_str)


//
// **********************************************************************
//
// - Call ConvertWtoA or ConvertAtoW for PCSTR<->PCWSTR conversion,
//   FreeConvertedStr to clean up
//
// - Call KnownSizeAtoW or KnownSizeWtoA for PCSTR<->PCWSTR conversion
//   when you know the destination can hold the result
//
// - Call the routines below for TCHAR<->dbcs/unicode conversion
//
// **********************************************************************
//

#ifdef UNICODE

//
// If your string is a PCTSTR, use these routines:
//

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW

//
// If your string is a PTSTR, use these routines:
//

#define DuplicateDbcs               DuplicateDbcsW
#define DuplicateUnicode            DuplicateUnicodeW
#define FreeDuplicatedDbcs          FreeDuplicatedDbcsW
#define FreeDuplicatedUnicode       FreeDuplicatedUnicodeW

//
// If your string is a PCSTR or PCWSTR, use these routines:
//

#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

// Known size means you know the out buffer is big enough!
#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

// These are low-level routines that don't care about nuls:
#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

//
// If your string is a PCTSTR, use these routines:
//

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA

//
// If your string is a PCSTR or PCWSTR, use these routines:
//

#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

//
// If your string is a PTSTR, use these routines:
//

#define DuplicateDbcs               DuplicateDbcsA
#define DuplicateUnicode            DuplicateUnicodeA
#define FreeDuplicatedDbcs          FreeDuplicatedDbcsA
#define FreeDuplicatedUnicode       FreeDuplicatedUnicodeA

// Known size means you know the out buffer is big enough!
#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

// These are low-level routines that don't care about nuls:
#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\regenum.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.h

Abstract:

    Set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

#define REGENUM_ALL_SUBLEVELS   0xFFFFFFFF

#define REG_ATTRIBUTE_KEY       0x00000001
#define REG_ATTRIBUTE_VALUE     0x00000002

//
// Root enumeration structures
//

typedef struct {
    PCSTR   RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMA, *PREGROOT_ENUMA;

typedef struct {
    PCWSTR  RegRootName;
    HKEY    RegRootHandle;
    UINT    Index;
} REGROOT_ENUMW, *PREGROOT_ENUMW;

//
// Key/Values enumeration structures
//

typedef enum {
    RECF_SKIPKEY                = 0x0001,
    RECF_SKIPSUBKEYS            = 0x0002,
    RECF_SKIPVALUES             = 0x0004,
} REGENUM_CONTROLFLAGS;

typedef enum {
    REIF_RETURN_KEYS            = 0x0001,
    REIF_VALUES_FIRST           = 0x0002,
    REIF_DEPTH_FIRST            = 0x0004,
    REIF_USE_EXCLUSIONS         = 0x0008,
    REIF_CONTAINERS_FIRST       = 0x0010,
    REIF_READ_VALUE_DATA        = 0x0020,
} REGENUMINFOFLAGS;

typedef enum {
    RNS_ENUM_INIT,
    RNS_VALUE_FIRST,
    RNS_VALUE_NEXT,
    RNS_VALUE_DONE,
    RNS_SUBKEY_FIRST,
    RNS_SUBKEY_NEXT,
    RNS_SUBKEY_DONE,
    RNS_ENUM_DONE
} RNS_ENUM_STATE;

typedef enum {
    RES_ROOT_FIRST,
    RES_ROOT_NEXT,
    RES_ROOT_DONE
} RES_ROOT_STATE;


typedef enum {
    RNF_RETURN_KEYS         = 0x0001,
    RNF_KEYNAME_MATCHES     = 0x0002,
    RNF_VALUENAME_INVALID   = 0x0004,
    RNF_VALUEDATA_INVALID   = 0x0008,
} REGNODE_FLAGS;

typedef struct {
    PCSTR   KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PSTR    ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PSTR    SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEA, *PREGNODEA;

typedef struct {
    PCWSTR  KeyName;
    HKEY    KeyHandle;
    DWORD   ValueCount;
    PWSTR   ValueName;
    DWORD   ValueLengthMax;
    DWORD   ValueType;
    PBYTE   ValueData;
    DWORD   ValueDataSize;
    DWORD   ValueDataSizeMax;
    DWORD   SubKeyCount;
    PWSTR   SubKeyName;
    DWORD   SubKeyLengthMax;
    DWORD   SubKeyIndex;
    DWORD   ValueIndex;
    DWORD   EnumState;
    DWORD   Flags;
    DWORD   SubLevel;
} REGNODEW, *PREGNODEW;

typedef BOOL (*RPE_ERROR_CALLBACKA)(PREGNODEA);

typedef struct {
    POBSPARSEDPATTERNA      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKA     CallbackOnError;
} REGENUMINFOA, *PREGENUMINFOA;

typedef BOOL (*RPE_ERROR_CALLBACKW)(PREGNODEW);

typedef struct {
    POBSPARSEDPATTERNW      RegPattern;
    DWORD                   Flags;
    DWORD                   RootLevel;
    DWORD                   MaxSubLevel;
    RPE_ERROR_CALLBACKW     CallbackOnError;
} REGENUMINFOW, *PREGENUMINFOW;

typedef struct {
    PCSTR           EncodedFullName;
    PCSTR           Name;
    PCSTR           Location;
    CHAR            NativeFullName[2 * MAX_MBCHAR_PATH];
    PBYTE           CurrentValueData;
    UINT            CurrentValueDataSize;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOA    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMA  RootEnum;
    PREGNODEA       LastNode;
    PSTR            RegNameAppendPos;
    PSTR            LastWackPtr;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    PCWSTR          EncodedFullName;
    PCWSTR          Name;
    PCWSTR          Location;
    WCHAR           NativeFullName[2 * MAX_WCHAR_PATH];
    PBYTE           CurrentValueData;
    UINT            CurrentValueDataSize;
    DWORD           CurrentValueType;
    HKEY            CurrentKeyHandle;
    DWORD           CurrentLevel;
    DWORD           Attributes;

    //
    // Private members
    //
    DWORD           ControlFlags;
    REGENUMINFOW    RegEnumInfo;
    GROWBUFFER      RegNodes;
    DWORD           RootState;
    PREGROOT_ENUMW  RootEnum;
    PREGNODEW       LastNode;
    PWSTR           RegNameAppendPos;
    PWSTR           LastWackPtr;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// API
//

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    );

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    );

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    );

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    );

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeA(e,p)  EnumFirstRegObjectInTreeExA(e,p,TRUE,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,FALSE,RegEnumDefaultCallbackA)

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedKeyPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    );

#define EnumFirstRegObjectInTreeW(e,p)  EnumFirstRegObjectInTreeExW(e,p,TRUE,TRUE,TRUE,TRUE,REGENUM_ALL_SUBLEVELS,FALSE,FALSE,RegEnumDefaultCallbackW)

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

VOID
AbortRegObjectInTreeEnumA (
    IN OUT  PREGTREE_ENUMA RegEnum
    );

VOID
AbortRegObjectInTreeEnumW (
    IN OUT  PREGTREE_ENUMW RegEnum
    );

BOOL
RgRemoveAllValuesInKeyA (
    IN      PCSTR KeyToRemove
    );

BOOL
RgRemoveAllValuesInKeyW (
    IN      PCWSTR KeyToRemove
    );

BOOL
RgRemoveKeyA (
    IN      PCSTR KeyToRemove
    );

BOOL
RgRemoveKeyW (
    IN      PCWSTR KeyToRemove
    );

//
// Macros
//

#ifdef UNICODE

#define RegEnumDefaultCallback      RegEnumDefaultCallbackW
#define REGROOT_ENUM                REGROOT_ENUMW
#define EnumFirstRegRoot            EnumFirstRegRootW
#define EnumNextRegRoot             EnumNextRegRootW
#define REGNODE                     REGNODEW
#define PREGNODE                    PREGNODEW
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKW
#define REGENUMINFO                 REGENUMINFOW
#define PREGENUMINFO                PREGENUMINFOW
#define REGTREE_ENUM                REGTREE_ENUMW
#define PREGTREE_ENUM               PREGTREE_ENUMW
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeW
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExW
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeW
#define AbortRegObjectInTreeEnum    AbortRegObjectInTreeEnumW
#define RgRemoveAllValuesInKey      RgRemoveAllValuesInKeyW
#define RgRemoveKey                 RgRemoveKeyW

#else

#define RegEnumDefaultCallback      RegEnumDefaultCallbackA
#define REGROOT_ENUM                REGROOT_ENUMA
#define EnumFirstRegRoot            EnumFirstRegRootA
#define EnumNextRegRoot             EnumNextRegRootA
#define REGNODE                     REGNODEA
#define PREGNODE                    PREGNODEA
#define RPE_ERROR_CALLBACK          RPE_ERROR_CALLBACKA
#define REGENUMINFO                 REGENUMINFOA
#define PREGENUMINFO                PREGENUMINFOA
#define REGTREE_ENUM                REGTREE_ENUMA
#define PREGTREE_ENUM               PREGTREE_ENUMA
#define EnumFirstRegObjectInTree    EnumFirstRegObjectInTreeA
#define EnumFirstRegObjectInTreeEx  EnumFirstRegObjectInTreeExA
#define EnumNextRegObjectInTree     EnumNextRegObjectInTreeA
#define AbortRegObjectInTreeEnum    AbortRegObjectInTreeEnumA
#define RgRemoveAllValuesInKey      RgRemoveAllValuesInKeyA
#define RgRemoveKey                 RgRemoveKeyA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)

BOOL
RegInitialize (
    VOID
    );

VOID
RegTerminate (
    VOID
    );


VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    );

VOID
RegTerminateCache (
    VOID
    );

//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PCVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) TRACK_BEGIN(PBYTE, GetRegValueDataA)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) TRACK_BEGIN(PBYTE,GetRegValueDataW)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        TRACK_END()

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeA)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  TRACK_BEGIN(PBYTE, GetRegValueDataOfTypeW)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    TRACK_END()

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataA)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  TRACK_BEGIN(PBYTE, GetRegKeyDataW)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) TRACK_BEGIN(PBYTE, GetRegDataA)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  TRACK_END()

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   TRACK_BEGIN(PBYTE, GetRegDataW)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    TRACK_END()

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    );

#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define DeleteRegKeyStr                 DeleteRegKeyStrW
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define DeleteRegKeyStr                 DeleteRegKeyStrA
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\version.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.h

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

#pragma once

//
// Includes
//

// None

//
// Debug constants
//

// None

//
// Strings
//

// None

//
// Constants
//

#define MAX_TRANSLATION             32

//
// Macros
//

// None

//
// Types
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VRVALUE_ENUMA, *PVRVALUE_ENUMA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VRVALUE_ENUMW, *PVRVALUE_ENUMW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes
//

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    );

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    );

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    );

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    );

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

BOOL
VrCheckVersionValueA (
    IN      PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionName,
    IN      PCSTR VersionValue
    );

BOOL
VrCheckFileVersionA (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    );

BOOL
VrCheckFileVersionW (
    IN      PCWSTR FileName,
    IN      PCWSTR NameToCheck,
    IN      PCWSTR ValueToCheck
    );

BOOL
VrCheckVersionValueW (
    IN      PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionName,
    IN      PCWSTR VersionValue
    );

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileVersionW(VrValueEnum)    VrGetBinaryFileVersionA((PVRVALUE_ENUMA)VrValueEnum)

ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryProductVersionW(VrValueEnum) VrGetBinaryProductVersionA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileDateLoW(VrValueEnum)     VrGetBinaryFileDateLoA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileDateHiW(VrValueEnum)     VrGetBinaryFileDateHiA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryOsVersionW(VrValueEnum)      VrGetBinaryOsVersionA((PVRVALUE_ENUMA)VrValueEnum)

DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    );

#define VrGetBinaryFileTypeW(VrValueEnum)       VrGetBinaryFileTypeA((PVRVALUE_ENUMA)VrValueEnum)

//
// Macro expansion definition
//

// None

//
// TCHAR mappings
//

#ifndef UNICODE

#define VRVALUE_ENUM                    VRVALUE_ENUMA
#define PVRVALUE_ENUM                   PVRVALUE_ENUMA
#define VrCreateEnumStruct              VrCreateEnumStructA
#define VrDestroyEnumStruct             VrDestroyEnumStructA
#define VrEnumFirstValue                VrEnumFirstValueA
#define VrEnumNextValue                 VrEnumNextValueA
#define VrCheckFileVersion              VrCheckFileVersionA
#define VrCheckVersionValue             VrCheckVersionValueA
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionA
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionA
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoA
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiA
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionA
#define VrGetBinaryFileType             VrGetBinaryFileTypeA

#else

#define VRVALUE_ENUM                    VRVALUE_ENUMW
#define PVRVALUE_ENUM                   PVRVALUE_ENUMW
#define VrCreateEnumStruct              VrCreateEnumStructW
#define VrDestroyEnumStruct             VrDestroyEnumStructW
#define VrEnumFirstValue                VrEnumFirstValueW
#define VrEnumNextValue                 VrEnumNextValueW
#define VrCheckFileVersion              VrCheckFileVersionW
#define VrCheckVersionValue             VrCheckVersionValueW
#define VrGetBinaryFileVersion          VrGetBinaryFileVersionW
#define VrGetBinaryProductVersion       VrGetBinaryProductVersionW
#define VrGetBinaryFileDateLo           VrGetBinaryFileDateLoW
#define VrGetBinaryFileDateHi           VrGetBinaryFileDateHiW
#define VrGetBinaryOsVersion            VrGetBinaryOsVersionW
#define VrGetBinaryFileType             VrGetBinaryFileTypeW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inc\wnd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.h

Abstract:

    The header file for Window utility routines.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

#define BACK_BUTTON         0x0001
#define NEXT_BUTTON         0x0002
#define CANCEL_BUTTON       0x0004
#define FINISH_BUTTON       0x0008

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

HWND
WndFindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle           OPTIONAL
    );

HWND
WndFindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle          OPTIONAL
    );

VOID
WndCenterWindow (
    IN  HWND WindowToCenter,
    IN  HWND ParentToCenterIn           OPTIONAL
    );


VOID
WndTurnOnWaitCursor (
    VOID
    );

VOID
WndTurnOffWaitCursor (
    VOID
    );

VOID
WndSetWizardButtonsA (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCSTR AlternateFinishText      OPTIONAL
    );

VOID
WndSetWizardButtonsW (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCWSTR AlternateFinishText      OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

#ifdef UNICODE

#define WndFindWindowInProcess          WndFindWindowInProcessW
#define WndSetWizardButtons             WndSetWizardButtonsW

#else

#define WndFindWindowInProcess          WndFindWindowInProcessA
#define WndSetWizardButtons             WndSetWizardButtonsA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\log\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by log.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inf\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be manipulated.

  The entry points are:

  OpenInfFile - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"


//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


typedef struct {
    HANDLE SourceInfFile;
    HANDLE DestInfFile;
    PMHANDLE InfPool;             // A pool for appended INF data
    PINFSECTION FirstInfSection;    // The first section of the parsed INF
    PINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} INFFILE, *PINFFILE;



BOOL
pReadInfIntoTable (
    IN OUT  PINFFILE InfFile,
    IN PWSTR SectionList,
    IN BOOL KeepComments
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.

Arguments:

  InfFile - Specifies the structure initilized with the INF file handle.
            Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = INIT_GROWBUFFER;
    PCWSTR Text;
    DWORD Pos;
    PCWSTR Key, Data;
    PWSTR p, q;
    DWORD i;
    PINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;
    HASHTABLE ht = NULL;
    BOOL neededSection = FALSE;
    PWSTR list;


    Section = AddInfSectionToTableW (InfFile, L"");
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }


    //
    // If we have a list of sections to fill, add them to a ht, for faster retrieval.
    //
    if (SectionList) {
        list = PmDuplicateStringW (InfFile->InfPool, SectionList);
        ht = HtAllocW ();
        if (ht) {
            while (list) {

                p = wcschr (list, L',');

                if (p) {
                    *p = 0;
                }

                HtAddStringW (ht, SkipSpaceW(list));

                if (p) {
                    *p = L',';
                    list = p + 1;
                }
                else {
                    list = p;
                }
            }
        }
        else {

            LOG ((LOG_ERROR, "Read Inf Into Table: Could not allocate section hash table."));
            return FALSE;
        }

    }


    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pGetInfFileWchar (InfFile->SourceInfFile, 0, &Error);
        InfFile->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        for (;;) {
            //
            // Get the line
            //

            Text = pGetNextInfLine (
                        InfFile->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        InfFile->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PWSTR) SkipSpaceW (Text);
            if (!p[0] || p[0] == L';') {
                if (KeepComments && !AddInfLineToTableW (InfFile, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (p[0] == L'[') {
                p++;
                q = wcschr (p, L']');
                if (!q) {
                    q = GetEndOfStringW (p);
                } else {
                    *q = 0;
                }

                if (!ht || HtFindStringW (ht, p)) {

                    Section = AddInfSectionToTableW (InfFile, p);
                    neededSection = TRUE;
                    if (!Section) {
                        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                        __leave;
                    }
                }
                else {

                    //
                    // We must not care about this section. Make sure we don't add any lines.
                    //
                    neededSection = FALSE;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                if (!neededSection) {
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (q[0] == L'\"') {
                    q = wcschr (q + 1, L'\"');
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q++;
                    }
                }

                i = (DWORD)wcscspn (q, L"\"=");

                if (q[i] == L'=') {
                    q += i;

                    Data = SkipSpaceW (q + 1);
                    *q = 0;
                    q = (PWSTR) SkipSpaceRW (Text, q);
                    if (q && *q) {
                        q++;
                        *q = 0;
                    }

                    Key = p;

                    if (Key[0] == L'\"') {

                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key++;

                        p = GetEndOfStringW (Key);
                        p = (PWSTR) SkipSpaceRW (Key, p);

                        if (p && *p) {
                            if (p[0] != L'\"') {
                                p++;
                            }

                            *p = 0;
                        }
                    }
                }

                if (!AddInfLineToTableW (InfFile, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (InfFile->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        GbFree (&LineBuf);
        if (ht) {
            HtFree (ht);
        }
    }

    return Result;
}


VOID
CloseInfFile (
    HINF InfFile
    )
{
    PINFFILE inf = (PINFFILE) InfFile;

    PmEmptyPool (inf->InfPool);
    PmDestroyPool (inf->InfPool);
    MemFree (g_hHeap, 0, inf);

}


HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;
    PWSTR wSectionList = NULL;


    if (SectionList) {
        wSectionList = (PWSTR) ConvertAtoW (SectionList);
    }



    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileA (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, wSectionList, KeepComments);
    }

    if (wSectionList) {
        FreeConvertedStr (wSectionList);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;

    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileW (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PmCreateNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, SectionList, KeepComments);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PmDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle (InfFile->SourceInfFile);
    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


BOOL
pSaveInfToFile (
    IN      PINFFILE InfFile
    )

/*++

Routine Description:

  InfParse_WriteInfToDisk writes the INF represented by the given memory
  image to disk.  This is done by enumerating the INF data structures in
  the INF.

Arguments:

  InfFile - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PINFSECTION Section;
    PINFLINE Line;
    BYTE UnicodeHeader[] = { 0xff, 0xfe };
    DWORD DontCare;
    PCSTR AnsiStr = NULL;
    BOOL b = TRUE;

    MYASSERT (InfFile->SourceInfFile == INVALID_HANDLE_VALUE);
    MYASSERT (InfFile->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    __try {
        if (InfFile->InfIsUnicode) {
            if (!WriteFile (InfFile->DestInfFile, UnicodeHeader, sizeof (UnicodeHeader), &DontCare, NULL)) {
                __leave;
            }

            if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                __leave;
            }

        } else {

            if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                __leave;
            }

        }

        Section = InfFile->FirstInfSection;

        while (Section) {
            if (Section->Name[0]) {

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, L"[") ||
                        !WriteFileStringW (InfFile->DestInfFile, Section->Name) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"]\r\n")
                        ) {
                        __leave;
                    }
                } else {

                    AnsiStr = ConvertWtoA (Section->Name);

                    if (!WriteFileStringA (InfFile->DestInfFile, "[") ||
                        !WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "]\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;
                }
            }

            Line = Section->FirstLine;

            while (Line) {
                if (Line->Key) {
                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, Line->Key)) {
                            __leave;
                        }

                    } else {

                        AnsiStr = ConvertWtoA (Line->Key);

                        if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr)) {
                            __leave;
                        }

                        FreeConvertedStr (AnsiStr);
                        AnsiStr = NULL;
                    }

                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (!WriteFile (InfFile->DestInfFile, L"\"", InfFile->InfIsUnicode ? 2 : 1, &DontCare, NULL)) {
                            __leave;
                        }

                    }

                    if (InfFile->InfIsUnicode) {

                        if (!WriteFileStringW (InfFile->DestInfFile, L" = ")) {
                            __leave;
                        }

                    } else {

                        if (!WriteFileStringA (InfFile->DestInfFile, " = ")) {
                            __leave;
                        }
                    }
                }

                if (InfFile->InfIsUnicode) {

                    if (!WriteFileStringW (InfFile->DestInfFile, Line->Data) ||
                        !WriteFileStringW (InfFile->DestInfFile, L"\r\n")
                        ) {

                        __leave;
                    }

                } else {

                    AnsiStr = ConvertWtoA (Line->Data);

                    if (!WriteFileStringA (InfFile->DestInfFile, AnsiStr) ||
                        !WriteFileStringA (InfFile->DestInfFile, "\r\n")
                        ) {
                        __leave;
                    }

                    FreeConvertedStr (AnsiStr);
                    AnsiStr = NULL;

                }

                Line = Line->Next;
            }

            if (InfFile->InfIsUnicode) {

                if (!WriteFileStringW (InfFile->DestInfFile, L"\r\n")) {
                    __leave;
                }
            } else {

                if (!WriteFileStringA (InfFile->DestInfFile, "\r\n")) {
                    __leave;
                }
            }

            Section = Section->Next;
        }
    }
    __finally {
        if (AnsiStr) {
            FreeConvertedStr (AnsiStr);
        }

        DEBUGMSG_IF((!b, DBG_ERROR, "Write Inf To Disk: Cannot write INF"));
    }

    return b;
}


BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileA (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileA (SaveToFileSpec);
    }

    return b;
}


BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileW (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileW (SaveToFileSpec);
    }

    return b;
}


PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION SectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    SectionPtr = AddInfSectionToTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (SectionName);

    return SectionPtr;
}


PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  Inf - Specifies the INF to add the section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PINFSECTION NewSection;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Return early if this section already exists
    //

    NewSection = FindInfSectionInTableW (InfFile, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PINFSECTION) PmGetAlignedMemory (
                                    InfFile->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PmDuplicateStringW (
                            InfFile->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = InfFile->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        InfFile->FirstInfSection = NewSection;
    }

    InfFile->LastInfSection = NewSection;

    return NewSection;
}


PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    )
{
    PCWSTR UnicodeKey;
    PCWSTR UnicodeData;
    PINFLINE Line;

    if (Key) {
        UnicodeKey = ConvertAtoW (Key);
    } else {
        UnicodeKey = NULL;
    }

    UnicodeData = ConvertAtoW (Data);

    Line = AddInfLineToTableW (Inf, SectionPtr, UnicodeKey, UnicodeData, LineFlags);

    if (Key) {
        FreeConvertedStr (UnicodeKey);
    }

    FreeConvertedStr (UnicodeData);

    return Line;
}


PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  InfFile - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PINFLINE NewLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    //
    // Allocate line struct
    //

    NewLine = (PINFLINE) PmGetAlignedMemory (
                              InfFile->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PmDuplicateStringW (
                            InfFile->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PmDuplicateStringW (
                        InfFile->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    SectionPtr->LastLine = NewLine;
    SectionPtr->LineCount++;

    return NewLine;
}


PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION InfSectionPtr;
    PCWSTR UnicodeSectionName;

    UnicodeSectionName = ConvertAtoW (SectionName);

    InfSectionPtr = FindInfSectionInTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return InfSectionPtr;
}


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PINFSECTION Section;
    PINFFILE InfFile = (PINFFILE) Inf;

    Section = InfFile->FirstInfSection;
    while (Section) {
        if (StringIMatchW (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    )
{

    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfFile) {
        return InfFile->FirstInfSection;
    }

    return NULL;
}

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    )
{

    if (Section) {
        return Section->Next;
    }

    return NULL;
}




PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    )

{
    PCWSTR UnicodeKey;
    PINFLINE LinePtr;

    UnicodeKey = ConvertAtoW (Key);

    LinePtr = FindLineInInfSectionW (Inf, Section, UnicodeKey);

    FreeConvertedStr (UnicodeKey);

    return LinePtr;
}


PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatchW (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return GetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PCWSTR UnicodeSection;
    PINFLINE LinePtr;

    UnicodeSection = ConvertAtoW (Section);

    LinePtr = GetFirstLineInSectionStrW (Inf, UnicodeSection);

    FreeConvertedStr (UnicodeSection);

    return LinePtr;
}


PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PINFSECTION SectionPtr;
    PINFFILE Table = (PINFFILE) Inf;

    SectionPtr = FindInfSectionInTableW (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return GetFirstLineInSectionStruct (SectionPtr);
}


INT
pGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, (LONG)g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return (WORD) c;
    }

    ch = (WORD) c;

    c = pGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    // pGetInfFileByte return a byte value or -1.
    // Since we checked for -1 the next cast is valid.
    ch += (WORD)(c * 256);
    *Error = FALSE;

    return ch;
}


PCSTR
pGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == L'\r' || ch == L'\n') {
            EndPos += 2;
            if (ch == L'\r') {
                ch = pGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GbGrow (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a string supplying the line.  This string can be any length and
  is nul-terminated.  It does not include the \r or \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCWSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = GbMultiSzAppendW (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCWSTR) LineBuf->Buf;
}


BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  Inf - Specifies the INF to modify

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFFILE InfFile = (PINFFILE) Inf;

    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PmReleaseMemory (InfFile->InfPool, (PVOID) InfLine);
    return TRUE;
}


BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  InfFile - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFLINE InfLine;
    PINFLINE DelInfLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!DeleteLineInInfSection (InfFile, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        InfFile->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        InfFile->LastInfSection = Section->Prev;
    }

    PmReleaseMemory (InfFile->InfPool, (PVOID) Section->Name);
    PmReleaseMemory (InfFile->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\inf\inf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Provides wrappers for commonly used INF file handling routines. The wrappers provide, amount
    other things, easy memory allocation using a user supplied GROWBUFFER or PMHANDLE

Author:

    09-Jul-1997 Marc R. Whitten (marcw) - File creation.

Revision History:

    22-Oct-1998  marcw    Added capability to replace/append inf files.
    08-Oct-1997  jimschm  OEM version of SetupGetStringField

--*/

#include "pch.h"

GROWLIST g_FileNameList;
HASHTABLE g_NameTable;
static INT g_InfRefs;


VOID
InfGlobalInit (
    IN  BOOL Terminate
    )
{
    if (!Terminate) {
        MYASSERT (g_InfRefs >= 0);

        g_InfRefs++;
        if (g_InfRefs == 1) {
            ZeroMemory (&g_FileNameList, sizeof (GROWLIST));
            g_NameTable = HtAllocA();
        }

    } else {
        MYASSERT (g_InfRefs >= 0);

        g_InfRefs--;

        if (!g_InfRefs) {
            GlFree (&g_FileNameList);
            HtFree (g_NameTable);
            g_NameTable = NULL;
        }
    }
}


VOID
pAddFileRef (
    IN      HINF InfHandle,
    IN      PCSTR FileName
    )
{
    PBYTE data;
    UINT size;

    size = sizeof (InfHandle) + SizeOfStringA (FileName);
    data = MemAlloc (g_hHeap, 0, size);

    if (data) {
        CopyMemory (data, &InfHandle, sizeof (InfHandle));
        StringCopyA ((PSTR) (data + sizeof (InfHandle)), FileName);

        GlAppend (&g_FileNameList, data, size);
        MemFree (g_hHeap, 0, data);
    }
}


PBYTE
pFindFileRef (
    IN      HINF InfHandle,
    OUT     PUINT ListPos       OPTIONAL
    )
{
    UINT u;
    UINT count;
    HINF *p;

    count = GlGetSize (&g_FileNameList);

    for (u = 0 ; u < count ; u++) {
        p = (HINF *) GlGetItem (&g_FileNameList, u);
        if (*p == InfHandle) {
            if (ListPos) {
                *ListPos = u;
            }

            return (PBYTE) p;
        }
    }

    DEBUGMSG ((DBG_VERBOSE, "Can't find file name for INF handle 0x%08X", InfHandle));

    return NULL;
}


VOID
pDelFileRef (
    IN      HINF InfHandle
    )
{
    UINT pos;

    if (pFindFileRef (InfHandle, &pos)) {
        GlDeleteItem (&g_FileNameList, pos);
    }
}


PCSTR
pGetFileNameOfInf (
    IN      HINF Inf
    )
{
    PBYTE fileRef;

    fileRef = pFindFileRef (Inf, NULL);
    if (fileRef) {
        return (PCSTR) (fileRef + sizeof (HINF));
    }

    return NULL;
}


VOID
InfNameHandle (
    IN      HINF Inf,
    IN      PCSTR NewName,
    IN      BOOL OverwriteExistingName
    )
{
    PCSTR name;
    HASHITEM item;

    if (!NewName) {
        pDelFileRef (Inf);
        return;
    }

    name = pGetFileNameOfInf (Inf);

    if (!OverwriteExistingName && name) {
        return;
    }

    if (name) {
        pDelFileRef (Inf);
    }

    item = HtAddStringA (g_NameTable, NewName);
    name = HtGetStringFromItemA (item);

    if (name) {
        pAddFileRef (Inf, name);
    }
}


PBYTE
pAllocateSpace (
    IN PINFSTRUCT Context,
    IN UINT      Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space using the user specified allocator.

Arguments:

    Context - A valid INFSTRUCT which has been initialized either by a call to InitInfStruct or
              by using one of the static initializers (INITINFSTRUCT_GROWBUFFER or
              INITINFSTRUCT_PMHANDLE)

    Size    - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{

    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
        //
        // Allocate space using Poolmem.
        //
        rBytes = PmGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GbGrow (&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_PMHANDLE:
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PmCreateNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PmGetMemory(Context -> PoolHandle, Size);
        }
        break;
    }

    return rBytes;
}


VOID
InitInfStruct (
    OUT PINFSTRUCT Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  PMHANDLE PoolHandle   OPTIONAL
    )

/*++

Routine Description:

    This function initializes an INFSTRUCT with the user supplied allocator. It is used when
    user of the INF wrapper routines wishes to manage his own memory (i.e. such as when he
    already has a suitable allocator with sufficient scope created, etc.)

    There is no need to call this function if the user wishes to have the INF wrapper routines
    manage there own memory. Initialize your Init structure with one of either

    INITINFSTRUCT_POOLMEM or INITINFSTRUCT_GROWBUFFER, depending on your preference and needs
    for an allocator.



Arguments:

    Context      - Recieves the initialized INFSTRUCT.
    GrowBuffer   - An optional parameter containing a user supplied and initialized GROWBUFFER.
                   If this parameter is non-NULL, then PoolHandle should be NULL.
    PoolHandle   - An optional parameter containing a user supplied and initialized POOLHANDLE.
                   If this parameter is non-NULL, then GrowBuffer should be NULL.

    One of either GrowBuffer or PoolHandle *must* be specified.

Return Value:

    None.

--*/
{
    ZeroMemory(Context,sizeof(INFSTRUCT));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_PMHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_PMHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}

VOID
InfCleanUpInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

    InfCleanupInfStruct is responsible for cleaning up the data associated
    with an INFSTRUCT.  This is a mandatory call, unless the INFSTRUCT
    was initialized with InitInfStruct, called with a non-NULL grow buffer or
    pool handle.

    This routine can be called no matter how the INFSTRUCT was initialized.
    However, it will NOT free caller-owned grow buffers or pools.

Arguments:

    Context - Receives the properly cleaned up INFSTRUCT, ready to be
              reused.


Return Value:

     none

--*/

{
    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        GbFree (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_PMHANDLE && Context -> PoolHandle) {
        PmEmptyPool (Context->PoolHandle);
        PmDestroyPool (Context -> PoolHandle);
    }

    InitInfStruct (Context, NULL, NULL);
}


VOID
InfResetInfStruct (
    IN OUT PINFSTRUCT Context
    )

/*++

Routine Description:

  InfResetInfStruct resets the pool so memory can be recycled.  The intent is
  to allow a caller to reset the INFSTRUCT in order to release the memory
  obtained from getting INF fields.  This is useful in a loop of InfFindFirstLine/
  InfFindNextLine, where two or more fields are processed for each line.

  If only one field is processed in an InfFindFirstLine/InfFindNextLine loop,
  a grow buffer should be used instead.

  This routine empties the active pool block, a block that is 8K by default.  If
  more than the block size has been allocated, other memory blocks besides the
  active block will exist.  Because only the active block is reset, the pool will
  grow.

  If the caller expects more than the block size during one iteration, it should call
  InfCleanupInfStruct to free the pool completely.

Arguments:

  Context - Specifies the struct to reset


Return Value:

  none

--*/

{
    switch (Context -> Allocator) {
    case INF_USE_PMHANDLE:
    case INF_USE_PRIVATE_PMHANDLE:
        if (Context->PoolHandle) {
            PmEmptyPool (Context->PoolHandle);
        }
        break;
    //for some reason lint thought we forgot about INF_USE_GROWBUFFER and
    //INF_USE_PRIVATE_GROWBUFFER. This is not the case so...
    //lint -e(787)
    }
}


/*++

Routine Description:

    InfOpenInfFileA and InfOpenInfFileW are wrappers for the SetupOpenInfFile function.
    They cut down the number of parameters necessary to open an INF file by supplying
    the most common options for non-user specified parameters.

    A call to one of these functions is equivelant to
    SetupOpenInfFile(<FileName>,NULL,INF_STYLE_WIN4,NULL)

Arguments:

    FileName - Contains the name of the INF file to open. See the help for SetupOpenInfFile
               for special details concerning this parameter.

Return Value:

    If the INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
RealInfOpenInfFileA (
    IN PCSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )


{
    HINF rInf;

    MYASSERT(FileSpec);

    //
    // Open the main inf.
    //
    rInf = SetupOpenInfFileA (
                FileSpec,
                NULL,
                INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                NULL
                );

    DebugRegisterAllocation (INF_HANDLE, (PVOID) rInf, File, Line);
    pAddFileRef (rInf, FileSpec);

    return rInf;
}


HINF
RealInfOpenInfFileW (
    IN PCWSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR AnsiFileSpec;
    HINF rInf;

    AnsiFileSpec = ConvertWtoA (FileSpec);

    MYASSERT (AnsiFileSpec);

    rInf = InfOpenInfFileA (AnsiFileSpec);

    FreeConvertedStr (AnsiFileSpec);

    return rInf;
}


VOID
InfCloseInfFile (
    HINF Inf
    )
{

    DebugUnregisterAllocation (INF_HANDLE, Inf);
    pDelFileRef (Inf);

    SetupCloseInfFile (Inf);
}



/*++

Routine Description:

    InfOpenInfInAllSourcesA and InfOpenInfInAllSourcesW are special inf open routines that
    are capable of opening multiple versions of the same inf file that may be spread out across
    installation directories. The first INF file found will be opened with a call to
    SetupOpenInfFile. Additional files will be opened with SetupOpenAppendInfFile.

Arguments:

    InfSpecifier - Contains the source directory indepent portion of the path to a particular inf file.
                   For files located in the root of the source directory, this will simply be the name
                   of the file. For files located in a sub-directory of the source directory, this will
                   be a partial path.

    SourceCount  - Contains the number of source directories

    SourceDirectories - Contains an array of all the source directories.


Return Value:

    If any INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    )
{
    DWORD           index;
    HINF            rInf = INVALID_HANDLE_VALUE;
    PSTR            curPath;
    BOOL            atLeastOneInfOpened = FALSE;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsA(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistA (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileA(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGA ((LOG_ERROR, "Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileA(curPath,rInf,NULL)) {
                    LOGA ((LOG_ERROR,"Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringA(curPath);
    }

    return rInf;
}



HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    )
{
    DWORD index;
    HINF rInf = INVALID_HANDLE_VALUE;
    PWSTR curPath;
    BOOL atLeastOneInfOpened = FALSE;
    PCSTR AnsiPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsW(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistW (curPath)) {

            //
            // Open the INF file.
            //
            if (!atLeastOneInfOpened) {
                //
                // Since we have not (successfully) opened any INF file yet, use SetupOpenInfFile.
                //
                rInf = InfOpenInfFileW(curPath);
                atLeastOneInfOpened = rInf != INVALID_HANDLE_VALUE;
                if (rInf == INVALID_HANDLE_VALUE) {
                    LOGW ((LOG_ERROR, "OpenInfInAllSources: Error opening INF %s.", curPath));
                }
            }
            else {
                //
                // Open and append this INF file.
                //
                if (!SetupOpenAppendInfFileW(curPath,rInf,NULL)) {
                    LOGW ((LOG_ERROR,"OpenInfInAllSources: Error opening INF %s.",curPath));
                }
            }
        }

        //
        // Free this string.
        //
        FreePathStringW(curPath);
    }

    return rInf;
}



/*++

Routine Description:

    InfGetLineTextA and InfGetLineTextW are wrappers for the SetupGetLineText function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCT Context
    )

{
    PSTR    rLine = NULL;
    DWORD   requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextA(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextA(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextA: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}

PWSTR
InfGetLineTextW (
    IN OUT PINFSTRUCT Context
    )
{
    PWSTR rLine = NULL;
    DWORD requiredSize;


    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextW(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextW(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetLineTextW: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}


/*++

Routine Description:

    InfGetMultiSzFieldA and InfGetMultiSzFieldW are wrappers for the SetupGetMultiSzField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated fields or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldA(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldA: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCT       Context,
    IN     UINT            FieldIndex
    )
{

    DWORD   requiredSize;
    PWSTR   rFields = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldW(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetMultiSzFieldW: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

/*++

Routine Description:

    InfGetStringFieldA and InfGetStringFieldW are wrappers for the SetupGetStringField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetStringFieldA (
    IN OUT  PINFSTRUCT Context,
    IN      UINT FieldIndex
    )
{

    DWORD   requiredSize;
    PSTR    rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PSTR) pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldA(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCT    Context,
    IN     UINT       FieldIndex
    )
{

    DWORD requiredSize;
    PWSTR rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PWSTR) pAllocateSpace(Context,requiredSize*sizeof(WCHAR));

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldW(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetStringFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


BOOL
InfGetIntField (
    IN PINFSTRUCT Context,
    IN UINT    FieldIndex,
    IN PINT     Value
    )
/*++

Routine Description:

    InfGetIntField is a wrapper for SetupGetIntField. It is virtually identical to this function
    except that it takes care of getting the INFCONTEXT out of the INFSTRUCT structure.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line from which to retrieve the field.

    Value   - Recieves the value of the requested Int field.

Return Value:

     TRUE if the field was successfully retrieved, FALSE otherwise. Use GetLastError() To receive
     extended error information.

--*/
{
    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}

PBYTE
InfGetBinaryField (
    IN  PINFSTRUCT    Context,
    IN  UINT       FieldIndex
    )
/*++

Routine Description:

    InfGetBinaryField is a wrapper for the SetupGetBinaryField function. It reduces
    the number of parameters required to get the line text and takes care of
    allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.
    FieldIndex - the index within the line of the desired binary information.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/
{

    DWORD requiredSize;
    PBYTE rField = NULL;

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpace(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSG((DBG_ERROR,"InfGetBinaryField: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

/*++

Routine Description:

  InfGetIndexByLine is a straight wrapper for SetupGetLineByIndex. The only
  difference is the use of an PINFSTRUCT instead of a PINFCONTEXT.

Arguments:

  InfHandle - Contains a valid HINF.

  Section   - Contains the name of the section within the InfFile.

  Index     - Contains the index within the section of the line in question.

  Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

  TRUE if the function was called successfully, FALSE otherwise.

--*/


BOOL
InfGetLineByIndexA(
    IN HINF InfHandle,
    IN PCSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexA(InfHandle,Section,Index,&(Context -> Context));
}

BOOL
InfGetLineByIndexW(
    IN HINF InfHandle,
    IN PCWSTR Section,
    IN DWORD Index,
    OUT PINFSTRUCT Context
)
{
    return SetupGetLineByIndexW(InfHandle,Section,Index,&(Context -> Context));
}





/*++

Routine Description:

    InfFindFirstLineA and InfFindFirstLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS.

Arguments:


    InfHandle - Contains a valid HINF.

    Section   - Contains the name of the section within the InfFile.

    Key       - An optional parameter containing the name of the key within the section to find.
                If NULL, these routines will return the first line in the section.

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if lines exist in the section, FALSE otherwise.

--*/
BOOL
InfFindFirstLineA (
    IN  HINF         InfHandle,
    IN  PCSTR        Section,
    IN  PCSTR        Key, OPTIONAL
    OUT PINFSTRUCT    Context
    )
{

    return SetupFindFirstLineA (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

BOOL
InfFindFirstLineW (
    IN      HINF InfHandle,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PINFSTRUCT Context
    )
{

    return SetupFindFirstLineW (
        InfHandle,
        Section,
        Key,
        &(Context -> Context)
        );
}

/*++

Routine Description:

    InfFindNextLineA and InfFindNextLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS and
    need only one INFSTRUCT parameter.

Arguments:

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if there is another line in the section, FALSE otherwise.

--*/
BOOL
InfFindNextLine (
    IN OUT PINFSTRUCT    Context
    )
{

    return SetupFindNextLine (&(Context -> Context),&(Context -> Context));
}

UINT
InfGetFieldCount (
    IN PINFSTRUCT Context
    )
{
    return SetupGetFieldCount(&(Context  -> Context));
}



PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCT Context,
    IN      UINT Field
    )

/*++

Routine Description:

  InfGetOemStringField returns a string field in the OEM character set.
  This routine is used when accessing txtsetup.sif.  It is implemented
  only in the A version because UNICODE does not have a concept of OEM
  characters.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Field - Specifies the field number

Return Value:

  A pointer to the OEM string, or NULL if an error occurred.

--*/

{
    PCSTR Text;
    PSTR OemText;
    UINT Size;

    Text = InfGetStringFieldA (Context, Field);
    if (!Text) {
        return NULL;
    }

    Size = SizeOfStringA (Text);

    OemText = (PSTR) pAllocateSpace (Context, Size);
    if (!OemText) {
        return NULL;
    }

    //
    // We leave Text allocated because the caller will free everything
    // when they clean up Context.  Note the assumption that the conversion
    // doesn't change string length.
    //

    OemToCharBuffA (Text, OemText, Size);

    return OemText;
}


BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PSTR ReturnBuffer,                  OPTIONAL
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize                 OPTIONAL
    )

/*++

Routine Description:

  SetupGetOemStringFieldA is a SetupGetStringField that converts the
  return text to the OEM character set.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Index - Specifies the field number

  ReturnBuffer - Specifies the buffer to fill the text into

  ReturnBufferSize - Specifies the size of ReturnBuffer in bytes

  RequiredSize - Receives the size of the buffer needed

Return Value:

  TRUE if successful, FALSE if failure.

--*/

{
    PSTR OemBuf;

    UINT Size;

    if (!SetupGetStringFieldA (
            Context,
            Index,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            )) {
        return FALSE;
    }

    if (!ReturnBuffer) {
        return TRUE;
    }

    Size = SizeOfStringA (ReturnBuffer);

    OemBuf = (PSTR) MemAlloc (g_hHeap, 0, Size);

    OemToCharBuffA (ReturnBuffer, OemBuf, Size);
    StringCopyA (ReturnBuffer, OemBuf);
    MemFree (g_hHeap, 0, OemBuf);

    return TRUE;
}


VOID
InfLogContext (
    IN      PCSTR LogType,
    IN      HINF InfHandle,
    IN      PINFSTRUCT InfStruct
    )
{
    PCSTR fileName;
    PSTR field0 = NULL;
    PSTR field1 = NULL;
    PSTR lineData;
    UINT requiredSize;

    //
    // Log the file name, if one exists
    //

    fileName = pGetFileNameOfInf (InfHandle);

    if (fileName) {
        LOGA ((
            LogType,
            "%s",
            fileName
            ));
    }

    //
    // Get field 0
    //

    if (SetupGetStringFieldA(
            &InfStruct->Context,
            0,
            NULL,
            0,
            &requiredSize
            )) {
        field0 = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (!SetupGetStringFieldA(
                &InfStruct->Context,
                0,
                field0,
                requiredSize,
                NULL
                )) {
            MemFree (g_hHeap, 0, field0);
            field0 = NULL;
        }
    }

    //
    // Get field 1
    //

    if (SetupGetStringFieldA(
            &InfStruct->Context,
            1,
            NULL,
            0,
            &requiredSize
            )) {
        field1 = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (!SetupGetStringFieldA(
                &InfStruct->Context,
                1,
                field1,
                requiredSize,
                NULL
                )) {
            MemFree (g_hHeap, 0, field1);
            field1 = NULL;
        }
    }

    //
    // Compare them, and if they are the same, eliminate field 0
    //

    if (field0 && field1) {
        if (StringMatchA (field0, field1)) {
            MemFree (g_hHeap, 0, field0);
            field0 = NULL;
        }
    }

    //
    // Now print the entire line
    //

    if (SetupGetLineTextA (
            &InfStruct->Context,
            NULL,
            NULL,
            NULL,
            NULL,
            0,
            &requiredSize
            )) {
        lineData = (PSTR) MemAlloc (g_hHeap, 0, requiredSize);

        if (SetupGetLineTextA (
                &InfStruct->Context,
                NULL,
                NULL,
                NULL,
                lineData,
                requiredSize,
                NULL
                )) {

            if (field0) {
                LOGA ((LogType, "Line: %s = %s", field0, lineData));
            } else {
                LOGA ((LogType, "Line: %s", lineData));
            }

            MemFree (g_hHeap, 0, lineData);
        }
    }

    if (field0) {
        MemFree (g_hHeap, 0, field0);
    }

    if (field1) {
        MemFree (g_hHeap, 0, field1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\log\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    ovidiut     08-Oct-1999 Updated for new coding conventions and Win64 compliance
    ovidiut     23-Oct-1998 Implemented a new log mechanism and added new logging capabilities
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    ovidiut     15-Mar-2000 Eliminate dependencies on HashTable/PoolMemory

--*/


#include "pch.h"

//
// Includes
//

// None

//
// Strings
//

#define S_COLUMNDOUBLELINEA     ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW     L":\r\n\r\n"
#define S_NEWLINEA              "\r\n"
#define S_NEWLINEW              L"\r\n"
#define DEBUG_SECTION           "Debug"
#define ENTRY_ALL               "All"
#define ENTRY_DEFAULTOVERRIDE   "DefaultOverride"

//
// Constants
//

#define OUTPUT_BUFSIZE_LARGE    8192
#define OUTPUT_BUFSIZE_SMALL    1024
#define MAX_MSGTITLE_LEN        13
#define MSGBODY_INDENT          14
#define SCREEN_WIDTH            80
#define MAX_TYPE                32
#define TYPE_ARRAY_SIZE         10

//
// Macros
//

#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)

#ifdef DEBUG
    #define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP)
#else
    #define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)      ((buf) + (DWSIZEOF(buf) / DWSIZEOF(buf[0])) - 1)

// This constant sets the default output
#ifndef DEBUG
    #define NORMAL_DEFAULT      OD_LOGFILE
#else
    #define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

#ifdef DEBUG
    #define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);
#else
    #define PRIVATE_ASSERT(expr)
#endif // DEBUG

#define NEWLINE_CHAR_COUNTA  (DWSIZEOF (S_NEWLINEA) / DWSIZEOF (CHAR) - 1)
#define NEWLINE_CHAR_COUNTW  (DWSIZEOF (S_NEWLINEW) / DWSIZEOF (WCHAR) - 1)

//
// Types
//

typedef DWORD   OUTPUTDEST;

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;

typedef struct {
    CHAR Type[MAX_TYPE];
    DWORD OutputDest;
} MAPTYPE2OUTDEST, *PMAPTYPE2OUTDEST;

//
// Globals
//

const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};

const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

BOOL g_LogInit;
HMODULE g_LibHandle;
CHAR g_MainLogFile [MAX_PATH] = "";
HANDLE g_LogMutex;
INT g_LoggingNow;

// a window handle for popup parent
HWND g_LogPopupParentWnd = NULL;
// thread id that set this window handle
DWORD g_InitThreadId = 0;
DWORD g_LogError;

//
// type table elements
//
PMAPTYPE2OUTDEST g_FirstTypePtr = NULL;
DWORD g_TypeTableCount = 0;
DWORD g_TypeTableFreeCount = 0;

OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
BOOL g_HasTitle = FALSE;
CHAR g_LastType [MAX_TYPE];
BOOL g_SuppressAllPopups = FALSE;
BOOL g_ResetLog = FALSE;
PLOGCALLBACKA g_LogCallbackA;
PLOGCALLBACKW g_LogCallbackW;

#ifdef DEBUG

CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
CHAR g_DebugLogFile[MAX_PATH];
// If g_DoLog is TRUE, then, debug logging is enabled in the
// checked build even if there is no debug.inf.
BOOL g_DoLog = FALSE;

DWORD g_FirstTickCount = 0;
DWORD g_LastTickCount  = 0;

#endif

//
// Macro expansion list
//

#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_LOGFILE|OD_DEBUGGER)                             \
        DEFMAC(DBG_ASSERT,DEFAULT_ERROR_FLAGS|OD_UNATTEND_POPUP)                \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#endif


//
// Private function prototypes
//

VOID
InitializeLog (
    VOID
    );


//
// Macro expansion definition
//

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/

#define DEFMAC(typestr, flags)      {typestr, (flags)},

DEFAULT_DESTINATION g_DefaultDest[] = {
    TYPE_DEFAULTS /* , */
    {NULL, 0}
};

#undef DEFMAC


//
// Code
//


#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBoxA (NULL, buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    UINT i;

    for (i = 0; i < DWSIZEOF (g_IgnoreKeys) / DWSIZEOF (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    UINT i;

    for (i = 0; i < DWSIZEOF (g_String2Binary) / DWSIZEOF (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    PMAPTYPE2OUTDEST last;
    OUTPUTDEST outDest = OD_UNDEFINED;

    if (g_FirstTypePtr) {
        typePtr = g_FirstTypePtr;
        last = g_FirstTypePtr + g_TypeTableCount;
        while (typePtr < last) {
            if (StringIMatchA (typePtr->Type, Type)) {
                outDest = typePtr->OutputDest;
#ifdef DEBUG
                if (g_DoLog) {
                    outDest |= OD_DEBUGLOG;
                }
#endif
                break;
            }
            typePtr++;
        }
    }

    return outDest;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        outDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        outDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (outDest)) {

            //
            // just return the default
            //

            outDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        outDest |= OD_DEBUGLOG;
    }
#endif


    return outDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    outDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (outDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LOGSEV_INFORMATION.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LOGSEV_ERROR;
    }

    return LOGSEV_INFORMATION;
}


BOOL
LogSetErrorDest (
    IN      PCSTR Type,
    IN      OUTPUT_DESTINATION OutDest
    )

/*++

Routine Description:

  LogSetErrorDest adds a <Type, OutDest> association
  to the table g_FirstTypePtr. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    UINT u;

    //
    // Try to locate the existing type
    //

    for (u = 0 ; u < g_TypeTableCount ; u++) {
        typePtr = g_FirstTypePtr + u;
        if (StringIMatchA (typePtr->Type, Type)) {
            typePtr->OutputDest = OutDest;
            return TRUE;
        }
    }

    //
    // look if any free slots are available first
    //
    if (!g_TypeTableFreeCount) {

        PRIVATE_ASSERT (g_hHeap != NULL);

        if (!g_FirstTypePtr) {
            typePtr = HeapAlloc (
                            g_hHeap,
                            0,
                            DWSIZEOF (MAPTYPE2OUTDEST) * TYPE_ARRAY_SIZE
                            );
        } else {
            typePtr = HeapReAlloc (
                            g_hHeap,
                            0,
                            g_FirstTypePtr,
                            DWSIZEOF (MAPTYPE2OUTDEST) * (TYPE_ARRAY_SIZE + g_TypeTableCount)
                            );
        }

        if (!typePtr) {
            return FALSE;
        }

        g_FirstTypePtr = typePtr;
        g_TypeTableFreeCount = TYPE_ARRAY_SIZE;
    }

    typePtr = g_FirstTypePtr + g_TypeTableCount;
    StringCopyByteCountA (typePtr->Type, Type, DWSIZEOF (typePtr->Type));
    typePtr->OutputDest = OutDest;

    g_TypeTableCount++;
    g_TypeTableFreeCount--;

    return TRUE;
}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST outDest = OD_UNDEFINED;
    CHAR value[OUTPUT_BUFSIZE_SMALL];
    UINT field;

    for (field = SetupGetFieldCount (InfContext); field > 0; field--) {
        if (SetupGetStringFieldA (
                InfContext,
                field,
                value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            outDest |= pConvertToOutputType(value);
        }
    }

    return outDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_FirstTypePtr table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT infContext;
    OUTPUTDEST outDest;
    CHAR key[OUTPUT_BUFSIZE_SMALL];

    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &infContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &infContext,
                    0,
                    key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }

            if (pIgnoreKey (key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&infContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&infContext);
                } else {
                    outDest = pGetAttributes(&infContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (outDest)) {
                        if (!LogSetErrorDest (key, outDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&infContext, &infContext));
    }

    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      UINT Indent
    )

{
    UINT i;
    PSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' '; //lint !e613 !e794
    }

    *p = 0; //lint !e613 !e794
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      UINT  Indent
    )
{
    UINT i;
    PWSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = CharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';    //lint !e613
    }

    *p = 0; //lint !e613
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCSTR lastSpace = NULL;
    PCSTR prevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && column < columnMax) {

        if (ch == '\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
            column++;
        } else {
            if (_ismbcspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        lastSpace = prevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (lastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCWSTR lastSpace = NULL;
    PCWSTR prevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && column < columnMax) {

        if (ch == L'\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
        } else {
            if (iswspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space was found
        lastSpace = prevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return lastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in buffer, which is no larger than Size.

Arguments:

  buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    CHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR nextLine;
    PCSTR s;
    PSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 3;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PSTR)pFindNextLineA (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (IsLeadByte (s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (buffer, indentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    WCHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR nextLine;
    PCWSTR s;
    PWSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCWSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 1;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PWSTR)pFindNextLineW (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyCharCountW (buffer, indentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      DWORD LastError
    )
{
    PSTR append;
    DWORD errMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    append = GetEndOfStringA (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + BufferSize - append);  //lint !e613

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (append, errMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (append, errMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      DWORD LastError
    )
{
    PWSTR append;
    DWORD errMsgLen;

    StringCopyCharCountW (MsgWithErr, Message, BufferSize / DWSIZEOF(WCHAR));
    append = GetEndOfStringW (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + (BufferSize / DWSIZEOF(WCHAR)) - append);

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  formattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR myMsgBody;
    PSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorA (bodyWithErr, DWSIZEOF (bodyWithErr), Body, LastError);
    }

    StringCopyByteCountA (formattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyByteCountA (currentPos, myMsgBody, remaining);
    pHangingIndentA (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringA (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTA + 1 < formattedMsg + BufferSize) { //lint !e613
        *currentPos++ = '\r';   //lint !e613
        *currentPos++ = '\n';   //lint !e613
        *currentPos = 0;        //lint !e613
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR myMsgBody;
    PWSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorW (bodyWithErr, DWSIZEOF (bodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (typeW, Type);

    StringCopyCharCountW (formattedMsg, typeW, MAX_MSGTITLE_LEN);
    pPadTitleW (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    StringCopyCharCountW (currentPos, myMsgBody, remaining);
    pHangingIndentW (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = GetEndOfStringW (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTW + 1 < formattedMsg + BufferSize) {
        *currentPos++ = L'\r';
        *currentPos++ = L'\n';
        *currentPos = 0;
    }
}


PCSTR
pGetSeverityStr (
    IN      LOGSEVERITY Severity,
    IN      BOOL Begin
    )
{
    switch (Severity) {
    case LogSevFatalError:
        return Begin?"":"\r\n***";
    case LogSevError:
        return Begin?"":"\r\n***";
    case LogSevWarning:
        return "";
    }
    return "";
}

/*++

Routine Description:

  pWriteToMainLogA and pWriteToMainLogW log the specified message to the main
  end-user log.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  formattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToMainLogA (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        WriteFileStringA (logHandle, FormattedMsg);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


VOID
pWriteToMainLogW (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCWSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        WriteFileStringW (logHandle, FormattedMsg);
        WriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR currentPos = buffer;
#endif
    UINT mbStyle;
    LONG rc;
    OUTPUTDEST outDest;
    HWND parentWnd;
    PCSTR displayMessage = Msg;
    LOGSEVERITY severity = pGetSeverityFromType (Type);

    outDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                currentPos += wsprintfA (buffer, " [ERROR=%u]", LastError);
            } else {
                currentPos += wsprintfA (buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (outDest)) {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (currentPos > buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            displayMessage = formattedMsg;
            StringCopyByteCountA (
                formattedMsg,
                Msg,
                ARRAYSIZE(formattedMsg) - (HALF_PTR) (currentPos - buffer)
                );
            StringCatA (formattedMsg, buffer);
        }
#endif

        switch (severity) {

        case LOGSEV_FATAL_ERROR:
            mbStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            mbStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            mbStyle = MB_ICONEXCLAMATION;
            break;

        default:
            mbStyle = MB_ICONINFORMATION;

        }
        mbStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (outDest)) {
            mbStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            mbStyle |= MB_OKCANCEL;
        }
#else
        mbStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            parentWnd = g_LogPopupParentWnd;

        } else {

            parentWnd = NULL;

        }

        rc = MessageBoxA (parentWnd, displayMessage, Type, mbStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            LogSetErrorDest (Type, outDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
    PCSTR msgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    msgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, msgA, LastError, Forced);
    FreeConvertedStr (msgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackA) {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = Message;
            callbackArgA.FormattedMessage = formattedMsg;
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);
        } else {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = ConvertAtoW (Message);
            callbackArgW.FormattedMessage = ConvertAtoW (formattedMsg);
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);

            if (callbackArgW.Message) {
                FreeConvertedStr (callbackArgW.Message);
            }
            if (callbackArgW.FormattedMessage) {
                FreeConvertedStr (callbackArgW.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogA (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringA (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fprintf (stderr, "%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                            g_DebugLogFile,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackW) {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = Message;
            callbackArgW.FormattedMessage = formattedMsg;
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);
        } else {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = ConvertWtoA (Message);
            callbackArgA.FormattedMessage = ConvertWtoA (formattedMsg);
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);

            if (callbackArgA.Message) {
                FreeConvertedStr (callbackArgA.Message);
            }
            if (callbackArgA.FormattedMessage) {
                FreeConvertedStr (callbackArgA.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogW (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringW (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fwprintf (stderr, L"%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                        g_DebugLogFile,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            WriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(output, OUTPUT_BUFSIZE_LARGE, Format, args);
    }

    pIndentMessageA (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputA (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (
                !MUST_BE_LOCALIZED (outDest) ||
                (SHIFTRIGHT16((UBINT)Format) == 0)
                );
        }

        pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR formatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((UBINT)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(UBINT) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {
        KnownSizeAtoW (formatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(output, OUTPUT_BUFSIZE_LARGE, formatW, args);
    }

    pIndentMessageW (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputW (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((UBINT)Format) == 0);
        }

        pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((UBINT)Format) == 0) {
            pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


BOOL
pInitLog (
    IN      BOOL FirstTimeInit,
    IN      HWND LogPopupParentWnd,     OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallbackA, OPTIONAL
    IN      PLOGCALLBACKW LogCallbackW  OPTIONAL
    )

/*++

Routine Description:

  pInitLog actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is not optional on the first call
                       to this function.

  OrgPopupParentWnd  - Receives the original parent window.

  LogFile - Specifies the name of the log file. If not specified,
            logging goes to a default file (%windir%\cobra.log).

  LogCallback - Specifies a function to call instead of the internal
                logging functions.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;
    PDEFAULT_DESTINATION dest;
#ifdef DEBUG
    PSTR p;
#endif

    __try {

        g_LogInit = FALSE;

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_FirstTypePtr);

            dest = g_DefaultDest;

            while (dest->Type) {
                LogSetErrorDest (dest->Type, dest->Flags);
                dest++;
            }

            GetWindowsDirectoryA (g_MainLogFile, ARRAYSIZE(g_MainLogFile));
            StringCatA (g_MainLogFile, "\\cobra");

#ifdef DEBUG
            StringCopyA (g_DebugLogFile, g_MainLogFile);
            StringCatA (g_DebugLogFile, ".dbg");
            g_DebugInfPathBufA[0] = g_DebugLogFile[0];
#endif

            StringCatA (g_MainLogFile, ".log");
        }

        if (LogFile) {
            StackStringCopyA (g_MainLogFile, LogFile);

#ifdef DEBUG
            StringCopyA (g_DebugLogFile, g_MainLogFile);
            p = _mbsrchr (g_DebugLogFile, '.');
            if (p) {
                if (_mbschr (p, TEXT('\\'))) {
                    p = NULL;
                }
            }

            if (p) {
                StringCopyA (p, ".dbg");
            } else {
                StringCatA (g_DebugLogFile, ".dbg");
            }


#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_MainLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_MainLogFile);
        }

#ifdef DEBUG
        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (LogCallbackA) {
            g_LogCallbackA = LogCallbackA;
        }

        if (LogCallbackW) {
            g_LogCallbackW = LogCallbackW;
        }

#ifdef DEBUG
        if (FirstTimeInit) {
            //
            // get user's preferences
            //

            hInf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            if (INVALID_HANDLE_VALUE != hInf && pGetUserPreferences(hInf)) {
                g_DoLog = TRUE;
            }
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        result = TRUE;
    }
    __finally {

        if (hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (hInf);
        }

        if (!result) {  //lint !e774

            if (g_FirstTypePtr) {
                HeapFree (g_hHeap, 0, g_FirstTypePtr);
                g_FirstTypePtr = NULL;
                g_TypeTableCount = 0;
                g_TypeTableFreeCount = 0;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif
        }

        g_LogInit = TRUE;
        g_ResetLog = FALSE;
    }

    return result;
}


VOID
LogSetVerboseLevel (
    IN      OUTPUT_DESTINATION Level
    )
{
    OUTPUT_DESTINATION Debugger = 0;

    if (Level > 3) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    LogSetErrorDest (LOG_FATAL_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_MODULE_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_WARNING, Level > 1 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_INFORMATION, Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest ("Assert", OD_POPUP|OD_ERROR|Debugger);
    LogSetErrorDest ("Verbose", Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
}

VOID
LogSetVerboseBitmap (
    IN      LOG_LEVEL Bitmap,
    IN      LOG_LEVEL BitsToAdjustMask,
    IN      BOOL EnableDebugger
    )
{

    OUTPUT_DESTINATION Debugger = 0;

    if (EnableDebugger) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    if (BitsToAdjustMask & LL_FATAL_ERROR) {
        LogSetErrorDest (LOG_FATAL_ERROR, (Bitmap & LL_FATAL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_MODULE_ERROR) {
        LogSetErrorDest (LOG_MODULE_ERROR, (Bitmap & LL_MODULE_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_ERROR) {
        LogSetErrorDest (LOG_ERROR, (Bitmap & LL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_WARNING) {
        LogSetErrorDest (LOG_WARNING, (Bitmap & LL_WARNING) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_INFORMATION) {
        LogSetErrorDest (LOG_INFORMATION, (Bitmap & LL_INFORMATION) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_STATUS) {
        LogSetErrorDest (LOG_STATUS, (Bitmap & LL_STATUS) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_UPDATE) {
        LogSetErrorDest (LOG_UPDATE, (Bitmap & LL_UPDATE) ? OD_CONSOLE : OD_SUPPRESS);
    }
}


/*++

Routine Description:

  pInitialize initializes the log system calling the worker pInitLog. This function
  should be only called once

Arguments:
  None

Return Value:

  TRUE if log system successfully initialized

--*/

BOOL
pInitialize (
    VOID
    )
{
    return pInitLog (TRUE, NULL, NULL, NULL, NULL, NULL);
}

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pInitLog.
  This function may be called any number of times, but only after pInitialize()

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

  LogFile - Specifies a new log file name

  LogCallback - Specifies a callback function that handles the log message (so
                one module can pass log messages to another)

  ResourceImage - Specifies the module path to use in FormatMessage when the
                  message is resource-based

Return Value:

  TRUE if log system was successfully re-initialized

--*/

BOOL
LogReInitA (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallback   OPTIONAL
    )
{
    return pInitLog (FALSE, NewParent, OrgParent, LogFile, LogCallback, NULL);
}


BOOL
LogReInitW (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCWSTR LogFile,             OPTIONAL
    IN      PLOGCALLBACKW LogCallback   OPTIONAL
    )
{
    CHAR ansiLogFile[MAX_MBCHAR_PATH];

    if (LogFile) {
        KnownSizeWtoA (ansiLogFile, LogFile);
        LogFile = (PWSTR) ansiLogFile;
    }

    return pInitLog (FALSE, NewParent, OrgParent, (PCSTR) LogFile, NULL, LogCallback);
}


VOID
LogBegin (
    IN      HMODULE ModuleInstance
    )
{
    DWORD threadError;
    DWORD rc;

    threadError = GetLastError ();

    if (!g_LogMutex) {
        InitializeLog();
    }

    rc = WaitForSingleObject (g_LogMutex, INFINITE);

    PRIVATE_ASSERT (rc == WAIT_OBJECT_0 || rc == WAIT_ABANDONED);

    if (rc == WAIT_ABANDONED) {
        g_LoggingNow = 0;
    }

    if (!g_LoggingNow) {
        g_LibHandle = ModuleInstance;
        SetLastError (threadError);
        g_LogError = threadError;
    }

    g_LoggingNow++;
}

VOID
LogEnd (
    VOID
    )
{
    g_LoggingNow--;

    if (!g_LoggingNow) {
        g_LibHandle = g_hInst;
        SetLastError (g_LogError);
    }

    ReleaseMutex (g_LogMutex);
}


VOID
pDisableLog (
    VOID
    )
{
    g_LogInit = FALSE;
}


VOID
pExitLog (
    VOID
    )

/*++

Routine Description:

  pExitLog cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{
    g_LogInit = FALSE;

    WaitForSingleObject (g_LogMutex, 60000);
    CloseHandle (g_LogMutex);
    g_LogMutex = NULL;

    if (g_FirstTypePtr) {
        HeapFree (g_hHeap, 0, g_FirstTypePtr);
        g_FirstTypePtr = NULL;
        g_TypeTableCount = 0;
        g_TypeTableFreeCount = 0;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


#ifdef DEBUG

VOID
_cdecl
DbgLogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}

#endif

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];

    if (!g_LogInit) {
        return;
    }

    StringCopyByteCountA (g_LastType, Type, DWSIZEOF (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCopyByteCountA (formattedMsg, Title, DWSIZEOF (formattedMsg) - DWSIZEOF (S_COLUMNDOUBLELINEA));
    StringCatA (formattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    if (!g_LogInit) {
        return;
    }

    StringCopyCharCountA (g_LastType, Type, DWSIZEOF (g_LastType));

    if (!Title) {
        KnownSizeAtoW (typeW, Type);
        Title = typeW;
    }

    StringCopyCharCountW (formattedMsg, Title, DWSIZEOF (formattedMsg) - DWSIZEOF (S_COLUMNDOUBLELINEW));
    StringCatW (formattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (output, Line, DWSIZEOF (output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNTA, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNTA] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatA (output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, output, FALSE);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCWSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyCharCountW (output, Line, DWSIZEOF (output) / DWSIZEOF (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNTW, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNTW] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        StringCatW (output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, output, FALSE);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, FALSE);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, FALSE);
}


#ifdef DEBUG
VOID
DbgDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, TRUE);
}


VOID
DbgDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, TRUE);
}
#endif


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    CHAR date[OUTPUT_BUFSIZE_SMALL];
    CHAR ttime[OUTPUT_BUFSIZE_SMALL];
    PSTR appendPos, end;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            ttime,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyA (ttime,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + _vsnprintf (msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    end = msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        appendPos,
        ((UBINT)end - (UBINT)appendPos) / (DWSIZEOF (CHAR)),
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        date,
        ttime,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", msg);
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    WCHAR msgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR dateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR timeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR formatW;
    PWSTR appendPosW, endW;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            dateW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (dateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            timeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCopyW (timeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    formatW = ConvertAtoW (Format);
    appendPosW = msgW + _vsnwprintf (msgW, OUTPUT_BUFSIZE_LARGE, formatW, args);
    FreeConvertedStr (formatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    endW = msgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        appendPosW,
        ((UBINT)endW - (UBINT)appendPosW) / (DWSIZEOF (WCHAR)),
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        dateW,
        timeW,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", msgW);
}

#endif // DEBUG


VOID
InitializeLog (
    VOID
    )
{
    g_LogMutex = CreateMutex (NULL, FALSE, TEXT("cobra_log_mutex"));
    UtInitialize (NULL);
    pInitialize ();
}


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
        g_LibHandle = hInstance;
        InitializeLog ();

        PRIVATE_ASSERT (g_LogMutex != NULL);
    }

    return TRUE;
}

VOID
LogDeleteOnNextInit(
    VOID
    )
{
    g_ResetLog = TRUE;
}

#ifdef DEBUG

VOID
LogCopyDebugInfPathA(
    OUT     PSTR MaxPathBuffer
    )
{
    StringCopyByteCountA (MaxPathBuffer, g_DebugInfPathBufA, MAX_PATH);
}


VOID
LogCopyDebugInfPathW(
    OUT     PWSTR MaxPathBuffer
    )
{
    KnownSizeAtoW (MaxPathBuffer, g_DebugInfPathBufA);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\linkpif\linkpif.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    linkpif.c

Abstract:

    Functions to query and modify LNK and PIF files.

Author:

    Calin Negreanu (calinn) 07-Sep-1998

Revision History:

--*/


//
// Includes
//

#include "pch.h"
#include <pif.h>        // private\windows\inc

//
// Debug constants
//

#define DBG_VERSION     "LnkPif"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    CoInitialize (NULL);

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkA, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    //
    // Initialize COM
    //
    CoInitialize (NULL);

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkW, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}

PVOID
pFindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    )

/*++

Routine Description:

  pFindEnhPifSignature finds a certain PIF structure inside a PIF file (if it exists)
  based on a signature.

Arguments:

  FileImage - image of the PIF file mapped into memory

  Signature - structure signature

Return Value:

  address of the PIF structure, or NULL if non existent

--*/

{
    PBYTE tempPtr;
    PBYTE lastPtr;
    PVOID result = NULL;
    BOOL finished = FALSE;

    PPIFEXTHDR pifExtHdr;

    lastPtr = (PBYTE) FileImage;
    tempPtr = (PBYTE) FileImage;
    tempPtr += sizeof (STDPIF);

    pifExtHdr = (PPIFEXTHDR) tempPtr;
    __try {
        do {
            if (tempPtr < lastPtr) {
                result = NULL;
                break;
            } else {
                lastPtr = tempPtr;
            }
            finished = pifExtHdr->extnxthdrfloff == LASTHDRPTR;
            if (StringMatchA (pifExtHdr->extsig, Signature)) {
                result = tempPtr + sizeof (PIFEXTHDR);
                break;
            }
            else {
                tempPtr = (PBYTE)FileImage + pifExtHdr->extnxthdrfloff;
                pifExtHdr = (PPIFEXTHDR) tempPtr;
            }

        } while (!finished);
    }
    __except (1) {
        // something went wrong trying to access PIF file. Let's exit with NULL
        return NULL;
    }
    return result;
}

BOOL
ExtractPifInfoA(
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData       OPTIONAL
    )
{
    PVOID  fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    CHAR   tempStr [MEMDB_MAX];
    CHAR   target1 [MEMDB_MAX];
    PSTR   strPtr;
    PSTR   dontCare;

    PSTDPIF    stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    BOOL result = TRUE;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }
    *IconNumber = 0;
    *MsDosMode = FALSE;

    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof(LNK_EXTRA_DATA));
    }

    __try {
        fileImage = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;


            //
            // getting working directory
            //
            _mbsncpy (tempStr, stdPif->defpath, PIFDEFPATHSIZE);

            // we might have a path terminated with a wack, we don't want that
            strPtr = _mbsdec (tempStr, GetEndOfStringA (tempStr));
            if (strPtr) {
                if (_mbsnextc (strPtr) == '\\') {
                    *strPtr = 0;
                }
            }
            // now get the long path.
            if (WorkDir) {
                *WorkDir = DuplicatePathStringA (tempStr, 0);
            }

            //
            // getting PIFs target
            //
            _mbsncpy (target1, stdPif->startfile, PIFSTARTLOCSIZE);

            // in most cases, the target is without a path. We try to build the path, either
            // by using WorkDir or by calling SearchPath to look for this file.
            if (*target1) {//non empty target
                strPtr = _mbsrchr (target1, '\\');
                if (!strPtr) {
                    if (WorkDir && (*WorkDir)[0]) {
                        StringCopyA (tempStr, *WorkDir);
                        StringCatA  (tempStr, "\\");
                        StringCatA  (tempStr, target1);
                    }
                    else {
                        if (!SearchPathA (NULL, target1, NULL, MEMDB_MAX, tempStr, &dontCare)) {
                            DEBUGMSG ((DBG_WARNING, "Could not find path for PIF target:%s", FileName));
                            StringCopyA (tempStr, target1);
                        }
                    }
                }
                else {
                    StringCopyA (tempStr, target1);
                }
                // now get the long path
                if (Target) {
                    *Target = DuplicatePathStringA (tempStr, 0);
                }
            }

            //
            // getting PIFs arguments
            //
            _mbsncpy (tempStr, stdPif->params, PIFPARAMSSIZE);
            if (Params) {
                *Params = DuplicatePathStringA (tempStr, 0);
            }

            //
            // let's try to read the WENHPIF40 structure
            //
            wenhPif40 = pFindEnhPifSignature (fileImage, WENHHDRSIG40);
            if (wenhPif40) {
                if (IconPath) {
                    *IconPath = DuplicatePathStringA (wenhPif40->achIconFileProp, 0);
                }
                *IconNumber = wenhPif40->wIconIndexProp;
                if (ExtraData) {
                    ExtraData->xSize = 80;
                    ExtraData->ySize = wenhPif40->vidProp.cScreenLines;
                    if (ExtraData->ySize < 25) {
                        ExtraData->ySize = 25;
                    }
                    ExtraData->QuickEdit = !(wenhPif40->mseProp.flMse & MSE_WINDOWENABLE);
                    ExtraData->CurrentCodePage = wenhPif40->fntProp.wCurrentCP;
                    // now let's do some crazy things trying to get the font used
                    {
                        LOGFONTA logFont;
                        HDC dc;
                        HFONT font;
                        HGDIOBJ oldObject;
                        TEXTMETRIC tm;

                        ZeroMemory (&logFont, sizeof (LOGFONTA));
                        logFont.lfHeight = wenhPif40->fntProp.cyFontActual;
                        logFont.lfWidth = wenhPif40->fntProp.cxFontActual;
                        logFont.lfEscapement = 0;
                        logFont.lfOrientation = 0;
                        logFont.lfWeight = FW_DONTCARE;
                        logFont.lfItalic = FALSE;
                        logFont.lfUnderline = FALSE;
                        logFont.lfStrikeOut = FALSE;
                        logFont.lfCharSet = DEFAULT_CHARSET;
                        logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
                        logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                        logFont.lfQuality = DEFAULT_QUALITY;
                        logFont.lfPitchAndFamily = DEFAULT_PITCH;
                        if (wenhPif40->fntProp.flFnt & FNT_TT) {
                            _mbsncpy (logFont.lfFaceName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                            _mbsncpy (ExtraData->FontName, wenhPif40->fntProp.achTTFaceName, LF_FACESIZE);
                        } else {
                            _mbsncpy (logFont.lfFaceName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                            _mbsncpy (ExtraData->FontName, wenhPif40->fntProp.achRasterFaceName, LF_FACESIZE);
                        }
                        dc = CreateDCA ("DISPLAY", NULL, NULL, NULL);
                        if (dc) {
                            font = CreateFontIndirectA (&logFont);
                            if (font) {
                                oldObject = SelectObject (dc, font);

                                if (GetTextMetrics (dc, &tm)) {
                                    ExtraData->xFontSize = tm.tmAveCharWidth;
                                    ExtraData->yFontSize = tm.tmHeight;
                                    ExtraData->FontWeight = tm.tmWeight;
                                    ExtraData->FontFamily = tm.tmPitchAndFamily;
                                }
                                SelectObject (dc, oldObject);
                                DeleteObject (font);
                            }
                            DeleteDC (dc);
                        }
                    }
                }
            }
            w386ext30 = pFindEnhPifSignature (fileImage, W386HDRSIG30);
            if (w386ext30) {
                if (((w386ext30->PfW386Flags & fRealMode      ) == fRealMode      ) ||
                    ((w386ext30->PfW386Flags & fRealModeSilent) == fRealModeSilent)
                    ) {
                    *MsDosMode = TRUE;
                }
                if (ExtraData) {
                    ExtraData->FullScreen = (w386ext30->PfW386Flags & fFullScreen) != 0;
                }
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            result = FALSE;
        }
    }
    __finally {
        UnmapFile (fileImage, mapHandle, fileHandle);
    }
    return result;
}

BOOL
ExtractPifInfoW(
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData       OPTIONAL
    )
{
    PCSTR  aTarget = NULL;
    PCSTR  aParams = NULL;
    PCSTR  aWorkDir = NULL;
    PCSTR  aIconPath = NULL;
    PCSTR  aFileName;
    PCWSTR tempStrW;
    BOOL   result;
    LNK_EXTRA_DATAA extraDataA;

    aFileName = ConvertWtoA (FileName);

    result = ExtractPifInfoA (
                aFileName,
                &aTarget,
                &aParams,
                &aWorkDir,
                &aIconPath,
                IconNumber,
                MsDosMode,
                ExtraData?&extraDataA:NULL
                );
    FreeConvertedStr (aFileName);

    if (Target) {
        *Target = NULL;
        if (aTarget) {
            tempStrW = ConvertAtoW (aTarget);
            *Target = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aTarget) {
        FreePathStringA (aTarget);
    }

    if (Params) {
        *Params = NULL;
        if (aParams) {
            tempStrW = ConvertAtoW (aParams);
            *Params = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aParams) {
        FreePathStringA (aParams);
    }

    if (WorkDir) {
        *WorkDir = NULL;
        if (aWorkDir) {
            tempStrW = ConvertAtoW (aWorkDir);
            *WorkDir = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aWorkDir) {
        FreePathStringA (aWorkDir);
    }

    if (IconPath) {
        *IconPath = NULL;
        if (aIconPath) {
            tempStrW = ConvertAtoW (aIconPath);
            *IconPath = DuplicatePathStringW (tempStrW, 0);
            FreeConvertedStr (tempStrW);
        }
    }
    if (aIconPath) {
        FreePathStringA (aIconPath);
    }

    if (ExtraData) {
        ExtraData->FullScreen = extraDataA.FullScreen;
        ExtraData->xSize = extraDataA.xSize;
        ExtraData->ySize = extraDataA.ySize;
        ExtraData->QuickEdit = extraDataA.QuickEdit;
        tempStrW = ConvertAtoW (extraDataA.FontName);
        StringCopyW (ExtraData->FontName, tempStrW);
        FreeConvertedStr (tempStrW);
        ExtraData->xFontSize = extraDataA.xFontSize;
        ExtraData->yFontSize = extraDataA.yFontSize;
        ExtraData->FontWeight = extraDataA.FontWeight;
        ExtraData->FontFamily = extraDataA.FontFamily;
        ExtraData->CurrentCodePage = extraDataA.CurrentCodePage;
    }

    return result;
}

BOOL
ExtractShellLinkInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    CHAR tempStr [MEMDB_MAX];
    PCSTR sanitizedStr = NULL;
    PCWSTR fileNameW;
    PSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAA fd;
    IShellLinkDataList *shellLinkDataList;
    LPEXP_SZ_LINK expSzLink;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }

    fileNameW = ConvertAtoW (FileName);
    hres = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
    FreeConvertedStr (fileNameW);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (Target) {
        sanitizedStr = SanitizePathA (tempStr);
        *Target = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (WorkDir) {
        sanitizedStr = SanitizePathA (tempStr);
        if (sanitizedStr) {
            strPtr = (PSTR)GetEndOfStringA (sanitizedStr);
            if (strPtr) {
                strPtr = _mbsdec (sanitizedStr, strPtr);
                if (strPtr) {
                    if (_mbsnextc (strPtr) == '\\') {
                        *strPtr = 0;
                    }
                }
            }
        }
        *WorkDir = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                tempStr,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }
    if (Params) {
        *Params = DuplicatePathStringA (tempStr, 0);
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    if (IconPath) {
        sanitizedStr = SanitizePathA (tempStr);
        *IconPath = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
        if (sanitizedStr) {
            FreePathStringA (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual icon path is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_ICON_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->szTarget [0]) {
                    FreePathStringA (*IconPath);
                    sanitizedStr = SanitizePathA (expSzLink->szTarget);
                    *IconPath = DuplicatePathStringA (sanitizedStr?sanitizedStr:"", 0);
                    if (sanitizedStr) {
                        FreePathStringA (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (
                                ShellLink,
                                HotKey
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    return TRUE;
}

BOOL
ExtractShellLinkInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    WCHAR tempStr [MEMDB_MAX];
    PCWSTR sanitizedStr = NULL;
    PWSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAW fd;
    IShellLinkDataList *shellLinkDataList;
    LPEXP_SZ_LINK expSzLink;

    if (Target) {
        *Target = NULL;
    }
    if (Params) {
        *Params = NULL;
    }
    if (WorkDir) {
        *WorkDir = NULL;
    }
    if (IconPath) {
        *IconPath = NULL;
    }

    hres = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (Target) {
        sanitizedStr = SanitizePathW (tempStr);
        *Target = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    if (WorkDir) {
        sanitizedStr = SanitizePathW (tempStr);
        if (sanitizedStr) {
            strPtr = GetEndOfStringW (sanitizedStr) - 1;
            if (strPtr >= sanitizedStr) {
                if (*strPtr == L'\\') {
                    *strPtr = 0;
                }
            }
        }
        *WorkDir = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }
    }

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                tempStr,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }
    if (Params) {
        *Params = DuplicatePathStringW (tempStr, 0);
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                sizeof (tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    if (IconPath) {
        sanitizedStr = SanitizePathW (tempStr);
        *IconPath = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
        if (sanitizedStr) {
            FreePathStringW (sanitizedStr);
            sanitizedStr = NULL;
        }

        // One more thing: let's see if the actual icon path is a EXPAND_SZ
        hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &shellLinkDataList);
        if (SUCCEEDED(hres)) {
            hres = shellLinkDataList->lpVtbl->CopyDataBlock (shellLinkDataList, EXP_SZ_ICON_SIG, (LPVOID*)&expSzLink);
            if (SUCCEEDED(hres)) {
                if (expSzLink->swzTarget [0]) {
                    FreePathStringW (*IconPath);
                    sanitizedStr = SanitizePathW (expSzLink->swzTarget);
                    *IconPath = DuplicatePathStringW (sanitizedStr?sanitizedStr:L"", 0);
                    if (sanitizedStr) {
                        FreePathStringW (sanitizedStr);
                        sanitizedStr = NULL;
                    }
                }
                LocalFree (expSzLink);
            }
            shellLinkDataList->lpVtbl->Release (shellLinkDataList);
        }
    }

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (
                                ShellLink,
                                HotKey
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    return TRUE;
}

BOOL
ExtractShortcutInfoA (
    IN      PCSTR FileName,
    OUT     PCSTR *Target,
    OUT     PCSTR *Params,
    OUT     PCSTR *WorkDir,
    OUT     PCSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    shortcutExt = GetFileExtensionFromPathA (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchA (shortcutExt, "LNK")) {
            return ExtractShellLinkInfoA (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchA (shortcutExt, "PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoA (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
ExtractShortcutInfoW (
    IN      PCWSTR FileName,
    OUT     PCWSTR *Target,
    OUT     PCWSTR *Params,
    OUT     PCWSTR *WorkDir,
    OUT     PCWSTR *IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt = NULL;

    *MsDosMode  = FALSE;
    *DosApp     = FALSE;
    *HotKey     = 0;

    shortcutExt = GetFileExtensionFromPathW (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchW (shortcutExt, L"LNK")) {
            return ExtractShellLinkInfoW (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchW (shortcutExt, L"PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoW (
                        FileName,
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
ModifyShellLinkFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,               OPTIONAL
    IN      PCSTR Params,               OPTIONAL
    IN      PCSTR WorkDir,              OPTIONAL
    IN      PCSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData, OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR fileNameW = NULL;
    PCWSTR faceNameW;
    HRESULT comResult;

    __try {
        if (!DoesFileExistA (FileName)) {
            __leave;
        }
        if (((Target   == NULL) || (Target   [0] == 0)) &&
            ((Params   == NULL) || (Params   [0] == 0)) &&
            ((WorkDir  == NULL) || (WorkDir  [0] == 0)) &&
            ((IconPath == NULL) || (IconPath [0] == 0)) &&
            (HotKey == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        fileNameW = ConvertAtoW (FileName);
        comResult = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
        if (comResult != S_OK) {
            LOGA ((LOG_ERROR, "LINKEDIT: Load failed for %s", FileName));
            __leave;
        }

        if (Target != NULL) {
            comResult = ShellLink->lpVtbl->SetPath (ShellLink, Target);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", FileName));
            }
        }
        if (Params != NULL) {
            comResult = ShellLink->lpVtbl->SetArguments (ShellLink, Params);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", FileName));
            }
        }
        if (WorkDir != NULL) {
            comResult = ShellLink->lpVtbl->SetWorkingDirectory (ShellLink, WorkDir);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", FileName));
            }
        }
        if (IconPath != NULL) {
            comResult = ShellLink->lpVtbl->SetIconLocation (ShellLink, IconPath, IconNumber);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", FileName));
            }
        }
        // NTRAID#NTBUG9-153303-2000/08/01-jimschm Add HotKey processing here

        //
        // add NT_CONSOLE_PROPS
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;
            NT_CONSOLE_PROPS *oldProps;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSGA ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // let's try to get the extra data
            //
            comResult = psldl->lpVtbl->CopyDataBlock (psldl, NT_CONSOLE_PROPS_SIG, &oldProps);
            if ((comResult != S_OK) || (oldProps->cbSize != props.cbSize)) {
                // no extra data exists. We need to fill some good data for this console
                props.wFillAttribute = 0x0007;
                props.wPopupFillAttribute = 0x00f5;
                props.dwWindowOrigin.X = 0;
                props.dwWindowOrigin.Y = 0;
                props.nFont = 0;
                props.nInputBufferSize = 0;
                props.uCursorSize = 0x0019;
                props.bInsertMode = FALSE;
                props.bAutoPosition = TRUE;
                props.uHistoryBufferSize = 0x0032;
                props.uNumberOfHistoryBuffers = 0x0004;
                props.bHistoryNoDup = FALSE;
                props.ColorTable [0] = 0x00000000;
                props.ColorTable [1] = 0x00800000;
                props.ColorTable [2] = 0x00008000;
                props.ColorTable [3] = 0x00808000;
                props.ColorTable [4] = 0x00000080;
                props.ColorTable [5] = 0x00800080;
                props.ColorTable [6] = 0x00008080;
                props.ColorTable [7] = 0x00c0c0c0;
                props.ColorTable [8] = 0x00808080;
                props.ColorTable [9] = 0x00ff0000;
                props.ColorTable [10] = 0x0000ff00;
                props.ColorTable [11] = 0x00ffff00;
                props.ColorTable [12] = 0x000000ff;
                props.ColorTable [13] = 0x00ff00ff;
                props.ColorTable [14] = 0x0000ffff;
                props.ColorTable [15] = 0x00ffffff;
            } else {
                props.wFillAttribute = oldProps->wFillAttribute;
                props.wPopupFillAttribute = oldProps->wPopupFillAttribute;
                props.dwWindowOrigin.X = oldProps->dwWindowOrigin.X;
                props.dwWindowOrigin.Y = oldProps->dwWindowOrigin.Y;
                props.nFont = oldProps->nFont;
                props.nInputBufferSize = oldProps->nInputBufferSize;
                props.uCursorSize = oldProps->uCursorSize;
                props.bInsertMode = oldProps->bInsertMode;
                props.bAutoPosition = oldProps->bAutoPosition;
                props.uHistoryBufferSize = oldProps->uHistoryBufferSize;
                props.uNumberOfHistoryBuffers = oldProps->uNumberOfHistoryBuffers;
                props.bHistoryNoDup = oldProps->bHistoryNoDup;
                props.ColorTable [0] = oldProps->ColorTable [0];
                props.ColorTable [1] = oldProps->ColorTable [1];
                props.ColorTable [2] = oldProps->ColorTable [2];
                props.ColorTable [3] = oldProps->ColorTable [3];
                props.ColorTable [4] = oldProps->ColorTable [4];
                props.ColorTable [5] = oldProps->ColorTable [5];
                props.ColorTable [6] = oldProps->ColorTable [6];
                props.ColorTable [7] = oldProps->ColorTable [7];
                props.ColorTable [8] = oldProps->ColorTable [8];
                props.ColorTable [9] = oldProps->ColorTable [9];
                props.ColorTable [10] = oldProps->ColorTable [10];
                props.ColorTable [11] = oldProps->ColorTable [11];
                props.ColorTable [12] = oldProps->ColorTable [12];
                props.ColorTable [13] = oldProps->ColorTable [13];
                props.ColorTable [14] = oldProps->ColorTable [14];
                props.ColorTable [15] = oldProps->ColorTable [15];
                psldl->lpVtbl->RemoveDataBlock (psldl, NT_CONSOLE_PROPS_SIG);
            }

            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            faceNameW = ConvertAtoW (ExtraData->FontName);
            StringCopyW (props.FaceName, faceNameW);
            FreeConvertedStr (faceNameW);
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSGA ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", FileName));
            }
        }

        comResult = PersistFile->lpVtbl->Save (PersistFile, fileNameW, FALSE);
        if (comResult != S_OK) {
            DEBUGMSGA ((DBG_WARNING, "LINKEDIT: Save failed for %s", FileName));
        }

        comResult = PersistFile->lpVtbl->SaveCompleted (PersistFile, fileNameW);
        if (comResult != S_OK) {
            DEBUGMSGA ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", FileName));
        }

        FreeConvertedStr (fileNameW);
        fileNameW = NULL;
    }
    __finally {
        if (fileNameW) {
            FreeConvertedStr (fileNameW);
            fileNameW = NULL;
        }
    }
    return TRUE;
}

BOOL
ModifyShellLinkFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,               OPTIONAL
    IN      PCWSTR Params,               OPTIONAL
    IN      PCWSTR WorkDir,              OPTIONAL
    IN      PCWSTR IconPath,             OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData, OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    HRESULT comResult;

    __try {
        if (!DoesFileExistW (FileName)) {
            __leave;
        }
        if (((Target   == NULL) || (Target   [0] == 0)) &&
            ((Params   == NULL) || (Params   [0] == 0)) &&
            ((WorkDir  == NULL) || (WorkDir  [0] == 0)) &&
            ((IconPath == NULL) || (IconPath [0] == 0)) &&
            (HotKey == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        comResult = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);
        if (comResult != S_OK) {
            LOGW ((LOG_ERROR, "LINKEDIT: Load failed for %s", FileName));
            __leave;
        }

        if (Target != NULL) {
            comResult = ShellLink->lpVtbl->SetPath (ShellLink, Target);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", FileName));
            }
        }
        if (Params != NULL) {
            comResult = ShellLink->lpVtbl->SetArguments (ShellLink, Params);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", FileName));
            }
        }
        if (WorkDir != NULL) {
            comResult = ShellLink->lpVtbl->SetWorkingDirectory (ShellLink, WorkDir);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", FileName));
            }
        }
        if (IconPath != NULL) {
            comResult = ShellLink->lpVtbl->SetIconLocation (ShellLink, IconPath, IconNumber);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", FileName));
            }
        }
        // NTRAID#NTBUG9-153303-2000/08/01-jimschm Add HotKey processing here

        //
        // add NT_CONSOLE_PROPS
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;
            NT_CONSOLE_PROPS *oldProps;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = ShellLink->lpVtbl->QueryInterface (ShellLink, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSGW ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // let's try to get the extra data
            //
            comResult = psldl->lpVtbl->CopyDataBlock (psldl, NT_CONSOLE_PROPS_SIG, &oldProps);
            if ((comResult != S_OK) || (oldProps->cbSize != props.cbSize)) {
                // no extra data exists. We need to fill some good data for this console
                props.wFillAttribute = 0x0007;
                props.wPopupFillAttribute = 0x00f5;
                props.dwWindowOrigin.X = 0;
                props.dwWindowOrigin.Y = 0;
                props.nFont = 0;
                props.nInputBufferSize = 0;
                props.uCursorSize = 0x0019;
                props.bInsertMode = FALSE;
                props.bAutoPosition = TRUE;
                props.uHistoryBufferSize = 0x0032;
                props.uNumberOfHistoryBuffers = 0x0004;
                props.bHistoryNoDup = FALSE;
                props.ColorTable [0] = 0x00000000;
                props.ColorTable [1] = 0x00800000;
                props.ColorTable [2] = 0x00008000;
                props.ColorTable [3] = 0x00808000;
                props.ColorTable [4] = 0x00000080;
                props.ColorTable [5] = 0x00800080;
                props.ColorTable [6] = 0x00008080;
                props.ColorTable [7] = 0x00c0c0c0;
                props.ColorTable [8] = 0x00808080;
                props.ColorTable [9] = 0x00ff0000;
                props.ColorTable [10] = 0x0000ff00;
                props.ColorTable [11] = 0x00ffff00;
                props.ColorTable [12] = 0x000000ff;
                props.ColorTable [13] = 0x00ff00ff;
                props.ColorTable [14] = 0x0000ffff;
                props.ColorTable [15] = 0x00ffffff;
            } else {
                props.wFillAttribute = oldProps->wFillAttribute;
                props.wPopupFillAttribute = oldProps->wPopupFillAttribute;
                props.dwWindowOrigin.X = oldProps->dwWindowOrigin.X;
                props.dwWindowOrigin.Y = oldProps->dwWindowOrigin.Y;
                props.nFont = oldProps->nFont;
                props.nInputBufferSize = oldProps->nInputBufferSize;
                props.uCursorSize = oldProps->uCursorSize;
                props.bInsertMode = oldProps->bInsertMode;
                props.bAutoPosition = oldProps->bAutoPosition;
                props.uHistoryBufferSize = oldProps->uHistoryBufferSize;
                props.uNumberOfHistoryBuffers = oldProps->uNumberOfHistoryBuffers;
                props.bHistoryNoDup = oldProps->bHistoryNoDup;
                props.ColorTable [0] = oldProps->ColorTable [0];
                props.ColorTable [1] = oldProps->ColorTable [1];
                props.ColorTable [2] = oldProps->ColorTable [2];
                props.ColorTable [3] = oldProps->ColorTable [3];
                props.ColorTable [4] = oldProps->ColorTable [4];
                props.ColorTable [5] = oldProps->ColorTable [5];
                props.ColorTable [6] = oldProps->ColorTable [6];
                props.ColorTable [7] = oldProps->ColorTable [7];
                props.ColorTable [8] = oldProps->ColorTable [8];
                props.ColorTable [9] = oldProps->ColorTable [9];
                props.ColorTable [10] = oldProps->ColorTable [10];
                props.ColorTable [11] = oldProps->ColorTable [11];
                props.ColorTable [12] = oldProps->ColorTable [12];
                props.ColorTable [13] = oldProps->ColorTable [13];
                props.ColorTable [14] = oldProps->ColorTable [14];
                props.ColorTable [15] = oldProps->ColorTable [15];
                psldl->lpVtbl->RemoveDataBlock (psldl, NT_CONSOLE_PROPS_SIG);
            }

            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            StringCopyW (props.FaceName, ExtraData->FontName);
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSGW ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", FileName));
            }
        }

        comResult = PersistFile->lpVtbl->Save (PersistFile, FileName, FALSE);
        if (comResult != S_OK) {
            DEBUGMSGW ((DBG_WARNING, "LINKEDIT: Save failed for %s", FileName));
        }

        comResult = PersistFile->lpVtbl->SaveCompleted (PersistFile, FileName);
        if (comResult != S_OK) {
            DEBUGMSGW ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", FileName));
        }
    }
    __finally {
    }
    return TRUE;
}

BOOL
ModifyPifFileA (
    IN      PCSTR FileName,
    IN      PCSTR Target,       OPTIONAL
    IN      PCSTR Params,       OPTIONAL
    IN      PCSTR WorkDir,      OPTIONAL
    IN      PCSTR IconPath,     OPTIONAL
    IN      INT  IconNumber
    )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryExA (FileName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (Target != NULL) {
                strncpy (stdPif->startfile, Target, PIFSTARTLOCSIZE);
            }

            if (Params != NULL) {
                strncpy (stdPif->params, Params, PIFPARAMSSIZE);
            }

            if (WorkDir != NULL) {
                strncpy (stdPif->defpath, WorkDir, PIFDEFPATHSIZE);
            }

            if (IconPath != NULL) {
                wenhPif40 = (PWENHPIF40) pFindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {
                    strncpy (wenhPif40->achIconFileProp, IconPath, PIFDEFFILESIZE);
                    wenhPif40->wIconIndexProp = (WORD)IconNumber;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = pFindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSGW ((DBG_WARNING, "Exception thrown when processing %s", FileName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}

BOOL
ModifyPifFileW (
    IN      PCWSTR FileName,
    IN      PCWSTR Target,          OPTIONAL
    IN      PCWSTR Params,          OPTIONAL
    IN      PCWSTR WorkDir,         OPTIONAL
    IN      PCWSTR IconPath,        OPTIONAL
    IN      INT  IconNumber
    )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR AnsiStr = NULL;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryExW (FileName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (Target != NULL) {

                AnsiStr = ConvertWtoA (Target);
                strncpy (stdPif->startfile, AnsiStr, PIFSTARTLOCSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (Params != NULL) {

                AnsiStr = ConvertWtoA (Params);
                strncpy (stdPif->params, AnsiStr, PIFPARAMSSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (WorkDir != NULL) {

                AnsiStr = ConvertWtoA (WorkDir);
                strncpy (stdPif->defpath, AnsiStr, PIFDEFPATHSIZE);
                FreeConvertedStr (AnsiStr);
            }

            if (IconPath != NULL) {
                wenhPif40 = (PWENHPIF40) pFindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {

                    AnsiStr = ConvertWtoA (IconPath);
                    strncpy (wenhPif40->achIconFileProp, AnsiStr, PIFDEFFILESIZE);
                    FreeConvertedStr (AnsiStr);

                    wenhPif40->wIconIndexProp = (WORD)IconNumber;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = pFindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSGW ((DBG_WARNING, "Exception thrown when processing %s", FileName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}

BOOL
ModifyShortcutFileExA (
    IN      PCSTR FileName,
    IN      PCSTR ForcedExtension,        OPTIONAL
    IN      PCSTR Target,                 OPTIONAL
    IN      PCSTR Params,                 OPTIONAL
    IN      PCSTR WorkDir,                OPTIONAL
    IN      PCSTR IconPath,               OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAA ExtraData,   OPTIONAL
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt;

    __try {
        shortcutExt = ForcedExtension;
        if (!shortcutExt) {
            shortcutExt = GetFileExtensionFromPathA (FileName);
        }
        if (shortcutExt) {
            if (StringIMatchA (shortcutExt, "LNK")) {
                return ModifyShellLinkFileA (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber,
                            HotKey,
                            NULL,
                            ShellLink,
                            PersistFile
                            );

            } else if (StringIMatchA (shortcutExt, "PIF")) {
                return ModifyPifFileA (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber
                            );
            }
        }
    }
    __except (1) {
        LOGA ((LOG_ERROR, "Cannot process shortcut %s", FileName));
    }

    return TRUE;
}

BOOL
ModifyShortcutFileExW (
    IN      PCWSTR FileName,
    IN      PCWSTR ForcedExtension,       OPTIONAL
    IN      PCWSTR Target,                OPTIONAL
    IN      PCWSTR Params,                OPTIONAL
    IN      PCWSTR WorkDir,               OPTIONAL
    IN      PCWSTR IconPath,              OPTIONAL
    IN      INT IconNumber,
    IN      WORD HotKey,
    IN      PLNK_EXTRA_DATAW ExtraData,   OPTIONAL
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt;

    __try {
        shortcutExt = ForcedExtension;
        if (!shortcutExt) {
            shortcutExt = GetFileExtensionFromPathW (FileName);
        }
        if (shortcutExt) {
            if (StringIMatchW (shortcutExt, L"LNK")) {
                return ModifyShellLinkFileW (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber,
                            HotKey,
                            NULL,
                            ShellLink,
                            PersistFile
                            );

            } else if (StringIMatchW (shortcutExt, L"PIF")) {
                return ModifyPifFileW (
                            FileName,
                            Target,
                            Params,
                            WorkDir,
                            IconPath,
                            IconNumber
                            );
            }
        }
    }
    __except (1) {
        LOGW ((LOG_ERROR, "Cannot process shortcut %s", FileName));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\ini\ini.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ini.c

Abstract:

    Provides wrappers for commonly used INI file handling routines.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_INILIB      "IniLib"

//
// Strings
//

// None

//
// Constants
//

#define INITIAL_BUFFER_CHAR_COUNT   256

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_IniLibPool;
INT g_IniRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
Ini_Init (
    VOID
    )

/*++

Routine Description:

    Ini_Init initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (g_IniRefs >= 0);

    g_IniRefs++;

    if (g_IniRefs == 1) {
        g_IniLibPool = PmCreateNamedPool ("IniLib");
    }

    return g_IniLibPool != NULL;
}


VOID
Ini_Exit (
    VOID
    )

/*++

Routine Description:

    Ini_Exit is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    MYASSERT (g_IniRefs > 0);

    g_IniRefs--;

    if (!g_IniRefs) {

        if (g_IniLibPool) {
            PmDestroyPool (g_IniLibPool);
            g_IniLibPool = NULL;
        }
    }
}


PBYTE
pAllocateSpace (
    IN      DWORD Size
    )

/*++

Routine Description:

    pAllocateSpace is a private function that allocates space from the module's private pool

Arguments:

    Size - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

{
    MYASSERT (g_IniLibPool);
    MYASSERT (Size);
    return PmGetMemory (g_IniLibPool, Size);
}


VOID
pFreeSpace (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pFreeSpace is a private function that frees space allocated from the module's private pool

Arguments:

    Buffer - Pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (g_IniLibPool);
    PmReleaseMemory (g_IniLibPool, Buffer);
}


/*++

Routine Description:

    RealIniFileOpen validates the args passed in and then
    initializes IniFile struct with info used in subsequent calls to INI functions.

Arguments:

    IniFile - Receives INI file attributes if open is successful

    IniFileSpec - Specifies the file name; if not full path,
                  current drive and/or dir are prefixed

    FileMustExist - Specifies TRUE if file must exist for open to succeed

Return Value:

    TRUE if open succeeded; IniFile is valid for subsequent calls to other INI APIs;
         IniFileClose must be called when this handle is no longer needed.
    FALSE if not

--*/

BOOL
RealIniFileOpenA (
    OUT     PINIFILEA IniFile,
    IN      PCSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    CHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameA (IniFileSpec, MAX_MBCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGA ((
            DBG_ERROR,
            "IniFileOpenA: GetFullPathNameA failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGA_IF ((
        !StringIMatchA (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenA: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (BfPathIsDirectoryA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistA (fullPath)) {
        DEBUGMSGA ((
            DBG_INILIB,
            "IniFileOpenA: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExA (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesA (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesA (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


BOOL
RealIniFileOpenW (
    OUT     PINIFILEW IniFile,
    IN      PCWSTR IniFileSpec,
    IN      BOOL FileMustExist /*,*/
    ALLOCATION_TRACKING_DEF   /* , PCSTR File, UINT Line */
    )
{
    WCHAR fullPath[MAX_MBCHAR_PATH];

    if (!GetFullPathNameW (IniFileSpec, MAX_WCHAR_PATH, fullPath, NULL)) {

        DEBUGMSGW ((
            DBG_ERROR,
            "IniFileOpenW: GetFullPathNameW failed on <%s>",
            IniFileSpec
            ));
        return FALSE;
    }

    DEBUGMSGW_IF ((
        !StringIMatchW (IniFileSpec, fullPath),
        DBG_INILIB,
        "IniFileOpenW: IniFileSpec supplied: <%s>; full path defaulting to <%s>",
        IniFileSpec,
        fullPath
        ));

    if (BfPathIsDirectoryW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: <%s> is a directory",
            fullPath
            ));
        return FALSE;
    }
    if (FileMustExist && !DoesFileExistW (fullPath)) {
        DEBUGMSGW ((
            DBG_INILIB,
            "IniFileOpenW: file not found: <%s>",
            fullPath
            ));
        return FALSE;
    }

    IniFile->IniFilePath = DuplicateTextExW (g_IniLibPool, fullPath, 0, NULL);
    IniFile->OriginalAttributes = GetFileAttributesW (fullPath);

    if (IniFile->OriginalAttributes != (DWORD)-1) {
        //
        // set working attributes
        //
        SetFileAttributesW (fullPath, FILE_ATTRIBUTE_NORMAL);
    }

    return TRUE;
}


/*++

Routine Description:

    IniFileClose frees resources and restores INI's initial attributes

Arguments:

    IniFile - Specifies a handle to an open INI file

Return Value:

    none

--*/

VOID
IniFileCloseA (
    IN      PINIFILEA IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesA (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExA (g_IniLibPool, IniFile->IniFilePath);
}


VOID
IniFileCloseW (
    IN      PINIFILEW IniFile
    )
{
    if (IniFile->OriginalAttributes != (DWORD)-1) {
        SetFileAttributesW (IniFile->IniFilePath, IniFile->OriginalAttributes);
    }
    FreeTextExW (g_IniLibPool, IniFile->IniFilePath);
}


/*++

Routine Description:

    EnumFirstIniSection returns the first section of the given INI file, if any.

Arguments:

    IniSectEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

Return Value:

    TRUE if there is a section
    FALSE if not

--*/

BOOL
EnumFirstIniSectionA (
    OUT     PINISECT_ENUMA IniSectEnum,
    IN      PINIFILEA IniFile
    )
{
    PSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesA (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


BOOL
EnumFirstIniSectionW (
    OUT     PINISECT_ENUMW IniSectEnum,
    IN      PINIFILEW IniFile
    )
{
    PWSTR sections;
    DWORD allocatedChars;
    DWORD chars;

    sections = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (sections) {
            pFreeSpace (sections);
        }
        allocatedChars *= 2;
        sections = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!sections) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionNamesW (
                    sections,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*sections) {
        pFreeSpace (sections);
        return FALSE;
    }

    IniSectEnum->Sections = sections;
    IniSectEnum->CurrentSection = sections;
    return TRUE;
}


/*++

Routine Description:

    EnumNextIniSection returns the next section, if any.

Arguments:

    IniSectEnum - Specifies the prev section/receives the next section

Return Value:

    TRUE if there is a next section
    FALSE if not

--*/

BOOL
EnumNextIniSectionA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringA (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumA (IniSectEnum);
    return FALSE;
}


BOOL
EnumNextIniSectionW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    if (IniSectEnum->CurrentSection && *IniSectEnum->CurrentSection != 0) {
        //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
        //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
        //lint --e(613)
        IniSectEnum->CurrentSection = GetEndOfStringW (IniSectEnum->CurrentSection) + 1;
        if (*IniSectEnum->CurrentSection != 0) {
            return TRUE;
        }
    }

    AbortIniSectionEnumW (IniSectEnum);
    return FALSE;
}


/*++

Routine Description:

    AbortIniSectionEnum aborts section enumeration

Arguments:

    IniSectEnum - Specifies the section enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniSectionEnumA (
    IN OUT  PINISECT_ENUMA IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


VOID
AbortIniSectionEnumW (
    IN OUT  PINISECT_ENUMW IniSectEnum
    )
{
    pFreeSpace ((PVOID)IniSectEnum->Sections);
    IniSectEnum->Sections = NULL;
    IniSectEnum->CurrentSection = NULL;
}


/*++

Routine Description:

    EnumFirstIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Receives the first section

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to enumearte

Return Value:

    TRUE if there is a key/value pair
    FALSE if not

--*/

BOOL
EnumFirstIniKeyValueA (
    OUT     PINIKEYVALUE_ENUMA IniKeyValueEnum,
    IN      PINIFILEA IniFile,
    IN      PCSTR Section
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionA (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueA (IniKeyValueEnum);
}


BOOL
EnumFirstIniKeyValueW (
    OUT     PINIKEYVALUE_ENUMW IniKeyValueEnum,
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section);
    if (!Section) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileSectionW (
                    Section,
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 2);

    if (!*buffer) {
        pFreeSpace (buffer);
        return FALSE;
    }

    IniKeyValueEnum->KeyValuePairs = buffer;
    IniKeyValueEnum->Private = NULL;
    return EnumNextIniKeyValueW (IniKeyValueEnum);
}


/*++

Routine Description:

    EnumNextIniKeyValue returns the first key/value pair of
    the given INI file/section name, if any.

Arguments:

    IniKeyValueEnum - Specifies the prev key/value pair / receives the next pair

Return Value:

    TRUE if there is a next pair
    FALSE if not

--*/

BOOL
EnumNextIniKeyValueA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringA will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringA (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumA (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = _mbschr (IniKeyValueEnum->CurrentKey, '=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == ';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == '=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringA (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceA ((PSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


BOOL
EnumNextIniKeyValueW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    //
    // restore from saved position
    //
    IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->Private;
    //
    // skip commented lines
    //
    do {
        if (IniKeyValueEnum->CurrentKeyValuePair) {
            //Since CurrentKeyValuePtr is not NULL the next assignment will not put NULL in
            //CurrentKeyValuePtr (because GetEndOfStringW will return a valid pointer) so...
            //lint --e(613)
            IniKeyValueEnum->CurrentKeyValuePair = GetEndOfStringW (IniKeyValueEnum->CurrentKeyValuePair) + 1;
        } else {
            IniKeyValueEnum->CurrentKeyValuePair = IniKeyValueEnum->KeyValuePairs;
        }

        MYASSERT (IniKeyValueEnum->CurrentKeyValuePair);
        if (!(*IniKeyValueEnum->CurrentKeyValuePair)) {
            AbortIniKeyValueEnumW (IniKeyValueEnum);
            return FALSE;
        }
        IniKeyValueEnum->CurrentKey = IniKeyValueEnum->CurrentKeyValuePair;
        IniKeyValueEnum->CurrentValue = wcschr (IniKeyValueEnum->CurrentKey, L'=');
    }  while (*IniKeyValueEnum->CurrentKeyValuePair == L';' || !IniKeyValueEnum->CurrentValue);

    MYASSERT (*IniKeyValueEnum->CurrentKeyValuePair);
    MYASSERT (*IniKeyValueEnum->CurrentValue == L'=');
    //
    // remember position for next iteration
    //
    IniKeyValueEnum->Private = GetEndOfStringW (IniKeyValueEnum->CurrentValue);
    //
    // modify buffer to get KEY and VALUE
    //
    *(PWSTR)IniKeyValueEnum->CurrentValue = 0;
    IniKeyValueEnum->CurrentValue++;
    TruncateTrailingSpaceW ((PWSTR)IniKeyValueEnum->CurrentKey);
    return TRUE;
}


/*++

Routine Description:

    AbortIniKeyValueEnum aborts key/value pairs enumeration

Arguments:

    IniKeyValueEnum - Specifies the key/value pair enumeration handle/receives NULLs

Return Value:

    none

--*/

VOID
AbortIniKeyValueEnumA (
    IN OUT  PINIKEYVALUE_ENUMA IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


VOID
AbortIniKeyValueEnumW (
    IN OUT  PINIKEYVALUE_ENUMW IniKeyValueEnum
    )
{
    pFreeSpace ((PVOID)IniKeyValueEnum->KeyValuePairs);
    IniKeyValueEnum->KeyValuePairs = NULL;
    IniKeyValueEnum->CurrentKeyValuePair = NULL;
    IniKeyValueEnum->CurrentKey = NULL;
    IniKeyValueEnum->CurrentValue = NULL;
}


/*++

Routine Description:

    IniReadValue returns the value of a specified key in a specified section
    from the given INI file. The buffer returned must be freed using IniFreeReadValue

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to read from

    Key - Specifies the key

    Value - Receives a pointer to an allocated buffer containing the read value,
            if function is successful; optional

    Chars - Receives the number of chars (not bytes) the value has,
            excluding the NULL terminator; optional

Return Value:

    TRUE if there is a value for the specified section/key
    FALSE if not

--*/

BOOL
IniReadValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    OUT     PSTR* Value,            OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PSTR)pAllocateSpace (allocatedChars * DWSIZEOF (CHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringA (
                    Section,
                    Key,
                    "",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}

BOOL
IniReadValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR* Value,           OPTIONAL
    OUT     PDWORD Chars            OPTIONAL
    )
{
    PWSTR buffer;
    DWORD allocatedChars;
    DWORD chars;

    MYASSERT (Section && Key);
    if (!Section || !Key) {
        return FALSE;
    }

    buffer = NULL;
    allocatedChars = INITIAL_BUFFER_CHAR_COUNT / 2;
    do {
        if (buffer) {
            pFreeSpace (buffer);
        }
        allocatedChars *= 2;
        buffer = (PWSTR)pAllocateSpace (allocatedChars * DWSIZEOF (WCHAR));
        if (!buffer) {
            return FALSE;
        }
        chars = GetPrivateProfileStringW (
                    Section,
                    Key,
                    L"",
                    buffer,
                    allocatedChars,
                    IniFile->IniFilePath
                    );
    } while (chars >= allocatedChars - 1);

    if (Chars) {
        *Chars = chars;
    }

    if (Value) {
        if (*buffer) {
            *Value = buffer;
        } else {
            *Value = NULL;
        }
    }

    if (!(Value && *Value)) {
        //
        // buffer no longer needed
        //
        pFreeSpace (buffer);
    }

    return chars > 0;
}


/*++

Routine Description:

    IniFreeReadValue is used to free the buffer allocated by IniReadValue
    and stored in Value, if specified.

Arguments:

    Value - Specifies a pointer to the string to be freed

Return Value:

    none

--*/

VOID
IniFreeReadValueA (
    IN      PCSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


VOID
IniFreeReadValueW (
    IN      PCWSTR Value
    )
{
    pFreeSpace ((PVOID)Value);
}


/*++

Routine Description:

    IniWriteValue writes the key/value pair in the specified section

Arguments:

    IniFile - Specifies a handle to an open INI file

    Section - Specifies the section to write to

    Key - Specifies the key

    Value - Spcifies the value

Return Value:

    TRUE if write was successful, FALSE if not

--*/

BOOL
IniWriteValueA (
    IN      PINIFILEA IniFile,
    IN      PCSTR Section,
    IN      PCSTR Key,
    IN      PCSTR Value
    )
{
    return WritePrivateProfileStringA (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}


BOOL
IniWriteValueW (
    IN      PINIFILEW IniFile,
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    IN      PCWSTR Value
    )
{
    return WritePrivateProfileStringW (
                    Section,
                    Key,
                    Value,
                    IniFile->IniFilePath
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\basemem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    basemem.c

Abstract:

    Implements macros and declares functions for basic allocation functions.
    Consolidated into this file from debug.c and main.c

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

--*/


#include "pch.h"


//
// Includes
//

#include "utilsp.h"


//
// Constants
//

#ifdef DEBUG

#define TRAIL_SIG               0x708aa210
#define TRACK_SIGNATURE         0x30405060

#endif

//
// Macros
//

#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))


//
// Types
//

#ifdef DEBUG

typedef struct _tagTRACKSTRUCT {

    DWORD Signature;
    PCSTR File;
    DWORD Line;
    SIZE_T Size;
    PSTR Comment;
    PCSTR CallerFile;
    DWORD CallerLine;
    BOOL Allocated;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;

} TRACKSTRUCT, *PTRACKSTRUCT;

#endif

//
// Globals
//

#ifdef DEBUG

PTRACKSTRUCT g_TrackHead = NULL;

#endif

//
// Heap debug statistics
//

static SIZE_T g_TotalBytesAllocated = 0;
static SIZE_T g_MaxBytesInUse = 0;
static SIZE_T g_HeapAllocs = 0;
static SIZE_T g_HeapReAllocs = 0;
static SIZE_T g_HeapFrees = 0;
static SIZE_T g_HeapAllocFails = 0;
static SIZE_T g_HeapReAllocFails = 0;
static SIZE_T g_HeapFreeFails = 0;

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
HWND g_OutOfMemoryParentWnd;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

#ifdef DEBUG

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );



VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    );

VOID
pTrackDelete (
    PTRACKSTRUCT p
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//



void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    if (_tcslen(Msg) + _tcslen(Msg2) < 2025) {
        strcat (Msg2, Msg);
    }
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}

#ifdef DEBUG

SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T rc;

    EnterCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveCriticalSection (&g_MemAllocCs);

    return rc;
}

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  This address is not valid.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    size = HeapSize (hHeap, 0, RealPtr);
    if (size == (SIZE_T)-1) {
        CHAR BadPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  "
                "This address is not the start of a memory block.",
            (DWORD)((UBINT)CallerPtr >> 32),
            (DWORD)(UBINT)CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    return size;
}

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD TrackStructSize;
    DWORD OrgError;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_HeapAllocs++;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    UBINT lastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    DWORD SizeAdjust;
    DWORD OrgError;
    DWORD TrackStructSize;
    SIZE_T OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        lastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (lastSize == (UBINT)INVALID_PTR) {
            // we want to go on, most likely we will AV shortly
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_HeapReAllocs++;
            g_TotalBytesAllocated -= lastSize;
            g_TotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_HeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    UBINT size;
    PCVOID RealPtr;
    DWORD SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (size == (UBINT)INVALID_PTR) {
            g_HeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            wsprintfA (
                BadPtrMsg,
                "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                "HeapFree() failed.",
                CallerPtr,
                Flags
                );

            HeapCallFailed (BadPtrMsg, File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        g_HeapFrees++;
        if (g_TotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_TotalBytesAllocated = 0;
        } else {
            g_TotalBytesAllocated -= size;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return Result;

}

VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_TotalBytesAllocated,
               g_MaxBytesInUse,
               g_HeapAllocs,
               g_HeapReAllocs,
               g_HeapFrees
               );

    if (g_HeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_HeapAllocFails);
    }
    if (g_HeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_HeapReAllocFails);
    }
    if (g_HeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_HeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveCriticalSection (&g_MemAllocCs);
}

#endif

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is not very good, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    if (!g_OutOfMemoryString || !g_OutOfMemoryString[0]) {
        return;
    }

    MessageBoxA (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        NULL,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    //
    // Not needed, will never get here
    //
    // TerminateProcess (GetModuleHandle (NULL), 0);
}

VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBoxA (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    NULL,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    } else {
        if (!Block) {
            // this is serious. We want to break now and give Dr. Watson a
            // chance to get our stack.
            DebugBreak ();
        }
    }
}

PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

#ifdef DEBUG

VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    if (g_TrackAlloc) {
        p->File = SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (File));
        if (p->File) {
            StringCopyA ((PSTR)p->File, File);
        }
    } else {
        p->File      = File;
        p->Allocated = FALSE;
    }
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = g_TrackHead;
    p->CallerFile = g_TrackFile;
    p->CallerLine = g_TrackLine;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (g_TrackHead) {
        g_TrackHead->PrevAlloc = p;
    }

    g_TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        g_TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
    if (p->Allocated) {
        if (p->File) {
            HeapFree (g_hHeap, 0, (PSTR)p->File);
        }
    }
}

VOID
DumpHeapLeaks (
    VOID
    )
{
    CHAR LineBuf[4096];
    PTRACKSTRUCT p;
    BOOL BadMem = FALSE;

    if (g_TrackHead) {

        __try {

            for (p = g_TrackHead ; p ; p = p->NextAlloc) {

                __try {

                    if (p->Comment) {

                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\n"
                                    "  %s\n"
                                    "  Caller: %s line %u",
                                p->File,
                                p->Line,
                                p->Comment,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "%s line %u\n  %s", p->File, p->Line, p->Comment);
                        }
                    } else {

                        if (p->CallerFile) {
                            wsprintfA (
                                LineBuf,
                                "%s line %u\n"
                                    "  Caller: %s line %u\n",
                                p->File,
                                p->Line,
                                p->CallerFile,
                                p->CallerLine
                                );
                        } else {
                            wsprintfA (LineBuf, "(direct alloc) %s line %u", p->File, p->Line);
                        }
                    }

                }
                __except (TRUE) {
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!", p);
                    BadMem = TRUE;
                }

                DEBUGMSG (("Leaks", "%s", LineBuf));

#ifdef CONSOLE
                printf ("%s", LineBuf);
#endif

                //lint --e(774)
                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }
    }
}
/*
VOID
DumpHeapLeaks (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "?:\\memtrack.log";

    GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
    memtrackLogPath[0] = TempPath[0];

    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {

        SetFilePointer (File, 0, NULL, FILE_END);

        if (g_TrackHead) {

            Count = 0;
            __try {
                for (p = g_TrackHead ; p ; p = p->NextAlloc) {
                    Count++;
                    __try {
                        if (p->Comment) {
                            if (p->CallerFile) {
                                wsprintfA (
                                    LineBuf,
                                    "%s line %u\r\n"
                                        "  %s\r\n"
                                        "  Caller: %s line %u\r\n"
                                        "\r\n",
                                    p->File,
                                    p->Line,
                                    p->Comment,
                                    p->CallerFile,
                                    p->CallerLine
                                    );
                            } else {
                                wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                            }
                        } else {
                            if (p->CallerFile) {
                                wsprintfA (
                                    LineBuf,
                                    "%s line %u\r\n"
                                        "  Caller: %s line %u\r\n"
                                        "\r\n",
                                    p->File,
                                    p->Line,
                                    p->CallerFile,
                                    p->CallerLine
                                    );
                            } else {
                                wsprintfA (LineBuf, "(direct alloc) %s line %u\r\n\r\n", p->File, p->Line);
                            }
                        }

                    }
                    __except (TRUE) {
                        wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", p);
                        BadMem = TRUE;
                    }
                    WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

                    //lint --e(774)
                    if (BadMem) {
                        break;
                    }
                }
            }
            __except (TRUE) {
            }

            wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n\r\n", Count, Count == 1 ? "":"s");
            WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);
        }

        wsprintfA (
           LineBuf,
           "Bytes currently allocated: %u\r\n"
           "Peak bytes allocated: %u\r\n"
           "Allocation count: %u\r\n"
           "Reallocation count: %u\r\n"
           "Free count: %u\r\n\r\n\r\n\r\n\r\n",
           g_TotalBytesAllocated,
           g_MaxBytesInUse,
           g_HeapAllocs,
           g_HeapReAllocs,
           g_HeapFrees
           );

        WriteFile (File, LineBuf, (DWORD)ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\basefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    basefile.c

Abstract:

    Contains simple wrappers for commonly used file i/o functions.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BASEFILE     "File Utils"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}

BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        // Win95 GetFileAttributes does not return a failure if FileName is NULL
        if (FileName == NULL) {
            return FALSE;
        } else {
            return GetFileAttributesA (FileName) != 0xffffffff;
        }
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        // Win95 GetFileAttributes does not return a failure if FileName is NULL
        if (FileName == NULL) {
            return FALSE;
        } else {
            return GetFileAttributesW (FileName) != 0xffffffff;
        }
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileW(FileName,&ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


/*++

Routine Description:

    PathIsDirectory determines if a path identifies an accessible directory.

Arguments:

    PathSpec - Specifies the full path.

Return Value:

    TRUE if the path identifies a directory.
    FALSE if not. GetLastError() returns extended error info.

--*/

BOOL
BfPathIsDirectoryA (
    IN      PCSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesA (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
BfPathIsDirectoryW (
    IN      PCWSTR PathSpec
    )
{
    DWORD attribs;

    MYASSERT (PathSpec);
    if (!PathSpec) {
        return FALSE;
    }
    attribs = GetFileAttributesW (PathSpec);
    return attribs != (DWORD)-1 && (attribs & FILE_ATTRIBUTE_DIRECTORY);
}


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        *FileHandle = NULL;
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingA (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        CloseHandle (*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA and MapFileIntoMemoryW map a file into memory. It does that
  by opening the file, creating a mapping object and mapping opened file into
  created mapping object. It returnes the address where the file is mapped and
  also sets FileHandle and MapHandle variables to be used in order to unmap the
  file when work is done.

Arguments:

  FileName - the name of the file to be mapped into memory
  FileHandle - will end keeping the file handle if the file was opened successfully
  MapHandle - will end keeping the mapping object handle if this object was created successfully

Return Value:

  NULL if function fails, a valid memory address if successfull

Comments:

  If the return value is NULL you should call UnmapFile to release all allocated resources

--*/

{
    PVOID fileImage = NULL;

    //verify function parameters
    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //first thing. Try to open the file, read-only
    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        *FileHandle = NULL;
        return NULL;
    }

    //now try to create a mapping object, read-only
    *MapHandle = CreateFileMappingW (*FileHandle, NULL, WriteAccess?PAGE_READWRITE:PAGE_READONLY, 0, 0, NULL);

    if (*MapHandle == NULL) {
        CloseHandle (*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    //one more thing to do: map view of file
    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


BOOL
UnmapFile (
    IN PCVOID FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - image of the mapped file as returned by MapFileIntoMemory
  MapHandle - handle of the mapping object as returned by MapFileIntoMemory
  FileHandle - handle of the file as returned by MapFileIntoMemory

Return Value:

  TRUE if successfull, FALSE if not

--*/

{
    BOOL result = TRUE;

    //if FileImage is a valid pointer then try to unmap file
    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //if mapping object is valid then try to delete it
    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //if file handle is valid then try to close the file
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}


BOOL
BfGetTempFileNameExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    )
{
    CHAR tempPath[MAX_MBCHAR_PATH];
    CHAR tempFile[MAX_MBCHAR_PATH];
    UINT tchars;
    PSTR p;

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = _mbsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (!DoesFileExistA (tempPath)) {
        BfCreateDirectoryA (tempPath);
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameA (tempPath, Prefix, 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameA (tempPath, Prefix, 0, tempFile)) {
            DWORD err = GetLastError ();
            return FALSE;
        }

        tchars = TcharCountA (tempFile) + 1;

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (CHAR));
    }

    return TRUE;
}


BOOL
BfGetTempFileNameExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    )
{
    WCHAR tempPath[MAX_WCHAR_PATH];
    WCHAR tempFile[MAX_WCHAR_PATH];
    UINT tchars;
    PWSTR p;

    if (!GetTempPathW (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = wcsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (BufferTchars >= MAX_PATH) {
        if (!GetTempFileNameW (tempPath, Prefix, 0, Buffer)) {
            return FALSE;
        }
    } else {
        if (!GetTempFileNameW (tempPath, Prefix, 0, tempFile)) {
            return FALSE;
        }

        tchars = TcharCountW (tempFile);

        if (tchars > BufferTchars) {
            DEBUGMSG ((DBG_ERROR, "Can't get temp file name -- buffer too small"));
            return FALSE;
        }

        CopyMemory (Buffer, tempFile, tchars * sizeof (WCHAR));
    }

    return TRUE;
}


BOOL
BfGetTempDirectoryExA (
    OUT     PSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCSTR Prefix
    )
{
    BOOL result = FALSE;

    result = BfGetTempFileNameExA (Buffer, BufferTchars, Prefix);

    if (result) {
        if (!DeleteFileA (Buffer)) {
            return FALSE;
        }
        if (!CreateDirectoryA (Buffer, NULL)) {
            return FALSE;
        }
    }
    return result;
}


BOOL
BfGetTempDirectoryExW (
    OUT     PWSTR Buffer,
    IN      UINT BufferTchars,
    IN      PCWSTR Prefix
    )
{
    BOOL result = FALSE;

    result = BfGetTempFileNameExW (Buffer, BufferTchars, Prefix);

    if (result) {
        if (!DeleteFileW (Buffer)) {
            return FALSE;
        }
        if (!CreateDirectoryW (Buffer, NULL)) {
            return FALSE;
        }
    }
    return result;
}


HANDLE
BfGetTempFile (
    VOID
    )
{
    CHAR tempFile[MAX_MBCHAR_PATH];
    HANDLE file;

    if (!BfGetTempFileNameA (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }

    file = CreateFileA (
                tempFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_DELETE_ON_CLOSE,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        file = NULL;
    }

    return file;
}


BOOL
BfSetFilePointer (
    IN      HANDLE File,
    IN      LONGLONG Offset
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Offset;

    li.LowPart = SetFilePointer (File, li.LowPart, &li.HighPart, FILE_BEGIN);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    }

    return li.QuadPart != -1;
}


HANDLE
BfOpenReadFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenReadFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfOpenFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


HANDLE
BfOpenFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle =  CreateFileA (
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;

}

HANDLE
BfCreateFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileA (
    IN      PCSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileA (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}

HANDLE
BfCreateSharedFileW (
    IN      PCWSTR FileName
    )
{
    HANDLE handle;

    handle = CreateFileW (
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (handle == INVALID_HANDLE_VALUE) {
        handle = NULL;
    }

    return handle;
}


BOOL
BfSetSizeOfFile (
    HANDLE File,
    LONGLONG Size
    )
{
    if (!BfSetFilePointer (File, Size)) {
        return FALSE;
    }

    return SetEndOfFile (File);
}


BOOL
BfGoToEndOfFile (
    IN      HANDLE File,
    OUT     PLONGLONG FileSize      OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_END);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FileSize) {
        *FileSize = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfGetFilePointer (
    IN      HANDLE File,
    OUT     PLONGLONG FilePointer       OPTIONAL
    )
{
    LARGE_INTEGER li;

    li.HighPart = 0;
    li.LowPart = SetFilePointer (File, 0, &li.HighPart, FILE_CURRENT);

    if (li.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
        li.QuadPart = -1;
    } else if (FilePointer) {
        *FilePointer = li.QuadPart;
    }

    return li.QuadPart != -1;
}


BOOL
BfReadFile (
    IN      HANDLE File,
    OUT     PBYTE Buffer,
    IN      UINT BytesToRead
    )
{
    DWORD bytesRead;

    if (!ReadFile (File, Buffer, BytesToRead, &bytesRead, NULL)) {
        return FALSE;
    }

    return bytesRead == BytesToRead;
}


BOOL
BfWriteFile (
    IN      HANDLE File,
    OUT     PCBYTE Buffer,
    IN      UINT BytesToWrite
    )
{
    DWORD bytesWritten;

    if (!WriteFile (File, Buffer, BytesToWrite, &bytesWritten, NULL)) {
        return FALSE;
    }

    return bytesWritten == BytesToWrite;
}


BOOL
BfCreateDirectoryExA (
    IN      PCSTR FullPath,
    IN      BOOL CreateLastSegment
    )
{
    PSTR pathCopy;
    PSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringA (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == ':' && pathCopy[2] == '\\') {
        //
        // <drive>:\ case
        //

        p = _mbschr (&pathCopy[3], '\\');

    } else if (pathCopy[0] == '\\' && pathCopy[1] == '\\') {

        //
        // UNC case
        //

        p = _mbschr (pathCopy + 2, '\\');
        if (p) {
            p = _mbschr (p + 1, '\\');
            if (p) {
                p = _mbschr (p + 1, '\\');
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _mbschr (pathCopy, '\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            LOG ((LOG_ERROR, "Can't create %s", pathCopy));
            break;
        }

        *p = '\\';
        p = _mbschr (p + 1, '\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b && CreateLastSegment) {
        b = CreateDirectoryA (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringA (pathCopy);

    return b;
}


BOOL
BfCreateDirectoryExW (
    IN      PCWSTR FullPath,
    IN      BOOL CreateLastSegment
    )
{
    PWSTR pathCopy;
    PWSTR p;
    BOOL b = TRUE;

    pathCopy = DuplicatePathStringW (FullPath, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == L':' && pathCopy[2] == L'\\') {
        //
        // <drive>:\ case
        //

        p = wcschr (&pathCopy[3], L'\\');

    } else if (pathCopy[0] == L'\\' && pathCopy[1] == L'\\') {

        //
        // UNC case
        //

        p = wcschr (pathCopy + 2, L'\\');
        if (p) {
            p = wcschr (p + 1, L'\\');
            if (p) {
                p = wcschr (p + 1, L'\\');
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = wcschr (pathCopy, L'\\');
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = L'\\';
        p = wcschr (p + 1, L'\\');
    }

    //
    // At last, make the FullPath directory
    //

    if (b && CreateLastSegment) {
        b = CreateDirectoryW (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    FreePathStringW (pathCopy);

    return b;
}


LONGLONG
BfGetFileSizeA (
    IN      PCSTR FileName
    )
{
    WIN32_FIND_DATAA fd;
    LONGLONG l;

    if (!DoesFileExistExA (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

LONGLONG
BfGetFileSizeW (
    IN      PCWSTR FileName
    )
{
    WIN32_FIND_DATAW fd;
    LONGLONG l;

    if (!DoesFileExistExW (FileName, &fd)) {
        return 0;
    }

    l = ((LONGLONG) fd.nFileSizeHigh << 32) | fd.nFileSizeLow;

    return l;
}

PSTR
pGetFirstSegA (
    IN      PCSTR SrcFileName
    )
{
    if (SrcFileName [0] == '\\') {
        SrcFileName ++;
        if (SrcFileName [0] == '\\') {
            SrcFileName ++;
        }
        return (_mbschr (SrcFileName, '\\'));
    } else {
        return (_mbschr (SrcFileName, '\\'));
    }
}

BOOL
pGetLongFileNameWorkerA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PSTR beginSegPtr;
    PSTR endSegPtr;
    WIN32_FIND_DATAA findData;
    CHAR savedChar;

    beginSegPtr = pGetFirstSegA (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringA (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr = _mbsinc (beginSegPtr);

    GbAppendStringABA (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = _mbschr (beginSegPtr, '\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringA (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExA (SrcFileName, &findData)) {
            if (StringIMatchA (findData.cFileName, ".")) {
                GbAppendStringA (GrowBuf, beginSegPtr);
            } else {
                GbAppendStringA (GrowBuf, findData.cFileName);
            }
        } else {
            GbAppendStringABA (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = _mbsinc (endSegPtr);
            GbAppendStringABA (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCSTR
BfGetLongFileNameA (
    IN      PCSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PSTR srcFileName;
    PCSTR result = NULL;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    if (pGetLongFileNameWorkerA (srcFileName, &growBuf)) {
        result = DuplicatePathStringA (growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringA (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExA (
    IN      PCSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PSTR srcFileName;
    BOOL result;

    srcFileName = (PSTR)SanitizePathA (SrcFileName);
    result = pGetLongFileNameWorkerA (srcFileName, GrowBuff);
    FreePathStringA (srcFileName);

    return result;
}

PWSTR
pGetFirstSegW (
    IN      PCWSTR SrcFileName
    )
{
    if (SrcFileName [0] == L'\\') {
        SrcFileName ++;
        if (SrcFileName [0] == L'\\') {
            SrcFileName ++;
        }
        return (wcschr (SrcFileName, L'\\'));
    } else {
        return (wcschr (SrcFileName, L'\\'));
    }
}

BOOL
pGetLongFileNameWorkerW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuf
    )
{
    PWSTR beginSegPtr;
    PWSTR endSegPtr;
    WIN32_FIND_DATAW findData;
    WCHAR savedChar;

    beginSegPtr = pGetFirstSegW (SrcFileName);

    if (!beginSegPtr) {
        GbAppendStringW (GrowBuf, SrcFileName);
        return TRUE;
    }
    beginSegPtr ++;

    GbAppendStringABW (GrowBuf, SrcFileName, beginSegPtr);

    while (beginSegPtr) {
        endSegPtr = wcschr (beginSegPtr, L'\\');
        if (!endSegPtr) {
            endSegPtr = GetEndOfStringW (beginSegPtr);
            MYASSERT (endSegPtr);
        }
        savedChar = *endSegPtr;
        *endSegPtr = 0;
        if (DoesFileExistExW (SrcFileName, &findData)) {
            GbAppendStringW (GrowBuf, findData.cFileName);
        } else {
            GbAppendStringABW (GrowBuf, beginSegPtr, endSegPtr);
        }
        *endSegPtr = savedChar;
        if (savedChar) {
            beginSegPtr = endSegPtr + 1;
            GbAppendStringABW (GrowBuf, endSegPtr, beginSegPtr);
        } else {
            beginSegPtr = NULL;
        }
    }
    return TRUE;
}

PCWSTR
BfGetLongFileNameW (
    IN      PCWSTR SrcFileName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PWSTR srcFileName;
    PCWSTR result = NULL;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    if (pGetLongFileNameWorkerW (srcFileName, &growBuf)) {
        result = DuplicatePathStringW ((PCWSTR)growBuf.Buf, 0);
        GbFree (&growBuf);
    }
    FreePathStringW (srcFileName);
    return result;
}

BOOL
BfGetLongFileNameExW (
    IN      PCWSTR SrcFileName,
    IN      PGROWBUFFER GrowBuff
    )
{
    PWSTR srcFileName;
    BOOL result;

    srcFileName = (PWSTR)SanitizePathW (SrcFileName);
    result = pGetLongFileNameWorkerW (srcFileName, GrowBuff);
    FreePathStringW (srcFileName);

    return result;
}

BOOL
BfCopyAndFlushFileA (
    IN      PCSTR SrcFileName,
    IN      PCSTR DestFileName,
    IN      BOOL FailIfExists
    )
{
    BYTE buffer[4096];
    HANDLE srcHandle;
    HANDLE destHandle;
    DWORD bytesRead = 4096;
    DWORD bytesWritten;
    BOOL error = FALSE;
    BOOL result = FALSE;

    srcHandle = BfOpenReadFileA (SrcFileName);
    if (srcHandle) {
        if (FailIfExists && DoesFileExistA (DestFileName)) {
            SetLastError (ERROR_ALREADY_EXISTS);
        } else {
            destHandle = BfCreateFileA (DestFileName);
            if (destHandle) {
                while (bytesRead == 4096) {
                    if (!ReadFile (srcHandle, buffer, 4096, &bytesRead, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead == 0) {
                        break;
                    }
                    if (!WriteFile (destHandle, buffer, bytesRead, &bytesWritten, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead != bytesWritten) {
                        error = TRUE;
                        break;
                    }
                }
                if (!error) {
                    result = TRUE;
                }
                if (result) {
                    FlushFileBuffers (destHandle);
                }
                CloseHandle (destHandle);
            }
        }
        CloseHandle (srcHandle);
    }

    return result;
}

BOOL
BfCopyAndFlushFileW (
    IN      PCWSTR SrcFileName,
    IN      PCWSTR DestFileName,
    IN      BOOL FailIfExists
    )
{
    BYTE buffer[4096];
    HANDLE srcHandle;
    HANDLE destHandle;
    DWORD bytesRead = 4096;
    DWORD bytesWritten;
    BOOL error = FALSE;
    BOOL result = FALSE;

    srcHandle = BfOpenReadFileW (SrcFileName);
    if (srcHandle) {
        if (FailIfExists && DoesFileExistW (DestFileName)) {
            SetLastError (ERROR_ALREADY_EXISTS);
        } else {
            destHandle = BfCreateFileW (DestFileName);
            if (destHandle) {
                while (bytesRead == 4096) {
                    if (!ReadFile (srcHandle, buffer, 4096, &bytesRead, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead == 0) {
                        break;
                    }
                    if (!WriteFile (destHandle, buffer, bytesRead, &bytesWritten, NULL)) {
                        error = TRUE;
                        break;
                    }
                    if (bytesRead != bytesWritten) {
                        error = TRUE;
                        break;
                    }
                }
                if (!error) {
                    result = TRUE;
                }
                if (result) {
                    FlushFileBuffers (destHandle);
                }
                CloseHandle (destHandle);
            }
        }
        CloseHandle (srcHandle);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\basereg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    <filename>

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\blobs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    blobs.c

Abstract:

    Implements a set of APIs to manage BLOBS and arrays of BLOBS.

Author:

    Ovidiu Temereanca (ovidiut)   24-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_BLOBS       "Blobs"

//
// Strings
//

// None

//
// Constants
//

#define BLOB_SIGNATURE              0x79563442
#define BLOB_GROWDATASIZE_DEFAULT   1024
#define BLOBS_GROWCOUNT_DEFAULT     64
#define BLOBS_SIGNATURE             0x12567841

//
// Macros
//

// None

//
// Types
//

typedef struct {
    DWORD       BlobSignature;
    DWORD       DataSize;
    DWORD       Flags;
} BLOBHDR, *PBLOBHDR;

typedef struct {
    DWORD       BlobsArraySignature;
    DWORD       BlobsCount;
} BLOBSARRAYHDR, *PBLOBSARRAYHDR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


#ifdef DEBUG

#define ASSERT_VALID_BLOB(b)            MYASSERT (pIsValidBlob (b))
#define ASSERT_VALID_BLOBS_ARRAY(a)     MYASSERT (pIsValidBlobsArray (a))

BOOL
pIsValidBlob (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    pIsValidBlob checks if the passed-in blob points to a valid OURBLOB blob structure

Arguments:

    Blob - Specifies a pointer to the blob to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!Blob) {
        return FALSE;
    }

    __try {
        b = !Blob->Data && !Blob->End && !Blob->Index && !Blob->AllocSize ||
            Blob->Data && Blob->AllocSize && Blob->End <= Blob->AllocSize && Blob->Index <= Blob->AllocSize;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

BOOL
pIsValidBlobsArray (
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    pIsValidBlobsArray checks if the passed-in bloba array points to a valid BLOBS array structure

Arguments:

    BlobsArray - Specifies a pointer to the blobs array to be checked

Return Value:

    TRUE if the check was successful.
    FALSE if not.

--*/

{
    BOOL b = TRUE;

    if (!BlobsArray) {
        return FALSE;
    }

    __try {
        b = !BlobsArray->Blobs && !BlobsArray->BlobsCount && !BlobsArray->BlobsAllocated ||
            BlobsArray->Signature == BLOBS_SIGNATURE &&
            BlobsArray->Blobs &&
            BlobsArray->BlobsAllocated &&
            BlobsArray->BlobsGrowCount &&
            BlobsArray->BlobsCount <= BlobsArray->BlobsAllocated;
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#else

#define ASSERT_VALID_BLOB(b)
#define ASSERT_VALID_BLOBS_ARRAY(a)

#endif


PVOID
pBlobAllocateMemory (
    IN      DWORD Size
    )

/*++

Routine Description:

    pBlobAllocateMemory is a private function that allocates space from the process heap

Arguments:

    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (Size);
    return HeapAlloc (g_hHeap, 0, Size);
}


static
PVOID
pReAllocateMemory (
    IN      PVOID OldBuffer,
    IN      DWORD NewSize
    )

/*++

Routine Description:

    pReAllocateMemory is a private function that re-allocates space from the process heap

Arguments:

    OldBuffer - Specifies the buffer to be re-allocated
    Size - Specifies the size (in bytes) to allocate.

Return Value:

    A pointer to the successfully re-allocated memory or NULL if not enough memory

--*/

{
    MYASSERT (OldBuffer);
    MYASSERT (NewSize);
    return HeapReAlloc (g_hHeap, 0, OldBuffer, NewSize);
}


VOID
pBlobFreeMemory (
    IN      PVOID Buffer
    )

/*++

Routine Description:

    pBlobFreeMemory is a private function that frees space allocated from the process heap

Arguments:

    Buffer - Specifies a pointer to buffer to free.

Return Value:

    none

--*/

{
    MYASSERT (Buffer);
    HeapFree (g_hHeap, 0, Buffer);
}


POURBLOB
BlobCreate (
    VOID
    )
{
    POURBLOB newBlob;

    newBlob = pBlobAllocateMemory (DWSIZEOF (OURBLOB));
    if (newBlob) {
        ZeroMemory (newBlob, DWSIZEOF (OURBLOB));
    }
    return newBlob;
}


POURBLOB
BlobDuplicate (
    IN      POURBLOB SourceBlob
    )

/*++

Routine Description:

    BlobDuplicate duplicates the data in the source blob, so the resulting blob will
    have an identical copy of data

Arguments:

    SourceBlob - Specifies the blob source of data

Return Value:

    Pointer to the new blob if duplicate was successful; NULL if not enough memory

--*/

{
    POURBLOB newBlob;
    DWORD dataSize;

    newBlob = BlobCreate ();
    if (newBlob && SourceBlob->Data) {
        dataSize = BlobGetDataSize (SourceBlob);
        newBlob->Data = pBlobAllocateMemory (dataSize);
        if (!newBlob->Data) {
            BlobDestroy (newBlob);
            return NULL;
        }
        newBlob->AllocSize = dataSize;
        newBlob->End = dataSize;
        CopyMemory (newBlob->Data, SourceBlob->Data, dataSize);
        newBlob->Flags = SourceBlob->Flags;
    }
    return newBlob;
}


VOID
BlobClear (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobClear clears the specified blob (frees its associated data)

Arguments:

    Blob - Specifies the blob to clear

Return Value:

    none

--*/

{
    if (Blob && Blob->Data) {
        pBlobFreeMemory (Blob->Data);
        ZeroMemory (Blob, DWSIZEOF (OURBLOB));
    }
}


VOID
BlobDestroy (
    IN OUT  POURBLOB Blob
    )

/*++

Routine Description:

    BlobDestroy destroys the specified blob (frees its associated data and the blob itself)

Arguments:

    Blob - Specifies the blob to destroy

Return Value:

    none

--*/

{
    if (Blob) {
        BlobClear (Blob);
        pBlobFreeMemory (Blob);
    }
}


BOOL
BlobSetIndex (
    IN OUT  POURBLOB Blob,
    IN      DWORD Index
    )

/*++

Routine Description:

    BlobSetIndex sets the current read/write pointer

Arguments:

    Blob - Specifies the blob
    Index - Specifies the new index value

Return Value:

    TRUE if the index move was successful

--*/

{
    ASSERT_VALID_BLOB (Blob);

    if (Index > Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobSetIndex: invalid Index specified (%lu)", Index));
        MYASSERT (FALSE);   //lint !e506
        return FALSE;
    }

    Blob->Index = Index;
    return TRUE;
}


DWORD
BlobGetRecordedDataType (
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobGetRecordedDataType returns the data type recorded at current read position

Arguments:

    Blob - Specifies the blob

Return Value:

    The current data type if the blob records data type and the read position is valid;
    BDT_NONE otherwise

--*/

{
    PBYTE p;

    if (BlobRecordsDataType (Blob)) {
        p = BlobGetPointer (Blob);
        if (p) {
            return *(DWORD*)p;
        }
    }
    return BDT_NONE;
}


BOOL
BlobWriteEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD DataType,         OPTIONAL
    IN      BOOL RecordDataSize,
    IN      DWORD DataSize,
    IN      PCVOID Data
    )

/*++

Routine Description:

    BlobWriteEx writes data at the current index position, growing the blob if necessary
    and adjusting it's size.

Arguments:

    Blob - Specifies the blob
    DataType - Specifies the type of data to be stored; can be zero only if the blob
               doesn't record data types
    RecordDataSize - Specifies TRUE if this size has to be recorded in the blob
    DataSize - Specifies the size, in bytes, of the data to be stored
    Data - Specifies the data

Return Value:

    TRUE if write was successful; FALSE if not enough memory

--*/

{
    PBYTE p;
    DWORD totalDataSize;
    DWORD growTo;
    DWORD d;

    ASSERT_VALID_BLOB (Blob);
    MYASSERT (DataSize);

    MYASSERT (DataType || !BlobRecordsDataType (Blob));
    if (!DataType && BlobRecordsDataType (Blob)) {
        return FALSE;
    }

    if (!Blob->GrowSize) {
        Blob->GrowSize = BLOB_GROWDATASIZE_DEFAULT;
    }

    totalDataSize = Blob->Index + DataSize;
    if (BlobRecordsDataType (Blob)) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        //
        // add the size of a DWORD
        //
        totalDataSize += DWSIZEOF (DWORD);
    }
    if (totalDataSize > Blob->AllocSize) {
        d = totalDataSize + Blob->GrowSize - 1;
        growTo = d - d % Blob->GrowSize;
    } else {
        growTo = 0;
    }

    if (!Blob->Data) {
        Blob->Data = (PBYTE) pBlobAllocateMemory (growTo);
        if (!Blob->Data) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pBlobAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
    } else if (growTo) {
        p = pReAllocateMemory (Blob->Data, growTo);
        if (!p) {
            DEBUGMSG ((DBG_ERROR, "BlobWriteEx: pReAllocateMemory (%lu) failed", growTo));
            return FALSE;
        }

        Blob->AllocSize = growTo;
        Blob->Data = p;
    }

    p = BlobGetPointer (Blob);

    if (BlobRecordsDataType (Blob)) {
        *(PDWORD)p = DataType;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }
    if (BlobRecordsDataSize (Blob) || RecordDataSize) {
        *(PDWORD)p = DataSize;
        p += DWSIZEOF (DWORD);
        Blob->Index += DWSIZEOF (DWORD);
    }

    CopyMemory (p, Data, DataSize);
    Blob->Index += DataSize;

    //
    // adjust EOF
    //
    if (Blob->Index > Blob->End) {
        Blob->End = Blob->Index;
    }

    return TRUE;
}


PBYTE
BlobReadEx (
    IN OUT  POURBLOB Blob,
    IN      DWORD ExpectedDataType,     OPTIONAL
    IN      DWORD ExpectedDataSize,     OPTIONAL
    IN      BOOL RecordedDataSize,
    OUT     PDWORD ActualDataSize,      OPTIONAL
    OUT     PVOID Data,                 OPTIONAL
    IN      PMHANDLE Pool               OPTIONAL
    )

/*++

Routine Description:

    BlobReadEx reads data from the specified blob, at the current index position

Arguments:

    Blob - Specifies the blob to read from
    ExpectedDataType - Specifies the expected data type; optional
    ExpectedDataSize - Specifies the expected data size; optional
    RecordedDataSize - Specifies TRUE if the data size was recorded in the blob
    ActualDataSize - Receives the actual data size; optional
    Data - Receives the actual data; optional; if NULL, a buffer will be allocated
    Pool - Specifies the pool to use for memory allocations; optional;
           if NULL, the process heap will be used

Return Value:

    A pointer to the buffer containing the data; NULL if an error occured
    or some data conditions don't match

--*/

{
    DWORD initialIndex;
    PBYTE readPtr;
    DWORD actualDataType;
    DWORD actualDataSize = 0;

    ASSERT_VALID_BLOB (Blob);

    readPtr = BlobGetPointer (Blob);
    if (!readPtr) {
        return NULL;
    }

    //
    // data size must be available some way
    //
    MYASSERT (BlobRecordsDataSize (Blob) || RecordedDataSize || ExpectedDataSize);

    initialIndex = BlobGetIndex (Blob);

    if (BlobRecordsDataType (Blob)) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            return NULL;
        }
        //
        // check actual data type
        //
        actualDataType = *(DWORD*)readPtr;

        if (ExpectedDataType && ExpectedDataType != actualDataType) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data type (%lu) different than expected data type (%lu)",
                actualDataType,
                ExpectedDataType
                ));

            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);
    }

    if (BlobRecordsDataSize (Blob) || RecordedDataSize) {

        if (readPtr + DWSIZEOF (DWORD) > BlobGetEOF (Blob)) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
        //
        // read actual data size
        //
        actualDataSize = *(DWORD*)readPtr;

        if (ExpectedDataSize && ExpectedDataSize != actualDataSize) {

            DEBUGMSG ((
                DBG_ERROR,
                "BlobReadEx: Actual data size (%lu) different than expected data size (%lu)",
                actualDataSize,
                ExpectedDataSize
                ));

            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }

        Blob->Index += DWSIZEOF (DWORD);
        readPtr += DWSIZEOF (DWORD);

    } else {
        actualDataSize = ExpectedDataSize;
    }

    if (!actualDataSize) {
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (ActualDataSize) {
        *ActualDataSize = actualDataSize;
    }

    //
    // don't read over end of file
    //
    if (readPtr + actualDataSize > BlobGetEOF (Blob)) {
        //
        // corrupt blob; undo anyway
        //
        MYASSERT (FALSE);   //lint !e506
        BlobSetIndex (Blob, initialIndex);
        return NULL;
    }

    if (!Data) {

        if (Pool) {
            Data = PmGetMemory (Pool, actualDataSize);
        } else {
            Data = pBlobAllocateMemory (actualDataSize);
        }

        if (!Data) {
            BlobSetIndex (Blob, initialIndex);
            return NULL;
        }
    }

    CopyMemory (Data, readPtr, actualDataSize);

    Blob->Index += actualDataSize;

    return Data;
}


BOOL
BlobWriteDword (
    IN OUT  POURBLOB Blob,
    IN      DWORD Data
    )

/*++

Routine Description:

    BlobWriteDword writes a DWORD at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORD

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_DWORD, FALSE, DWSIZEOF (DWORD), &Data);
}


BOOL
BlobReadDword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORD Data
    )

/*++

Routine Description:

    BlobReadDword reads a DWORD from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORD

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_DWORD, DWSIZEOF (DWORD), FALSE, NULL, Data, NULL) != NULL;
}


BOOL
BlobWriteQword (
    IN OUT  POURBLOB Blob,
    IN      DWORDLONG Data
    )

/*++

Routine Description:

    BlobWriteQword writes a DWORDLONG at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the DWORDLONG

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_QWORD, FALSE, DWSIZEOF (DWORDLONG), &Data);
}


BOOL
BlobReadQword (
    IN OUT  POURBLOB Blob,
    OUT     PDWORDLONG Data
    )

/*++

Routine Description:

    BlobReadQword reads a DWORDLONG from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives the DWORDLONG

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    return BlobReadEx (Blob, BDT_QWORD, DWSIZEOF (DWORDLONG), FALSE, NULL, Data, NULL) != NULL;
}


/*++

Routine Description:

    BlobWriteString writes a string at the current writing position in the specified blob;
    the string is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the string

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteStringA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PCWSTR unicodeString;
    BOOL b;

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = ConvertAtoW (Data);
        b = BlobWriteStringW (Blob, unicodeString);
        FreeConvertedStr (unicodeString);
        return b;
    }
    return BlobWriteEx (Blob, BDT_SZA, TRUE, SizeOfStringA (Data), Data);
}


BOOL
BlobWriteStringW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_SZW, TRUE, SizeOfStringW (Data), Data);
}


/*++

Routine Description:

    BlobReadString reads a string from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_SZA for the ANSI version
    and BDT_SZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated string
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadStringA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {

        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);

            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadStringW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_SZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_SZA) {

            ansiString = BlobReadEx (Blob, BDT_SZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }
            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);
                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadStringW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_SZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


/*++

Routine Description:

    BlobWriteMultiSz writes a multisz at the current writing position in the specified blob;
    the multisz is stored in UNICODE inside the blob if BF_UNICODESTRINGS is set

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the multisz

Return Value:

    TRUE if data was successfully stored in the blob

--*/

BOOL
BlobWriteMultiSzA (
    IN OUT  POURBLOB Blob,
    IN      PCSTR Data
    )
{
    PWSTR unicodeString;
    BOOL b;
    DWORD stringSize = SizeOfMultiSzA (Data);

    if (BlobRecordsUnicodeStrings (Blob)) {
        unicodeString = AllocTextW (stringSize);
        DirectDbcsToUnicodeN (unicodeString, Data, stringSize);
        b = BlobWriteMultiSzW (Blob, unicodeString);
        FreeTextW (unicodeString);
        return b;
    }

    return BlobWriteEx (Blob, BDT_MULTISZA, TRUE, stringSize, Data);
}

BOOL
BlobWriteMultiSzW (
    IN OUT  POURBLOB Blob,
    IN      PCWSTR Data
    )
{
    return BlobWriteEx (Blob, BDT_MULTISZW, TRUE, SizeOfMultiSzW (Data), Data);
}



/*++

Routine Description:

    BlobReadMultiSz reads a multisz from the current reading position in the specified blob;
    the string may be converted to the ANSI/UNICODE format.
    If the blob doesn't store data types, this is assumed to be BDT_MULTISZA for the ANSI version
    and BDT_MULTISZW for the UNICODE version of this function

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated multisz
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

BOOL
BlobReadMultiSzA (
    IN OUT  POURBLOB Blob,
    OUT     PCSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PSTR ansiString;
    PCWSTR unicodeString;
    DWORD dataType;
    DWORD index;
    DWORD length = 0;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    ansiString = NULL;
    unicodeString = NULL;

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZW) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzA: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        if (BlobRecordsUnicodeStrings (Blob)) {

            unicodeString = (PCWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, &length, NULL, Pool);

        } else {
            //
            // assume an ANSI string is stored there
            //
            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, NULL, NULL, Pool);
        }
    }

    if (!ansiString) {
        if (!unicodeString) {
            return FALSE;
        }

        if (Pool) {
            ansiString = PmGetMemory (Pool, length);
        } else {
            ansiString = pBlobAllocateMemory (length);
        }

        if (ansiString) {
            DirectUnicodeToDbcsN (ansiString, unicodeString, length);
        }

        if (Pool) {
            PmReleaseMemory (Pool, (PVOID)unicodeString);
        } else {
            pBlobFreeMemory ((PVOID)unicodeString);
        }

        if (!ansiString) {
            //
            // recover prev state
            //
            BlobSetIndex (Blob, index);
            return FALSE;
        }
    }

    *Data = ansiString;
    return TRUE;
}

BOOL
BlobReadMultiSzW (
    IN OUT  POURBLOB Blob,
    OUT     PCWSTR* Data,
    IN      PMHANDLE Pool       OPTIONAL
    )
{
    PWSTR unicodeString;
    PCSTR ansiString;
    DWORD dataType;
    DWORD index;
    DWORD length;

    //
    // save initial index; in case of failure it will be restored
    //
    index = BlobGetIndex (Blob);
    if (!index) {
        return FALSE;
    }

    if (BlobRecordsDataType (Blob)) {

        dataType = BlobGetRecordedDataType (Blob);

        if (dataType == BDT_MULTISZW) {

            unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);

        } else if (dataType == BDT_MULTISZA) {

            ansiString = BlobReadEx (Blob, BDT_MULTISZA, 0, TRUE, &length, NULL, Pool);

            if (!ansiString) {
                return FALSE;
            }

            if (Pool) {
                unicodeString = PmGetMemory (Pool, length * DWSIZEOF (WCHAR));
            } else {
                unicodeString = pBlobAllocateMemory (length * DWSIZEOF (WCHAR));
            }

            if (unicodeString) {
                DirectDbcsToUnicodeN (unicodeString, ansiString, length);
            }

            if (Pool) {
                PmReleaseMemory (Pool, (PVOID)ansiString);
            } else {
                pBlobFreeMemory ((PVOID)ansiString);
            }

            if (!unicodeString) {
                //
                // recover prev state
                //
                BlobSetIndex (Blob, index);

                return FALSE;
            }

        } else {

            DEBUGMSG ((DBG_ERROR, "BlobReadMultiSzW: unexpected data type (%lu)", dataType));
            return FALSE;

        }
    } else {
        //
        // assume an UNICODE string is stored there
        //
        unicodeString = (PWSTR)BlobReadEx (Blob, BDT_MULTISZW, 0, TRUE, NULL, NULL, Pool);
    }

    if (!unicodeString) {
        return FALSE;
    }

    *Data = unicodeString;
    return TRUE;
}


BOOL
BlobWriteBinaryEx (
    IN OUT  POURBLOB Blob,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      BOOL RecordDataSize
    )

/*++

Routine Description:

    BlobWriteBinary writes a buffer at the current writing position in the specified blob

Arguments:

    Blob - Specifies the blob to write to
    Data - Specifies the source buffer
    Size - Specifies the size of the buffer
    RecordDataSize - Specifies TRUE if data size should be recorded, too

Return Value:

    TRUE if data was successfully stored in the blob

--*/

{
    return BlobWriteEx (Blob, BDT_BINARY, RecordDataSize, Size, Data);
}


BOOL
BlobReadBinary (
    IN OUT  POURBLOB Blob,
    OUT     PBYTE* Data,
    OUT     PDWORD Size,
    IN      PMHANDLE Pool       OPTIONAL
    )

/*++

Routine Description:

    BlobReadBinary reads a buffer from the current reading position in the specified blob

Arguments:

    Blob - Specifies the blob to read from
    Data - Receives a pointer to the new allocated buffer
    Size - Receives the size of the buffer
    Pool - Specifies the pool to use for allocating memory;
           if NULL, the process heap will be used

Return Value:

    TRUE if data was successfully read from the blob

--*/

{
    *Data = BlobReadEx (Blob, BDT_BINARY, 0, TRUE, Size, NULL, Pool);
    return *Data != NULL;
}


BOOL
BlobWriteToFile (
    IN      POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobWriteToFile writes the specified blob to the given file

Arguments:

    Blob - Specifies the blob to save
    File - Specifies the handle of the file to write the blob to

Return Value:

    TRUE if blob was successfully written to the file

--*/

{
    BLOBHDR header;
    DWORD d;

    if (!Blob->End) {
        DEBUGMSG ((DBG_BLOBS, "BlobWriteToFile: Did not write empty blob to file"));
        return FALSE;
    }

    //
    // save blob's Flags and End position
    //
    header.BlobSignature = BLOB_SIGNATURE;
    header.DataSize = Blob->End;
    header.Flags = Blob->Flags;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob header!"));
        return FALSE;
    }
    if (!WriteFile (File, Blob->Data, Blob->End, &d, NULL) || d != Blob->End) {
        DEBUGMSG ((DBG_ERROR, "BlobWriteToFile: Error writing blob data!"));
        return FALSE;
    }
    return TRUE;
}


BOOL
BlobReadFromFile (
    OUT     POURBLOB Blob,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobReadFromFile reads data from the given file in the specified blob

Arguments:

    Blob - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if blob was successfully read from the file

--*/

{
    BLOBHDR header;
    DWORD d;

    //
    // read blob's Flags and End position
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBHDR), &d, NULL) || d != DWSIZEOF (BLOBHDR)) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob header!"));
        return FALSE;
    }

    if (header.BlobSignature != BLOB_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Not a valid blob signature!"));
        return FALSE;
    }

    Blob->Data = pBlobAllocateMemory (header.DataSize);
    if (!Blob->Data) {
        return FALSE;
    }

    if (!ReadFile (File, Blob->Data, header.DataSize, &d, NULL) || d != header.DataSize) {
        DEBUGMSG ((DBG_ERROR, "BlobReadFromFile: Error reading blob data!"));
        pBlobFreeMemory (Blob->Data);
        Blob->Data = NULL;
        return FALSE;
    }

    Blob->AllocSize = header.DataSize;
    Blob->End = header.DataSize;
    Blob->Flags = header.Flags;
    Blob->Index = 0;
    return TRUE;
}


BOOL
BlobsAdd (
    IN OUT  PBLOBS BlobsArray,
    IN      POURBLOB Blob
    )

/*++

Routine Description:

    BlobsAdd adds the specified Blob to a blobs array

Arguments:

    BlobsArray - Specifies the array to add to
    Blob - Specifies the blob to add

Return Value:

    TRUE if the new blob pointer was added successfully

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (!BlobsArray->BlobsGrowCount) {
        BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;
    }

    if (!BlobsArray->Blobs) {

        BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (
                                        BlobsArray->BlobsGrowCount * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            DEBUGMSG ((DBG_ERROR, "BlobsAddE: Initial alloc failed"));
            return FALSE;
        }
        BlobsArray->Signature = BLOBS_SIGNATURE;
        BlobsArray->BlobsAllocated = BlobsArray->BlobsGrowCount;
        BlobsArray->BlobsCount = 0;

    } else if (BlobsArray->BlobsCount == BlobsArray->BlobsAllocated) {

        BlobsArray->BlobsAllocated += BlobsArray->BlobsGrowCount;
        BlobsArray->Blobs = (POURBLOB*)pReAllocateMemory (
                                        BlobsArray->Blobs,
                                        BlobsArray->BlobsAllocated * DWSIZEOF (POURBLOB)
                                        );
        if (!BlobsArray->Blobs) {
            BlobsArray->BlobsAllocated -= BlobsArray->BlobsGrowCount;
            DEBUGMSG ((DBG_ERROR, "BlobsAdd: Realloc failed"));
            return FALSE;
        }
    }

    *(BlobsArray->Blobs + BlobsArray->BlobsCount) = Blob;
    BlobsArray->BlobsCount++;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);
    return TRUE;
}


VOID
BlobsFree (
    IN OUT  PBLOBS BlobsArray,
    IN      BOOL DestroyBlobs
    )

/*++

Routine Description:

    BlobsFree destroys the array and optionally destroys all blobs in it

Arguments:

    BlobsArray - Specifies the array to delete
    DestroyBlobs - Specifies TRUE if the component blobs are to be deleted, too

Return Value:

    none

--*/

{
    BLOB_ENUM e;

    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    if (DestroyBlobs) {
        if (EnumFirstBlob (&e, BlobsArray)) {
            do {
                BlobDestroy (e.CurrentBlob);
            } while (EnumNextBlob (&e));
        }
    }

    pBlobFreeMemory (BlobsArray->Blobs);
    ZeroMemory (BlobsArray, DWSIZEOF (BLOBS));
}


BOOL
EnumFirstBlob (
    OUT     PBLOB_ENUM BlobEnum,
    IN      PBLOBS BlobsArray
    )

/*++

Routine Description:

    EnumFirstBlob enumerates the first blob in the given array

Arguments:

    BlobEnum - Receives enum info
    BlobsArray - Specifies the array to enum from

Return Value:

    TRUE if a first blob was found; FALSE if array is empty

--*/

{
    ASSERT_VALID_BLOBS_ARRAY (BlobsArray);

    BlobEnum->Index = 0;
    BlobEnum->Array = BlobsArray;
    return EnumNextBlob (BlobEnum);
}


BOOL
EnumNextBlob (
    IN OUT  PBLOB_ENUM BlobEnum
    )

/*++

Routine Description:

    EnumNextBlob enumerates the next blob in the given array

Arguments:

    BlobEnum - Specifies/receives enum info

Return Value:

    TRUE if a next blob was found; FALSE if no more blobs

--*/

{
    if (BlobEnum->Index >= BlobEnum->Array->BlobsCount) {
        return FALSE;
    }

    BlobEnum->CurrentBlob = *(BlobEnum->Array->Blobs + BlobEnum->Index);
    BlobEnum->Index++;
    return TRUE;
}


BOOL
BlobsWriteToFile (
    IN      PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsWriteToFile writes the specified blobs array to the given file

Arguments:

    BlobsArray - Specifies the blobs array to save
    File - Specifies the handle of the file to write the array to

Return Value:

    TRUE if array was successfully written to the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    POURBLOB* blob;

    if (!BlobsArray->BlobsCount) {
        DEBUGMSG ((DBG_BLOBS, "BlobsWriteToFile: Did not write empty blobs array to file"));
        return FALSE;
    }

    //
    // save blobs count
    //
    header.BlobsArraySignature = BLOBS_SIGNATURE;
    header.BlobsCount = BlobsArray->BlobsCount;

    if (!WriteFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsWriteToFile: Error writing blobs array header!"));
        return FALSE;
    }
    for (blob = BlobsArray->Blobs; blob < BlobsArray->Blobs + BlobsArray->BlobsCount; blob++) {
        if (!BlobWriteToFile (*blob, File)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsWriteToFile: Error writing blob # %lu to file",
                blob - BlobsArray->Blobs
                ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
BlobsReadFromFile (
    OUT     PBLOBS BlobsArray,
    IN      HANDLE File
    )

/*++

Routine Description:

    BlobsReadFromFile reads data from the given file in the specified blobs array

Arguments:

    BlobsArray - Receives the data
    File - Specifies the handle of the file to read from

Return Value:

    TRUE if array was successfully read from the file

--*/

{
    BLOBSARRAYHDR header;
    DWORD d;
    UINT u;
    POURBLOB blob;

    //
    // read blobs count
    //
    if (!ReadFile (File, &header, DWSIZEOF (BLOBSARRAYHDR), &d, NULL) ||
        d != DWSIZEOF (BLOBSARRAYHDR)
        ) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Error reading blobs array header!"));
        return FALSE;
    }

    if (header.BlobsArraySignature != BLOBS_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "BlobsReadFromFile: Not a valid blobs array signature!"));
        return FALSE;
    }

    BlobsArray->Blobs = (POURBLOB*)pBlobAllocateMemory (header.BlobsCount * DWSIZEOF (POURBLOB*));
    if (!BlobsArray->Blobs) {
        return FALSE;
    }

    ZeroMemory (BlobsArray->Blobs, header.BlobsCount * DWSIZEOF (POURBLOB));

    BlobsArray->Signature = BLOBS_SIGNATURE;
    BlobsArray->BlobsAllocated = header.BlobsCount;
    BlobsArray->BlobsCount = 0;
    BlobsArray->BlobsGrowCount = BLOBS_GROWCOUNT_DEFAULT;

    for (u = 0; u < header.BlobsCount; u++) {

        blob = BlobCreate ();
        if (!blob) {
            return FALSE;
        }

        if (!BlobReadFromFile (blob, File)) {

            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error reading blob # %lu from file",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }

        if (!BlobsAdd (BlobsArray, blob)) {
            DEBUGMSG ((
                DBG_BLOBS,
                "BlobsReadFromFile: Error adding blob # %lu to array",
                u
                ));

            BlobsFree (BlobsArray, TRUE);
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\dbgtrack.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgtrack.c

Abstract:

    Allocation tracking implementation. From old debug.c

Author:

    Marc R. Whitten  (marcw) 09-Sept-1999

Revision History:

--*/

//
// Includes
//

#include "pch.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")



//
// Strings
//

// None

//
// Constants
//

#define TRACK_BUCKETS           1501
#define BUCKET_ITEMS_PER_POOL   8192




//
// Macros
//

// None

//
// Types
//

typedef UBINT ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;


typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
    BOOL Allocated;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;

//
// Globals
//

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];
PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//
PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
BOOL g_TrackAlloc;
INT g_UseCount;
UINT g_DisableTrackComment = 0;
GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}



PBYTE
pOurTrackedGbGrow (
    IN      PGROWBUFFER Buffer,
    IN      UINT Bytes
    )
{
    PBYTE p;
    BOOL trackMsg = FALSE;

    //
    // Because grow buffers themselves cause tracking, we have to
    // call the untracked version.  To eliminate confusion, we
    // give a helpful note.
    //

    if (!g_TrackFile) {
        trackMsg = TRUE;
        g_TrackFile = "<allocation tracking in dbgtrack.c, not a real leak>";
        g_TrackLine = __LINE__;
    }

    p = (PSTR) RealGbGrow (Buffer, Bytes);

    if (trackMsg) {
        g_TrackFile = NULL;
    }

    return p;
}


INT
TrackPushEx (
    PCSTR Msg,
    PCSTR File,
    UINT Line,
    BOOL Alloc
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    TrackPush (Msg, File, Line);
    g_TrackAlloc = TRUE;

    return 0;
}


INT
TrackPush (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s line %u [%s]", File, Line, Msg);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    g_TrackFile = File;
    g_TrackLine = Line;
    g_TrackAlloc = FALSE;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}


INT
TrackPop (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment = NULL;
        g_TrackFile = NULL;
        g_TrackLine = 0;
        g_TrackAlloc = FALSE;
    }

    return 0;
}


VOID
TrackDump (
    VOID
    )
{
    if (g_UseCount > 0) {
        DEBUGMSGA (("Caller", "%s line %u (%s)", g_TrackFile, g_TrackLine, g_TrackComment));
    }
}


VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}


VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = INIT_GROWBUFFER;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = (UINT) wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);
        p = (PSTR) pOurTrackedGbGrow (&Msg, Bytes);

        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) pOurTrackedGbGrow (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        GbFree (&Msg);
    }

    GbFree (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    DWORD Hash;

    Hash = (DWORD) ((DWORD)Type << 16) ^ (DWORD)(UBINT)Ptr;
    return Hash % TRACK_BUCKETS;
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocationEx (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line,
    IN      BOOL Alloc
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        if (Alloc) {
            Item->FileName = SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (File));
            if (Item->FileName) {
                StringCopyA ((PSTR)Item->FileName, File);
            }
            Item->Allocated = TRUE;
        } else {
            Item->FileName = File;
            Item->Allocated = FALSE;
        }
        Item->Line = Line;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
        //DEBUGMSG ((DBG_VERBOSE, "Allocation: File=%s, Line=%d, Size=%d", File, Line, Size));
    }
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) pOurTrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;
        Item->Allocated = FALSE;

        pTrackHashTableInsert (
            g_AllocationList.Buf,
            (ALLOCATION_ITEM_OFFSET) ((PBYTE) Item - g_AllocationList.Buf)
            );
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        if (Item->Allocated) {
            HeapFree (g_hHeap, 0, (PSTR)Item->FileName);
        }
        Item->FileName = NULL;
        Item->Type = (ALLOCTYPE) -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\exclist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    exclist.c

Abstract:

    Implements a set of APIs to manage exclusion lists of objects
    of various well-known types.

Author:

    Ovidiu Temereanca (ovidiut)   23-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_EXCLIST         "ExcList"

//
// Strings
//

#define S_EXCLUSIONLIST     "ExcList"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_ElPool,Size)

#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_ElPool, (PVOID)Buffer)


//
// Types
//

typedef struct {
    DWORD TypeId;
    PCSTR TypeName;
} EXCLISTPROPS, *PEXCLISTPROPS;


//
// Globals
//

PMHANDLE g_ElPool;
GROWLIST* g_ElTypeLists;

//
// Macro expansion list
//

// Defined in exclist.h

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(TypeId,TypeName)     TypeId, TypeName,

EXCLISTPROPS g_ExcListProps [] = {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_LAST, NULL
};

#undef DEFMAC


//
// Code
//


BOOL
ElInitialize (
    VOID
    )

/*++

Routine Description:

    ElInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (!g_ElPool);
    g_ElPool = PmCreateNamedPool (S_EXCLUSIONLIST);
    if (!g_ElPool) {
        return FALSE;
    }

    MYASSERT (!g_ElTypeLists);
    g_ElTypeLists = pAllocateMemory (ELT_LAST * DWSIZEOF (GROWLIST));
    MYASSERT (g_ElTypeLists);
    ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));

    return TRUE;
}


/*++

Routine Description:

    ElTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElTerminateA (
    VOID
    )
{
    ElRemoveAllA ();

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}

VOID
ElTerminateW (
    VOID
    )
{
    ElRemoveAllW ();

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}


/*++

Routine Description:

    ElGetTypeId returns the TypeId of a type given by name

Arguments:

    TypeName - Specifies the name

Return Value:

    One of DWORD enumeration values

--*/

DWORD
ElGetTypeId (
    IN      PCSTR TypeName
    )
{
    UINT u;

    if (TypeName) {
        for (u = 0; g_ExcListProps[u].TypeName; u++) {
            if (StringIMatchA (g_ExcListProps[u].TypeName, TypeName)) {
                return g_ExcListProps[u].TypeId;
            }
        }
    }

    return ELT_LAST;
}


/*++

Routine Description:

    ElGetTypeName returns the type name of a type given by TypeId

Arguments:

    TypeId - Specifies the ID

Return Value:

    A pointer to one of the known type names or NULL if TypeId is unknown

--*/

PCSTR
ElGetTypeName (
    IN      DWORD TypeId
    )
{
    MYASSERT (TypeId < ELT_LAST);
    if (TypeId >= ELT_LAST) {
        return NULL;
    }
    return g_ExcListProps[TypeId].TypeName;
}


/*++

Routine Description:

    ElAdd adds the given object of the given type to the exclusion list. The object
    is first parsed so that the decision if a given string matches this pattern is faster.

Arguments:

    ObjectType - Specifies the object type
    ObjectName - Specifies the object pattern string

Return Value:

    TRUE if the string pattern was successfully parsed and added to the list

--*/

BOOL
ElAddA (
    IN      DWORD ObjectType,
    IN      PCSTR ObjectName
    )
{
    POBSPARSEDPATTERNA pp;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    pp = ObsCreateParsedPatternExA (NULL, ObjectName, ObjectType == ELT_FILE);
    if (!pp) {
        DEBUGMSGA ((
            DBG_EXCLIST,
            "ElAddA: Bad ObjectName: %s (type %s)",
            ObjectName,
            ElGetTypeName (ObjectType)
            ));
        return FALSE;
    }

    //
    // add the pointer to the list
    //
    GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp, DWSIZEOF (pp));

    DEBUGMSGA ((
        DBG_EXCLIST,
        "ElAddA: Added excluded %s as type %s",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));

    return TRUE;
}


BOOL
ElAddW (
    IN      DWORD ObjectType,
    IN      PCWSTR ObjectName
    )
{
    POBSPARSEDPATTERNW pp;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    pp = ObsCreateParsedPatternExW (NULL, ObjectName, ObjectType == ELT_FILE);
    if (!pp) {
        DEBUGMSGW ((
            DBG_EXCLIST,
            "ElAddW: Bad ObjectName: %s (type %hs)",
            ObjectName,
            ElGetTypeName (ObjectType)
            ));
        return FALSE;
    }

    //
    // add the pointer to the list
    //
    GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp, DWSIZEOF (pp));

    DEBUGMSGW ((
        DBG_EXCLIST,
        "ElAddW: Added excluded %s as type %hs",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));

    return TRUE;
}


/*++

Routine Description:

    ElRemoveAll removes all object patterns from the exclusion list.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElRemoveAllA (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_LAST; u++) {
            gl = &g_ElTypeLists[u];

            for (i = GlGetSize (gl); i > 0; i--) {
                ObsDestroyParsedPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                GlDeleteItem (gl, i - 1);
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));
    }
}

VOID
ElRemoveAllW (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_LAST; u++) {
            gl = &g_ElTypeLists[u];
            for (i = GlGetSize (gl); i > 0; i--) {
                ObsDestroyParsedPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                GlDeleteItem (gl, i - 1);
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));
    }
}


/*++

Routine Description:

    ElIsExcluded decides if the given object string is excluded (if it matches one of the
    patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Object - Specifies the object string

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;
    PSTR node;
    PSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (!ObsSplitObjectStringExA (Object, &node, &leaf, g_ElPool, FALSE)) {
        DEBUGMSGA ((DBG_EXCLIST, "ElIsExcludedA: invalid Object: \"%s\"", Object));
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !node) {
            continue;
        }
        if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
            continue;
        }
        if (leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternA (pp->NodePattern, node)) {
            continue;
        }
        //
        // the patterns match!
        //
        b = TRUE;
        break;
    }

    pFreeMemory (node);
    pFreeMemory (leaf);

    return b;
}

BOOL
ElIsExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;
    PWSTR node;
    PWSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (!ObsSplitObjectStringExW (Object, &node, &leaf, g_ElPool, FALSE)) {
        DEBUGMSGW ((DBG_EXCLIST, "ElIsExcludedW: invalid Object: \"%s\"", Object));
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !node) {
            continue;
        }
        if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
            continue;
        }
        if (leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternW (pp->NodePattern, node)) {
            continue;
        }
        //
        // the patterns match!
        //
        b = TRUE;
        break;
    }

    pFreeMemory (node);
    pFreeMemory (leaf);

    return b;
}


/*++

Routine Description:

    ElIsExcluded2 decides if the object given by its 2 components is excluded
    (if it matches one of the patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Node - Specifies the node part of the object
    Leaf - Specifies the leaf part of the object; optional

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Node,             OPTIONAL
    IN      PCSTR Leaf              OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !Node) {
            continue;
        }
        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternA (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}

BOOL
ElIsExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Node,            OPTIONAL
    IN      PCWSTR Leaf             OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !Node) {
            continue;
        }
        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternW (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    ElIsTreeExcluded2 decides if the object given by its 2 components and representing the
    whole tree beneath it (as a root) is excluded; i.e. if any child of the given object
    is excluded

Arguments:

    ObjectType - Specifies the object type
    Root - Specifies the root of the tree
    LeafPattern - Specifies the leaf pattern to be used for this decision; optional;
                  if NULL, no leaf pattern matching will be attempted

Return Value:

    TRUE if the tree is excluded, given the leaf pattern

--*/

BOOL
ElIsTreeExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNA pp;
    PCSTR subTreePattern;
    PPARSEDPATTERNA stpp;
    PPARSEDPATTERNA lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternA (LeafPattern);
        if (!lpp) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackA (Root);
    if (!subTreePattern || subTreePattern[1] != '*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExA ((g_ElPool, Root, "*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternA (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternA (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternA (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternA (stpp);
    }
    ELSE_DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternA (lpp);
    }

    return b;
}

BOOL
ElIsTreeExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR LeafPattern          OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNW pp;
    PCWSTR subTreePattern;
    PPARSEDPATTERNW stpp;
    PPARSEDPATTERNW lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternW (LeafPattern);
        if (!lpp) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackW (Root);
    if (!subTreePattern || subTreePattern[1] != L'*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExW ((g_ElPool, Root, L"*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternW (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternW (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternW (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternW (stpp);
    }
    ELSE_DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternW (lpp);
    }

    return b;
}


/*++

Routine Description:

    ElIsObsPatternExcluded decides if the object given by its parsed pattern is excluded;
    i.e. if any object matching this pattern is excluded

Arguments:

    ObjectType - Specifies the object type
    Pattern - Specifies the parsed pattern to be used for this decision

Return Value:

    TRUE if the object is excluded

--*/

BOOL
ElIsObsPatternExcludedA (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
ElIsObsPatternExcludedW (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of binary
    objects.

Author:

    08-Aug-1997   jimschm     Created

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGlAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGlAdd allocates memory for a binary block by using a pool, and then expands
  an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PmCreateNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PmDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GbGrow (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PmGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GlGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
GlFree (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlFree frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GbFree (&GrowList->ListArray);
    if (GrowList->ListData) {
        PmDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlReset empties the grow list but does not destroy the index buffer or pool.
  It is used to efficiently reuse a list.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GrowList->ListArray.End = 0;;
    if (GrowList->ListData) {
        PmEmptyPool (GrowList->ListData);
    }
}


PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlGetItem returns a pointer to the block of data for item specified by
  Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    MYASSERT(ItemPtr);

    return ItemPtr[Index];
}


UINT
GlGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GlGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item and appends two zero
  bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a black of data as a new list item, before the specified
  Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a block of data as a new list item, before the specified
  Index.  Two zero bytes are appended to the block of data (used for string
  termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    GrowList->ListArray.End = Size * sizeof (PBYTE);

    return TRUE;
}


BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlResetItem sets the list pointer of the specified item to NULL, freeing the
  memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GlSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PmGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "utilsp.h"
#include "locale.h"

//#define DEBUG_ALL_FILES

HINSTANCE g_hInst;
HANDLE g_hHeap;

OSVERSIONINFOA g_OsInfo;

#define TEXT_GROWTH_SIZE    65536


//
// OS-dependent flags for MultiByteToWideChar
//

DWORD g_MigutilWCToMBFlags = 0;


//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;

//
// The PoolMem routines must also be thread-safe
//

CRITICAL_SECTION g_PmCs;

//
// MemAlloc critical section
//

CRITICAL_SECTION g_MemAllocCs;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//
PMHANDLE g_RegistryApiPool;
PMHANDLE g_PathsPool;
PMHANDLE g_TextPool;
static BOOL g_UtilsInitialized;

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    )
{
    if (g_UtilsInitialized) {
        DEBUGMSG ((DBG_ERROR, "Utilities already initialized"));
        return;
    }

    g_UtilsInitialized = TRUE;

    //
    // Set globals
    //

    if (Heap) {
        g_hHeap = Heap;
    } else {
        g_hHeap = GetProcessHeap();
    }

    if (!g_hInst) {
        g_hInst = GetModuleHandle (NULL);
    }

    //
    // Load in OSVERSION info.
    //
    g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA (&g_OsInfo);

    //
    // Create critical sections
    //

    __try {
        InitializeCriticalSection (&g_MemAllocCs);
        InitializeCriticalSection (&g_PmCs);
        InitializeOurCriticalSection (&g_MessageCs);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception, but we don't check for that in this function.
        // Ignored
    }

    //
    // Create text pool, needed for the log
    //

    g_TextPool = PmCreateNamedPool ("Text");
    PmSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

    //
    // Create the rest of the pools
    //

    g_RegistryApiPool = PmCreateNamedPool ("Registry API");
    g_PathsPool = PmCreateNamedPool ("Paths");

    //
    // Now that MemAlloc will work, initialize allocation tracking
    //

    InitAllocationTracking();

    //
    // Create the short-term alloc table for string resource utils
    //

    g_ShortTermAllocTable = CreateAllocTable();

    //
    // MultiByteToWideChar has desirable flags that only function on NT
    //

    if (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT && g_OsInfo.dwMajorVersion > 4) {
        // This flag is only valid for Win2k and above, it will cause conversion to fail on NT4
        g_MigutilWCToMBFlags = WC_NO_BEST_FIT_CHARS;
    } else {
        g_MigutilWCToMBFlags =  0;
    }

    //
    // The "out of memory" message
    //

    g_OutOfMemoryTable = CreateAllocTable();

    g_OutOfMemoryRetry  = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10001 /* MSG_OUT_OF_MEMORY_RETRY */
                                );

    g_OutOfMemoryString = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10002 /* MSG_OUT_OF_MEMORY */
                                );

    if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
        //
        //DEBUGMSG ((
        //    DBG_WARNING,
        //    "Cannot load out of memory messages; resources 10001 and 10002 do not exist"
        //   ));
    }

    ObsInitialize ();
    ElInitialize ();

    //
    // set the locale to the system locale. Not doing this can cause isspace
    // to AV in certain MBSCHR circumstances.
    //
    setlocale(LC_ALL,"");
    InitLeadByteTable();
}


VOID
UtTerminate (
    VOID
    )
{
    if (!g_UtilsInitialized) {
        DEBUGMSG ((DBG_ERROR, "UtTerminate already called"));
        return;
    }
    g_UtilsInitialized = FALSE;

    //
    // Free utility pools
    //

    ElTerminate ();
    ObsTerminate ();

    if (g_RegistryApiPool) {
        PmDestroyPool (g_RegistryApiPool);
    }

    if (g_PathsPool) {
        PmDestroyPool (g_PathsPool);
    }

    if (g_ShortTermAllocTable) {
        DestroyAllocTable (g_ShortTermAllocTable);
    }

    if (g_OutOfMemoryTable) {
        DestroyAllocTable (g_OutOfMemoryTable);
    }

    if (g_TextPool) {
        PmDestroyPool (g_TextPool);
    }

    //
    // Clean up handles used by critical sections
    //
    FreeAllocationTracking();

    DumpHeapLeaks ();

    PmDumpStatistics ();

    GbDumpStatistics ();

    DumpHeapStats();

    DeleteCriticalSection (&g_MemAllocCs);
    DeleteCriticalSection (&g_PmCs);
    DeleteOurCriticalSection (&g_MessageCs);
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}




HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}


HANDLE
StartProcessA (
    IN      PCSTR CmdLine
    )
{
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    PSTR copyOfCmdLine;
    BOOL b;

    copyOfCmdLine = DuplicateTextA (CmdLine);

    ZeroMemory (&si, sizeof (si));

    b = CreateProcessA (
            NULL,
            copyOfCmdLine,
            NULL,
            NULL,
            FALSE,
            CREATE_NEW_PROCESS_GROUP,
            NULL,
            NULL,
            &si,
            &pi
            );

    FreeTextA (copyOfCmdLine);

    if (!b) {
        return NULL;
    }

    CloseHandle (pi.hThread);
    return pi.hProcess;
}

HANDLE
StartProcessW (
    IN      PCWSTR CmdLine
    )
{
    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    PWSTR copyOfCmdLine;
    BOOL b;

    copyOfCmdLine = DuplicateTextW (CmdLine);

    ZeroMemory (&si, sizeof (si));

    b = CreateProcessW (
            NULL,
            copyOfCmdLine,
            NULL,
            NULL,
            FALSE,
            CREATE_NEW_PROCESS_GROUP,
            NULL,
            NULL,
            &si,
            &pi
            );

    FreeTextW (copyOfCmdLine);

    if (!b) {
        return NULL;
    }

    CloseHandle (pi.hThread);
    return pi.hProcess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_GROWBUF     "GrowBuffer"

//
// Strings
//

// None

//
// Constants
//

#define DEFAULT_GROW_SIZE 8192

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

#ifdef DEBUG

DWORD g_GbCurrActiveAlloc = 0;
DWORD g_GbCurrUsedAlloc = 0;
DWORD g_GbMaxActiveAlloc = 0;
DWORD g_GbMaxUsedAlloc = 0;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
#ifdef DEBUG
        GrowBuf->StatEnd = 0;
#endif
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Realloc failed"));
            return NULL;
        }

#ifdef DEBUG
        if (GrowBuf->Buf != NewBuffer) {
            DEBUGMSG ((
                DBG_WARNING,
                "GbGrow: Realloc caused growbuffer to move %u bytes to new location; "
                    "any pointers inside old buffer are now invalid",
                GrowBuf->Size
                ));

            if (GrowBuf->Size > 32767) {
                TRACKDUMP();
            }
        }
#endif

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

#ifdef DEBUG
    GrowBuf->StatEnd = GrowBuf->End;
    g_GbCurrActiveAlloc += GrowBuf->Size;
    if (g_GbMaxActiveAlloc < g_GbCurrActiveAlloc) {
        g_GbMaxActiveAlloc = g_GbCurrActiveAlloc;
    }
    g_GbCurrUsedAlloc += GrowBuf->StatEnd;
    if (g_GbMaxUsedAlloc < g_GbCurrUsedAlloc) {
        g_GbMaxUsedAlloc = g_GbCurrUsedAlloc;
    }
#endif

    return NewBuffer;
}


VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GbGrow (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GbGrow (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GbGrow (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID Ptr
    )
{
    PCVOID *p;

    p = (PVOID *) GbGrow (GrowBuf, sizeof (PVOID));
    if (!p) {
        return FALSE;
    }

    *p = Ptr;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGbAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGbAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT)((UBINT) EndPlusOne - (UBINT) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGbCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGbCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}

BOOL
RealGbCopyQuotedStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringA (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (CHAR));
    if (!Buf) {
        return FALSE;
    }

    *((CHAR *)(Buf)) = '\"';
    CopyMemory (Buf + sizeof (CHAR), String, Size);
    *((CHAR *)(Buf + Size)) = '\"';
    *((CHAR *)(Buf + Size + sizeof (CHAR))) = 0;
    return TRUE;
}


BOOL
RealGbCopyQuotedStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SizeOfStringW (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (WCHAR));
    if (!Buf) {
        return FALSE;
    }

    *((WCHAR *)(Buf)) = L'\"';
    CopyMemory (Buf + sizeof (WCHAR), String, Size);
    *((WCHAR *)(Buf + Size)) = L'\"';
    *((WCHAR *)(Buf + Size + sizeof (WCHAR))) = 0;
    return TRUE;
}


#ifdef DEBUG

VOID
GbDumpStatistics (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "Grow buffers usage:\nPeak   : Usable:%-8d Used:%-8d\nCurrent: Usable:%-8d Leak:%-8d",
        g_GbMaxActiveAlloc,
        g_GbMaxUsedAlloc,
        g_GbCurrActiveAlloc,
        g_GbCurrUsedAlloc
        ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    BOOL CaseSensitive;
    PMHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    PBUCKETITEM DelayedDelete;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  if all strings should be stored and compared in lower-case
                  only

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    PMHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PmCreateNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    PmDisableTracking (pool);

    hashTable = (PHASHTABLESTRUCT) PmGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->CaseSensitive = CaseSensitive;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PmEmptyPool (table->Pool);
        PmDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is already lower case
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.
  PrevBucketItem    - Receives the previous bucket item

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        (void) CharLowerA (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        (void) CharLowerW (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  BufferEnd        - Specifies the end of the string buffer, which may be longer
                     than all entries in the hash table, or it may be shorter.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is in lower-case, FALSE otherwise.
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.  If pHtFindPrefix does not find a match,
                     this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        if (!dupStr) {
            return NULL;
        }

        StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
        CharLowerA (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = _mbsdec2 (String, BufferEnd);
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        if (!dupStr) {
            return NULL;
        }

        StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
        CharLowerW (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable        - Specifies the handle to the hash table, as returned from
                     AllocateHashTable.
  String           - Specifies the string to add to the table
  ExtraData        - Specifies the source binary data to be copied to the hash
                     table entry
  AlreadyLowercase - Specifies TRUE String is in all lowercase

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        CharLowerA (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        CharLowerW (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


VOID
pRemoveHashItem (
    IN      PHASHTABLESTRUCT Table,
    IN      UINT BucketNum,
    IN      PBUCKETITEM PrevItem,
    IN      PBUCKETITEM ItemToDelete
    )
{
    if (!PrevItem) {
        MYASSERT (Table->Bucket[BucketNum] == ItemToDelete);
        Table->Bucket[BucketNum] = ItemToDelete->Next;
    } else {
        PrevItem->Next = ItemToDelete->Next;
    }

    if (ItemToDelete->PrevLink) {
        ItemToDelete->PrevLink->NextLink = ItemToDelete->NextLink;
    } else {
        Table->FirstLink = ItemToDelete->Next;
    }

    if (ItemToDelete->NextLink) {
        ItemToDelete->NextLink->PrevLink = ItemToDelete->PrevLink;
    } else {
        Table->LastLink = ItemToDelete->PrevLink;
    }

    if (ItemToDelete->Locked) {
        ItemToDelete->Next = Table->DelayedDelete;
        Table->DelayedDelete = ItemToDelete;
    } else {
        PmReleaseMemory (Table->Pool, ItemToDelete);
    }
}


BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    if (!Item) {
        return FALSE;
    }

    //
    // Find prev bucket item
    //

    if (table->Unicode) {
        unicodeStr = HtGetStringFromItemW (Item);
        MYASSERT (unicodeStr);

        thisItem = pHtFindStringW (
                        HashTable,
                        unicodeStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    } else {
        ansiStr = HtGetStringFromItemA (Item);
        MYASSERT (ansiStr);

        thisItem = pHtFindStringA (
                        HashTable,
                        ansiStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    }

    MYASSERT (Item == thisItem);

    if (Item != thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}


BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete UNICODE table with ANSI api"));
        return FALSE;
    }

    thisItem = pHtFindStringA (
                    HashTable,
                    AnsiString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete ANSI table with UNICODE api"));
        return FALSE;
    }

    thisItem = pHtFindStringW (
                    HashTable,
                    UnicodeString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if the String is in lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringA (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringW (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  BufferEnd        - Specifies the end of the buffer for String
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if String is in all lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetExtraData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraDataBuffer
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable       - Specifies the handle to the hash table
  Index           - Specifies the offset as returned from HtFindStringEx or
                    HtAddStringEx
  ExtraDataBuffer - Receives the extra data

Return Value:

  TRUE if ExtraDataBuffer was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraDataBuffer,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


VOID
AbortHashTableEnumA (
    IN      PHASHTABLE_ENUMA EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM nextItem;
    PBUCKETITEM prevItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PmReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));
}


VOID
AbortHashTableEnumW (
    IN      PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM prevItem;
    PBUCKETITEM nextItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PmReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumA (&e);
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumW (&e);
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\objstr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.c

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_OBJSTR      "ObjStr"

//
// Strings
//

#define S_OBJSTR        "ObjStr"

//
// Constants
//

#define OBJSTR_NODE_BEGINA          '\025'
#define OBJSTR_NODE_BEGINW          L'\025'

#define OBJSTR_NODE_TERMA           '\\'
#define OBJSTR_NODE_TERMW           L'\\'

#define OBJSTR_NODE_LEAF_SEPA       '\020'
#define OBJSTR_NODE_LEAF_SEPW       L'\020'

#define OBJSTR_LEAF_BEGINA          '\005'
#define OBJSTR_LEAF_BEGINW          L'\005'

//
// Macros
//

#define pObjStrAllocateMemory(Size)   PmGetMemory (g_ObjStrPool, Size)

#define pObjStrFreeMemory(Buffer)     if (/*lint --e(774)*/Buffer) PmReleaseMemory (g_ObjStrPool, Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_ObjStrPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
ObsInitialize (
    VOID
    )

/*++

Routine Description:

    ObsInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_ObjStrPool = PmCreateNamedPool (S_OBJSTR);
    return g_ObjStrPool != NULL;
}


VOID
ObsTerminate (
    VOID
    )

/*++

Routine Description:

    ObsTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_ObjStrPool) {
        PmDestroyPool (g_ObjStrPool);
        g_ObjStrPool = NULL;
    }
}


/*++

Routine Description:

    pExtractStringAB is a private function that creates a new string in the given pool,
    using a source string and a limit to copy up to.

Arguments:

    Start - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

PSTR
pExtractStringABA (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      PMHANDLE Pool
    )
{
    PSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (CHAR));
    StringCopyABA (p, Start, End);
    return p;
}


PWSTR
pExtractStringABW (
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      PMHANDLE Pool
    )
{
    PWSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (WCHAR));
    StringCopyABW (p, Start, End);
    return p;
}


/*++

Routine Description:

    ObsFree frees the given object from the private pool

Arguments:

    EncodedObject - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}


VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}

BOOL
ObsEncodeStringExA (
    PSTR Destination,
    PCSTR Source,
    PCSTR CharsToEncode
    )
{
    MBCHAR ch;

    if (!CharsToEncode) {
        CharsToEncode = EscapedCharsA;
    }

    while (*Source) {
        ch = _mbsnextc (Source);
        if (_mbschr (CharsToEncode, ch)) {
            *Destination = '^';
            Destination ++;
        }
        // now copy the multibyte character
        if (IsLeadByte (Source)) {
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsEncodeStringExW (
    PWSTR Destination,
    PCWSTR Source,
    PCWSTR CharsToEncode
    )
{
    if (!CharsToEncode) {
        CharsToEncode = EscapedCharsW;
    }

    while (*Source) {
        if (wcschr (CharsToEncode, *Source)) {
            *Destination = L'^';
            Destination ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((_mbsnextc (Source) == '^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            // now copy the multibyte character
            if (IsLeadByte (Source)) {
                *Destination = *Source;
                Destination ++;
                Source ++;
            }
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((*Source == L'^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}


PCSTR
ObsFindNonEncodedCharInEncodedStringA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    MBCHAR ch;

    while (*String) {
        ch = _mbsnextc (String);

        if (ch == '^') {
            String++;
        } else if (ch == Char) {
            return String;
        }

        String = _mbsinc (String);
    }

    return NULL;
}


PCWSTR
ObsFindNonEncodedCharInEncodedStringW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    WCHAR ch;

    while (*String) {
        ch = *String;

        if (ch == L'^') {
            String++;
        } else if (ch == Char) {
            return String;
        }

        String++;
    }

    return NULL;
}


/*++

Routine Description:

    ObsSplitObjectStringEx splits the given encoded object into components: node and
    leaf. Strings are allocated from the given pool

Arguments:

    EncodedObject - Specifies the source object string
    DecodedNode - Receives the decoded node part; optional
    DecodedLeaf - Receives the decoded leaf part; optional
    Pool - Specifies the pool to use for allocation; optional; if not specified,
           the module pool will be used and ObsFree needs to be called for them
           to be freed

Return Value:

    TRUE if the source object has a legal format and it has been split into components

--*/

BOOL
RealObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PCSTR* DecodedNode,         OPTIONAL
    OUT     PCSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCSTR currStr = EncodedObject;
    PCSTR end;
    PCSTR oneBack;
    PCSTR next;
    MBCHAR ch;
    BOOL middle = FALSE;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    if (DecodedNode) {
        *DecodedNode = NULL;
    }
    if (DecodedLeaf) {
        *DecodedLeaf = NULL;
    }

    for (;;) {

        ch = _mbsnextc (currStr);

        if (!middle && ch == OBJSTR_NODE_BEGINA) {

            //
            // Find the end of node
            //

            currStr++;
            end = ObsFindNonEncodedCharInEncodedStringA (currStr, OBJSTR_NODE_LEAF_SEPA);

            next = end;
            MYASSERT (next);
            if (*next) {
                next++;
            }

            if (end > currStr) {
                oneBack = _mbsdec (currStr, end);
                if (_mbsnextc (oneBack) == '\\') {
                    end = oneBack;
                }
            }

            if (DecodedNode) {
                //
                // Extract the string into a pool
                //

                *DecodedNode = pExtractStringABA (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringA ((PSTR)(*DecodedNode), *DecodedNode);
                }
            }

            //
            // Continue on to leaf portion
            //

            currStr = next;
            middle = TRUE;

        } else if (ch == OBJSTR_LEAF_BEGINA) {

            //
            // Find the end of leaf
            //

            currStr++;
            end = GetEndOfStringA (currStr);

            if (DecodedLeaf) {
                //
                // Extract the string into a pool
                //

                *DecodedLeaf = pExtractStringABA (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringA ((PSTR)(*DecodedLeaf), *DecodedLeaf);
                }
            }

            //
            // Done
            //

            break;

        } else if (ch == 0 && middle) {

            //
            // Either no leaf or empty string
            //

            break;

        } else if (!middle && ch == OBJSTR_NODE_LEAF_SEPA) {

            middle = TRUE;
            currStr++;

        } else {
            //
            // Syntax error
            //

            DEBUGMSGA ((DBG_ERROR, "%s is an invalid string encoding", EncodedObject));

            if (DecodedNode && *DecodedNode) {
                ObsFreeA (*DecodedNode);
                *DecodedNode = NULL;
            }

            if (DecodedLeaf && *DecodedLeaf) {
                ObsFreeA (*DecodedLeaf);
                *DecodedLeaf = NULL;
            }

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
RealObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PCWSTR* DecodedNode,         OPTIONAL
    OUT     PCWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,               OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCWSTR currStr = EncodedObject;
    PCWSTR end;
    PCWSTR oneBack;
    PCWSTR next;
    WCHAR ch;
    BOOL middle = FALSE;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    if (DecodedNode) {
        *DecodedNode = NULL;
    }
    if (DecodedLeaf) {
        *DecodedLeaf = NULL;
    }

    for (;;) {

        ch = *currStr;

        if (!middle && ch == OBJSTR_NODE_BEGINA) {

            //
            // Find the end of node
            //

            currStr++;
            end = ObsFindNonEncodedCharInEncodedStringW (currStr, OBJSTR_NODE_LEAF_SEPA);

            next = end;
            MYASSERT (next);
            if (*next) {
                next++;
            }

            if (end > currStr) {
                oneBack = end - 1;
                if (*oneBack == L'\\') {
                    end = oneBack;
                }
            }

            if (DecodedNode) {
                //
                // Extract the string into a pool
                //

                *DecodedNode = pExtractStringABW (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringW ((PWSTR)(*DecodedNode), *DecodedNode);
                }
            }

            //
            // Continue on to leaf portion
            //

            currStr = next;
            middle = TRUE;

        } else if (ch == OBJSTR_LEAF_BEGINA) {

            //
            // Find the end of leaf
            //

            currStr++;
            end = GetEndOfStringW (currStr);

            if (DecodedLeaf) {
                //
                // Extract the string into a pool
                //

                *DecodedLeaf = pExtractStringABW (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringW ((PWSTR)(*DecodedLeaf), *DecodedLeaf);
                }
            }

            //
            // Done
            //

            break;

        } else if (ch == 0 && middle) {

            //
            // Either no leaf or empty string
            //

            break;

        } else if (!middle && ch == OBJSTR_NODE_LEAF_SEPW) {

            middle = TRUE;
            currStr++;

        } else {
            //
            // Syntax error
            //

            DEBUGMSGW ((DBG_ERROR, "%s is an invalid string encoding", EncodedObject));

            if (DecodedNode && *DecodedNode) {
                ObsFreeW (*DecodedNode);
                *DecodedNode = NULL;
            }

            if (DecodedLeaf && *DecodedLeaf) {
                ObsFreeW (*DecodedLeaf);
                *DecodedLeaf = NULL;
            }

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ObsHasNodeA (
    IN      PCSTR EncodedObject
    )
{
    return *EncodedObject == OBJSTR_NODE_BEGINA;
}


BOOL
ObsHasNodeW (
    IN      PCWSTR EncodedObject
    )
{
    return *EncodedObject == OBJSTR_NODE_BEGINW;
}


PCSTR
ObsGetLeafPortionOfEncodedStringA (
    IN      PCSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringA (EncodedObject, OBJSTR_LEAF_BEGINA);
}


PCWSTR
ObsGetLeafPortionOfEncodedStringW (
    IN      PCWSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringW (EncodedObject, OBJSTR_LEAF_BEGINW);
}


PCSTR
ObsGetNodeLeafDividerA (
    IN      PCSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringA (EncodedObject, OBJSTR_NODE_LEAF_SEPA);
}


PCWSTR
ObsGetNodeLeafDividerW (
    IN      PCWSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringW (EncodedObject, OBJSTR_NODE_LEAF_SEPW);
}


/*++

Routine Description:

    ObsBuildEncodedObjectStringEx builds an encoded object from components: node and
    leaf. The string is allocated from the module's pool

Arguments:

    DecodedNode - Specifies the decoded node part
    DecodedLeaf - Specifies the decoded leaf part; optional
    EncodeObject - Specifies TRUE if the resulting object needs to be encoded using
                   encoding rules
    Partial - Specifies TRUE if the node/leaf separator should not be added.  In this
              case, DecodedLeaf must be NULL.

Return Value:

    Pointer to the newly created object string

--*/

PSTR
RealObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,      OPTIONAL
    IN      PCSTR DecodedLeaf,      OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PSTR result;
    PSTR p;
    UINT size;

    //
    // at most, one byte char will be expanded to 2 bytes (2 times)
    //
    if (EncodeObject) {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPA);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINA);
            size += ByteCountA (DecodedNode) * 2;
            size += DWSIZEOF(OBJSTR_NODE_TERMA);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINA);
            size += ByteCountA (DecodedLeaf) * 2;
        }

        size += DWSIZEOF(CHAR);

        //
        // Build encoded string
        //

        result = (PSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINA;

            ObsEncodeStringA (p, DecodedNode);
            p = GetEndOfStringA (p);

            if (p == (result + 1) || _mbsnextc (_mbsdec (result, p)) != OBJSTR_NODE_TERMA) {
                *p++ = OBJSTR_NODE_TERMA;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPA;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINA;
            ObsEncodeStringA (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    } else {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPA);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINA);
            size += ByteCountA (DecodedNode);
            size += DWSIZEOF(OBJSTR_NODE_TERMA);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINA);
            size += ByteCountA (DecodedLeaf);
        }

        size += DWSIZEOF(CHAR);

        //
        // Build non-encoded string
        //

        result = (PSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINA;
            *p = 0;

            p = StringCatA (p, DecodedNode);

            if (p == (result + 1) || _mbsnextc (_mbsdec (result, p)) != OBJSTR_NODE_TERMA) {
                *p++ = OBJSTR_NODE_TERMA;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPA;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINA;
            StringCopyA (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    }

    return result;
}


PWSTR
RealObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,     OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PWSTR result;
    PWSTR p;
    UINT size;

    //
    // at most, one byte char will be expanded to 2 bytes (2 times)
    //
    if (EncodeObject) {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPW);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINW);
            size += ByteCountW (DecodedNode) * 2;
            size += DWSIZEOF(OBJSTR_NODE_TERMW);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINW);
            size += ByteCountW (DecodedLeaf) * 2;
        }

        size += DWSIZEOF(WCHAR);

        //
        // Build encoded string
        //

        result = (PWSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINW;

            ObsEncodeStringW (p, DecodedNode);
            p = GetEndOfStringW (p);

            if (p == (result + 1) || *(p - 1) != OBJSTR_NODE_TERMW) {
                *p++ = OBJSTR_NODE_TERMW;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPW;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINW;
            ObsEncodeStringW (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    } else {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPW);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINW);
            size += ByteCountW (DecodedNode);
            size += DWSIZEOF(OBJSTR_NODE_TERMW);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINW);
            size += ByteCountW (DecodedLeaf);
        }

        size += DWSIZEOF(WCHAR);

        //
        // Build non-encoded string
        //

        result = (PWSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINW;
            *p = 0;

            p = StringCatW (p, DecodedNode);

            if (p == (result + 1) || *(p - 1) != OBJSTR_NODE_TERMW) {
                *p++ = OBJSTR_NODE_TERMW;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPW;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINW;
            StringCopyW (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    }

    return result;
}


/*++

Routine Description:

    RealObsCreateParsedPatternEx parses the given object into an internal format for quick
    pattern matching

Arguments:

    EncodedObject - Specifies the source object string

Return Value:

    A pointer to the newly created structure or NULL if the object was invalid

--*/

POBSPARSEDPATTERNA
RealObsCreateParsedPatternExA (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    POBSPARSEDPATTERNA ospp;
    PSTR decodedNode;
    PSTR decodedLeaf;
    PCSTR p;
    PCSTR root;
    PSTR encodedStr;
    PSTR decodedStr;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = g_ObjStrPool;
    }

    ospp = PmGetMemory (pool, DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNA));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;
    ospp->Pool = pool;

    MYASSERT (decodedNode);
    if (*decodedNode) {
        if (!GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
    } else {
        ospp->MinNodeLevel = 1;
        ospp->MaxNodeLevel = NODE_LEVEL_MAX;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    if (*decodedNode) {
        ospp->NodePattern = CreateParsedPatternExA (Pool, decodedNode);
        if (!ospp->NodePattern) {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                EncodedObject
                ));
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
        if (ospp->NodePattern->PatternCount > 1) {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                EncodedObject
                ));
            DestroyParsedPatternA (ospp->NodePattern);
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }

        root = ParsedPatternGetRootA (ospp->NodePattern);
        if (root) {
            //
            // extract the real root part
            //
            if (ParsedPatternIsExactMatchA (ospp->NodePattern)) {
                ospp->Flags |= OBSPF_EXACTNODE;
                // the ExactRoot needs to be case sensitive, we rely on root to give
                // us the size but we extract it from decodedNode
                ospp->ExactRootBytes = ByteCountA (root);
                ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (CHAR));
                CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                ospp->ExactRoot [ospp->ExactRootBytes / sizeof (CHAR)] = 0;
                ospp->MaxSubLevel = 0;
            } else {
                p = FindLastWackA (root);
                if (p) {
                    //
                    // exact root specified
                    // if the last wack is actually the last character or is followed by star(s),
                    // optimize the matching by setting some flags
                    //
                    if (*(p + 1) == 0) {
                        if (ParsedPatternIsRootPlusStarA (ospp->NodePattern)) {
                            ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                        }
                    }
                    if (MakePrimaryRootEndWithWack && p == _mbschr (root, '\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                    // the ExactRoot needs to be case sensitive, we rely on root to give
                    // us the size but we extract it from decodedNode
                    ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
                    decodedStr = AllocPathStringA (ospp->ExactRootBytes / sizeof (CHAR) + 1);
					encodedStr = AllocPathStringA (2 * ospp->ExactRootBytes / sizeof (CHAR) + 1);
                    CopyMemory (decodedStr, root, ospp->ExactRootBytes);
					decodedStr [ospp->ExactRootBytes / sizeof (CHAR)] = 0;
                    ObsEncodeStringA (encodedStr, decodedStr);
					ospp->ExactRootBytes = SizeOfStringA (encodedStr) - sizeof (CHAR);
                    ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (CHAR));
                    CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                    FreePathStringA (encodedStr);
                    FreePathStringA (decodedStr);
                    ospp->ExactRoot [ospp->ExactRootBytes / sizeof (CHAR)] = 0;

				}
            }
        } else if (ParsedPatternIsOptionalA (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_OPTIONALNODE;
        }
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternExA (Pool, decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                DestroyParsedPatternA (ospp->LeafPattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->LeafPattern = CreateParsedPatternExA (Pool, decodedLeaf);
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = PmDuplicateStringA (pool, decodedLeaf);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


POBSPARSEDPATTERNW
RealObsCreateParsedPatternExW (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    POBSPARSEDPATTERNW ospp;
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    PCWSTR p;
    PCWSTR root;
    PWSTR encodedStr;
    PWSTR decodedStr;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = g_ObjStrPool;
    }

    ospp = PmGetMemory (pool, DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNW));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;
    ospp->Pool = pool;

    MYASSERT (decodedNode);
    if (*decodedNode) {
        if (!GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            pObjStrFreeMemory (ospp);
            return NULL;
        }
    } else {
        ospp->MinNodeLevel = 1;
        ospp->MaxNodeLevel = NODE_LEVEL_MAX;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    if (*decodedNode) {
        ospp->NodePattern = CreateParsedPatternExW (Pool, decodedNode);
        if (!ospp->NodePattern) {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                EncodedObject
                ));
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
        if (ospp->NodePattern->PatternCount > 1) {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                EncodedObject
                ));
            DestroyParsedPatternW (ospp->NodePattern);
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }

        root = ParsedPatternGetRootW (ospp->NodePattern);
        if (root) {
            //
            // extract the real root part
            //
            if (ParsedPatternIsExactMatchW (ospp->NodePattern)) {
                ospp->Flags |= OBSPF_EXACTNODE;
                // the ExactRoot needs to be case sensitive, we rely on root to give
                // us the size but we extract it from decodedNode
                ospp->ExactRootBytes = ByteCountW (root);
                ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (WCHAR));
                CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                ospp->ExactRoot [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                ospp->MaxSubLevel = 0;
            } else {
                p = FindLastWackW (root);
                if (p) {
                    //
                    // exact root specified
                    // if the last wack is actually the last character or is followed by star(s),
                    // optimize the matching by setting some flags
                    //
                    if (*(p + 1) == 0) {
                        if (ParsedPatternIsRootPlusStarW (ospp->NodePattern)) {
                            ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                        }
                    }
                    if (MakePrimaryRootEndWithWack && p == wcschr (root, L'\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                    // the ExactRoot needs to be case sensitive, we rely on root to give
                    // us the size but we extract it from decodedNode
                    ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
                    decodedStr = AllocPathStringW (ospp->ExactRootBytes / sizeof (WCHAR) + 1);
					encodedStr = AllocPathStringW (2 * ospp->ExactRootBytes / sizeof (WCHAR) + 1);
                    CopyMemory (decodedStr, root, ospp->ExactRootBytes);
                    decodedStr [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                    ObsEncodeStringW (encodedStr, decodedStr);
					ospp->ExactRootBytes = SizeOfStringW (encodedStr) - sizeof (WCHAR);
                    ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (WCHAR));
                    CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                    FreePathStringW (encodedStr);
                    FreePathStringW (decodedStr);
                    ospp->ExactRoot [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                }
            }
        } else if (ParsedPatternIsOptionalW (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_OPTIONALNODE;
        }
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternExW (Pool, decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                DestroyParsedPatternW (ospp->LeafPattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->LeafPattern = CreateParsedPatternExW (Pool, decodedLeaf);
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = PmDuplicateStringW (pool, decodedLeaf);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


/*++

Routine Description:

    ObsDestroyParsedPattern destroys the given structure, freeing resources

Arguments:

    ParsedPattern - Specifies the parsed pattern structure

Return Value:

    none

--*/

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternA (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternA (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->Leaf);
        }
        if (ParsedPattern->ExactRoot) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->ExactRoot);
        }
        PmReleaseMemory (ParsedPattern->Pool, ParsedPattern);
    }
}


VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternW (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternW (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->Leaf);
        }
        if (ParsedPattern->ExactRoot) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->ExactRoot);
        }
        PmReleaseMemory (ParsedPattern->Pool, ParsedPattern);
    }
}


/*++

Routine Description:

    ObsParsedPatternMatch tests the given object against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    EncodedObject - Specifies the object string to test against the pattern

Return Value:

    TRUE if the string matches the pattern

--*/

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, TRUE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExA (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, TRUE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExW (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsParsedPatternMatchEx tests the given object, given by its components,
    against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((ParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPatternA (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternA (ParsedPattern->LeafPattern, Leaf);
}

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,                        OPTIONAL
    IN      PCWSTR Leaf                         OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((ParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPatternW (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternW (ParsedPattern->LeafPattern, Leaf);
}


/*++

Routine Description:

    ObsPatternMatch tests an object string against a pattern object string

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    CHAR dummy[] = "";
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExA (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABA (opNode, osNode, GetEndOfStringA (osNode));
                } else {
                    b = IsPatternMatchExABA (opNode, dummy, GetEndOfStringA (dummy));
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABA (opLeaf, osLeaf, GetEndOfStringA (osLeaf));
                    } else {
                        b = IsPatternMatchExABA (opLeaf, dummy, GetEndOfStringA (dummy));
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    WCHAR dummy[] = L"";
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExW (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABW (opNode, osNode, GetEndOfStringW (osNode));
                } else {
                    b = IsPatternMatchExABW (opNode, dummy, GetEndOfStringW (dummy));
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABW (opLeaf, osLeaf, GetEndOfStringW (osLeaf));
                    } else {
                        b = IsPatternMatchExABW (opLeaf, dummy, GetEndOfStringW (dummy));
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

/*++

Routine Description:

    ObsIsPatternContained compares two patterns to see if one of them is
    included in the other. Both patterns may contain any of the following
    expressions:

Arguments:

    Container - Specifies the container pattern
    Contained - Specifies the contained pattern

Return Value:

    TRUE if Contained is contained in Container

--*/

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExA (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExA (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExA (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Container string: %s", Container));

    return b;
}

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExW (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExW (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExW (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Container string: %s", Container));

    return b;
}


/*++

Routine Description:

    ObsGetPatternLevels gets the minimum and maximum levels of a string that would
    match the given pattern.

Arguments:

    ObjectPattern - Specifies the pattern
    MinLevel - Receives the minimum possible level; the root has level 1
    MaxLevel - Receives the maximum possible level; the root has level 1

Return Value:

    TRUE if the pattern was correct and computing was done; FALSE otherwise

--*/

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,
    OUT     PDWORD MaxLevel
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsPatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternA (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternA (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternW (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternW (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif


//
// Includes
//

#include "utilsp.h"

#define DBG_POOLMEM "Poolmem"

//
// Strings
//

// None

//
// Constants
//

//
// Tree Memory Allocation structure.
//

#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32

//
// Macros
//

// None

//
// Types
//

typedef struct _PMBLOCK PMBLOCK, *PPMBLOCK;

struct _PMBLOCK {
    UINT_PTR Index;         // Tracks into RawMemory.
    SIZE_T Size;            // the size in bytes of RawMemory.
    PPMBLOCK NextBlock;     // A pointer to the next block in the pool chain.
    PPMBLOCK PrevBlock;     // A pointer to the prev block in the pool chain.
    DWORD UseCount;         // The number of allocations currently referring
                            // to this block.
    PBYTE RawMemory;        // The actual bytes of allocable memory in this block.
};
typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD DogTag;           // A signature to ensure validity.
    SIZE_T Size;
    PALLOCATION Next;       // The next allocation in the list.
    PALLOCATION Prev;       // The previous allocation in the list.
#endif

    PPMBLOCK ParentBlock;   // A reference to the block from which this allocation
                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPMBLOCK PoolHead;                  // The active memory block in this pool.
    SIZE_T MinimumBlockSize;            // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR Name[MAX_POOL_NAME];
    SIZE_T TotalAllocationRequestBytes;
    SIZE_T CurrentAllocationSize;
    SIZE_T MaxAllocationSize;
    SIZE_T CurrentlyAllocatedMemory;
    SIZE_T MaximumAllocatedMemory;
    UINT NumAllocationRequests;
    UINT NumFreeRequests;
    UINT NumBlockFrees;
    UINT NumBlockClears;
    UINT NumBlockAllocations;

    PALLOCATION AllocationList;         // A linked list of all of the allocations active in the
                                        // pool.
    FREESTATE FreeCalled;               // A state variable indicating that PoolMemReleaseMemory()
                                        // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;

//
// Globals
//

#ifdef DEBUG
DWORD g_PmDisplayed;
DWORD g_PmNotDisplayed;

UINT g_PoolCurrPools = 0;
SIZE_T g_PoolCurrTotalAlloc = 0;
SIZE_T g_PoolCurrActiveAlloc = 0;
SIZE_T g_PoolCurrUsedAlloc = 0;
UINT g_PoolMaxPools = 0;
SIZE_T g_PoolMaxTotalAlloc = 0;
SIZE_T g_PoolMaxActiveAlloc = 0;
SIZE_T g_PoolMaxUsedAlloc = 0;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



BOOL
pPmAddMemory (
    IN  PMHANDLE Handle,
    IN  SIZE_T Size
    )
/*++

Routine Description:

    pPmAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PmCreatePool and PmGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE allocedMemory;
    PPMBLOCK newBlock;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    SIZE_T sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(PMBLOCK) > poolHeader->MinimumBlockSize) {
        sizeNeeded = Size + sizeof(PMBLOCK);
    }
    else {
        sizeNeeded = poolHeader->MinimumBlockSize;
    }
    MYASSERT (g_TrackFile);
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

#ifdef DEBUG
        g_PoolCurrTotalAlloc += sizeNeeded;
        if (g_PoolMaxTotalAlloc < g_PoolCurrTotalAlloc) {
            g_PoolMaxTotalAlloc = g_PoolCurrTotalAlloc;
        }
        g_PoolCurrActiveAlloc += (sizeNeeded - sizeof(PMBLOCK));
        if (g_PoolMaxActiveAlloc < g_PoolCurrActiveAlloc) {
            g_PoolMaxActiveAlloc = g_PoolCurrActiveAlloc;
        }
#endif

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock = (PPMBLOCK) allocedMemory;
        newBlock->Size = sizeNeeded - sizeof(PMBLOCK);
        newBlock->RawMemory = allocedMemory + sizeof(PMBLOCK);
        newBlock->Index = 0;
        newBlock->UseCount = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader->PoolHead) {
            poolHeader->PoolHead->PrevBlock = newBlock;
        }
        newBlock->NextBlock = poolHeader->PoolHead;
        newBlock->PrevBlock = NULL;
        poolHeader->PoolHead = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader->CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader->MaximumAllocatedMemory =
            max(poolHeader->MaximumAllocatedMemory,poolHeader->CurrentlyAllocatedMemory);

        poolHeader->NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


PMHANDLE
RealPmCreatePoolEx (
    IN      DWORD BlockSize     OPTIONAL
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid PMHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

#ifdef DEBUG
        g_PoolCurrTotalAlloc += sizeof(POOLHEADER);
        if (g_PoolMaxTotalAlloc < g_PoolCurrTotalAlloc) {
            g_PoolMaxTotalAlloc = g_PoolCurrTotalAlloc;
        }
#endif

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header->MinimumBlockSize = BlockSize?BlockSize:POOLMEMORYBLOCKSIZE;
        header->PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header->TotalAllocationRequestBytes = 0;
        header->CurrentAllocationSize = 0;
        header->MaxAllocationSize = 0;
        header->CurrentlyAllocatedMemory = 0;
        header->MaximumAllocatedMemory = 0;
        header->NumAllocationRequests = 0;
        header->NumFreeRequests = 0;
        header->NumBlockFrees = 0;
        header->NumBlockClears = 0;
        header->NumBlockAllocations = 0;
        header->Name[0] = 0;

#endif

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPmAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);

#ifdef DEBUG
            g_PoolCurrTotalAlloc -= sizeof(POOLHEADER);
#endif

            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PmNotDisplayed =  12;
        g_PmDisplayed =     24;

        if (ableToAddMemory) {
            header->AllocationList = NULL;  //lint !e613
            header->FreeCalled = FREE_NOT_CALLED;   //lint !e613
        }
#endif

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

#ifdef DEBUG
    if (header) {
        g_PoolCurrPools ++;
        if (g_PoolMaxPools < g_PoolCurrPools) {
            g_PoolMaxPools = g_PoolCurrPools;
        }
    }
#endif

    return (PMHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION p,cur;

    if (PoolHeader->FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader->AllocationList;

    while (p) {

        cur = p;
        p = p->Next;

        g_PoolCurrUsedAlloc -= cur->Size;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader->AllocationList = NULL;
#endif
}


VOID
PmEmptyPool (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    if (!Handle) {
        return;
    }

    EnterCriticalSection (&g_PmCs);

    __try {

        poolHeader->PoolHead->UseCount = 0;
        poolHeader->PoolHead->Index = 0;

#ifdef DEBUG
        poolHeader->NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

}



VOID
PmSetMinimumGrowthSize (
    IN PMHANDLE Handle,
    IN SIZE_T Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader->MinimumBlockSize = max(Size,0);
}


VOID
PmDestroyPool (
    PMHANDLE Handle
    )
/*++

Routine Description:

    PmDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid PMHANDLE.

Return Value:

    None.

--*/
{
    PPMBLOCK nextBlock;
    PPMBLOCK blockToFree;
    PPOOLHEADER poolHeader;


    if (!Handle) {
        return;
    }

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader->TotalAllocationRequestBytes)) / poolHeader->NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader->Name[0] ? poolHeader->Name : "[Unnamed Pool]",
            FloatWorkaround,
            poolHeader->MaxAllocationSize,
            poolHeader->CurrentlyAllocatedMemory,
            poolHeader->MaximumAllocatedMemory,
            poolHeader->NumAllocationRequests,
            poolHeader->NumBlockAllocations,
            poolHeader->NumFreeRequests,
            poolHeader->NumBlockFrees,
            poolHeader->NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }

#endif

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader-> PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;

#ifdef DEBUG
        g_PoolCurrTotalAlloc -= (blockToFree->Size + sizeof(PMBLOCK));
        g_PoolCurrActiveAlloc -= blockToFree->Size;
#endif

        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //

#ifdef DEBUG
    g_PoolCurrTotalAlloc -= sizeof (POOLHEADER);
    g_PoolCurrPools --;
#endif

    MemFree(g_hHeap,0,poolHeader);

}

PVOID
RealPmGetMemory (
    IN PMHANDLE Handle,
    IN SIZE_T Size,
    IN DWORD AlignSize
    )

/*++

Routine Description:

    RealPmGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL haveEnoughMemory = TRUE;
    PVOID rMemory = NULL;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    PPMBLOCK currentBlock;
    PALLOCATION allocation;
    SIZE_T sizeNeeded;
    UINT_PTR padLength;

    MYASSERT(poolHeader != NULL);
    MYASSERT(Size);

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader->PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader->CurrentAllocationSize += Size;
        poolHeader->MaxAllocationSize = max(poolHeader->MaxAllocationSize,poolHeader->CurrentAllocationSize);
        poolHeader->NumAllocationRequests++;
        poolHeader->TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock->Size - currentBlock->Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPmAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader->PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (UINT_PTR) currentBlock + sizeof(PMBLOCK)
                    + currentBlock->Index + sizeof(ALLOCATION);
                currentBlock->Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            allocation = (PALLOCATION) &(currentBlock->RawMemory[currentBlock->Index]);
            allocation->ParentBlock = currentBlock;


#ifdef DEBUG
            //
            // Track this memory.
            //
            allocation->DogTag = VALIDDOGTAG;
            allocation->Size = Size;
            allocation->Next = poolHeader->AllocationList;
            allocation->Prev = NULL;

            if (poolHeader->AllocationList) {
                poolHeader->AllocationList->Prev = allocation;
            }

            poolHeader->AllocationList = allocation;

            if (poolHeader->FreeCalled != WHO_CARES) {

                g_PoolCurrUsedAlloc += Size;
                if (g_PoolMaxUsedAlloc < g_PoolCurrUsedAlloc) {
                    g_PoolMaxUsedAlloc = g_PoolCurrUsedAlloc;
                }

                DebugRegisterAllocationEx (
                    POOLMEM_POINTER,
                    allocation,
                    g_TrackFile,
                    g_TrackLine,
                    g_TrackAlloc
                    );

            }
#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock->Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

    return rMemory;
}

VOID
PmReleaseMemory (
    IN PMHANDLE Handle,
    IN PCVOID Memory
    )
/*++

Routine Description:

    PmReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION allocation;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader->NumFreeRequests++;  //lint !e613
        poolHeader->CurrentAllocationSize -= allocation->Size;

#endif




#ifdef DEBUG

        if (poolHeader->FreeCalled == FREE_NOT_CALLED) {    //lint !e613
            poolHeader->FreeCalled = FREE_CALLED;   //lint !e613
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation->DogTag != VALIDDOGTAG) {
            if (allocation->DogTag == FREEDOGTAG) {
                DEBUGMSG((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);   //lint !e506
            }

            __leave;

        } else {
            allocation->DogTag = FREEDOGTAG;
        }

        if (allocation->Next) {
            allocation->Next->Prev = allocation->Prev;
        }

        if (poolHeader->AllocationList == allocation) { //lint !e613
            poolHeader->AllocationList = allocation->Next;  //lint !e613
        } else {

            allocation->Prev->Next = allocation->Next;
        }

        if (poolHeader->FreeCalled != WHO_CARES) {  //lint !e613

            g_PoolCurrUsedAlloc -= allocation->Size;

            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation->ParentBlock == NULL) {
            DEBUGMSG((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation->ParentBlock->UseCount--;




        if (allocation->ParentBlock->UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation->ParentBlock != poolHeader->PoolHead) {  //lint !e613
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader->NumBlockFrees++;    //lint !e613
                poolHeader->CurrentlyAllocatedMemory -=
                    allocation->ParentBlock->Size + sizeof(PMBLOCK);    //lint !e613


#endif

                if (allocation->ParentBlock->NextBlock) {
                    allocation->ParentBlock->NextBlock->PrevBlock =
                        allocation->ParentBlock->PrevBlock;
                }
                allocation->ParentBlock->PrevBlock->NextBlock =
                    allocation->ParentBlock->NextBlock;

#ifdef DEBUG
                g_PoolCurrTotalAlloc -= (allocation->ParentBlock->Size + sizeof(PMBLOCK));
                g_PoolCurrActiveAlloc -= allocation->ParentBlock->Size;
#endif

                MemFree(g_hHeap,0,allocation->ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation->ParentBlock->Index = 0;
                allocation->ParentBlock = NULL;

#ifdef DEBUG
                poolHeader->NumBlockClears++;   //lint !e613
#endif

            }
        }
        else {
            allocation->ParentBlock = NULL;

        }

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

}


#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPoolEx (
    IN      PCSTR Name,
    IN      DWORD BlockSize     OPTIONAL
    )
{
    PMHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = RealPmCreatePoolEx (BlockSize);
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        StringCopyByteCountA (poolHeader->Name, Name, MAX_POOL_NAME);
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    )
{
    PSTR rString = (PSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringA (rString) + 1;    //lint !e613
    }
    size = (rString - MultiSzToCopy + 1) * sizeof(CHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    )
{
    PWSTR rString = (PWSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringW (rString) + 1;
    }
    size = (rString - MultiSzToCopy + 1) * sizeof(WCHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}



#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);
    poolHeader->FreeCalled = WHO_CARES;
}

VOID
PmDumpStatistics (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "Pools usage:\nPeak   : Pools:%-3d Total:%-8d Usable:%-8d Used:%-8d\nCurrent: Pools:%-3d Total:%-8d Usable:%-8d Leak:%-8d",
        g_PoolMaxPools,
        g_PoolMaxTotalAlloc,
        g_PoolMaxActiveAlloc,
        g_PoolMaxUsedAlloc,
        g_PoolCurrPools,
        g_PoolCurrTotalAlloc,
        g_PoolCurrActiveAlloc,
        g_PoolCurrUsedAlloc
        ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\strmap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm)   05-Jun-2000     Added multi table capability

    Jim Schmidt (jimschm)   08-May-2000     Improved replacement routines and
                                            added consistent filtering and
                                            extra data option

    Jim Schmidt (jimschm)   18-Aug-1998     Redesigned to fix two bugs, made
                                            A & W versions

--*/

//
// Includes
//

#include "pch.h"

//
// Strings
//

// None

//
// Constants
//

#define CHARNODE_SINGLE_BYTE            0x0000
#define CHARNODE_DOUBLE_BYTE            0x0001
#define CHARNODE_REQUIRE_WACK_OR_NUL    0x0002

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilters,
    IN      BOOL UsesExtraData
    )

/*++

Routine Description:

  CreateStringMapping allocates a string mapping data structure and
  initializes it. Callers can enable filter callbacks, extra data support, or
  both. The mapping structure contains either CHARNODE elements, or
  CHARNODEEX elements, depending on the UsesFilters or UsesExtraData flag.

Arguments:

  UsesFilters   - Specifies TRUE to enable filter callbacks. If enabled,
                  those who add string pairs must specify the filter callback
                  (each search/replace pair has its own callback)
  UsesExtraData - Specifies TRUE to associate extra data with the string
                  mapping pair.

Return Value:

  A handle to the string mapping structure, or NULL if a structure could not
  be created.

--*/

{
    PMHANDLE Pool;
    PMAPSTRUCT Map;

    Pool = PmCreateNamedPool ("String Mapping");
    MYASSERT (Pool);

    Map = (PMAPSTRUCT) PmGetAlignedMemory (Pool, sizeof (MAPSTRUCT));
    MYASSERT (Map);

    ZeroMemory (Map, sizeof (MAPSTRUCT));
    Map->Pool = Pool;

    Map->UsesExNode = UsesFilters|UsesExtraData;
    Map->UsesFilter = UsesFilters;
    Map->UsesExtraData = UsesExtraData;

    return Map;
}

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    )
{
    if (Map) {
        PmEmptyPool (Map->Pool);
        PmDestroyPool (Map->Pool);
        // Map is no longer valid
    }
}

PCHARNODE
pFindCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char
    )
{
    PCHARNODE Node;

    if (!PrevNode) {
        Node = Map->FirstLevelRoot;
    } else {
        Node = PrevNode->NextLevel;
    }

    while (Node) {
        if (Node->Char == Char) {
            return Node;
        }
        Node = Node->NextPeer;
    }

    return NULL;
}

PCHARNODE
pAddCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char,
    IN      WORD Flags
    )
{
    PCHARNODE Node;
    PCHARNODEEX exNode;

    if (Map->UsesExNode) {
        exNode = PmGetAlignedMemory (Map->Pool, sizeof (CHARNODEEX));
        Node = (PCHARNODE) exNode;
        MYASSERT (Node);
        ZeroMemory (exNode, sizeof (CHARNODEEX));
    } else {
        Node = PmGetAlignedMemory (Map->Pool, sizeof (CHARNODE));
        MYASSERT (Node);
        ZeroMemory (Node, sizeof (CHARNODE));
    }

    Node->Char = Char;
    Node->Flags = Flags;

    if (PrevNode) {
        Node->NextPeer = PrevNode->NextLevel;
        PrevNode->NextLevel = Node;
    } else {
        Node->NextPeer = Map->FirstLevelRoot;
        Map->FirstLevelRoot = Node;
    }

    return Node;
}


VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PSTR OldCopy;
    PSTR NewCopy;
    PCSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PmDuplicateStringA (Map->Pool, Old);
    NewCopy = PmDuplicateStringA (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerA (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    for (Prev = NULL, p = OldCopy ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);
        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;
    }

    for ( ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);

        nodeFlags |= (WORD) (IsLeadByte (p) ? CHARNODE_DOUBLE_BYTE : CHARNODE_SINGLE_BYTE);
        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
    }

    if (Prev) {
        StringCopyA (OldCopy, Old);
        Prev->OriginalStr = (PVOID) OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountA (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PWSTR OldCopy;
    PWSTR NewCopy;
    PCWSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PmDuplicateStringW (Map->Pool, Old);
    NewCopy = PmDuplicateStringW (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerW (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    Prev = NULL;
    p = OldCopy;
    while (w = *p) {        // intentional assignment optimization

        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;

        p++;
    }

    while (w = *p) {        // intentional assignment optimization

        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
        p++;
    }

    if (Prev) {
        StringCopyW (OldCopy, Old);
        Prev->OriginalStr = OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountW (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


PCSTR
pFindReplacementStringInOneMapA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    WORD Char;
    PCSTR OrgSource;
    PCSTR newString = NULL;
    INT newStringSizeInBytes = 0;
    PCHARNODEEX exNode;
    BOOL replacementFound;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Char = (WORD) _mbsnextc (Source);

        Node = pFindCharNode (Map, Node, Char);

        if (Node) {
            //
            // Advance string pointer
            //

            if (Node->Flags & CHARNODE_DOUBLE_BYTE) {
                Source += 2;
            } else {
                Source++;
            }

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && _mbsnextc (Source) != '\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Ansi.BeginningOfMatch = OrgSource;
                        Data->Ansi.OldSubString = (PCSTR) Node->OriginalStr;
                        Data->Ansi.NewSubString = newString;
                        Data->Ansi.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Ansi.NewSubString;
                            newStringSizeInBytes = Data->Ansi.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {
        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCSTR
pFindReplacementStringA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapA (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


PCWSTR
pFindReplacementStringInOneMapW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    PCWSTR OrgSource;
    PCWSTR newString = NULL;
    INT newStringSizeInBytes;
    BOOL replacementFound;
    PCHARNODEEX exNode;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Node = pFindCharNode (Map, Node, *Source);

        if (Node) {
            //
            // Advance string pointer
            //

            Source++;

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && *Source != L'\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCWSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Unicode.BeginningOfMatch = OrgSource;
                        Data->Unicode.OldSubString = (PCWSTR) Node->OriginalStr;
                        Data->Unicode.NewSubString = newString;
                        Data->Unicode.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Unicode.NewSubString;
                            newStringSizeInBytes = Data->Unicode.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {

        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCWSTR
pFindReplacementStringW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCWSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapW (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )

/*++

Routine Description:

  MappingSearchAndReplaceEx performs a search/replace operation based on the
  specified string mapping. The replace can be in-place or to another buffer.

Arguments:

  MapArray          - Specifies an array of string mapping tables that holds
                      zero or more search/replace pairs
  MapArrayCount     - Specifies the number of mapping tables in MapArray
  SrcBuffer         - Specifies the source string that might contain one or
                      more search strings
  Buffer            - Specifies the outbound buffer. This arg can be the same
                      as SrcBuffer.
  InboundBytes      - Specifies the number of bytes in SrcBuffer to process,
                      or 0 to process a nul-terminated string in SrcBuffer.
                      If InboundBytes is specified, it must point to the nul
                      terminator of SrcBuffer.
  OutbountBytesPtr  - Receives the number of bytes that Buffer contains,
                      excluding the nul terminator.
  MaxSizeInBytes    - Specifies the size of Buffer, in bytes.
  Flags             - Specifies flags that control the search/replace:
                            STRMAP_COMPLETE_MATCH_ONLY
                            STRMAP_FIRST_CHAR_MUST_MATCH
                            STRMAP_RETURN_AFTER_FIRST_REPLACE
                            STRMAP_REQUIRE_WACK_OR_NUL
  ExtraDataValue    - Receives the extra data associated with the first search/
                      replace pair.
  EndOfString       - Receives a pointer to the end of the replace string, or
                      the nul pointer when the entire string is processed. The
                      pointer is within the string contained in Buffer.

--*/

{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCSTR lowerCaseSrc;
    PCSTR orgSrc;
    PCSTR lowerSrcPos;
    PCSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PSTR destPos;
    PCSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCSTR replaceString;
    BOOL result = FALSE;
    INT i;
    PCSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountA (SrcBuffer);
    } else {
        i = 0;
        while (i < InboundBytes) {
            if (IsLeadByte (&SrcBuffer[i])) {
                MYASSERT (SrcBuffer[i + 1]);
                i += 2;
            } else {
                i++;
            }
        }

        if (i > InboundBytes) {
            InboundBytes--;
        }
    }

    inboundSize = InboundBytes + sizeof (CHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextA (sizeOfTempBuf);

    CopyMemory ((PSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffA ((PSTR) lowerCaseSrc, InboundBytes / sizeof (CHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (CHAR);

    filterData.UnicodeData = FALSE;
    filterData.Ansi.OriginalString = orgSrc;
    filterData.Ansi.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringA (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {

                //
                // Respect logical dbcs characters
                //

                replaceStringBytes = 0;
                i = 0;

                while (i < destBytesLeft) {
                    MYASSERT (replaceString[i]);

                    if (IsLeadByte (&replaceString[i])) {
                        MYASSERT (replaceString[i + 1]);
                        i += 2;
                    } else {
                        i++;
                    }
                }

                if (i > destBytesLeft) {
                    destBytesLeft--;
                }

                replaceStringBytes = destBytesLeft;

            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (IsLeadByte (orgSrcPos)) {

                //
                // Copy double-byte character
                //

                if (destBytesLeft < sizeof (CHAR) * 2) {
                    break;
                }

                MYASSERT (sizeof (CHAR) * 2 == sizeof (WORD));

                *((PWORD) destPos)++ = *((PWORD) orgSrcPos)++;
                destBytesLeft -= sizeof (WORD);
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + sizeof (WORD));

            } else {

                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }
        }
    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountA (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringA (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringA (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextA (lowerCaseSrc);

    return result;
}


BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCWSTR lowerCaseSrc;
    PCWSTR orgSrc;
    PCWSTR lowerSrcPos;
    PCWSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PWSTR destPos;
    PCWSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCWSTR replaceString;
    BOOL result = FALSE;
    PCWSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountW (SrcBuffer);
    } else {
        InboundBytes = (InboundBytes / sizeof (WCHAR)) * sizeof (WCHAR);
    }


    inboundSize = InboundBytes + sizeof (WCHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextW (sizeOfTempBuf);

    CopyMemory ((PWSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PWSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffW ((PWSTR) lowerCaseSrc, InboundBytes / sizeof (WCHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCWSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCWSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCWSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (WCHAR);

    filterData.UnicodeData = TRUE;
    filterData.Unicode.OriginalString = orgSrc;
    filterData.Unicode.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringW (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {
                replaceStringBytes = destBytesLeft;
            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PWSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCWSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCWSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (destBytesLeft < sizeof (WCHAR)) {
                break;
            }

            *destPos++ = *orgSrcPos++;
            destBytesLeft -= sizeof (WCHAR);
            lowerSrcPos++;
        }

    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountW (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PWSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringW (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringW (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextW (lowerCaseSrc);

    return result;
}


BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExA (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExW (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    ovidiut     12-Jan-2000 Added GetNodePatternMinMaxLevels,PatternIncludesPattern
    ovidiut     14-Sep-1999 Updated for new coding conventions and Win64 compliance
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"

//
// Includes
//

#include "utilsp.h"

#define DBG_STRINGS     "Strings"

//
// Strings
//

// None

//
// Constants
//

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK           32
#define WACK_REPLACE_CHAR   0x02
#define DWORD_MAX           0xFFFFFFFFu

//
// Macros
//

// None

//
// Types
//

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

//
// Globals
//

BOOL g_LeadByteArray[256];

CHAR EscapedCharsA[] = "?*\020<>,^";
WCHAR EscapedCharsW[] = L"?*\020<>,^";

DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;
DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};
extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PMHANDLE g_TextPool;                     // in main.c
PGROWBUFFER g_LastAllocTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    );

BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//


// This has bugs on JPN systems. We need to terminate the string and then call CharLowerA
// #define OURTOLOWER(l) ((WORD)CharLowerA((PSTR)((WORD)(l))))

MBCHAR
OURTOLOWER (
    MBCHAR ch
    )
{
    CHAR str [3];
    MBCHAR result = 0;

    if (((PBYTE)(&ch))[1]) {
        str [0] = ((PBYTE)(&ch))[1];
        str [1] = ((PBYTE)(&ch))[0];
    } else {
        str [0] = ((PBYTE)(&ch))[0];
        str [1] = 0;
    }
    CharLowerA (str);
    if (str[1]) {
        ((PBYTE)(&result))[0] = str [1];
        ((PBYTE)(&result))[1] = str [0];
    } else {
        ((PBYTE)(&result))[0] = str [0];
    }
    return result;
}

VOID
InitLeadByteTable (
    VOID
    )
{
    INT i;

    g_LeadByteArray[0] = FALSE;

    for (i = 1 ; i < 256 ; i++) {
        g_LeadByteArray[i] = IsDBCSLeadByte ((BYTE) i);
    }
}


/*++

Routine Description:

  StringCopy implements lstrcpyA and a UNICODE version. We don't use the Win32
  api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy

Return Value:

  The pointer to the Destionation's nul terminator.

--*/

PSTR
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    while (*current) {
        *Destination++ = *current++;
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;
    }

    *Destination = 0;
    return Destination;
}


PWSTR
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
    return Destination;
}


/*++

Routine Description:

  StringCopyByteCount implements lstrcpynA and a UNICODE version. We don't
  use the Win32 api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy
  Count       - Specifies the maximum number of bytes to copy, including the
                nul terminator. If Count is zero, then not even a nul
                terminator is written.

Return Value:

  None.

--*/

PSTR
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT Count
    )
{
    PCSTR end;
    PCSTR current;
    PSTR destEnd;

    destEnd = Destination;

    if (Count >= sizeof (CHAR)) {

        current = Source;

        end = (PCSTR) ((PBYTE) Source + Count - sizeof (CHAR));

        while (*current && current < end) {
            *destEnd++ = *current++;
        }

        //
        // If current has data left, we need to make sure a DBCS string
        // is properly terminated.
        //

        if (*current) {

            end = current;
            current--;

            while (current >= Source) {

                if (!IsLeadByte (current)) {
                    //
                    // destEnd is correct
                    //
                    break;
                }

                current--;
            }

            if (!((end - current) & 1)) {
                destEnd--;
            }
        }

        *destEnd = 0;
    }

    return destEnd;
}


PWSTR
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT Count
    )
{
    PCWSTR end;

    if (Count < sizeof (WCHAR)) {
        DEBUGMSG_IF ((
            Count != 0,
            DBG_WHOOPS,
            "Buffer passed to StringCopyByteCountW is a fraction of one character"
            ));

        return Destination;
    }

    end = (PCWSTR) ((PBYTE) Source + Count - sizeof (WCHAR));

    while ((Source < end) && (*Source)){
        *Destination++ = *Source++;
    }

    *Destination = 0;
    return Destination;
}


PSTR
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )

/*++

Routine Description:

  StringCopyByteCountAB copies a string segment into a destination buffer,
  and limits the copy to a maximum buffer size.  The return string is always
  nul-terminated, unless the buffer is too small to even hold a nul character.

Arguments:

  Destination          - Receives the string starting at Start and ending one
                         character before End.
  Start                - Specifies the start of the string.
  End                  - Specifies the first character not to copy.  If End
                         is equal or less than Start, then Destination is set
                         to an empty string (assuming the buffer can hold at
                         least one character)
  MaxBytesToCopyIncNul - Specifies the size of Destination, in bytes, and
                         including the nul terminator.

Return Value:

  A pointer to the destination nul terminator.

--*/

{
    INT width;

#ifdef DEBUG
    PCSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABA: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) ((End - Start + 1) * sizeof (CHAR));

    if (width > sizeof (CHAR)) {
        return StringCopyByteCountA (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (CHAR)) {
        *Destination = 0;
    }

    return Destination;
}

PWSTR
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    INT width;

#ifdef DEBUG
    PCWSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABW: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) ((End - Start + 1) * sizeof (WCHAR));

    if (width > sizeof (WCHAR)) {
        return StringCopyByteCountW (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (WCHAR)) {
        *Destination = 0;
    }

    return Destination;
}



/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (!Pool) {
        Pool = g_TextPool;
    }

    MYASSERT (Pool);
    MYASSERT (CountOfChars);

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    if (text) {
        text [0] = 0;
    }

    return text;
}

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (!Pool) {
        Pool = g_TextPool;
    }

    MYASSERT (Pool);
    MYASSERT (CountOfChars);

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    if (text) {
        text [0] = 0;
    }

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR buf;
    PSTR d;
    PCSTR s;

    buf = AllocTextExA (Pool, CharCountA (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            if (IsLeadByte (s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR buf;
    PWSTR d;
    PCWSTR s;

    buf = AllocTextExW (Pool, CharCountW (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR buf;
    PSTR end;
    PSTR d;
    PCSTR s;

    buf = DuplicateTextExA (
              Pool,
              String1,
              CharCountA (String2) + ExtraChars + (CenterString ? CharCountA (CenterString) : 0),
              &end
              );

    MYASSERT (buf);

    d = end;

    if (CenterString) {
        s = CenterString;
        while (*s) {
            if (IsLeadByte (s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
    }

    s = String2;
    while (*s) {
        if (IsLeadByte (s)) {
            *d++ = *s++;
        }
        *d++ = *s++;
    }
    *d = 0;

    if (NulChar) {
        *NulChar = d;
    }

    return buf;
}


PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR buf;
    PWSTR end;
    PCWSTR s;
    PWSTR d;

    buf = DuplicateTextExW (
              Pool,
              String1,
              CharCountW (String2) + ExtraChars + (CenterString ? CharCountW(CenterString) : 0),
              &end
              );

    MYASSERT (buf);

    d = end;

    if (CenterString) {
        s = CenterString;
        while (*s) {
            *d++ = *s++;
        }
    }

    s = String2;

    while (*s) {
        *d++ = *s++;
    }
    *d = 0;

    if (NulChar) {
        *NulChar = d;
    }

    return buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN      PCWSTR InString,
    IN      PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    UINT    maxSize             = 0;
    UINT    curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpandEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    //lint -e(671)
                    CopyMemory (newString, rString, (SIZE_T) ((UINT)curSize * sizeof(WCHAR)));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW(nextPercent - source);
                        if (!envName) {
                            errorOccurred = TRUE;
                            __leave;
                        }

                        StringCopyByteCountABW (
                            envName,
                            source + 1,
                            nextPercent,
                            (UINT) ((UBINT)nextPercent - (UBINT)source)
                            );


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PWSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableW(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            } else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextW(size);


                                if ((size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }

                                freeValue = TRUE;
                            }
                        }


                        if (foundValue) {
                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;
                        }
                        else {
                            DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;
                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextW(envName);
                        envName = NULL;
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //

            rString[curSize++] = *source++; //lint !e613

            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}


PSTR
RealExpandEnvironmentTextExA (
    IN      PCSTR InString,
    IN      PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    UINT   maxSize             = 0;
    UINT   curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (rString) {
                    CopyMemory (newString, rString, curSize * sizeof(CHAR));    //lint !e671
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (!IsLeadByte(source) && *source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA(nextPercent - source);
                        StringCopyABA (envName, source+1, nextPercent);


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchA (ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableA(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            }
                            else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextA(size);
                                freeValue = TRUE;

                                if ((size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }
                            }
                        }




                        if (foundValue) {

                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;



                        }
                        else {
                            DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;

                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextA(envName);
                        envName = NULL;


                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(source)) {  //lint !e613
                rString[curSize++] = *source++; //lint !e613
            }
            rString[curSize++] = *source++; //lint !e613


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}



/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  Str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str)
        return Str;

    last = Str;

    while (*Str) {
        last = Str;
        Str = _mbsinc (Str);
    }

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendWackW (
    IN      PWSTR Str
    )
{
    PCWSTR last;

    if (!Str)
        return Str;

    if (*Str) {
        Str = GetEndOfStringW (Str);
        last = Str - 1;
    } else {
        last = Str;
    }

    if (*last != '\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendDosWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\' && *last != ':') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendDosWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\' && *last != L':') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendUncWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendUncWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendPathWackA (
    IN      PSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == '\\' && Str[1] == '\\') {
        return AppendUncWackA (Str);
    }

    return AppendDosWackA (Str);
}


PWSTR
AppendPathWackW (
    IN      PWSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == L'\\' && Str[1] == L'\\') {
        return AppendUncWackW (Str);
    }

    return AppendDosWackW (Str);
}


DWORD
pGetStringsTotalSizeA (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCSTR source;

    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        size += ByteCountA (source) + DWSIZEOF(CHAR);
    }

    return size;
}

DWORD
pGetStringsTotalSizeW (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCWSTR source;

    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        size += ByteCountW (source) + DWSIZEOF(WCHAR);
    }

    return size;
}


PSTR
pJoinPathsInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PSTR end;
    PSTR endMinusOne;
    PCSTR source;
    PCSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            endMinusOne = _mbsdec2 (p, end);
            if (endMinusOne) {
                if (_mbsnextc (source) == '\\') {
                    if (_mbsnextc (endMinusOne) == '\\') {
                        source++;
                    }
                } else {
                    if (_mbsnextc (endMinusOne) != '\\') {
                        *end = '\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatA (end, source);
        }
        counter++;
    }

    return end;
}

PWSTR
pJoinPathsInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    PCWSTR source;
    PCWSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            endMinusOne = end > p ? end - 1 : NULL;
            if (endMinusOne) {
                if (*source == L'\\') {
                    if (*endMinusOne == L'\\') {
                        source++;
                    }
                } else {
                    if (*endMinusOne != L'\\') {
                        *end = L'\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatW (end, source);
        }
        counter++;
    }

    return end;
}


PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pJoinPathsInBufferA (dest, args);
    va_end (args);

    return dest;
}


PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PWSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);
    va_start (args, Pool);
    pJoinPathsInBufferW (dest, args);
    va_end (args);

    return dest;
}


BOOL
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferA (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}

BOOL
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferW (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}


PSTR
pBuildPathInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PCSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            *Buffer++ = '\\';
            *Buffer = 0;
        }
        Buffer = StringCatA (Buffer, source);
        counter++;
    }

    return Buffer;
}

PWSTR
pBuildPathInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PCWSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            *Buffer++ = L'\\';
            *Buffer = 0;
        }
        Buffer = StringCatW (Buffer, source);
        counter++;
    }

    return Buffer;
}


DWORD
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferA (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}

DWORD
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferW (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}


BOOL
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferA (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}

BOOL
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferW (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}


PSTR
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferA (dest, args);
    va_end (args);

    return dest;
}

PWSTR
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PWSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferW (dest, args);
    va_end (args);

    return dest;
}


PSTR
RealAllocPathStringA (
    IN      DWORD Tchars
    )
{
    PSTR str;

    if (Tchars == 0) {
        Tchars = MAX_MBCHAR_PATH;
    }

    str = (PSTR) PmGetAlignedMemory (g_PathsPool, Tchars);

    str [0] = 0;

    return str;
}


PWSTR
RealAllocPathStringW (
    IN      DWORD Tchars
    )
{
    PWSTR str;

    if (Tchars == 0) {
        Tchars = MAX_WCHAR_PATH;
    }

    str = (PWSTR) PmGetAlignedMemory (g_PathsPool, Tchars * sizeof (WCHAR));

    str [0] = 0;

    return str;
}

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR drive[_MAX_DRIVE];
    CHAR dir[_MAX_DIR];
    CHAR fileName[_MAX_FNAME];
    CHAR ext[_MAX_EXT];

    _splitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringA (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringA (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringA (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringA (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fileName[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    _wsplitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringW (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringW (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringW (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringW (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


PSTR
RealDuplicatePathStringA (
    IN      PCSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}


PWSTR
RealDuplicatePathStringW (
    IN      PCWSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariableA ("PATH", NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyA (PathEnum->BufferPtr, AdditionalPath);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (SysDir != NULL) {
        StringCatA (PathEnum->BufferPtr, SysDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (WinDir != NULL) {
        StringCatA (PathEnum->BufferPtr, WinDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringA (PathEnum->BufferPtr);
        GetEnvironmentVariableA ("PATH", currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}


BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    PSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumA (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath = _mbsinc (PathEnum->PtrNextPath);
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathA (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


BOOL
EnumFirstPathExW (
    OUT     PPATH_ENUMW PathEnum,
    IN      PCWSTR AdditionalPath,
    IN      PCWSTR WinDir,
    IN      PCWSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PWSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariableW (L"PATH", NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringW (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringW (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringW (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyW (PathEnum->BufferPtr, AdditionalPath);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (SysDir != NULL) {
        StringCatW (PathEnum->BufferPtr, SysDir);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (WinDir != NULL) {
        StringCatW (PathEnum->BufferPtr, WinDir);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringW (PathEnum->BufferPtr);
        GetEnvironmentVariableW (L"PATH", currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathW (PathEnum);
}


BOOL
EnumNextPathW (
    IN OUT  PPATH_ENUMW PathEnum
    )
{
    PWSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumW (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = wcschr (PathEnum->PtrNextPath, L';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath ++;
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathW (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumW (
    IN OUT  PPATH_ENUMW PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


VOID
FreePathStringExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PSTR) Path);
    }
}


VOID
FreePathStringExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


VOID
PushNewError (DWORD dwError)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

VOID
PushError (VOID)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (VOID)
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

int
GetHexDigit (IN  int c)

{
    if (c >= '0' && c <= '9')
        return (c - '0');

    c = towlower ((wint_t) c);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, or 0 if a syntax error was found.

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, or zero if a syntax error was
  found.

--*/

DWORD
_mbsnum (IN PCSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == '0' && OURTOLOWER (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD
_wcsnum (
    IN PCWSTR szNum
    )

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  StringCat is a lstrcat-type routine. It returns the pointer to the end
  of a string instead of the beginning, is faster, and has the proper types
  to keep lint happy.

Arguments:

  Destination - A pointer to a caller-allocated buffer that may point
                anywhere within the string to append to
  Source      - A pointer to a string that is appended to Destination

Return Value:

  A pointer to the NULL terminator within the Destination string.

--*/

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringA (Destination);

    while (*current) {
        *Destination++ = *current++;    //lint !e613
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;  //lint !e794
    }

    *Destination = 0;   //lint !e794

    return Destination;
}


PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )

{
    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringW (Destination);

    //
    // Copy string
    //

    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (PCSTR mbstrStr, PCSTR mbstrSubStr)

{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               OURTOLOWER ((MBCHAR) _mbsnextc (mbstrSubStrPos)) == OURTOLOWER ((MBCHAR) _mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (PCWSTR wstrStr, PCWSTR wstrSubStr)

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  StringCompareAB compares a string against a string between to string
  pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  end - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and
                  End

  Zero: String matches the string between Start and End identically

  Greater than zero: String is numerically greater than the string between
                     Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbsnextc (String) != _mbsnextc (Start)) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (INT) (_mbsnextc (Start) - _mbsnextc (String));
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    )

/*++

Routine Description:

  StringMatchA is an optimized string compare.  Usually a comparison is used to
  see if two strings are identical, and the numeric releationships aren't
  important. This routine exploits that fact and does a byte-by-byte compare.

Arguments:

  String1 - Specifies the first string to compare
  String2 - Specifies the second string to compare

Return Value:

  TRUE if the strings match identically, FALSE otherwise.

--*/

{
    while (*String1) {
        if (*String1 != *String2) {
            return FALSE;
        }

        String1++;
        String2++;
    }

    if (*String2) {
        return FALSE;
    }

    return TRUE;
}


BOOL
StringMatchABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )

/*++

Routine Description:

  StringMatchABA is an optimized string compare.  Usually a comparison is
  used to see if two strings are identical, and the numeric releationships
  aren't important. This routine exploits that fact and does a byte-by-byte
  compare.

Arguments:

  String - Specifies the first string to compare
  Start  - Specifies the beginning of the second string to compare
  End    - Specifies the end of the second string to compare (points to one
           character beyond the last valid character of the second string)

Return Value:

  TRUE if the strings match identically, FALSE otherwise.  If End is equal
  or less than Start, the return value is always TRUE.

--*/

{
    while (*String && Start < End) {
        if (*String != *Start) {
            return FALSE;
        }

        String++;
        Start++;
    }

    if (Start < End && *Start) {
        return FALSE;
    }

    return TRUE;
}


INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (OURTOLOWER ((INT)(_mbsnextc (String))) != OURTOLOWER ((INT)(_mbsnextc (Start)))) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (OURTOLOWER ((INT)(_mbsnextc (Start))) - OURTOLOWER ((INT)(_mbsnextc (String))));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



VOID
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR) c;
    } else {
        if (!IsLeadByte (Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *p_szRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  p_szRule   - A pointer to a pointer; a caller-allocated buffer that
               holds the rule string.
  p_bFromHex - A pointer to a caller-allocated BOOL that receives TRUE
               when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *p_bFromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = _mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = _mbsinc (StartPtr);
    return _mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )

{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (szRule), possibly
  encoded with hex-specified character values (~xx~).  The output

  string contains unencoded characters.

Arguments:

  szRule    - A caller-allocated buffer, big enough to hold an
              unencoded rule.  szRule can be equal to szEncRule.
  szEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to szRule.

--*/


PSTR
DecodeRuleCharsA (PSTR mbstrRule, PCSTR mbstrEncRule)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    } while (c);

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (PWSTR wstrRule, PCWSTR wstrEncRule)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    } while (c);

    return wstrOrgRule;
}


PSTR
DecodeRuleCharsABA (PSTR mbstrRule, PCSTR mbstrEncRule, PCSTR End)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (PWSTR wstrRule, PCWSTR wstrEncRule, PCWSTR End)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  szEncRule - A caller-allocated buffer, big enough to hold an
              encoded rule.  szEncRule CAN NOT be equal to szRule.
              One way to calculate a max buffer size for szEncRule
              is to use the following code:

                  allocsize = SizeOfString (szRule) * 6;

              In the worst case, each character in szRule will take
              six single-byte characters in szEncRule.  In the normal
              case, szEncRule will only be a few bytes bigger than
              szRule.

  szRule    - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsExA (
    PSTR mbstrEncRule,
    PCSTR mbstrRule,
    PCSTR mbstrEncChars     OPTIONAL
    )

{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;

    if (!mbstrEncChars) {
        mbstrEncChars = mbstrExclusions;
    }

    mbstrOrgRule = mbstrEncRule;

    while (*mbstrRule)  {
        c = _mbsnextc (mbstrRule);

        if (!_ismbcprint (c) || _mbschr (mbstrEncChars, c)) {

            // Escape unprintable or excluded character
            wsprintfA (mbstrEncRule, "~%X~", c);
            mbstrEncRule = GetEndOfStringA (mbstrEncRule);
            mbstrRule = _mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;  //lint !e613

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsExW (
    PWSTR wstrEncRule,
    PCWSTR wstrRule,
    PCWSTR wstrEncChars    OPTIONAL
    )
{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;

    if (!wstrEncChars) {
        wstrEncChars = wstrExclusions;
    }

    wstrOrgRule = wstrEncRule;

    while (c = *wstrRule)   {   //lint !e720
        if (!iswprint (c) || wcschr (wstrEncChars, c)) {
            wsprintfW (wstrEncRule, L"~%X~", c);
            wstrEncRule = GetEndOfStringW (wstrEncRule);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


int
_mbsisprint (PCSTR mbstrStr)

{
    while (*mbstrStr && _ismbcprint ((MBCHAR) _mbsnextc (mbstrStr))) {
        mbstrStr = _mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


int
_wcsisprint (PCWSTR wstrStr)

{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (PCSTR mbstrStr)

{
    while (_ismbcspace ((MBCHAR) _mbsnextc (mbstrStr)))
        mbstrStr = _mbsinc (mbstrStr);

    return mbstrStr;
}


PCWSTR
SkipSpaceW (PCWSTR wstrStr)

{
    while (iswspace (*wstrStr))
        wstrStr++;

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {    //lint !e613
        Str = _mbsdec2 (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) _mbsnextc(Str))) {
            return Str;
        }

    } while (Str = _mbsdec2(StrBase, Str)); //lint !e720

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses isspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) _mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = _mbsinc (Str);
    }

    if (LastNonSpace) {
        *_mbsinc (LastNonSpace) = 0;
    } else {
        *OrgStr = 0;
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        *(LastNonSpace + 1) = 0;
    } else {
        *OrgStr = 0;
    }
}



/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (strStr));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}

BOOL
IsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    MBCHAR chSrc, chPat;

    while (*Contained) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (Contained));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (Container));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Container)) == '*') {
                Container = _mbsinc (Container);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Container))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedA (_mbsinc (Container), Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained = _mbsinc (Contained);
            continue;
        } else if (chPat == '?') {
            if (chSrc == '*') {
                return FALSE;
            }
        } else {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Contained = _mbsinc (Contained);
        Container = _mbsinc (Container);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Container) == '*') {
        Container = _mbsinc (Container);
    }
    if (_mbsnextc (Container)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    while (*Contained) {

        if (*Container == L'*') {

            // Skip all asterisks that are grouped together
            while (Container[1] == L'*') {
                Container++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!Container[1]) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedW (Container + 1, Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained++;
            continue;
        } else if (*Container == L'?') {
            if (*Contained == L'*') {
                return FALSE;
            }
        } else {
            if (*Container != *Contained) {
                return FALSE;
            }
        }
        Contained++;
        Container++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (*Container == '*') {
        Container++;
    }
    if (*Container) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (Start));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Start)) == '*') {
                Start = _mbsinc (Start);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = _mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = _mbsinc (Start);
        Pattern = _mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Pattern) == '*') {
        Pattern = _mbsinc (Pattern);
    }

    if (_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternA (Handle, String);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternW (Handle, String);

    DestroyParsedPatternW (Handle);

    return b;
}

/*++

Routine Description:

  IsPatternMatchExAB compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}

BOOL
pTestSetsA (
    IN      PCSTR Container,
    IN      PCSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    MBCHAR ch;

    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        ch = _mbsnextc (Contained);
        if (!pTestSetA (ch, Container, NULL)) {
            return FALSE;
        }
        Contained = _mbsinc (Contained);
    }
    return TRUE;
}

BOOL
pTestSetsW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        if (!pTestSetW (*Contained, Container, NULL)) {
            return FALSE;
        }
        Contained ++;
    }
    return TRUE;
}

BOOL
pMatchSegmentA (
    IN      PSEGMENTA Source,
    IN      PSEGMENTA Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (_mbsnextc (Destination->Exact.LowerCasePhrase) != _mbsnextc (Source->Exact.LowerCasePhrase)) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
}

BOOL
pMatchSegmentW (
    IN      PSEGMENTW Source,
    IN      PSEGMENTW Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (*Destination->Exact.LowerCasePhrase != *Source->Exact.LowerCasePhrase) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
}

BOOL
pIsOneParsedPatternContainedA (
    IN      PPATTERNPROPSA Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSA Contained,
    IN      UINT StartContained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTA containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedA (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained,
                    SkipDotWithStar
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            if (SkipDotWithStar) {
                // we allow one dot to be able to match *.* with files without extensions
                if (containerSeg->Type == SEGMENTTYPE_EXACTMATCH) {
                    if (!pTestSetA (
                            _mbsnextc (containerSeg->Exact.LowerCasePhrase),
                            "..",
                            NULL
                            )) {
                        return FALSE;
                    } else {
                        // only one dot allowed
                        SkipDotWithStar = FALSE;
                    }
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
pIsOneParsedPatternContainedW (
    IN      PPATTERNPROPSW Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSW Contained,
    IN      UINT StartContained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTW containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedW (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained,
                    SkipDotWithStar
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            if (SkipDotWithStar) {
                // we allow one dot to be able to match *.* with files without extensions
                if (containerSeg->Type == SEGMENTTYPE_EXACTMATCH) {
                    if (!pTestSetW (
                            *containerSeg->Exact.LowerCasePhrase,
                            L"..",
                            NULL
                            )) {
                        return FALSE;
                    } else {
                        // only one dot allowed
                        SkipDotWithStar = FALSE;
                    }
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedA (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0,
                    SkipDotWithStar
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedW (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0,
                    SkipDotWithStar
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
pDoOneParsedPatternIntersectA (
    IN      PPATTERNPROPSA Pat1,
    IN      UINT StartPat1,
    IN      PPATTERNPROPSA Pat2,
    IN      UINT StartPat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT indexPat1 = StartPat1;
    UINT indexPat2 = StartPat2;
    PSEGMENTA pat1Seg, pat2Seg;

    while ((indexPat1 < Pat1->SegmentCount) && (indexPat2 < Pat2->SegmentCount)) {
        pat1Seg = &Pat1->Segment [indexPat1];
        pat2Seg = &Pat2->Segment [indexPat2];

        if (pat1Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
                indexPat1 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectA (
                    Pat1,
                    indexPat1 + 1,
                    Pat2,
                    indexPat2,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (pat2Seg, pat1Seg)) {
                indexPat2 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectA (
                    Pat1,
                    indexPat1,
                    Pat2,
                    indexPat2 + 1,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat1 ++;
            continue;
        }

        if (pat1Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (pat2Seg, pat1Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
            return FALSE;
        }
        indexPat1 ++;
        indexPat2 ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    if ((indexPat1 < Pat1->SegmentCount) && IgnoreWackAtEnd) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if ((pat1Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchA (pat1Seg->Exact.LowerCasePhrase, "\\"))
            ) {
            indexPat1 ++;
        }
    }
    while (indexPat1 < Pat1->SegmentCount) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if (pat1Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat1 ++;
    }

    if ((indexPat2 < Pat2->SegmentCount) && IgnoreWackAtEnd) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if ((pat2Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchA (pat2Seg->Exact.LowerCasePhrase, "\\"))
            ) {
            indexPat2 ++;
        }
    }
    while (indexPat2 < Pat2->SegmentCount) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if (pat2Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat2 ++;
    }

    return TRUE;
}

BOOL
pDoOneParsedPatternIntersectW (
    IN      PPATTERNPROPSW Pat1,
    IN      UINT StartPat1,
    IN      PPATTERNPROPSW Pat2,
    IN      UINT StartPat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT indexPat1 = StartPat1;
    UINT indexPat2 = StartPat2;
    PSEGMENTW pat1Seg, pat2Seg;

    while ((indexPat1 < Pat1->SegmentCount) && (indexPat2 < Pat2->SegmentCount)) {
        pat1Seg = &Pat1->Segment [indexPat1];
        pat2Seg = &Pat2->Segment [indexPat2];

        if (pat1Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
                indexPat1 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectW (
                    Pat1,
                    indexPat1 + 1,
                    Pat2,
                    indexPat2,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (pat2Seg, pat1Seg)) {
                indexPat2 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectW (
                    Pat1,
                    indexPat1,
                    Pat2,
                    indexPat2 + 1,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat1 ++;
            continue;
        }

        if (pat1Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (pat2Seg, pat1Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
            return FALSE;
        }
        indexPat1 ++;
        indexPat2 ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    if ((indexPat1 < Pat1->SegmentCount) && IgnoreWackAtEnd) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if ((pat1Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchW (pat1Seg->Exact.LowerCasePhrase, L"\\"))
            ) {
            indexPat1 ++;
        }
    }
    while (indexPat1 < Pat1->SegmentCount) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if (pat1Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat1 ++;
    }

    if ((indexPat2 < Pat2->SegmentCount) && IgnoreWackAtEnd) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if ((pat2Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchW (pat2Seg->Exact.LowerCasePhrase, L"\\"))
            ) {
            indexPat2 ++;
        }
    }
    while (indexPat2 < Pat2->SegmentCount) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if (pat2Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat2 ++;
    }

    return TRUE;
}

BOOL
DoExplodedParsedPatternsIntersectExA (
    IN      PPARSEDPATTERNA Pat1,
    IN      PPARSEDPATTERNA Pat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Pat2->PatternCount ; u1++) {

        for (u2 = 0 ; u2 < Pat1->PatternCount ; u2++) {

            b = pDoOneParsedPatternIntersectA (
                    &Pat1->Pattern[u2],
                    0,
                    &Pat2->Pattern[u1],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;

            b = pDoOneParsedPatternIntersectA (
                    &Pat2->Pattern[u1],
                    0,
                    &Pat1->Pattern[u2],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;
        }
    }

    return FALSE;
}

BOOL
DoExplodedParsedPatternsIntersectExW (
    IN      PPARSEDPATTERNW Pat1,
    IN      PPARSEDPATTERNW Pat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Pat2->PatternCount ; u1++) {

        for (u2 = 0 ; u2 < Pat1->PatternCount ; u2++) {

            b = pDoOneParsedPatternIntersectW (
                    &Pat1->Pattern[u2],
                    0,
                    &Pat2->Pattern[u1],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;

            b = pDoOneParsedPatternIntersectW (
                    &Pat2->Pattern[u1],
                    0,
                    &Pat1->Pattern[u2],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;
        }
    }

    return FALSE;
}

PPARSEDPATTERNA
ExplodeParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNA Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNA pattern;
    PPATTERNPROPSA oldProps, newProps;
    PSEGMENTA oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex, byteIndex;
    BOOL result = TRUE;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    __try {

        pattern = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNA));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->ExternalPool = externalPool;
        pattern->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSA)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSA));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        newPropsSize += oldSeg->Wildcard.MaxLen;
                    } else {
                        newPropsSize ++;
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTA)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTA));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    byteIndex = oldSeg->Exact.PhraseBytes;
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(CHAR)
                                                                        );
                            ((PSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, 3 * sizeof(CHAR)
                                                                        );
                            if (IsLeadByte (&oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex])) {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[2] = 0;
                                newSeg->Exact.PhraseBytes = 2;
                            } else {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                                newSeg->Exact.PhraseBytes = 1;
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        oldSegIndex = oldSeg->Wildcard.MaxLen;
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Wildcard.MaxLen = 1;
                            if (oldSeg->Wildcard.IncludeSet) {
                                newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                            }
                            if (oldSeg->Wildcard.ExcludeSet) {
                                newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    } else {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

PPARSEDPATTERNW
ExplodeParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNW Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNW pattern;
    PPATTERNPROPSW oldProps, newProps;
    PSEGMENTW oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex;
    BOOL result = TRUE;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    __try {

        pattern = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNW));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->ExternalPool = externalPool;
        pattern->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSW)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSW));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        newPropsSize += oldSeg->Wildcard.MaxLen;
                    } else {
                        newPropsSize ++;
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTW)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTW));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, 2 * sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [(oldSeg->Exact.PhraseBytes / sizeof(WCHAR)) - oldSegIndex];
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        oldSegIndex = oldSeg->Wildcard.MaxLen;
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Wildcard.MaxLen = 1;
                            if (oldSeg->Wildcard.IncludeSet) {
                                newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                            }
                            if (oldSeg->Wildcard.ExcludeSet) {
                                newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    } else {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

/*++

Routine Description:

  IsPatternContainedEx compares two patterns to see if one of them is
  included in the other. Both patterns may contain any of the following
  expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Container - A container pattern possibly containing wildcards
  Contained - A contained pattern possibly containing wildcards

Return Value:

  TRUE when the second pattern is contained in the first one, FALSE if not.

--*/

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PPARSEDPATTERNA container = NULL, contained = NULL;
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternA (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternA (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternA (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (contained) {
            DestroyParsedPatternA (contained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
        if (container) {
            DestroyParsedPatternA (container);
        }
    }

    return result;
}

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PPARSEDPATTERNW container = NULL, contained = NULL;
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternW (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternW (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternW (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (contained) {
            DestroyParsedPatternW (contained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
        if (container) {
            DestroyParsedPatternW (container);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternA (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternW (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
    }

    return result;
}

/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  buf       - Specifies the grow buffer to add the character to, receives the
              character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (PtrToChar)) {
        Len = 2;
    } else {
        Len = 1;
    }

    p = GbGrow (Buf, Len);
    CopyMemory (p, PtrToChar, (SIZE_T) Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GbGrow (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}

#define BASESTATE_BEGIN             0
#define BASESTATE_END               1
#define BASESTATE_ERROR             2
#define BASESTATE_BEGIN_COMPOUND    3
#define BASESTATE_END_COMPOUND      4
#define BASESTATE_EXAMINE_PATTERN   5
#define BASESTATE_SKIP_PATTERN      6

PCSTR
GetPatternBaseExA (
    IN      PCSTR Pattern,
    IN      BOOL NodePattern
    )
{
    GROWBUFFER resultBuf = INIT_GROWBUFFER;
    UINT state;
    UINT lastWackIdx = 0;
    UINT firstCharIdx = 0;
    BOOL compoundPattern = FALSE;
    MBCHAR ch = 0;
    PSTR result = NULL;

    state = BASESTATE_BEGIN;

    for (;;) {

        switch (state) {

        case BASESTATE_BEGIN:
            if (_mbsnextc (Pattern) == '<') {
                compoundPattern = TRUE;
                state = BASESTATE_BEGIN_COMPOUND;
            } else {
                state = BASESTATE_EXAMINE_PATTERN;
            }
            break;
        case BASESTATE_BEGIN_COMPOUND:
            while (_ismbcspace ((MBCHAR)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                state = BASESTATE_END;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                pAppendCharToGrowBufferA (&resultBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                state = BASESTATE_EXAMINE_PATTERN;
            } else {
                state = BASESTATE_ERROR;
            }
            break;
        case BASESTATE_END_COMPOUND:
            pAppendCharToGrowBufferA (&resultBuf, Pattern);
            Pattern = _mbsinc (Pattern);
            state = BASESTATE_BEGIN_COMPOUND;
            break;
        case BASESTATE_EXAMINE_PATTERN:
            ch = _mbsnextc (Pattern);
            if (ch == '>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            if ((ch == '*') || (ch == '?')) {
                if (NodePattern) {
                    if (resultBuf.Buf) {
                        ((PSTR)resultBuf.Buf) [lastWackIdx / sizeof (CHAR)] = 0;
                    }
                    resultBuf.End = lastWackIdx;
                } else {
                    if (resultBuf.Buf) {
                        ((PSTR)resultBuf.Buf) [firstCharIdx / sizeof (CHAR)] = 0;
                    }
                    resultBuf.End = firstCharIdx;
                    firstCharIdx = 0;
                }
                state = BASESTATE_SKIP_PATTERN;
                break;
            }
            if (!NodePattern && !firstCharIdx) {
                firstCharIdx = resultBuf.End;
            }
            if (ch == '\\') {
                if (NodePattern) {
                    lastWackIdx = resultBuf.End;
                }
            }
            if (ch == '^') {
                pAppendCharToGrowBufferA (&resultBuf, Pattern);
                Pattern = _mbsinc (Pattern);
            }
            pAppendCharToGrowBufferA (&resultBuf, Pattern);
            Pattern = _mbsinc (Pattern);
            break;
        case BASESTATE_SKIP_PATTERN:
            ch = _mbsnextc (Pattern);
            if (ch == '>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            Pattern = _mbsinc (Pattern);
            break;
        }
        if ((state == BASESTATE_END) || (state == BASESTATE_ERROR)) {
            break;
        }
    }
    if (state == BASESTATE_END) {
        if (resultBuf.End) {
            ((PSTR)resultBuf.Buf) [resultBuf.End / sizeof (CHAR)] = 0;
            result = DuplicatePathStringA ((PCSTR)resultBuf.Buf, 0);
        }
    }
    GbFree (&resultBuf);
    return result;
}

PCWSTR
GetPatternBaseExW (
    IN      PCWSTR Pattern,
    IN      BOOL NodePattern
    )
{
    GROWBUFFER resultBuf = INIT_GROWBUFFER;
    UINT state;
    UINT lastWackIdx = 0;
    UINT firstCharIdx = 0;
    BOOL compoundPattern = FALSE;
    WCHAR ch = 0;
    PWSTR result = NULL;

    state = BASESTATE_BEGIN;

    for (;;) {

        switch (state) {

        case BASESTATE_BEGIN:
            if (*Pattern == L'<') {
                compoundPattern = TRUE;
                state = BASESTATE_BEGIN_COMPOUND;
            } else {
                state = BASESTATE_EXAMINE_PATTERN;
            }
            break;
        case BASESTATE_BEGIN_COMPOUND:
            while (*Pattern == L' ') {
                Pattern ++;
            }

            if (*Pattern == 0) {
                state = BASESTATE_END;
                break;
            }

            if (*Pattern == L'<') {
                pAppendCharToGrowBufferW (&resultBuf, Pattern);
                Pattern ++;
                state = BASESTATE_EXAMINE_PATTERN;
            } else {
                state = BASESTATE_ERROR;
            }
            break;
        case BASESTATE_END_COMPOUND:
            pAppendCharToGrowBufferW (&resultBuf, Pattern);
            Pattern ++;
            state = BASESTATE_BEGIN_COMPOUND;
            break;
        case BASESTATE_EXAMINE_PATTERN:
            ch = *Pattern;
            if (ch == L'>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            if ((ch == L'*') || (ch == L'?')) {
                if (NodePattern) {
                    if (resultBuf.Buf) {
                        ((PWSTR)resultBuf.Buf) [lastWackIdx / sizeof (WCHAR)] = 0;
                    }
                    resultBuf.End = lastWackIdx;
                } else {
                    if (resultBuf.Buf) {
                        ((PWSTR)resultBuf.Buf) [firstCharIdx / sizeof (WCHAR)] = 0;
                    }
                    resultBuf.End = firstCharIdx;
                    firstCharIdx = 0;
                }
                state = BASESTATE_SKIP_PATTERN;
                break;
            }
            if (!NodePattern && !firstCharIdx) {
                firstCharIdx = resultBuf.End;
            }
            if (ch == L'\\') {
                if (NodePattern) {
                    lastWackIdx = resultBuf.End;
                }
            }
            if (ch == L'^') {
                pAppendCharToGrowBufferW (&resultBuf, Pattern);
                Pattern ++;
            }
            pAppendCharToGrowBufferW (&resultBuf, Pattern);
            Pattern ++;
            break;
        case BASESTATE_SKIP_PATTERN:
            ch = *Pattern;
            if (ch == L'>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            Pattern ++;
            break;
        }
        if ((state == BASESTATE_END) || (state == BASESTATE_ERROR)) {
            break;
        }
    }
    if (state == BASESTATE_END) {
        if (resultBuf.End) {
            ((PWSTR)resultBuf.Buf) [resultBuf.End / sizeof (WCHAR)] = 0;
            result = DuplicatePathStringW ((PCWSTR)resultBuf.Buf, 0);
        }
    }
    GbFree (&resultBuf);
    return result;
}


/*++

Routine Description:

  RealCreateParsedPatternEx parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
RealCreateParsedPatternExA (
    IN      PMHANDLE Pool,  OPTIONAL
    IN      PCSTR Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    Struct = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (_ismbcspace ((MBCHAR)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                Pattern = _mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GbGrow (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PmGetAlignedMemory (pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = _mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = _mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = _mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = _mbsinc (Pattern);

                if (_mbsnextc (Pattern) == '[') {
                    Pattern = _mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = _mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringA (
                                                pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            CharLowerA ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GbGrow (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && _mbsnextc (LookAhead) == ':') {
                Pattern = _mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringA (
                                                        pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    CharLowerA ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = _mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringA (
                                                        pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    CharLowerA ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = _mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = _mbsinc (SetBegin);

                if (_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = _mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (_mbsnextc (SetBegin) == '^') {
                SetBegin = _mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = _mbsinc (SetBegin);

            if (_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = _mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (_mbsnextc (SetBegin) == '^') {
                    SetBegin = _mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = _mbsinc (SetBegin);
            ch = _mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = _mbsinc (SetBegin);
                    ch = _mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            while (*SetBegin) {
                if (_mbsnextc (SetBegin) == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin)) {
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = _mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) { //lint !e613
                ch = _mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = _mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);   //lint !e794

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        if (!externalPool) {
            PmDestroyPool (Pool);
        }
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = pool;
        Struct->ExternalPool = externalPool;
        Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                sizeof (PATTERNPROPSA)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                    pool,
                                                    sizeof (SEGMENTA)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringA (pool, "");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                            pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = pool;
    Struct->ExternalPool = externalPool;

    GbFree (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
RealCreateParsedPatternExW (
    IN      PMHANDLE Pool,  OPTIONAL
    IN      PCWSTR Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    Struct = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GbGrow (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PmGetAlignedMemory (pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringW (
                                                pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );  //lint !e64
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            CharLowerW ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GbGrow (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringW (
                                                        pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    CharLowerW ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringW (
                                                        pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    CharLowerW ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++; //lint !e613

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++; //lint !e613

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        if (!externalPool) {
            PmDestroyPool (pool);
        }
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = pool;
        Struct->ExternalPool = externalPool;
        Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                sizeof (PATTERNPROPSW)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                    pool,
                                                    sizeof (SEGMENTW)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringW (pool, L"");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                            pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = pool;
    Struct->ExternalPool = externalPool;

    GbFree (&PatternArray);

    return Struct;
}

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount < 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount < 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (CHAR);
    *(PSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
            ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (WCHAR);
    *(PWSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
             ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}


VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    sprintf (String, "0x00000000%08X", Number);
#endif
}

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    swprintf (String, L"0x00000000%08X", Number);
#endif
}

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64u", Number);
#else
    sprintf (String, "%lu", Number);
#endif
}

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64u", Number);
#else
    swprintf (String, L"%lu", Number);
#endif
}

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64d", Number);
#else
    sprintf (String, "%ld", Number);
#endif
}

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64d", Number);
#else
    swprintf (String, L"%ld", Number);
#endif
}

VOID
PrintPattern (
    IN      PCSTR PatStr,
    IN      PPARSEDPATTERNA Struct
    )

/*++

Routine Description:

  PrintPattern is used for debugging the pattern parsing and testing
  functions.

Arguments:

  PatStr - Specifies the original pattern string (which is printed as a
           heading)
  Struct - Specifies the parsed pattern struct

Return Value:

  None.

--*/

{
    CHAR poolStr [sizeof (UBINT) * 2 + 2 + 1];
    UINT u, v;

    printf ("Pattern: %s\n\n", PatStr);

    if (!Struct) {
        printf ("Invalid Pattern\n\n");
        return;
    }

    printf ("PatternCount: %u\n", Struct->PatternCount);
    UBINTtoHexA ((UBINT)Struct->Pool, poolStr);
    printf ("Pool: %s\n", poolStr);

    for (u = 0 ; u < Struct->PatternCount ; u++) {

        printf ("  Segment Count: %u\n", Struct->Pattern[u].SegmentCount);

        for (v = 0 ; v < Struct->Pattern->SegmentCount ; v++) {
            printf ("    Type: ");

            switch (Struct->Pattern[u].Segment[v].Type) {

            case SEGMENTTYPE_EXACTMATCH:
                printf ("SEGMENTTYPE_EXACTMATCH\n");
                printf ("      String: %s\n", Struct->Pattern[u].Segment[v].Exact.LowerCasePhrase);
                printf ("      Bytes: %u\n", Struct->Pattern[u].Segment[v].Exact.PhraseBytes);
                break;

            case SEGMENTTYPE_OPTIONAL:
                printf ("SEGMENTTYPE_OPTIONAL\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;

            case SEGMENTTYPE_REQUIRED:
                printf ("SEGMENTTYPE_REQUIRED\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;
            }   //lint !e744
        }

    }

    printf ("\n");
}



/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (_ismbcspace ((MBCHAR)ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = OURTOLOWER (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);
            HighChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);
            HighChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = _mbsnextc (StringToTest);
                ch2 = _mbsnextc (q);

                ch1 = OURTOLOWER (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!_ismbcspace ((MBCHAR)ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = _mbsinc (q);
                StringToTest = _mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            _mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = _mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = _mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase; //lint !e64

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,   //lint !e64
                            Segment->Wildcard.ExcludeSet
                            )) {    //lint !e64
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    if (!ParsedPattern) {
        return FALSE;
    }

    if (!StringToTest) {
        return FALSE;
    }

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    if (!ParsedPattern) {
        return FALSE;
    }

    if (!StringToTest) {
        return FALSE;
    }

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern && (!ParsedPattern->ExternalPool)) {
        PmEmptyPool (ParsedPattern->Pool);
        PmDestroyPool (ParsedPattern->Pool);
    }
}


VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern && (!ParsedPattern->ExternalPool)) {
        PmEmptyPool (ParsedPattern->Pool);
        PmDestroyPool (ParsedPattern->Pool);
    }
}


/*++

Routine Description:

  DecodeParsedPattern decodes all exact-matches sub-strings of the given pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern.

Return Value:

  None.

--*/

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT u;
    UINT v;
    PSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsA (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountA (phrase);
            }
        }
    }
}


VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT u;
    UINT v;
    PWSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PWSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsW (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountW (phrase);
            }
        }
    }
}


/*++

Routine Description:

  GetParsedPatternMinMaxSize returns the minimum and the maximum size (in bytes)
  of a string that would match the given parsed pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern
  MinSize - Receives the minimum size of a string that would match the pattern
  MaxSize - Receives the maximum size of a string that would match the pattern

Return Value:

  None.

--*/

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}


/*++

Routine Description:

    PatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    )
{
    PPATTERNPROPSA pp1;
    PPATTERNPROPSA pp2;
    PSEGMENTA ps1;
    PSEGMENTA ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGA ((DBG_ERROR, "PatternIncludesPatternA: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchA (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalA (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountA (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalA (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountA (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeA (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeA (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // NTRAID#NTBUG9-153305-2000/08/01-jimschm Not implemented yet
    //
    return FALSE;
}

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    )
{
    PPATTERNPROPSW pp1;
    PPATTERNPROPSW pp2;
    PSEGMENTW ps1;
    PSEGMENTW ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGW ((DBG_ERROR, "PatternIncludesPatternW: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchW (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);   //lint !e64
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalW (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountW (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );  //lint !e64
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalW (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountW (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );  //lint !e64
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeW (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeW (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // NTRAID#NTBUG9-153305-2000/08/01-jimschm  not implemented yet
    //
    return FALSE;
}


VOID
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (sz2)) {
        sz1[1] = sz2[1];
    }

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = _mbsdec2 (str, end);
    if (end && _mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


BOOL
_wcsctrim (
    OUT     PWSTR str,
    IN      WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    PCSTR *ptr, *end, *start;

    if (!String) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }

    start = (PCSTR *) AllocTable->Buf;
    end = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    ptr = end;
    while (ptr >= start) {
        if (*ptr == String) {
            break;
        }
        ptr--;
    }

    //
    // String not found case
    //

    if (ptr < start) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (ptr < end) {
        *ptr = *end;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *ptr;

    ptr = (PCSTR *) GbGrow (GrowBuf, sizeof (PCSTR));
    if (ptr) {
        *ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *ptr, *start, *end;

    if (AllocTable->End) {
        start = (PCSTR *) AllocTable->Buf;
        end = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (ptr = start ; ptr < end ; ptr++) {
            LocalFree ((HLOCAL) (*ptr));
        }
    }

    GbFree (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
RealCreateAllocTable (
    VOID
    )
{
    PGROWBUFFER allocTable;
    GROWBUFFER tempForInit = INIT_GROWBUFFER;

    allocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (allocTable, &tempForInit, sizeof (GROWBUFFER));

    return allocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    OUT     PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/


BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}


VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)((UBINT)Template),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    return NULL;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT)Template,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    return NULL;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    IN      HWND Hwnd,
    IN      PCSTR ArgArray[]
    )
{
    CHAR buffer[512];
    PCSTR parsedMsg;

    GetWindowTextA (Hwnd, buffer, 512);
    parsedMsg = ParseMessageA (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextA (Hwnd, parsedMsg);
        FreeStringResourceA (parsedMsg);
    }
}


VOID
ParseMessageInWndW (
    IN      HWND hwnd,
    IN      PCWSTR ArgArray[]
    )
{
    WCHAR buffer[512];
    PCWSTR parsedMsg;

    GetWindowTextW (hwnd, buffer, 512);
    parsedMsg = ParseMessageW (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextW (hwnd, parsedMsg);
        FreeStringResourceW (parsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  HwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR message;
    PCSTR title;
    int rc;

    message = ParseMessageA ((PSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (HwndOwner, message, title, Flags);

    FreeStringResourceA (message);
    if (title) {
        FreeStringResourceA (title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR message;
    PCWSTR title;
    int rc;

    message = ParseMessageW ((PWSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (HwndOwner, message, title, Flags);

    FreeStringResourceW (message);
    if (title) {
        FreeStringResourceW (title);
    }

    return rc;
}


BOOL
StringReplaceA (
    IN      PSTR Buffer,
    IN      DWORD MaxSize,
    IN      PSTR ReplaceStartPos,
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN      PWSTR Buffer,
    IN      DWORD MaxSize,
    IN      PWSTR ReplaceStartPos,
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = CharCountW(NewString);
    currentStringLength = CharCountW(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for (movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                 movePosition < Buffer + currentStringLength;
                 movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

/*++

Routine Description:

  AddInfSectionToHashTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToHashTableA (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    HASHTABLE ht;
    DWORD reqSize;
    DWORD currentSize = 0;
    PSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //

    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExA (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToHashTableW (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    HASHTABLE ht;
    LONG rc;
    DWORD reqSize;
    DWORD currentSize = 0;
    PWSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //

    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PWSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExW (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = _mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (_mbsnextc (String) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (*String == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    Char = (MBCHAR)OURTOLOWER ((INT)Char);

    count = 0;
    while (*String) {
        if ((MBCHAR) OURTOLOWER ((INT)_mbsnextc (String)) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    Char = towlower (Char);

    count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchBytes;

    count = 0;
    p = SourceString;
    searchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {    //lint !e720
        count++;
        p += searchBytes;
    }

    return count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT SearchChars;

    count = 0;
    p = SourceString;
    SearchChars = CharCountW (SearchString);

    while (p = _wcsistr (p, SearchString)) {    //lint !e720
        count++;
        p += SearchChars;
    }

    return count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountA (SearchString);
    replaceBytes = ByteCountA (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringA (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {    //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyA ((PSTR) dest, (PSTR) p);

    return newString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountW (SearchString);
    replaceBytes = ByteCountW (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringW (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PWSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {   //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyW ((PWSTR) dest, (PWSTR) p);

    return newString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR start, end;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    UINT Pass;
    UINT ArgStrSize;
    UINT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        start = CmdLine;

        // Skip leading space
        while (_ismbcspace ((MBCHAR)(*start))) {
            start++;
        }

        while (*start) {
            // Look for quote mode
            if (*start == '\"') {
                QuoteMode = TRUE;
                start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            end = start;
            while (*end) {
                ch = _mbsnextc (end);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (_ismbcspace ((MBCHAR)ch)) {
                        break;
                    }
                }

                end = _mbsinc (end);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (UINT)((UBINT)end - (UBINT)start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;  //lint !e613
                StringCopyABA (ArgStrEnd, start, end);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);    //lint !e668
                ArgStrEnd++;    //lint !e613
            }

            // Set start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                end = _mbsinc (end);
            }

            start = end;
            while (_ismbcspace ((MBCHAR)(*start))) {
                start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            (UINT)(sizeof (PSTR) * Args + ArgStrSize)
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;  //lint !e613
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}

BOOL
IsStrInMultiSzA (
    IN      PCSTR String,
    IN      PCSTR MultiSz
    )
{
    BOOL result = FALSE;
    MULTISZ_ENUMA multiSzEnum;

    if (EnumFirstMultiSzA (&multiSzEnum, MultiSz)) {
        do {
            if (StringIMatchA (String, multiSzEnum.CurrentString)) {
                result = TRUE;
                break;
            }
        } while (EnumNextMultiSzA (&multiSzEnum));
    }
    return result;
}

BOOL
IsStrInMultiSzW (
    IN      PCWSTR String,
    IN      PCWSTR MultiSz
    )
{
    BOOL result = FALSE;
    MULTISZ_ENUMW multiSzEnum;

    if (EnumFirstMultiSzW (&multiSzEnum, MultiSz)) {
        do {
            if (StringIMatchW (String, multiSzEnum.CurrentString)) {
                result = TRUE;
                break;
            }
        } while (EnumNextMultiSzW (&multiSzEnum));
    }
    return result;
}

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = _mbsdec2 (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    while (ptr > StartStr) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
    }

    return NULL;
}


VOID
ToggleWacksA (
    IN      PSTR Line,
    IN      BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = _mbsinc (p);
        }

    } while (p);
}


VOID
ToggleWacksW (
    IN      PWSTR Line,
    IN      BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _mbsdec2 (FirstChar, LastChar);
    while (NumWacks && (LastChar >= FirstChar)) {
        if (_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = _mbsdec2 (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar >= FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = _mbsinc (PathSeg);
    }
    return numDots;
}


UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MAX_MBCHAR_PATH];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = _mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABA (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    MAX_MBCHAR_PATH
                    );

                FileSpec = _mbsinc (wackPtr);
            } else {
                StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
            }
        } else {
            StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABW (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    (UINT) sizeof (pathSeg)
                    );

                FileSpec = wackPtr + 1;
            } else {
                StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), (UINT) sizeof (pathSeg));
            }
        } else {
            StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), (UINT) sizeof (pathSeg));
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}


VOID
_mbssetchar (
    OUT     PSTR Dest,
    IN      UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)(&Char) + 1);
    }
    else {
        *Dest = (CHAR) Char;
    }
}


/*++

Routine Description:

    FindLastWack finds the position of the last \ in the given string or NULL if none found

Arguments:

    Str - Specifies the string

Return Value:

    Pointer to the last occurence of a \ in the string or NULL

--*/

PCSTR
FindLastWackA (
    IN      PCSTR Str
    )
{
    PCSTR lastWack = NULL;

    if (Str) {
        while ((Str = _mbschr (Str, '\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    )
{
    PCWSTR lastWack = NULL;

    if (Str) {
        while ((Str = wcschr (Str, L'\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


/*++

Routine Description:

    GetNodePatternMinMaxLevels treats the given string pattern as a path with \ as separator
    and computes the min and max levels of the given node; the root has level 1; if a * is
    followed by \ it is treated as a single level (e.g. *\ only enumerates roots)

Arguments:

    NodePattern - Specifies the node as a string pattern
    FormattedNodePattern - Receives the formatted string, eliminating duplicate * and the last \;
                    may be the same as NodePattern
    MinLevel - Receives the minimum level of a node having this pattern
    MaxLevel - Receives the maximum level of a node having this pattern; may be NODE_LEVEL_MAX

Return Value:

    TRUE if NodePattern is a valid pattern and the function succeeded, FALSE otherwise

--*/

#define NODESTATE_BEGIN     0
#define NODESTATE_UNC       1
#define NODESTATE_BEGINSEG  2
#define NODESTATE_INSEG     3
#define NODESTATE_ESCAPED   4
#define NODESTATE_STAR      5
#define NODESTATE_STARONLY  6
#define NODESTATE_INEXPAT   7
#define NODESTATE_QMARK     8

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCSTR nodePattern = NodePattern;
    MBCHAR currCh = 0;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        currCh = _mbsnextc (nodePattern);
        switch (state) {
        case NODESTATE_BEGIN:
            switch (currCh) {
            case '\\':
                state = NODESTATE_UNC;
                break;
            case '*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (currCh) {
            case '\\':
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (currCh) {
            case '\\':
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case '*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            switch (currCh) {
            case '*':
                copyChar = FALSE;
                break;
            case '[':
                state = NODESTATE_INEXPAT;
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            default:
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_INEXPAT:
            // NTRAID#NTBUG9-153307-2000/08/01-jimschm  Min/max parsing needs to be more extensive
            // so we can allow ] in the excluded or included list
            // The syntax checking needs to be quite extensive
            switch (currCh) {
            case ']':
                state = NODESTATE_INSEG;
                break;
            default:
                break;
            }
            break;
        case NODESTATE_STAR:
            switch (currCh) {
            case '*':
                state = NODESTATE_STAR;
                copyChar = FALSE;
                break;
            case '[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_QMARK:
            switch (currCh) {
            case '[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (currCh) {
            case '\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_QMARK;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!_mbschr (EscapedCharsA, currCh)) {
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                if (IsLeadByte (nodePattern)) {
                    *FormattedNode = *nodePattern;
                    FormattedNode ++;
                    nodePattern ++;
                }
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern = _mbsinc (nodePattern);
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCWSTR nodePattern = NodePattern;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        switch (state) {
        case NODESTATE_BEGIN:
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_UNC;
                break;
            case L'*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (*nodePattern) {
            case L'\\':
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case L'*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            switch (*nodePattern) {
            case L'*':
                copyChar = FALSE;
                break;
            case L'[':
                state = NODESTATE_INEXPAT;
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            default:
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_INEXPAT:
            // NTRAID#NTBUG9-153307-2000/08/01-jimschm  Min/max parsing needs to be more extensive
            // so we can allow ] in the excluded or included list
            // The syntax checking needs to be quite extensive
            switch (*nodePattern) {
            case L']':
                state = NODESTATE_INSEG;
                break;
            default:
                break;
            }
            break;
        case NODESTATE_STAR:
            switch (*nodePattern) {
            case L'*':
                state = NODESTATE_STAR;
                copyChar = FALSE;
                break;
            case L'[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_QMARK:
            switch (*nodePattern) {
            case L'[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (*nodePattern) {
            case L'\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_QMARK;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!wcschr (EscapedCharsW, *nodePattern)) {
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern ++;
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

#if 0
//
// PORTBUG Uses memdb max. #if 0'd out for now.
//
PCSTR
ConvertSBtoDB (
    IN      PCSTR RootPath,
    IN      PCSTR FullPath,
    IN      PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && (((DWORD)s - (DWORD)result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, _mbsnextc(p));
            q = _mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, _mbsnextc(p));
        } else {
            ch = _mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = _mbsinc (p);
                if (p1) {
                    ch1 = _mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = _mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = _mbsinc (p);
        s = _mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}

#endif

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == '-') {
        negate = TRUE;
        String++;
    } else if (*String == '+') {
        String++;
    }

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == L'-') {
        negate = TRUE;
        String++;
    } else if (*String == L'+') {
        String++;
    }

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


BOOL
TestBuffer (
    IN      PCBYTE SrcBuff,
    IN      PCBYTE DestBuff,
    IN      UINT Size
    )
{
    while (Size) {
        if (*SrcBuff != *DestBuff) {
            return FALSE;
        }
        SrcBuff ++;
        DestBuff ++;
        Size --;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include <locale.h>
#include "utilsp.h"

extern PMHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
    InitLeadByteTable ();
}

WORD
SetConversionCodePage (
    IN      WORD CodePage
    )
{
    WORD oldCodePage = g_GlobalCodePage;
    g_GlobalCodePage = CodePage;
    return oldCodePage;
}

VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD) GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Chars - Specifies the number of characters, excluding the nul, to
          convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    Size = (Chars + 1) * 3; // maximum for UTF8 encoding

    DbcsStr = (PSTR) PmGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     (g_GlobalCodePage == CP_UTF8)?0:g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,           // wc input count
                     DbcsStr,
                     (INT) Size,
                     NULL,
                     NULL
                     );

    // Report error returns from WideCharToMultiByte
    if (!rc && Chars) {
        PushError();
        PmReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    if (g_GlobalCodePage == CP_UTF8) {
        DbcsStr [rc] = 0;
    } else {
        *CharCountToPointerA (DbcsStr, Chars) = 0;
    }

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Chars     - Specifies the number of multibyte characters, excluding the nul,
              to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = (DWORD)(CharCountToPointerA(StrIn, Chars) - StrIn);

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Chars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PmGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = (DWORD) MultiByteToWideChar (
                                 g_GlobalCodePage,
                                 0,
                                 StrIn,
                                 (INT) StrInBytesToConvert,
                                 UnicodeStr,
                                 (INT) UnicodeStrBufLenBytes
                                 );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Chars) {
        PushError();
        PmReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless	 warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PmReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,               // wc input count
                     StrOut,
                     (INT) Chars * 2,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Chars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = (DWORD)(CharCountToPointerA (StrIn, Chars) - StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) StrInBytesToConvert,
                     StrOut,
                     (INT) StrInBytesToConvert * 2
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) (Bytes / sizeof (WCHAR)),
                     StrOut,
                     (INT) Bytes,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut + rc;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) Bytes,
                     StrOut,
                     (INT) Bytes * 2
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut + rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\utilsp.h ===
#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

//lint -save -e757

extern PCSTR g_OutOfMemoryString;
extern PCSTR g_OutOfMemoryRetry;

extern PMHANDLE g_RegistryApiPool;
extern PMHANDLE g_PathsPool;
extern CRITICAL_SECTION g_PmCs;
extern CRITICAL_SECTION g_MemAllocCs;

VOID
InitLeadByteTable (
    VOID
    );


//lint -restore
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\main\wnd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.c

Abstract:

    Utilities for window management

Author:

    Jim Schmidt (jimschm)   01-Feb-2000

Revision History:


--*/

//
// Includes
//

#include "pch.h"


#define DBG_WND         "Wnd"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTA, *PFINDWINDOW_STRUCTA;

typedef struct {
    PCWSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTW, *PFINDWINDOW_STRUCTW;

//
// Globals
//

static INT g_CursorRefCount = 0;
static HCURSOR g_OldCursor = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
CALLBACK
pEnumWndProcA (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system. It is
  used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCTA variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    CHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTA p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTA) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchA (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGA ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


BOOL
CALLBACK
pEnumWndProcW (
    HWND hwnd,
    LPARAM lParam
    )

{
    WCHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTW p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTW) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGW ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchW (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGW ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


HWND
WndFindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle          OPTIONAL
    )

/*++

Routine Description:

  Finds a window by enumerating all top-level windows, and checking the
  process id. The first one to match the optionally supplied title is used.

Arguments:

  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.
  WindowTitle   - Specifies the name of the window to find.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCTA findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcA, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


HWND
WndFindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    )
{
    FINDWINDOW_STRUCTW findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcW, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

VOID
WndCenterWindow (
    IN      HWND hwnd,
    IN      HWND Parent         OPTIONAL
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


VOID
WndTurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  WndTurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_CursorRefCount == 0) {
        g_OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_CursorRefCount++;
}


VOID
WndTurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  WndTurnOffWaitCursor decrements the wait cursor counter, and if it reaches
  zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_CursorRefCount) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_CursorRefCount--;

        if (!g_CursorRefCount) {
            SetCursor (g_OldCursor);
        }
    }
}


VOID
WndSetWizardButtonsA (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCSTR AlternateFinishText       OPTIONAL
    )
{
    DWORD flags = 0;
    HWND wizardHandle;

    wizardHandle = GetParent (PageHandle);

    if (EnableButtons & FINISH_BUTTON) {

        MYASSERT (!(EnableButtons & CANCEL_BUTTON));
        MYASSERT (!(EnableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & CANCEL_BUTTON));
        MYASSERT (!(DisableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & FINISH_BUTTON));

        EnableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);
        DisableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);

        flags |= PSWIZB_FINISH;
    }

    if (DisableButtons & FINISH_BUTTON) {

        MYASSERT (!(EnableButtons & CANCEL_BUTTON));
        MYASSERT (!(EnableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & CANCEL_BUTTON));
        MYASSERT (!(DisableButtons & NEXT_BUTTON));

        EnableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);
        DisableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);

        flags |= PSWIZB_DISABLEDFINISH;
    }

    if (EnableButtons & NEXT_BUTTON) {
        MYASSERT (!(DisableButtons & NEXT_BUTTON));
        flags |= PSWIZB_NEXT;
    }

    if (EnableButtons & BACK_BUTTON) {
        MYASSERT (!(DisableButtons & BACK_BUTTON));
        flags |= PSWIZB_BACK;
    }

    if (DisableButtons & NEXT_BUTTON) {
        flags &= ~PSWIZB_NEXT;
    }

    if (DisableButtons & BACK_BUTTON) {
        flags &= ~PSWIZB_BACK;
    }

    PropSheet_SetWizButtons (wizardHandle, flags);

    if (EnableButtons & CANCEL_BUTTON) {
        EnableWindow (GetDlgItem (wizardHandle, IDCANCEL), TRUE);
    }

    if (DisableButtons & CANCEL_BUTTON) {
        EnableWindow (GetDlgItem (wizardHandle, IDCANCEL), FALSE);
    }

    if (AlternateFinishText) {
        if (flags & PSWIZB_FINISH) {
            SendMessage (
                wizardHandle,
                PSM_SETFINISHTEXT,
                0,
                (LPARAM) AlternateFinishText
                );
        }
    }

}


VOID
WndSetWizardButtonsW (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCWSTR AlternateFinishText      OPTIONAL
    )
{
    PCSTR ansiText;

    if (AlternateFinishText) {
        ansiText = ConvertWtoA (AlternateFinishText);
        WndSetWizardButtonsA (PageHandle, EnableButtons, DisableButtons, ansiText);
        FreeConvertedStr (ansiText);
    } else {
        WndSetWizardButtonsA (PageHandle, EnableButtons, DisableButtons, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\database.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    database.c

Abstract:

    Routines that manage the memdb database memory

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    calinn     12-Jan-2000  prepare for 5.1 release

--*/

//
// Includes
//

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define MAX_MEMDB_SIZE      0x80000000  //02 GB
#define INIT_BLOCK_SIZE     0x00010000  //64 KB

//
// Types
//

typedef struct {
    HANDLE hFile;
    HANDLE hMap;
    CHAR FileName[MAX_PATH];
    PDATABASE Database;
} DATABASECONTROL, *PDATABASECONTROL;

//
// Globals
//

BOOL g_DatabaseInitialized = FALSE;
DATABASECONTROL g_PermanentDatabaseControl;
DATABASECONTROL g_TemporaryDatabaseControl;
PDATABASE g_CurrentDatabase = NULL;
BYTE g_CurrentDatabaseIndex = DB_NOTHING;
PSTR g_CurrentDatabasePath = NULL;

#ifdef DEBUG

BOOL g_UseDebugStructs = TRUE;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    )
{
    switch (DatabaseIndex) {
    case DB_PERMANENT:
        g_CurrentDatabase = g_PermanentDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_PERMANENT;
        break;
    case DB_TEMPORARY:
        g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_TEMPORARY;
        break;
    default:
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_CurrentDatabase == NULL) {
        SetLastError (ERROR_OPEN_FAILED);
        return FALSE;
    }

    return TRUE;
}

BOOL
pMapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    DatabaseControl->Database = (PDATABASE) MapFileFromHandle (DatabaseControl->hFile, &DatabaseControl->hMap);

    return DatabaseControl->Database != NULL;
}

BOOL
pUnmapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    UnmapFileFromHandle (
        (PBYTE)DatabaseControl->Database,
        DatabaseControl->hMap
        );

    DatabaseControl->hMap = NULL;
    DatabaseControl->Database = NULL;

    return TRUE;
}

BOOL
pGetTempFileName (
    IN OUT  PSTR FileName,
    IN      BOOL TryCurrent
    )
{
    PCHAR a, b;
    CHAR Extension[6];
    UINT Number = 0;

    a = (PCHAR) GetFileNameFromPathA (FileName);
    b = (PCHAR) GetDotExtensionFromPathA (FileName);

    if (!a) {
        a = (PCHAR) GetEndOfStringA (FileName);
    } else if (b && a<b && TryCurrent) {
        //
        // if we have a filename and we want to try the current file...
        //
        if (!DoesFileExistA (FileName)) {
            return TRUE;
        }
    }

    if (b) {
        StringCopyA (Extension, b);
        *b = 0;
    } else {
        b = (PCHAR) GetEndOfStringA (FileName);
        Extension [0] = 0;
    }

    if (a >= b) {       //lint !e613
        a = b;
        *(a++) = 'T';   //lint !e613
    } else {
        a++;            //lint !e613
    }

    if (a+7 == b) {
        b = a;
        while (*b) {
            if (*b < '0' || *b > '9') {
                break;
            }
            b++;
        }

        if (!(*b)) {
            Number = (UINT)atoi(a);
            Number++;
        }
    }

    do {
        if (Number > 9999999) {
            return FALSE;
        }

        wsprintfA (a, "%07lu", Number);
        StringCatA (a, Extension);
        Number++;
        if (!DoesFileExistA (FileName)) {
            return TRUE;
        }
    } while (TRUE);

    return TRUE;
}

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    )
/*++
Routine Description:

    SizeDatabaseBuffer will resize the file that backs up the existent allocated
    memory and will remap the file.

Arguments:

    DatabaseIndex - specifies which database we are talking about
    NewSize - specifies the new size of the buffer

Return Value:

    TRUE if the function succeeded, FALSE if not.

--*/

{
    DWORD bytes;
    BOOL resetCurrentDatabase = FALSE;
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }
    resetCurrentDatabase = (databaseControl->Database == g_CurrentDatabase);

    MYASSERT(databaseControl->hFile);

    if (databaseControl->Database) {
        //
        // if we already have a database, unmap current file from memory.
        //
        if (!pUnmapDatabaseFile (databaseControl)) {
            return FALSE;
        }
    }

    if (SetFilePointer(
            databaseControl->hFile,
            0,
            NULL,
            FILE_BEGIN
            ) == INVALID_SET_FILE_POINTER) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set file pointer"));
        return FALSE;
    }

    if (NewSize) {
        //
        // if size argument is not 0, fix file size indicator at beginning
        //
        if (!WriteFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    } else {
        //
        // if size argument is 0, that means look at first UINT in file
        // which is database->allocsize, and size the file to that size
        //
        if (!ReadFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    }

    // in the next call, we know that NewSize cannot exceed MAX_MEMDB_SIZE
    // which is 2GB (so casting an unsigned to a signed is safe).
    if (!SetSizeOfFile (databaseControl->hFile, (LONGLONG)NewSize)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set size of file"));
        return FALSE;
    }

    //
    // now map file into memory, so everything can use ->Buf for access.
    //
    if (!pMapDatabaseFile(databaseControl)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot map database file to memory"));
        return FALSE;
    }

    MYASSERT(databaseControl->Database->AllocSize == NewSize);

    if (resetCurrentDatabase) {
        SelectDatabase (DatabaseIndex);
    }

    return TRUE;
}

UINT
DatabaseAllocBlock (
    UINT Size
    )

/*++
Routine Description:

    DatabaseAllocBlock allocates a block of memory in the single
    heap of size Size, expanding it if necessary.
    This function may move the database buffer.  Pointers
    into the database might not be valid afterwards.

Arguments:

    Size - size of block to allocate

Return Value:

    An offset to block that was allocated

--*/

{
    UINT blockSize;
    UINT offset;

    MYASSERT (g_CurrentDatabase);

    if (Size + g_CurrentDatabase->End + sizeof(DATABASE) > g_CurrentDatabase->AllocSize) {

        if (g_CurrentDatabase->AllocSize >= MAX_MEMDB_SIZE) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (1)"));
            return INVALID_OFFSET;
        }

        blockSize = INIT_BLOCK_SIZE * (1 + (g_CurrentDatabase->AllocSize / (INIT_BLOCK_SIZE*8)));

        if (g_CurrentDatabase->AllocSize + blockSize > MAX_MEMDB_SIZE) {

            blockSize = MAX_MEMDB_SIZE - g_CurrentDatabase->AllocSize;
            
            if (blockSize < Size) {
                DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (2)"));
                return INVALID_OFFSET;
            }
        }

        if (blockSize < Size) {
            // we want even more
            blockSize = INIT_BLOCK_SIZE * (1 + (Size / INIT_BLOCK_SIZE));
        }

        if (!SizeDatabaseBuffer (g_CurrentDatabaseIndex, g_CurrentDatabase->AllocSize + blockSize)) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (2)"));
            return INVALID_OFFSET;
        }
    }

    offset = g_CurrentDatabase->End;
    g_CurrentDatabase->End += Size;

    return offset;
}

BOOL
pInitializeDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    MYASSERT (g_CurrentDatabasePath);

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        StringCopyA (databaseControl->FileName, g_CurrentDatabasePath);
        StringCopyA (AppendWackA (databaseControl->FileName), "p0000000.db");
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        StringCopyA (databaseControl->FileName, g_CurrentDatabasePath);
        StringCopyA (AppendWackA (databaseControl->FileName), "t0000000.db");
        break;
    default:
        return FALSE;
    }
    if (!pGetTempFileName (databaseControl->FileName, TRUE)) {
        DEBUGMSG ((
            DBG_ERROR,
            "MemDb Databases: Can't get temporary file name for %s",
            databaseControl->FileName
            ));
        return FALSE;
    }

    databaseControl->hMap = NULL;
    databaseControl->Database = NULL;
    databaseControl->hFile = BfCreateFileA (databaseControl->FileName);

    if (!databaseControl->hFile) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot open database file"));
        return FALSE;

    }

    if ((!SizeDatabaseBuffer (DatabaseIndex, INIT_BLOCK_SIZE)) ||
        (databaseControl->Database == NULL)
        ) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot initialize database"));
        CloseHandle (databaseControl->hFile);
        DeleteFileA (databaseControl->FileName);
        return FALSE;

    }

    databaseControl->Database->End = 0;
    databaseControl->Database->FirstLevelTree = INVALID_OFFSET;
    databaseControl->Database->FirstKeyDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeNodeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeListElemDeleted = INVALID_OFFSET;

    databaseControl->Database->HashTable = CreateHashBlock();
    MYASSERT (databaseControl->Database->HashTable);

    ZeroMemory (&databaseControl->Database->OffsetBuffer, sizeof (GROWBUFFER));
    databaseControl->Database->OffsetBufferFirstDeletedIndex = INVALID_OFFSET;

    return TRUE;
}

BOOL
pDestroyDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }

    //
    // Free all resources for the database
    //
    if (databaseControl->Database) {

        FreeHashBlock (databaseControl->Database->HashTable);
        GbFree (&databaseControl->Database->OffsetBuffer);
    }

    pUnmapDatabaseFile (databaseControl);

    if (databaseControl->hFile) {
        CloseHandle (databaseControl->hFile);
        databaseControl->hFile = NULL;
    }

    DeleteFileA (databaseControl->FileName);

    ZeroMemory (databaseControl, sizeof (DATABASECONTROL));

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    case DB_TEMPORARY:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    default:
        return FALSE;
    }

    return g_CurrentDatabase != NULL;
}

BOOL
pDatabasesInitialize (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    DWORD databasePathSize = 0;

    g_CurrentDatabase = NULL;
    g_CurrentDatabaseIndex = DB_NOTHING;

    if (DatabasePath) {
        g_CurrentDatabasePath = DuplicatePathStringA (DatabasePath, 0);
    } else {
        databasePathSize = GetCurrentDirectoryA (0, NULL);
        if (databasePathSize == 0) {
            return FALSE;
        }
        g_CurrentDatabasePath = AllocPathStringA (databasePathSize + 1);
        databasePathSize = GetCurrentDirectoryA (databasePathSize, g_CurrentDatabasePath);
        if (databasePathSize == 0) {
            FreePathStringA (g_CurrentDatabasePath);
            g_CurrentDatabasePath = NULL;
            return FALSE;
        }
    }

    //
    // Empty the database memory block
    //
    ZeroMemory (&g_PermanentDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_PERMANENT)) {
        return FALSE;
    }
    ZeroMemory (&g_TemporaryDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_TEMPORARY)) {
        pDestroyDatabase (DB_PERMANENT);
        return FALSE;
    }

    g_DatabaseInitialized = TRUE;

    return SelectDatabase (DB_PERMANENT);
}

BOOL
DatabasesInitializeA (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    return pDatabasesInitialize (DatabasePath);
}

BOOL
DatabasesInitializeW (
    IN      PCWSTR DatabasePath  OPTIONAL
    )
{
    PCSTR databasePath = NULL;
    BOOL result = FALSE;

    if (DatabasePath) {
        databasePath = ConvertWtoA (DatabasePath);
    }
    result = pDatabasesInitialize (databasePath);
    if (databasePath) {
        FreeConvertedStr (databasePath);
        databasePath = NULL;
    }
    return result;
}

VOID
DatabasesTerminate (
    IN      BOOL EraseDatabasePath
    )
{
    if (g_DatabaseInitialized) {

        //
        // Free all database blocks
        //

        pDestroyDatabase (DB_TEMPORARY);
        pDestroyDatabase (DB_PERMANENT);

        g_CurrentDatabase = NULL;
        g_CurrentDatabaseIndex = DB_NOTHING;
    }
    if (g_CurrentDatabasePath) {
        if (EraseDatabasePath) {
            if (!FiRemoveAllFilesInTreeA (g_CurrentDatabasePath)) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "Can't remove all files in temporary directory %s",
                    g_CurrentDatabasePath
                    ));
            }
        }
        FreePathStringA (g_CurrentDatabasePath);
        g_CurrentDatabasePath = NULL;
    }
    ELSE_DEBUGMSG ((DBG_MEMDB, "DatabaseTerminate: no database path was set"));
}

PCSTR
DatabasesGetBasePath (
    VOID
    )
{
    return g_CurrentDatabasePath;
}

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    )
{
    PCWSTR result = FullKeyStr;

    if (FullKeyStr) {

        switch (FullKeyStr[0]) {
        case L'~':
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
            result ++;
            break;
        default:
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        }
    }

    if (!g_CurrentDatabase) {
        SetLastError (ERROR_OPEN_FAILED);
        return NULL;
    }

    return result;
}

BYTE
GetCurrentDatabaseIndex (
    VOID
    )
{
    return g_CurrentDatabaseIndex;
}


#ifdef DEBUG
#include "bintree.h"

UINT g_DatabaseCheckLevel = 0;

BOOL
CheckDatabase (
    IN      UINT Level
    )
{
    UINT offset,currOffset;
    BOOL deleted;
    PKEYSTRUCT keyStruct, newStruct;
    PDWORD signature;
    UINT blockSize;

    MYASSERT (g_CurrentDatabase);

    if (Level >= MEMDB_CHECKLEVEL1) {

        // first let's walk the deleted structures making sure that the signature is good
        offset = g_CurrentDatabase->FirstKeyDeleted;

        while (offset != INVALID_OFFSET) {

            keyStruct = GetKeyStructFromOffset (offset);
            MYASSERT (keyStruct);

            if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", offset));
                return FALSE;
            }
            offset = keyStruct->NextDeleted;
        }
    }

    if (Level >= MEMDB_CHECKLEVEL2) {

        // now let's look in the offset array and examine all keystructs pointed from there
        offset = 0;
        while (offset < g_CurrentDatabase->OffsetBuffer.End) {

            // now let's look if offset is deleted or not
            deleted = FALSE;
            currOffset = g_CurrentDatabase->OffsetBufferFirstDeletedIndex;
            while (currOffset != INVALID_OFFSET) {
                if (currOffset == offset) {
                    deleted = TRUE;
                    break;
                }
                currOffset = *(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + currOffset);
            }

            if (!deleted) {

                keyStruct = GetKeyStruct (GET_INDEX (offset));
                if (!keyStruct) {
                    DEBUGMSG ((DBG_ERROR, "Invalid offset found: 0x%8X!", GET_INDEX (offset)));
                    return FALSE;
                }
                if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                    DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", GET_INDEX(offset)));
                    return FALSE;
                }
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
            }
            offset += SIZEOF (UINT);
        }
    }

    if (Level >= MEMDB_CHECKLEVEL3) {

        // now let's walk the actual database buffer looking for all valid structures stored here
        offset = 0;

        while (offset < g_CurrentDatabase->End) {

            signature = (PDWORD)OFFSET_TO_PTR (offset);

            switch (*signature) {
            case KEYSTRUCT_SIGNATURE:
                if (!FindKeyStructInDatabase (offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find KeyStruct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                keyStruct = GetKeyStructFromOffset (offset);
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
                blockSize = keyStruct->Size;
                break;
            case NODESTRUCT_SIGNATURE:
            case BINTREE_SIGNATURE:
            case LISTELEM_SIGNATURE:
                if (!BinTreeFindStructInDatabase (*signature, offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find BinTree struct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                blockSize = BinTreeGetSizeOfStruct(*signature);
                break;
            default:
                DEBUGMSG ((DBG_ERROR, "Invalid structure found in database buffer!"));
                return FALSE;
            }

            if (blockSize==0) {
                DEBUGMSG ((DBG_ERROR, "Invalid block size found in database buffer!"));
                return FALSE;
            }

            offset += blockSize;
        }
    }
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\hash.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hashing routines used to speed lookup of memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"



//
// #defines
//

#define HASH_BUCKETS    7001//4099
#define HASH_BLOCK_SIZE (HASH_BUCKETS * sizeof (BUCKETSTRUCT))
#define HASHBUFPTR(offset) ((PBUCKETSTRUCT) (pHashTable->Buf + offset))






typedef struct _tagHASHSTRUCT {
    UINT Offset;
    UINT NextItem;
} BUCKETSTRUCT, *PBUCKETSTRUCT;

typedef struct {
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT Bucket;
    UINT LastOffset;
} HASHENUM, *PHASHENUM;


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM HashEnum
    );

BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM HashEnum
    );


//
// Local privates
//

VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    );


//
// Implementation
//

PMEMDBHASH
CreateHashBlock (
    VOID
    )
{
    PMEMDBHASH pHashTable;
    pHashTable = (PMEMDBHASH) MemAlloc (g_hHeap, 0, sizeof(MEMDBHASH));
    if (!pHashTable) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash table!\n"));
        return NULL;
    }
    pHashTable->Size = HASH_BLOCK_SIZE * 2;

    pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    if (!pHashTable->Buf) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash buffer!\n"));
        MemFree (g_hHeap, 0, pHashTable);
        return NULL;
    }
    pResetHashBlock(pHashTable);

    return pHashTable;
}


VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    PBUCKETSTRUCT BucketPtr;
    INT i;

    pHashTable->End = HASH_BLOCK_SIZE;
    pHashTable->FreeHead = INVALID_OFFSET;

    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf;
    for (i = 0 ; i < HASH_BUCKETS ; i++) {
        BucketPtr->Offset = INVALID_OFFSET;
        BucketPtr->NextItem = INVALID_OFFSET;
        BucketPtr++;
    }
}


VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    if (pHashTable->Buf) {
        MemFree (g_hHeap, 0, pHashTable->Buf);
    }

    MemFree (g_hHeap, 0, pHashTable);
}


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (HASHENUM));

    return EnumNextHashEntry (pHashTable, EnumPtr);
}


BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM EnumPtr
    )
{
    for (;;) {
        if (EnumPtr->Bucket == HASH_BUCKETS) {
            //
            // The completion case
            //

            return FALSE;
        }

        if (!EnumPtr->BucketPtr) {
            //
            // This case occurs when we are begining to enumerate a bucket
            //

            EnumPtr->BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + EnumPtr->Bucket;
            if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Return this first item in the bucket
            //

            EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
            return TRUE;
        }

        //
        // This case occurs when we are continuing enumeration of a bucket
        //

        if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
            //
            // Current bucket item (and also the last bucket item) may have
            // been deleted -- check that now
            //

            if (!EnumPtr->PrevBucketPtr) {
                //
                // Last item has been deleted; continue to next bucket
                //

                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Previous bucket item is valid; use it.
            //

            EnumPtr->BucketPtr = EnumPtr->PrevBucketPtr;

        } else {
            //
            // Current bucket item may have been deleted, but another item was
            // moved to its place -- check that now
            //

            if (EnumPtr->BucketPtr->Offset != EnumPtr->LastOffset) {
                EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
                return TRUE;
            }
        }

        //
        // We now know that the current bucket item was not changed, so it
        // becomes our previous item and we move on to the next item (if
        // one exists)
        //

        if (EnumPtr->BucketPtr->NextItem == INVALID_OFFSET) {
            //
            // End of bucket reached
            //

            EnumPtr->BucketPtr = NULL;
            EnumPtr->Bucket += 1;
            continue;
        }

        EnumPtr->PrevBucketPtr = EnumPtr->BucketPtr;
        EnumPtr->BucketPtr = HASHBUFPTR (EnumPtr->BucketPtr->NextItem);


        EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
        MYASSERT(EnumPtr->LastOffset != INVALID_OFFSET);
        break;
    }

    return TRUE;
}



BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    *(((PUINT)*Buf)++) = pHashTable->End;
    *(((PUINT)*Buf)++) = pHashTable->FreeHead;

    CopyMemory(*Buf, pHashTable->Buf, pHashTable->End);
    *Buf += pHashTable->End;

    return TRUE;
}


BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    pHashTable->End = *(((PUINT)*Buf)++);
    pHashTable->FreeHead = *(((PUINT)*Buf)++);

    if (pHashTable->End > pHashTable->Size) {
        //
        // if the hash table in the file will not fit in the buffer
        // already allocated, free current buffer and allocate new one.
        //
        MemFree (g_hHeap, 0, pHashTable->Buf);
        pHashTable->Size = pHashTable->End;
        pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    }

    CopyMemory(pHashTable->Buf, *Buf, pHashTable->End);
    *Buf += pHashTable->End;
    return TRUE;
}

UINT GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    )
{
    return 2*sizeof(UINT) + pHashTable->End;
}


UINT
pCalculateHashVal (
    IN      PCWSTR String
    )
{
    UINT Hash = 0;

    while (*String) {
        Hash = (Hash << 5) | (Hash >> 29);
        Hash += towlower (*String);
        String++;
    }

    Hash %= HASH_BUCKETS;

    return Hash;
}

UINT
pAllocBucket (
    IN      PMEMDBHASH pHashTable
    )
{
    UINT rBucketOffset;
    PBYTE TempBuf;
    PBUCKETSTRUCT BucketPtr;

    if (pHashTable->FreeHead != INVALID_OFFSET) {
        rBucketOffset = pHashTable->FreeHead;
        BucketPtr = HASHBUFPTR (rBucketOffset);
        pHashTable->FreeHead = BucketPtr->NextItem;

        MYASSERT (rBucketOffset < pHashTable->End);
    } else {

        if (pHashTable->End + sizeof (BUCKETSTRUCT) > pHashTable->Size) {
            pHashTable->Size += HASH_BLOCK_SIZE;
            TempBuf = MemReAlloc (g_hHeap, 0, pHashTable->Buf, pHashTable->Size);
            DEBUGMSG ((DBG_NAUSEA, "Realloc'd memdb hash table"));

            if (!TempBuf) {
                DEBUGMSG ((DBG_ERROR, "Out of memory!"));
                pHashTable->Size -= HASH_BLOCK_SIZE;
                return INVALID_OFFSET;
            }

            pHashTable->Buf = TempBuf;
        }

        rBucketOffset = pHashTable->End;
        pHashTable->End += sizeof (BUCKETSTRUCT);

        BucketPtr = HASHBUFPTR (rBucketOffset);
    }

    BucketPtr->Offset = INVALID_OFFSET;
    BucketPtr->NextItem = INVALID_OFFSET;

    return rBucketOffset;
}


BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    )
{
    UINT Bucket;
    PBUCKETSTRUCT BucketPtr, PrevBucketPtr;
    UINT BucketOffset;
    UINT NewOffset;
    UINT PrevBucketOffset;

    Bucket = pCalculateHashVal (FullString);
    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + Bucket;

    //
    // See if root bucket item has been used or not
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        //
        // Yes - add to end of the chain
        //

        BucketOffset = Bucket * sizeof (BUCKETSTRUCT);
        do {
            BucketPtr = HASHBUFPTR (BucketOffset);
            PrevBucketOffset = BucketOffset;
            BucketOffset = BucketPtr->NextItem;
        } while (BucketOffset != INVALID_OFFSET);


        //
        // Add to the chain
        //

        NewOffset = pAllocBucket(pHashTable);
        PrevBucketPtr = HASHBUFPTR (PrevBucketOffset);
        PrevBucketPtr->NextItem = NewOffset;

        if (NewOffset == INVALID_OFFSET) {
            return FALSE;
        }

        BucketPtr = HASHBUFPTR (NewOffset);
        MYASSERT (BucketPtr->NextItem == INVALID_OFFSET);
    }

    BucketPtr->Offset = Offset;

#ifdef DEBUG
    {
        UINT HashOffset;

        HashOffset = FindStringInHashTable (pHashTable, FullString);
        MYASSERT (HashOffset != INVALID_OFFSET);
        DEBUGMSG_IF ((HashOffset != Offset, DBG_MEMDB, "Duplicate in hash table: %s", FullString));
    }
#endif

    return TRUE;
}


PBUCKETSTRUCT
pFindBucketItemInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    OUT     PBUCKETSTRUCT *PrevBucketPtr,       OPTIONAL
    OUT     PUINT HashOffsetPtr                 OPTIONAL
    )
{
    UINT Bucket;
    UINT BucketOffset;
    PBUCKETSTRUCT BucketPtr = NULL;
    WCHAR TempStr[MEMDB_MAX];

    Bucket = pCalculateHashVal (FullString);
    BucketOffset = Bucket * sizeof (BUCKETSTRUCT);

#ifdef DEBUG
    {
        //
        // Circular link check
        //

        UINT Prev, Next;
        UINT Turtle, Rabbit;
        BOOL Even = FALSE;

        Rabbit = BucketOffset;
        Turtle = Rabbit;
        while (Rabbit != INVALID_OFFSET) {
            // Make rabbit point to next item in chain
            Prev = Rabbit;
            BucketPtr = HASHBUFPTR (Rabbit);
            Rabbit = BucketPtr->NextItem;

            // We should always be ahead of the turtle
            if (Rabbit == Turtle) {
                BucketPtr = HASHBUFPTR (Rabbit);
                Next = BucketPtr->NextItem;
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Circular link detected in memdb hash table!  Turtle=%u, Rabbit=%u, Next=%u, Prev=%u",
                    Turtle,
                    Rabbit,
                    Next,
                    Prev
                    ));

                return NULL;
            }

            // Make turtle point to next item in chain (1 of every 2 passes)
            if (Even) {
                BucketPtr = HASHBUFPTR (Turtle);
                Turtle = BucketPtr->NextItem;
            }

            Even = !Even;
        }
    }
#endif

    BucketPtr = HASHBUFPTR (BucketOffset);

    if (PrevBucketPtr) {
        *PrevBucketPtr = BucketPtr;
    }

    //
    // If root bucket is not empty, scan bucket for FullString
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        do  {

            BucketPtr = HASHBUFPTR (BucketOffset);
            //
            // Build string using offset
            //

            PrivateBuildKeyFromIndex (
                0,
                BucketPtr->Offset,
                TempStr,
                NULL,
                NULL,
                NULL
                );

            //
            // Do compare and return if match is found
            //

            if (StringIMatchW (FullString, TempStr)) {
                if (HashOffsetPtr) {
                    *HashOffsetPtr = BucketOffset;
                }
                return BucketPtr;
            }


            if (PrevBucketPtr) {
                *PrevBucketPtr = BucketPtr;
            }

            BucketOffset = BucketPtr->NextItem;

        } while (BucketOffset != INVALID_OFFSET);
    }

    return NULL;
}


UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, NULL, NULL);
    if (BucketPtr) {
        return BucketPtr->Offset;
    }

    return INVALID_OFFSET;
}


BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT NextOffset;
    PBUCKETSTRUCT NextBucketPtr;
    UINT BucketOffset;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, &PrevBucketPtr, &BucketOffset);
    if (!BucketPtr) {
        return FALSE;
    }

    if (PrevBucketPtr != BucketPtr) {
        //
        // If not at the first level (prev != current), give the block
        // to free space.
        //

        PrevBucketPtr->NextItem = BucketPtr->NextItem;
        BucketPtr->NextItem = pHashTable->FreeHead;
        BucketPtr->Offset = INVALID_OFFSET;
        pHashTable->FreeHead = BucketOffset;

    } else {

        //
        // Invalidate next item pointer if at the first level
        //

        if (BucketPtr->NextItem != INVALID_OFFSET) {
            //
            // Copy next item to root array
            //

            NextOffset = BucketPtr->NextItem;
            NextBucketPtr = HASHBUFPTR (NextOffset);
            CopyMemory (BucketPtr, NextBucketPtr, sizeof (BUCKETSTRUCT));

            //
            // Donate next item to free space
            //

            NextBucketPtr->NextItem = pHashTable->FreeHead;
            NextBucketPtr->Offset = INVALID_OFFSET;
            pHashTable->FreeHead = NextOffset;


        } else {
            //
            // Delete of last item in bucket -- invalidate the root array item
            //

            BucketPtr->NextItem = INVALID_OFFSET;
            BucketPtr->Offset = INVALID_OFFSET;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\bintree.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bintree.h

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999


--*/


//
// all string arguments for BinTree functions must
// be Pascal-style strings (use StringPas...() functions
// defined in pastring.c).
//




//
// returns offset of binary tree
// OffsetOfString is the offset in bytes in the data structure
// of the string used to order the different nodes
//
UINT BinTreeNew();

//
// returns INVALID_OFFSET if node already exists,
// or offset of NODESTRUCT if add went okay
//
BOOL BinTreeAddNode(UINT TreeOffset, UINT data);

//
// removes node and returns offset of data
//
UINT BinTreeDeleteNode(UINT TreeOffset, PCWSTR str, PBOOL LastNode);

//
// returns pointer to data
//
UINT BinTreeFindNode(UINT TreeOffset, PCWSTR str);

//
// destroys and deallocates tree (but not data contained inside)
//
void BinTreeDestroy(UINT TreeOffset);

//
// enumerate first node in tree.  this takes the offset of
// the BINTREE struct and a pointer to a UINT which will
// hold data for BinTreeEnumNext.
//
UINT BinTreeEnumFirst(UINT TreeOffset, PUINT pEnum);

//
// pEnum is the enumerator filled by BinTreeEnumFirst
//
UINT BinTreeEnumNext(PUINT pEnum);

//
// turns the binary tree to insertion order - can only be
// done if the binary tree contains 0 or 1 nodes.  return
// TRUE if conversion is successful, or if binary tree is
// already in Insertion-Ordered mode.
//
BOOL BinTreeSetInsertionOrdered(UINT TreeOffset);



//
// number of nodes in tree
//
UINT BinTreeSize(UINT TreeOffset);



#ifdef DEBUG

//
// maximum depth of tree
//
int BinTreeMaxDepth(UINT TreeOffset);

//
// displays tree.  strsize is length of strings to display
//
void BinTreePrint(UINT TreeOffset);

//
// checks to make sure tree is valid and good
//
BOOL BinTreeCheck(UINT TreeOffset);

#else

#define BinTreePrint(a)
#define BinTreeCheck(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\keyfind.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keyfind.c

Abstract:

    Routines that manage finding the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from keystruct.c


--*/

#include "pch.h"
#include "memdbp.h"


UINT
FindKeyStruct (
    PCWSTR Key
    )
/*++

Routine Description:

  FindKeyStruct takes a wack-delimited key string, and returns the Index
  of the keystruct.  this is different than FindKey() because that only
  finds endpoints, so it is fast, because it can use the hash table.
  this recurses down the memdb database levels to the specified keystruct.

Arguments:

  Key                - String holding full path of key to be found

Return Value:

  Index of key, or INVALID_OFFSET if function failed

--*/
{
    UINT TreeOffset, Index=INVALID_OFFSET;
    PWSTR p, q;
    WCHAR Temp[MEMDB_MAX];

    MYASSERT (g_CurrentDatabase);

    if (*Key==0) {
        return INVALID_OFFSET;
    }
    StringCopyW (Temp, Key);
    q = Temp;

    do {
        if (Index == INVALID_OFFSET) {
            TreeOffset = g_CurrentDatabase->FirstLevelTree;
        } else {
            TreeOffset = GetKeyStruct(Index)->NextLevelTree;
        }

        if (TreeOffset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        p = wcschr (q, L'\\');
        if (p) {
            *p = 0;
        }

        Index = FindKeyStructInTree (TreeOffset, q, FALSE);

        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        if (p) {
            q = p + 1;
        }

    } while (p);

    return Index;
}


UINT
FindKey (
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKey locates a complete key string and returns
  the Index to the KEYSTRUCT, or INVALID_OFFSET if
  the key path does not exist.  The FullKeyPath
  must supply the complete path to the KEYSTRUCT.

Arguments:

  FullKeyPath - A backslash-delimited key path to a value

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    MYASSERT (g_CurrentDatabase);

    return FindStringInHashTable (g_CurrentDatabase->HashTable, FullKeyPath);
}

UINT
FindKeyStructUsingTreeOffset (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR KeyStr
    )

/*++

Routine Description:

  FindKeyStructUsingTreeOffset takes a key pattern and looks
  for the Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes, but can contain wildcards.

Arguments:

  TreeOffset - An offset to the tree

  pTreeEnum - The previous value from FindKeyStructUsingTreeOffset
               (for enumeration) or INVALID_OFFSET for the first
               call.

  KeyStr - The name of the key to find in the binary tree

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex;
    SIZE_T len1, len2;

    MYASSERT(pTreeEnum!=NULL);

    if (*pTreeEnum == INVALID_OFFSET) {
        KeyIndex = GetFirstIndex(TreeOffset, pTreeEnum);
    } else {
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    //
    // Examine key as a pattern, then go to next node
    //
    while (KeyIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(KeyIndex);

        len1 = CharCountW (KeyStr);
        len2 = *KeyStruct->KeyName;
        if ((len1 == len2) &&
            (StringIMatchCharCountW (KeyStr, KeyStruct->KeyName + 1, len1))
            ) {
            return KeyIndex;
        }
        //
        // No match yet - go to next node
        //
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    return INVALID_OFFSET;
}

#ifdef DEBUG
BOOL FindKeyStructInDatabase(UINT KeyOffset)
{
    PKEYSTRUCT pKey;

    MYASSERT (g_CurrentDatabase);

    pKey = GetKeyStructFromOffset(KeyOffset);

    if (pKey->KeyFlags & KSF_DELETED) {
        return TRUE;
    }

    while (pKey->PrevLevelIndex!=INVALID_OFFSET) {
        pKey=GetKeyStruct(pKey->PrevLevelIndex);
    }

    return (FindKeyStructInTree(g_CurrentDatabase->FirstLevelTree, pKey->KeyName, TRUE)!=INVALID_OFFSET);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\bintree.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    bintree.c

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

--*/


#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

#define NODESTRUCT_SIZE_MAIN    (4*sizeof(UINT) + sizeof(WORD))
#define BINTREE_SIZE_MAIN    sizeof(UINT)
#define LISTELEM_SIZE_MAIN    (3*sizeof(UINT))

#ifdef DEBUG

    #define NODESTRUCT_HEADER_SIZE  (sizeof(DWORD)+sizeof(BOOL))
    #define NODESTRUCT_SIZE         ((WORD)(NODESTRUCT_SIZE_MAIN + (g_UseDebugStructs ? NODESTRUCT_HEADER_SIZE : 0)))

    #define BINTREE_HEADER_SIZE  (sizeof(DWORD)+2*sizeof(INT)+sizeof(BOOL))
    #define BINTREE_SIZE         ((WORD)(BINTREE_SIZE_MAIN + (g_UseDebugStructs ? BINTREE_HEADER_SIZE : 0)))

    #define LISTELEM_HEADER_SIZE  sizeof(DWORD)
    #define LISTELEM_SIZE         ((WORD)(LISTELEM_SIZE_MAIN + (g_UseDebugStructs ? LISTELEM_HEADER_SIZE : 0)))

#else

    #define NODESTRUCT_SIZE         ((WORD)NODESTRUCT_SIZE_MAIN)
    #define BINTREE_SIZE         ((WORD)BINTREE_SIZE_MAIN)
    #define LISTELEM_SIZE         ((WORD)LISTELEM_SIZE_MAIN)

#endif


//
// Macros
//

#define MAX(a,b) (a>b ? a : b)
#define ABS(x) (x<0 ? -x : x)

#ifdef DEBUG

//
// if BINTREECHECKTREEBALANCE is true, every addition or deletion
// or rotation checks to make sure tree is balanced and
// correct.  this of course take a lot of time.
//
#define BINTREECHECKTREEBALANCE    FALSE

#define INITTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc=0; } }
#define INCTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc++; } }
#define DECTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc--; } }
#define TESTTREENODES(tree) { if (g_UseDebugStructs) { MYASSERT(tree->NodeAlloc==0); } }
#define INITTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc=0; } }
#define INCTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc++; } }
#define DECTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc--; } }
#define TESTTREEELEMS(tree) { if (g_UseDebugStructs) { MYASSERT(tree->ElemAlloc==0); } }

#else

#define BINTREECHECKTREEBALANCE

#define INITTREENODES(tree)
#define INCTREENODES(tree)
#define DECTREENODES(tree)
#define TESTTREENODES(tree)
#define INITTREEELEMS(tree)
#define INCTREEELEMS(tree)
#define DECTREEELEMS(tree)
#define TESTTREEELEMS(tree)

#endif

#if defined(DEBUG)
#if BINTREECHECKTREEBALANCE

#define TESTNODETREE(node) MYASSERT(pBinTreeCheckBalance(node));
#define TESTTREE(tree) MYASSERT(pBinTreeCheck(tree));

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

//
// Types
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
    BOOL Deleted;
#endif

    union {
        struct {        //for normal nodes
            UINT Data;              //offset of data structure
            UINT Left;              //offset of left child
            UINT Right;             //offset of right child
            UINT Parent;            //offset of parent
        };//lint !e657
        struct {        //for the InsertionOrdered list header node (tree->Root points to this)
            UINT Root;              //offset of actual root of tree
            UINT Head;              //head of insertion ordered list
            UINT Tail;              //tail of insertion ordered list
        };//lint !e657
        UINT NextDeleted;           //offset of next deleted node
    };


    struct {
        WORD InsertionOrdered : 1;  //flag, 1 if insertion-ordered (only really needed
                                    //by enumeration methods, because to save space
                                    //there is no tree pointer in the NODESTRUCT, but
                                    //we need a way for enumeration methods to know if
                                    //node->Data is the offset of the data or the
                                    //offset of a LISTELEM (which it is when we are in
                                    //insertion-ordered mode)).
        WORD InsertionHead : 1;     //flag, 1 if this node is the head of insertion
                                    //ordered tree.
        WORD LeftDepth : 7;         //depths of subtrees.  these can be 7 bits because
        WORD RightDepth : 7;        //if depth got up to near 128, the approximate
                                    //number of nodes would be 1e35.
    };//lint !e657
} NODESTRUCT, *PNODESTRUCT;

//
// normally, the BINTREE structure simply has the offset
// of the root node of the tree in its Root member.  but
// when we are in insertion-ordered mode, we have an extra
// node whose offset is stored in the BINTREE->Root.  this
// Header Node points to the head of the insertion-ordered
// linked list, the tail of the list, and the actual root
// of the binary tree.
//

typedef struct {

#ifdef DEBUG

    DWORD Signature;
    INT NodeAlloc;          // counter for number of nodes allocated
    INT ElemAlloc;          // counter for number of elems allocated
    BOOL Deleted;           // flag which is TRUE if tree is deleted

#endif

    union {
        UINT Root;          // offset of top level NODESTRUCT
        UINT NextDeleted;   // offset of next deleted tree
    };

} BINTREE, *PBINTREE;

//
// if we are in insertion-ordered mode, that means every
// enumeration will be in the order that we added the
// data.  to do this, we use a linked list with the binary
// tree.  the data member of the NODESTRUCT holds the
// offset of the LISTELEM structure, and the data member
// of the LISTELEM structure holds the offset of the data.
// To enumerate, we just walk the linked list in order.
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        struct {
            UINT Next;      // offset of next element in list
            UINT Data;      // offset of data structure this element is for
            UINT Node;      // offset of NODESTRUCT this listelem corresponds to
        };//lint !e657
        UINT NextDeleted;
    };

} LISTELEM, *PLISTELEM;

//
// Globals
//

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR String
    );

PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    );

PNODESTRUCT
pBinTreeEnumNext (
    IN OUT  PNODESTRUCT CurrentNode
    );

PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    );

PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    );

PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    );

VOID
pBinTreeFreeNode (
    PNODESTRUCT Node
    );

VOID
pBinTreeFreeTree (
    PBINTREE Tree
    );

VOID
pBinTreeFreeListElem (
    PLISTELEM Elem
    );

VOID
pBinTreeDestroy (
    PNODESTRUCT Node,
    PBINTREE Tree
    );

//
// This starts at node and moves up tree balancing.
// The function stops moving up when it finds a node
// which has no change in depth values and/or no balancing
// to be done.  Otherwise, it goes all the way to top.
// Carry TreeOffset through for rotate functions
//
VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After pBinTreeNodeBalance, parent of node could have incorrect
// depth values and might need rebalancing.
// Carry TreeOffset through for rotate functions.
// Assumes children of 'node' are balanced.
// Returns true if node rebalanced or if depth values changed.
//
BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After using the following rotate functions, the parents of node
// could have incorrect depth values, and could need rebalancing.
// We do not have double-rotate functions because that is taken
// care of inside these.  Need TreeOffset just in case node is top node
//
VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );


#ifdef DEBUG

INT
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    );

INT
pBinTreeCheck (
    IN      PBINTREE Tree
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//

//
// If we are in debug mode, these conversions
// are implemented as functions, so we can
// check for errors.  If we are not in debug
// mode, the conversions are simple macros.
//
#ifdef DEBUG

UINT
GetNodeOffset (
    IN      PNODESTRUCT Node
    )
{
    if (!Node) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Node) + NODESTRUCT_HEADER_SIZE;
    }

    MYASSERT (Node->Signature == NODESTRUCT_SIGNATURE);

    return PTR_TO_OFFSET(Node);
}


UINT
GetTreeOffset (
    PBINTREE Tree
    )
{

    if (!Tree) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Tree) + BINTREE_HEADER_SIZE;
    }

    MYASSERT (Tree->Signature == BINTREE_SIGNATURE);

    return PTR_TO_OFFSET(Tree);
}


UINT
GetListElemOffset (
    PLISTELEM Elem
    )
{
    if (!Elem) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Elem) + LISTELEM_HEADER_SIZE;
    }

    MYASSERT (Elem->Signature == LISTELEM_SIGNATURE);

    return PTR_TO_OFFSET(Elem);
}


PNODESTRUCT
GetNodeStruct (
    UINT Offset
    )
{
    PNODESTRUCT node;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PNODESTRUCT) OFFSET_TO_PTR(Offset - NODESTRUCT_HEADER_SIZE);
    }

    node = (PNODESTRUCT) OFFSET_TO_PTR(Offset);

    MYASSERT (node->Signature == NODESTRUCT_SIGNATURE);

    return node;
}


PBINTREE
GetBinTree (
    UINT Offset
    )
{
    PBINTREE tree;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PBINTREE) OFFSET_TO_PTR(Offset - BINTREE_HEADER_SIZE);
    }

    tree = (PBINTREE) OFFSET_TO_PTR(Offset);

    MYASSERT (tree->Signature == BINTREE_SIGNATURE);

    return tree;
}


PLISTELEM
GetListElem (
    UINT Offset
    )
{
    PLISTELEM elem;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PLISTELEM) OFFSET_TO_PTR(Offset - LISTELEM_HEADER_SIZE);
    }

    elem = (PLISTELEM) OFFSET_TO_PTR(Offset);

    MYASSERT (elem->Signature == LISTELEM_SIGNATURE);

    return elem;
}

#else

#define GetNodeOffset(Node)         ((Node) ?                   \
                                        PTR_TO_OFFSET(Node) :   \
                                        INVALID_OFFSET)

#define GetTreeOffset(Tree)         ((Tree) ?                   \
                                        PTR_TO_OFFSET(Tree) :   \
                                        INVALID_OFFSET)

#define GetListElemOffset(Elem)     ((Elem) ?                   \
                                        PTR_TO_OFFSET(Elem) :   \
                                        INVALID_OFFSET)

#define GetNodeStruct(Offset)       (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PNODESTRUCT) OFFSET_TO_PTR(Offset))

#define GetBinTree(Offset)          (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PBINTREE) OFFSET_TO_PTR(Offset))

#define GetListElem(Offset)         (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PLISTELEM)OFFSET_TO_PTR(Offset))


#endif


//
// GetNodeData - takes a node and gets the data
//      structure offset
//
// GetNodeDataStr - takes a node and gets the
//      pascal-style string in the data structure offset
//

#define GetNodeData(Node)       ((Node)->InsertionOrdered ?                 \
                                        GetListElem((Node)->Data)->Data :   \
                                        (Node)->Data)

#define GetNodeDataStr(Node)    (GetDataStr(GetNodeData(Node)))


PNODESTRUCT
GetTreeRoot (
    IN      PBINTREE Tree
    )
{
    PNODESTRUCT cur;

    if (!Tree || Tree->Root == INVALID_OFFSET) {
        return NULL;
    }

    cur = GetNodeStruct (Tree->Root);

    if (cur->InsertionHead) {
        return GetNodeStruct (cur->Root);
    } else {
        return cur;
    }
}


VOID
pSetTreeRoot (
    IN      PBINTREE Tree,
    IN      UINT Offset
    )
{
    PNODESTRUCT cur;

    if (!Tree) {
        return;
    }

    cur = GetNodeStruct(Tree->Root);

    if (cur && cur->InsertionHead) {
        cur->Root = Offset;
    } else {
        Tree->Root = Offset;
    }
}

#define IsTreeInsertionOrdered(Tree)    ((Tree) ?                                               \
                                            ((Tree)->Root==INVALID_OFFSET ?                     \
                                                FALSE :                                         \
                                                GetNodeStruct((Tree)->Root)->InsertionHead) :   \
                                            FALSE)







UINT
BinTreeNew (
    VOID
    )

/*++

Routine Description:

  BinTreeNew creates a new binary tree data structure. This is done when a new
  node is created via a set operation of some sort. Additional items are added
  to the binary tree via BinTreeAddNode.

Arguments:

  None.

Return Value:

  The offset to the new tree.

Comments:

  This function assumes that it cannot fail,  because if a low-level memory
  routine fails, the process will die.

  The database heap might be moved by the allocation request, and could
  invalidate pointers. The caller must use care not to use pointers until
  after this routine returns, or it must re-convert offsets into new pointers.

--*/

{
    UINT treeOffset;
    PBINTREE tree;

    tree = pBinTreeAllocTree (&treeOffset);
    if (!tree) {
        return INVALID_OFFSET;
    }

    tree->Root = INVALID_OFFSET;

    INITTREENODES(tree);
    INITTREEELEMS(tree);

    return treeOffset;
}


BOOL
BinTreeAddNode (
    IN      UINT TreeOffset,
    IN      UINT Data
    )

/*++

Routine Description:

  BinTreeAddNode adds a new item to an existing binary tree.

Arguments:

  TreeOffset - Indicates the root of the binary tree, as returned by
               BinTreeNew.
  Data       - Specifies the offset of the data structure containing the
               node to insert. The string address is computed from Data via
               GetDataStr.

Return Value:

  TRUE if the insertion operation succeeded, FALSE if the item is already in
  the tree.

--*/

{
    UINT nodeOffset;
    UINT elemOffset;
    UINT parentOffset;
    PNODESTRUCT node;
    PNODESTRUCT cur;
    PNODESTRUCT parent;
    PBINTREE tree;
    PLISTELEM elem;
    INT cmp;
    PCWSTR dataStr;

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // Keep track of initial database pointer.  If it changes, we need
    // to readjust our pointers.
    //

    tree = GetBinTree (TreeOffset);

    if (!GetTreeRoot (tree)) {

        //
        // No root case -- add this item as the root
        //

        node = pBinTreeAllocNode (&nodeOffset);
        if (!node) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        pSetTreeRoot (tree, nodeOffset);

        node->Parent = INVALID_OFFSET;
        parentOffset = INVALID_OFFSET;
        parent = NULL;

    } else {

        //
        // Existing root case -- try to find the item, then if it does
        // not exist, add it.
        //

        cur = GetTreeRoot (tree);
        dataStr = GetDataStr (Data);

        do {
            cmp = StringPasICompare (dataStr, GetNodeDataStr (cur));

            if (!cmp) {
                //
                // Node is already in tree
                //
                return FALSE;
            }

            //
            // Go to left or right node, depending on search result
            //

            parentOffset = GetNodeOffset (cur);

            if (cmp < 0) {
                cur = GetNodeStruct(cur->Left);
            } else {
                cur = GetNodeStruct(cur->Right);
            }

        } while (cur);

        //
        // Node is not in the tree.  Add it now.
        //

        node = pBinTreeAllocNode(&nodeOffset);
        if (!node) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(cur);
        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        node->Parent = parentOffset;
        parent = GetNodeStruct (parentOffset);

        if (cmp < 0) {
            parent->Left = nodeOffset;
        } else {
            parent->Right = nodeOffset;
        }
    }

    //
    // Verify the code above restored the tree pointer if
    // an allocation occurred.
    //

    MYASSERT (tree == GetBinTree (TreeOffset));

    //
    // Initialize the new node
    //

    node->Left          = INVALID_OFFSET;
    node->Right         = INVALID_OFFSET;
    node->LeftDepth     = 0;
    node->RightDepth    = 0;
    node->InsertionHead = 0;

    if (!IsTreeInsertionOrdered (tree)) {
        //
        // We are in sorted-order mode
        //

        node->Data = Data;
        node->InsertionOrdered = 0;

    } else {
        //
        // We are in insertion-ordered mode
        //

        elem = pBinTreeAllocListElem (&elemOffset);
        if (!elem) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(parent);
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(node);

        parent = GetNodeStruct (parentOffset);
        tree = GetBinTree (TreeOffset);
        node = GetNodeStruct (nodeOffset);

        INCTREEELEMS(tree);

        node->InsertionOrdered = 1;
        node->Data = elemOffset;                // NODESTRUCT.Data is offset of list element
        elem->Data = Data;                      // LISTELEM holds offset of data
        elem->Node = nodeOffset;                // LISTELEM points back to nodestruct
        elem->Next = INVALID_OFFSET;            // elem will be put at end of list

        //now use node to point to list header
        node = GetNodeStruct (tree->Root);
        MYASSERT (node->InsertionHead);

        if (node->Head == INVALID_OFFSET) {     // if this is true, the list is empty
            node->Head = elemOffset;            // put elemOffset at beginning of the list
        } else {                                // otherwise, put the new element at end of list
            MYASSERT (node->Tail != INVALID_OFFSET);
            GetListElem (node->Tail)->Next = elemOffset;
        }

        node->Tail = elemOffset;                // new element is tail of list
    }

    pBinTreeBalanceUpward (parent, TreeOffset);

    TESTTREE (GetBinTree (TreeOffset));

    return TRUE;
}


UINT
BinTreeDeleteNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str,
    OUT     PBOOL LastNode              OPTIONAL
    )

/*++

Routine Description:

  BinTreeDeleteNode removes a string from a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to remove the string from
  Str        - Specifies the string to remove
  LastNode   - Receives TRUE if the binary tree became empty as a result of
               the delete, FALSE otherwise

Return Value:

  The data offset of the string that was deleted

--*/

{
    PNODESTRUCT deleteNode;
    PNODESTRUCT parent;
    PNODESTRUCT replace;
    UINT data;
    UINT replaceOffset;
    UINT deleteNodeOffset;
    PNODESTRUCT startBalance;
    PNODESTRUCT startBalance2 = NULL;
    PBINTREE tree;
    UINT elemOffset;
    PLISTELEM elem;
    PLISTELEM cur;
    PNODESTRUCT header;

    //
    // after we delete a node, we have to start from somewhere and
    // move up the tree, fixing the balance of nodes.  startBalance
    // is a pointer to the nodestruct to start at.  in more complicated
    // deletions, like when the deleted node has two children, and the
    // replacement node is way down the tree, there are two places to
    // start rebalancing from.
    //

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    deleteNode = pBinTreeFindNode (tree, Str);
    if (deleteNode == NULL) {
        return INVALID_OFFSET;
    }

    if (LastNode) {
        *LastNode = FALSE;
    }

    deleteNodeOffset = GetNodeOffset (deleteNode);
    parent = GetNodeStruct (deleteNode->Parent);

    data = GetNodeData (deleteNode);

    if (deleteNode->Right == INVALID_OFFSET && deleteNode->Left == INVALID_OFFSET) {

        //
        // deleteNode has no children
        //

        if (parent == NULL) {

            if (LastNode) {
                *LastNode = TRUE;
            }

            pSetTreeRoot(tree, INVALID_OFFSET);

        } else {

            if (parent->Left == deleteNodeOffset) {
                parent->Left=INVALID_OFFSET;
            } else {
                parent->Right=INVALID_OFFSET;
            }

        }

        startBalance = parent;

    } else {
        //
        // deleteNode has one or two children
        //

        if (deleteNode->Right == INVALID_OFFSET || deleteNode->Left == INVALID_OFFSET) {

            //
            // deleteNode has one child
            //

            if (deleteNode->Right == INVALID_OFFSET) {
                replace = GetNodeStruct (deleteNode->Left);
            } else {
                replace = GetNodeStruct (deleteNode->Right);
            }

            replaceOffset = GetNodeOffset (replace);

            //
            // deleteNode->Parent has new child, so check balance
            //

            startBalance = parent;

        } else {

            //
            // deleteNode has two children: find replacement on deeper side
            //

            if (deleteNode->LeftDepth > deleteNode->RightDepth) {

                //
                // find replacement node on left
                //

                replace = GetNodeStruct (deleteNode->Left);

                if (replace->Right == INVALID_OFFSET) {
                    //
                    // node's left child has no right child, so replace is node->Left
                    //
                    replace->Right = deleteNode->Right;  //hook up node's right child to replace

                    GetNodeStruct (replace->Right)->Parent = deleteNode->Left;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's left child has right child, so find the rightmost child
                    //

                    do {
                        //
                        // move right as far as possible
                        //
                        replace = GetNodeStruct (replace->Right);

                    } while (replace->Right != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //

                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's right child is replace's left
                    //

                    startBalance2->Right = replace->Left;

                    if (replace->Left != INVALID_OFFSET) {
                        //
                        // hook up left children to replace->Parent
                        //
                        GetNodeStruct(replace->Left)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;

                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;
                }

            } else {
                //
                // find replacement node on right
                //

                replace = GetNodeStruct (deleteNode->Right);

                if (replace->Left == INVALID_OFFSET) {
                    //
                    // deleteNode's right child has no left child, so replace is deleteNode->Right
                    //

                    replace->Left = deleteNode->Left;  // hook up node's left child to replace

                    GetNodeStruct (replace->Left)->Parent = deleteNode->Right;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's right child has left child, so find the leftmost child
                    //

                    do {

                        replace = GetNodeStruct (replace->Left);

                    } while (replace->Left != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //
                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's left child is replace's right
                    //
                    startBalance2->Left = replace->Right;

                    if (replace->Right != INVALID_OFFSET) {
                        //
                        // hook up right children to replace->Parent
                        //
                        GetNodeStruct (replace->Right)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //
                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;
                }
            }

            //
            // in all cases of deleted node having two children,
            // the place to start (second) balancing is the node
            // that replaces the deleted node, because it will
            // always have at least one new child.
            //
            startBalance = replace;
        }

        //
        // this is offset
        //

        replace->Parent = deleteNode->Parent;

        if (parent == NULL) {
            //
            // deleting top-level node
            //
            pSetTreeRoot (tree, replaceOffset);

        } else {
            if (parent->Left == deleteNodeOffset) {
                parent->Left = replaceOffset;
            } else {
                parent->Right = replaceOffset;
            }
        }
    }

    if (startBalance2) {
        //
        // startBalance2 is lower one
        //
        pBinTreeBalanceUpward (startBalance2, TreeOffset);
    }

    pBinTreeBalanceUpward (startBalance, TreeOffset);

    if (deleteNode->InsertionOrdered) {
        //
        // We are in insertion-ordered mode
        //

        //
        // get offset of LISTELEM for this NODESTRUCT
        //
        elemOffset = deleteNode->Data;
        elem = GetListElem (elemOffset);

        header = GetNodeStruct (tree->Root);   //get the header of list

        if (header->Head == elemOffset) {
            //
            // if elem was first in list
            //

            header->Head = elem->Next;

            if (elem->Next == INVALID_OFFSET) {     // if elem was last in list
                header->Tail = INVALID_OFFSET;
            }

        } else {
            //
            // elem was not first in list
            //

            cur = GetListElem (header->Head);

            while (cur->Next != elemOffset) {
                MYASSERT (cur->Next != INVALID_OFFSET);
                cur = GetListElem (cur->Next);
            }

            //
            // now cur is the element before elem, so pull elem out of list
            //

            cur->Next = elem->Next;
            if (elem->Next == INVALID_OFFSET) {           // if elem was last in list
                header->Tail = GetListElemOffset(cur);    // set end pointer to new last element
            }
        }

        pBinTreeFreeListElem (elem);
        DECTREEELEMS(tree);
    }

    pBinTreeFreeNode (deleteNode);
    DECTREENODES(tree);

    TESTTREE(tree);

    return data;
}


PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR Str
    )
{
    PNODESTRUCT cur;
    INT cmp;

    if (!Tree) {
        return NULL;
    }

    cur = GetTreeRoot (Tree);

    while (cur) {

        cmp = StringPasICompare (Str, GetNodeDataStr (cur));

        if (!cmp) {
            break;
        }

        if (cmp < 0) {
            cur = GetNodeStruct (cur->Left);
        } else {
            cur = GetNodeStruct (cur->Right);
        }
    }

    return cur;
}


UINT
BinTreeFindNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str
    )

/*++

Routine Description:

  BinTreeFindNode searches a binary tree for a string and returns the offset
  to the item data.

Arguments:

  TreeOffset - Specifies the binary tree to search
  Str        - Specifies the string to find

Return Value:

  The offset to the node data, or INVALID_OFFSET if string is not found.

--*/

{
    PNODESTRUCT node;
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);
    node = pBinTreeFindNode (tree, Str);

    if (!node) {
        return INVALID_OFFSET;
    }

    return GetNodeData(node);
}


VOID
pBinTreeDestroy (
    IN      PNODESTRUCT Node,       OPTIONAL
    IN      PBINTREE Tree           OPTIONAL
    )

/*++

Routine Description:

  pBinTreeDestroy destroys a binary tree. This routine is recursive.

Arguments:

  Node - Specifies the node to deallocate.  All child nodes are also
         deallocated.
  Tree - Specifies the tree that Node belongs to

Return Value:

  None.

--*/

{
    if (!Node || !Tree) {
        return;
    }

    pBinTreeDestroy (GetNodeStruct (Node->Left), Tree);
    pBinTreeDestroy (GetNodeStruct (Node->Right), Tree);

    if (Node->InsertionOrdered) {
        pBinTreeFreeListElem (GetListElem (Node->Data));
        DECTREEELEMS(Tree);
    }

    pBinTreeFreeNode (Node);
    DECTREENODES(Tree);
}


VOID
BinTreeDestroy (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeDestroy deallocates all nodes in a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to free

Return Value:

  None.

--*/

{
    PBINTREE tree;
    PNODESTRUCT root;
    PNODESTRUCT header;

    if (TreeOffset==INVALID_OFFSET) {
        return;
    }

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        header = root;
        root = GetNodeStruct (root->Root);
    } else {
        header = NULL;
    }

    pBinTreeDestroy (root, tree);

    if (header) {
        pBinTreeFreeNode(header);
        DECTREENODES(tree);
    }

    TESTTREENODES(tree);
    TESTTREEELEMS(tree);

    pBinTreeFreeTree(tree);
}


PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeEnumFirst returns the first node in the specified tree.

Arguments:

  Tree - Specifies the tree to begin enumerating

Return Value:

  A pointer to the first node struct, or NULL if no items exist in Tree, or
  if Tree is NULL.

--*/

{
    PNODESTRUCT cur;

    cur = GetTreeRoot (Tree);

    if (cur) {

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

    }

    return cur;
}


PNODESTRUCT
pBinTreeEnumNext (
    IN      PNODESTRUCT CurrentNode
    )

/*++

Routine Description:

  pBinTreeEnumNext continues an enumeration of a binary tree. It walks the
  tree in sorted order.

Arguments:

  CurrentNode - Specifies the previous node returned by pBinTreeEnumFirst or
                pBinTreeEnumNext.

Return Value:

  Returns the next node in the tree, or NULL if no more items are left to
  enumerate.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT parent;

    if (!CurrentNode) {
        return NULL;
    }

    cur = CurrentNode;

    if (cur->Right != INVALID_OFFSET) {

        cur = GetNodeStruct (cur->Right);

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

        return cur;
    }

    //
    // otherwise, cur has no right child, so we have to
    // move upwards until we find a parent to the right
    // (or we reach top of tree, meaning we are done)
    //

    for (;;) {
        parent = GetNodeStruct (cur->Parent);

        //
        // if has no parent or parent is to right
        //

        if (!parent || parent->Left == GetNodeOffset (cur)) {
            break;
        }

        cur = parent;
    }

    return parent;
}


PLISTELEM
pBinTreeInsertionEnumFirst (
    PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeInsertionEnumFirst begins an enumeration of the nodes inside an
  insertion-ordered tree.  If the tree is not insertion ordered, no items are
  enumerated.  If insertion order was enabled after items had been previously
  added, this enumeration will not return those initial items.

Arguments:

  Tree - Specifies the tree to begin enumeration of

Return Value:

  A pointer to the linked list element, or NULL if no insertion-ordered nodes
  exist in Tree, or NULL if Tree is NULL.

--*/

{
    PNODESTRUCT header;

    if (!Tree) {
        return NULL;
    }

    header = GetNodeStruct (Tree->Root);

    return header ? GetListElem (header->Head) : NULL;
}


PLISTELEM
pBinTreeInsertionEnumNext (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeInsertionEnumNext continues an enumeration of the insertion-ordered
  nodes in a binary tree.

Arguments:

  Elem - Specifies the previously enumerated list element

Return Value:

  A pointer to the next element, or NULL if no more elements exist, or if
  Elem is NULL.

--*/

{
    if (!Elem) {
        return NULL;
    }

    return GetListElem (Elem->Next);
}


UINT
BinTreeEnumFirst (
    IN      UINT TreeOffset,
    OUT     PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumFirst begins an enumeration of the data offsets stored in a
  binary tree. The enumeration is sorted order or insertion order, depending
  on the insertion order setting within the tree.

Arguments:

  TreeOffset - Specifies the binary tree to begin enumeration of.
  Enum       - Receives the offset to the binary tree node.

Return Value:

  The offset to the data associated with the first node, or INVALID_OFFSET if
  the tree is empty.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    if (IsTreeInsertionOrdered (tree)) {
        //
        // tree is insertion-ordered, so get first element in
        // linked list.  enumerator is NODESTRUCT for this elem
        //

        elem = pBinTreeInsertionEnumFirst (tree);

        if (!elem) {

            if (Enum) {
                *Enum = INVALID_OFFSET;
            }

            return INVALID_OFFSET;

        } else {

            if (Enum) {
                *Enum = elem->Node;
            }

            return elem->Data;
        }

    } else {

        //
        // tree is not insertion-ordered, so get leftmost node.
        // enumerator is the offset of this node.
        //

        node = pBinTreeEnumFirst (tree);

        if (Enum) {
            *Enum = GetNodeOffset (node);
        }

        return !node ? INVALID_OFFSET : node->Data;
    }
}


UINT
BinTreeEnumNext (
    IN OUT  PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumNext continues an enumeration started by BinTreeEnumFirst.

Arguments:

  Enum - Specifies the previous node offset, receivies the enumerated node
         offset.

Return Value:

  The offset to the data associated with the next node, or INVALID_OFFSET if
  no more nodes exist in the tree.

--*/

{
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (*Enum == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    node = GetNodeStruct (*Enum);

    if (node->InsertionOrdered) {
        //
        // tree is insertion-ordered,
        // so get next node in list.
        //

        elem = pBinTreeInsertionEnumNext (GetListElem (node->Data));

        if (!elem) {
            *Enum = INVALID_OFFSET;
            return INVALID_OFFSET;
        } else {
            *Enum = elem->Node;
            return elem->Data;
        }

    } else {
        //
        // tree is not insertion-ordered,
        // so get next node in tree.
        //
        node = pBinTreeEnumNext (node);

        *Enum = GetNodeOffset (node);
        return !node ? INVALID_OFFSET : node->Data;
    }
}



PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocNode allocates a node in the current global database, and
  returns the offset and pointer to that node.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the newly created node.

Return Value:

  A pointer to the newly created node.

--*/

{
    PNODESTRUCT node;
    UINT tempOffset;

    MYASSERT (g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeNodeDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (NODESTRUCT_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG
        if (g_UseDebugStructs) {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
            node->Signature = NODESTRUCT_SIGNATURE;
        } else {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset - NODESTRUCT_HEADER_SIZE);
        }
#else
        node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeNodeDeleted;
        node = GetNodeStruct(*Offset);
        g_CurrentDatabase->FirstBinTreeNodeDeleted = node->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        node->Deleted = FALSE;
    }
#endif

    return node;
}


VOID
pBinTreeFreeNode (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeFreeNode puts an allocated node on the deleted list.  It does not
  adjust any other linkage.

Arguments:

  Node - Specifies the node to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Node);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Node->Signature == NODESTRUCT_SIGNATURE);
        Node->Deleted = TRUE;
    }
#endif

    MYASSERT(g_CurrentDatabase);

    Node->NextDeleted = g_CurrentDatabase->FirstBinTreeNodeDeleted;
    g_CurrentDatabase->FirstBinTreeNodeDeleted = GetNodeOffset(Node);
}


PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocTree creates a binary tree data structure. If a structure
  is available in the detele list, then it is used.  Otherwise, the
  database grows.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the binary tree.

Return Value:

  A pointer to the new binary tree structure.

--*/

{
    PBINTREE tree;
    UINT tempOffset;

    MYASSERT(g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (BINTREE_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG
        if (g_UseDebugStructs) {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset);
            tree->Signature = BINTREE_SIGNATURE;
        } else {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset - BINTREE_HEADER_SIZE);
        }
#else
        tree = (PBINTREE)OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeDeleted;
        tree = GetBinTree (*Offset);
        g_CurrentDatabase->FirstBinTreeDeleted = tree->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        tree->Deleted = FALSE;
    }
#endif

    return tree;
}


VOID
pBinTreeFreeTree (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeFreeTree frees a binary tree structure.  It does not free the nodes
  within the structure.

Arguments:

  Tree - Specifies the binary tree structure to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT (Tree);
    MYASSERT (g_CurrentDatabase);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        Tree->Deleted = TRUE;
        MYASSERT (Tree->Signature == BINTREE_SIGNATURE);
    }
#endif

    Tree->NextDeleted = g_CurrentDatabase->FirstBinTreeDeleted;
    g_CurrentDatabase->FirstBinTreeDeleted = GetTreeOffset (Tree);
}


PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocListElem allocates a list element. If an element is available
  in the deleted list, it is used.  Otherwise, a new element is allocated
  from the database.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receives the offset of the newly allocated element

Return Value:

  A pointer to the allocated list element

--*/

{
    PLISTELEM elem;
    UINT tempOffset;

    MYASSERT (g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeListElemDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (LISTELEM_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG

        if (g_UseDebugStructs) {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
            elem->Signature = LISTELEM_SIGNATURE;
        } else {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset - LISTELEM_HEADER_SIZE);
        }

#else
        elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeListElemDeleted;
        elem = GetListElem (*Offset);
        g_CurrentDatabase->FirstBinTreeListElemDeleted = elem->NextDeleted;
    }

    return elem;
}


VOID
pBinTreeFreeListElem (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeFreeListElem puts an allocated list element on the deleted element
  list, so it will be reused in a future allocation.

Arguments:

  Elem - Specifies the element to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Elem);
    MYASSERT(g_CurrentDatabase);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Elem->Signature == LISTELEM_SIGNATURE);
    }
#endif

    Elem->NextDeleted = g_CurrentDatabase->FirstBinTreeListElemDeleted;
    g_CurrentDatabase->FirstBinTreeListElemDeleted = GetListElemOffset(Elem);
}


VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeBalanceUpward makes sure that the specified node is balanced. If it
  is not balanced, the nodes are rotated as necessary, and balancing
  continues up the tree.

Arguments:

  Node - Specifies the node to balance

  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT next;

    cur = Node;

    //
    // Move up tree.  stop if:
    //      a) hit top of tree
    //      b) pBinTreeNodeBalance returns FALSE (nothing changed)
    //

    while (cur) {
        //
        // need to grab cur's parent before balancing
        // cur because cur might change place in tree
        //

        next = GetNodeStruct (cur->Parent);

        if (!pBinTreeNodeBalance (cur, TreeOffset)) {
            return;
        }

        cur = next;
    }
}


BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeNodeBalance checks the balance of the specified node, and if
  necessary, performs a rotation to balance the node. If a rotation was
  performed, the parent might become imbalanced.

Arguments:

  Node       - Specifies the node to balance
  TreeOffset - Specifies the offset to the binary tree that contains Node

Return Value:

  TRUE if a rotation was performed, FALSE if Node is already balanced

--*/

{
    UINT left;
    UINT right;
    PNODESTRUCT leftNode;
    PNODESTRUCT rightNode;

    if (!Node) {
        return FALSE;
    }

    leftNode  = GetNodeStruct (Node->Left);
    rightNode = GetNodeStruct (Node->Right);

    if (!rightNode) {
        right = 0;
    } else {
        right = MAX (rightNode->RightDepth, rightNode->LeftDepth) + 1;
    }

    if (!leftNode) {
        left = 0;
    } else {
        left = MAX (leftNode->RightDepth, leftNode->LeftDepth) + 1;
    }

    if (right == Node->RightDepth && left == Node->LeftDepth) {
        //
        // if node values have not changed, node is balanced
        //
        TESTNODETREE(Node);
        return FALSE;
    }

    MYASSERT (right < 126);
    MYASSERT (left < 126);

    Node->RightDepth = (WORD) right;
    Node->LeftDepth  = (WORD) left;

    if (Node->RightDepth > (Node->LeftDepth + 1)) {
        //
        // right heavy
        //

        pBinTreeRotateLeft (Node, TreeOffset);

    } else if (Node->LeftDepth > (Node->RightDepth + 1)) {
        //
        // left heavy
        //

        pBinTreeRotateRight (Node, TreeOffset);
    }

    return TRUE;
}


VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateLeft performs a left rotation on Node, moving one node
  from the right side to the left side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT right;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Right != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent     = GetNodeStruct (Node->Parent);

    right = GetNodeStruct (Node->Right);

    //
    // make sure right side is heavier on outside
    //

    if (right->LeftDepth > right->RightDepth) {
        pBinTreeRotateRight (right, TreeOffset);
        PTR_WAS_INVALIDATED(right);
    }

    newRootOffset = Node->Right;
    newRoot = GetNodeStruct (newRootOffset);

    Node->Right = newRoot->Left;
    if (newRoot->Left != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Left)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;
    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Left = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);
}


VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateRight performs a right rotation on Node, moving one node from
  the left side to the right side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT left;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Left != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent = GetNodeStruct (Node->Parent);

    left = GetNodeStruct (Node->Left);

    //
    // make sure left side is heavier on outside
    //

    if (left->RightDepth > left->LeftDepth) {
        pBinTreeRotateLeft (left, TreeOffset);
        PTR_WAS_INVALIDATED (left);
    }

    newRootOffset = Node->Left;
    newRoot = GetNodeStruct (newRootOffset);
    Node->Left = newRoot->Right;

    if (newRoot->Right != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Right)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;

    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Right = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);

}


BOOL
BinTreeSetInsertionOrdered (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSetInsertionOrdered transforms a binary tree into an
  insertion-ordered link list.

Arguments:

  TreeOffset - Specifies the binary tree to make insertion-ordered

Return Value:

  TRUE if the tree was changed, FALSE if TreeOffset is not valid.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PNODESTRUCT root;
    PNODESTRUCT header;
    PLISTELEM elem;
    PLISTELEM prevElem;
    UINT headerOffset;
    UINT offset;
    UINT nodeOffset;
    PBYTE buf;

    MYASSERT (g_CurrentDatabase);

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // This is to test if allocations move buffer
    //
    buf = g_CurrentDatabase->Buf;

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        return TRUE;
    }

    header = pBinTreeAllocNode (&headerOffset);
    if (!header) {
        return FALSE;
    }

    if (buf != g_CurrentDatabase->Buf) {
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(root);

        tree = GetBinTree (TreeOffset);
        root = GetNodeStruct (tree->Root);
        buf = g_CurrentDatabase->Buf;
    }

    INCTREENODES(tree);

    header->InsertionOrdered = TRUE;
    header->InsertionHead = TRUE;
    header->Data = tree->Root;
    header->Head = INVALID_OFFSET;
    header->Tail = INVALID_OFFSET;
    header->Parent = INVALID_OFFSET;
    tree->Root = headerOffset;

    if (root) {
        //
        // There is at least one node in tree, so create LISTELEMs
        //

        node = pBinTreeEnumFirst (tree);

        do {
            nodeOffset = GetNodeOffset (node);

            elem = pBinTreeAllocListElem (&offset);
            if (!elem) {
                return FALSE;
            }

            if (buf != g_CurrentDatabase->Buf) {
                PTR_WAS_INVALIDATED(tree);
                PTR_WAS_INVALIDATED(root);
                PTR_WAS_INVALIDATED(header);
                PTR_WAS_INVALIDATED(node);

                tree = GetBinTree (TreeOffset);
                header = GetNodeStruct (headerOffset);
                node = GetNodeStruct (nodeOffset);

                buf = g_CurrentDatabase->Buf;
            }

            INCTREEELEMS(tree);

            //
            // Update header element pointers
            //
            if (header->Head == INVALID_OFFSET) {
                header->Head = offset;
            }

            if (header->Tail != INVALID_OFFSET) {
                prevElem = GetListElem (header->Tail);
                prevElem->Next = offset;
            }

            header->Tail = offset;

            //
            // Set new LISTELEM members, and corresponding node members
            //

            elem->Data = node->Data;
            elem->Node = nodeOffset;
            elem->Next = INVALID_OFFSET;
            node->Data = offset;

            node->InsertionOrdered = 1;

            node = pBinTreeEnumNext (node);

        } while (node);
    }

    return TRUE;
}


UINT
pBinTreeSize (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeSize computes the number of nodes indicated by Node and all of its
  children.

Arguments:

  Node - Specifies the node to find the size of.

Return Value:

  The number of nodes represented by Node and its children.

--*/

{
    if (!Node) {
        return 0;
    }

    return (pBinTreeSize (GetNodeStruct (Node->Left)) ? 1 : 0) +
           (pBinTreeSize (GetNodeStruct (Node->Right)) ? 1 : 0) + 1;
}


UINT
BinTreeSize (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSize returns the total number of nodes in the specified binary tree

Arguments:

  TreeOffset - Specifies the offset to the binary tree

Return Value:

  The number of nodes in the binary tree

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeSize (GetTreeRoot (tree));
}

#ifdef DEBUG


INT
pBinTreeMaxDepth (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeMaxDepth returns the number of nodes in the longest path. This
  function is used to find out how deep the tree is.

  This routine is recursive.

Arguments:

  Node - Specifies the node to compute the depth of.

Return Value:

  The number of nodes in the deepest path.

--*/

{
    INT leftDepth, rightDepth;

    if (Node == NULL) {
        return 0;
    }

    leftDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Left));
    rightDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Right));

    return MAX (leftDepth, rightDepth) + 1;
}


INT
BinTreeMaxDepth (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeMaxDepth returns the total depth of the specified tree

Arguments:

  TreeOffset - Specifies the tree to compute the depth of

Return Value:

  The depth of the tree (in levels)

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeMaxDepth (GetTreeRoot (tree));
}


BOOL
pBinTreeCheckBalanceOfNode (
    IN      PNODESTRUCT Node,
    OUT     PINT Depth
    )

/*++

Routine Description:

  pBinTreeCheckBalanceOfNode verifies Node is balanced, and all of its
  children are also balanced.

  This function is recursive.

Arguments:

  Node - Specifies the node to check
  Depth - Receives the depth of the node

Return Value:

  TRUE if the node is balanced, FALSE otherwise

--*/

{
    INT lDepth = 0;
    INT rDepth = 0;
    BOOL flag = TRUE;

    if (!Node) {
        if (Depth) {
            *Depth = 0;
        }

        return TRUE;
    }

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Left), &lDepth);
    MYASSERT (flag);

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Right), &rDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->LeftDepth == lDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->RightDepth == rDepth);
    MYASSERT (flag);

    if (Depth != NULL) {
        *Depth = MAX (lDepth, rDepth) + 1;
    }

    flag = flag && (ABS ((lDepth - rDepth)) <= 1);
    MYASSERT (flag);

    return flag;
}


BOOL
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeCheckBalance checks the balance of Node

Arguments:

  Node - Specifies the node to check the balance of

Return Value:

  TRUE if Node is balanced, FALSE otherwise.

--*/

{
    return pBinTreeCheckBalanceOfNode (Node, NULL);
}


BOOL
pBinTreeCheck (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeCheck checks if the binary tree is sorted and linked properly.  It
  enumerates the binary tree structure and compares the strings for proper
  order. If the tree is sorted properly, then the balance is checked.

Arguments:

  Tree - Specifies the tree to check

Return Value:

  TRUE if the binary tree is correct, FALSE otherwise.

--*/

{
    BOOL flag;
    PNODESTRUCT cur;
    PNODESTRUCT prev;

    prev = pBinTreeEnumFirst (Tree);

    if (Tree) {

        cur = pBinTreeEnumNext (prev);

        while (cur) {

            flag = (StringPasICompare (GetNodeDataStr(prev), GetNodeDataStr(cur)) < 0);
            MYASSERT(flag);

            if (!flag) {
                return FALSE;
            }

            prev = cur;
            cur = pBinTreeEnumNext (prev);
        }
    }

    return pBinTreeCheckBalance (GetTreeRoot (Tree));
}


BOOL
BinTreeCheck (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeCheck makes sure the specified binary tree is sorted and balanced
  properly

Arguments:

  TreeOffset - Specifies the offset of the tree to check

Return Value:

  TRUE if the tree is sorted properly, FALSE otherwise.

--*/

{
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);

    return pBinTreeCheck (tree);
}





#include <stdio.h>
#include <math.h>

void indent (
    IN      UINT size)
{
    UINT i;
    for (i = 0; i < size; i++)
        wprintf (L" ");
}

INT turn (
    IN      UINT num,
    IN      UINT sel,
    IN      UINT width
    )
{
    UINT temp = num;

    MYASSERT (width > sel);

    if ((temp >> (width-sel-1)) & 1)
        return 1;
    else
        return -1;
}

#define SCREENWIDTH     64

void BinTreePrint(UINT TreeOffset)
{
    PNODESTRUCT cur;
    UINT i,j;
    UINT level=0;
    UINT numnodes,spacing;
    BOOL printed;
    PBINTREE tree;
    PWSTR str;
    UINT strsize,stringlen;
    tree = GetBinTree(TreeOffset);

    if (!GetTreeRoot(tree)) return;

    while (level<31)
    {
        printed=FALSE;

        if (level == 0) {
            numnodes = 1;
        } else {
            numnodes = (UINT)pow ((double)2, (double)level);
        }

        spacing=SCREENWIDTH / numnodes;

        for (i=0;i<numnodes;i++)
        {
            cur = GetTreeRoot(tree);
            j=0;
            while (j<level && cur!=NULL)
            {
                if (turn(i,j,level)<0)
                    cur = GetNodeStruct(cur->Left);
                else
                    cur = GetNodeStruct(cur->Right);
                j++;
            }

            if (cur==NULL) {
                indent(spacing);
            } else {
                str=GetNodeDataStr(cur);
                strsize=StringPasCharCount(str);
                StringPasConvertFrom(str);
                printed=TRUE;
                if (cur->LeftDepth==0 && cur->RightDepth==0) {
                    stringlen=strsize+1;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s ",str);
                } else {
                    stringlen=strsize+2;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s%1d%1d",str,cur->LeftDepth,cur->RightDepth);
                }
                indent(spacing-((spacing-stringlen)/2)-stringlen);
                StringPasConvertTo(str);
            }
        }

        wprintf(L"\n");
        if (!printed)
            break;
        level++;
    }
}



UINT BinTreeGetSizeOfStruct(DWORD Signature)
{
    switch (Signature)
    {
    case NODESTRUCT_SIGNATURE:
        return NODESTRUCT_SIZE;
    case BINTREE_SIGNATURE:
        return BINTREE_SIZE;
    case LISTELEM_SIGNATURE:
        return LISTELEM_SIZE;
    default:
        return 0;
    }
}


BOOL pBinTreeFindTreeInDatabase(UINT TreeOffset)
{
    PBINTREE Tree;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (TreeOffset==INVALID_OFFSET)
        return FALSE;

    Tree=GetBinTree(TreeOffset);

    if (Tree->Deleted) {
        return TRUE;
    }

    if (!GetTreeRoot(Tree)) {
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Binary tree at offset 0x%08lX is Empty!",
            TreeOffset
            ));
        return FALSE;
    }

    return BinTreeFindStructInDatabase(NODESTRUCT_SIGNATURE, GetNodeOffset(GetTreeRoot(Tree)));
}

BOOL pBinTreeFindNodeInDatabase(UINT NodeOffset)
{
    UINT Index;
    PNODESTRUCT Node;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (NodeOffset == INVALID_OFFSET)
        return FALSE;

    Node=GetNodeStruct(NodeOffset);
    if (Node->Deleted || Node->InsertionHead) {
        return TRUE;
    }

    Index = GetNodeData(Node);

    if (Index==INVALID_OFFSET) {

        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Data of Node at offset 0x%8lX is Invalid!",
            NodeOffset
            ));
        return FALSE;
    }

    return FindKeyStructInDatabase(KeyIndexToOffset(Index));
}


BOOL BinTreeFindStructInDatabase(DWORD Sig, UINT Offset)
{
    switch (Sig)
    {
    case NODESTRUCT_SIGNATURE:
        return (pBinTreeFindNodeInDatabase(Offset));
    case BINTREE_SIGNATURE:
        return (pBinTreeFindTreeInDatabase(Offset));
    case LISTELEM_SIGNATURE:
        return TRUE;
    default:
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Invalid BinTree Struct!"
            ));
        printf("Invalid BinTree struct!\n");
    }
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\keystruct.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keystruct.c

Abstract:

    Routines that manage the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  major restructuring
    jimschm     30-Dec-1998  Hacked in AVL balancing
    jimschm     23-Sep-1998  Proxy nodes, so MemDbMoveTree can replace end nodes too
    jimschm     29-May-1998  Ability to replace center nodes in key strings
    jimschm     21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"
#include "bintree.h"

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalKeys = 0;

UINT
pAllocKeyStruct (
    IN     PCWSTR KeyName,
    IN     UINT PrevLevelIndex
    )
/*++

Routine Description:

  pAllocKeyStruct allocates a block of memory in the single
  heap, expanding it if necessary.

  The KeyName must not already be in the tree, and
  PrevLevelIndex must point to a valid UINT Index
  variable.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyName - The string identifying the key.  It cannot
            contain backslashes.  The new struct will
            be initialized and this name will be copied
            into the struct.

  PrevLevelIndex - Specifies the previous level root Index

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT KeyStruct = NULL;
    UINT Offset;
    UINT PrevDel;
    UINT TreeOffset;
    UINT Index;

    MYASSERT (g_CurrentDatabase);

    size = SizeOfStringW (KeyName) + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //

    PrevDel = INVALID_OFFSET;
    Offset = g_CurrentDatabase->FirstKeyDeleted;

    while (Offset != INVALID_OFFSET) {
        KeyStruct = GetKeyStructFromOffset(Offset);
        MYASSERT(KeyStruct);
        if (KeyStruct->Size >= size && KeyStruct->Size < (size + ALLOC_TOLERANCE)) {
            break;
        }

        PrevDel = Offset;
        Offset = KeyStruct->NextDeleted;
    }

    if (Offset == INVALID_OFFSET) {
        //
        // Alloc new block if no free space
        //

        g_TotalKeys ++;

        Offset = DatabaseAllocBlock (size);
        if (Offset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
            KeyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
#endif

        KeyStruct->Size = size;
    } else {
        //
        // Delink free block if recovering free space
        //

        if (PrevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset(PrevDel)->NextDeleted = KeyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = KeyStruct->NextDeleted;
        }
#ifdef DEBUG
        KeyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    KeyStruct->DataStructIndex = INVALID_OFFSET;
    KeyStruct->NextLevelTree = INVALID_OFFSET;
    KeyStruct->PrevLevelIndex = PrevLevelIndex;
    KeyStruct->Value = 0;
    KeyStruct->KeyFlags = 0;
    KeyStruct->DataFlags = 0;
    StringPasCopyConvertTo (KeyStruct->KeyName, KeyName);

    Index = AddKeyOffsetToBuffer(Offset);

    //
    // Put it in the tree
    //
    TreeOffset = (KeyStruct->PrevLevelIndex == INVALID_OFFSET) ?
                    g_CurrentDatabase->FirstLevelTree :
                    GetKeyStruct(KeyStruct->PrevLevelIndex)->NextLevelTree;
    if (TreeOffset == INVALID_OFFSET) {
        TreeOffset = BinTreeNew();
        if (TreeOffset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }


        if (PrevLevelIndex == INVALID_OFFSET) {
            g_CurrentDatabase->FirstLevelTree = TreeOffset;
        } else {
            GetKeyStruct(PrevLevelIndex)->NextLevelTree = TreeOffset;
        }
    }
    if (!BinTreeAddNode(TreeOffset, Index)) {
        return INVALID_OFFSET;
    }

    return Index;
}
//lint -restore

UINT
pNewKey (
    IN  PCWSTR KeyStr,
    IN  BOOL Endpoint
    )

/*++

Routine Description:

  NewKey allocates a key struct off our heap, and links it into the binary
  tree.  KeyStr must be a full key path, and any part of the path that does
  not exist will be created.  KeyStr must not already exist (though parts
  of it can exist).

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The full path to the value, separated by backslashes.
           Each string between backslashes will cause a key
           struct to be allocated and linked.  Some of the
           structs may already have been allocated.

  Endpoint - Specifies TRUE if new node is an endpoint, or FALSE if
             it is not.

Return Value:

  An Index to the last node of the new structure, or
  INVALID_OFFSET if the key could not be allocated.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, ThisLevelTree;
    PKEYSTRUCT KeyStruct;
    UINT PrevLevelIndex;
    BOOL NewNodeCreated = FALSE;

    MYASSERT (g_CurrentDatabase);

    StringCopyW (Path, KeyStr);
    End = Path;
    ThisLevelTree = g_CurrentDatabase->FirstLevelTree;
    PrevLevelIndex = INVALID_OFFSET;

    do  {
        // Split string at backslash
        Start = End;
        p = wcschr (End, L'\\');
        if (p) {
            End = p + 1;
            *p = 0;
        }
        else
            End = NULL;

        // Look in tree for key
        if (!NewNodeCreated) {
            Index = FindKeyStructInTree (ThisLevelTree, Start, FALSE);
        } else {
            Index = INVALID_OFFSET;
        }

        if (Index == INVALID_OFFSET) {
            // Add a new key if it was not found
            Index = pAllocKeyStruct (Start, PrevLevelIndex);
            if (Index == INVALID_OFFSET) {
                return INVALID_OFFSET;
            }


            NewNodeCreated = TRUE;
        }

        // Continue to next level
        KeyStruct = GetKeyStruct (Index);
        PrevLevelIndex = Index;
        ThisLevelTree = KeyStruct->NextLevelTree;
    } while (End);

    if (Endpoint) {
        if (!(KeyStruct->KeyFlags & KSF_ENDPOINT)) {
            NewNodeCreated = TRUE;
        }

        KeyStruct->KeyFlags |= KSF_ENDPOINT;

        if (NewNodeCreated) {
            (void)AddHashTableEntry (g_CurrentDatabase->HashTable, KeyStr, Index);
        }
    }
    return Index;
}

UINT
NewKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates a new key that is an endpoint.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates an empty new key that is NOT an endpoint.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}






VOID
pRemoveKeyFromTree (
    IN      PKEYSTRUCT pKey
    )
{
    BOOL LastNode;
    PUINT pTreeOffset;

    MYASSERT(pKey);
    MYASSERT (g_CurrentDatabase);

    if (pKey->PrevLevelIndex==INVALID_OFFSET) {
        pTreeOffset = &g_CurrentDatabase->FirstLevelTree;
    } else {
        pTreeOffset = &GetKeyStruct(pKey->PrevLevelIndex)->NextLevelTree;
    }

    MYASSERT(*pTreeOffset!=INVALID_OFFSET);
    BinTreeDeleteNode (*pTreeOffset, pKey->KeyName, &LastNode);
    if (LastNode) {
        BinTreeDestroy(*pTreeOffset);
        *pTreeOffset = INVALID_OFFSET;
    }
}


VOID
pDeallocKeyStruct (
    IN      UINT Index,
    IN      BOOL ClearFlag,
    IN      BOOL DelinkFlag,
    IN      BOOL FreeIndexFlag
    )

/*++

Routine Description:

  pDeallocKeyStruct first deletes all structures pointed to by
  NextLevelTree.  After all items are deleted from the next
  level, pDeallocKeyStruct optionally delinks the struct from
  the binary tree.  Before exiting, the struct is given to the
  deleted block chain.

Arguments:

  Index       - An index in g_CurrentDatabase->OffsetBuffer
  ClearFlag   - Specifies TRUE if the key struct's children are to
                be deleted, or FALSE if the current key struct should
                simply be cleaned up but left allocated.
  DelinkFlag  - A flag indicating TRUE to delink the struct from
                the binary tree it is in, or FALSE if the struct is
                only to be added to the deleted block chain.
  FreeIndexFlag - This argument is only used if ClearFlag is true.
                It is FALSE if we do not want to free the index in
                g_CurrentDatabase->OffsetBuffer (i.e., we are moving the key and we do
                not want to deallocate the space in the buffer), or
                TRUE if we are just deleting the key, so we no longer
                need the g_CurrentDatabase->OffsetBuffer space at Index.

Return Value:

  none

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex, TreeEnum;
    WCHAR TempStr[MEMDB_MAX];
    PUINT linkageList;
    UINT linkageSize;
    BYTE instance;
    BYTE oldDbIndex;

    MYASSERT (g_CurrentDatabase);

    KeyStruct = GetKeyStruct (Index);

    if (FreeIndexFlag && (KeyStruct->DataFlags & DATAFLAG_DOUBLELINK)) {
        //
        // we have some double linkage here. Let's go to the other
        // key and remove the linkage that points to this one
        //

        for (instance = 0; instance <= DATAFLAG_INSTANCEMASK; instance ++) {

            // First, retrieve the linkage list
            linkageSize = 0;
            linkageList = (PUINT) KeyStructGetBinaryData (
                                        Index,
                                        DATAFLAG_DOUBLELINK,
                                        instance,
                                        &linkageSize,
                                        NULL
                                        );
            if (linkageList) {

                oldDbIndex = g_CurrentDatabaseIndex;

                while (linkageSize) {

                    SelectDatabase (GET_DATABASE (*linkageList));

                    KeyStructDeleteLinkage (
                        GET_INDEX (*linkageList),
                        DATAFLAG_DOUBLELINK,
                        instance,
                        GET_EXTERNAL_INDEX (Index),
                        FALSE
                        );

                    linkageSize -= SIZEOF (UINT);
                    linkageList ++;

                    if (linkageSize < SIZEOF (UINT)) {
                        break;
                    }
                }

                SelectDatabase (oldDbIndex);
            }
        }
    }

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        //
        // Remove endpoints from hash table and free key data
        //
        if (PrivateBuildKeyFromIndex (0, Index, TempStr, NULL, NULL, NULL)) {
            RemoveHashTableEntry (g_CurrentDatabase->HashTable, TempStr);
        }

        KeyStructFreeAllData (KeyStruct);
        KeyStruct->KeyFlags &= ~KSF_ENDPOINT;
    }

    if (ClearFlag) {
        //
        // Call recursively if there are sublevels to this key
        //
        if (KeyStruct->NextLevelTree != INVALID_OFFSET) {

            KeyIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

            while (KeyIndex != INVALID_OFFSET) {
                pDeallocKeyStruct (KeyIndex, TRUE, FALSE, FreeIndexFlag);
                KeyIndex = GetNextIndex (&TreeEnum);
            }

            BinTreeDestroy(KeyStruct->NextLevelTree);
        }

        //
        // Remove the item from its binary tree
        //
        if (DelinkFlag) {
            pRemoveKeyFromTree(KeyStruct);
        }

        //
        // Donate block to free space unless caller does not
        // want child structs freed.
        //

        KeyStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset(Index);
#ifdef DEBUG
        KeyStruct->KeyFlags |= KSF_DELETED;
#endif

        // let's empty the keystruct (for better compression)
        ZeroMemory (KeyStruct->KeyName, KeyStruct->Size - KEYSTRUCT_SIZE);

        if (FreeIndexFlag) {
            RemoveKeyOffsetFromBuffer(Index);
        }
    }
}

BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    )

/*++

Routine Description:

  PrivateDeleteKeyByIndex will completely destroy the key struct
  that Index points to (along with all sub-levels. Furthermore,
  it goes back recursively and removes the parent structures as well
  if they no longer have a child (the current one was the only one).

Arguments:

  Index     - Index of the key structure.

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    PKEYSTRUCT keyStruct;
    UINT prevLevelIndex;
    BOOL result = TRUE;

    keyStruct = GetKeyStruct (Index);

    prevLevelIndex = keyStruct->PrevLevelIndex;

    pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);

    if (prevLevelIndex != INVALID_OFFSET) {

        keyStruct = GetKeyStruct (prevLevelIndex);

        if (keyStruct->NextLevelTree != INVALID_OFFSET) {

            result = PrivateDeleteKeyByIndex (prevLevelIndex);
        }
    }

    return result;
}

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    )

/*++

Routine Description:

  DeleteKey takes a key path and puts the key struct in the deleted
  block chain.  Any sub-levels are deleted as well.

Arguments:

  KeyStr     - The full path to the value, separated by backslashes.
  TreeOffset    - A pointer to the level's binary tree root variable.
  MustMatch  - A flag indicating if the delete only applies to
               end points or if any matching struct is to be deleted.
               TRUE indicates only endpoints can be deleted.

Return Value:

  none

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, NextIndex, TreeEnum=INVALID_OFFSET;
    PKEYSTRUCT KeyStruct;

    StringCopyW (Path, KeyStr);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = p + 1;
        *p = 0;

    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Index = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);

    //
    // If this is the last level, delete the matching keys
    // (may need to be endpoints if MustMatch is TRUE)
    //

    if (!End) {
        while (Index != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Index);
            NextIndex = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);

            //
            // If must match and lower levels exist, don't delete, just turn
            // off the endpoint flag
            //

            if (MustMatch && KeyStruct->NextLevelTree != INVALID_OFFSET) {
                // Call to clean up, not to delink or recurse
                pDeallocKeyStruct (Index, FALSE, FALSE, FALSE);
            }

            //
            // Else delete the struct if an endpoint or don't care about
            // endpoints
            //

            else if (!MustMatch || (KeyStruct->KeyFlags & KSF_ENDPOINT)) {
                // Call to free the entire key struct and all children
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            Index = NextIndex;
        }
    }

    //
    // Otherwise recursively examine next level for each match
    //

    else {
        while (Index != INVALID_OFFSET) {
            //
            // Delete all matching subkeys
            //

            NextIndex = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);
            KeyStruct = GetKeyStruct (Index);
            DeleteKey (End, KeyStruct->NextLevelTree, MustMatch);

            //
            // If this is not an endpoint and has no children, delete it
            //

            if (KeyStruct->NextLevelTree == INVALID_OFFSET &&
                !(KeyStruct->KeyFlags & KSF_ENDPOINT)
                ) {
                // Call to free the entire key struct
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            //
            // Continue looking in this level for another match
            //

            Index = NextIndex;
        }
    }

    return TRUE;
}




VOID
pRemoveHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index
    )

/*++

Routine Description:

  pRemoveHashEntriesFromNode removes all hash table entries from all children
  of the specified node.  This function is called recursively.

Arguments:

  Root   - Specifies the root string that corresponds with Index.  This must
           also contain the temporary hive root.
  Index - Specifies the Index of the node to process.  The node and all of
           its children will be removed from the hash table.

Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;

    MYASSERT (g_CurrentDatabase);

    //
    // Remove hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        RemoveHashTableEntry (g_CurrentDatabase->HashTable, Root);

#ifdef DEBUG
        {
            UINT HashIndex;

            HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb move duplicate: %s", Root));
            }
        }
#endif
    }

    //
    // Recurse for all children, removing hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pRemoveHashEntriesForNode (ChildRoot, ChildIndex);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}


VOID
pAddHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index,
    IN      BOOL AddRoot
    )

/*++

Routine Description:

  pAddHashEntriesForNode adds hash table entries for the specified root and
  all of its children.

Arguments:

  Root    - Specifies the root string that corresponds to Index.  This string
            must also include the temporary hive root.
  Index  - Specifies the node Index to begin processing.  The node and all
            of its children are added to the hash table.
  AddRoot - Specifies TRUE if the root should be added to the hash table,
            FALSE otherwise.


Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;
    UINT HashIndex;

    MYASSERT (g_CurrentDatabase);

    //
    // Add hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (AddRoot && KeyStruct->KeyFlags & KSF_ENDPOINT) {

        HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);

        if (HashIndex != Index) {

#ifdef DEBUG
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb duplicate: %s", Root));
            }
#endif

            AddHashTableEntry (g_CurrentDatabase->HashTable, Root, Index);
        }
    }

    //
    // Recurse for all children, adding hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pAddHashEntriesForNode(ChildRoot, ChildIndex, TRUE);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}

#ifdef DEBUG
//
// in non-DEBUG mode, GetKeyStructFromOffset
// and GetKeyStruct are implemented as macros
//

PKEYSTRUCT
GetKeyStructFromOffset (
    IN UINT Offset
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Offset.  The debug version
  checks the signature and validity of each Index.  It is assumed that
  Offset is always valid.

Arguments:

  Offset - Specifies the Offset to the node

Return Value:

  The pointer to the node.

--*/
{
    PKEYSTRUCT KeyStruct;

    MYASSERT (g_CurrentDatabase);

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at offset %u", Offset));
        return NULL;
    }
    if (!g_CurrentDatabase) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }
    if (Offset > g_CurrentDatabase->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in GetKeyStruct (offset %u)", Offset));
        return NULL;
    }

    if (!g_UseDebugStructs) {
        KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset - KEYSTRUCT_HEADER_SIZE);
        return KeyStruct;
    }

    KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset);
    if (KeyStruct->Signature != KEYSTRUCT_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in GetKeyStruct at offset %u!", Offset));
        return NULL;
    }

    return KeyStruct;
}


PKEYSTRUCT
GetKeyStruct (
    IN UINT Index
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Index.  The debug version
  checks the signature and validity of each Index.  It is assumed that Index
  is always valid.

Arguments:

  Index - Specifies the Index to the node

Return Value:

  The pointer to the node.

--*/
{
    UINT Offset;
    if (Index == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at index %u", Index));
        return NULL;
    }

    Offset = KeyIndexToOffset(Index);
    if (Offset == INVALID_OFFSET) {
        return NULL;
    }
    return GetKeyStructFromOffset(Offset);
}


#endif











BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT Chars                     OPTIONAL
    )

/*++

Routine Description:

  PrivateBuildKeyFromIndex generates the key string given an Index.  The
  caller can specify the start level to skip root nodes.  It is assumed that
  TailIndex is always valid.

Arguments:

  StartLevel   - Specifies the zero-based level to begin building the key
                 string.  This is used to skip the root portion of the key
                 string.
  TailIndex    - Specifies the Index to the last level of the key string.
  Buffer       - Receives the key string, must be able to hold MEMDB_MAX
                 characters.
  ValPtr       - Receives the key's value
  UserFlagsPtr - Receives the user flags
  Chars        - Receives the number of characters in Buffer

Return Value:

  TRUE if the key was build properly, FALSE otherwise.

--*/

{
    static UINT Indices[MEMDB_MAX];
    PKEYSTRUCT KeyStruct;
    UINT CurrentIndex;
    UINT IndexEnd;
    UINT IndexStart;
    register PWSTR p;

    //
    // Build string
    //

    IndexEnd = MEMDB_MAX;
    IndexStart = MEMDB_MAX;

    CurrentIndex = TailIndex;
    while (CurrentIndex != INVALID_OFFSET) {
        //
        // Record offset
        //
        IndexStart--;
        Indices[IndexStart] = CurrentIndex;

        //
        // Dec for start level and go to parent
        //
        KeyStruct = GetKeyStruct (CurrentIndex);
        if (!KeyStruct) {
            return FALSE;
        }
        CurrentIndex = KeyStruct->PrevLevelIndex;
    }

    //
    // Filter for "string is not long enough"
    //
    IndexStart += StartLevel;
    if (IndexStart >= IndexEnd) {
        return FALSE;
    }

    //
    // Transfer node's value and flags to caller's variables
    //

    if (ValPtr) {
        KeyStructGetValue (GetKeyStruct(TailIndex), ValPtr);
    }
    if (UserFlagsPtr) {
        KeyStructGetFlags (GetKeyStruct(TailIndex), UserFlagsPtr);
    }

    //
    // Copy each piece of the string to Buffer and calculate character count
    //
    if (Buffer) {
        p = Buffer;
        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            CopyMemory(p, KeyStruct->KeyName + 1, *KeyStruct->KeyName * sizeof(WCHAR));
            p += *KeyStruct->KeyName;
            *p++ = L'\\';
        }
        p--;
        *p = 0;

        if (Chars) {
            *Chars = (UINT)(((UBINT)p - (UBINT)Buffer) / sizeof (WCHAR));
        }

    } else if (Chars) {
        *Chars = 0;

        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            *Chars += StringPasCharCount(KeyStruct->KeyName) + 1;
        }

        *Chars -= 1;
    }

    return TRUE;
}



BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT pKey
    )

/*++
Routine Description:

  KeyStructSetInsertionOrdered sets the enumeration order of the children
  of Key to be in the order they were inserted.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    return BinTreeSetInsertionOrdered(pKey->NextLevelTree);
}





UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    )

/*++

Routine Description:

  GetFirstIndex walks down the left side of the binary tree
  pointed to by TreeOffset, and returns the left-most node.

Arguments:

  TreeOffset    - An offset to the root of the tree
  TreeEnum      - a pointer to a UINT which will hold enumeration
                  information for future calls of GetNextIndex

Return Value:

  An Index to the leftmost structure, or INVALID_OFFSET if the
  root was invalid.

--*/


{
    return BinTreeEnumFirst(TreeOffset, pTreeEnum);
}


UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    )

/*++

Routine Description:

  GetNextIndex traverses the binary tree in order.

Arguments:

  TreeEnum   - Enumerator filled by GetFirstIndex which
               will be changed by this function

Return Value:

  An Index to the next structure, or INVALID_OFFSET if the
  end is reached.

--*/

{
    return BinTreeEnumNext(pTreeEnum);
}



UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    )
{
    if (!pKey) {
        return 0;
    }
    return BinTreeSize(pKey->NextLevelTree);
}



UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    )

/*++

Routine Description:

  FindKeyStructInTree takes a key name and looks for the
  Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes.

Arguments:

  TreeOffset - An offset to the root of the level

  KeyName - The name of the key to find in the binary tree
        (not the full key path; just the name of this level).

  IsPascalString - TRUE if string is in pascal format (char
        count is first WCHAR, no null terminator) otherwise FALSE

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    UINT Index;
    if (!IsPascalString) {
        StringPasConvertTo(KeyName);
    }
    Index = BinTreeFindNode(TreeOffset, KeyName);
    if (!IsPascalString) {
        StringPasConvertFrom(KeyName);
    }
    return Index;
}












#ifdef DEBUG

BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            )
{
    PKEYSTRUCT pKey;
    UINT KeyIndex, TreeEnum;
    WCHAR key[MEMDB_MAX];

    if (TreeOffset==INVALID_OFFSET) {
        return TRUE;
    }
    BinTreeCheck(TreeOffset);

#if MEMDB_VERBOSE
    if (PrevLevelIndex!=INVALID_OFFSET) {
        wprintf(L"children of %.*s:\n",*GetKeyStruct(PrevLevelIndex)->KeyName,GetKeyStruct(PrevLevelIndex)->KeyName+1);
    } else {
        printf("top level children:\n");
    }

    BinTreePrint(TreeOffset);
#endif

    if ((KeyIndex=BinTreeEnumFirst(TreeOffset,&TreeEnum))!=INVALID_OFFSET) {
        do {
            pKey=GetKeyStruct(KeyIndex);

            if (pKey->PrevLevelIndex!=PrevLevelIndex) {
                wprintf(L"MemDbCheckDatabase: PrevLevelIndex of Keystruct %s incorrect!", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

            if (!CheckLevel(pKey->NextLevelTree, KeyIndex)) {
                wprintf(L"Child tree of %s bad!\n", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

        } while ((KeyIndex=BinTreeEnumNext(&TreeEnum))!=INVALID_OFFSET);
    } else {
        printf("MemDbCheckDatabase: non-null binary tree has no children!");
        return FALSE;
    }
    return TRUE;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\keydata.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keydata.c

Abstract:

    Routines that manage data for the memdb key structures.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"






//
// KeyStruct Data Functions
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    )

/*++

Routine Description:

  sets the value for a key

Arguments:

  KeyIndex - index of key
  Value - value to put in key

Return Value:

  TRUE if successful

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    KeyStruct->Value = Value;

    KeyStruct->DataFlags |= DATAFLAG_VALUE;

    return TRUE;
}

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  sets the flags for a key

Arguments:

  KeyIndex      - index of key
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    if (KeyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (ReplaceFlags) {
            KeyStruct->Flags = SetFlags;
        } else {
            KeyStruct->Flags &= ~ClearFlags;
            KeyStruct->Flags |= SetFlags;
        }
    } else {
        KeyStruct->Flags = SetFlags;
        KeyStruct->DataFlags |= DATAFLAG_FLAGS;
    }
    return TRUE;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalData = 0;

UINT
pAllocateNewDataStruct (
    IN      UINT DataSize,
    IN      UINT AltDataSize
    )

/*++

Routine Description:

  pAllocateNewDataStruct allocates a block of memory in the single
  heap, for holding a data structure.

Arguments:

  DataSize       - Size of the binary data that needs to be stored here

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT keyStruct = NULL;
    UINT offset;
    UINT prevDel;
    UINT result;

    MYASSERT (g_CurrentDatabase);

    size = DataSize + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //
    prevDel = INVALID_OFFSET;
    offset = g_CurrentDatabase->FirstKeyDeleted;

    while (offset != INVALID_OFFSET) {
        keyStruct = GetKeyStructFromOffset (offset);
        MYASSERT (keyStruct);
        if ((keyStruct->Size >= size) && (keyStruct->Size < (size + ALLOC_TOLERANCE))) {
            break;
        }

        prevDel = offset;
        offset = keyStruct->NextDeleted;
    }

    if (offset == INVALID_OFFSET) {
        //
        // We could not find one so we need to allocate a new block
        //
        g_TotalData ++;

        offset = DatabaseAllocBlock (size + AltDataSize);
        if (offset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset);
            keyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(offset);
#endif

        keyStruct->Size = size + AltDataSize;
    } else {
        //
        // Delink free block if recovering free space
        //
        if (prevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset (prevDel)->NextDeleted = keyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = keyStruct->NextDeleted;
        }
#ifdef DEBUG
        keyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    keyStruct->DataSize = DataSize;
    keyStruct->DataStructIndex = INVALID_OFFSET;
    keyStruct->NextLevelTree = INVALID_OFFSET;
    keyStruct->PrevLevelIndex = INVALID_OFFSET;
    keyStruct->Flags = 0;
    keyStruct->KeyFlags = KSF_DATABLOCK;
    keyStruct->DataFlags = 0;

    result = AddKeyOffsetToBuffer (offset);

    return result;
}
//lint -restore

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructAddBinaryData adds a certain type of binary data to a key
  if it doesn't exist yet. If it does, the function fails.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct,dataStruct,nextStruct,keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if (found) {
        return INVALID_OFFSET;
    }

    dataIndex = pAllocateNewDataStruct (DataSize, 0);

    if (dataIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);
    prevStruct = GetKeyStruct (prevIndex);
    MYASSERT (prevStruct);

    dataStruct = GetKeyStruct (dataIndex);
    MYASSERT (dataStruct);

    keyStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Instance;
    CopyMemory (dataStruct->Data, Data, DataSize);

    dataStruct->DataStructIndex = prevStruct->DataStructIndex;
    dataStruct->PrevLevelIndex = prevIndex;
    prevStruct->DataStructIndex = dataIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = dataIndex;
    }

    return dataIndex;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryData appends a certain type of binary data to a key
  if it does exist. If it doesn't, the new data is added.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct;
    PKEYSTRUCT dataStruct;
    PKEYSTRUCT keyStruct;
    PKEYSTRUCT nextStruct;
    PKEYSTRUCT newStruct;
    UINT dataIndex;
    UINT newIndex;
    UINT prevIndex;
    BOOL found = FALSE;

    MYASSERT (g_CurrentDatabase);

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevStruct = keyStruct;
    prevIndex = KeyIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevStruct = dataStruct;
        prevIndex = dataIndex;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return KeyStructAddBinaryData (KeyIndex, Type, Instance, Data, DataSize);
    }

    if (dataStruct->Size >= KEYSTRUCT_SIZE + DataSize + dataStruct->DataSize) {

        CopyMemory (dataStruct->Data + dataStruct->DataSize, Data, DataSize);
        dataStruct->DataSize += DataSize;
        return dataIndex;

    } else {

        newIndex = pAllocateNewDataStruct (DataSize + dataStruct->DataSize, min (dataStruct->DataSize, 65536));

        if (newIndex == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        // now we need to reget all keystructs used so far because the database
        // might have moved
        keyStruct = GetKeyStruct (KeyIndex);
        MYASSERT (keyStruct);
        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);
        prevStruct = GetKeyStruct (prevIndex);
        MYASSERT (prevStruct);

        newStruct = GetKeyStruct (newIndex);
        MYASSERT (newStruct);

        newStruct->DataSize = dataStruct->DataSize + DataSize;
        newStruct->DataFlags = dataStruct->DataFlags;
        newStruct->DataStructIndex = dataStruct->DataStructIndex;
        newStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
        CopyMemory (newStruct->Data, dataStruct->Data, dataStruct->DataSize);
        CopyMemory (newStruct->Data + dataStruct->DataSize, Data, DataSize);

        prevStruct->DataStructIndex = newIndex;

        if (newStruct->DataStructIndex != INVALID_OFFSET) {
            nextStruct = GetKeyStruct (newStruct->DataStructIndex);
            MYASSERT (nextStruct);
            nextStruct->PrevLevelIndex = newIndex;
        }

        // now simply remove the block
        //
        // Donate block to free space
        //

        dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
        dataStruct->KeyFlags |= KSF_DELETED;
#endif
        // let's empty the keystruct (for better compression)
        ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

        RemoveKeyOffsetFromBuffer (dataIndex);

        return newIndex;
    }
}
//lint -restore

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryDataByIndex appends a certain type of binary data to
  an existing structure identified by OldIndex. The old structure is
  deleted and a new one is allocated holding both old and new data.

Arguments:

  OldIndex  - index of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data index if successfull, INVALID_OFFSET otherwise.

--*/

{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    MYASSERT (g_CurrentDatabase);

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

    if (oldStruct->Size >= KEYSTRUCT_SIZE + DataSize + oldStruct->DataSize) {

        CopyMemory (oldStruct->Data + oldStruct->DataSize, Data, DataSize);
        oldStruct->DataSize += DataSize;
        return OldIndex;

    } else {

        newIndex = pAllocateNewDataStruct (DataSize + oldStruct->DataSize, min (oldStruct->DataSize, 65536));

        if (newIndex == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        // now we need to reget all keystructs used so far because the database
        // might have moved
        oldStruct = GetKeyStruct (OldIndex);
        MYASSERT (oldStruct);

        newStruct = GetKeyStruct (newIndex);
        MYASSERT (newStruct);

        newStruct->DataStructIndex = oldStruct->DataStructIndex;
        newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
        newStruct->DataFlags = oldStruct->DataFlags;
        CopyMemory (newStruct->Data, oldStruct->Data, oldStruct->DataSize);
        CopyMemory (newStruct->Data + oldStruct->DataSize, Data, DataSize);

        prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
        MYASSERT (prevStruct);
        prevStruct->DataStructIndex = newIndex;

        if (newStruct->DataStructIndex != INVALID_OFFSET) {
            nextStruct = GetKeyStruct (newStruct->DataStructIndex);
            MYASSERT (nextStruct);
            nextStruct->PrevLevelIndex = newIndex;
        }

        // now simply remove the block
        //
        // Donate block to free space
        //

        oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
        oldStruct->KeyFlags |= KSF_DELETED;
#endif
        // let's empty the keystruct (for better compression)
        ZeroMemory (oldStruct->Data, oldStruct->Size - KEYSTRUCT_SIZE);

        RemoveKeyOffsetFromBuffer (OldIndex);

        return newIndex;
    }
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructDeleteBinaryData deletes a certain type of binary data from a key
  if it exists. If it doesn't, the function will simply return success.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;
    UINT typeInstances = 0;

    MYASSERT (g_CurrentDatabase);

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        // no such type of data, exiting
        return TRUE;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
            typeInstances ++;
            if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance) {
                found = TRUE;
                //
                // now let's see if we have more instances of this binary type
                //
                if (dataStruct->DataStructIndex != INVALID_OFFSET) {
                    nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
                    if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
                        typeInstances ++;
                    }
                }
                break;
            } else if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance) {
                break;
            }
        } else if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return TRUE;
    }

    // remove the linkage
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = prevIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (dataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        keyStruct->DataFlags &= ~Type;
    }

    return TRUE;
}
//lint -restore

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    )

/*++

Routine Description:

  KeyStructDeleteBinaryDataByIndex deletes a certain type of binary data from a key.

Arguments:

  DataIndex  - index of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    BYTE type = 0;
    UINT typeInstances = 0;

    MYASSERT (g_CurrentDatabase);

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);
    type = dataStruct->DataFlags & DATAFLAG_BINARYMASK;
    typeInstances ++;

    prevStruct = GetKeyStruct (dataStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    if ((prevStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
        typeInstances ++;
    }
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
            typeInstances ++;
        }
        nextStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (DataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (DataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        // first we need to find the key starting with the current database struct
        keyStruct = dataStruct;
        while (keyStruct->KeyFlags & KSF_DATABLOCK) {
            // still a datablock
            if (keyStruct->PrevLevelIndex == INVALID_OFFSET) {
                // something is wrong, the first level is a datablock??
                break;
            }
            keyStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
            MYASSERT (keyStruct);
        }
        if (!(keyStruct->KeyFlags & KSF_DATABLOCK)) {
            keyStruct->DataFlags &= ~type;
        }
    }

    return TRUE;
}

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )
{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    MYASSERT (g_CurrentDatabase);

    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Optimize this by keeping the current structure is big enough.

    newIndex = pAllocateNewDataStruct (DataSize, 0);

    if (newIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

    newStruct = GetKeyStruct (newIndex);
    MYASSERT (newStruct);

    newStruct->DataStructIndex = oldStruct->DataStructIndex;
    newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
    newStruct->DataFlags = oldStruct->DataFlags;
    CopyMemory (newStruct->Data, Data, DataSize);

    prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    prevStruct->DataStructIndex = newIndex;

    if (newStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (newStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = newIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
    oldStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (oldStruct->Data, oldStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (OldIndex);

    return newIndex;
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize,
    OUT     PUINT DataIndex     //OPTIONAL
    )
{
    PKEYSTRUCT dataStruct,keyStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return NULL;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return NULL;
    }

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    if (DataIndex) {
        *DataIndex = dataIndex;
    }

    return dataStruct->Data;
}
//lint -restore

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    )
{
    PKEYSTRUCT dataStruct;

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    return dataStruct->Data;
}

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructGetDataIndex looks for a certain type of data and returns it's index
  if it exists. If it doesn't, the function will simply return INVALID_OFFSET.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  A data index if successfull, INVALID_OFFSET if not.

--*/

{
    PKEYSTRUCT keyStruct, dataStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return INVALID_OFFSET;
    }

    // check to see if we have the data there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }
    if (!found) {
        return INVALID_OFFSET;
    }
    return dataIndex;
}

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &linkSize, &result);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        if (result != INVALID_OFFSET) {
            result = KeyStructGrowBinaryDataByIndex (result, (PBYTE)(&Linkage), SIZEOF (UINT));
        } else {
            result = KeyStructGrowBinaryData (KeyIndex, Type, Instance, (PBYTE)(&Linkage), SIZEOF (UINT));
        }
    }

    return result;
}

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &linkSize);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        result = KeyStructGrowBinaryDataByIndex (DataIndex, (PBYTE)(&Linkage), SIZEOF (UINT));
    } else {
        result = DataIndex;
    }

    return result;
}

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;
    UINT dataIndex;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize, &dataIndex);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                } else {
                    *destArray = *srcArray;
                    newSize += SIZEOF (UINT);
                    destArray ++;
                }
                srcArray ++;
                srcSize -= SIZEOF (UINT);
            }

            if (newSize) {
                result = (KeyStructReplaceBinaryDataByIndex (dataIndex, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryDataByIndex (dataIndex);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                } else {
                    *destArray = *srcArray;
                    newSize += SIZEOF (UINT);
                    destArray ++;
                }
                srcArray ++;
                srcSize -= SIZEOF (UINT);
            }

            if (newSize) {
                result = (KeyStructReplaceBinaryDataByIndex (DataIndex, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryDataByIndex (DataIndex);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize = 0;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize, NULL);

    while (srcSize >= SIZEOF (KEYHANDLE)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (KEYHANDLE);
        srcArray++;
    }
    return result;
}

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    while (srcSize >= SIZEOF (UINT)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (UINT);
        srcArray++;
    }
    return result;
}

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    )
{
    if (!Value) {
        return TRUE;
    }

    if (!(KeyStruct->DataFlags & DATAFLAG_VALUE)) {
        //
        // there is no value, but we still set output to
        // zero and return TRUE
        //
        *Value = 0;
        return TRUE;
    }
    *Value = KeyStruct->Value;

    return TRUE;
}

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    )
{
    if (!Flags) {
        return TRUE;
    }
    if (!(KeyStruct->DataFlags & DATAFLAG_FLAGS)) {
        //
        // there are no flags, but we still set output to
        // zero and return TRUE
        //
        *Flags = 0;
        return TRUE;
    }
    *Flags = KeyStruct->Flags;

    return TRUE;
}



VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    )

/*++

Routine Description:

  KeyStructFreeDataBlock frees a data block and resets the
  the KSF data flags, if the key struct has a data block allocated.

--*/

{
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Reimplement free routine
    //KeyStructFreeData (KeyStruct);
    KeyStruct->Value = 0;
    KeyStruct->Flags = 0;
    KeyStruct->DataFlags &= ~DATAFLAG_VALUE;
    KeyStruct->DataFlags &= ~DATAFLAG_FLAGS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\memdbex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbex.c

Abstract:

    Extensions to use the memdb tree like a relational database

Author:

    Jim Schmidt (jimschm) 2-Dec-1996

Revision History:

    mvander     13-Aug-1999 many changes
    jimschm     23-Sep-1998 Expanded user flags to 24 bits (from
                            12 bits), removed AnsiFromUnicode
    jimschm     21-Oct-1997 Cleaned up a little
    marcw       09-Apr-1997 Added MemDbGetOffset* functions.
    jimschm     17-Jan-1997 All string params can be NULL now
    jimschm     18-Dec-1996 Added GetEndpointValue functions

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\memdbutil.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbutil.c

Abstract:

    MemDb Utility functions

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     xx-xxx-1999  split from memdb.c

--*/

#include "pch.h"

BOOL
MemDbValidateDatabase (
    VOID
    )
{
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Reimplement MemDbValidateDatabase
    return TRUE;
}


/*++

Routine Description:

  MemDbMakeNonPrintableKey converts the double-backslashe pairs in a string
  to ASCII 1, a non-printable character.  This allows the caller to store
  properly escaped strings in MemDb.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakeNonPrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == '\\' &&
                _mbsnextc (_mbsinc (KeyName)) == '\\'
                ) {
                _setmbchar (KeyName, 1);
                KeyName = _mbsinc (KeyName);
                MYASSERT (_mbsnextc (KeyName) == '\\');
                _setmbchar (KeyName, 1);
            }

            DEBUGMSG_IF ((
                _mbsnextc (KeyName) == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == '*') {
                _setmbchar (KeyName, 2);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == '?') {
                _setmbchar (KeyName, 3);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakeNonPrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == L'\\' && KeyName[1] == L'\\') {
                KeyName[0] = 1;
                KeyName[1] = 1;
                KeyName++;
            }

            DEBUGMSG_IF ((
                KeyName[0] == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 2;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 3;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName++;
    }
}


/*++

Routine Description:

  MemDbMakePrintableKey converts the ASCII 1 characters to backslashes,
  restoring the string converted by MemDbMakeNonPrintableKey.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakePrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == 1) {
                _setmbchar (KeyName, '\\');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == 2) {
                _setmbchar (KeyName, '*');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == 3) {
                _setmbchar (KeyName, '?');
            }
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakePrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == 1) {
                KeyName[0] = L'\\';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == 2) {
                KeyName[0] = L'*';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == 3) {
                KeyName[0] = L'?';
            }
        }
        KeyName++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\memdbp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbp.h

Abstract:

    internal functions for memdb operations

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/


//
// Constants
//

#define INVALID_OFFSET      (~((UINT)0))


//
// database types
//
#define DB_NOTHING          0x00
#define DB_PERMANENT        0x01
#define DB_TEMPORARY        0x02

#ifdef DEBUG

#define PTR_WAS_INVALIDATED(x)          (x=NULL)

#else

#define PTR_WAS_INVALIDATED(x)

#endif

//
// signatures for different memory structures.
//
#define KEYSTRUCT_SIGNATURE         ('K'+('E'<<8)+('E'<<16)+('Y'<<24))
#define DATABLOCK_SIGNATURE         ('B'+('L'<<8)+('O'<<16)+('K'<<24))
#define NODESTRUCT_SIGNATURE        ('N'+('O'<<8)+('D'<<16)+('E'<<24))
#define BINTREE_SIGNATURE           ('T'+('R'<<8)+('E'<<16)+('E'<<24))
#define LISTELEM_SIGNATURE          ('L'+('I'<<8)+('S'<<16)+('T'<<24))


#define MEMDB_VERBOSE   0


//
// KEYSTRUCT flags
//

#define KSF_ENDPOINT        0x01
#define KSF_DATABLOCK       0x02

//
// we only need this flag for easier checking
// of keys, in FindKeyStructInDatabase()
//
#ifdef DEBUG
#define KSF_DELETED         0x04
#endif






//
// database allocation parameters
//

#define ALLOC_TOLERANCE 32

#define MAX_HIVE_NAME       64


//
// Typedefs
//

typedef struct {
    UINT Size;
    UINT End;
    UINT FreeHead;
    PBYTE Buf;
} MEMDBHASH, *PMEMDBHASH;



//
//
// The DATABASE structure holds all pieces of information necessary
// to maintain a portion of the overall memory database.  There are
// two DATABASE structures, a permanent and a temporary one.
//

typedef struct {
    UINT AllocSize;
    UINT End;
    UINT FirstLevelTree;
    UINT FirstKeyDeleted;          // this stores the Offset of the key, not the Index
    UINT FirstBinTreeDeleted;
    UINT FirstBinTreeNodeDeleted;
    UINT FirstBinTreeListElemDeleted;
    BOOL AllocFailed;
    PMEMDBHASH HashTable;
    GROWBUFFER OffsetBuffer;
    UINT OffsetBufferFirstDeletedIndex;
    BYTE Buf[];
} DATABASE, *PDATABASE;



//
// Globals - defined in database.c
//

extern PDATABASE g_CurrentDatabase;
extern BYTE g_CurrentDatabaseIndex;
extern CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG
extern BOOL g_UseDebugStructs;
#endif




#define OFFSET_TO_PTR(Offset)   (g_CurrentDatabase->Buf+(Offset))
#define PTR_TO_OFFSET(Ptr)      (UINT)((UBINT)(Ptr)-(UBINT)(g_CurrentDatabase->Buf))



//
// GET_EXTERNAL_INDEX converts an internal index and converts it to a key or data handle (has database number as top byte).
// GET_DATABASE takes a key or data handle and returns the database number byte
// GET_INDEX takes a key or data handle and returns the index without the database number
//
#define GET_EXTERNAL_INDEX(Index) ((Index) | ((UINT)(g_CurrentDatabaseIndex) << (8*sizeof(UINT)-8)))
#define GET_DATABASE(Index) ((BYTE)((Index) >> (8*sizeof(UINT)-8)))
#define GET_INDEX(Index) ((Index) & (INVALID_OFFSET>>8))




//
// a KEYSTRUCT holds each piece of a memdb entry.  A single KEYSTRUCT
// holds a portion of a key (delimited by a backslash), and the
// KEYSTRUCTs are organized into a binary tree.  Each KEYSTRUCT
// can also contain additional binary trees.  This is what makes
// memdb so versatile--many relationships can be established by
// formatting key strings in various ways.
//
// when changing offset of KeyName in KEYSTRUCT (by adding new members
// or resizing or reordering, etc) be sure to change constant in
// GetDataStr macro below (currently (3*sizeof(UINT)+4)).


typedef struct {
#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        UINT Value;                // value of key
        UINT DataSize;             // size of the actual data (if this is a data structure
        UINT NextDeleted;          // for deleted items, we keep a list of free blocks
    };

    UINT Flags;                    // key flags

    UINT DataStructIndex;          // offset of Data structure holding the binary data
    UINT NextLevelTree;            // offset of bintree holding next level keystructs
    UINT PrevLevelIndex;           // index of previous level keystruct

    UINT Size;                     // size of block (maybe not all of it is used)
    BYTE KeyFlags;
    BYTE DataFlags;

    union {
        WCHAR KeyName[];           // name of key (just this level, not full key)
        BYTE Data[];               // Binary data stored in this keystruct
    };
} KEYSTRUCT, *PKEYSTRUCT;

#define KEYSTRUCT_SIZE_MAIN ((WORD)(5*sizeof(UINT) + sizeof(UINT) + 2*sizeof(BYTE)))

#ifdef DEBUG
#define KEYSTRUCT_HEADER_SIZE   sizeof(DWORD)
#define KEYSTRUCT_SIZE      (KEYSTRUCT_SIZE_MAIN + \
                            (WORD)(g_UseDebugStructs ? KEYSTRUCT_HEADER_SIZE : 0))
#else
#define KEYSTRUCT_SIZE      KEYSTRUCT_SIZE_MAIN
#endif

//
// GetDataStr is used by the bintree.c functions to get
// the data string inside a data element, to be used for
// ordering in the tree.  For us, the data type is
// a KeyStruct.
//
#define GetDataStr(DataIndex) ((PWSTR)(OFFSET_TO_PTR(KeyIndexToOffset(DataIndex)+KEYSTRUCT_SIZE)))












//
// hash.c routines
//

PMEMDBHASH
CreateHashBlock (
    VOID
    );

VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    );

BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

UINT
GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    );

BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    );

UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );

BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );



//
// memdbfile.c
//



BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    );

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    );

#define UnmapFileFromHandle(Buf, hMap) UnmapFile(Buf, hMap, INVALID_HANDLE_VALUE)





//
// database.c
//


BOOL
DatabasesInitializeA (
    IN      PCSTR DatabasePath  OPTIONAL
    );

BOOL
DatabasesInitializeW (
    IN      PCWSTR DatabasePath  OPTIONAL
    );

PCSTR
DatabasesGetBasePath (
    VOID
    );

VOID
DatabasesTerminate (
    IN      BOOL EraseDatabasePath
    );

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    );

UINT
DatabaseAllocBlock (
    IN      UINT Size
    );

BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    );

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    );

BYTE
GetCurrentDatabaseIndex (
    VOID
    );

#ifdef DEBUG

BOOL
CheckDatabase (
    IN      UINT Level
    );

#endif


//
// offsetbuf.c
//

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    );

UINT
KeyIndexToOffset (
    IN  UINT Index
    );

UINT
AddKeyOffsetToBuffer(
    IN  UINT Offset
    );

VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    );

VOID
MarkIndexList (
    PUINT IndexList,
    UINT IndexListSize
    );

BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    );



//
// pastring.c
// Pascal-style string: wide characters, first char
//      is number of characters, no null-termination
//

typedef WCHAR * PPASTR;
typedef WCHAR const * PCPASTR;

//
// these convert a WSTR in place from null-terminated
// to Pascal-style strings
//
PPASTR StringPasConvertTo (PWSTR str);
PWSTR StringPasConvertFrom (PPASTR str);

//
// these convert a WSTR from null-terminated
// to Pascal-style strings in new string buffer
//
PPASTR StringPasCopyConvertTo (PPASTR str1, PCWSTR str2);
PWSTR StringPasCopyConvertFrom (PWSTR str1, PCPASTR str2);

PPASTR StringPasCopy (PPASTR str1, PCPASTR str2);
UINT StringPasCharCount (PCPASTR str);

INT  StringPasCompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasMatch (PCPASTR str1, PCPASTR str2);
INT  StringPasICompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasIMatch (PCPASTR str1, PCPASTR str2);


//
// keystrct.c
//

#ifdef DEBUG

PKEYSTRUCT
GetKeyStructFromOffset (
    UINT Offset
    );

PKEYSTRUCT
GetKeyStruct (
    UINT Index
    );

#else

#define GetKeyStructFromOffset(Offset) ((Offset==INVALID_OFFSET) ?          \
                                        NULL :                              \
                                        (PKEYSTRUCT)OFFSET_TO_PTR(Offset))
#define GetKeyStruct(Index)            ((Index==INVALID_OFFSET) ?           \
                                        NULL :                              \
                                        GetKeyStructFromOffset(KeyIndexToOffset(Index)))
#endif



UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    );

UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    );

UINT
NewKey (
    IN  PCWSTR KeyStr
    );

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    );


BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    );

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    );

BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT SizeInChars               OPTIONAL
    );


BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT Key
    );


UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    );

UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    );




#ifdef DEBUG
BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            );
#endif



//
// keyfind.c
//


UINT
FindKeyStruct(
    IN PCWSTR Key
    );

UINT
FindKey (
    IN  PCWSTR FullKeyPath
    );

UINT
FindKeyStructUsingTreeOffset (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR KeyStr
    );

#ifdef DEBUG
BOOL
FindKeyStructInDatabase(
    UINT KeyOffset
    );
#endif


//
// keydata.c
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    );

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    );

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize,
    OUT     PUINT DataIndex     //OPTIONAL
    );

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    );

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    );

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    );

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    );

VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    );







//
// bintree.c
//

#ifdef DEBUG

//
// violating code hiding for easier debugging.
// (only database.c should see bintree functions)
//

UINT
BinTreeGetSizeOfStruct(
    DWORD Signature
    );

BOOL
BinTreeFindStructInDatabase(
    DWORD Sig,
    UINT Offset
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\memdb.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdb.c

Abstract:

    A memory-based database for managing all kinds of data relationships.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     05-Oct-1999  Documentation
    mvander     13-Aug-1999  many changes
    jimschm     23-Sep-1998  Expanded user flags to 24 bits (from 12 bits)
    calinn      12-Dec-1997  Extended MemDbMakePrintableKey and MemDbMakeNonPrintableKey
    jimschm     03-Dec-1997  Added multi-thread synchronization
    jimschm     22-Oct-1997  Split into multiple source files,
                             added multiple memory block capability
    jimschm     16-Sep-1997  Hashing: delete fix
    jimschm     29-Jul-1997  Hashing, user flags added
    jimschm     07-Mar-1997  Signature changes
    jimschm     03-Mar-1997  PrivateBuildKeyFromOffset changes
    jimschm     18-Dec-1996  Fixed deltree bug

--*/

#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

CRITICAL_SECTION g_MemDbCs;
PMHANDLE g_MemDbPool = NULL;
static INT g_Initialized;

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

Routine Description:

  MemDbInitializeEx creates data structures for an initial database.  Calling
  this routine is required.

Arguments:

  None.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

BOOL
MemDbInitializeExA (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    BOOL result = TRUE;

    MYASSERT (g_Initialized >= 0);
    g_Initialized++;

    if (g_Initialized == 1) {

        g_MemDbPool = PmCreateNamedPool ("MemDb");

        if (g_MemDbPool == NULL) {
            return FALSE;
        }

        __try {
            InitializeCriticalSection (&g_MemDbCs);
        } __except (EXCEPTION_CONTINUE_EXECUTION) {
            // Might raise an out of memory exception, but we don't check for that in this function.
            // Ignores
        }


        //
        // If we fail, we don't automatically call MemDbTerminate, because
        // there is an option to MemDbTerminate which we don't know.
        //

        if (!DatabasesInitializeA (DatabasePath)) {
            return FALSE;
        }

        result = FileEnumInitialize ();
    }

    return result;
}

BOOL
MemDbInitializeExW (
    IN      PCWSTR DatabasePath  OPTIONAL
    )
{
    BOOL result = TRUE;

    MYASSERT (g_Initialized >= 0);

    g_Initialized++;

    if (g_Initialized == 1) {

        g_MemDbPool = PmCreateNamedPool ("MemDb");

        if (g_MemDbPool == NULL) {
            return FALSE;
        }

        __try {
            InitializeCriticalSection (&g_MemDbCs);
        } __except (EXCEPTION_CONTINUE_EXECUTION) {
            // Might raise an out of memory exception, but we don't check for that in this function.
            // Ignores
        }

        //
        // If we fail, we don't automatically call MemDbTerminate, because
        // there is an option to MemDbTerminate which we don't know.
        //

        if (!DatabasesInitializeW (DatabasePath)) {
            return FALSE;
        }

        result = FileEnumInitialize ();
    }

    return result;
}

VOID
MemDbTerminateEx (
    IN      BOOL EraseDatabasePath
    )

/*++

Routine Description:

  MemDbTerminateEx frees all resources associated with MemDb
  and, optionally, removes the database directory.
  This routine should be called at process termination.

Arguments:

  None.

Return Value:

  None.

--*/

{
    MYASSERT (g_Initialized > 0);

    g_Initialized--;

    if (!g_Initialized) {

        if (g_MemDbPool) {
            PmDestroyPool (g_MemDbPool);
            g_MemDbPool = NULL;
        }

        DatabasesTerminate (EraseDatabasePath);

        DeleteCriticalSection (&g_MemDbCs);

        FileEnumTerminate ();

    } else if (g_Initialized < 0) {
        //
        // Since we call ourselves, protect callers from over-termination
        //

        g_Initialized = 0;
    }
}

PVOID
MemDbGetMemory (
    IN      UINT Size
    )
{
    MYASSERT (g_MemDbPool);
    return PmGetMemory (g_MemDbPool, Size);
}

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    )
{
    if (Memory) {
        MYASSERT (g_MemDbPool);
        PmReleaseMemory (g_MemDbPool, Memory);
    }
}


KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or NULL if
  not successful.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbAddKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or NULL if not successful.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any other data.
  This is used to reduce the size of the database. If the key exists it will
  return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or NULL if some error
  occurs.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any other data.
  This is used to reduce the size of the database. If the key exists it will
  return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or NULL if some error
  occurs.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            result = GET_EXTERNAL_INDEX (keyIndex);;
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);;
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        result = MemDbDeleteKeyW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyStr);
    if (subKey) {
        result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, TRUE);

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    )

/*++

Routine Description:

  MemDbDeleteKeyByHandle deletes a specific key from the database
  identified by the key handle. It also removes all data associated
  with it.

Arguments:

  KeyHandle - Key Handle identifying the key

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    dbIndex = GET_DATABASE (KeyHandle);
    if (SelectDatabase (dbIndex)) {

        result = PrivateDeleteKeyByIndex (GET_INDEX (KeyHandle));

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteTreeW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteTreeW (
    IN  PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyName);
    if (subKey) {
        result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, FALSE);

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;
    PSTR p;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            result = MemDbGetMemory (keyStruct->KeyName[0] * 2 + 1);
            p = DirectUnicodeToDbcsN (
                    result,
                    keyStruct->KeyName + 1,
                    keyStruct->KeyName[0] * sizeof (WCHAR)
                    );
            *p = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            result = MemDbGetMemory (chars*2+1);
            KnownSizeWtoA (result, wideBuffer);
            __leave;
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PWSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            chars = keyStruct->KeyName[0];
            result = MemDbGetMemory ((chars + 1) * sizeof (WCHAR));
            CopyMemory (result, keyStruct->KeyName + 1, chars * sizeof (WCHAR));
            result[chars] = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                result = MemDbGetMemory ((chars + 1) * sizeof (WCHAR));
                StringCopyW (result, wideBuffer);
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    CHAR ansiBuffer[MEMDB_MAX*2];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                KnownSizeWtoA (ansiBuffer, wideBuffer);
                if (Buffer) {
                    (void)GbCopyStringA (Buffer, ansiBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN      PGROWBUFFER Buffer      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                if (Buffer) {
                    (void)GbCopyStringW (Buffer, wideBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or NULL if the key is not present.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbGetHandleFromKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or NULL if the key is not present.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        //
        // first make sure there is a key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetValueAndFlagsExW (
                    keyNameW,
                    AlterValue,
                    Value,
                    ReplaceFlags,
                    SetFlags,
                    ClearFlags
                    );
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    PCWSTR subKey;
    KEYHANDLE result = 0;
    UINT keyIndex;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        if (AlterValue) {
            if (!KeyStructSetValue (keyIndex, Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (keyIndex, ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        MYASSERT (keyIndex != INVALID_OFFSET);
        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx modifies value and/or flags for an existing key
  identified by KeyHandle.

Arguments:

  KeyHandle     - Identifies an existing key
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (AlterValue) {
            if (!KeyStructSetValue (GET_INDEX (KeyHandle), Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (GET_INDEX (KeyHandle), ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,       OPTIONAL
    OUT     PUINT Flags        OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsA is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetValueAndFlagsW (p, Value, Flags);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsW (
    IN  PCWSTR KeyName,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsW is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (GetKeyStruct (keyIndex), Value);
        result = result && KeyStructGetFlags (GetKeyStruct (keyIndex), Flags);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsByHandle (
    IN  KEYHANDLE KeyHandle,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsByHandle is the external entry point for querying the database
  for a value and flags based on a key handle.

Arguments:

  KeyHandle     - Specifies the key handle to query
  Value         - Recieves the value associated with Key, if KeyHandle exists.
  Flags         - Receives the flags associated with Key, if KeyHandle exists.

Return Value:

  TRUE if KeyHandle exists in the database, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PKEYSTRUCT keyStruct;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
        if (!keyStruct) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (keyStruct, Value);
        result = result && KeyStructGetFlags (keyStruct, Flags);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataHandleW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        dataIndex = KeyStructGetDataIndex (keyIndex, Type, Instance);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbSetDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced, if it doesn't, it is created.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data   handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        KeyStructDeleteBinaryData (keyIndex, Type, Instance);
        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for replacing an existing binary data.

Arguments:

  DataHandle    - Specifies an existing data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!DataHandle) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructReplaceBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }
        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetDataByKeyHandle is the a general purpose routine for setting binary data for a key.
  If this type of data already exists, it is replaced, if it doesn't, it is created.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGrowDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructGrowBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary data for a key.

Arguments:

  DataHandle    - Specifies the existing binary data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructGrowBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary
  data for a key. If the data is not present it is added, if it's present, the
  new data is appended.

Arguments:

  KeyHandle     - Specifies the key we want by it's handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructGrowBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    PCWSTR p;
    PBYTE result = NULL;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataW (p, Type, Instance, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize, NULL);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize                  OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandle is the a general purpose routine for retrieving
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize                      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize, NULL);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataEx is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataExW (p, Type, Instance, Buffer, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize, NULL);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize, NULL);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for removing existing data for a
  key. If the data does not exist the function will return TRUE anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteDataW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbDeleteData is the a general purpose routine for removing existing binary
  data for a key. If the data does not exist the function will return TRUE
  anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteBinaryData (keyIndex, Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteBinaryDataByIndex (GET_INDEX (DataHandle));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddLinkageValueW (p, Type, Instance, Linkage, AllowDuplicates);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddLinkage (keyIndex, Type, Instance, Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddLinkageByIndex (GET_INDEX (DataHandle), Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteLinkageValueW (p, Type, Instance, Linkage, FirstOnly);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteLinkage (keyIndex, Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteLinkageByIndex (GET_INDEX (DataHandle), Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbTestLinkageValueW (p, Type, Instance, Linkage);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructTestLinkage (keyIndex, Type, Instance, Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructTestLinkageByIndex (GET_INDEX (DataHandle), Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructTestLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbAddLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {

            keyIndex1 = NewKey (subKey1);
            if (keyIndex1 == INVALID_OFFSET) {
                __leave;
            }
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {

            keyIndex2 = NewKey (subKey2);
            if (keyIndex2 == INVALID_OFFSET) {
                __leave;
            }
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);
        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            SelectDatabase (dbIndex2);
            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbDeleteLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);
        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbTestLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        result = KeyStructTestLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2));

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            result = KeyStructTestLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1));
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);
        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructTestLinkage (keyIndex1, Type, Instance, KeyHandle2);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructTestLinkage (keyIndex2, Type, Instance, KeyHandle1);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    PCWSTR p = NULL;
    KEYHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetLinkageW (p, Type, Instance, LinkageIndex);
        FreeConvertedStr (p);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;
    PUINT linkArray;
    UINT linkArraySize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        linkArraySize = 0;

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize, NULL);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    BYTE dbIndex;
    KEYHANDLE result = 0;
    PUINT linkArray;
    UINT linkArraySize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyIndex = GET_INDEX (KeyHandle);
        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize, NULL);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
pCheckEnumConditions (
    IN      UINT KeyIndex,
    IN      PMEMDB_ENUMW MemDbEnum
    )
{
    PKEYSTRUCT keyStruct;
    UINT index;
    PWSTR segPtr, segEndPtr;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (keyStruct->KeyFlags & KSF_ENDPOINT) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_ENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = TRUE;
    } else {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_NONENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = FALSE;
    }
    if (keyStruct->DataFlags & DATAFLAG_UNORDERED) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_UNORDERED)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_SINGLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_SINGLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_DOUBLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_DOUBLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_VALUE) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_VALUE)) {
            return FALSE;
        }
        MemDbEnum->Value = keyStruct->Value;
    } else {
        MemDbEnum->Value = 0;
    }
    if (keyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_FLAGS)) {
            return FALSE;
        }
        MemDbEnum->Flags = keyStruct->Flags;
    } else {
        MemDbEnum->Flags = 0;
    }
    if (!keyStruct->DataFlags) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_EMPTY)) {
            return FALSE;
        }
    }
    if (MemDbEnum->BeginLevel != ENUMLEVEL_LASTLEVEL) {
        if (MemDbEnum->CurrentLevel - 1 < MemDbEnum->BeginLevel) {
            return FALSE;
        }
        if (MemDbEnum->CurrentLevel - 1 > MemDbEnum->EndLevel) {
            return FALSE;
        }
    }

    MYASSERT (KeyIndex != INVALID_OFFSET);
    MemDbEnum->KeyHandle = GET_EXTERNAL_INDEX (KeyIndex);

    index = 0;
    segPtr = MemDbEnum->KeyNameCopy;
    MemDbEnum->FullKeyName[0] = 0;
    MemDbEnum->KeyName[0] = 0;

    while (segPtr) {
        segEndPtr = wcschr (segPtr, L'\\');
        if (segEndPtr) {
            *segEndPtr = 0;
        }

        index ++;
        if (index > 1) {
            StringCatW (MemDbEnum->FullKeyName, L"\\");
            StringCatW (MemDbEnum->FullKeyName, segPtr);
        } else {
            switch (g_CurrentDatabaseIndex) {

            case DB_PERMANENT:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);
                break;

            case DB_TEMPORARY:

                StringCopyW (MemDbEnum->FullKeyName, L"~");
                StringCatW (MemDbEnum->FullKeyName, segPtr);
                break;

            default:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);

            }
        }
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            if (index >= MemDbEnum->CurrentLevel) {
                //this is the last segment, copy it to the
                //partial key
                StringCopyW (MemDbEnum->KeyName, segPtr);
            }
        } else {
            if (index > MemDbEnum->BeginLevel) {
                //copy the current segment in partial key
                if ((index - 1) == MemDbEnum->BeginLevel) {
                    if (index == 1) {
                        switch (g_CurrentDatabaseIndex) {

                        case DB_PERMANENT:
                            StringCopyW (MemDbEnum->KeyName, segPtr);
                            break;

                        case DB_TEMPORARY:

                            StringCopyW (MemDbEnum->KeyName, L"~");
                            StringCatW (MemDbEnum->KeyName, segPtr);
                            break;

                        default:
                            StringCopyW (MemDbEnum->KeyName, segPtr);

                        }
                    } else {
                        StringCopyW (MemDbEnum->KeyName, segPtr);
                    }
                } else {
                    StringCatW (MemDbEnum->KeyName, L"\\");
                    StringCatW (MemDbEnum->KeyName, segPtr);
                }
            }
        }

        if (segEndPtr) {
            segPtr = segEndPtr + 1;
            *segEndPtr = L'\\';
        } else {
            segPtr = NULL;
        }

        if (index >= MemDbEnum->CurrentLevel) {
            // no more segments to copy
            break;
        }
    }
    return TRUE;
}

VOID
pAddKeyToEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR KeyName
    )
{
    PCWSTR lastName;
    PWSTR endPtr;

    lastName = MemDbEnum->KeyNameCopy;
    if (lastName) {
        MemDbEnum->KeyNameCopy = JoinTextExW (g_MemDbPool, lastName, L"\\", NULL, KeyName[0] + 1, &endPtr);
        StringPasCopyConvertFrom (endPtr, KeyName);
        MemDbReleaseMemory ((PBYTE)lastName);
    } else {
        MemDbEnum->KeyNameCopy = (PWSTR)MemDbGetMemory ((KeyName[0] + 1) * SIZEOF(WCHAR));
        StringPasCopyConvertFrom ((PWSTR)MemDbEnum->KeyNameCopy, KeyName);
    }
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm  this way of doing it will fill out the pool very fast.
    // need to find a way to release first and allocate after that.
}

VOID
pDeleteLastKeyFromEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    PWSTR lastWackPtr;

    lastWackPtr = wcsrchr (MemDbEnum->KeyNameCopy, L'\\');
    if (lastWackPtr) {
        *lastWackPtr = 0;
    } else {
        MemDbReleaseMemory (MemDbEnum->KeyNameCopy);
        MemDbEnum->KeyNameCopy = NULL;
    }
}

BOOL
pMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL shouldReturn = FALSE;
    BOOL result = FALSE;
    BOOL patternMatch = TRUE;
    BOOL goOn = TRUE;
    BOOL patternFound;
    UINT treeEnumContext;
    UINT treeEnumNode;
    UINT tempKeyIndex;
    PKEYSTRUCT tempKeyStruct;
    PBYTE gbAddress;
    UINT minLevel;
    UINT internalLevel;

    while (!shouldReturn) {

        if (MemDbEnum->EnumerationMode) {

            result = FALSE;

            minLevel = MemDbEnum->CurrentLevel;
            internalLevel = MemDbEnum->CurrentLevel;

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {

                patternMatch = FALSE;

                while (!patternMatch) {

                    if (MemDbEnum->TreeEnumBuffer.End) {

                        goOn = TRUE;

                        while (goOn) {
                            // we are in the middle of some tree enumeration
                            // let's get back the context and continue
                            if (MemDbEnum->TreeEnumBuffer.End == 0) {
                                // we can't back out any more, we're done
                                break;
                            }
                            MemDbEnum->TreeEnumBuffer.End -= (SIZEOF(UINT)+SIZEOF(UINT));
                            if (MemDbEnum->TreeEnumLevel > MemDbEnum->TreeEnumBuffer.End) {
                                MemDbEnum->TreeEnumLevel = MemDbEnum->TreeEnumBuffer.End;
                            }
                            minLevel --;
                            if (MemDbEnum->CurrentLevel > minLevel) {
                                MemDbEnum->CurrentLevel = minLevel;
                            }
                            if (internalLevel > minLevel) {
                                internalLevel = minLevel;
                            }
                            pDeleteLastKeyFromEnumStruct (MemDbEnum);
                            treeEnumContext = *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumBuffer.End + SIZEOF(UINT)));
                            tempKeyIndex = BinTreeEnumNext (&treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                goOn = FALSE;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                                while ((treeEnumNode != INVALID_OFFSET) &&
                                       (internalLevel - 1 <= MemDbEnum->EndLevel)
                                       ) {
                                    tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                                    if (tempKeyIndex != INVALID_OFFSET) {
                                        minLevel ++;
                                        internalLevel ++;
                                        // put them in the grow buffer
                                        gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                        if (gbAddress) {
                                            *((PUINT) (gbAddress)) = tempKeyIndex;
                                            *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                        }
                                        tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                        MYASSERT (tempKeyStruct);
                                        pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                        treeEnumNode = tempKeyStruct->NextLevelTree;
                                    } else {
                                        treeEnumNode = INVALID_OFFSET;
                                    }
                                }
                            }
                        }

                    } else {
                        // we are about to start the tree enumeration
                        // let's start the enumeration and push the
                        // context data in our buffer

                        treeEnumNode = MemDbEnum->CurrentIndex;
                        while ((treeEnumNode != INVALID_OFFSET) &&
                               (internalLevel <= MemDbEnum->EndLevel)
                               ) {
                            tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                            } else {
                                treeEnumNode = INVALID_OFFSET;
                            }
                        }
                    }
                    if (MemDbEnum->TreeEnumBuffer.End == 0) {
                        // we can't back out any more, we're done
                        break;
                    }
                    if (MemDbEnum->PatternStruct.PatternMatch) {
                        MYASSERT (MemDbEnum->PatternStruct.Data);
                        patternMatch =
                            MemDbEnum->PatternStruct.PatternMatch (
                                MemDbEnum->PatternStruct.Data,
                                MemDbEnum->KeyNameCopy
                                );
                    } else {
                        patternMatch = IsPatternMatchW (
                                            MemDbEnum->PatternCopy,
                                            MemDbEnum->KeyNameCopy
                                            );
                    }
                }
            }

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {
                break;
            }
            MYASSERT (MemDbEnum->TreeEnumLevel < MemDbEnum->TreeEnumBuffer.End);

            // now implement segment by segment enumeration because we
            // just created a full key that matches the pattern
            MemDbEnum->CurrentLevel ++;
            shouldReturn = pCheckEnumConditions (
                                *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumLevel)),
                                MemDbEnum
                                );
            MemDbEnum->TreeEnumLevel += (SIZEOF(UINT)+SIZEOF(UINT));
            result = TRUE;

        } else {

            result = FALSE;

            if (!MemDbEnum->PatternEndPtr) {
                //we are done, no more segments
                break;
            }

            MemDbEnum->PatternPtr = MemDbEnum->PatternEndPtr;
            MemDbEnum->PatternEndPtr = wcschr (MemDbEnum->PatternPtr, L'\\');
            if (MemDbEnum->PatternEndPtr) {
                *MemDbEnum->PatternEndPtr = 0;
            }

            if (MemDbEnum->PatternStruct.PatternFind) {
                patternFound =
                    MemDbEnum->PatternStruct.PatternFind (
                        MemDbEnum->PatternPtr
                        );
            } else {
                patternFound = (wcschr (MemDbEnum->PatternPtr, L'*') ||
                                wcschr (MemDbEnum->PatternPtr, L'?')
                                );
            }

            if (patternFound) {

                MemDbEnum->EnumerationMode = TRUE;
                if (MemDbEnum->PatternEndPtr) {
                    *MemDbEnum->PatternEndPtr = L'\\';
                    MemDbEnum->PatternEndPtr++;
                }

            } else {
                tempKeyIndex = FindKeyStructInTree (
                                    MemDbEnum->CurrentIndex,
                                    MemDbEnum->PatternPtr,
                                    FALSE
                                    );
                if (tempKeyIndex == INVALID_OFFSET) {
                    // we are done, the segment we look for does not exist
                    break;
                }
                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                MYASSERT (tempKeyStruct);
                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                MemDbEnum->CurrentIndex = tempKeyStruct->NextLevelTree;

                MemDbEnum->CurrentLevel ++;
                if (MemDbEnum->PatternEndPtr) {
                    *MemDbEnum->PatternEndPtr = L'\\';
                    MemDbEnum->PatternEndPtr++;
                }
                patternMatch = IsPatternMatchW (
                                    MemDbEnum->PatternCopy,
                                    MemDbEnum->KeyNameCopy
                                    );
                shouldReturn = patternMatch && pCheckEnumConditions (
                                                    tempKeyIndex,
                                                    MemDbEnum
                                                    );
                result = TRUE;
            }
        }
    }
    return result;
}

BOOL
RealMemDbEnumFirstExW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    )
{
    BOOL result = FALSE;
    PCWSTR subPattern;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subPattern = SelectHiveW (EnumPattern);
        if (!subPattern) {
            __leave;
        }

        ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
        MemDbEnum->CurrentDatabaseIndex = GetCurrentDatabaseIndex ();
        MemDbEnum->EnumFlags = EnumFlags;
        MemDbEnum->PatternCopy = DuplicateTextExW (g_MemDbPool, subPattern, 0, NULL);
        if (!MemDbEnum->PatternCopy) {
            __leave;
        }
        MemDbEnum->PatternPtr = MemDbEnum->PatternCopy;
        MemDbEnum->PatternEndPtr = MemDbEnum->PatternPtr;
        MemDbEnum->CurrentIndex = g_CurrentDatabase->FirstLevelTree;
        MemDbEnum->BeginLevel = BeginLevel;
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            MemDbEnum->EndLevel = ENUMLEVEL_ALLLEVELS;
        } else {
            MemDbEnum->EndLevel = EndLevel;
            if (MemDbEnum->EndLevel < MemDbEnum->BeginLevel) {
                MemDbEnum->EndLevel = MemDbEnum->BeginLevel;
            }
        }
        MemDbEnum->CurrentLevel = 0;

        if (PatternStruct) {
            MemDbEnum->PatternStruct.PatternFind = PatternStruct->PatternFind;
            MemDbEnum->PatternStruct.PatternMatch = PatternStruct->PatternMatch;
            MemDbEnum->PatternStruct.Data = PatternStruct->Data;
        }

        result = pMemDbEnumNextW (MemDbEnum);

        if (!result) {
            MemDbAbortEnumW (MemDbEnum);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
RealMemDbEnumFirstExA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    )
{
    BOOL result = FALSE;
    PCWSTR unicodeStr;

    unicodeStr = ConvertAtoW (EnumPattern);
    if (!unicodeStr) {
        return FALSE;
    }
    result = RealMemDbEnumFirstExW (
                &(MemDbEnum->UnicodeEnum),
                unicodeStr,
                EnumFlags,
                BeginLevel,
                EndLevel,
                PatternStruct
                );
    if (result) {
        KnownSizeWtoA (MemDbEnum->FullKeyName, MemDbEnum->UnicodeEnum.FullKeyName);
        KnownSizeWtoA (MemDbEnum->KeyName, MemDbEnum->UnicodeEnum.KeyName);

        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }

    FreeConvertedStr (unicodeStr);
    return result;
}

BOOL
RealMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        if (!SelectDatabase (MemDbEnum->CurrentDatabaseIndex)) {
            __leave;
        }

        result = pMemDbEnumNextW (MemDbEnum);

        if (!result) {
            MemDbAbortEnumW (MemDbEnum);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
RealMemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    BOOL result = FALSE;

    result = RealMemDbEnumNextW (&(MemDbEnum->UnicodeEnum));
    if (result) {
        KnownSizeWtoA (MemDbEnum->FullKeyName, MemDbEnum->UnicodeEnum.FullKeyName);
        KnownSizeWtoA (MemDbEnum->KeyName, MemDbEnum->UnicodeEnum.KeyName);

        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }

    return result;
}

BOOL
MemDbAbortEnumW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    if (MemDbEnum->KeyNameCopy) {
        MemDbReleaseMemory (MemDbEnum->KeyNameCopy);
    }

    if (MemDbEnum->PatternCopy) {
        MemDbReleaseMemory (MemDbEnum->PatternCopy);
    }

    GbFree (&(MemDbEnum->TreeEnumBuffer));

    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
    return TRUE;
}

BOOL
MemDbAbortEnumA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    MemDbAbortEnumW (&(MemDbEnum->UnicodeEnum));

    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMA));
    return TRUE;
}

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedA sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PCWSTR unicodeKey;
    BOOL b = FALSE;

    unicodeKey = ConvertAtoW (Key);

    if (unicodeKey) {
        b = MemDbSetInsertionOrderedW (unicodeKey);
        FreeConvertedStr (unicodeKey);
    }
    return b;
}

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedW sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (Key);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKeyStruct (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        b = KeyStructSetInsertionOrdered(GetKeyStruct(keyIndex));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbSetInsertionOrderedByKeyHandle (
    IN      KEYHANDLE KeyHandle
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedByKeyHandle sets the enumeration order of the children of
  KeyHandle to be in the order they were inserted.

Arguments:

  KeyHandle - Specifies the key using the key handle

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        b = KeyStructSetInsertionOrdered (GetKeyStruct(GET_INDEX (KeyHandle)));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbMoveKeyHandleToEnd (
    IN      KEYHANDLE KeyHandle
    )
{
    BYTE dbIndex;
    UINT keyIndex;
    PKEYSTRUCT keyStruct;
    UINT parentIndex;
    PKEYSTRUCT parentKeyStruct;
    UINT treeOffset;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyIndex = GET_INDEX (KeyHandle);
        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        keyStruct = GetKeyStruct (keyIndex);
        if (!keyStruct) {
            __leave;
        }

        parentIndex = keyStruct->PrevLevelIndex;
        if (parentIndex == INVALID_OFFSET) {
            __leave;
        }

        parentKeyStruct = GetKeyStruct (parentIndex);
        if (!parentKeyStruct) {
            __leave;
        }

        if (!KeyStructSetInsertionOrdered (parentKeyStruct)) {
            __leave;
        }

        // reloading key struct and parent key struct
        keyStruct = GetKeyStruct (keyIndex);
        if (!keyStruct) {
            __leave;
        }
        parentKeyStruct = GetKeyStruct (parentIndex);
        if (!parentKeyStruct) {
            __leave;
        }

        treeOffset = parentKeyStruct->NextLevelTree;
        if (treeOffset == INVALID_OFFSET) {
            __leave;
        }

        if (!BinTreeDeleteNode (treeOffset, keyStruct->KeyName, NULL)) {
            __leave;
        }

        if (!BinTreeAddNode (treeOffset, keyIndex)) {
            __leave;
        }

        b = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

PCBYTE
MemDbGetDatabaseAddress (
    VOID
    )
{
    PCBYTE result = NULL;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);
    if (SelectDatabase(0)) {
        result = g_CurrentDatabase->Buf;
    }

    LeaveCriticalSection (&g_MemDbCs);
    return result;
}

UINT
MemDbGetDatabaseSize (
    VOID
    )
/*++

Routine Description:

  MemDbGetDatabaseSize returns the size of the permanent database

Arguments:

  None.

Return Value:

  The size of the permanent database.

--*/
{
    UINT result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);
    EnterCriticalSection (&g_MemDbCs);

    if (SelectDatabase(0)) {
        result = g_CurrentDatabase->End;
    }

    LeaveCriticalSection (&g_MemDbCs);
    return result;
}

#ifdef DEBUG

BOOL
MemDbCheckDatabase(
    UINT Level
    )

/*++

Routine Description:

  MemDbCheckDatabase enumerates the entire database and verifies that each
  enumerated key can be found in the hash table.

Arguments:

  Level - Specifies database check level

Return Value:

  TRUE if the database is valid, FALSE otherwise.

--*/

{
    MYASSERT (g_MemDbPool);

    return (CheckDatabase(Level) && CheckLevel(g_CurrentDatabase->FirstLevelTree, INVALID_OFFSET));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\memdbfile.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbfile.c

Abstract:

    file operations for memdb saving/loading/exporting/importing

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from memdb.c


--*/

#include "pch.h"
#include "memdbp.h"

//
// This is our version stamp.  Change MEMDB_VERSION_STAMP only.
//

#define MEMDB_VERSION_STAMP L"v9 "

#define VERSION_BASE_SIGNATURE  L"memdb dat file "
#define MEMDB_DEBUG_SIGNATURE   L"debug"
#define MEMDB_NODBG_SIGNATURE   L"nodbg"

#define VERSION_SIGNATURE VERSION_BASE_SIGNATURE MEMDB_VERSION_STAMP
#define DEBUG_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_DEBUG_SIGNATURE
#define RETAIL_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_NODBG_SIGNATURE

#ifdef DEBUG
#define FILE_SIGNATURE DEBUG_FILE_SIGNATURE
#else
#define FILE_SIGNATURE RETAIL_FILE_SIGNATURE
#endif

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    )
{
    MYASSERT(hMap);
    if (!hFile || hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    *hMap = CreateFileMappingA (
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL
        );
    if (*hMap == NULL) {
        return NULL;
    }

    return MapViewOfFile (*hMap, FILE_MAP_WRITE, 0, 0, 0);
}

BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    )
{
    LONG a;
    LONG b;
    PLONG sizeHi;

    a = (LONG) Size;
    b = (LONG) (SHIFTRIGHT32(Size));
    if (b) {
        sizeHi = &b;
    } else {
        sizeHi = NULL;
    }

    if (SetFilePointer (hFile, a, sizeHi, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        return FALSE;
    }
    if (!SetEndOfFile (hFile)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
WriteBlocks (
    IN OUT  PBYTE *Buf,
    IN      PMEMDBHASH pHashTable,
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(pHashTable);
    MYASSERT(pOffsetBuffer);

    if (!WriteHashBlock (pHashTable, Buf)) {
        return FALSE;
    }
    if (!WriteOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadBlocks (
    IN OUT  PBYTE *Buf,
    OUT     PMEMDBHASH *ppHashTable,
    OUT     PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(ppHashTable);
    MYASSERT(pOffsetBuffer);

    //
    // fill hash block
    //
    if (!*ppHashTable) {
        return FALSE;
    }
    if (!ReadHashBlock (*ppHashTable, Buf)) {
        return FALSE;
    }
    if (!ReadOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
pPrivateMemDbSave (
    PCSTR FileName
    )
{
    HANDLE FileHandle = NULL;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    PBYTE Buf = NULL;
    PBYTE MapPtr = NULL;
    BOOL result = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        if (!SelectDatabase (DB_PERMANENT)) {
            __leave;
        }

        //
        // now we resize file to fit everything in it.
        //
        FileHandle = BfCreateFileA (FileName);

        if (!FileHandle) {
            __leave;
        }

        if (!SetSizeOfFile (
                FileHandle,
                (LONGLONG)(sizeof (FILE_SIGNATURE)) +
                g_CurrentDatabase->AllocSize +
                GetHashTableBlockSize (g_CurrentDatabase->HashTable) +
                GetOffsetBufferBlockSize (&g_CurrentDatabase->OffsetBuffer)
                )) {
            __leave;
        }

        Buf = MapFileFromHandle (FileHandle, &hMap);

        if (Buf == NULL) {
            __leave;
        }

        MapPtr = Buf;

        CopyMemory (Buf, FILE_SIGNATURE, sizeof (FILE_SIGNATURE));

        Buf += sizeof (FILE_SIGNATURE);

        CopyMemory (Buf, g_CurrentDatabase, g_CurrentDatabase->AllocSize);

        Buf += g_CurrentDatabase->AllocSize;

        if (!WriteBlocks (
                &Buf,
                g_CurrentDatabase->HashTable,
                &g_CurrentDatabase->OffsetBuffer
                )) {
            __leave;
        }

        result = TRUE;
    }
    __finally {

        UnmapFile (MapPtr, hMap, FileHandle);

        PushError();

        // lint is not familiar with __finally so...
        if (!result) {  //lint !e774
            if (FileHandle) {
                CloseHandle (FileHandle);
            }

            DeleteFileA (FileName);
        }

        LeaveCriticalSection (&g_MemDbCs);

        PopError();
    }

    return result;
}

BOOL
MemDbSaveA (
    PCSTR FileName
    )
{
    return pPrivateMemDbSave (FileName);                   // TRUE=UNICODE
}

BOOL
MemDbSaveW (
    PCWSTR FileName
    )
{
    PCSTR p;
    BOOL b = FALSE;

    p = ConvertWtoA (FileName);
    if (p) {
        b = pPrivateMemDbSave (p);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
pPrivateMemDbLoad (
    IN      PCSTR AnsiFileName,
    IN      PCWSTR UnicodeFileName,
    OUT     PMEMDB_VERSION Version,                 OPTIONAL
    IN      BOOL QueryVersionOnly
    )
{
    HANDLE FileHandle = NULL;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    WCHAR FileSig[sizeof(FILE_SIGNATURE)];
    PCWSTR VerPtr;
    UINT DbSize;
    PMEMDBHASH pHashTable;
    PBYTE Buf = NULL;
    PBYTE SavedBuf = NULL;
    PCSTR databaseLocation = NULL;
    BOOL result = FALSE;


    EnterCriticalSection (&g_MemDbCs);

    __try {
        __try {

            if (Version) {
                ZeroMemory (Version, sizeof (MEMDB_VERSION));
            }

            //
            // Blow away existing resources
            //

            if (!QueryVersionOnly) {
                databaseLocation = DuplicatePathStringA (DatabasesGetBasePath (), 0);
                DatabasesTerminate (FALSE);
                DatabasesInitializeA (databaseLocation);
                FreePathStringA (databaseLocation);

                if (!SelectDatabase (DB_PERMANENT)) {
                    __leave;
                }
            }

            if (AnsiFileName) {
                Buf = MapFileIntoMemoryA (AnsiFileName, &FileHandle, &hMap);
            } else {
                Buf = MapFileIntoMemoryW (UnicodeFileName, &FileHandle, &hMap);
            }

            if (Buf == NULL) {
                __leave;
            }
            SavedBuf = Buf;

            //
            // Obtain the file signature
            //
            // NOTE: Entire file read is in UNICODE char set
            //

            CopyMemory (FileSig, Buf, sizeof(FILE_SIGNATURE));

            if (Version) {
                if (StringMatchByteCountW (
                        VERSION_BASE_SIGNATURE,
                        FileSig,
                        sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR)
                        )) {

                    Version->Valid = TRUE;

                    //
                    // Identify version number
                    //

                    VerPtr = (PCWSTR) ((PBYTE)FileSig + sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR));

                    if (StringMatchByteCountW (
                            MEMDB_VERSION_STAMP,
                            VerPtr,
                            sizeof (MEMDB_VERSION_STAMP) - sizeof (WCHAR)
                            )) {
                        Version->CurrentVersion = TRUE;
                    }

                    Version->Version = (UINT) _wtoi (VerPtr + 1);

                    //
                    // Identify checked or free build
                    //

                    VerPtr += (sizeof (MEMDB_VERSION_STAMP) / sizeof (WCHAR)) - 1;

                    if (StringMatchByteCountW (
                            MEMDB_DEBUG_SIGNATURE,
                            VerPtr,
                            sizeof (MEMDB_DEBUG_SIGNATURE) - sizeof (WCHAR)
                            )) {

                        Version->Debug = TRUE;

                    } else if (!StringMatchByteCountW (
                                    VerPtr,
                                    MEMDB_NODBG_SIGNATURE,
                                    sizeof (MEMDB_NODBG_SIGNATURE) - sizeof (WCHAR)
                                    )) {
                        Version->Valid = FALSE;
                    }
                }
            }

            if (!QueryVersionOnly) {

                if (!StringMatchW (FileSig, FILE_SIGNATURE)) {

#ifdef DEBUG
                    if (StringMatchW (FileSig, DEBUG_FILE_SIGNATURE)) {

                        g_UseDebugStructs = TRUE;

                    } else if (StringMatchW (FileSig, RETAIL_FILE_SIGNATURE)) {

                        DEBUGMSG ((DBG_ERROR, "memdb dat file is from free build; checked version expected"));
                        g_UseDebugStructs = FALSE;

                    } else {
#endif
                        SetLastError (ERROR_BAD_FORMAT);
                        LOG ((LOG_WARNING, "Warning: data file could be from checked build; free version expected"));
                        __leave;
#ifdef DEBUG
                    }
#endif
                }

                Buf += sizeof(FILE_SIGNATURE);
                DbSize = *((PUINT)Buf);

                //
                // resize the database.  SizeDatabaseBuffer also fixes g_CurrentDatabase
                // and other global variables, so we dont have to worry.
                //
                if (!SizeDatabaseBuffer(g_CurrentDatabaseIndex, DbSize)) {
                    __leave;
                }

                MYASSERT (g_CurrentDatabase);

                //
                // save hashtable pointer (which points to hashtable created
                // in InitializeDatabases (above)), then load database, then
                // fix hashtable pointer.
                //
                pHashTable = g_CurrentDatabase->HashTable;
                CopyMemory (g_CurrentDatabase, Buf, DbSize);
                g_CurrentDatabase->HashTable = pHashTable;
                Buf += DbSize;

                if (!ReadBlocks (
                        &Buf,
                        &g_CurrentDatabase->HashTable,
                        &g_CurrentDatabase->OffsetBuffer
                        )) {
                    __leave;
                }
                result = TRUE;
            }

            UnmapFile (SavedBuf, hMap, FileHandle);

        }
        __except (TRUE) {
            result = FALSE;
            PushError();

#ifdef DEBUG
            if (AnsiFileName) {
                LOGA ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", AnsiFileName));
            } else {
                LOGW ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", UnicodeFileName));
            }
#endif

            PopError();
        }
    }
    __finally {

        PushError();

        if (!result && !QueryVersionOnly) {
            databaseLocation = DuplicatePathStringA (DatabasesGetBasePath (), 0);
            DatabasesTerminate (FALSE);
            DatabasesInitializeA (databaseLocation);
            FreePathStringA (databaseLocation);
        }

        LeaveCriticalSection (&g_MemDbCs);

        PopError();
    }
    return result;
}

BOOL
MemDbLoadA (
    IN PCSTR FileName
    )
{

    return pPrivateMemDbLoad (FileName, NULL, NULL, FALSE);
}

BOOL
MemDbLoadW (
    IN PCWSTR FileName
    )
{
    return pPrivateMemDbLoad (NULL, FileName, NULL, FALSE);
}

BOOL
MemDbQueryVersionA (
    PCSTR FileName,
    PMEMDB_VERSION Version
    )
{
    BOOL b;

    b = pPrivateMemDbLoad (FileName, NULL, Version, TRUE);

    return b ? Version->Valid : FALSE;
}

BOOL
MemDbQueryVersionW (
    PCWSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad (NULL, FileName, Version, TRUE);
    return Version->Valid;
}

/* format for binary file export

    DWORD Signature

    UINT Version

    UINT GlobalFlags// 0x00000001 mask for Ansi format
                    // 0x00000002 mask for debug mode

        //
        // each _KEY block is followed by its children,
        // and each of those is followed by its children,
        // etc., so it is easy to recurse to gather
        // the whole tree.
        //

    struct _KEY {

      #if (GlobalFlags & MEMDB_EXPORT_FLAGS_DEBUG)
        WORD DebugSig       // signature for each keystruct block.
      #endif
        WORD StructSize;    // total number of bytes including this member
        WORD NameSize;      // total number of bytes in Key[]
        WORD DataSize;      // total number of bytes in Data[]
        WORD NumChildren    // number of children, whose data structures will follow
                            // this one (though not necessarily one after another, if
                            // any of them have children themselves)
        BYTE Key[];         // Should be PCSTR or PCWSTR (not zero terminated).
                            // the first key in the exported file will have the full
                            // key path as its key name.
        BYTE Data[];        // block of data pieces, all in same format as in datablock.c
    }

*/
#define MEMDB_EXPORT_SIGNATURE              ('M'+('D'<<8)+('B'<<16)+('X'<<24))
// NTRAID#NTBUG9-153308-2000/08/01-jimschm reenable the line below when implementing export and import functions
//#define MEMDB_EXPORT_DEBUG_SIG              ('K'+('Y'<<8))
#define MEMDB_EXPORT_VERSION                0x00000003
#define MEMDB_EXPORT_FLAGS_ANSI             0x00000001
#define MEMDB_EXPORT_FLAGS_DEBUG            0x00000002

// NTRAID#NTBUG9-153308-2000/08/01-jimschm  Implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbExportWorker (
    IN  HANDLE FileHandle,
    IN  UINT KeyIndex,
    IN  BOOL AnsiFormat,
    IN  PCWSTR FullKeyPath
    )
/*++

Routine Description:

  exports a key to a file, and then recurses through
  that key's children.

Arguments:

  FileHandle - already opened handle to write to

  KeyIndex - index of key to write

  AnsiFormat - if TRUE, then FullKeyPath (above) and KeyName
        (below) are actually ANSI strings (not unicode).

  FullKeyPath - only used for first keystruct to be written
        to file.  it specifies the full path of the root key.
        for all others, this argument should be NULL.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
pMemDbExport (
    IN      PCWSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
/*++

Routine Description:

  exports a MemDb tree to a file

Arguments:

  RootTree - full key path of the top level key to write
        to the file.

  FileName - file to write to.

  AnsiFormat - if TRUE, then RootTree and FileName are
        actually ANSI strings (not unicode).


Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    HANDLE FileHandle = NULL;
    UINT Flags;
    DWORD written;
    UINT RootIndex = INVALID_OFFSET;
    PCWSTR SubRootTreeW, RootTreeW;
    BOOL b;

    if (AnsiFormat) {
        //
        // if we are in ansi mode, everything is ANSI strings,
        // but we still need unicode string for SelectHiveW ()
        //
        RootTreeW = ConvertAtoW ((PCSTR)RootTree);

        if (!RootTreeW) {
            return FALSE;
        }
    } else {
        RootTreeW = RootTree;
    }
    SubRootTreeW = SelectHiveW (RootTreeW);

    if (SubRootTreeW) {
        RootIndex = FindKeyStruct (SubRootTreeW);
    }

    if (AnsiFormat) {
        FreeConvertedStr(RootTreeW);
    }

    if (RootIndex == INVALID_OFFSET) {
        return FALSE;
    }

    FileHandle = BfCreateFileA (FileName);

    if (!FileHandle) {
        return FALSE;
    }

    Flags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (FileHandle, &Flags, sizeof (DWORD), &written, NULL);

    Flags = MEMDB_EXPORT_VERSION;
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    Flags = AnsiFormat ? MEMDB_EXPORT_FLAGS_ANSI : 0;

#ifdef DEBUG
    Flags |= MEMDB_EXPORT_FLAGS_DEBUG;
#endif
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    //
    // write root index key and all children to file.
    //
    b = pMemDbExportWorker(FileHandle, RootIndex, AnsiFormat, RootTree);


    //
    // finally write the zero terminator
    //
    Flags = 0;
    WriteFile (FileHandle, &Flags, sizeof (WORD), &written, NULL);

    CloseHandle (FileHandle);

    return b;
}

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCWSTR p;
    BOOL b;

    if (!AnsiFormat) {

        p = ConvertAtoW (RootTree);

        if (!p) {
            return FALSE;
        }

        b = pMemDbExport (p, FileName, FALSE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport ((PCWSTR)RootTree, FileName, TRUE);

    }

    return b;
}

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCSTR p, FileNameA;
    BOOL b;

    FileNameA = ConvertWtoA (FileName);

    if (!FileNameA) {

        return FALSE;

    }

    if (AnsiFormat) {

        p = ConvertWtoA (RootTree);

        if (!p) {

            FreeConvertedStr (FileNameA);
            return FALSE;

        }

        b = pMemDbExport ((PCWSTR)p, FileNameA, TRUE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport (RootTree, FileNameA, FALSE);

    }

    FreeConvertedStr (FileNameA);

    return b;
}

// NTRAID#NTBUG9-153308-2000/08/01-jimschm Implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbImportWorker (
    IN      PBYTE *FileBuffer,
    IN      BOOL AnsiFormat,
    IN      BOOL DebugMode,
    IN      BOOL ExportRoot
    )
/*++

Routine Description:

  imports a key from a file, and then recurses through
  that key's children.

Arguments:

  FileBuffer - pointer to a memory pointer, which should
        initially point to the beginning of the
        memory-mapped file to read.  this will be updated
        as the function runs

  AnsiFormat - TRUE if the file is in ANSI mode (determined
        by file header)

  DebugMode - TRUE if the file is in debug mode (determined
        by file header)

  ExportRoot - TRUE if this is the first call to this function
        for a file (the name of the first keystruct in a file
        is the full key path for that keystruct, all other keys
        in the file have only the relative name).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
MemDbImportA (
    IN      PCSTR FileName
    )
{
    PCWSTR FileNameW;
    BOOL b = FALSE;

    FileNameW = ConvertAtoW (FileName);

    if (FileNameW) {
        b = MemDbImportW (FileNameW);
        FreeConvertedStr (FileNameW);
    }

    return b;
}

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  MemDbImportW imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/
{
    PBYTE fileBuff, BufferPtr;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL b = FALSE;
    UINT Flags;

    fileBuff = MapFileIntoMemoryW (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGW ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        BufferPtr = fileBuff;
        if (*((PDWORD) BufferPtr) != MEMDB_EXPORT_SIGNATURE) {
            DEBUGMSGW ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            b = FALSE;
        } else {
            BufferPtr += sizeof (DWORD);

            if (*((PUINT) BufferPtr) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGW ((DBG_ERROR, "Unknown or outdated version for file to import: %s", FileName));
                b = FALSE;
            } else {
                BufferPtr += sizeof (UINT);
                Flags = *((PUINT) BufferPtr);
                BufferPtr += sizeof (UINT);

                b = pMemDbImportWorker (
                    &BufferPtr,
                    Flags & MEMDB_EXPORT_FLAGS_ANSI,
                    Flags & MEMDB_EXPORT_FLAGS_DEBUG,
                    TRUE
                    );
            }
        }
    }
    __except (1) {
        DEBUGMSGW ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\offsetbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    offsetbuf.c

Abstract:

    Routines that manage the keystruct offsetbuffer

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"



//
// we store index flags in the top two bits of the UINT offsets in
// the buffer, because offsets never have a top two bits set
//
// if the user links a key, we want to mark that index, so we
// dont add it to the deleted index list.  if a key is linked,
// and then deleted, we want to keep that key's index pointing
// to INVALID_OFFSET, instead of reusing the index.
//
// if a key is moved, we replace the key's original offset with
// the index of the new key's offset.  then we flag that the
// offset has been redirected.
//
// if an index is marked or redirected, when that key is deleted,
// we just set the true index (the index that any redirected indices
// point to) to INVALID_OFFSET.
//

#define INDEX_FLAG_BITS                 2
#define INDEX_MOVE_BITS_TO_POS(bits)    (((UINT)(bits)) << (8*sizeof(UINT)-INDEX_FLAG_BITS))
#define INDEX_MARKED_FLAG               INDEX_MOVE_BITS_TO_POS(0x01)
#define INDEX_REDIRECTED_FLAG           INDEX_MOVE_BITS_TO_POS(0x02)
#define INDEX_FLAG_MASK                 INDEX_MOVE_BITS_TO_POS(0x03)

#define GET_UINT_AT_INDEX(index)          (*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))
#define SET_UINT_AT_INDEX(index, offset)  ((*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))=(offset))

#define MARK_INDEX(Index)       (GET_UINT_AT_INDEX(Index) |= INDEX_MARKED_FLAG)
#define IS_INDEX_MARKED(Index)  ((BOOL)(GET_UINT_AT_INDEX(Index) & INDEX_FLAG_MASK))


VOID
MarkIndexList (
    IN      PUINT IndexList,
    IN      UINT IndexListSize
    )
{
    BYTE CurrentDatabase;
    UINT i;

    CurrentDatabase = g_CurrentDatabaseIndex;

    //
    // iterate through whole list, switch to correct
    // database, and mark list as linked.
    //
    for (i = 0; i < IndexListSize; i++) {
        SelectDatabase (GET_DATABASE (IndexList[i]));
        MARK_INDEX (GET_INDEX (IndexList[i]));
#ifdef _DEBUG
        if (GET_UINT_AT_INDEX (GET_INDEX (IndexList[i])) != INVALID_OFFSET) {
            MYASSERT (GetKeyStruct (GET_INDEX (IndexList[i])));
        }
#endif
    }

    SelectDatabase (CurrentDatabase);
}

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    )
/*++

Routine Description:
  sets the offset at Index to TargetIndex, with INDEX_REDIRECTED_FLAG
  set in the top byte.  also, we mark TargetIndex, indicating it has
  something redirected to it.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT(!(TargetIndex & INDEX_FLAG_MASK));
    MYASSERT(!(GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG));
    MYASSERT(!(GET_UINT_AT_INDEX(TargetIndex) & INDEX_REDIRECTED_FLAG));
    SET_UINT_AT_INDEX(Index, TargetIndex | INDEX_REDIRECTED_FLAG);
    MARK_INDEX(TargetIndex);
}

UINT
pGetTrueIndex (
    IN  UINT Index
    )
/*++

Routine Description:
  takes and index and returns the true index, which is the index that
  actually holds the offset of the keystruct.  indexes with the
  redirected flag hold the index they are redirected to.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    while (GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG) {
        Index = GET_UINT_AT_INDEX(Index) & ~INDEX_FLAG_MASK;
    }
    return Index;
}










UINT
KeyIndexToOffset (
    IN  UINT Index
    )
/*++

Routine Description:
  KeyIndexToOffset converts an index of a Keystruct
  (in g_CurrentDatabase->OffsetBuffer) to the Keystruct's offset in the database.

Arguments:
  Index - index in OffsetBuffer.  must be valid

Return Value:
  Offset of Keystruct.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));
    MYASSERT (g_CurrentDatabase);

    if (!g_CurrentDatabase->OffsetBuffer.Buf) {
        return INVALID_OFFSET;
    }

    do {
        Index = GET_UINT_AT_INDEX(Index);
        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }
        if (!(Index & INDEX_REDIRECTED_FLAG)) {
            //
            // we have found a non-redirected index, so check
            // that this points to a real keystruct, and return it.
            //
            MYASSERT(GetKeyStructFromOffset(Index & ~INDEX_FLAG_MASK));
            return Index & ~INDEX_FLAG_MASK;
        }
        Index &= ~INDEX_FLAG_MASK;
        MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));
    } while (TRUE); //lint !e506
}






UINT
AddKeyOffsetToBuffer (
    IN  UINT Offset
    )
/*++

Routine Description:
  gets a space in g_CurrentDatabase->OffsetBuffer and sets it to Offset

Arguments:
  Offset - value to put in buffer space

Return Value:
  Index of space in g_CurrentDatabase->OffsetBuffer

--*/
{
    PUINT Ptr;

    MYASSERT (g_CurrentDatabase);

    if (Offset & INDEX_FLAG_MASK) {
        DEBUGMSG ((DBG_ERROR, "Offset to be put in list is too big, 0x%08lX", Offset));
        return FALSE;
    }

    //
    // this will check that Offset is valid and points to Keystruct
    //
    MYASSERT(GetKeyStructFromOffset(Offset));

    if (g_CurrentDatabase->OffsetBufferFirstDeletedIndex != INVALID_OFFSET)
    {
        //
        // if we have deleted offsets from offset list, we
        // find an open index, the first of which is stored
        // in g_CurrentDatabase->OffsetBufferFirstDeletedIndex.  the value at
        // this index in the buffer is the next open index,
        // and the value at that index is the next one, etc.
        //
        Ptr = &GET_UINT_AT_INDEX(g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = *Ptr;
    } else {
        //
        // otherwise, make g_CurrentDatabase->OffsetBuffer bigger to hold new offset.
        //
        Ptr = (PUINT) GbGrow (&g_CurrentDatabase->OffsetBuffer, sizeof(UINT));
    }

    *Ptr = Offset;

    return (UINT)((UBINT)Ptr - (UBINT)g_CurrentDatabase->OffsetBuffer.Buf);
}


VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    )
/*++

Routine Description:
  frees a space in g_CurrentDatabase->OffsetBuffer (adds to deleted index list)

Arguments:
  Index - position of space to free

--*/
{
    if (Index == INVALID_OFFSET) {
        return;
    }

    MYASSERT (g_CurrentDatabase);

    if (IS_INDEX_MARKED(Index)) {
        //
        // if index is marked, either it is redirected or something
        // is linked to this index.  either way, we do not want to
        // reuse the index, so just set true index (not a redirected
        // one) to INVALID_OFFSET.
        //
        SET_UINT_AT_INDEX(pGetTrueIndex(Index), INVALID_OFFSET);
    } else {
        //
        // index not marked, so we can reuse this index by
        // putting it in the deleted index list.
        //
        SET_UINT_AT_INDEX(Index, g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = Index;
    }
}



BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    MYASSERT(pOffsetBuffer);

    *(((PUINT)*Buf)++) = pOffsetBuffer->End;
    CopyMemory (*Buf, pOffsetBuffer->Buf, pOffsetBuffer->End);

    *Buf += pOffsetBuffer->End;
    return TRUE;
}


BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    UINT OffsetBufferSize;

    MYASSERT(pOffsetBuffer);

    ZeroMemory (pOffsetBuffer, sizeof (GROWBUFFER));

    OffsetBufferSize = *(((PUINT)*Buf)++);

    if (OffsetBufferSize > 0) {
        if (!GbGrow(pOffsetBuffer, OffsetBufferSize)) {
            return FALSE;
        }
        CopyMemory (pOffsetBuffer->Buf, *Buf, OffsetBufferSize);
        *Buf += OffsetBufferSize;
    }

    return TRUE;
}


UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    return sizeof (UINT) + pOffsetBuffer->End;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\pch\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\memdb\pastring.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pastring.c

Abstract:

    Routines that manage the pascal strings

Author:

    Matthew Vanderzee (matthewv) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"








PPASTR
StringPasConvertTo (
    IN OUT PWSTR str
    )
/*++

  Converts a string in place from a zero-terminated
  string to a pascal-style string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = (WORD) CharCountW (str);
    MoveMemory (str + 1, str, Len * sizeof(WCHAR));
    *str = Len;
    return str;
}

PWSTR
StringPasConvertFrom (
    IN OUT PPASTR str
    )
/*++

  Converts a string in place from a pascal-style string
  to a null-terminated string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = *str;
    MoveMemory (str, str + 1, Len * sizeof(WCHAR));
    *(str + Len) = 0;
    return str;
}

PPASTR
StringPasCopyConvertTo (
    OUT PPASTR str1,
    IN  PCWSTR str2
    )
/*++

  Converts a string from a zero-terminated
  string to a pascal-style string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    *str1 = (WORD) CharCountW (str2);
    CopyMemory (str1 + 1, str2, *str1 * sizeof(WCHAR));
    return str1;
}

PWSTR
StringPasCopyConvertFrom (
    OUT PWSTR str1,
    IN  PCPASTR str2
    )
/*++

  Converts a string from a pascal-style string
  to a null-terminated string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2 + 1, *str2 * sizeof(WCHAR));
    *(str1 + *str2) = 0;
    return str1;
}

PPASTR
StringPasCopy (
    OUT PPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Copys a pascal string to a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2, (*str2+1) * sizeof(WCHAR));
    return str1;
}

UINT
StringPasCharCount (
    IN  PCPASTR str
    )
/*++

  Returns the number of characters in a string.

--*/
{
    MYASSERT(str);
    return (UINT)(*str);
}


INT
StringPasCompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = wcsncmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return wcsncmp(str1+1, str2+1, *str2)==0;
}


INT
StringPasICompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().  (CASE INSENSITIVE)

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = _wcsnicmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasIMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match (CASE INSENSITIVE)

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return _wcsnicmp(str1+1, str2+1, *str2)==0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\modimage\modimage.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    modimage.c

Abstract:

    Implements a set of routines for examining EXE modules

Author:

    Calin Negreanu (calinn) 27-Nov-1997

Revision History:

    calinn      08-Mar-2000 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_MODIMAGE    "ModImage"

//
// Strings
//

// None

//
// Constants
//

#define SEG_CODE_MASK                   0x0001
#define SEG_CODE                        0x0000
#define SEG_PRELOAD_MASK                0x0040
#define SEG_PRELOAD                     0x0040
#define SEG_RELOC_MASK                  0x0100
#define SEG_RELOC                       0x0100

#define RELOC_IMPORTED_ORDINAL          0x01
#define RELOC_IMPORTED_NAME             0x02
#define RELOC_ADDR_TYPE                 0x03

#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_NE_SIGNATURE              0x454E      // NE
#define IMAGE_PE_SIGNATURE              0x00004550l // PE00

//
// Macros
//

// None

//
// Types
//

#pragma pack(push,1)

typedef struct _DOS_HEADER {  // DOS .EXE header
    WORD e_magic;           // Magic number
    WORD e_cblp;            // Bytes on last page of file
    WORD e_cp;              // Pages in file
    WORD e_crlc;            // Relocations
    WORD e_cparhdr;         // Size of header in paragraphs
    WORD e_minalloc;        // Minimum extra paragraphs needed
    WORD e_maxalloc;        // Maximum extra paragraphs needed
    WORD e_ss;              // Initial (relative) SS value
    WORD e_sp;              // Initial SP value
    WORD e_csum;            // Checksum
    WORD e_ip;              // Initial IP value
    WORD e_cs;              // Initial (relative) CS value
    WORD e_lfarlc;          // File address of relocation table
    WORD e_ovno;            // Overlay number
    WORD e_res[4];          // Reserved words
    WORD e_oemid;           // OEM identifier (for e_oeminfo)
    WORD e_oeminfo;         // OEM information; e_oemid specific
    WORD e_res2[10];        // Reserved words
    LONG e_lfanew;          // File address of new exe header
} DOS_HEADER, *PDOS_HEADER;

typedef struct _NE_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    WORD  EntryTableOff;
    WORD  EntryTableLen;
    ULONG Reserved;
    WORD  Flags;
    WORD  NumberOfDataSeg;
    WORD  SizeOfHeap;
    WORD  SizeOfStack;
    ULONG CS_IP;
    ULONG SS_SP;
    WORD  NumEntriesSegTable;
    WORD  NumEntriesModuleTable;
    WORD  NonResNameTableSize;
    WORD  SegTableOffset;
    WORD  ResTableOffset;
    WORD  ResNameTableOffset;
    WORD  ModuleTableOffset;
    WORD  ImportedTableOffset;
    ULONG NonResNameTableOffset;
    WORD  NumberOfMovableEntryPoints;
    WORD  ShiftCount;
    WORD  NumberOfResourceSegments;
    BYTE  TargetOS;
    BYTE  AdditionalInfo;
    WORD  FastLoadOffset;
    WORD  FastLoadSize;
    WORD  Reserved1;
    WORD  WinVersionExpected;
} NE_HEADER, *PNE_HEADER;

typedef struct {
    WORD Signature;                             // 00h
    BYTE LinkerVersion;                         // 02h
    BYTE LinkerRevision;                        // 03h
    WORD OffsetToEntryTable;                    // 04h
    WORD LengthOfEntryTable;                    // 06h
    DWORD Reserved;                             // 08h
    WORD Flags;                                 // 0ch
    WORD AutoDataSegment;                       // 0eh
    WORD LocalHeapSize;                         // 10h
    WORD StackSize;                             // 12h
    DWORD EntryAddress;                         // 14h
    DWORD StackAddress;                         // 18h
    WORD SegmentTableEntries;                   // 1ch
    WORD ModuleReferenceTableEntries;           // 1eh
    WORD NonResidentTableSize;                  // 20h
    WORD OffsetToSegmentTable;                  // 22h
    WORD OffsetToResourceTable;                 // 24h
    WORD OffsetToResidentNameTable;             // 26h
    WORD OffsetToModuleReferenceTable;          // 28h
    WORD OffsetToImportedNameTable;             // 2ah
    WORD OffsetToNonResidentNameTable;          // 2ch
    WORD Unused;                                // 2eh
    WORD MovableEntryPoints;                    // 30h
    WORD LogicalSectorShiftCount;               // 32h
    WORD ResourceSegments;                      // 34h
    BYTE TargetOS;                              // 36h
    BYTE AdditionalFlags;                       // 37h
    WORD FastLoadOffset;                        // 38h
    WORD SectorsInFastLoad;                     // 3ah
    WORD Reserved2;                             // 3ch
    WORD WindowsVersion;                        // 3eh
} NE_INFO_BLOCK, *PNE_INFO_BLOCK;

typedef struct _NE_SEGMENT_ENTRY {
    WORD  SegmentOffset;
    WORD  SegmentLen;
    WORD  SegmentFlags;
    WORD  SegMinAlloc;
} NE_SEGMENT_ENTRY, *PNE_SEGMENT_ENTRY;

typedef struct _NE_RELOC_ITEM {
    BYTE  AddressType;
    BYTE  RelocType;
    WORD  RelocOffset;
    WORD  ModuleOffset;
    WORD  FunctionOffset;
} NE_RELOC_ITEM, *PNE_RELOC_ITEM;

typedef struct {
    WORD Offset;
    WORD Length;
    WORD Flags;
    WORD Id;
    WORD Handle;
    WORD Usage;
} NE_RES_NAMEINFO, *PNE_RES_NAMEINFO;

typedef struct {
    WORD TypeId;
    WORD ResourceCount;
    DWORD Reserved;
    NE_RES_NAMEINFO NameInfo[];
} NE_RES_TYPEINFO, *PNE_RES_TYPEINFO;

#pragma pack(pop)

typedef struct {
    WORD AlignShift;
    GROWLIST TypeInfoArray;
    GROWLIST ResourceNames;
} NE_RESOURCES, *PNE_RESOURCES;

typedef struct {
    PLOADED_IMAGE Image;
    PIMAGE_IMPORT_DESCRIPTOR ImageDescriptor;
    DWORD ImportFunctionAddr;
    PIMAGE_THUNK_DATA ImageData;
    PIMAGE_IMPORT_BY_NAME ImageName;
} MD_IMPORT_ENUM32_HANDLE, *PMD_IMPORT_ENUM32_HANDLE;

typedef struct {
    PBYTE Image;
    PDOS_HEADER DosHeader;
    PNE_HEADER NeHeader;
    PNE_SEGMENT_ENTRY SegmentEntry;
    WORD CurrSegEntry;
    PWORD CurrNrReloc;
    PNE_RELOC_ITEM RelocItem;
    WORD CurrRelocItem;
} MD_IMPORT_ENUM16_HANDLE, *PMD_IMPORT_ENUM16_HANDLE;

typedef struct {
    HANDLE File;
    DWORD HeaderOffset;
    NE_INFO_BLOCK Header;
    NE_RESOURCES Resources;
    BOOL ResourcesLoaded;
    PMHANDLE ResourcePool;
} NE_HANDLE, *PNE_HANDLE;

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef struct {
    PCSTR TypeToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    BOOL Found;
} TYPESEARCHDATAA, *PTYPESEARCHDATAA;

typedef struct {
    PCSTR NameToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    PNE_RES_NAMEINFO OutboundNameInfo;
    BOOL Found;
} NAMESEARCHDATAA, *PNAMESEARCHDATAA;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
MdLoadModuleDataA (
    IN      PCSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    )
{
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MD_MODULE_IMAGE));

    fileHandle = CreateFileA (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
                __leave;
            }
            ModuleImage->ModuleType = MODULETYPE_DOS;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }
            CloseHandle (fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN32;
                result = MapAndLoad ((PSTR)ModuleName, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN16;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemoryA (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
MdLoadModuleDataW (
    IN      PCWSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    )
{
    PCSTR moduleNameA;
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MD_MODULE_IMAGE));

    fileHandle = CreateFileW (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
                __leave;
            }
            ModuleImage->ModuleType = MODULETYPE_DOS;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }
            CloseHandle (fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN32;
                moduleNameA = ConvertWtoA (ModuleName);
                if (moduleNameA) {
                    result = MapAndLoad ((PSTR) moduleNameA, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
                    FreeConvertedStr (moduleNameA);
                }
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN16;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemoryW (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
MdUnloadModuleDataA (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case MODULETYPE_WIN32:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case MODULETYPE_WIN16:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}

BOOL
MdUnloadModuleDataW (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case MODULETYPE_WIN32:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case MODULETYPE_WIN16:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}

BOOL
MdEnumNextImport16A (
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    PBYTE currSegmentOffset,importPtr;
    PWORD moduleNameOffset;
    BOOL itemFound;
    PMD_IMPORT_ENUM16_HANDLE handle;

    handle = (PMD_IMPORT_ENUM16_HANDLE) ImportsEnum->Handle;

    handle->RelocItem ++;
    handle->CurrRelocItem ++;

    itemFound = FALSE;

    while ((handle->CurrSegEntry <= handle->NeHeader->NumEntriesSegTable) && (!itemFound)) {

        if (((handle->SegmentEntry->SegmentFlags & SEG_CODE_MASK   ) == SEG_CODE   ) &&
            ((handle->SegmentEntry->SegmentFlags & SEG_RELOC_MASK  ) == SEG_RELOC  ) &&
            ((handle->SegmentEntry->SegmentFlags & SEG_PRELOAD_MASK) == SEG_PRELOAD)
           ) {
            __try {

                while ((handle->CurrRelocItem <= *(handle->CurrNrReloc)) && (!itemFound)) {

                    if (((handle->RelocItem->AddressType ==  0) ||
                         (handle->RelocItem->AddressType ==  2) ||
                         (handle->RelocItem->AddressType ==  3) ||
                         (handle->RelocItem->AddressType ==  5) ||
                         (handle->RelocItem->AddressType == 11) ||
                         (handle->RelocItem->AddressType == 13)
                        ) &&
                        ((handle->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) ||
                         (handle->RelocItem->RelocType == RELOC_IMPORTED_NAME   )
                        )
                       ) {
                        itemFound = TRUE;
                        moduleNameOffset = (PWORD) (handle->Image +
                                                    handle->DosHeader->e_lfanew +
                                                    handle->NeHeader->ModuleTableOffset +
                                                    (handle->RelocItem->ModuleOffset - 1) * sizeof (WORD));
                        importPtr = handle->Image +
                                    handle->DosHeader->e_lfanew +
                                    handle->NeHeader->ImportedTableOffset +
                                    *moduleNameOffset;
                        strncpy (ImportsEnum->ImportModule, importPtr + 1, (BYTE)importPtr[0]);
                        ImportsEnum->ImportModule[(BYTE)importPtr[0]] = 0;

                        if (handle->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) {
                            ImportsEnum->ImportFunction[0] = 0;
                            ImportsEnum->ImportFunctionOrd = handle->RelocItem->FunctionOffset;
                        }
                        else {
                            importPtr = handle->Image +
                                        handle->DosHeader->e_lfanew +
                                        handle->NeHeader->ImportedTableOffset +
                                        handle->RelocItem->FunctionOffset;
                            strncpy (ImportsEnum->ImportFunction, importPtr + 1, (BYTE)importPtr[0]);
                            ImportsEnum->ImportFunction[(BYTE)importPtr[0]] = 0;
                            ImportsEnum->ImportFunctionOrd = 0;
                        }
                    }

                    if (!itemFound) {
                        handle->RelocItem ++;
                        handle->CurrRelocItem ++;
                    }
                }
            }
            __except (1) {
                itemFound = FALSE;
            }
        }
        if (!itemFound) {
            handle->SegmentEntry ++;
            handle->CurrSegEntry ++;

            currSegmentOffset = handle->Image +
                                (handle->SegmentEntry->SegmentOffset << handle->NeHeader->ShiftCount);
            if (handle->SegmentEntry->SegmentLen == 0) {
                currSegmentOffset += 65535;
            }
            else {
                currSegmentOffset += handle->SegmentEntry->SegmentLen;
            }
            handle->CurrNrReloc = (PWORD) currSegmentOffset;
            currSegmentOffset += sizeof(WORD);

            handle->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

            handle->CurrRelocItem = 1;
        }
    }
    return itemFound;
}


BOOL
MdEnumFirstImport16A (
    IN      PBYTE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    PMD_IMPORT_ENUM16_HANDLE handle;
    PBYTE currSegmentOffset;

    ZeroMemory (ImportsEnum, sizeof (MD_IMPORT_ENUM16A));

    ImportsEnum->Handle = MemAlloc (g_hHeap, 0, sizeof (MD_IMPORT_ENUM16_HANDLE));

    handle = (PMD_IMPORT_ENUM16_HANDLE) ImportsEnum->Handle;

    handle->Image = ModuleImage;

    handle->DosHeader = (PDOS_HEADER) (handle->Image);
    handle->NeHeader = (PNE_HEADER) (handle->Image + handle->DosHeader->e_lfanew);

    handle->SegmentEntry = (PNE_SEGMENT_ENTRY) (handle->Image +
                                                handle->DosHeader->e_lfanew +
                                                handle->NeHeader->SegTableOffset
                                                );
    handle->CurrSegEntry = 1;

    currSegmentOffset = handle->Image +
                        (handle->SegmentEntry->SegmentOffset << handle->NeHeader->ShiftCount);
    if (handle->SegmentEntry->SegmentLen == 0) {
        currSegmentOffset += 65535;
    }
    else {
        currSegmentOffset += handle->SegmentEntry->SegmentLen;
    }
    handle->CurrNrReloc = (PWORD) currSegmentOffset;
    currSegmentOffset += sizeof(WORD);

    handle->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

    handle->CurrRelocItem = 1;

    handle->RelocItem --;
    handle->CurrRelocItem --;

    return MdEnumNextImport16A (ImportsEnum);
}

BOOL
MdAbortImport16EnumA (
    IN      PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    if (ImportsEnum->Handle) {
        MemFree (g_hHeap, 0, ImportsEnum->Handle);
        ImportsEnum->Handle = NULL;
    }
    return TRUE;
}

BOOL
MdEnumNextImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if (handle->ImportFunctionAddr == 0) {
        return FALSE;
    }
    handle->ImageData = (PIMAGE_THUNK_DATA)
                         ImageRvaToVa (
                            handle->Image->FileHeader,
                            handle->Image->MappedAddress,
                            handle->ImportFunctionAddr,
                            NULL
                            );

    if (handle->ImageData->u1.AddressOfData) {
        handle->ImageName = (PIMAGE_IMPORT_BY_NAME)
                             ImageRvaToVa (
                                handle->Image->FileHeader,
                                handle->Image->MappedAddress,
                                (DWORD)handle->ImageData->u1.AddressOfData,
                                NULL
                                );

        if (handle->ImageName) {    //import by name

            ImportsEnum->ImportFunction = handle->ImageName->Name;
            ImportsEnum->ImportFunctionOrd = 0;
        }
        else {  //import by number

            ImportsEnum->ImportFunction = NULL;
            ImportsEnum->ImportFunctionOrd = (ULONG) handle->ImageData->u1.Ordinal & (~0x80000000);
        }
        handle->ImportFunctionAddr += 4;
        return TRUE;
    }
    else {
        handle->ImportFunctionAddr = 0;
        return FALSE;
    }
}

BOOL
MdEnumFirstImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if ((handle->ImageDescriptor == NULL) ||
        (ImportsEnum->ImportModule == NULL)
        ) {
        return FALSE;
    }
    handle->ImportFunctionAddr = handle->ImageDescriptor->OriginalFirstThunk;

    return MdEnumNextImportFunction32A (ImportsEnum);
}

BOOL
MdEnumNextImportModule32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if (handle->ImageDescriptor == NULL) {
        return FALSE;
    }

    handle->ImageDescriptor ++;

    if (handle->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ImportsEnum->ImportModule = (PCSTR)
                                 ImageRvaToVa (
                                    handle->Image->FileHeader,
                                    handle->Image->MappedAddress,
                                    handle->ImageDescriptor->Name,
                                    NULL
                                    );
    return (ImportsEnum->ImportModule != NULL);
}

BOOL
MdEnumFirstImportModule32A (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;
    ULONG imageSize;

    ZeroMemory (ImportsEnum, sizeof (MD_IMPORT_ENUM32A));

    ImportsEnum->Handle = MemAlloc (g_hHeap, 0, sizeof (MD_IMPORT_ENUM32_HANDLE));

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    handle->Image = ModuleImage;

    handle->ImageDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
                               ImageDirectoryEntryToData (
                                    ModuleImage->MappedAddress,
                                    FALSE,
                                    IMAGE_DIRECTORY_ENTRY_IMPORT,
                                    &imageSize
                                    );
    if (!handle->ImageDescriptor) {
        DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load import directory for %s", ModuleImage->ModuleName));
        return FALSE;
    }
    if (handle->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ImportsEnum->ImportModule = (PCSTR)
                                 ImageRvaToVa (
                                    handle->Image->FileHeader,
                                    handle->Image->MappedAddress,
                                    handle->ImageDescriptor->Name,
                                    NULL
                                    );
    return (ImportsEnum->ImportModule != NULL);
}

BOOL
MdAbortImport32EnumA (
    IN      PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    if (ImportsEnum->Handle) {
        MemFree (g_hHeap, 0, ImportsEnum->Handle);
        ImportsEnum->Handle = NULL;
    }
    return TRUE;
}

DWORD
MdGetModuleTypeA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    DWORD result = MODULETYPE_UNKNOWN;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        result = moduleImage.ModuleType;
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

DWORD
MdGetModuleTypeW (
    IN      PCWSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    DWORD result = MODULETYPE_UNKNOWN;

    __try {
        if (!MdLoadModuleDataW (ModuleName, &moduleImage)) {
            DEBUGMSGW((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        result = moduleImage.ModuleType;
    }
    __finally {
        MdUnloadModuleDataW (&moduleImage);
    }
    return result;
}

PCSTR
MdGet16ModuleDescriptionA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    PSTR result = NULL;

    PDOS_HEADER dosHeader;
    PNE_HEADER  neHeader;
    PBYTE size;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN16) {
            __leave;
        }
        __try {
            dosHeader = (PDOS_HEADER) (moduleImage.ModuleData.W16Data.Image);
            neHeader  = (PNE_HEADER)  (moduleImage.ModuleData.W16Data.Image + dosHeader->e_lfanew);
            size = (PBYTE) (moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset);
            if (*size == 0) {
                __leave;
            }
            result = AllocPathStringA (*size + 1);
            strncpy (result, moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset + 1, *size);
            result [*size] = 0;
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            if (result != NULL) {
                FreePathStringA (result);
                result = NULL;
            }
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

PCWSTR
MdGet16ModuleDescriptionW (
    IN      PCWSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    PSTR resultA = NULL;
    PCWSTR tempResult = NULL;
    PCWSTR result = NULL;

    PDOS_HEADER dosHeader;
    PNE_HEADER  neHeader;
    PBYTE size;

    __try {
        if (!MdLoadModuleDataW (ModuleName, &moduleImage)) {
            DEBUGMSGW((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN16) {
            __leave;
        }
        __try {
            dosHeader = (PDOS_HEADER) (moduleImage.ModuleData.W16Data.Image);
            neHeader  = (PNE_HEADER)  (moduleImage.ModuleData.W16Data.Image + dosHeader->e_lfanew);
            size = (PBYTE) (moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset);
            if (*size == 0) {
                __leave;
            }
            resultA = AllocPathStringA (*size + 1);
            if (resultA) {
                strncpy (resultA, moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset + 1, *size);
                resultA [*size] = 0;
                tempResult = ConvertAtoW (resultA);
                if (tempResult) {
                    result = DuplicatePathStringW (tempResult, 0);
                    FreeConvertedStr (tempResult);
                    tempResult = NULL;
                }
                FreePathStringA (resultA);
                resultA = NULL;
            }
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            if (result != NULL) {
                FreePathStringW (result);
                result = NULL;
            }
            if (tempResult != NULL) {
                FreeConvertedStr (tempResult);
                tempResult = NULL;
            }
            if (resultA != NULL) {
                FreePathStringA (resultA);
                resultA = NULL;
            }
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataW (&moduleImage);
    }
    return result;
}

PIMAGE_NT_HEADERS
pGetImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    return NULL;
}

ULONG
MdGetPECheckSumA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    ULONG result = 0;
    PIMAGE_NT_HEADERS NtHeaders;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN32) {
            __leave;
        }
        __try {
            NtHeaders = pGetImageNtHeader(moduleImage.ModuleData.W32Data.Image.MappedAddress);
            if (NtHeaders) {
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
                } else
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
                }
            }
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            result = 0;
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

DWORD
MdGetCheckSumA (
    IN      PCSTR ModuleName
    )
/*++

Routine Description:

  GetCheckSum will compute the check sum for 4096 bytes starting at offset 512. The offset and the size of
  the chunk are modified if the file size is too small.

Arguments:

  ModuleName - Specifies the file to compute the check sum for.

Return value:

  The computed checksum

--*/
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;
    WIN32_FIND_DATAA findData;

    if (!DoesFileExistExA (ModuleName, &findData)) {
        return checkSum;
    }

    if (findData.nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = findData.nFileSizeLow;
    }
    else
    if (startAddr + size > findData.nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = findData.nFileSizeLow - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    __try {
        buffer = HeapAlloc (g_hHeap, 0, size);
        if (buffer == NULL) {
            __leave;
        }
        fileHandle = CreateFileA (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer (fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile (fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr (checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree (g_hHeap, 0, buffer);
        }
    }
    return checkSum;
}

DWORD
MdGetCheckSumW (
    IN      PCWSTR ModuleName
    )
/*++

Routine Description:

  GetCheckSum will compute the check sum for 4096 bytes starting at offset 512. The offset and the size of
  the chunk are modified if the file size is too small.

Arguments:

  ModuleName - Specifies the file to compute the check sum for.

Return value:

  The computed checksum

--*/
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;
    WIN32_FIND_DATAW findData;

    if (!DoesFileExistExW (ModuleName, &findData)) {
        return checkSum;
    }

    if (findData.nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = findData.nFileSizeLow;
    }
    else
    if (startAddr + size > findData.nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = findData.nFileSizeLow - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    __try {
        buffer = HeapAlloc (g_hHeap, 0, size);
        if (buffer == NULL) {
            __leave;
        }
        fileHandle = CreateFileW (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer (fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile (fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr (checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree (g_hHeap, 0, buffer);
        }
    }
    return checkSum;
}

VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    )
{
    if (HIWORD (AnsiId)) {
        FreeConvertedStr (AnsiId);
    }
}


VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    )
{
    if (HIWORD (UnicodeId)) {
        FreeConvertedStr (UnicodeId);
    }
}

BOOL
NeLoadHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    )
{
    DOS_HEADER dh;
    LONG rc = ERROR_BAD_FORMAT;
    BOOL b = FALSE;

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);
        if (!BfReadFile (File, (PBYTE)(&dh), sizeof (DOS_HEADER))) {
            __leave;
        }

        if (dh.e_magic != ('M' + 'Z' * 256)) {
            __leave;
        }

        SetFilePointer (File, dh.e_lfanew, NULL, FILE_BEGIN);
        if (!BfReadFile (File, (PBYTE)Header, sizeof (NE_INFO_BLOCK))) {
            __leave;
        }

        if (Header->Signature != ('N' + 'E' * 256) &&
            Header->Signature != ('L' + 'E' * 256)
            ) {
            if (Header->Signature == ('P' + 'E' * 256)) {
                rc = ERROR_BAD_EXE_FORMAT;
            } else {
                rc = ERROR_INVALID_EXE_SIGNATURE;
            }

            DEBUGMSG ((DBG_NAUSEA, "Header signature is %c%c", Header->Signature & 0xff, Header->Signature >> 8));
            __leave;
        }

        SetFilePointer (File, (DWORD) dh.e_lfanew, NULL, FILE_BEGIN);

        b = TRUE;
    }
    __finally {
        if (!b) {
            SetLastError (rc);
        }
    }

    return b;
}

DWORD
pComputeSizeOfTypeInfo (
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    return sizeof (NE_RES_TYPEINFO) + TypeInfo->ResourceCount * sizeof (NE_RES_NAMEINFO);
}

PNE_RES_TYPEINFO
pReadNextTypeInfoStruct (
    IN      HANDLE File,
    IN      PMHANDLE Pool
    )
{
    WORD Type;
    WORD ResCount;
    NE_RES_TYPEINFO TypeInfo;
    PNE_RES_TYPEINFO ReturnInfo = NULL;
    DWORD Size;

    if (!BfReadFile (File, (PBYTE)(&Type), sizeof (WORD))) {
        return NULL;
    }

    if (!Type) {
        return NULL;
    }

    if (!BfReadFile (File, (PBYTE)(&ResCount), sizeof (WORD))) {
        return NULL;
    }

    TypeInfo.TypeId = Type;
    TypeInfo.ResourceCount = ResCount;

    if (!BfReadFile (File, (PBYTE)(&TypeInfo.Reserved), sizeof (DWORD))) {
        return NULL;
    }

    Size = sizeof (NE_RES_NAMEINFO) * ResCount;

    ReturnInfo  = (PNE_RES_TYPEINFO) PmGetMemory (Pool, Size + sizeof (TypeInfo));
    if (!ReturnInfo) {
        return NULL;
    }

    CopyMemory (ReturnInfo, &TypeInfo, sizeof (TypeInfo));

    if (!BfReadFile (File, (PBYTE) ReturnInfo + sizeof (TypeInfo), Size)) {
        return NULL;
    }

    return ReturnInfo;
}

BOOL
pReadTypeInfoArray (
    IN      HANDLE File,
    IN OUT  PGROWLIST TypeInfoList
    )
{
    PNE_RES_TYPEINFO TypeInfo;
    DWORD Size;
    PMHANDLE TempPool;
    BOOL b = FALSE;

    TempPool = PmCreatePool();
    if (!TempPool) {
        return FALSE;
    }

    __try {

        TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        while (TypeInfo) {
            Size = pComputeSizeOfTypeInfo (TypeInfo);
            if (!GlAppend (TypeInfoList, (PBYTE) TypeInfo, Size)) {
                __leave;
            }

            TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        }

        b = TRUE;
    }
    __finally {

        PmDestroyPool (TempPool);
    }

    return b;
}

BOOL
pReadStringArrayA (
    IN      HANDLE File,
    IN OUT  PGROWLIST GrowList
    )
{
    BYTE Size;
    CHAR Name[256];

    if (!BfReadFile (File, (PBYTE)(&Size), sizeof (BYTE))) {
        return FALSE;
    }

    while (Size) {

        if (!BfReadFile (File, Name, (DWORD) Size)) {
            return FALSE;
        }

        Name[Size] = 0;

        GlAppendStringA (GrowList, Name);

        if (!BfReadFile (File, (PBYTE)(&Size), sizeof (BYTE))) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
NeLoadResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    )
{
    NE_INFO_BLOCK Header;

    ZeroMemory (Resources, sizeof (NE_RESOURCES));

    if (!NeLoadHeader (File, &Header)) {
        return FALSE;
    }

    //
    // Read in NE_RESOURCES struct
    //

    SetFilePointer (File, (DWORD) Header.OffsetToResourceTable, NULL, FILE_CURRENT);

    if (!BfReadFile (File, (PBYTE)(&Resources->AlignShift), sizeof (WORD))) {
        return FALSE;
    }

    // Array of NE_RES_TYPEINFO structs
    if (!pReadTypeInfoArray (File, &Resources->TypeInfoArray)) {
        return FALSE;
    }

    // Resource names
    if (!pReadStringArrayA (File, &Resources->ResourceNames)) {
        return FALSE;
    }

    return TRUE;
}

VOID
NeFreeResources (
    PNE_RESOURCES Resources
    )
{
    GlFree (&Resources->TypeInfoArray);
    GlFree (&Resources->ResourceNames);

    ZeroMemory (Resources, sizeof (NE_RESOURCES));
}

HANDLE
NeOpenFileA (
    PCSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PmCreatePool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileA (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!NeLoadHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PmDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}

HANDLE
NeOpenFileW (
    PCWSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PmCreatePool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileW (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!NeLoadHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PmDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}

VOID
NeCloseFile (
    HANDLE Handle
    )
{
    PNE_HANDLE NeHandle;

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle) {
        return;
    }

    if (NeHandle->File != INVALID_HANDLE_VALUE) {
        CloseHandle (NeHandle->File);
    }

    if (NeHandle->ResourcesLoaded) {
        NeFreeResources (&NeHandle->Resources);
    }

    PmDestroyPool (NeHandle->ResourcePool);

    MemFree (g_hHeap, 0, NeHandle);
}

PCSTR
pConvertUnicodeResourceId (
    IN      PCWSTR ResId
    )
{
    if (HIWORD (ResId)) {
        return ConvertWtoA (ResId);
    }

    return (PCSTR) ResId;
}

PCSTR
pDecodeIdReferenceInString (
    IN      PCSTR ResName
    )
{
    if (HIWORD (ResName) && ResName[0] == '#') {
        return (PCSTR) (ULONG_PTR) atoi (&ResName[1]);
    }

    return ResName;
}

BOOL
pNeLoadResourcesFromHandle (
    IN      PNE_HANDLE NeHandle
    )
{
    if (NeHandle->ResourcesLoaded) {
        return TRUE;
    }

    if (!NeLoadResources (NeHandle->File, &NeHandle->Resources)) {
        return FALSE;
    }

    NeHandle->ResourcesLoaded = TRUE;
    return TRUE;
}

BOOL
pLoadNeResourceName (
    OUT     PSTR ResName,
    IN      HANDLE File,
    IN      DWORD StringOffset
    )
{
    BYTE ResNameSize;

    SetFilePointer (File, StringOffset, NULL, FILE_BEGIN);
    if (!BfReadFile (File, (PBYTE)(&ResNameSize), 1)) {
        return FALSE;
    }

    ResName[ResNameSize] = 0;

    return BfReadFile (File, ResName, ResNameSize);
}

BOOL
pNeEnumResourceTypesEx (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    INT Count;
    INT i;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESTYPEPROCA EnumFunc2 = (ENUMRESTYPEPROCA) EnumFunc;
    ENUMRESTYPEPROCEXW EnumFuncW = (ENUMRESTYPEPROCEXW) EnumFunc;
    ENUMRESTYPEPROCW EnumFunc2W = (ENUMRESTYPEPROCW) EnumFunc;
    PWSTR UnicodeResName = NULL;

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Enumerate all resource types
    //

    Count = GlGetSize (&NeHandle->Resources.TypeInfoArray);
    for (i = 0 ; i < Count ; i++) {
        TypeInfo = (PNE_RES_TYPEINFO) GlGetItem (&NeHandle->Resources.TypeInfoArray, i);

        if (TypeInfo->TypeId & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, (PWSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, (PSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, (PWSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, (PSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + TypeInfo->TypeId;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = (PWSTR) ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeResName, lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, ResName, lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, ResName, lParam)) {
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
NeEnumResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                FALSE           // ANSI enum proc
                );
}

BOOL
NeEnumResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                TRUE            // UNICODE enum proc
                );
}

BOOL
pEnumTypeForNameSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      LONG_PTR lParam,
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    PTYPESEARCHDATAA Data;

    Data = (PTYPESEARCHDATAA) lParam;

    //
    // Compare type
    //

    if (HIWORD (Data->TypeToFind) == 0) {
        if (Type != Data->TypeToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Type) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Type, Data->TypeToFind)) {
            return TRUE;
        }
    }

    //
    // Type found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->Found = TRUE;

    return FALSE;
}

BOOL
pNeEnumResourceNamesEx (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    PNE_RES_NAMEINFO NameInfo;
    TYPESEARCHDATAA Data;
    WORD w;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESNAMEPROCA EnumFunc2 = (ENUMRESNAMEPROCA) EnumFunc;
    ENUMRESNAMEPROCEXW EnumFuncW = (ENUMRESNAMEPROCEXW) EnumFunc;
    ENUMRESNAMEPROCW EnumFunc2W = (ENUMRESNAMEPROCW) EnumFunc;
    PCWSTR UnicodeType = NULL;
    PCWSTR UnicodeResName = NULL;

    Type = pDecodeIdReferenceInString (Type);

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Locate type
    //

    ZeroMemory (&Data, sizeof (Data));

    Data.TypeToFind = Type;

    if (!pNeEnumResourceTypesEx (
            Handle,
            pEnumTypeForNameSearchProcA,
            (ULONG_PTR) &Data,
            TRUE,           // ex functionality
            FALSE           // ANSI enum proc
            )) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    TypeInfo = Data.OutboundTypeInfo;

    if (UnicodeProc) {
        if (HIWORD (Type)) {
            UnicodeType = ConvertAtoW (Type);
        } else {
            UnicodeType = (PCWSTR) Type;
        }
    }

    //
    // Enumerate the resource names
    //

    NameInfo = TypeInfo->NameInfo;

    for (w = 0 ; w < TypeInfo->ResourceCount ; w++) {

        if (NameInfo->Id & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (
                            Handle,
                            UnicodeType,
                            (PWSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam,
                            TypeInfo,
                            NameInfo
                            )) {
                        break;
                    }
                } else {
                    if (!EnumFunc (
                            Handle,
                            Type,
                            (PSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam,
                            TypeInfo,
                            NameInfo
                            )) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (
                            Handle,
                            UnicodeType,
                            (PWSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam
                            )) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (
                            Handle,
                            Type,
                            (PSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam
                            )) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + NameInfo->Id;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, ResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, ResName, lParam)) {
                        break;
                    }
                }
            }

            if (UnicodeProc) {
                FreeConvertedStr (UnicodeResName);
            }
        }

        NameInfo++;
    }

    if (UnicodeProc) {
       DestroyUnicodeResourceId (UnicodeType);
    }

    return TRUE;
}

BOOL
NeEnumResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceNamesEx (
                Handle,
                Type,
                (ENUMRESNAMEPROCEXA) EnumFunc,
                lParam,
                FALSE,      // no ex functionality
                FALSE       // ANSI enum proc
                );
}

BOOL
NeEnumResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    BOOL b;
    PCSTR AnsiType;

    AnsiType = pConvertUnicodeResourceId (Type);

    b = pNeEnumResourceNamesEx (
            Handle,
            AnsiType,
            (ENUMRESNAMEPROCEXA) EnumFunc,
            lParam,
            FALSE,          // no ex functionality
            TRUE            // UNICODE enum proc
            );

    PushError();
    DestroyAnsiResourceId (AnsiType);
    PopError();

    return b;
}

BOOL
pEnumTypeForResSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam,
    IN      PNE_RES_TYPEINFO TypeInfo,
    IN      PNE_RES_NAMEINFO NameInfo
    )
{
    PNAMESEARCHDATAA Data;

    Data = (PNAMESEARCHDATAA) lParam;

    //
    // Compare name
    //

    if (HIWORD (Data->NameToFind) == 0) {
        if (Name != Data->NameToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Name) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Name, Data->NameToFind)) {
            return TRUE;
        }
    }

    //
    // Name found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->OutboundNameInfo = NameInfo;
    Data->Found = TRUE;

    return FALSE;
}

PBYTE
NeFindResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD Offset;
    DWORD Length;
    PNE_RES_NAMEINFO NameInfo;
    PBYTE ReturnData;

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return NULL;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pNeEnumResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    NameInfo = Data.OutboundNameInfo;

    Offset = (DWORD) NameInfo->Offset << (DWORD) NeHandle->Resources.AlignShift;
    Length = (DWORD) NameInfo->Length << (DWORD) NeHandle->Resources.AlignShift;

    ReturnData = PmGetMemory (NeHandle->ResourcePool, Length);
    if (!ReturnData) {
        return NULL;
    }

    SetFilePointer (NeHandle->File, Offset, NULL, FILE_BEGIN);

    if (!BfReadFile (NeHandle->File, ReturnData, Length)) {
        PushError();
        MemFree (g_hHeap, 0, ReturnData);
        PopError();
        return NULL;
    }

    return ReturnData;
}

PBYTE
NeFindResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    PBYTE Resource;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Resource = NeFindResourceExA (
                    Handle,
                    AnsiType,
                    AnsiName
                    );

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Resource;
}

DWORD
NeSizeofResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD result = 0;

    SetLastError (ERROR_SUCCESS);

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return 0;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pNeEnumResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    result = Data.OutboundNameInfo->Length;
    result = result<<4;
    return result;
}

DWORD
NeSizeofResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    DWORD Size;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Size = NeSizeofResourceA (Handle, AnsiType, AnsiName);

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\cache.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    Implements a cache mechanism to speed up OpenRegKeyStr.

Author:

    Jim Schmidt (jimschm)  11-Sep-2000

Revisions:

    <alias>     <date>      <comments>

--*/

#include "pch.h"
#include "regp.h"

#define DBG_REG     "Reg"

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    BYTE KeyString[];
} REGKEYCACHE, *PREGKEYCACHE;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    CHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMA, *PWORKITEMA;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    WCHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMW, *PWORKITEMW;

GROWLIST g_KeyCache = INIT_GROWLIST;
UINT g_MaxCacheCount = 0;
UINT g_CacheAddPos;
CHAR g_LastParent[MAX_REGISTRY_KEY];
UINT g_LastParentBytes;
UINT g_LastParentUse;
WCHAR g_LastParentW[MAX_REGISTRY_KEY];
UINT g_LastParentBytesW;
UINT g_LastParentUseW;

BOOL
pRemoveItemFromCache (
    IN      UINT Item
    );

//
// Implementation
//

VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    )
{
    if (InitialCacheSize > 64) {
        InitialCacheSize = 64;
    }

    g_MaxCacheCount = InitialCacheSize;
    g_CacheAddPos = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


VOID
RegTerminateCache (
    VOID
    )
{
    UINT u;
    UINT count;

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        pRemoveItemFromCache (u);
    }

    GlFree (&g_KeyCache);
    g_MaxCacheCount = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


BOOL
pRemoveItemFromCache (
    IN      UINT Item
    )
{
    PREGKEYCACHE cacheItem;

    cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, Item);

    if (!cacheItem) {
        return TRUE;
    }

    if (cacheItem->RefCount == 0) {

        while (cacheItem->ClosesNeeded) {
            CloseRegKeyWorker (cacheItem->Key);
            cacheItem->ClosesNeeded--;
        }

        return TRUE;

    } else {
        return FALSE;
    }
}


VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (CHAR))) {
        return;
    }

    if (g_LastParentUse && g_LastParentUse < 3 && g_LastParentBytes == byteCount) {

        StringCopyABA (lowerStr, KeyString, StringEnd);
        CharLowerA (lowerStr);

        if (StringMatchA (g_LastParent, lowerStr)) {
            g_LastParentUse++;

            if (g_LastParentUse == 3) {
                //
                // Stimulate the cache
                //
                rootKey = ConvertRootStringToKeyA (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {
#ifdef DEBUG
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheA (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABA (g_LastParent, KeyString, StringEnd);
    CharLowerA (g_LastParent);
    g_LastParentBytes = byteCount;

    g_LastParentUse = 1;
}


HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR KeyEnd,       OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCSTR end;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    count = GlGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyA (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABA (lowerStr, KeyString, KeyEnd);
    }

    CharLowerA (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (!cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchA ((PCSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMA workItem;
    PCSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && !cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                DEBUGMSG ((DBG_REG, "Updating empty-named key %s", KeyString));

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyA (workItem.KeyString, KeyString);
                CharLowerA (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (CHAR);
                GlSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = FALSE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyA (workItem.KeyString, KeyString);
    CharLowerA (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (CHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixA ((PCSTR) lastAddItem->KeyString, (PCSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GlSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}


BOOL
RegDecrementRefCount (
    IN      HKEY Key
    )
{
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    if (!g_MaxCacheCount) {
        return FALSE;
    }

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);
        if (cacheItem->Key == Key) {
            if (cacheItem->RefCount == 0) {

                //
                // The caller is tried to close the key more times than what
                // it was opened.
                //

                if (cacheItem->Unicode) {
                    DEBUGMSGW ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                } else {
                    DEBUGMSGA ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                }
            } else {
                cacheItem->RefCount--;
            }

            //
            // Return TRUE to postpone the close
            //

            return TRUE;
        }
    }

    return FALSE;
}


VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (WCHAR))) {
        return;
    }

    if (g_LastParentUseW && g_LastParentUseW < 3 && g_LastParentBytesW == byteCount) {

        StringCopyABW (lowerStr, KeyString, StringEnd);
        CharLowerW (lowerStr);

        if (StringMatchW (g_LastParentW, lowerStr)) {
            g_LastParentUseW++;

            if (g_LastParentUseW == 3) {
                //
                // Stimulate the cache
                //

                rootKey = ConvertRootStringToKeyW (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {

#ifdef DEBUG
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheW (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABW (g_LastParentW, KeyString, StringEnd);
    CharLowerW (g_LastParentW);
    g_LastParentBytesW = byteCount;

    g_LastParentUseW = 1;
}


HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR KeyEnd,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCWSTR end;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    count = GlGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyW (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABW (lowerStr, KeyString, KeyEnd);
    }

    CharLowerW (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchW ((PCWSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMW workItem;
    PCWSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyW (workItem.KeyString, KeyString);
                CharLowerW (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (WCHAR);
                GlSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = TRUE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyW (workItem.KeyString, KeyString);
    CharLowerW (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (WCHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (!cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixW ((PCWSTR) lastAddItem->KeyString, (PCWSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GlSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\progbar\progbar.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    progbar.c

Abstract:

    Centralizes access to the progress bar and associated messages accross components
    (hwcomp,migapp,etc.) and sides (w9x, nt)

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm     19-Jun-1998     Improved to allow revision of estimates, necessary
                                for NT-side progress bar.

--*/

//
// Includes
//

#include "pch.h"

#define DBG_PROGBAR     "Progbar"

//
// Strings
//

// None

//
// Constants
//

#define TICKSCALE       100

//
// Macros
//

// None

//
// Types
//

typedef struct {
    BOOL    Started;
    BOOL    Completed;
    UINT    InitialGuess;
    UINT    TotalTicks;
    UINT    TicksSoFar;
    UINT    LastTickDisplayed;
} SLICE, *PSLICE;

typedef struct {
    HWND Window;
    HANDLE CancelEvent;
    PCSTR Message;
    DWORD MessageId;
    DWORD Delay;
    BOOL  InUse;
} DELAYTHREADPARAMS, *PDELAYTHREADPARAMS;


#if 0

typedef struct {
    HANDLE CancelEvent;
    DWORD TickCount;
    BOOL  InUse;
} TICKTHREADPARAMS, *PTICKTHREADPARAMS;

#endif

//
// Globals
//

static BOOL g_ProgBarInitialized = FALSE;

static HWND g_ProgressBar;
HWND g_Component;
HWND g_SubComponent;

static PBRANGE g_OrgRange;

HANDLE g_ComponentCancelEvent;
HANDLE g_SubComponentCancelEvent;

static BOOL *g_CancelFlagPtr;
static GROWBUFFER g_SliceArray;
static UINT g_SliceCount;
static UINT g_MaxTickCount;
static UINT g_PaddingTicks;
static UINT g_CurrentTickCount;
static UINT g_CurrentPos;
static UINT g_ReduceFactor;
static BOOL g_Reverse = FALSE;
static OUR_CRITICAL_SECTION g_ProgBarCriticalSection;
static UINT g_CurrentSliceId = (UINT)-1;
static INT g_ProgBarRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
PbInitialize (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    LONG rc;
    CHAR Data[256];
    DWORD Size;
    HKEY Key;

    MYASSERT (g_ProgBarRefs >= 0);

    g_ProgBarRefs++;

    if (g_ProgBarRefs == 1) {

        g_ProgressBar = ProgressBar;
        g_CancelFlagPtr = CancelFlagPtr;

        g_ProgBarInitialized = TRUE;

        SendMessage (ProgressBar, PBM_SETPOS, 0, 0);
        g_CurrentPos = 0;
        SendMessage (ProgressBar, PBM_GETRANGE, 0, (LPARAM) &g_OrgRange);

        //
        // Create cancel events for delayed messages.
        //
        g_ComponentCancelEvent      = CreateEvent (NULL, FALSE, FALSE, NULL);
        g_SubComponentCancelEvent   = CreateEvent (NULL, FALSE, FALSE, NULL);

        if (!g_ComponentCancelEvent || !g_SubComponentCancelEvent) {
            DEBUGMSG ((DBG_ERROR, "ProgressBar: Could not create cancel events."));
        }

        InitializeOurCriticalSection (&g_ProgBarCriticalSection);

        g_Component = Component;
        g_SubComponent = SubComponent;

        DEBUGMSG_IF ((
            Component && !IsWindow (Component),
            DBG_WHOOPS,
            "Progress bar component is not a valid window"
            ));

        DEBUGMSG_IF ((
            SubComponent && !IsWindow (SubComponent),
            DBG_WHOOPS,
            "Progress bar sub component is not a valid window"
            ));

        MYASSERT (!g_SliceCount);
        MYASSERT (!g_SliceArray.Buf);
        MYASSERT (!g_MaxTickCount);
        MYASSERT (!g_PaddingTicks);
        MYASSERT (!g_CurrentTickCount);
        MYASSERT (g_CurrentSliceId == (UINT)-1);

        g_ReduceFactor = 1;

        Key = OpenRegKeyStrA ("HKLM\\inapoi");
        if (Key) {
            Size = 256;
            rc = RegQueryValueExA (Key, "", NULL, NULL, (PBYTE) Data, &Size);
            CloseRegKey (Key);

            if (rc == ERROR_SUCCESS && !lstrcmpiA (Data, "backwards")) {
                g_Reverse = TRUE;
            }
        }
    }
}


VOID
PbTerminate (
    VOID
    )
{
    MYASSERT (g_ProgBarRefs > 0);

    g_ProgBarRefs--;

    if (!g_ProgBarRefs) {
        if (g_ComponentCancelEvent) {
            CloseHandle (g_ComponentCancelEvent);
            g_ComponentCancelEvent = NULL;
        }

        if (g_SubComponentCancelEvent) {
            CloseHandle (g_SubComponentCancelEvent);
            g_SubComponentCancelEvent = NULL;
        }

        DeleteOurCriticalSection (&g_ProgBarCriticalSection);

        GbFree (&g_SliceArray);
        g_SliceCount = 0;
        g_MaxTickCount = 0;
        g_PaddingTicks = 0;
        g_CurrentTickCount = 0;
        g_CurrentSliceId = -1;
        g_Component = NULL;
        g_SubComponent = NULL;

        g_ReduceFactor = 1;

        SendMessage (g_ProgressBar, PBM_SETRANGE32, g_OrgRange.iLow, g_OrgRange.iHigh);

        g_ProgBarInitialized = FALSE;
    }
}


UINT
PbRegisterSlice (
    IN      UINT InitialEstimate
    )
{
    PSLICE Slice;
    UINT SliceId;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return 0;
    }

    SliceId = g_SliceCount;

    Slice = (PSLICE) GbGrow (&g_SliceArray, sizeof (SLICE));
    g_SliceCount++;

    Slice->Started = FALSE;
    Slice->Completed = FALSE;
    Slice->TotalTicks = InitialEstimate * TICKSCALE;
    Slice->InitialGuess = Slice->TotalTicks;
    Slice->TicksSoFar = 0;
    Slice->LastTickDisplayed = 0;

    return SliceId;
}


VOID
PbReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Invalid slice ID %u", SliceId));
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (!g_CurrentTickCount) {
        Slice->TotalTicks = RevisedEstimate;
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Can't revise completed slice"));
        return;
    }

    if (Slice->InitialGuess == 0) {
        return;
    }

    RevisedEstimate *= TICKSCALE;

    MYASSERT (Slice->TicksSoFar * RevisedEstimate >= Slice->TicksSoFar);
    MYASSERT (Slice->LastTickDisplayed * RevisedEstimate >= Slice->LastTickDisplayed);

    Slice->TicksSoFar = (UINT) ((LONGLONG) Slice->TicksSoFar * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->LastTickDisplayed = (UINT) ((LONGLONG) Slice->LastTickDisplayed * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->TotalTicks = RevisedEstimate;
}


VOID
PbBeginSliceProcessing (
    IN      UINT SliceId
    )
{
    PSLICE Slice;
    UINT u;
    UINT TotalTicks;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (!g_ProgressBar) {
        DEBUGMSG ((DBG_WHOOPS, "No progress bar handle"));
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Invalid slice ID %u", SliceId));
        return;
    }

    if (!g_CurrentTickCount) {
        //
        // Initialize the progress bar
        //

        MYASSERT (g_CurrentSliceId == (UINT)-1);

        TotalTicks = 0;
        Slice = (PSLICE) g_SliceArray.Buf;

        for (u = 0 ; u < g_SliceCount ; u++) {
            TotalTicks += Slice->InitialGuess;
            Slice++;
        }

        TotalTicks /= TICKSCALE;
        g_PaddingTicks = TotalTicks * 5 / 100;
        g_MaxTickCount = TotalTicks + 2 * g_PaddingTicks;

        g_ReduceFactor = 1;
        while (g_MaxTickCount > 0xffff) {
            g_ReduceFactor *= 10;
            g_MaxTickCount /= 10;
        }

        SendMessage (g_ProgressBar, PBM_SETRANGE, 0, MAKELPARAM (0, g_MaxTickCount));
        SendMessage (g_ProgressBar, PBM_SETSTEP, 1, 0);

        if (g_Reverse) {
            SendMessage (
                g_ProgressBar,
                PBM_SETPOS,
                g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor),
                0
                );
        } else {
            SendMessage (g_ProgressBar, PBM_SETPOS, g_PaddingTicks / g_ReduceFactor, 0);
        }

        g_CurrentTickCount = g_PaddingTicks;
        g_CurrentPos = g_PaddingTicks;

    } else if (SliceId <= g_CurrentSliceId) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Slice ID %u processed already", SliceId));
        return;
    }


    g_CurrentSliceId = SliceId;
    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    Slice->Started = TRUE;
}


VOID
pIncrementBarIfNecessary (
    IN OUT  PSLICE Slice
    )
{
    UINT Increment;
    UINT Pos;

    if (Slice->TicksSoFar >= Slice->TotalTicks) {
        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;
    }

    if (Slice->TicksSoFar - Slice->LastTickDisplayed >= TICKSCALE) {
        Increment = (Slice->TicksSoFar - Slice->LastTickDisplayed) / TICKSCALE;
        Slice->LastTickDisplayed += Increment * TICKSCALE;

        Pos = ((g_CurrentPos + Slice->TicksSoFar) / TICKSCALE);

        Pos += g_PaddingTicks;
        Pos /= g_ReduceFactor;

        if (Pos > g_MaxTickCount) {
            Pos = g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor);
        }

        if (g_Reverse) {

            SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount - Pos, 0);

        } else {

            SendMessage (g_ProgressBar, PBM_SETPOS, Pos, 0);
        }
    }
}


VOID
static
pTickProgressBar (
    IN      UINT Ticks
    )
{
    PSLICE Slice;
    LONGLONG x;

    if (!Ticks || g_CurrentSliceId == (UINT)-1 || g_CurrentSliceId >= g_SliceCount) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Slice ID %u already completed", g_CurrentSliceId));
        return;
    }

    MYASSERT (Ticks * TICKSCALE > Ticks);
    x = ((LONGLONG) Ticks * TICKSCALE * (LONGLONG) Slice->TotalTicks) / (LONGLONG) Slice->InitialGuess;
    MYASSERT (x + (LONGLONG) Slice->TicksSoFar < 0x100000000);

    Slice->TicksSoFar += (UINT) x;

    pIncrementBarIfNecessary (Slice);

}


BOOL
PbTickDelta (
    IN      UINT TickCount
    )
{
    BOOL    rSuccess = TRUE;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    if (g_CancelFlagPtr && *g_CancelFlagPtr) {
        SetLastError (ERROR_CANCELLED);
        rSuccess = FALSE;
    } else {
        pTickProgressBar (TickCount);
    }

    return rSuccess;
}


BOOL
PbTick (
    VOID
    )
{
    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return PbTickDelta (1);
}


VOID
PbGetSliceInfo (
    IN      UINT SliceId,
    OUT     PBOOL SliceStarted,     OPTIONAL
    OUT     PBOOL SliceFinished,    OPTIONAL
    OUT     PUINT TicksCompleted,   OPTIONAL
    OUT     PUINT TotalTicks        OPTIONAL
    )
{
    PSLICE Slice;

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (SliceStarted) {
        *SliceStarted = Slice->Started;
    }

    if (SliceFinished) {
        *SliceFinished = Slice->Completed;
    }

    if (TicksCompleted) {
        *TicksCompleted = Slice->TicksSoFar / TICKSCALE;
    }

    if (TotalTicks) {
        *TotalTicks = Slice->TotalTicks / TICKSCALE;
    }
}

VOID
PbEndSliceProcessing (
    VOID
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        Slice->Completed = TRUE;
        return;
    }

    if (!Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Progress bar slice %u was not completed.", g_CurrentSliceId));

        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;

        pIncrementBarIfNecessary (Slice);
    }

    g_CurrentPos += Slice->TotalTicks;

    if (g_CurrentSliceId == g_SliceCount - 1) {
        //
        // End of progress bar
        //

        SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount, 0);
    }
}


BOOL
pCheckProgressBarState (
    IN HANDLE CancelEvent
    )
{

    SetEvent(CancelEvent);

    return (!g_CancelFlagPtr || !*g_CancelFlagPtr);
}


BOOL
PbSetWindowStringA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,        OPTIONAL
    IN      DWORD MessageId       OPTIONAL
    )
{
    BOOL rSuccess = TRUE;
    PCSTR string = NULL;

    EnterOurCriticalSection (&g_ProgBarCriticalSection);

    if (g_ProgBarInitialized) {

        if (pCheckProgressBarState(CancelEvent)) {

            if (Message) {

                //
                // We have a normal message string.
                //

                if (!SetWindowTextA(Window, Message)) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
            else if (MessageId) {

                //
                // We have a message ID. Convert it and set it.
                //
                string = GetStringResourceA(MessageId);

                if (string) {

                    if (!SetWindowTextA(Window, string)) {
                        rSuccess = FALSE;
                        DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                    }

                    FreeStringResourceA(string);
                }
                ELSE_DEBUGMSG((DBG_ERROR,"ProgressBar: Error with GetStringResource"));

            }
            else {

                //
                // Just clear the text.
                //

                if (!SetWindowTextA(Window, "")) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
        }
        else {
            //
            // We are in a canceled state.
            //
            rSuccess = FALSE;
            SetLastError (ERROR_CANCELLED);
        }
    }

    LeaveOurCriticalSection (&g_ProgBarCriticalSection);

    return rSuccess;

}


DWORD
pSetDelayedMessageA (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PDELAYTHREADPARAMS  tParams = (PDELAYTHREADPARAMS) Param;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //
    switch (WaitForSingleObject(tParams -> CancelEvent, tParams -> Delay)) {

    case WAIT_TIMEOUT:
        //
        // We timed out without cancel being signaled. Set the delayed message.
        //
        PbSetWindowStringA (
            tParams->Window,
            tParams->CancelEvent,
            tParams->Message,
            tParams->MessageId
            );

        break;

    case WAIT_OBJECT_0:
    default:
        //
        //  We were canceled (or something strange happened :> Do nothing!
        //
        break;
    }

    //
    // can set a new thread now
    //
    tParams->InUse = FALSE;

    return rc;
}


VOID
PbCancelDelayedMessage (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return;
    }

    SetEvent(CancelEvent);

}


BOOL
PbSetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    )
{
    BOOL                rSuccess = FALSE;
    DWORD               threadId;
    static DELAYTHREADPARAMS   tParams;

    if (!g_ProgBarInitialized || tParams.InUse) {
        return TRUE;
    }

    if (!pCheckProgressBarState(Window)) {


        //
        // Fill in the parameters for this call to create thread.
        //
        tParams.Window       = Window;
        tParams.CancelEvent  = CancelEvent;
        tParams.Message      = Message;
        tParams.MessageId    = MessageId;
        tParams.Delay        = Delay;

        //
        // Spawn off a thread that will set the message.
        //
        rSuccess = NULL != CreateThread (
                            NULL,   // No inheritance.
                            0,      // Normal stack size.
                            pSetDelayedMessageA,
                            &tParams,
                            0,      // Run immediately.
                            &threadId
                            );

        if (rSuccess) {
            tParams.InUse = TRUE;
        }
        ELSE_DEBUGMSG((DBG_ERROR,"Error spawning thread in PbSetDelayedMessageA."));
    }

    return rSuccess;
}

#if 0

DWORD
pTickProgressBarThread (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PTICKTHREADPARAMS   Params = (PTICKTHREADPARAMS)Param;
    BOOL                Continue = TRUE;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //

    do {
        switch (WaitForSingleObject(Params->CancelEvent, Params->TickCount)) {

        case WAIT_TIMEOUT:
            //
            // We timed out without cancel being signaled. Tick the progress bar.
            //
            if (!PbTickDelta (Params->TickCount)) {
                //
                // cancelled
                //
                Continue = FALSE;
            }
            break;

        case WAIT_OBJECT_0:
        default:
            //
            //  We were canceled (or something strange happened :> Do nothing!
            //
            Continue = FALSE;
            break;
        }
    } while (Continue);

    //
    // can set a new thread now
    //
    Params->InUse = FALSE;

    return rc;
}


BOOL
PbCreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    )
{
    BOOL                    rSuccess = FALSE;
    DWORD                   threadId;
    static TICKTHREADPARAMS g_Params;

    if (g_ProgBarInitialized && !g_Params.InUse) {

        if (pCheckProgressBarState(NULL)) {

            //
            // Fill in the parameters for this call to create thread.
            //
            g_Params.CancelEvent = CancelEvent;
            g_Params.TickCount = TickCount;

            //
            // Spawn off a thread that will set the message.
            //
            if (CreateThread (
                    NULL,   // No inheritance.
                    0,      // Normal stack size.
                    pTickProgressBarThread,
                    &g_Params,
                    0,      // Run immediately.
                    &threadId
                    )) {
                rSuccess = TRUE;
                g_Params.InUse = TRUE;
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Error spawning thread in PbCreateTickThread."));
        }
    }

    return rSuccess;
}


BOOL
PbCancelTickThread (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return SetEvent(CancelEvent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\regenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.c

Abstract:

    Implements a set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "reg.h"

//
// Includes
//

// None

#define DBG_REGENUM     "RegEnum"

//
// Strings
//

#define S_REGENUM       "REGENUM"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_RegEnumPool,Size)
#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_RegEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_RegEnumPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
RegEnumInitialize (
    VOID
    )

/*++

Routine Description:

    RegEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_RegEnumPool = PmCreateNamedPool (S_REGENUM);
    return g_RegEnumPool != NULL;
}


VOID
RegEnumTerminate (
    VOID
    )

/*++

Routine Description:

    RegEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    DumpOpenKeys ();
    if (g_RegEnumPool) {
        PmDestroyPool (g_RegEnumPool);
        g_RegEnumPool = NULL;
    }
}

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    )
{
    return TRUE;
}

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    )
{
    return TRUE;
}


INT g_RootEnumIndexTable [] = { 2, 4, 6, 8, -1};

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootA (EnumPtr);
}

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootW (EnumPtr);
}


BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetA (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetW (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

/*++

Routine Description:

    pGetRegEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    RegEnumInfo - Receives the enum info
    EncodedRegPattern - Specifies the encoded pattern (encoded as defined by the
                        ObjectString functions)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ContainersFirst - Specifies TRUE if keys should be returned before any of its
                      values or subkeys; used only if EnumKeyNames is TRUE
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum level of a key that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed
    ReadValueData - Specifies TRUE if data associated with values should also be returned

Return Value:

    TRUE if all params are valid; in this case, RegEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetRegEnumInfoA (
    OUT     PREGENUMINFOA RegEnumInfo,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternA (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetRegEnumInfoA: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                RegEnumInfo->RegPattern->ExactRoot,
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_REGENUM,
            "pGetRegEnumInfoA: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ContainersFirst) {
        RegEnumInfo->Flags |= REIF_CONTAINERS_FIRST;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }
    if (ReadValueData) {
        RegEnumInfo->Flags |= REIF_READ_VALUE_DATA;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


BOOL
pGetRegEnumInfoW (
    OUT     PREGENUMINFOW RegEnumInfo,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternW (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetRegEnumInfoW: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                RegEnumInfo->RegPattern->ExactRoot, //lint !e64
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {    //lint !e64
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_REGENUM,
            "pGetRegEnumInfoW: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ContainersFirst) {
        RegEnumInfo->Flags |= REIF_CONTAINERS_FIRST;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }
    if (ReadValueData) {
        RegEnumInfo->Flags |= REIF_READ_VALUE_DATA;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetRegNodeInfo retrieves information about a key, using its name

Arguments:

    RegNode - Receives information about this key
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if info was successfully read, FALSE otherwise.

--*/

BOOL
pGetRegNodeInfoA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;

    rc = RegQueryInfoKeyA (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            ReadData ? &RegNode->ValueDataSizeMax : NULL,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYA;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (MBCHAR));
        if (ReadData) {
            RegNode->ValueDataSizeMax++;
            RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        }
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}

BOOL
pGetRegNodeInfoW (
    IN OUT  PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;

    rc = RegQueryInfoKeyW (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            ReadData ? &RegNode->ValueDataSizeMax : NULL,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYW;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (WCHAR));
        if (ReadData) {
            RegNode->ValueDataSizeMax++;
            RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        }
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentRegNode returns the current reg node to be enumerated, based on DepthFirst flag

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PREGNODEA
pGetCurrentRegNodeA (
    IN      PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEA)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEA)(gb->Buf + gb->UserIndex);
    }
}

PREGNODEW
pGetCurrentRegNodeW (
    IN      PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEW)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteRegNode frees the resources associated with the current reg node and destroys it

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEA regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeA (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExA (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEA);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}

BOOL
pDeleteRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEW regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeW (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExW (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEW);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    pCreateRegNode creates a new node given a context, a key name or a parent node

Arguments:

    RegEnum - Specifies the context
    KeyName - Specifies the key name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if KeyName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PREGNODEA
pCreateRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      PCSTR KeyName,              OPTIONAL
    IN      PREGNODEA* ParentNode,      OPTIONAL
    IN      PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEA newNode;
    PSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExA (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExA ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {
            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_REGISTRY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEA) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEA));
    if (!newNode) {
        FreeTextExA (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEA)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEA));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyA ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrA (newNode->KeyName);
        if ((RegEnum->RegEnumInfo.RegPattern->Leaf == NULL) &&
            (RegEnum->RegEnumInfo.RegPattern->ExactRoot) &&
            (!WildCharsPatternA (RegEnum->RegEnumInfo.RegPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoA (newNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeA (RegEnum, TRUE);
    }
    return NULL;
}

PREGNODEW
pCreateRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      PCWSTR KeyName,             OPTIONAL
    IN      PREGNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEW newNode;
    PWSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExW (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExW ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {    //lint !e64
            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_REGISTRY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64

            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEW) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEW));
    if (!newNode) {
        FreeTextExW (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEW)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEW));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyW ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrW (newNode->KeyName);
        if ((RegEnum->RegEnumInfo.RegPattern->Leaf == NULL) &&
            (RegEnum->RegEnumInfo.RegPattern->ExactRoot) &&
            (!WildCharsPatternW (RegEnum->RegEnumInfo.RegPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoW (newNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeW (RegEnum, TRUE);
    }
    return NULL;
}


/*++

Routine Description:

    pEnumFirstRegRoot enumerates the first root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PCSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;

    if (root) {

        if (pCreateRegNodeA (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMA));

        if (!EnumFirstRegRootA (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_REGISTRY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {
                    DEBUGMSGA ((DBG_REGENUM, "pEnumFirstRegRootA: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootA (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PCWSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;  //lint !e64

    if (root) {

        if (pCreateRegNodeW (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMW));

        if (!EnumFirstRegRootW (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_REGISTRY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64
                    DEBUGMSGW ((DBG_REGENUM, "pEnumFirstRegRootW: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootW (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumNextRegRoot enumerates the next root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumNextRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootA (RegEnum->RootEnum)) {
        if (pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootW (RegEnum->RootEnum)) {
        if (pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    pEnumNextValue enumerates the next value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if a new value was found; FALSE if not

--*/

BOOL
pEnumNextValueA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;
    DWORD valueNameLength;

    if (RegNode->ValueIndex == 0) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    RegNode->ValueIndex--;

    valueNameLength = RegNode->ValueLengthMax;
    if (ReadData) {
        RegNode->ValueDataSize = RegNode->ValueDataSizeMax;
    }

    rc = RegEnumValueA (
            RegNode->KeyHandle,
            RegNode->ValueIndex,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            ReadData ? RegNode->ValueData : NULL,
            ReadData ? &RegNode->ValueDataSize : NULL
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~RNF_VALUENAME_INVALID;
    if (ReadData) {
        RegNode->Flags &= ~RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}

BOOL
pEnumNextValueW (
    IN OUT  PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;
    DWORD valueNameLength;

    if (RegNode->ValueIndex == 0) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    RegNode->ValueIndex--;

    valueNameLength = RegNode->ValueLengthMax;
    if (ReadData) {
        RegNode->ValueDataSize = RegNode->ValueDataSizeMax;
    }

    rc = RegEnumValueW (
            RegNode->KeyHandle,
            RegNode->ValueIndex,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            ReadData ? RegNode->ValueData : NULL,
            ReadData ? &RegNode->ValueDataSize : NULL
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~RNF_VALUENAME_INVALID;
    if (ReadData) {
        RegNode->Flags &= ~RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstValue enumerates the first value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if a first value was found; FALSE if not

--*/

BOOL
pEnumFirstValueA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    RegNode->ValueIndex = RegNode->ValueCount;
    return pEnumNextValueA (RegNode, ReadData);
}

BOOL
pEnumFirstValueW (
    OUT     PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    RegNode->ValueIndex = RegNode->ValueCount;
    return pEnumNextValueW (RegNode, ReadData);
}


/*++

Routine Description:

    pEnumNextSubKey enumerates the next subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subkey was found; FALSE if not

--*/

BOOL
pEnumNextSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyA (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}

BOOL
pEnumNextSubKeyW (
    IN OUT  PREGNODEW RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyW (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}


/*++

Routine Description:

    pEnumFirstSubKey enumerates the first subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subkey was found; FALSE if not

--*/

BOOL
pEnumFirstSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyA (RegNode);
}

BOOL
pEnumFirstSubKeyW (
    OUT     PREGNODEW RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyW (RegNode);
}


/*++

Routine Description:

    pEnumNextRegObjectInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the keys/values
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    RegEnum - Specifies the current enum context; receives updated info
    CurrentKeyNode - Receives the key node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
pEnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    OUT     PREGNODEA* CurrentKeyNode
    )
{
    PREGNODEA currentNode;
    PREGNODEA newNode;
    PCSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeA (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                BOOL readData = RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA;

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExA (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        readData ? currentNode->ValueData : NULL,
                        readData ? &currentNode->ValueDataSize : NULL
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringA (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (MBCHAR)
                        ) {
                        StringCopyA (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~RNF_VALUENAME_INVALID;
                        if (readData) {
                            currentNode->Flags &= ~RNF_VALUEDATA_INVALID;
                        }
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueA (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueA (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                return TRUE;
            }

            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyA (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyA (currentNode)) {
                newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~RNF_RETURN_KEYS;
                            *CurrentKeyNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (!(RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        //
                        // set additional data before returning
                        //
                        if (currentNode->ValueName) {
                            pFreeMemory (currentNode->ValueName);
                            currentNode->ValueName = NULL;
                            currentNode->Flags |= RNF_VALUENAME_INVALID;
                        }
                        return TRUE;
                    }
                }
            }
            pDeleteRegNodeA (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        return TRUE;
                    }
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    OUT     PREGNODEW* CurrentKeyNode
    )
{
    PREGNODEW currentNode;
    PREGNODEW newNode;
    PCWSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeW (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                BOOL readData = RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA;

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExW (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        readData ? currentNode->ValueData : NULL,
                        readData ? &currentNode->ValueDataSize : NULL
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringW (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (WCHAR)
                        ) {
                        StringCopyW (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~RNF_VALUENAME_INVALID;
                        if (readData) {
                            currentNode->Flags &= ~RNF_VALUEDATA_INVALID;
                        }
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueW (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueW (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                return TRUE;
            }
            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyW (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGW ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyW (currentNode)) {
                newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~RNF_RETURN_KEYS;
                            *CurrentKeyNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (!(RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        //
                        // set additional data before returning
                        //
                        if (currentNode->ValueName) {
                            pFreeMemory (currentNode->ValueName);
                            currentNode->ValueName = NULL;
                            currentNode->Flags |= RNF_VALUENAME_INVALID;
                        }
                        return TRUE;
                    }
                }
            }
            pDeleteRegNodeW (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        return TRUE;
                    }
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    EnumFirstRegObjectInTreeEx enumerates registry keys, and optionally values, that match the
    specified criteria

Arguments:

    RegEnum - Receives the enum context info; this will be used in subsequent calls to
              EnumNextRegObjectInTree
    EncodedRegPattern - Specifies the encoded key pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedValuePattern - Specifies the encoded value pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no values
                          should be returned (only look for keys)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ContainersFirst - Specifies TRUE if keys should be returned before any of its
                      values or subkeys; used only if EnumKeyNames is TRUE
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a key that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed
    ReadValueData - Specifies TRUE if data associated with values should also be returned
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMA));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoA (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ContainersFirst,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions,
            ReadValueData
            )) {    //lint !e613
        AbortRegObjectInTreeEnumA (RegEnum);
        return FALSE;
    }
    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) { //lint !e613
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_REGISTRY, RegEnum->RegEnumInfo.RegPattern)) {    //lint !e613
            DEBUGMSGA ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExA: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortRegObjectInTreeEnumA (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootA (RegEnum)) {
        AbortRegObjectInTreeEnumA (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeA (RegEnum);
}

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMW));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoW (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ContainersFirst,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions,
            ReadValueData
            )) {    //lint !e613
        AbortRegObjectInTreeEnumW (RegEnum);
        return FALSE;
    }
    if (/*lint -e(613)*/RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_REGISTRY, /*lint -e(613)*/RegEnum->RegEnumInfo.RegPattern)) {
            DEBUGMSGW ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExW: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortRegObjectInTreeEnumW (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootW (RegEnum)) {
        AbortRegObjectInTreeEnumW (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeW (RegEnum);
}


/*++

Routine Description:

    EnumNextRegObjectInTree enumerates the next node matching the criteria specified in
    RegEnum; this is filled on the call to EnumFirstRegObjectInTreeEx;

Arguments:

    RegEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PREGNODEA currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeA (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = '\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeA (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = _mbsrchr (RegEnum->Location, '\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = _mbsinc (RegEnum->LastWackPtr);
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueDataSize = 0;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;

                //
                // prepare full path buffer
                //
                StringCopyA (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_REGISTRY, RegEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueDataSize = currentNode->ValueDataSize;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringA (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                }

                MYASSERT (RegEnum->Name);

                if ((RegEnum->RegNameAppendPos + SizeOfStringA (RegEnum->Name) / DWSIZEOF(CHAR))>
                    (RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(CHAR))) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyA (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatA (RegEnum->RegNameAppendPos, "]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternA (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcluded2A (ELT_REGISTRY, NULL, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2A (ELT_REGISTRY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootA (RegEnum);

    } while (success);

    AbortRegObjectInTreeEnumA (RegEnum);

    return FALSE;
}

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PREGNODEW currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeW (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = L'\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeW (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = wcsrchr (RegEnum->Location, L'\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = RegEnum->LastWackPtr + 1;
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueDataSize = 0;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;
                //
                // prepare full path buffer
                //
                StringCopyW (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_REGISTRY, RegEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueDataSize = currentNode->ValueDataSize;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringW (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                }

                MYASSERT (RegEnum->Name);

				{
					UINT size1 = 0;
					UINT size2 = 0;
					INT size3 = 0;

					size1 = (UINT)(RegEnum->RegNameAppendPos + SizeOfStringW (RegEnum->Name) / DWSIZEOF(WCHAR));
					size2 = (UINT)(RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(WCHAR));
					size3 = size2 - size1;
				}

                if ((RegEnum->RegNameAppendPos + SizeOfStringW (RegEnum->Name) / DWSIZEOF(WCHAR))>
                    (RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(WCHAR))) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeW: RegKey %s [%s] was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyW (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatW (RegEnum->RegNameAppendPos, L"]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternW (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcluded2W (ELT_REGISTRY, NULL, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2W (ELT_REGISTRY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootW (RegEnum);

    } while (success);

    AbortRegObjectInTreeEnumW (RegEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortRegObjectInTreeEnum aborts the enumeration, freeing all resources allocated

Arguments:

    RegEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortRegObjectInTreeEnumA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    while (pDeleteRegNodeA (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeA (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternA (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}

VOID
AbortRegObjectInTreeEnumW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    while (pDeleteRegNodeW (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeW (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternW (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\regp.h ===
HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    );

HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
CloseRegKeyWorker (
    IN      HKEY Key
    );

#ifdef DEBUG

VOID
RegTrackTerminate (
    VOID
    );

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#define TRACK_KEYA(handle,keystr) AddKeyReferenceA(handle,keystr,__FILE__,__LINE__)
#define TRACK_KEYW(handle,keystr) AddKeyReferenceW(handle,keystr,__FILE__,__LINE__)

#else

#define TRACK_KEYA(handle,keystr)
#define TRACK_KEYW(handle,keystr)

#endif


//
// Cache apis
//

BOOL
RegEnumInitialize (
    VOID
    );

VOID
RegEnumTerminate (
    VOID
    );

VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    );

HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    );

HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

BOOL
RegDecrementRefCount (
    IN      HKEY Key
    );

VOID
RegIncrementRefCount (
    IN      HKEY Key
    );

extern REGSAM g_OpenSam;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are three groups of APIs in this
    source file: query functions, open and create functions, and registry
    string parsing functions.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    jimschm     18-Sep-2000 Added cache
    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"
#include "regp.h"

#ifdef DEBUG
#undef RegCloseKey
#endif

HKEY g_Root = HKEY_ROOT;
REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;
INT g_RegRefs;

#define DBG_REG     "Reg"

//
// Implementation
//


BOOL
RegInitialize (
    VOID
    )
{
    BOOL b = TRUE;

    MYASSERT (g_RegRefs >= 0);

    g_RegRefs++;

    if (g_RegRefs == 1) {

        RegInitializeCache (0);
        b = RegEnumInitialize ();
    }

    return b;
}


VOID
RegTerminate (
    VOID
    )
{
    MYASSERT (g_RegRefs > 0);

    g_RegRefs--;

    if (!g_RegRefs) {
        RegEnumTerminate ();
        RegTerminateCache ();
    }

#ifdef DEBUG
    RegTrackTerminate();
#endif
}


VOID
SetRegRoot (
    IN      HKEY Root
    )
{
    g_Root = Root;
}

HKEY
GetRegRoot (
    VOID
    )
{
    return g_Root;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheA (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYA (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (RegKey, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGA ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyA (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerA (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheA (RegKey, lastWack);
    }

    return Key;
}


HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCWSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheW (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYW (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (RegKey, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGW ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyW (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerW (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheW (RegKey, lastWack);
    }

    return Key;
}

HKEY
RealOpenRegKeyStrW1 (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStrA (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyA (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyW (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyA (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyA (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyW (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyW (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteEmptyRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
MemFreeWrapper (
    IN      PCVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  FreeRoutine  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }


    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  AllocRoutine - Specifies the allocation routine, called to allocate the return data.

  FreeRoutine - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    switch (MustBeType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        if (Type == REG_SZ) {
            break;
        }
        if (Type == REG_EXPAND_SZ) {
            break;
        }
        return NULL;

    default:
        if (Type == MustBeType) {
            break;
        }
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (WORD));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWORD) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size = 0;

    rc = RegQueryValueExA (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  AllocRoutine  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  FreeRoutine   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyA (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2A (SubKeyHandle, "", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  AllocRoutine - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  FreeRoutine  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrA (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2A (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
pCreateRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExA (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerA (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_CreateSam);

    return result;
}

HKEY
pCreateRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerW (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_CreateSam);

    return result;
}

/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    CHAR RegKey[MAX_REGISTRY_KEYA];
    PCSTR Start;
    PCSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheA (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYA (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (NewKeyName, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyA (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyA (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = _mbschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringA (Start);
        }

        StringCopyABA (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) { //lint !e613
            rc = OurRegOpenKeyExA (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExA (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) { //lint !e613
            Start = _mbsinc (Start);
        }

    } while (*Start);   //lint !e613

    if (Parent) {
        RegAddKeyToCacheA (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheA (NewKeyName, lastWack);
    }

    return Parent;
}


HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_REGISTRY_KEYW];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCWSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheW (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYW (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (NewKeyName, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyW (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = OurRegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    if (Parent) {
        RegAddKeyToCacheW (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheW (NewKeyName, lastWack);
    }

    return Parent;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyExA (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerA (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_OpenSam);

    return result;
}


HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen           OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerW (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_OpenSam);

    return result;
}


LONG
CloseRegKeyWorker (
    IN      HKEY Key
    )
{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "RegCloseKey threw an exception!"));
    }

    MYASSERT (rc == ERROR_SUCCESS);

    return rc;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (RegDecrementRefCount (Key)) {
        //
        // Key is in the cache; don't call CloseRegKeyWorker. This will
        // be done by the cache code.
        //

        return ERROR_SUCCESS;
    }

    return CloseRegKeyWorker (Key);
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    UINT    TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKR",                     L"HKR",                     3, HKEY_ROOT,
    "HKEY_ROOT",               L"HKEY_ROOT",               9, HKEY_ROOT,
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringA (
    IN      PCSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    MBCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (StringIMatchCharCountA (
                RootString,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength
                )) {

            c = _mbsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != '\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = _wcsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    if (RootKey == g_Root) {
        return 1;
    }

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    HKEY Ret;

    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    Ret = g_RegRoots[i - 1].RootKey;
    if (Ret == HKEY_ROOT) {
        Ret = g_Root;
    }

    return Ret;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyA (
    PCSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringA (RegPath, LengthPtr));
}

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCSTR
ConvertKeyToRootStringA (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetA (GetOffsetOfRootKey (RegRoot));
}

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}



/*++

Routine Description:

  CreateEncodedRegistryStringEx is used to create a registry string in the format commonly
  expected by w95upg reg routines. This format is:

    EncodedKey\[EncodedValue]

  Encoding is used to safely represent "special" characters
    (such as MBS chars and certain punctuation marks.)

  The [EncodedValue] part will exist only if Value is non null.

Arguments:

    Key - Contains an unencoded registry key.
    Value - Optionally contains an unencoded registry value.
    Tree - Specifies that the registry key refers to the entire key

Return Value:

    Returns a pointer to the encoded registry string, or NULL if there was an error.

--*/

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    )
{
    PSTR    rEncodedString = NULL;
    DWORD   requiredSize;
    PSTR    end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringA(Key)*6 + (Value ? SizeOfStringA(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringA(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsA(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form. If a value does not exist,
    // then add an '*' to the line.
    //
    if (Value) {

        StringCopyA (AppendWackA (rEncodedString), "[");
        end = GetEndOfStringA (rEncodedString);
        EncodeRuleCharsA(end, Value);
        StringCatA(end, "]");

    } else if (Tree) {
        StringCopyA (AppendWackA (rEncodedString), "*");
    }

    return rEncodedString;
}


PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    )
{
    PWSTR   rEncodedString = NULL;
    DWORD   requiredSize;
    PWSTR   end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringW(Key)*6 + (Value ? SizeOfStringW(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringW(requiredSize);
    if (!rEncodedString) {
        return NULL;
    }

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsW(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form.
    // If a value doesn't exist, add na '*' to the line.
    //
    if (Value) {

        StringCopyW (AppendWackW (rEncodedString), L"[");
        end = GetEndOfStringW (rEncodedString);
        EncodeRuleCharsW(end, Value);
        StringCatW(end, L"]");
    } else if (Tree) {
        StringCopyW (AppendWackW (rEncodedString), L"*");
    }

    return rEncodedString;
}


/*++

Routine Description:

    FreeEncodedRegistryString frees the memory allocated by a call to CreateEncodedRegistryString.

Arguments:

    None.


Return Value:

    None.

--*/
VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    )
{
    FreePathStringA(RegString);
}


VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    )
{
    FreePathStringW(RegString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:

  marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"
#include "regp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = INIT_GROWLIST;
extern INT g_RegRefs;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GlGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    MYASSERT (g_RegRefs > 0);

    Size = sizeof (KEYTRACK) + SizeOfStringA (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopyA (KeyTrack->SubKey, SubKey);

    (VOID)GlAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    MYASSERT (g_RegRefs > 0);

    AnsiSubKey = ConvertWtoA (SubKey);
    AddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GlDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    RegTerminateCache();

    Items = GlGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }

    GlFree (&g_KeyTrackList);
}

VOID
RegTrackTerminate (
    VOID
    )
{
    GlFree (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\version\version.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    version.c

Abstract:

    Implements a set of enumeration routines to access version
    information from a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_VERSION     "VerAPI"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

//
// Macro expansion definition
//

// None

//
// Code
//


/*++

Routine Description:

  VrCreateEnumStructA and VrCreateEnumStructW are called to load a version
  structure from a file and to obtain the fixed version stamp info that is
  language-independent.

  The caller must call VrDestroyEnumStruct after the VrValueEnum is no
  longer needed.

Arguments:

  VrValueEnum - Receives the version stamp info to be used by other
                functions in this module

  FileSpec    - Specifies the file to obtain version information from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    )
{
    //
    // Initialize the structure
    //

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %s does not have version information", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructA (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VrValueEnum->VersionBuffer,
        "\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    )
{
    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructW (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VrValueEnum->VersionBuffer,
        L"\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}


/*++

Routine Description:

  VrDestroyEnumStructA and VrDestroyEnumStructW cleans up all memory
  allocated by the routines in this module.

Arguments:

  VrValueEnum - Specifies the structure to clean up

Return Value:

  none

--*/

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
}

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
}


/*++

Routine Description:

  pVrEnumFirstTranslationA and pVrEnumFirstTranslationW return the translation
  string needed to access the string table of a version stamp.

Arguments:

  VrValueEnum - Specifies the structure that has been initialized
                by VrCreateEnumStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

PCSTR
pVrEnumFirstTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VrValueEnum->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %s has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationA (VrValueEnum);
}

PCWSTR
pVrEnumFirstTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueW (
            VrValueEnum->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %S has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationW (VrValueEnum);
}


/*++

Routine Description:

  pIsDefaultTranslationA and pIsDefaultTranslationW return TRUE
  if the specified translation string is enumerated by default.
  These routines stops multiple enumeration of the same
  translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


/*++

Routine Description:

  pVrEnumNextTranslationA and pVrEnumNextTranslationW continue
  the enumeration of translation strings, needed to access the
  string table in a version stamp.

Arguments:

  VrValueEnum - Specifies the same structure passed to
                pVrEnumFirstTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCopyA (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfA (
                VrValueEnum->TranslationStr,
                "%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]) {

        StringCopyW (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfW (
                VrValueEnum->TranslationStr,
                L"%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}


/*++

Routine Description:

  VrEnumFirstValueA and VrEnumFirstValueW return the first value
  stored in a version stamp for a specific field. If the field
  does not exist, the functions returns NULL.

  An enumeration of VrEnumFirstValue/VrEnumNextValue
  is used to list all localized strings for a field.

Arguments:

  VrValueEnum  - Specifies the structure that was initialized by
                 VrCreateEnumStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    )
{
    PCSTR result = NULL;

    if (!pVrEnumFirstTranslationA (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueA (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueA (VrValueEnum);
    }

    return result;
}

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    )
{
    PCWSTR result = NULL;

    if (!pVrEnumFirstTranslationW (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueW (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueW (VrValueEnum);
    }

    return result;
}


/*++

Routine Description:

  VrEnumNextValueA and VrEnumNextValueW return the next value
  stored in a version stamp for a specific field.

Arguments:

  VrValueEnum - Specifies the same structure passed to VrEnumFirstValue

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PCSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationA (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueA (VrValueEnum);

    } while (!result);

    return result;
}

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PCWSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationW (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueW (VrValueEnum);

    } while (!result);

    return result;
}


/*++

Routine Description:

  pVrEnumValueA and pVrEnumValueW are routines that obtain
  the value of a version field. They are used for both
  VrEnumFirstValue and VrEnumNextValue.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PSTR text;
    UINT stringLen;
    PBYTE string;
    PCSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = AllocTextA (
               SizeOfStringA (VrValueEnum->TranslationStr) +
               SizeOfStringA (VrValueEnum->VersionField) +
               16
               );

    if (!text) {
        return NULL;
    }

    wsprintfA (
        text,
        "\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        StringCopyByteCountA (VrValueEnum->StringBuffer, (PCSTR) string, stringLen);

        result = (PCSTR)VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextA (text);
    }

    return result;
}

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PWSTR text;
    UINT stringLen;
    PBYTE string;
    PCWSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = AllocTextW (
               18 +
               CharCountW (VrValueEnum->TranslationStr) +
               CharCountW (VrValueEnum->VersionField)
               );

    if (!text) {
        return NULL;
    }

    wsprintfW (
        text,
        L"\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        CopyMemory (VrValueEnum->StringBuffer, string, stringLen * sizeof (WCHAR));
        VrValueEnum->StringBuffer [stringLen * sizeof (WCHAR)] = 0;
        result = (PWSTR) VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextW (text);
    }

    return result;
}

/*++

Routine Description:

  VrCheckVersionValueA and VrCheckVersionValueW return TRUE
  if the version value name specified has the specified version
  value.

Arguments:

  VrValueEnum  - Specifies the structure being processed

  VersionName  - Specifies the version value name.

  VersionValue - Specifies the version value.

Return value:

  TRUE  - the query was successful
  FALSE - the query failed

--*/

BOOL
VrCheckVersionValueA (
    IN      PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionName,
    IN      PCSTR VersionValue
    )
{
    PCSTR CurrentStr;
    BOOL result = FALSE;

    if ((!VersionName) || (!VersionValue)) {
        return FALSE;
    }

    CurrentStr = VrEnumFirstValueA (VrValueEnum, VersionName);
    while (CurrentStr) {
        CurrentStr = SkipSpaceA (CurrentStr);
        TruncateTrailingSpaceA ((PSTR) CurrentStr);
        if (IsPatternMatchA (VersionValue, CurrentStr)) {
            result = TRUE;
            break;
        }
        CurrentStr = VrEnumNextValueA (VrValueEnum);
    }
    return result;
}

BOOL
VrCheckVersionValueW (
    IN      PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionName,
    IN      PCWSTR VersionValue
    )
{
    PCWSTR CurrentStr;
    BOOL result = FALSE;

    if ((!VersionName) || (!VersionValue)) {
        return FALSE;
    }

    CurrentStr = VrEnumFirstValueW (VrValueEnum, VersionName);
    while (CurrentStr) {
        CurrentStr = SkipSpaceW (CurrentStr);
        TruncateTrailingSpaceW ((PWSTR) CurrentStr);
        if (IsPatternMatchW (VersionValue, CurrentStr)) {
            result = TRUE;
            break;
        }
        CurrentStr = VrEnumNextValueW (VrValueEnum);
    }
    return result;
}

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileVersion returns the FileVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG FileVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwFileVersionMS;
    }
    return result;
}


ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryProductVersion returns the ProductVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG ProductVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwProductVersionMS;
    }
    return result;
}


DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateLo returns the LS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, LS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateLS;
    }
    return 0;
}


DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateHi returns the MS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, MS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateMS;
    }
    return 0;
}


DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryOsVersion returns the FileOS field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileOS field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileOS;
    }
    return 0;
}


DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileType returns the FileType field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileType field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileType;
    }
    return 0;
}


/*++

Routine Description:

  VrCheckFileVersionA and VrCheckFileVersionW look in the file's version
  structure trying to see if a specific name has a specific value.

Arguments:

  FileName     - File to query for version struct.

  NameToCheck  - Name to query in version structure.

  ValueToCheck - Value to query in version structure.

Return value:

  TRUE  - the query was successful
  FALSE - the query failed

--*/

BOOL
VrCheckFileVersionA (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    )
{
    VRVALUE_ENUMA Version;
    PCSTR CurrentStr;
    BOOL result = FALSE;

    MYASSERT (NameToCheck);
    MYASSERT (ValueToCheck);

    if (VrCreateEnumStructA (&Version, FileName)) {
        __try {
            CurrentStr = VrEnumFirstValueA (&Version, NameToCheck);
            while (CurrentStr) {
                CurrentStr = SkipSpaceA (CurrentStr);
                TruncateTrailingSpaceA ((PSTR) CurrentStr);
                if (IsPatternMatchA (ValueToCheck, CurrentStr)) {
                    result = TRUE;
                    __leave;
                }

                CurrentStr = VrEnumNextValueA (&Version);
            }
        }
        __finally {
            VrDestroyEnumStructA (&Version);
        }
    }
    return result;
}

BOOL
VrCheckFileVersionW (
    IN      PCWSTR FileName,
    IN      PCWSTR NameToCheck,
    IN      PCWSTR ValueToCheck
    )
{
    VRVALUE_ENUMW Version;
    PCWSTR CurrentStr;
    BOOL result = FALSE;

    MYASSERT (NameToCheck);
    MYASSERT (ValueToCheck);

    if (VrCreateEnumStructW (&Version, FileName)) {
        __try {
            CurrentStr = VrEnumFirstValueW (&Version, NameToCheck);
            while (CurrentStr) {
                CurrentStr = SkipSpaceW (CurrentStr);
                TruncateTrailingSpaceW ((PWSTR) CurrentStr);
                if (IsPatternMatchW (ValueToCheck, CurrentStr)) {
                    result = TRUE;
                    __leave;
                }

                CurrentStr = VrEnumNextValueW (&Version);
            }
        }
        __finally {
            VrDestroyEnumStructW (&Version);
        }
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\sandbox\sandbox.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sandbox.c

Abstract:

    Utilities to run code in isolated processes (sandbox apis).

Author:

    Jim Schmidt (jimschm)   31-Jan-2000

Revision History:



--*/

//
// Includes
//

#include "pch.h"
#include "utilsp.h"

#define DBG_SANDBOX     "Sandbox"

//
// Strings
//

// None

//
// Constants
//

#define S_SBCLASS       TEXT("SandboxHost")

//
// Macros
//

// None

//
// Types
//

typedef struct {
    BOOL Win32;
    HANDLE Mapping;
    HANDLE Ack;
    UINT Instance;
    TCHAR WindowTitle[64];

} IPCDATA, *PIPCDATA;

typedef struct {
    DWORD   Command;
    DWORD   Result;
    DWORD   TechnicalLogId;
    DWORD   GuiLogId;
    DWORD   DataSize;
    BYTE    Data[];
} MAPDATA, *PMAPDATA;

//
// Globals
//

static PCTSTR g_Mode;
static BOOL g_Sandbox;
static TCHAR g_ExePath16[MAX_TCHAR_PATH] = TEXT("sandbx16.exe");
static TCHAR g_ExePath32[MAX_TCHAR_PATH] = TEXT("sandbx32.exe");

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

LRESULT
CALLBACK
pIpcMessageProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
pCreateExchangeThread (
    IN      UINT Instance
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
SbInitialize (
    IN      BOOL SandboxProcess
    )
{
    WNDCLASS wc;

    //
    // Set the globals
    //

    g_Sandbox = SandboxProcess;
    g_Mode = SandboxProcess ? TEXT("Sandbox") : TEXT("HostProc");
    g_ProcessHandle = NULL;

    //
    // Register the window class for message passing
    //

    ZeroMemory (&wc, sizeof (wc));

    wc.lpfnWndProc = pIpcMessageProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = S_SBCLASS;

    RegisterClass (&wc);

    return TRUE;
}


VOID
pCloseIpcData (
    IN OUT  PIPCDATA IpcData
    )
{
    if (IpcData->Ack) {
        CloseHandle (IpcData->Ack);
    }

    if (IpcData->Mapping) {
        CloseHandle (IpcData->Mapping);
    }

    if (IpcData->ProcessHandle) {
        CloseHandle (IpcData->ProcessHandle);
    }

    if (IpcData->File && IpcData->File != INVALID_HANDLE_VALUE) {
        CloseHandle (IpcData->File);
    }

    if (IpcData->HostProcHwnd) {
        DestroyWindow (ipcData->HostProcHwnd);
    }

    ZeroMemory (IpcData, sizeof (IPCDATA));
}


DWORD
WINAPI
pAckThread (
    PVOID Arg
    )
{
    PIPCDATA ipcData = (PIPCDATA) Arg;
    MSG msg;
    HWND hwnd;

    //
    // Create a message-only hwnd
    //

    hwnd = CreateWindow (
                S_SBCLASS,
                ipcData->WindowTitle,
                WS_POPUP,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInst,
                ipcData->Instance
                );

    if (!hwnd) {
        LOG ((LOG_ERROR, "Failed to create host message window"));
        return 0;
    }

    //
    // Loop until the window is destroyed
    //

    while (GetMessage (&msg, hwnd, 0, 0)) {

        DispatchMessage (&msg);

        if (msg.message == WM_NCDESTROY) {
            break;
        }
    }

    return 1;
}


SBHANDLE
SbCreateSandboxA (
    IN      PCSTR DllPath,
    IN      PCSTR WorkingDir            OPTIONAL
    )
{
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL result = FALSE;
    PIPCDATA ipcData = NULL;
    static UINT instance = 0;
    TCHAR objectName[64];
    TCHAR cmdLine[MAX_TCHAR_PATH * 2];
    BOOL win32;
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL processResult;
    HANDLE objectArray[2];
    UINT u;
    DWORD rc;
    TCHAR tempPath[MAX_TCHAR_PATH];
    TCHAR tempFile[MAX_TCHAR_PATH];

    __try {
        //
        // TODO - need mutex to guard instance variable
        // TODO - need to test instance variable against window title
        // TODO - need to detect dll type
        //

        win32 = TRUE;

        //
        // Allocate an IPCDATA struct, then fill it in
        //

        ipcData = (PIPCDATA) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (IPCDATA));

        ipcData.Win32 = win32;
        ipcData.Instance = instance;

        if (ISNT()) {
            //
            // Create nul DACL for NT
            //

            ZeroMemory (&sa, sizeof (sa));

            psd = (PSECURITY_DESCRIPTOR) MemAlloc (g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION)) {
                __leave;
            }

            if (!SetSecurityDescriptorDacl (psd, TRUE, (PACL) NULL, FALSE)) {
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        //
        // Create the IPC objects: an event and a memory mapped file
        //

        ipcData->Ack = CreateEvent (psa, FALSE, FALSE, NULL);

        wsprintf (objectName, TEXT("Sandbox%u.IpcData"), instance);
        ipcData->Mapping = CreateFileMapping (
                                INVALID_HANDLE_VALUE,
                                psa,
                                PAGE_READWRITE,
                                0,
                                0x10000,
                                objectName
                                );

        if (!ipcData->Ack || !ipcData->Mapping) {
            LOG ((LOG_ERROR, "Can't create IPC objects"));
            __leave;
        }

        //
        // Create the ack window proc thread and have it wait for messages
        //

        wsprintf (ipcData->WindowTitle, TEXT("SandboxHost%u"), instance);

        if (!pCreateExchangeThread()) {
            LOG ((LOG_ERROR, "Can't create ack thread"));
            __leave;
        }

        //
        // Launch the sandbox process
        //

        wsprintfA (
            cmdLine,
            "\"%s\" -i:%u",
            win32 ? g_ExePath32 : g_ExePath16,
            instance
            );

        ZeroMemory (&si, sizeof (si));
        si.cb = sizeof (si);
        si.dwFlags = STARTF_FORCEOFFFEEDBACK;

        processResult = CreateProcessA (
                            NULL,
                            cmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            CREATE_DEFAULT_ERROR_MODE,
                            NULL,
                            WorkingDir,
                            &si,
                            &pi
                            );

        if (!processResult) {
            LOG ((LOG_ERROR, "Cannot start %s", cmdLine));
            __leave;
        }

        CloseHandle (pi.hThread);
        ipcData->ProcessHandle = pi.hProcess;

        //
        // Wait for process to fail or wait for it to send an ack
        //

        objectArray[0] = ipcData->Ack;
        objectArray[1] = pi.hProcess;
        rc = WaitForMultipleObjects (2, objectArray, FALSE, 60000);

        if (rc != WAIT_OBJECT_0) {
            DEBUGMSG ((
                DBG_WARNING,
                "Process %x did not signal 'ready'. Wait timed out. (%s)",
                g_ProcessHandle,
                g_Mode
                ));

            LOG ((LOG_ERROR, "Failed to launch sandbox."));
            __leave;
        }

        //
        // Launch was successful -- sandbox is now waiting for a command
        //

        DEBUGMSG ((DBG_SANDBOX, "Process %s is running (%s)", cmdLine, g_Mode));

        instance++;
        result = TRUE;
    }
    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!result) {
            if (ipcData) {
                pCloseIpcData (ipcData);
                MemFree (g_hHeap, 0, ipcData);
            }
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }

        PopError();
    }

    return result ? (SBHANDLE) ipcData : NULL;
}


VOID
SbDestroySandbox (
    IN      SBHANDLE SandboxHandle
    )
{
    PIPCDATA ipcData = (PIPCDATA) SandboxHandle;
    DWORD rc;
    COPYDATA copyData;

    if (ipcData) {
        //
        // Tell sandbox to close
        //

        if (ipcData->Win32) {
            //
            // Turn off the ready event
            //

            MYASSERT (WAIT_OBJECT_0 == WaitForSingleObject (ipcData->ReadyEvent, 0));

            ResetEvent (ipcData->ReadyEvent);

            //
            // Wait for the sandbox to close, kill it if necessary
            //

            rc = WaitForSingleObject (ipcData->ProcessHandle, 10000);

            if (rc != WAIT_OBJECT_0) {
                TerminateProcess (ipcData->ProcessHandle, 0);
            }

        } else {

            //
            // Send a shutdown message to the sandbox
            //

            ZeroMemory (&copyData, sizeof (copyData));

            copyData.dwData = SB_CLOSE;

            SendMessage (
                ipcData->SandboxHwnd,
                WM_COPYDATA,
                ipcData->HostProcHwnd,
                copyData
                );

            //
            // Wait for the sandbox to close, kill it if necessary
            //

            rc = WaitForSingleObject (ipcData->ProcessHandle, 10000);

            if (rc != WAIT_OBJECT_0) {
                TerminateProcess (ipcData->ProcessHandle, 0);
            }
        }

        //
        // Clean up resources
        //

        pCloseIpcData (ipcData);
        MemFree (g_hHeap, 0, ipcData);
    }
}


LRESULT
CALLBACK
pIpcMessageProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    COPYDATASTRUCT *p;

    switch (uMsg) {

    case WM_COPYDATA:
        p = (COPYDATASTRUCT *) lParam;
        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}


BOOL
pCreateExchangeThread (
    IN      UINT Instance
    )
{
    HANDLE thread;

    thread = StartThread (pAckThread, (PVOID) Instance);

    return thread != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\reg\tree.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Implements routines that do operations on entire trees

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_TREE        "Tree"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
RgRemoveAllValuesInKeyA (
    IN      PCSTR KeyToRemove
    )
{
    REGTREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    HKEY deleteHandle;
    REGSAM prevMode;
    LONG rc;

    pattern = ObsBuildEncodedObjectStringExA (KeyToRemove, "*", FALSE);

    if (EnumFirstRegObjectInTreeExA (
            &e,
            pattern,
            FALSE,      // no key names
            TRUE,       // ignored in this case
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {

        do {

            MYASSERT (!(e.Attributes & REG_ATTRIBUTE_KEY));

            prevMode = SetRegOpenAccessMode (KEY_ALL_ACCESS);
            deleteHandle = OpenRegKeyStrA (e.Location);
            if (deleteHandle) {
                rc = RegDeleteValueA (deleteHandle, e.Name);
                CloseRegKey (deleteHandle);
                SetRegOpenAccessMode (prevMode);
                if (rc != ERROR_SUCCESS && rc != ERROR_FILE_NOT_FOUND) {
                    SetLastError (rc);
                    AbortRegObjectInTreeEnumA (&e);
                    ObsFreeA (pattern);
                    return FALSE;
                }
            } else {
                SetRegOpenAccessMode (prevMode);
                AbortRegObjectInTreeEnumA (&e);
                ObsFreeA (pattern);
                return FALSE;
            }

        } while (EnumNextRegObjectInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
RgRemoveAllValuesInKeyW (
    IN      PCWSTR KeyToRemove
    )
{
    REGTREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    HKEY deleteHandle;
    REGSAM prevMode;
    LONG rc;

    pattern = ObsBuildEncodedObjectStringExW (KeyToRemove, L"*", FALSE);

    if (EnumFirstRegObjectInTreeExW (
            &e,
            pattern,
            FALSE,      // no key names
            TRUE,       // ignored in this case
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {

        do {

            MYASSERT (!(e.Attributes & REG_ATTRIBUTE_KEY));

            prevMode = SetRegOpenAccessMode (KEY_ALL_ACCESS);
            deleteHandle = OpenRegKeyStrW (e.Location);
            if (deleteHandle) {
                rc = RegDeleteValueW (deleteHandle, e.Name);
                CloseRegKey (deleteHandle);
                SetRegOpenAccessMode (prevMode);
                if (rc != ERROR_SUCCESS && rc != ERROR_FILE_NOT_FOUND) {
                    SetLastError (rc);
                    AbortRegObjectInTreeEnumW (&e);
                    ObsFreeW (pattern);
                    return FALSE;
                }
            } else {
                SetRegOpenAccessMode (prevMode);
                AbortRegObjectInTreeEnumW (&e);
                ObsFreeW (pattern);
                return FALSE;
            }

        } while (EnumNextRegObjectInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
pDeleteKeyStrA (
    IN OUT  PSTR *DeleteKey
    )
{
    PSTR p;
    HKEY key;
    LONG rc;

    if (*DeleteKey == NULL) {
        return TRUE;
    }

    p = (PSTR) FindLastWackA (*DeleteKey);
    if (p) {
        *p = 0;
        p++;

        key = OpenRegKeyStrA (*DeleteKey);
        if (key) {

            rc = RegDeleteKeyA (key, p);
            CloseRegKey (key);

        } else {
            rc = GetLastError();
        }

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        rc = ERROR_SUCCESS;
    }

    FreeTextA (*DeleteKey);
    *DeleteKey = NULL;

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


BOOL
pDeleteKeyStrW (
    IN OUT  PWSTR *DeleteKey
    )
{
    PWSTR p;
    HKEY key;
    LONG rc;

    if (*DeleteKey == NULL) {
        return TRUE;
    }

    p = (PWSTR) FindLastWackW (*DeleteKey);
    if (p) {
        *p = 0;
        p++;

        key = OpenRegKeyStrW (*DeleteKey);
        if (key) {

            rc = RegDeleteKeyW (key, p);
            CloseRegKey (key);

        } else {
            rc = GetLastError();
        }

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        rc = ERROR_SUCCESS;
    }

    FreeTextW (*DeleteKey);
    *DeleteKey = NULL;

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


BOOL
RgRemoveKeyA (
    IN      PCSTR KeyToRemove
    )
{
    REGTREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PSTR deleteKey = NULL;
    PSTR encodedKey;

    encodedKey = AllocTextA (ByteCountA (KeyToRemove) * 2 + 2 * sizeof (CHAR));
    ObsEncodeStringA (encodedKey, KeyToRemove);
    StringCatA (encodedKey, "\\*");
    pattern = ObsBuildEncodedObjectStringExA (encodedKey, NULL, FALSE);
    FreeTextA (encodedKey);

    if (EnumFirstRegObjectInTreeExA (
            &e,
            pattern,
            TRUE,       // key names
            FALSE,      // containers last
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {
        do {

            if (!pDeleteKeyStrA (&deleteKey)) {
                result = FALSE;
                break;
            }

            MYASSERT (e.Attributes & REG_ATTRIBUTE_KEY);

            if (!RgRemoveAllValuesInKeyA (e.NativeFullName)) {
                result = FALSE;
                break;
            }

            //
            // The reg enum wrappers hold on to a key handle, which prevents
            // us from deleting the key now. We need to hold on to the key
            // name, then continue on to the next item.  At that time, we can
            // delete the key.
            //

            deleteKey = DuplicateTextA (e.NativeFullName);

        } while (EnumNextRegObjectInTreeA (&e));
    }

    ObsFreeA (pattern);

    if (result) {

        result = pDeleteKeyStrA (&deleteKey);
        result = result && RgRemoveAllValuesInKeyA (KeyToRemove);

        if (result) {
            deleteKey = DuplicateTextA (KeyToRemove);
            result = pDeleteKeyStrA (&deleteKey);
        }

    } else {

        AbortRegObjectInTreeEnumA (&e);

        if (deleteKey) {
            FreeTextA (deleteKey);
            INVALID_POINTER (deleteKey);
        }
    }

    return result;
}


BOOL
RgRemoveKeyW (
    IN      PCWSTR KeyToRemove
    )
{
    REGTREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PWSTR deleteKey = NULL;
    PWSTR encodedKey;

    encodedKey = AllocTextW (ByteCountW (KeyToRemove) * 2 + 2 * sizeof (WCHAR));
    ObsEncodeStringW (encodedKey, KeyToRemove);
    StringCatW (encodedKey, L"\\*");
    pattern = ObsBuildEncodedObjectStringExW (encodedKey, NULL, FALSE);
    FreeTextW (encodedKey);

    if (EnumFirstRegObjectInTreeExW (
            &e,
            pattern,
            TRUE,       // key names
            FALSE,      // containers last
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {
        do {

            if (!pDeleteKeyStrW (&deleteKey)) {
                result = FALSE;
                break;
            }

            MYASSERT (e.Attributes & REG_ATTRIBUTE_KEY);

            if (!RgRemoveAllValuesInKeyW (e.NativeFullName)) {
                result = FALSE;
                break;
            }

            //
            // The reg enum wrappers hold on to a key handle, which prevents
            // us from deleting the key now. We need to hold on to the key
            // name, then continue on to the next item.  At that time, we can
            // delete the key.
            //

            deleteKey = DuplicateTextW (e.NativeFullName);

        } while (EnumNextRegObjectInTreeW (&e));
    }

    ObsFreeW (pattern);

    if (result) {

        result = pDeleteKeyStrW (&deleteKey);
        result = result && RgRemoveAllValuesInKeyW (KeyToRemove);

        if (result) {
            deleteKey = DuplicateTextW (KeyToRemove);
            result = pDeleteKeyStrW (&deleteKey);
        }

    } else {

        AbortRegObjectInTreeEnumW (&e);

        if (deleteKey) {
            FreeTextW (deleteKey);
            INVALID_POINTER (deleteKey);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\common\bothchar.cxx ===
//--------------------------------------------------------------
//
// File:        bothchar
//
// Contents:    Functions that need to be compiled as ascii for
//              scanstate and unicode for loadstate.
//
//---------------------------------------------------------------

#include "bothchar.hxx"


//---------------------------------------------------------------
// Constants

UCHAR       EMPTY_STRING[] = "";

const UCHAR NEWLINE_SET[256] =
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

const DWORD VERBOSE_BIT                 = 0x01;   // used with -v flag
const DWORD DEBUGOUTPUT_BIT             = 0x02;   // used with -v flag
const DWORD VERBOSEREG_BIT              = 0x04;   // used with -v flag

#define LOADSTATE_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Loadstate")

//---------------------------------------------------------------
// Globals.
TCHAR  *DomainName    = NULL;
TCHAR  *UserName      = NULL;
TCHAR  *UserPath      = NULL;

//---------------------------------------------------------------
void CStringList::Add( CStringList *pslMore )
{
    CStringList *b;
    CStringList *c;
    CStringList *d;

    // Do nothing if there is no list.
    if (pslMore == NULL)
        return;

    // Determine some nodes to work with.
    b = pslMore->_pslNext;
    c = pslMore;
    d = _pslNext;

    // Relink the list so head points to b is a list to c points to d is
    // a list back to head.
    _pslNext    = b;
    c->_pslNext = d;
}


//---------------------------------------------------------------
CStringList::CStringList( DWORD dwLen )
{
    _pslNext = this;
    if (dwLen == 0)
    {
        _ptsString = NULL;
        _fHead = TRUE;
    }
    else
    {
        _fHead = FALSE;
        _ptsString = (TCHAR *) malloc( dwLen*sizeof(TCHAR) );
    }
}

//---------------------------------------------------------------
CStringList::~CStringList()
{
    CStringList *pslCurrent = _pslNext;
    CStringList *pslEnd;

    // Non header nodes just free their string.
    if (_ptsString != NULL)
        free( _ptsString );
    
    // Header nodes free the list.
    if (_fHead)
    {
        while (pslCurrent != this)
        {
            pslEnd = pslCurrent->_pslNext;
            delete pslCurrent;
            pslCurrent = pslEnd;
        }
    }
}

//---------------------------------------------------------------
DWORD ParseSectionList( INFCONTEXT *pic,
                        TCHAR **pptsLabel,
                        CStringList **pslList )
{
    DWORD        len;
    BOOL         fSuccess;
    DWORD        dwFields;
    DWORD        i;
    DWORD        dwResult = ERROR_SUCCESS;
    CStringList *pslCurrent;

    // Initialize output
    *pslList = NULL;

    // Query the length of the label name
    fSuccess = SetupGetStringField( pic, 0, NULL, 0, &len );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    // Allocate space
    *pptsLabel = (TCHAR *) malloc( len * sizeof(TCHAR) );    
    LOG_ASSERT_EXPR( *pptsLabel != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );

    // Read the label name
    fSuccess = SetupGetStringField( pic, 0, *pptsLabel, len, NULL );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    // Find out how many fields are on the line.
    dwFields = SetupGetFieldCount( pic );
    LOG_ASSERT_GLE( dwFields != 0, dwResult );

    // Read each field.
    for (i = 1; i <= dwFields; i++)
    {
        // Query the length of the field
        fSuccess = SetupGetStringField( pic, i, NULL, 0, &len );
        LOG_ASSERT_GLE( fSuccess, dwResult );

        // Allocate a new node.
        pslCurrent = new CStringList( len );
        LOG_ASSERT_EXPR( pslCurrent != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY);
        
        LOG_ASSERT_EXPR( pslCurrent->String() != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );

        // Copy the field into the node.
        fSuccess = SetupGetStringField( pic, i, pslCurrent->String(), len, NULL );
        LOG_ASSERT_GLE( fSuccess, dwResult );

        // Link the node in the list.
        if (*pslList == NULL)
            *pslList = pslCurrent;
        else
            (*pslList)->Add( pslCurrent );
    }

cleanup:
    return dwResult;
}

/***************************************************************************

        ParseRegPath

     Read a string field from a line in the rules inf file and parse it
into a root, key, and value.  All components of the reg path are optional.

        root\key [value]

***************************************************************************/

DWORD ParseRegPath( INFCONTEXT *pic,
                    DWORD dwField,
                    TCHAR **pptsRoot,
                    TCHAR **pptsKey,
                    TCHAR **pptsValue )
{
    TCHAR *ptsBuffer = NULL;
    TCHAR *ptsStop;
    TCHAR *ptsStart;
    TCHAR *bracket;
    BOOL   fSuccess;
    DWORD  dwLen    = 0;
    DWORD  dwResult = ERROR_SUCCESS;

    //Null out return values in case of later error.
    *pptsRoot  = NULL;
    *pptsKey   = NULL;
    *pptsValue = NULL;
    
    // Compute the length of the reg path field.
    SetupGetStringField( pic, dwField, NULL, 0, &dwLen );

    // Allocate a buffer.
    ptsBuffer = (TCHAR *) malloc( dwLen*sizeof(TCHAR) );
    LOG_ASSERT_EXPR( ptsBuffer != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );

    // Get the whole reg path.  The function fails if the field is empty.
    fSuccess = SetupGetStringField( pic, dwField, ptsBuffer, dwLen, &dwLen );
    if (!fSuccess)
    {
        free( ptsBuffer );
        return ERROR_SUCCESS;
    }

    // Look for a backslash.
    ptsStop = _tcschr( ptsBuffer, TEXT('\\') );

    // If there wasn't one, there is no root.
    if (ptsStop == NULL)
    {
        *pptsRoot = NULL;
        ptsStart = ptsBuffer;
    }

    // If there was one, copy the root name.
    else
    {
        *pptsRoot = (TCHAR *) malloc( ((ptsStop - ptsBuffer) + 1) *
                                      sizeof(TCHAR) );
    
        LOG_ASSERT_EXPR( *pptsRoot != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );
        _tcsncpy( *pptsRoot, ptsBuffer, ptsStop - ptsBuffer );
        (*pptsRoot)[ptsStop - ptsBuffer] = 0;
        ptsStart = ptsStop + 1;
    }

    // Look for an opening square bracket.
    ptsStop = _tcschr( ptsStart, TEXT('[') );

    // If there wasn't one, copy the rest of the string to the key name.
    if (ptsStop == NULL)
    {
        if (ptsStart[0] == 0)
            *pptsKey = NULL;
        else
        {
            *pptsKey   = (TCHAR *) malloc( (dwLen - (ptsStart - ptsBuffer)) *
                                           sizeof(TCHAR) );
            *pptsValue = NULL;
            LOG_ASSERT_EXPR( *pptsKey != NULL,
                             IDS_NOT_ENOUGH_MEMORY,
                             dwResult,
                             ERROR_NOT_ENOUGH_MEMORY );
            _tcscpy( *pptsKey, ptsStart );
        }
    }

    // Handle an optional key and a value.
    else
    {
        // Back up past any intervening white space.
        bracket = ptsStop + 1;
        while (ptsStop != ptsStart &&
               (ptsStop[0] == TEXT(' ') || ptsStop[0] == TEXT('[')))
            ptsStop -= 1;

        // If there are any characters left, copy them